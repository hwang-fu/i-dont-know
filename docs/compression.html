<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Compression Algorithms</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 35px;
        height: 35px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/compression.png" alt="Logo" class="nav-icon"/></h2>
    <ul style="line-height: 1.8;">
        <li><a href="#compression-intro">Introduction</a></li>
        <li><a href="#compression-lz77">LZ77</a></li>
        <li><a href="#compression-lz78">LZ78</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="compression-intro">Introduction to Compression Algorithms</h3>
<ol>
    <li><b>What Is Compression?</b></li>
    <br/>
    <ul>
        <li>Compression is the process of reducing the size of data by removing redundancy.</li>
        <br/>
        <li>Compression algorithms fall mainly into:
            <ul>
                <li><u>Lossless</u> compression</li>
                <li><u>Lossy</u> compression</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Lossless Compression</b></li>
    <br/>
    <ul>
        <li>Lossless algorithms preserve all data exactly.</li>
        <li>Used for text, source code, executables, database dumps, configuration files, etc.</li>
        <li>Common techniques:
            <ul>
                <li>Dictionary-based compression (e.g., <code>LZ77</code>, <code>LZ78</code>, <code>LZW</code>)</li>
                <li>Entropy coding (<code>Huffman</code>, <code>Arithmetic Coding</code>)</li>
                <li>Context-based models (<code>PPM</code>, <code>bzip2 BWT</code>)</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-text line-numbers">Example formats:
ZIP, GZIP, PNG, FLAC, Zstandard, Brotli
</code></pre>
    <br/><br/>


    <li><b>Lossy Compression</b></li>
    <br/>
    <ul>
        <li>Lossy algorithms remove data that is less noticeable to human senses.</li>
        <li>Used for images, audio, and video.</li>
        <li>Common techniques:
            <ul>
                <li>Transform coding (e.g., <code>DCT</code> in JPEG)</li>
                <li>Frequency-domain reduction (e.g., <code>MP3</code>, <code>AAC</code>)</li>
                <li>Motion compensation + frame prediction (e.g., <code>H.264</code>, <code>H.265</code>)</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-text line-numbers">Example formats:
JPEG, MP3, AAC, WebM, H.264 / H.265, AV1
</code></pre>
    <br/><br/>


    <li><b>Dictionary-Based Algorithms</b></li>
    <br/>
    <ul>
        <li>Basic idea: Replace repeated patterns with references to earlier occurrences.</li>
    </ul>
    <ul>
        <li><code>LZ77</code>: Sliding window + references to earlier substrings.</li>
        <li><code>LZ78</code>: Builds a dictionary of repeated patterns.</li>
        <li><code>LZW</code>: Popular variant used in GIF and old compression tools.</li>
    </ul>
<pre><code class="language-text line-numbers">Example:
"abcabcabc" →
(abc)(3 repeats) →
much smaller representation
</code></pre>
    <br/><br/>


    <li><b>Entropy Coding</b></li>
    <br/>
    <ul>
        <li>Entropy coding assigns shorter bit patterns to more frequent symbols.</li>
        <br/>
        <li><b>Huffman Coding</b>:
            <ul>
                <li>Tree-based coding method</li>
                <li>Guaranteed prefix-free bit patterns</li>
            </ul>
        </li>
        <li><b>Arithmetic Coding</b>:
            <ul>
                <li>Represents whole messages as a fraction</li>
                <li>Achieves better compression than Huffman in many cases</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-text line-numbers">Example:
Frequent 'A' → 0
Less frequent 'Z' → 11011
</code></pre>
    <br/><br/>


    <li><b>Burrows–Wheeler Transform (BWT)</b></li>
    <br/>
    <ul>
        <li>BWT rearranges text so similar characters stay close together.
        This makes the text more compressible with RLE or Huffman.</li>
        <li>Used in <code>bzip2</code> and modern high-compression tools.</li>
        <li>Reversible transform—no data is lost.</li>
    </ul>
    <br/><br/>


    <li><b>Modern High-Performance Algorithms</b></li>
    <br/>
    <ul>
        <li><b>Zstandard (zstd)</b>:
            <ul>
                <li>Very fast</li>
                <li>Excellent compression ratio</li>
                <li>Widely used in Linux, Docker, Facebook systems</li>
            </ul>
        </li>
        <li><b>Brotli</b>:
            <ul>
                <li>Used in web browsers</li>
                <li>Designed for HTTP compression</li>
                <li>Better than gzip for many workloads</li>
            </ul>
        </li>
        <li><b>LZ4</b>:
            <ul>
                <li>Extremely fast</li>
                <li>Great for real-time logging or database compression</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-text line-numbers">Speed vs Ratio:
LZ4 → fastest
Zstandard → balanced
Brotli → best ratio for web
</code></pre>
    <br/><br/>


    <li><b>Applications of Compression</b></li>
    <br/>
    <ul>
        <li>Web assets (CSS, JS, HTML)</li>
        <li>Data transmission (HTTP, gRPC, WebSocket)</li>
        <li>File formats (ZIP, PNG, MP3)</li>
        <li>Databases (PostgreSQL TOAST, RocksDB block compression)</li>
        <li>Backups and archives</li>
        <li>Embedded systems</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Compression Types</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Description</th>
                <th>Examples</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lossless</td>
                <td>Preserves exact data</td>
                <td><code>gzip</code>, <code>PNG</code>, <code>ZIP</code></td>
            </tr>
            <tr>
                <td>Lossy</td>
                <td>Removes perceptually unnecessary data</td>
                <td><code>JPEG</code>, <code>MP3</code>, <code>H.264</code></td>
            </tr>
            <tr>
                <td>Dictionary-based</td>
                <td>Reuses repeated fragments</td>
                <td><code>LZ77</code>, <code>LZW</code></td>
            </tr>
            <tr>
                <td>Entropy coding</td>
                <td>Shorter codes for frequent symbols</td>
                <td><code>Huffman</code>, <code>Arithmetic</code></td>
            </tr>
            <tr>
                <td>Modern fast</td>
                <td>Optimized for speed + ratio</td>
                <td><code>Zstd</code>, <code>LZ4</code>, <code>Brotli</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Compression is essential for performance, storage, networking, and modern computing efficiency.</li>
        <li>Choosing the right algorithm depends on your trade-off: speed vs ratio vs quality.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compression-lz77">LZ77 Compression Algorithm</h3>
<ol>

    <li><b>What Is LZ77?</b></li>
    <ul>
        <br/>
        <li><b>LZ77</b>, invented by <a href="https://en.wikipedia.org/wiki/Abraham_Lempel">Abraham Lempel</a> and <a href="https://en.wikipedia.org/wiki/Jacob_Ziv">Jacob Ziv</a> in 1977, is one of the most important and foundational lossless compression algorithms.</li>
        <br/>
        <li>It is the ancestor of many modern compressors:
            <ul>
                <li>gzip (DEFLATE)</li>
                <li>ZIP files</li>
                <li>PNG images</li>
                <li>LZMA (7zip)</li>
                <li>LZW (GIF)</li>
            </ul>
        </li>
        <br/>
        <li>LZ77 works by replacing repeated text with references to earlier occurrences of the same data.</li>
        <br/>
        <li>It uses the concept of a <code>sliding window</code> over the data stream.</li>
    </ul>
    <br/><br/>


    <li><b>Core Idea: Sliding Window + Lookahead Buffer</b></li>
    <ul>
        <br/>
        <li>LZ77 views the input through two windows:</li>
        <ul>
            <li><code>search buffer</code> which is the previously processed data</li>
            <li><code>lookahead buffer</code> which is the data we are about to encode</li>
        </ul>
        <br/>
        <li>The encoder attempts to match the longest substring in the <code>lookahead buffer</code> that also appears in the <code>search buffer</code>.</li>
    </ul>

    <ul>
        <li>LZ77 represents matches using a triple:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">(offset, length, nextSymbol)
</code></pre>

    <ul>
        <li><code>offset</code>: how far back the match begins</li>
        <li><code>length</code>: how many characters match</li>
        <li><code>nextSymbol</code>: what character follows the matched block</li>
    </ul>

    <br/><br/>


    <li><b>A Minimal Example</b></li>
    <br/>
    <ul>
        <li>Given input:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">A B C A B C A
</code></pre>

    <ul>
        <li><b>1.</b> First characters (A B C) have no prior match → output literal triples:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">(0, 0, A)
(0, 0, B)
(0, 0, C)
</code></pre>

    <ul>
        <li><b>2.</b> Remaining input: A B C A</li>
        <li>The longest match is <code>A B C</code> appearing at offset 3.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">(3, 3, A)
</code></pre>

    <ul>
        <li>This means:
            <ul>
                <li>Go back 3 characters,</li>
                <li>Copy 3 characters,</li>
                <li>Then append <code>A</code>.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Advantages of LZ77</b></li>
    <br/>
    <ul>
        <li>Simple algorithm is easy to implement.</li>
        <li>Effective for text and repetitive data.</li>
        <li>Fast decoding (copying previously seen blocks).</li>
        <li>Forms the basis of many industrial-strength compressors.</li>
    </ul>
    <br/><br/>


    <li><b>Limitations of LZ77</b></li>
    <br/>
    <ul>
        <li>Compression ratio decreases on <u>random data</u> and <u>non-repetitive files</u></li>
        <li>Large window sizes require more memory.</li>
        <li>The simple triple format is sometimes inefficient → improved by formats like <b>LZSS</b>, <b>LZMA</b>, and <b>DEFLATE</b>.</li>
    </ul>
    <br/><br/>


    <li><b>A Micro Implementation Example (Pseudo-code)</b></li>

<pre><code class="language-plaintext line-numbers">for each position i in input:
    best_length = 0
    best_offset = 0

    for each j in search_buffer:
        length = number of characters matching input[j...] and input[i...]

        if length &gt; best_length:
            best_length = length
            best_offset = i - j

    if best_length &gt; 0:
        emit (best_offset, best_length, input[i + best_length])
        advance i by best_length + 1
    else:
        emit (0, 0, input[i])
        advance i by 1
</code></pre>

    <ul>
        <li>This matches the original LZ77 description.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compression-lz78">LZ78 Compression Algorithm</h3>
<ol>

    <li><b>What Is LZ78?</b></li>
    <ul>
        <br/>
        <li><b>LZ78</b> is a dictionary-based compression algorithm invented by <a href="https://en.wikipedia.org/wiki/Abraham_Lempel">Abraham Lempel</a> and <a href="https://en.wikipedia.org/wiki/Jacob_Ziv">Jacob Ziv</a> in 1978.</li>
        <br/>
        <li>It works by building a dictionary of previously seen substrings and replacing repeated substrings with:
            <ul>
                <li>an <code>index</code> (a reference to a dictionary entry), and</li>
                <li>a <code>next character</code>.</li>
            </ul>
        </li>
        <br/>
        <li>Each compressed token has the form:</li>
<pre><code class="language-plaintext line-numbers">(index, nextSymbol)
</code></pre>
        <ul>
            <li><code>index</code> is 0 if no previous substring is matched.</li>
            <li><code>nextSymbol</code> is the character following the matched substring.</li>
        </ul>
        <br/>
        <li>Unlike LZ77, which looks backward into a sliding window, <b>LZ78 grows an explicit dictionary</b> of phrases.</li>
    </ul>
    <br/><br/>



    <li><b>How the Algorithm Works (Intuition)</b></li>
    <br/>
    <ul>
        <li>Start with an empty dictionary.</li>
        <li>Read the input character-by-character, building the <b>longest substring</b> that already exists in the dictionary.</li>
        <li>When the next character causes the substring to <b>not exist</b> in the dictionary:
            <ul>
                <li>emit a token <code>(index, nextSymbol)</code>,</li>
                <li>add the new substring to the dictionary.</li>
            </ul>
        </li>
        <li>Repeat until the input is consumed.</li>
    </ul>
    <br/><br/>



    <li><b>A Step-by-Step Example</b></li>
    <br/>
    <ul>
        <li>Input:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">A B C A B B C C A
</code></pre>

    <ul>
        <li>Dictionary starts empty and will grow like:</li>
    </ul>
<pre><code class="language-plaintext line-numbers">1: "A"
2: "B"
3: "C"
4: "AB"
5: "BC"
6: "CA"
</code></pre>

    <br/>
    <ul><li><b>Compression process:</b></li></ul>
    <br/>

    <table>
        <tr><th>Step</th><th>Matched Substring</th><th>Next Symbol</th><th>Output</th><th>New Dictionary Entry</th></tr>

        <tr>
            <td>1</td>
            <td>"" (none)</td>
            <td>A</td>
            <td>(0, A)</td>
            <td>1: "A"</td>
        </tr>

        <tr>
            <td>2</td>
            <td>""</td>
            <td>B</td>
            <td>(0, B)</td>
            <td>2: "B"</td>
        </tr>

        <tr>
            <td>3</td>
            <td>""</td>
            <td>C</td>
            <td>(0, C)</td>
            <td>3: "C"</td>
        </tr>

        <tr>
            <td>4</td>
            <td>"A"</td>
            <td>B</td>
            <td>(1, B)</td>
            <td>4: "AB"</td>
        </tr>

        <tr>
            <td>5</td>
            <td>"B"</td>
            <td>C</td>
            <td>(2, C)</td>
            <td>5: "BC"</td>
        </tr>

        <tr>
            <td>6</td>
            <td>"C"</td>
            <td>A</td>
            <td>(3, A)</td>
            <td>6: "CA"</td>
        </tr>
    </table>

    <br/>
    <ul>
        <li><b>Final encoded output:</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">(0, A)
(0, B)
(0, C)
(1, B)
(2, C)
(3, A)
</code></pre>
    <ul><li>And the final dictionary consists of 6 entries.</li></ul>

    <br/><br/>



    <li><b>Decoding LZ78</b></li>
    <br/>
    <ul>
        <li>Decoding is straightforward:
            <ul>
                <li>Start with an empty dictionary.</li>
                <li>For each <code>(index, symbol)</code>:
                    <ul>
                        <li>If <code>index = 0</code>, output <code>symbol</code>.</li>
                        <li>Else:
                            <ul>
                                <li>Fetch the dictionary entry at <code>index</code>,</li>
                                <li>output that string + <code>symbol</code>.</li>
                            </ul>
                        </li>
                        <li>Add the output string as a new dictionary entry.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

<pre><code class="language-plaintext line-numbers">Token (1, B)
→ dictionary[1] = "A"
→ output "AB"
→ add "AB" as new dictionary entry
</code></pre>

    <br/><br/>



    <li><b>Key Differences: LZ78 vs LZ77</b></li>
    <br/>
    <ul>
        <li><b>LZ77</b>:
            <ul>
                <li>Uses a <b>sliding window</b> of past characters.</li>
                <li>Matches substrings by <b>offset</b> and <b>length</b>.</li>
                <li>Dictionary is implicit (part of the data window).</li>
            </ul>
        </li>
        <br/>
        <li><b>LZ78</b>:
            <ul>
                <li>Builds an <b>explicit dictionary</b> of substrings.</li>
                <li>Dictionary persists and grows as the input is read.</li>
                <li>Each token is an <b>index</b> + <b>next character</b>.</li>
            </ul>
        </li>
        <br/>
        <li>LZ77 tends to handle long repeated patterns better without huge dictionaries.</li>
        <br/>
        <li>LZ78 provides simpler decoding and is foundational for LZW (used in GIF).</li>
    </ul>
    <br/><br/>



    <li><b>Performance Notes</b></li>
    <br/>
    <ul>
        <li>Compresses well when the input has many repeated substrings.</li>
        <li>Dictionary growth can be memory-intensive.</li>
        <li>Many real-world compressors (like LZW) refined LZ78 by:
            <ul>
                <li>using variable-width codes,</li>
                <li>limiting dictionary size,</li>
                <li>handling dictionary resets.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
