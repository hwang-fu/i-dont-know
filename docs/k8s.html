<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>k8s</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;
        height: 18px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/k8s.jpeg" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ol style="line-height: 1.8;">
        <li><a href="#k8s-key-terminologies">Key Concepts and Terminologies</a></li>
        <li><a href="#k8s-deployment-yaml">How to Write a Kubernetes Deployment YAML?</a></li>
        <li><a href="#k8s-kubectl-intro">Introduction to <code>kubectl</code></a></li>
        <li><a href="#k8s-choosing-managed-provider">Choosing a Managed Provider</a></li>
        <li><a href="#k8s-install-local-cluster">Installing a Local Cluster</a></li>
        <li><a href="#k8s-deploy-first-app">Deploying Your First Application in Kubernetes</a></li>
        <li><a href="#k8s-minikube-first-app">Deploying Your First Real Application in Minikube</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-key-terminologies">Key Concepts & Terminologies in Kubernetes</h3>
<ol>
    <li>Cluster</li>
    <br/>
    <ul>
        <li>A <code>cluster</code> is a group of machines (nodes) managed by Kubernetes.</li>
        <br/>
        <li>It consists of:
            <ul>
                <li><b>Control Plane</b> — the brain</li>
                <li><b>Nodes (Workers)</b> — machines that run applications</li>
            </ul>
        </li>
        <br/>
        <li>Kubernetes ensures the cluster always matches the “desired state” you declare in YAML manifests.</li>
    </ul>
    <br/><br/>


    <li>Node</li>
    <br/>
    <ul>
        <li>A <code>node</code> is a machine (VM or physical) that runs your containers.</li>
        <br/>
        <li>Each node runs:
            <ul>
                <li><b>kubelet</b> — talks to the control plane</li>
                <li><b>container runtime</b> — containerd, CRI-O, etc.</li>
                <li><b>kube-proxy</b> — manages networking rules</li>
            </ul>
        </li>
        <br/>
        <li>Nodes are the worker machines powering workloads.</li>
    </ul>
    <br/><br/>


    <li>Pod</li>
    <br/>
    <ul>
        <li>A <code>pod</code> is the smallest deployable unit in Kubernetes.</li>
        <br/>
        <li>It contains:
            <ul>
                <li>one container</li>
                <li>or multiple tightly-coupled containers</li>
            </ul>
        </li>
        <br/>
        <li>Pods share:
            <ul>
                <li>network namespace</li>
                <li>IP address</li>
                <li>volumes</li>
            </ul>
        </li>
        <br/>
        <li>Pods are ephemeral — they can be destroyed and recreated anytime.</li>
    </ul>
    <br/><br/>


    <li>Deployment</li>
    <br/>
    <ul>
        <li>A <code>Deployment</code> manages stateless applications.</li>
        <br/>
        <li>It defines:
            <ul>
                <li>how many pods should exist</li>
                <li>how pods update (rolling updates)</li>
                <li>how to roll back</li>
            </ul>
        </li>
        <br/>
        <li>Kubernetes ensures the Deployment maintains the correct number of pods at all times.</li>
    </ul>
    <br/><br/>


    <li>ReplicaSet</li>
    <br/>
    <ul>
        <li>A <code>ReplicaSet</code> ensures that the specified number of pod replicas are running.</li>
        <br/>
        <li>Deployments use ReplicaSets internally.</li>
        <br/>
        <li>You rarely interact with ReplicaSets directly.</li>
    </ul>
    <br/><br/>


    <li>Service</li>
    <br/>
    <ul>
        <li>A <code>Service</code> exposes pods to other pods or to the outside world.</li>
        <br/>
        <li>Types of services:
            <ul>
                <li><b>ClusterIP</b> — internal access only</li>
                <li><b>NodePort</b> — exposed on a port on each node</li>
                <li><b>LoadBalancer</b> — cloud provider load balancer</li>
                <li><b>ExternalName</b> — DNS alias</li>
            </ul>
        </li>
        <br/>
        <li>Services provide stable networking even if pods constantly restart.</li>
    </ul>
    <br/><br/>


    <li>Ingress</li>
    <br/>
    <ul>
        <li>An <code>Ingress</code> exposes HTTP/HTTPS routes from outside the cluster to services inside the cluster.</li>
        <br/>
        <li>Example routing features:</li>
        <ul>
            <li>domain routing</li>
            <li>path-based routing</li>
            <li>TLS termination</li>
        </ul>
        <br/>
        <li>Requires an Ingress Controller (e.g., NGINX Ingress Controller).</li>
    </ul>
    <br/><br/>


    <li>ConfigMap</li>
    <br/>
    <ul>
        <li><code>ConfigMaps</code> store non-sensitive configuration data such as:
            <ul>
                <li>environment variables</li>
                <li>application configs</li>
                <li>files</li>
            </ul>
        </li>
        <br/>
        <li>They help avoid hardcoding configuration inside images.</li>
    </ul>
    <br/><br/>


    <li>Secret</li>
    <br/>
    <ul>
        <li><code>Secrets</code> store sensitive data such as:
            <ul>
                <li>passwords</li>
                <li>API keys</li>
                <li>tokens</li>
            </ul>
        </li>
        <br/>
        <li>Unlike ConfigMaps, Secrets are base64-encoded and handled more securely.</li>
    </ul>
    <br/><br/>


    <li>PersistentVolume (PV)</li>
    <br/>
    <ul>
        <li>A <code>PV</code> is storage that exists independently of pods.</li>
        <br/>
        <li>PVs represent actual storage resources:
            <ul>
                <li>local disk</li>
                <li>NFS</li>
                <li>cloud disk (AWS EBS, GCP Persistent Disk)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>PersistentVolumeClaim (PVC)</li>
    <br/>
    <ul>
        <li><code>PVCs</code> are storage requests made by pods.</li>
        <br/>
        <li>A PVC asks:
            <ul>
                <li>“Give me 10GB of storage”</li>
                <li>“Give me ReadWriteOnce access”</li>
            </ul>
        </li>
        <br/>
        <li>Kubernetes binds PVCs to PVs automatically if requirements match.</li>
    </ul>
    <br/><br/>


    <li>StatefulSet</li>
    <br/>
    <ul>
        <li>A <code>StatefulSet</code> manages stateful applications like:
            <ul>
                <li>databases</li>
                <li>message queues</li>
                <li>storage systems</li>
            </ul>
        </li>
        <br/>
        <li>Features:</li>
        <ul>
            <li>stable network identity</li>
            <li>stable persistent storage</li>
            <li>ordered pod startup/shutdown</li>
        </ul>
    </ul>
    <br/><br/>


    <li>DaemonSet</li>
    <br/>
    <ul>
        <li>A <code>DaemonSet</code> ensures that exactly one instance of a pod runs on every node.</li>
        <br/>
        <li>Used for:
            <ul>
                <li>log collectors</li>
                <li>node monitoring (Prometheus Node Exporter)</li>
                <li>storage drivers</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Job</li>
    <br/>
    <ul>
        <li>A <code>Job</code> runs a task to completion one time.</li>
        <br/>
        <li>Example use cases:
            <ul>
                <li>database migrations</li>
                <li>data processing tasks</li>
                <li>one-time scripts</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>CronJob</li>
    <br/>
    <ul>
        <li>A <code>CronJob</code> runs a Job on a time-based schedule.</li>
        <br/>
        <li>Example:</li>
        <ul>
            <li>clean temporary data every hour</li>
            <li>run backups daily</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Labels and Selectors</li>
    <br/>
    <ul>
        <li><code>Labels</code> are key-value metadata attached to objects.</li>
        <br/>
        <li><code>Selectors</code> are queries used to match labels.</li>
        <br/>
        <li>Used for:
            <ul>
                <li>service-to-pod matching</li>
                <li>deployment-to-pod matching</li>
                <li>organizational grouping</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Namespace</li>
    <br/>
    <ul>
        <li>A <code>namespace</code> logically divides cluster resources.</li>
        <br/>
        <li>Common uses:
            <ul>
                <li>separate teams or projects</li>
                <li>isolate environments (dev, staging, prod)</li>
                <li>apply resource quotas</li>
            </ul>
        </li>
        <br/>
        <li>Default namespaces:
            <ul>
                <li><b>default</b></li>
                <li><b>kube-system</b></li>
                <li><b>kube-public</b></li>
                <li><b>kube-node-lease</b></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>The Control Plane (Master Components)</li>
    <br/>
    <ul>
        <li>Core components controlling the cluster:</li>
        <ul>
            <li><b>kube-apiserver</b> — central API interface</li>
            <li><b>etcd</b> — persistent key-value store</li>
            <li><b>kube-scheduler</b> — decides which node to place pods on</li>
            <li><b>kube-controller-manager</b> — manages controllers (jobs, nodes, replicas)</li>
            <li><b>cloud-controller-manager</b> — integrates cloud provider logic</li>
        </ul>
        <br/>
        <li>Users normally interact only with the API server via <code>kubectl</code>.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-deployment-yaml">How to Write a Kubernetes Deployment YAML (Step by Step)</h3>
<ol>

    <li>What Is a Deployment YAML?</li>
    <br/>
    <ul>
        <li>A <b>Deployment</b> in Kubernetes is a higher-level object that:
            <ul>
                <li>manages <b>Pods</b> (your running containers)</li>
                <li>ensures a certain number of replicas (copies) are running</li>
                <li>handles rolling updates and rollbacks</li>
            </ul>
        </li>
        <br/>
        <li>A <code>Deployment</code> is described in a YAML file (often called <code>deployment.yaml</code> or similar).</li>
        <br/>
        <li>You then apply this file with:</li>
<pre><code class="language-bash line-numbers">kubectl apply -f deployment.yaml</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Skeleton of a Deployment</li>
    <br/>
    <ul>
        <li>Every Deployment YAML has 4 main top-level keys:</li>
<pre><code class="language-yaml line-numbers">apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
spec:
  # deployment details go here
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>apiVersion: apps/v1</code> is the API group &amp; version for Deployments (modern standard).</li>
            <li><code>kind: Deployment</code> tells Kubernetes this file defines a Deployment.</li>
            <li><code>metadata:</code> identifies information like name, labels, annotations.</li>
            <li><code>spec:</code> is the desired state (what this Deployment should do).</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 1: Choose a Name and Labels in <code>metadata</code></li>
    <br/>
    <ul>
        <li><code>metadata</code> describes the Deployment object itself, not the Pods.</li>
<pre><code class="language-yaml line-numbers">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  labels:
    app: nginx-app
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>name: nginx-deploy</code> tells how you reference this Deployment via <code>kubectl</code>.</li>
            <li><code>labels:</code> are key-value metadata, often used for grouping and selection.</li>
        </ul>
        <br/>
        <li>Common pattern:
            <ul>
                <li>Deployment label: <code>app: nginx-app</code></li>
                <li>Pods inside will also have <code>app: nginx-app</code> label, so Services can target them.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Step 2: Define Replicas and the Pod Selector in <code>spec</code></li>
    <br/>
    <ul>
        <li>The <code>spec</code> section of a Deployment has two critical parts:
            <ul>
                <br/>
                <li><code>replicas</code> &mdash; how many Pods</li>
                <br/>
                <li><code>selector</code> &mdash; which Pods belong to this Deployment</li>
            </ul>
            <br/>
        </li>
<pre><code class="language-yaml line-numbers">spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-app
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>replicas: 3</code> tells that Deployment maintains 3 identical Pods.</li>
            <li><code>selector.matchLabels</code> tells that Deployment manages all Pods with label <code>app=nginx-app</code>.</li>
        </ul>
        <br/>
        <li>Important rule: The labels defined here must match the labels inside the Pod template (next step).</li>
    </ul>
    <br/><br/>


    <li>Step 3: Define the Pod Template in <code>spec.template</code></li>
    <br/>
    <ul>
        <li><code>spec.template</code> describes the Pod that will be created.</li>
<pre><code class="language-yaml line-numbers">spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-app
  template:
    metadata:
      labels:
        app: nginx-app
    spec:
      containers:
        - name: nginx-container
          image: nginx:1.25
          ports:
            - containerPort: 80
</code></pre>
        <li>Breakdown of <code>template</code>:</li>
        <ul>
            <li><code>template:</code> is the Pod template definition.</li>
            <li><code>template.metadata.labels</code> labels applied to each Pod.</li>
            <li><code>template.spec.containers</code> is a list of containers in the Pod.</li>
        </ul>
        <br/>
        <li>Container details:</li>
        <ul>
            <li><code>name: nginx-container</code> is the internal name for this container.</li>
            <li><code>image: nginx:1.25</code> tells which Docker image to run.</li>
            <li><code>ports.containerPort: 80</code> tells which port the container listens on.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 4: Add Environment Variables with <code>env</code></li>
    <br/>
    <ul>
        <li>You often need to pass configuration to containers via environment variables.</li>
<pre><code class="language-yaml line-numbers">spec:
  template:
    spec:
      containers:
        - name: nginx-container
          image: nginx:1.25
          env:
            - name: NGINX_ENV
              value: "production"
            - name: API_URL
              value: "https://api.example.com"
          ports:
            - containerPort: 80
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>env</code> is a list of <code>name</code> / <code>value</code> pairs.</li>
            <li>These become environment variables inside the container.</li>
        </ul>
        <br/>
        <li>For secrets or ConfigMaps, you’d later replace <code>value</code> with <code>valueFrom</code> (advanced topic).</li>
    </ul>
    <br/><br/>


    <li>Step 5: Set Resource Requests and Limits</li>
    <br/>
    <ul>
        <li>To control CPU and memory usage, use <code>resources</code>:</li>
<pre><code class="language-yaml line-numbers">spec:
  template:
    spec:
      containers:
        - name: nginx-container
          image: nginx:1.25
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>requests</code> tells what the container <b>needs at minimum</b>.</li>
            <li><code>limits</code> tells maximum CPU/memory allowed.</li>
            <li><code>"100m"</code> means 0.1 CPU core (100 millicores).</li>
            <li><code>"128Mi"</code> means 128 mebibytes of memory.</li>
        </ul>
        <br/>
        <li>Good practice: always define at least requests for production workloads.</li>
    </ul>
    <br/><br/>


    <li>Step 6: Add Liveness and Readiness Probes</li>
    <br/>
    <ul>
        <li>Probes let Kubernetes know whether your app is:
            <ul>
                <li><b>alive</b> (liveness)</li>
                <li><b>ready to receive traffic</b> (readiness)</li>
            </ul>
        </li>
<pre><code class="language-yaml line-numbers">spec:
  template:
    spec:
      containers:
        - name: nginx-container
          image: nginx:1.25
          ports:
            - containerPort: 80
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 15
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>livenessProbe</code> &mdash; if it fails repeatedly, Kubernetes restarts the container.</li>
            <li><code>readinessProbe</code> &mdash; if it fails, the Pod is removed from Service load-balancing.</li>
            <li><code>initialDelaySeconds</code> &mdash; wait this long before first check.</li>
            <li><code>periodSeconds</code> &mdash; how often to check.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 7: Set the Update Strategy</li>
    <br/>
    <ul>
        <li>Deployments support rolling updates controlled by <code>strategy</code>:</li>
<pre><code class="language-yaml line-numbers">spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>type: RollingUpdate</code> updates Pods gradually (default).</li>
            <li><code>maxUnavailable: 1</code> means at most 1 Pod can be unavailable during update.</li>
            <li><code>maxSurge: 1</code> means Kubernetes may create 1 extra Pod above desired replicas during update.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 8: Add Annotations (Optional but Useful)</li>
    <br/>
    <ul>
        <li><b>Annotations</b> store extra metadata (not used for selection):</li>
<pre><code class="language-yaml line-numbers">metadata:
  name: nginx-deploy
  labels:
    app: nginx-app
  annotations:
    app.kubernetes.io/owner: "Junzhe"
    app.kubernetes.io/description: "Demo nginx deployment"
</code></pre>
    </ul>
    <br/><br/>


    <li>Step 9: Full Example of a Well-Structured Deployment</li>
    <br/>
    <ul>
        <li>Here is a complete Deployment that combines all core concepts:</li>
<pre><code class="language-yaml line-numbers">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  labels:
    app: nginx-app
  annotations:
    app.kubernetes.io/owner: "Junzhe"
    app.kubernetes.io/description: "Simple Nginx web server"
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  template:
    metadata:
      labels:
        app: nginx-app
    spec:
      containers:
        - name: nginx-container
          image: nginx:1.25
          ports:
            - containerPort: 80
          env:
            - name: NGINX_ENV
              value: "production"
            - name: API_URL
              value: "https://api.example.com"
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 15
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
</code></pre>
        <br/>
        <li>What this Deployment guarantees:</li>
        <ul>
            <li>Exactly <b>3 Pods</b> with Nginx are running (unless you scale).</li>
            <li>Pods have label <code>app=nginx-app</code> so Services can route to them.</li>
            <li>Deployment updates Pods gradually with rolling update rules.</li>
            <li>Resources are constrained and requested properly.</li>
            <li>Health checks ensure traffic only goes to healthy Pods.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 10: Using and Inspecting Your Deployment</li>
    <br/>
    <ul>
        <li>Apply the YAML:</li>
<pre><code class="language-bash line-numbers">kubectl apply -f nginx-deploy.yaml</code></pre>
        <br/>
        <li>See the Deployment:</li>
<pre><code class="language-bash line-numbers">kubectl get deployments</code></pre>
        <br/>
        <li>See the Pods it created:</li>
<pre><code class="language-bash line-numbers">kubectl get pods -l app=nginx-app</code></pre>
        <br/>
        <li>Detailed info:</li>
<pre><code class="language-bash line-numbers">kubectl describe deployment nginx-deploy</code></pre>
        <br/>
        <li>Update the image:</li>
<pre><code class="language-bash line-numbers">kubectl set image deployment/nginx-deploy \
  nginx-container=nginx:1.26
</code></pre>
        <br/>
        <li>Roll back if something goes wrong:</li>
<pre><code class="language-bash line-numbers">kubectl rollout undo deployment nginx-deploy</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-kubectl-intro">Introduction to <code>kubectl</code> (Kubernetes Command-Line Tool)</h3>
<ol>

    <li>What Is <code>kubectl</code>?</li>
    <br/>
    <ul>
        <li><code>kubectl</code> is the <b>official command-line interface</b> used to interact with Kubernetes clusters.</li>
        <br/>
        <li>Under the hood:
            <ul>
                <li><code>kubectl</code> communicates with the Kubernetes API Server</li>
                <li>authentication is based on <code>~/.kube/config</code></li>
                <li>commands produce YAML or JSON outputs</li>
            </ul>
        </li>
        <br/>
        <li><code>kubectl</code> is the <b>primary tool</b> used by developers, DevOps engineers, and SREs.</li>
    </ul>
    <br/><br/>


    <li>Where Does <code>kubectl</code> Connect?</li>
    <br/>
    <ul>
        <li><code>kubectl</code> communicates with the Kubernetes API Server via HTTP(S).</li>
        <br/>
        <li>The connection details are stored in:
<pre><code class="language-plaintext line-numbers">~/.kube/config</code></pre>
        </li>
        <br/>
        <li>This config file defines:
            <ul>
                <li><code>clusters</code> → the API server endpoints</li>
                <li><code>users</code> → authentication credentials</li>
                <li><code>contexts</code> → cluster + namespace + user combinations</li>
            </ul>
        </li>
        <br/>
        <li>List contexts:</li>
<pre><code class="language-bash line-numbers">kubectl config get-contexts</code></pre>
        <br/>
        <li>Switch context:</li>
<pre><code class="language-bash line-numbers">kubectl config use-context minikube</code></pre>
    </ul>
    <br/><br/>


    <li>The Basic Syntax of <code>kubectl</code></li>
    <br/>
    <ul>
        <li>The general structure is:</li>
<pre><code class="language-plaintext line-numbers">kubectl [COMMAND] [TYPE] [NAME] [FLAGS]</code></pre>
        </li>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">kubectl get pods -n kube-system</code></pre>
        <br/>
        <li>Meaning:
            <ul>
                <li><code>get</code> → list resources</li>
                <li><code>pods</code> → resource type</li>
                <li><code>-n kube-system</code> → in this namespace</li>
            </ul>
        </li>
        <br/>
        <li>Command groups:
            <ul>
                <li>View → <code>get</code>, <code>describe</code>, <code>logs</code>, <code>events</code></li>
                <li>Modify → <code>apply</code>, <code>edit</code>, <code>scale</code>, <code>patch</code></li>
                <li>Delete → <code>delete</code></li>
                <li>Debug → <code>exec</code>, <code>port-forward</code>, <code>attach</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Common Resource Types</li>
    <br/>
    <ul>
        <li>Some common Kubernetes objects you will interact with:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Resource Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>pods</code> / <code>po</code></td><td>Individual running containers</td></tr>
                <tr><td><code>deployments</code> / <code>deploy</code></td><td>Manages replicas and updates</td></tr>
                <tr><td><code>services</code> / <code>svc</code></td><td>Networking entry points</td></tr>
                <tr><td><code>nodes</code></td><td>Worker machines</td></tr>
                <tr><td><code>configmaps</code> / <code>cm</code></td><td>Configuration as key-value data</td></tr>
                <tr><td><code>secrets</code></td><td>Base64-encoded sensitive data</td></tr>
                <tr><td><code>ingress</code></td><td>HTTP routing gateway</td></tr>
                <tr><td><code>namespaces</code></td><td>Logical grouping of resources</td></tr>
            </tbody>
        </table>
    </ul>
    <br/><br/>


    <li>Essential Commands Every Developer Uses</li>
    <br/>
    <ul>
        <li>1. View resources:</li>
<pre><code class="language-bash line-numbers">kubectl get pods</code></pre>
<pre><code class="language-bash line-numbers">kubectl get deployments</code></pre>
<pre><code class="language-bash line-numbers">kubectl get services</code></pre>
        <br/>

        <li>2. Describe resources:</li>
<pre><code class="language-bash line-numbers">kubectl describe pod mypod</code></pre>
        <br/>

        <li>3. Get logs from a container:</li>
<pre><code class="language-bash line-numbers">kubectl logs mypod</code></pre>
        <br/>

        <li>4. Execute a command inside a container:</li>
<pre><code class="language-bash line-numbers">kubectl exec -it mypod -- bash</code></pre>
        <br/>

        <li>5. Apply a YAML file:</li>
<pre><code class="language-bash line-numbers">kubectl apply -f deployment.yaml</code></pre>
        <br/>

        <li>6. Delete resources:</li>
<pre><code class="language-bash line-numbers">kubectl delete pod mypod</code></pre>
        <br/>

        <li>7. Port-forward for local testing:</li>
<pre><code class="language-bash line-numbers">kubectl port-forward deployment/myapp 8080:80</code></pre>
    </ul>
    <br/><br/>


    <li>Using <code>-o</code> for Output Formatting</li>
    <br/>
    <ul>
        <li><code>kubectl</code> can output data in multiple formats:</li>
<pre><code class="language-bash line-numbers">kubectl get pods -o wide</code></pre>
<pre><code class="language-bash line-numbers">kubectl get pod mypod -o yaml</code></pre>
<pre><code class="language-bash line-numbers">kubectl get nodes -o json</code></pre>

        <li>Common formats:</li>
        <ul>
            <li><code>-o wide</code> → more details</li>
            <li><code>-o yaml</code> → show full YAML spec</li>
            <li><code>-o json</code> → machine-parsable JSON</li>
            <li><code>-o name</code> → only return resource names</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Editing Resources with <code>kubectl edit</code></li>
    <br/>
    <ul>
        <li>You can modify resources live:</li>
<pre><code class="language-bash line-numbers">kubectl edit deployment nginx-deploy</code></pre>
        <br/>
        <li>This opens the YAML in your system editor (usually <code>vi</code> or <code>nano</code>).</li>
        <br/>
        <li>When saved, Kubernetes applies the change automatically.</li>
    </ul>
    <br/><br/>


    <li>Scaling Applications</li>
    <br/>
    <ul>
        <li>Increase or decrease the number of Pods:</li>
<pre><code class="language-bash line-numbers">kubectl scale deployment nginx-deploy --replicas=5</code></pre>
        <li>Kubernetes will automatically create or remove Pods.</li>
    </ul>
    <br/><br/>


    <li>Rollouts and Rollbacks</li>
    <br/>
    <ul>
        <li>Check rollout status:</li>
<pre><code class="language-bash line-numbers">kubectl rollout status deployment nginx-deploy</code></pre>
        <li>Undo a failed rollout:</li>
<pre><code class="language-bash line-numbers">kubectl rollout undo deployment nginx-deploy</code></pre>
        <li>This is extremely useful when updating images.</li>
    </ul>
    <br/><br/>


    <li>Using Namespaces</li>
    <br/>
    <ul>
        <li>List namespaces:</li>
<pre><code class="language-bash line-numbers">kubectl get namespaces</code></pre>
        <li>Specify a namespace:</li>
<pre><code class="language-bash line-numbers">kubectl get pods -n testing</code></pre>
        <li>Set a default namespace for your context:</li>
<pre><code class="language-bash line-numbers">kubectl config set-context --current --namespace=testing</code></pre>
    </ul>
    <br/><br/>


    <li>Debugging with <code>kubectl</code></li>
    <br/>
    <ul>
        <li>Run an interactive shell inside a container:</li>
<pre><code class="language-bash line-numbers">kubectl exec -it mypod -- bash</code></pre>
        <li>Check events:</li>
<pre><code class="language-bash line-numbers">kubectl get events --sort-by=.metadata.creationTimestamp</code></pre>
        <li>Inspect failing pods:</li>
<pre><code class="language-bash line-numbers">kubectl describe pod mypod</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-choosing-managed-provider">Choosing a Managed Kubernetes Provider</h3>
<ol>

    <li>What Is a Managed Kubernetes Provider?</li>
    <br/>
    <ul>
        <li>A <b>managed Kubernetes provider</b> is a cloud service that runs and maintains the Kubernetes control plane for you.</li>
        <br/>
        <li>This means you do <u>not</u> manage:
            <ul>
                <li>API server</li>
                <li>scheduler</li>
                <li>etcd database</li>
                <li>controller manager</li>
                <li>control-plane nodes</li>
            </ul>
        </li>
        <br/>
        <li>Instead, you only manage:
            <ul>
                <li>worker nodes (or sometimes not even these)</li>
                <li>deployments, services, autoscaling</li>
                <li>network policies</li>
                <li>storage and secrets</li>
            </ul>
        </li>
        <br/>
        <li>Managed Kubernetes is essential for:
            <ul>
                <li>production workloads</li>
                <li>high availability</li>
                <li>enterprise deployments</li>
                <li>teams without deep Kubernetes expertise</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Why Choose a Managed Provider?</li>
    <br/>
    <ul>
        <li>Running Kubernetes manually requires:
            <ul>
                <li>patching control plane</li>
                <li>maintaining etcd backups</li>
                <li>managing API certificates</li>
                <li>configuring HA/replicas for control plane</li>
                <li>debugging cluster internals</li>
            </ul>
        </li>
        <br/>
        <li>A managed provider removes 90% of that work.</li>
    </ul>
    <br/><br/>


    <li>Popular Managed Kubernetes Providers</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Provider</th>
                <th>Service Name</th>
            </tr>
        </thead>
        <tbody>
            <tr><td><b>Amazon AWS</b></td><td>Amazon Elastic Kubernetes Service (EKS)</td></tr>
            <tr><td><b>Google Cloud</b></td><td>Google Kubernetes Engine (GKE)</td></tr>
            <tr><td><b>Microsoft Azure</b></td><td>Azure Kubernetes Service (AKS)</td></tr>
            <tr><td><b>DigitalOcean</b></td><td>DigitalOcean Kubernetes (DOKS)</td></tr>
            <tr><td><b>Linode</b></td><td>Linode Kubernetes Engine (LKE)</td></tr>
            <tr><td><b>Oracle Cloud</b></td><td>Oracle OKE</td></tr>
            <tr><td><b>IBM Cloud</b></td><td>IBM Cloud Kubernetes Service</td></tr>
            <tr><td><b>Vultr</b></td><td>Vultr Kubernetes Engine (VKE)</td></tr>
        </tbody>
    </table>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-install-local-cluster">Installing a Local Kubernetes Cluster</h3>
<ol>

    <li>What Is a Local Kubernetes Cluster?</li>
    <br/>
    <ul>
        <li>A <b>local Kubernetes cluster</b> is a Kubernetes environment that runs entirely on your local machine.</li>
        <br/>
        <li>It allows you to:
            <ul>
                <li>practice Kubernetes without paying for cloud resources</li>
                <li>test deployments locally before pushing to production</li>
                <li>experiment with YAML manifests</li>
                <li>learn core concepts (pods, services, deployments, volumes, etc.)</li>
            </ul>
        </li>
        <br/>
        <li>You do NOT need real cloud nodes. Everything runs as:
            <ul>
                <li>Docker containers, or</li>
                <li>local virtual machines</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Popular Tools for Running Kubernetes Locally</li>
    <br/>
    <ul>
        <li>There are four major options:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Tool</th>
                    <th>Description</th>
                    <th>Best For</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><b>Minikube</b></td>
                    <td>Single-node cluster using VM or Docker</td>
                    <td>Beginners</td>
                </tr>
                <tr>
                    <td><b>Kind</b> (Kubernetes in Docker)</td>
                    <td>Runs cluster entirely inside Docker containers</td>
                    <td>Fast local setups, CI pipelines</td>
                </tr>
                <tr>
                    <td><b>Docker Desktop Kubernetes</b></td>
                    <td>K8s cluster built into Docker Desktop</td>
                    <td>Mac/Windows users</td>
                </tr>
                <tr>
                    <td><b>MicroK8s</b></td>
                    <td>Lightweight single-node K8s from Canonical</td>
                    <td>Linux developers</td>
                </tr>
            </tbody>
        </table>
    </ul>
    <br/><br/>


    <li>Installing Kubernetes Locally Using Minikube</li>
    <br/>
    <ul>
        <li><b>Minikube</b> is the most popular tool.</li>
        <br/>
        <br/>

        <li><b>Step 1: Install Minikube</b>(Check for Your Specific Machine)</li>
        <br/>

        <br/>
        <li><b>Step 2: Start the cluster</b></li>
<pre><code class="language-bash line-numbers">minikube start</code></pre>
        <li>By default:
            <ul>
                <li>1 node cluster</li>
                <li>uses Docker driver if installed</li>
            </ul>
        </li>
        <br/>
        <li>You can choose the VM driver explicitly:</li>
<pre><code class="language-bash line-numbers">minikube start --driver=docker</code></pre>
        <br/>

        <br/>
        <li><b>Step 3: Check the cluster status</b></li>
<pre><code class="language-bash line-numbers">kubectl get nodes</code></pre>
        <br/>

        <br/>
        <li><b>Step 4: Access the Kubernetes Dashboard</b></li>
<pre><code class="language-bash line-numbers">minikube dashboard</code></pre>
        <li>This opens a full graphical K8S dashboard in your browser.</li>
    </ul>
    <br/><br/>


    <li>Installing Kubernetes Locally Using kind (Kubernetes in Docker)</li>
    <br/>
    <ul>
        <li><b>Kind</b> creates clusters inside Docker containers.</li>
        <br/>
        <li>It is extremely fast and widely used in CI pipelines.</li>
        <br/>
        <br/>

        <li><b>Step 1: Install kind</b></li>
        <br/>

        <br/>

        <li><b>Step 2: Create a cluster</b></li>
<pre><code class="language-bash line-numbers">kind create cluster</code></pre>
        <li>This creates:</li>
        <ul>
            <li>a control-plane container</li>
            <li>a worker node container</li>
        </ul>
        <br/>

        <br/>
        <li><b>Step 3: Verify</b></li>
<pre><code class="language-bash line-numbers">kubectl get nodes</code></pre>
        <br/>

        <li><b>Optional: Create a multi-node cluster</b></li>
<pre><code class="language-yaml line-numbers"># kind-cluster.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
  - role: control-plane
  - role: worker
  - role: worker
</code></pre>

<pre><code class="language-bash line-numbers">kind create cluster --config kind-cluster.yaml</code></pre>
    </ul>
    <br/><br/>


    <li>Installing Kubernetes Using Docker Desktop (Mac / Windows)</li>
    <br/>
    <ul>
        <li>If you use <b>Mac</b> or <b>Windows</b>, Docker Desktop includes Kubernetes support.</li>
        <br/>

        <li><b>Step 1: Install Docker Desktop</b></li>
        <li><b>Step 2: Enable Kubernetes</b></li>
        <ul>
            <li>Open Docker Desktop</li>
            <li>Go to: <b>Settings → Kubernetes</b></li>
            <li>Check: <code>Enable Kubernetes</code></li>
            <li>Click <b>Apply & Restart</b></li>
        </ul>
        <br/>
        <li>After a few minutes, check:</li>
<pre><code class="language-bash line-numbers">kubectl get nodes</code></pre>
        <li>You now have a single-node Kubernetes cluster running inside Docker Desktop.</li>
    </ul>
    <br/><br/>


    <li>Testing Your Local Cluster</li>
    <br/>
    <ul>
        <li>After installing any of the above, test with a simple workload:</li>
<pre><code class="language-bash line-numbers">kubectl create deployment hello --image=nginx
kubectl expose deployment hello --port=80 --type=NodePort
kubectl get svc
</code></pre>
        <li>Access application:</li>
        <ul>
            <li>Minikube → <code>minikube service hello</code></li>
            <li>Kind / MicroK8s → use <code>kubectl port-forward</code></li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-deploy-first-app">Deploying Your First Application in Kubernetes</h3>
<ul>
    <li>Step 1: Ensure Your Kubernetes Cluster Is Ready</li>
    <br/>
    <ul>
        <li>You need a running cluster.
            <br/>Examples:
            <ul>
                <li><b>minikube</b> (local development)</li>
                <li><b>Docker Desktop Kubernetes</b></li>
                <li><b>kind</b> (Kubernetes-in-Docker)</li>
            </ul>
        </li>
        <br/>
        <li>Verify cluster status:</li>
<pre><code class="language-bash line-numbers">kubectl get nodes</code></pre>
        <br/>
        <li>You should see at least one node in <code>Ready</code> state.</li>
    </ul>
    <br/><br/>


    <li>Step 2: Create Your First Deployment</li>
    <br/>
    <ul>
        <li>Create a file named <code>nginx-deployment.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-app
  template:
    metadata:
      labels:
        app: nginx-app
    spec:
      containers:
        - name: nginx-container
          image: nginx:latest
          ports:
            - containerPort: 80
</code></pre>
        <br/>
        <li>Explanation:
            <ul>
                <li><code>replicas: 2</code> → run two identical pods</li>
                <li><code>selector</code> → Deployment uses this label to manage pods</li>
                <li><code>template</code> → describes the pod</li>
                <li><code>containerPort: 80</code> → nginx listens on port 80</li>
            </ul>
        </li>
        <br/>
        <li>Apply the manifest:</li>
<pre><code class="language-bash line-numbers">kubectl apply -f nginx-deployment.yaml</code></pre>
    </ul>
    <br/><br/>


    <li>Step 3: Verify Deployment</li>
    <br/>
    <ul>
        <li>Check deployments:</li>
<pre><code class="language-bash line-numbers">kubectl get deployments</code></pre>
        <br/>
        <li>Check pods:</li>
<pre><code class="language-bash line-numbers">kubectl get pods</code></pre>
        <br/>
        <li>You should see two <code>nginx</code> pods running.</li>
        <br/>
        <li>Describe more details:</li>
<pre><code class="language-bash line-numbers">kubectl describe deployment nginx-deploy</code></pre>
    </ul>
    <br/><br/>


    <li>Step 4: Expose Your Application with a Service</li>
    <br/>
    <ul>
        <li>Create <code>nginx-service.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  type: NodePort
  selector:
    app: nginx-app
  ports:
    - port: 80
      targetPort: 80
      nodePort: 32000
</code></pre>
        <br/>
        <li>Explanation:
            <ul>
                <li><code>type: NodePort</code> → expose service on all nodes</li>
                <li><code>selector</code> → connect service to pods</li>
                <li><code>port: 80</code> → service port</li>
                <li><code>targetPort: 80</code> → container port</li>
                <li><code>nodePort: 32000</code> → external port (30000–32767)</li>
            </ul>
        </li>
        <br/>
        <li>Apply the service:</li>
<pre><code class="language-bash line-numbers">kubectl apply -f nginx-service.yaml</code></pre>
    </ul>
    <br/><br/>


    <li>Step 5: Access the Application</li>
    <br/>
    <ul>
        <li>Get your node’s IP:</li>
<pre><code class="language-bash line-numbers">kubectl get nodes -o wide</code></pre>
        <br/>
        <li>Check <code>INTERNAL-IP</code> or <code>EXTERNAL-IP</code>.</li>
        <br/>
        <li>Now visit the app in your browser:
<pre><code class="language-plaintext line-numbers">http://NODE-IP:32000</code></pre>
        </li>
        <br/>
        <li>If you use minikube:
<pre><code class="language-bash line-numbers">minikube service nginx-service</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Step 6: Scaling Your Application</li>
    <br/>
    <ul>
        <li>Kubernetes makes scaling easy:</li>
<pre><code class="language-bash line-numbers">kubectl scale deployment nginx-deploy --replicas=5</code></pre>
        <br/>
        <li>Verify the new pods:</li>
<pre><code class="language-bash line-numbers">kubectl get pods</code></pre>
        <br/>
        <li>Your application now runs with 5 replicas.</li>
    </ul>
    <br/><br/>


    <li>Step 7: Updating Your Application (Rolling Update)</li>
    <br/>
    <ul>
        <li>Update image version:</li>
<pre><code class="language-bash line-numbers">
kubectl set image deployment/nginx-deploy nginx-container=nginx:1.25
</code></pre>
        <br/>
        <li>Kubernetes will:
            <ul>
                <li>start new pods using new image</li>
                <li>stop old pods gradually</li>
            </ul>
        </li>
        <br/>
        <li>Check rollout status:</li>
<pre><code class="language-bash line-numbers">kubectl rollout status deployment nginx-deploy</code></pre>
    </ul>
    <br/><br/>


    <li>Step 8: Rolling Back to Previous Version</li>
    <br/>
    <ul>
        <li>Undo the last update:</li>
<pre><code class="language-bash line-numbers">kubectl rollout undo deployment nginx-deploy</code></pre>
        <br/>
        <li>Kubernetes automatically returns to the last stable version.</li>
    </ul>
    <br/><br/>


    <li>Step 9: Deleting the Application</li>
    <br/>
    <ul>
        <li>Delete service:</li>
<pre><code class="language-bash line-numbers">kubectl delete -f nginx-service.yaml</code></pre>
        <br/>
        <li>Delete deployment:</li>
<pre><code class="language-bash line-numbers">kubectl delete -f nginx-deployment.yaml</code></pre>
        <br/>
        <li>Pods and Service are cleanly removed.</li>
    </ul>
    <br/><br/>
</ul>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="k8s-minikube-first-app">Deploying Your First Real Application in Minikube</h3>
<ol>

    <li>Overview</li>
    <br/>
    <ul>
        <li>After installing Minikube, the next step is deploying a real workload.</li>
        <br/>
        <li>We will now try to deploy a complete real-world application consisting of:
            <ul>
                <li>a backend API (Node.js)</li>
                <li>a frontend (Nginx static site)</li>
                <li>a Kubernetes Service to expose the app</li>
            </ul>
        </li>
        <br/>
        <li>Minikube behaves like a real Kubernetes cluster:
            <ul>
                <li>Pods, Deployments, Services, Ingress all work the same</li>
                <li>Perfect for local development before pushing to cloud</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Project Structure</li>
    <br/>
    <ul>
        <li>Create a workspace:</li>
<pre><code class="language-plaintext line-numbers">myapp/
├── backend/
│   └── Dockerfile
│   └── server.js
├── frontend/
│   └── Dockerfile
│   └── index.html
└── k8s/
    ├── backend-deploy.yaml
    ├── backend-svc.yaml
    ├── frontend-deploy.yaml
    ├── frontend-svc.yaml
    └── ingress.yaml
</code></pre>
        <li>We will deploy <b>backend → service → frontend → ingress</b>.</li>
    </ul>
    <br/><br/>


    <li>Step 1: Write the Backend API</li>
    <br/>
    <ul>
        <li><code>backend/server.js</code>:</li>
<pre><code class="language-javascript line-numbers">const express = require('express');
const app = express();
const PORT = 5000;

app.get('/api/hello', (req, res) =&gt; {
    res.json({ message: "Hello from Minikube Backend!" });
});

app.listen(PORT, () =&gt; console.log("Backend running on port", PORT));
</code></pre>

    <li>Create a simple <code>Dockerfile</code> for backend:</li>
<pre><code class="language-dockerfile line-numbers">FROM node:18
WORKDIR /app
COPY . .
RUN npm install express
CMD ["node", "server.js"]
</code></pre>
    </ul>
    <br/><br/>


    <li>Step 2: Write the Frontend</li>
    <br/>
    <ul>
        <li><code>frontend/index.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;h1&gt;Frontend served in Minikube&lt;/h1&gt;
    &lt;button id="btn"&gt;Call API&lt;/button&gt;
    &lt;pre id="result"&gt;&lt;/pre&gt;
    &lt;script&gt;
        document.getElementById('btn').onclick = async () =&gt; {
            const res = await fetch('/api/hello');
            const data = await res.json();
            document.getElementById('result').innerText = data.message;
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

    <li>Frontend <code>Dockerfile</code>:</li>
<pre><code class="language-dockerfile line-numbers">FROM nginx:latest
COPY . /usr/share/nginx/html/
</code></pre>
    </ul>
    <br/><br/>


    <li>Step 3: Build Docker Images Inside Minikube</li>
    <br/>
    <ul>
        <li>Minikube uses its own Docker daemon.</li>
        <br/>
        <li>Connect your terminal to Minikube's Docker environment:</li>
<pre><code class="language-bash line-numbers">eval $(minikube docker-env)</code></pre>
        <li>Build images:</li>
<pre><code class="language-bash line-numbers">docker build -t my-backend:1.0 ./backend
docker build -t my-frontend:1.0 ./frontend
</code></pre>
        <li>These images remain inside Minikube’s Docker daemon, NOT your system Docker.</li>
    </ul>
    <br/><br/>


    <li>Step 4: Write the Backend Deployment + Service</li>
    <br/>
    <ul>

        <li><code>k8s/backend-deploy.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: my-backend:1.0
          ports:
            - containerPort: 5000
</code></pre>

        <li><code>k8s/backend-svc.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: v1
kind: Service
metadata:
  name: backend-svc
spec:
  selector:
    app: backend
  ports:
    - port: 5000
      targetPort: 5000
  type: ClusterIP
</code></pre>
        <li>This exposes the backend internally as <code>http://backend-svc:5000</code>.</li>

    </ul>
    <br/><br/>


    <li>Step 5: Write the Frontend Deployment + Service</li>
    <br/>
    <ul>

        <li><code>k8s/frontend-deploy.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: my-frontend:1.0
          ports:
            - containerPort: 80
</code></pre>

        <li><code>k8s/frontend-svc.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: v1
kind: Service
metadata:
  name: frontend-svc
spec:
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
  type: ClusterIP
</code></pre>

        <li>This exposes frontend internally as <code>http://frontend-svc</code>.</li>

    </ul>
    <br/><br/>


    <li>Step 6: Configure Ingress for External Access</li>
    <br/>
    <ul>
        <li>Enable Minikube ingress:</li>
<pre><code class="language-bash line-numbers">minikube addons enable ingress</code></pre>

        <li><code>k8s/ingress.yaml</code>:</li>
<pre><code class="language-yaml line-numbers">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
spec:
  rules:
  - host: myapp.local
    http:
      paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: frontend-svc
              port:
                number: 80
        - path: /api
          pathType: Prefix
          backend:
            service:
              name: backend-svc
              port:
                number: 5000
</code></pre>

        <li>Explanation:</li>
        <ul>
            <li><code>myapp.local</code> will point to Minikube</li>
            <li><code>/</code> serves frontend</li>
            <li><code>/api</code> routes to backend</li>
        </ul>

        <br/>
        <li>Add to local hosts file (<code>/etc/hosts</code>):</li>
<pre><code class="language-plaintext line-numbers">127.0.0.1   myapp.local
</code></pre>

    </ul>
    <br/><br/>


    <li>Step 7: Apply All Kubernetes Manifests</li>
    <br/>
    <ul>
        <li>Deploy everything:</li>
<pre><code class="language-bash line-numbers">kubectl apply -f k8s/backend-deploy.yaml
kubectl apply -f k8s/backend-svc.yaml
kubectl apply -f k8s/frontend-deploy.yaml
kubectl apply -f k8s/frontend-svc.yaml
kubectl apply -f k8s/ingress.yaml
</code></pre>

        <li>Check resources:</li>
<pre><code class="language-bash line-numbers">kubectl get all</code></pre>

        <li>Check ingress:</li>
<pre><code class="language-bash line-numbers">kubectl get ingress</code></pre>

    </ul>
    <br/><br/>


    <li>Step 8: Access the Application</li>
    <br/>
    <ul>
        <li>Open browser:</li>
<pre><code class="language-plaintext line-numbers">http://myapp.local</code></pre>

        <br/>
        <li>Click button → backend API is called.</li>
        <br/>
        <li>You now have a full full-stack application deployed inside Minikube.</li>
        <br/>
        <li>This mirrors real production deployments using K8S + Ingress.</li>
    </ul>
    <br/><br/>


    <li>Step 9: Debugging Tips</li>
    <br/>
    <ul>
        <li>Check pods:</li>
<pre><code class="language-bash line-numbers">kubectl get pods</code></pre>

        <li>Describe pod (very useful):</li>
<pre><code class="language-bash line-numbers">kubectl describe pod backend-deploy-xxxxx</code></pre>

        <li>See logs:</li>
<pre><code class="language-bash line-numbers">kubectl logs backend-deploy-xxxxx</code></pre>

        <li>Restart pods:</li>
<pre><code class="language-bash line-numbers">kubectl rollout restart deployment backend-deploy</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
