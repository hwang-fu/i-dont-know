<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Flask</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 28px;
        height: 28px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/flask.svg" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ol style="line-height: 1.8;">
        <li><a href="#flask-introduction">Introduction</a></li>
        <li><a href="#flask-application-overview">Application Overview</a></li>
        <li><a href="#flask-routing">Routing</a></li>
        <li><a href="#flask-variable-rules">variable Rules</a></li>
        <li><a href="#flask-url-building">URL Building</a></li>
        <li><a href="#flask-http-methods">HTTP Methods</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-introduction">Introduction to Flask</h3>
<ol>
    <li><b>What Is Flask?</b></li>
    <br/>
    <ul>
        <li><u>Flask</u> is a lightweight, flexible, and minimalistic web framework for Python.</li>
        <br/>
        <li>It follows the <u>WSGI</u> standard and promotes a <u>micro-framework</u> philosophy:
            <ul>
                <li>Keep the core small and simple,</li>
                <li>Allow developers to add only what they need via extensions.</li>
            </ul>
        </li>
        <br/>
        <li>Flask is ideal for:
            <ul>
                <li>Small to medium web applications,</li>
                <li>REST APIs and JSON services,</li>
                <li>Rapid prototyping,</li>
                <li>Learning how HTTP servers work internally.</li>
            </ul>
        </li>
        <br/>
        <li>The philosophy: <b>“Simple core, powerful when extended.”</b></li>
    </ul>
    <br/><br/>

    <li><b>Installing Flask</b></li>
    <br/>
    <ul>
        <li>Create a virtual environment (recommended):</li>
    </ul>

<pre><code class="language-bash line-numbers">python3 -m venv venv
source venv/bin/activate
</code></pre>

    <ul>
        <li>Install Flask:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install flask
</code></pre>
    <br/><br/>

    <li><b>Your First Flask Application</b></li>
    <br/>
    <ul>
        <li>Create a file <code>app.py</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello, Flask!"

if __name__ == "__main__":
    app.run(debug=True)
</code></pre>

    <ul>
        <li>Explanation:
            <ul>
                <li><code>Flask(__name__)</code> creates your web application object.</li>
                <li><code>@app.route("/")</code> maps the URL <code>/</code> to the function <code>home()</code>.</li>
                <li><code>debug=True</code> enables automatic reloading and developer-friendly errors.</li>
            </ul>
        </li>

        <br/>

        <li>Run it:</li>
    </ul>

<pre><code class="language-bash line-numbers">python3 app.py
</code></pre>

    <ul>
        <li>Visit <code>http://127.0.0.1:5000</code> in the browser.</li>
    </ul>
    <br/><br/>

    <li><b>Routing: Connecting URLs to Functions</b></li>
    <br/>
    <ul>
        <li>A <u>route</u> defines how your Flask application responds to a URL.</li>
        <li>Each route corresponds to a view function.</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/hello")
def greet():
    return "Hello!"
</code></pre>

    <br/>
    <ul>
        <li>You can define dynamic routes:</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/user/&lt;name&gt;")
def user(name):
    return f"User: {name}"
</code></pre>

    <br/>
    <ul>
        <li>Flask supports types:</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/square/&lt;int:num&gt;")
def square(num):
    return str(num * num)
</code></pre>
    <br/><br/>

    <li><b>Templates: Rendering HTML with Jinja2</b></li>
    <br/>
    <ul>
        <li>Flask includes the <u>Jinja2 templating engine</u> for generating HTML.</li>
        <li>Folder structure:</li>
    </ul>

<pre><code class="language-text line-numbers">project/
├── app.py
└── templates/
    └── index.html
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- templates/index.html --&gt;
&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;
</code></pre>

<pre><code class="language-python line-numbers">from flask import render_template

@app.route("/hello/&lt;name&gt;")
def hello(name):
    return render_template("index.html", name=name)
</code></pre>

    <br/>
    <ul>
        <li>Jinja2 allows loops, conditions, inheritance, and more.</li>
    </ul>
    <br/><br/>

    <li><b>Handling POST Requests</b></li>
    <br/>
    <ul>
        <li>By default, routes accept GET requests. To handle POST, specify the method:</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/submit", methods=["GET", "POST"])
def submit():
    if request.method == "POST":
        data = request.form["username"]
        return f"Received: {data}"
    return "Send a POST request!"
</code></pre>

    <br/><br/>

    <li><b>Using JSON and Building APIs</b></li>
    <br/>
    <ul>
        <li>Flask makes it easy to build REST APIs or JSON endpoints:</li>
    </ul>

<pre><code class="language-python line-numbers">from flask import jsonify

@app.route("/api/user/&lt;int:id&gt;")
def api_user(id):
    return jsonify({"id": id, "name": "Alice"})
</code></pre>

    <br/>
    <ul>
        <li><code>jsonify</code> automatically converts Python dictionaries into JSON responses.</li>
    </ul>
    <br/><br/>

    <li><b>Flask Application Structure (Recommended Layout)</b></li>
    <br/>
    <ul>
        <li>For larger apps, organize code like this:</li>
    </ul>

<pre><code class="language-text line-numbers">myapp/
├── app.py
├── static/
│   └── style.css
├── templates/
│   ├── base.html
│   └── index.html
└── routes/
    └── home.py
</code></pre>

    <br/>
    <ul>
        <li>Flask doesn't force you into a rigid folder structure — this flexibility is one of its strengths.</li>
    </ul>
    <br/><br/>

    <li><b>Development vs. Production</b></li>
    <br/>
    <ul>
        <li>Flask's built-in development server is <b>not</b> meant for production.</li>
        <li>Use a WSGI server such as:
            <ul>
                <li>Gunicorn,</li>
                <li>uWSGI,</li>
                <li>Waitress (Windows).</li>
            </ul>
        </li>
        <li>Then run Flask under the WSGI server.</li>
    </ul>
    <br/><br/>

    <li><b>Flask Extensions (Powerful Add-ons)</b></li>

    <ul>
        <li><b>Flask-SQLAlchemy</b> — ORM for relational databases</li>
        <li><b>Flask-Migrate</b> — database migrations</li>
        <li><b>Flask-Login</b> — authentication and session management</li>
        <li><b>Flask-WTF</b> — form handling and CSRF protection</li>
        <li><b>Flask-Admin</b> — admin dashboard</li>
        <li><b>Flask-RESTful</b> — build REST APIs more easily</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-application-overview">Flask Application Overview</h3>
<ol>

    <li>What Is Flask?</li>
    <br/>
    <ul>
        <li><b>Flask</b> is a lightweight, flexible, and minimalistic Python web framework.</li>
        <br/>
        <li>It follows a <b>micro-framework</b> philosophy:
            <ul>
                <li>no built-in ORM</li>
                <li>no built-in template engine (uses Jinja2)</li>
                <li>no strict project structure</li>
                <li>everything is extensible via extensions</li>
            </ul>
        </li>
        <br/>
        <li>Flask is commonly used for:
            <ul>
                <li>REST APIs</li>
                <li>small to mid-sized web applications</li>
                <li>prototypes and rapid development</li>
                <li>microservices</li>
            </ul>
        </li>
        <br/>
        <li>Main advantages:
            <ul>
                <li>simple and intuitive API</li>
                <li>minimal boilerplate</li>
                <li>easy to integrate with SQLAlchemy, Jinja2, WTForms</li>
                <li>large ecosystem of extensions</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Installing and Running a Flask Application</li>
    <br/>
    <ul>
        <li>Install Flask via pip:</li>
<pre><code class="language-bash line-numbers">pip install Flask</code></pre>
        </li>
        <br/>
        <li>Minimal Flask app (<code>app.py</code>):</li>
<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello, Flask!"

if __name__ == "__main__":
    app.run(debug=True)</code></pre>
        </li>
        <br/>
        <li>Run the app:</li>
<pre><code class="language-bash line-numbers">python app.py</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding the Flask Application Object</li>
    <br/>
    <ul>
        <li>The <code>Flask</code> object represents your application.</li>
        <br/>
        <li>Created using:
<pre><code class="language-python line-numbers">app = Flask(__name__)</code></pre>
        </li>
        <br/>
        <li>Responsibilities:
            <ul>
                <li>handling incoming requests</li>
                <li>mapping URLs to functions (routing)</li>
                <li>managing application-wide configuration</li>
                <li>initializing extensions</li>
                <li>managing Jinja2 templates</li>
            </ul>
        </li>
        <br/>
        <li><code>__name__</code> helps Flask locate resources (templates, static files).</li>
    </ul>
    <br/><br/>


    <li>Routing Fundamentals</li>
    <br/>
    <ul>
        <li>Routes connect URLs to Python functions (called <b>view functions</b>).</li>
        <br/>
        <li>Basic route:</li>
<pre><code class="language-python line-numbers">@app.route("/about")
def about():
    return "About page"</code></pre>
        </li>
        <br/>
        <li>Routes can accept parameters:</li>
<pre><code class="language-python line-numbers">@app.route("/user/&lt;username&gt;")
def profile(username):
    return f"Hello, {username}"</code></pre>
        </li>
        <br/>
        <li>Routes can restrict parameter types:</li>
<pre><code class="language-python line-numbers">@app.route("/item/&lt;int:id&gt;")
def item(id):
    return f"Item {id}"</code></pre>
    </ul>
    <br/><br/>


    <li>Template Rendering</li>
    <br/>
    <ul>
        <li>Flask uses the Jinja2 template engine.</li>
        <br/>
        <li>Render templates:</li>
<pre><code class="language-python line-numbers">from flask import render_template

@app.route("/hello")
def hello():
    return render_template("hello.html", name="Junzhe")</code></pre>
        </li>
        <br/>
        <li>Example <code>templates/hello.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Hello {{ name }}!&lt;/h1&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Handling Requests and Forms</li>
    <br/>
    <ul>
        <li>Flask provides the <code>request</code> object:</li>
<pre><code class="language-python line-numbers">from flask import request

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username")
        return f"Logged in as {username}"
    return render_template("login.html")</code></pre>
        </li>
        <br/>
        <li>Use cases:
            <ul>
                <li>processing HTML forms</li>
                <li>AJAX requests</li>
                <li>JSON APIs</li>
            </ul>
        </li>
        <br/>
        <li>Accessing JSON:</li>
<pre><code class="language-python line-numbers">data = request.get_json()</code></pre>
    </ul>
    <br/><br/>


    <li>Flask Application Configuration</li>
    <br/>
    <ul>
        <li>Configuration values stored in <code>app.config</code>.</li>
        <br/>
        <li>Common settings:</li>
<pre><code class="language-plaintext line-numbers">DEBUG = True
SECRET_KEY = "super-secret"
DATABASE_URI = "sqlite:///app.db"
</code></pre>
        </li>
        <br/>
        <li>Load configuration from Python file:</li>
<pre><code class="language-python line-numbers">app.config.from_pyfile("config.py")</code></pre>
        </li>
        <br/>
        <li>Or from environment variables:</li>
<pre><code class="language-python line-numbers">app.config.from_envvar("APP_SETTINGS")</code></pre>
    </ul>
    <br/><br/>


    <li>Using Flask Extensions</li>
    <br/>
    <ul>
        <li>Flask achieves rich functionality through extensions:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Extension</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Flask-SQLAlchemy</code></td>
            <td>Object-relational mapping (ORM) for database models.</td>
        </tr>
        <tr>
            <td><code>Flask-Migrate</code></td>
            <td>Database migrations built on top of Alembic.</td>
        </tr>
        <tr>
            <td><code>Flask-WTF</code></td>
            <td>Form handling, validation, and CSRF protection.</td>
        </tr>
        <tr>
            <td><code>Flask-Login</code></td>
            <td>User authentication and session management.</td>
        </tr>
        <tr>
            <td><code>Flask-Mail</code></td>
            <td>Email sending integration for Flask applications.</td>
        </tr>
        <tr>
            <td><code>Flask-RESTful</code></td>
            <td>REST API framework for building JSON APIs.</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Extensions typically follow this pattern:</li>
<pre><code class="language-python line-numbers">db = SQLAlchemy()
login = LoginManager()

def create_app():
    app = Flask(__name__)
    db.init_app(app)
    login.init_app(app)
    return app
</code></pre>
    </ul>
    <br/><br/>


    <li>The Application Factory Pattern</li>
    <br/>
    <ul>
        <li>Large applications use a factory to create the app instance.</li>
        <br/>
        <li>Allows:
            <ul>
                <li>testing flexibility</li>
                <li>extension initialization</li>
                <li>different configurations</li>
            </ul>
        </li>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">def create_app(config_name="default"):
    app = Flask(__name__)
    app.config.from_object(config_name)
    return app
</code></pre>
    </ul>
    <br/><br/>


    <li>Blueprints (Modular Applications)</li>
    <br/>
    <ul>
        <li><b>Blueprints</b> allow you to break the application into reusable modules.</li>
        <br/>
        <li>Create a blueprint:</li>
<pre><code class="language-python line-numbers">from flask import Blueprint

bp = Blueprint("auth", __name__)

@bp.route("/login")
def login():
    return "Login page"
</code></pre>
        </li>
        <br/>
        <li>Register it:</li>
<pre><code class="language-python line-numbers">app.register_blueprint(bp, url_prefix="/auth")</code></pre>
    </ul>
    <br/><br/>


    <li>Static Files and Templates</li>
    <br/>
    <ul>
        <li>Default structure:</li>
<pre><code class="language-plaintext line-numbers">project/
    static/
        css/
        js/
        images/
    templates/
        .html files
</code></pre>
        </li>
        <br/>
        <li>Serve static files:</li>
<pre><code class="language-html line-numbers">&lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Error Handling</li>
    <br/>
    <ul>
        <li>Custom error pages:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def not_found(e):
    return render_template("404.html"), 404
</code></pre>
        </li>
        <br/>
        <li>Useful for user experience and debugging.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-routing">Flask Routing</h3>
<ol>

    <li>What Is Routing in Flask?</li>
    <br/>
    <ul>
        <li><b>Routing</b> is the mechanism that maps a URL path to a Python function (called a <b>view function</b>).</li>
        <br/>
        <li>The route determines:
            <ul>
                <li>which function handles which URL</li>
                <li>which HTTP methods are allowed</li>
                <li>how dynamic URL segments are parsed</li>
                <li>how parameters are passed to the function</li>
            </ul>
        </li>
        <br/>
        <li>Defined using the <code>@app.route()</code> decorator.</li>
        <br/>
        <li>Flask uses Werkzeug’s routing system under the hood.</li>
    </ul>
    <br/><br/>


    <li>Basic Route Definition</li>
    <br/>
    <ul>
        <li>Simplest route example:</li>
<pre><code class="language-python line-numbers">@app.route("/")
def home():
    return "Hello!"
</code></pre>
        </li>
        <br/>
        <li>Routes must return either:
            <ul>
                <li>a string</li>
                <li>a Response object</li>
                <li>a tuple (body, status code, headers)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Defining Routes with URLs</li>
    <br/>
    <ul>
        <li>Another simple example:</li>
<pre><code class="language-python line-numbers">@app.route("/about")
def about():
    return "About Page"
</code></pre>
        </li>
        <br/>
        <li>Flask automatically handles trailing slashes:
            <ul>
                <li><code>/about/</code> redirects to <code>/about</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Dynamic URL Parameters</li>
    <br/>
    <ul>
        <li>URLs can contain dynamic segments:</li>
<pre><code class="language-python line-numbers">@app.route("/user/&lt;username&gt;")
def profile(username):
    return f"User: {username}"
</code></pre>
        </li>
        <br/>
        <li>Example request:
<pre><code class="language-plaintext line-numbers">/user/junzhe</code></pre>
        </li>
        <br/>
        <li>Function receives:
<pre><code class="language-plaintext line-numbers">username = "junzhe"</code></pre>
        </li>
        <br/>
        <li>Available converters:
            <ul>
                <li><code>string</code> (default)</li>
                <li><code>int</code></li>
                <li><code>float</code></li>
                <li><code>path</code> (accepts slashes)</li>
                <li><code>uuid</code></li>
            </ul>
        </li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-python line-numbers">@app.route("/item/&lt;int:item_id&gt;")
def item(item_id):
    return f"Item ID = {item_id}"

@app.route("/files/&lt;path:filepath&gt;")
def files(filepath):
    return f"File Path = {filepath}"
</code></pre>
    </ul>
    <br/><br/>


    <li>URL Building with <code>url_for()</code></li>
    <br/>
    <ul>
        <li>Instead of hardcoding URLs, Flask encourages <code>url_for</code>:</li>
<pre><code class="language-python line-numbers">from flask import url_for

@app.route("/")
def index():
    return url_for("hello")

@app.route("/hello")
def hello():
    return "Hi!"
</code></pre>
        </li>
        <br/>
        <li>URL with parameters:</li>
<pre><code class="language-python line-numbers">url_for("profile", username="Alice")
</code></pre>
        </li>
        <br/>
        <li>Benefits:
            <ul>
                <li>automatic URL creation</li>
                <li>avoiding broken links</li>
                <li>routes remain consistent if changed later</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>HTTP Methods (GET, POST, etc.)</li>
    <br/>
    <ul>
        <li>Routes accept only GET by default.</li>
        <br/>
        <li>To enable POST or other methods:</li>
<pre><code class="language-python line-numbers">@app.route("/submit", methods=["POST"])
def submit():
    return "Form submitted"
</code></pre>
        </li>
        <br/>
        <li>Multiple methods:</li>
<pre><code class="language-python line-numbers">@app.route("/api/user", methods=["GET", "POST"])
def api_user():
    if request.method == "POST":
        return "Created"
    return "Listing users"
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Handling Query Parameters</li>
    <br/>
    <ul>
        <li>Access via <code>request.args</code>:</li>
<pre><code class="language-python line-numbers">from flask import request

@app.route("/search")
def search():
    keyword = request.args.get("q")
    return f"Keyword: {keyword}"
</code></pre>
        </li>
        <br/>
        <li>Example request:
<pre><code class="language-plaintext line-numbers">/search?q=python</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Route Defaults</li>
    <br/>
    <ul>
        <li>Set default values for parameters:</li>
<pre><code class="language-python line-numbers">@app.route("/page/&lt;int:num&gt;")
@app.route("/page", defaults={"num": 1})
def page(num):
    return f"Page {num}"
</code></pre>
        </li>
        <br/>
        <li>Useful for pagination or optional params.</li>
    </ul>
    <br/><br/>


    <li>Redirects</li>
    <br/>
    <ul>
        <li>Use <code>redirect</code> together with <code>url_for</code>:</li>
<pre><code class="language-python line-numbers">from flask import redirect

@app.route("/old")
def old():
    return redirect(url_for("new"))

@app.route("/new")
def new():
    return "This is the new page"
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Custom Error Routes</li>
    <br/>
    <ul>
        <li>Define custom error handlers:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def not_found(e):
    return "Page not found!", 404
</code></pre>
        </li>
        <br/>
        <li>Common handlers:
            <ul>
                <li>404 — Not Found</li>
                <li>500 — Server Error</li>
                <li>405 — Method Not Allowed</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Routing Inside Blueprints</li>
    <br/>
    <ul>
        <li>Blueprints let you group related routes.</li>
        <br/>
        <li>Create blueprint:</li>
<pre><code class="language-python line-numbers">from flask import Blueprint

auth = Blueprint("auth", __name__)

@auth.route("/login")
def login():
    return "Login Page"
</code></pre>
        </li>
        <br/>
        <li>Register blueprint:</li>
<pre><code class="language-python line-numbers">app.register_blueprint(auth, url_prefix="/auth")
</code></pre>
        </li>
        <br/>
        <li>Final route becomes:</li>
<pre><code class="language-plaintext line-numbers">/auth/login
</code></pre>
    </ul>
    <br/><br/>


    <li>Advanced Routing Features</li>
    <br/>
    <ul>
        <li>Custom URL Converters:</li>
<pre><code class="language-python line-numbers">from werkzeug.routing import BaseConverter

class EvenIntConverter(BaseConverter):
    regex = r"\d*[02468]"

app.url_map.converters["even"] = EvenIntConverter

@app.route("/number/&lt;even:n&gt;")
def even_number(n):
    return f"Even: {n}"
</code></pre>
        </li>
        <br/>
        <li>Subdomain Routing:</li>
<pre><code class="language-python line-numbers">@app.route("/", subdomain="api")
def api_home():
    return "API Home"
</code></pre>
        </li>
        <br/>
        <li>Strict Slash Control:</li>
<pre><code class="language-python line-numbers">@app.route("/users/", strict_slashes=False)
def users():
    return "Users"
</code></pre>
        </li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-variable-rules">Flask Variable Rules</h3>
<ol>

    <li>What Are Variable Rules in Flask?</li>
    <br/>
    <ul>
        <li>In Flask, <b>variable rules</b> let you capture parts of the URL as parameters and pass them into your view functions.</li>
        <br/>
        <li>They are defined directly inside the route pattern using angle brackets, such as <code>&lt;username&gt;</code> or <code>&lt;int:id&gt;</code>.</li>
        <br/>
        <li>Example idea:</li>
        <ul>
            <li><code>/user/junzhe</code> → passes <code>"junzhe"</code> to the view function</li>
            <li><code>/post/42</code> → passes <code>42</code> as an integer</li>
        </ul>
        <br/>
        <li>Variable rules make routes more dynamic and expressive, which is essential for REST-style APIs.</li>
    </ul>
    <br/><br/>


    <li>Basic Syntax of Variable Rules</li>
    <br/>
    <ul>
        <li>General pattern:</li>
<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)

@app.route('/user/&lt;username&gt;')
def show_user_profile(username):
    return f'User: {username}'
</code></pre>
        <br/>
        <li>Key points:</li>
        <ul>
            <li>Everything inside <code>&lt;...&gt;</code> is treated as a variable name.</li>
            <li>The variable name becomes a parameter of the view function.</li>
            <li>By default, the value is a <b>string</b>.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Built-In Converters</li>
    <br/>
    <ul>
        <li>Flask provides several converters to control the type and shape of URL variables:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Converter</th>
                    <th>Meaning</th>
                    <th>Example URL Rule</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>string</code></td>
                    <td>(default) any text without slashes</td>
                    <td><code>/hello/&lt;string:name&gt;</code></td>
                </tr>
                <tr>
                    <td><code>int</code></td>
                    <td>only integers</td>
                    <td><code>/post/&lt;int:post_id&gt;</code></td>
                </tr>
                <tr>
                    <td><code>float</code></td>
                    <td>floating-point numbers</td>
                    <td><code>/price/&lt;float:value&gt;</code></td>
                </tr>
                <tr>
                    <td><code>path</code></td>
                    <td>string including slashes</td>
                    <td><code>/files/&lt;path:subpath&gt;</code></td>
                </tr>
                <tr>
                    <td><code>uuid</code></td>
                    <td>UUID strings converted to <code>UUID</code> objects</td>
                    <td><code>/item/&lt;uuid:item_id&gt;</code></td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>Syntax with a converter:</li>
<pre><code class="language-python line-numbers">@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    # post_id is already an int
    return f'Post ID: {post_id}'
</code></pre>
    </ul>
    <br/><br/>


    <li>Default Converter: string</li>
    <br/>
    <ul>
        <li>If you omit a converter, Flask uses the <code>string</code> converter by default.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/hello/&lt;name&gt;')
def hello(name):
    # name is a string
    return f'Hello, {name}!'
</code></pre>
        <br/>
        <li>The following are equivalent:</li>
<pre><code class="language-python line-numbers">@app.route('/hello/&lt;name&gt;')
@app.route('/hello/&lt;string:name&gt;')
def hello(name):
    ...
</code></pre>
    </ul>
    <br/><br/>


    <li>Using the int Converter</li>
    <br/>
    <ul>
        <li>The <code>int</code> converter ensures that only integer values match the route.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    # If the URL is /post/abc, this route will NOT match.
    # If the URL is /post/42, post_id == 42 (int).
    return f'Post ID is {post_id}'
</code></pre>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>Automatic type conversion (string → int)</li>
            <li>More precise routing</li>
            <li>Invalid URLs (e.g. non-numeric IDs) return 404 instead of entering the view</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Using the float and path Converters</li>
    <br/>
    <ul>
        <li><b>float</b> converter:</li>
<pre><code class="language-python line-numbers">@app.route('/discount/&lt;float:rate&gt;')
def show_discount(rate):
    return f'Discount rate: {rate:.2f}'
</code></pre>
        <br/>
        <li><b>path</b> converter (includes slashes):</li>
<pre><code class="language-python line-numbers">@app.route('/files/&lt;path:subpath&gt;')
def show_file(subpath):
    # Matches /files/images/logo.png
    # subpath == 'images/logo.png'
    return f'Serving: {subpath}'
</code></pre>
        <br/>
        <li><code>path</code> is useful for nested directories or "catch-all" URLs.</li>
    </ul>
    <br/><br/>


    <li>Using the uuid Converter</li>
    <br/>
    <ul>
        <li>The <code>uuid</code> converter parses a standard UUID string into a Python <code>UUID</code> object.</li>
        <br/>
<pre><code class="language-python line-numbers">from uuid import UUID
from flask import Flask

app = Flask(__name__)

@app.route('/items/&lt;uuid:item_id&gt;')
def get_item(item_id: UUID):
    # item_id is a UUID instance, not a plain string
    return f'Item ID: {item_id}'
</code></pre>
        <br/>
        <li>This is very convenient for REST APIs that use UUIDs as primary identifiers.</li>
    </ul>
    <br/><br/>


    <li>Multiple Variable Rules in One Route</li>
    <br/>
    <ul>
        <li>You can define multiple variables inside the same URL pattern.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/shop/&lt;category&gt;/item/&lt;int:item_id&gt;')
def show_item(category, item_id):
    return f'Category: {category}, Item ID: {item_id}'
</code></pre>
        <br/>
        <li>Flask maps each variable to a separate function parameter in the same order as their appearance.</li>
        <br/>
        <li>Make sure the parameter names in the function <b>match exactly</b> the variable names in the route.</li>
    </ul>
    <br/><br/>


    <li>Variable Rules and url_for()</li>
    <br/>
    <ul>
        <li>When using <code>url_for()</code>, route variables become keyword arguments.</li>
        <br/>
<pre><code class="language-python line-numbers">from flask import url_for

@app.route('/user/&lt;username&gt;')
def profile(username):
    return f'Profile: {username}'

@app.route('/where-is-junzhe')
def where_is_junzhe():
    # Generates /user/Junzhe
    return url_for('profile', username='Junzhe')
</code></pre>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>No hardcoding of URLs</li>
            <li>URLs update automatically if the rule changes</li>
            <li>Safer refactoring</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Trailing Slashes and Variable Rules</li>
    <br/>
    <ul>
        <li>Flask treats routes with and without trailing slashes differently:</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/hello/&lt;name&gt;')    # no trailing slash
def hello(name):
    ...

@app.route('/hello2/&lt;name&gt;/')   # with trailing slash
def hello2(name):
    ...
</code></pre>
        <br/>
        <li>Behavior:</li>
        <ul>
            <li><code>/hello/Bob</code> → works</li>
            <li><code>/hello/Bob/</code> → 404 (by default)</li>
            <li><code>/hello2/Bob/</code> → works</li>
            <li><code>/hello2/Bob</code> → may redirect to <code>/hello2/Bob/</code></li>
        </ul>
        <br/>
        <li>Be consistent with your trailing slash style to avoid confusion.</li>
    </ul>
    <br/><br/>


    <li>Custom Converters (Overview)</li>
    <br/>
    <ul>
        <li>Flask allows you to create <b>custom converters</b> for more complex validation rules.</li>
        <br/>
        <li>Typical use cases:</li>
        <ul>
            <li>restricting strings to certain patterns (e.g. usernames, slugs)</li>
            <li>matching date formats</li>
            <li>matching serialized IDs</li>
        </ul>
        <br/>
        <li>Basic steps to create a custom converter:</li>
        <ul>
            <li>Subclass <code>werkzeug.routing.BaseConverter</code>.</li>
            <li>Register it on <code>app.url_map.converters</code>.</li>
            <li>Use it in routes like <code>&lt;custom:name&gt;</code>.</li>
        </ul>
        <br/>
        <li>Example (slug converter):</li>
<pre><code class="language-python line-numbers">from werkzeug.routing import BaseConverter

class SlugConverter(BaseConverter):
    regex = r'[a-z0-9-]+'

app.url_map.converters['slug'] = SlugConverter

@app.route('/blog/&lt;slug:post_slug&gt;')
def show_blog_post(post_slug):
    return f'Post slug: {post_slug}'
</code></pre>
        <br/>
        <li>Custom converters keep your routes clean and reusable.</li>
    </ul>
    <br/><br/>


    <li>Error Handling with Variable Rules</li>
    <br/>
    <ul>
        <li>If a URL does not match the variable rule, Flask returns a <b>404 Not Found</b> before entering your view.</li>
        <br/>
        <li>Examples:</li>
        <ul>
            <li><code>/post/abc</code> does not match <code>/post/&lt;int:post_id&gt;</code>, so Flask returns 404.</li>
            <li><code>/price/1.23</code> matches <code>/price/&lt;float:value&gt;</code>, but <code>/price/abc</code> does not.</li>
        </ul>
        <br/>
        <li>You can provide a custom 404 handler if you want more user-friendly messages.</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def page_not_found(e):
    return 'Custom 404 page', 404
</code></pre>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-url-building">Flask URL Building</h3>
<ol>

    <li>What Is URL Building in Flask?</li>
    <br/>
    <ul>
        <li><b>URL building</b> means generating URLs from view function names (endpoints) instead of hardcoding paths as strings.</li>
        <br/>
        <li>Flask provides the <code>url_for()</code> helper to build URLs based on:
            <ul>
                <li>the endpoint name (usually the view function name)</li>
                <li>any variable parts (path parameters)</li>
                <li>optional query parameters</li>
            </ul>
        </li>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>no hardcoded URL strings scattered in templates and Python code</li>
            <li>safer refactoring: renaming or changing routes in one place</li>
            <li>supports blueprints, static files, and external URLs</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Basic Usage of <code>url_for()</code> in Python</li>
    <br/>
    <ul>
        <li>Typical pattern inside your Python code:</li>
<pre><code class="language-python line-numbers">from flask import Flask, url_for

app = Flask(__name__)

@app.route('/')
def index():
    # Build URL for the 'hello' endpoint
    return url_for('hello')

@app.route('/hello')
def hello():
    return 'Hello!'
</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>'hello'</code> is the endpoint name (the function name by default).</li>
            <li><code>url_for('hello')</code> returns <code>'/hello'</code>.</li>
        </ul>
        <br/>
        <li>If you later change the route to <code>/greeting</code>, only the route definition needs updating, not every link in your app.</li>
    </ul>
    <br/><br/>


    <li>URL Building with Variable Rules</li>
    <br/>
    <ul>
        <li>For routes with path parameters, pass them as keyword arguments to <code>url_for()</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/user/&lt;username&gt;')
def profile(username):
    return f'Profile: {username}'

@app.route('/where-is-junzhe')
def where_is_junzhe():
    # Generates /user/Junzhe
    return url_for('profile', username='Junzhe')
</code></pre>
        <br/>
        <li>Important:</li>
        <ul>
            <li>Keyword names must match the variable names in the route (<code>username</code> in this example).</li>
            <li>Type converters (like <code>&lt;int:id&gt;</code>) are automatically handled as long as you pass compatible values.</li>
        </ul>
        <br/>
        <li>Example with an <code>int</code> converter:</li>
<pre><code class="language-python line-numbers">@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    return f'Post {post_id}'

url_for('show_post', post_id=42)   # '/post/42'
</code></pre>
    </ul>
    <br/><br/>


    <li>Adding Query Parameters with <code>url_for()</code></li>
    <br/>
    <ul>
        <li>Arguments that do <b>not</b> belong to the route pattern become query parameters:</li>
<pre><code class="language-python line-numbers">@app.route('/search')
def search():
    # Imagine we read request.args['q'] and request.args['page']
    ...

# In Python:
url_for('search', q='flask', page=2)
# Result: '/search?q=flask&amp;page=2'
</code></pre>
        <br/>
        <li>Notes:</li>
        <ul>
            <li>Flask automatically URL-encodes special characters (spaces, &amp;, etc.).</li>
            <li>Combine path variables and query parameters in one call.</li>
        </ul>
<pre><code class="language-python line-numbers">@app.route('/user/&lt;username&gt;/posts')
def user_posts(username):
    ...

url_for('user_posts', username='Junzhe', page=3, sort='latest')
# '/user/Junzhe/posts?page=3&amp;sort=latest'
</code></pre>
    </ul>
    <br/><br/>


    <li>Using <code>url_for()</code> in Templates (Jinja2)</li>
    <br/>
    <ul>
        <li>In Jinja2 templates, use <code>url_for</code> exactly like in Python:</li>
<pre><code class="language-html line-numbers">&lt;a href="{{ url_for('index') }}"&gt;Home&lt;/a&gt;

&lt;a href="{{ url_for('profile', username='Junzhe') }}"&gt;
    View profile
&lt;/a&gt;

&lt;a href="{{ url_for('search', q='flask', page=1) }}"&gt;
    Search for Flask
&lt;/a&gt;
</code></pre>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>Templates react automatically to route changes.</li>
            <li>Mixing logic (URL building) and HTML stays clean.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>URL Building for Static Files</li>
    <br/>
    <ul>
        <li>Flask automatically serves static files from the <code>static/</code> directory at the <code>/static</code> URL prefix.</li>
        <br/>
        <li>Use <code>url_for('static', ...)</code> to generate links to static resources:</li>
<pre><code class="language-html line-numbers">&lt;!-- In a Jinja2 template --&gt;
&lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" /&gt;

&lt;img src="{{ url_for('static', filename='images/logo.png') }}" alt="Logo" /&gt;
</code></pre>
        <br/>
        <li>Why not write <code>/static/css/style.css</code> directly?</li>
        <ul>
            <li>URL prefix can be changed in app configuration.</li>
            <li>Caches and versioning strategies sometimes modify static URLs.</li>
            <li><code>url_for</code> ensures all links stay correct.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Custom Endpoint Names</li>
    <br/>
    <ul>
        <li>You can override the default endpoint name (function name) using the <code>endpoint</code> argument in <code>route()</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/dashboard', endpoint='user_dashboard')
def show_dashboard():
    return 'Dashboard'

# URL building:
url_for('user_dashboard')   # '/dashboard'
</code></pre>
        <br/>
        <li>Use cases:</li>
        <ul>
            <li>multiple routes pointing to the same function but with different endpoint names</li>
            <li>avoiding name clashes (e.g. in large applications)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>URL Building with Blueprints</li>
    <br/>
    <ul>
        <li>When using blueprints, endpoint names automatically get a prefix: <code>'blueprint_name.view_function'</code>.</li>
<pre><code class="language-python line-numbers">from flask import Blueprint, url_for

bp = Blueprint('admin', __name__, url_prefix='/admin')

@bp.route('/users')
def user_list():
    ...

app.register_blueprint(bp)

# Building URL:
url_for('admin.user_list')    # '/admin/users'
</code></pre>
        <br/>
        <li>In templates, you use the same endpoint:</li>
<pre><code class="language-html line-numbers">&lt;a href="{{ url_for('admin.user_list') }}"&gt;Admin users&lt;/a&gt;
</code></pre>
        <br/>
        <li>Blueprint-aware URL building keeps your routes nicely namespaced.</li>
    </ul>
    <br/><br/>


    <li>Building Absolute URLs (<code>_external</code> and <code>_scheme</code>)</li>
    <br/>
    <ul>
        <li>By default, <code>url_for()</code> returns a <b>relative</b> path (e.g. <code>/user/Junzhe</code>).</li>
        <br/>
        <li>To build an absolute URL (including domain), use <code>_external=True</code>:</li>
<pre><code class="language-python line-numbers">with app.test_request_context():
    url_for('profile', username='Junzhe', _external=True)
    # e.g. 'http://localhost/user/Junzhe'
</code></pre>
        <br/>
        <li>To control the scheme (HTTP/HTTPS), use <code>_scheme</code>:</li>
<pre><code class="language-python line-numbers">with app.test_request_context():
    url_for('profile', username='Junzhe',
            _external=True, _scheme='https')
    # 'https://localhost/user/Junzhe'
</code></pre>
        <br/>
        <li>Absolute URLs are useful for:</li>
        <ul>
            <li>email links</li>
            <li>redirects to your site from external systems</li>
            <li>API callbacks and webhooks</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Using <code>url_for()</code> with <code>redirect()</code></li>
    <br/>
    <ul>
        <li>Flask’s <code>redirect()</code> often works together with <code>url_for()</code>:</li>
<pre><code class="language-python line-numbers">from flask import redirect, url_for

@app.route('/old-home')
def old_home():
    # Redirect to the new route
    return redirect(url_for('index'))

@app.route('/')
def index():
    return 'New homepage'
</code></pre>
        <br/>
        <li>This pattern allows you to:</li>
        <ul>
            <li>migrate URLs gradually</li>
            <li>avoid broken links</li>
            <li>implement login redirects, logout redirects, etc.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Common Pitfalls and Tips</li>
    <br/>
    <ul>
        <li>Mismatch between variable names and parameters:</li>
        <ul>
            <li>Route: <code>/user/&lt;username&gt;</code></li>
            <li><code>url_for('profile', name='Junzhe')</code> → error, should be <code>username</code>.</li>
        </ul>
        <br/>
        <li>Calling <code>url_for()</code> outside a request context: Use <code>with app.test_request_context():</code> in scripts or shell.</li>
        <br/>
        <li>Forgetting query parameters: Always encode filters, pagination, and sorting options via <code>url_for</code> to keep URLs consistent.</li>
        <br/>
        <li>General recommendation: never hardcode URLs when you can use <code>url_for()</code>.</li>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-http-methods">Flask HTTP Methods</h3>
<ol>

    <li>What Are HTTP Methods in Flask?</li>
    <br/>
    <ul>
        <li>HTTP methods define the action a client wants to perform when sending a request to a server.</li>
        <br/>
        <li>Flask allows each route to explicitly define which HTTP methods it accepts.</li>
        <br/>
        <li>If a request uses a method not allowed by the route, Flask returns <b>405 Method Not Allowed</b>.</li>
    </ul>
    <br/><br/>


    <li>Defining Allowed Methods in <code>@app.route()</code></li>
    <br/>
    <ul>
        <li>Use the <code>methods</code> parameter to specify allowed HTTP methods:</li>
<pre><code class="language-python line-numbers">@app.route('/submit', methods=['POST'])
def submit():
    return 'Form submitted!'
</code></pre>
        <br/>
        <li>If <code>methods</code> is not specified, Flask defaults to <b>GET</b>.</li>
        <br/>
        <li>Multiple allowed methods:</li>
<pre><code class="language-python line-numbers">@app.route('/user', methods=['GET', 'POST'])
def user():
    if request.method == 'POST':
        return 'Posted!'
    return 'User page'
</code></pre>
    </ul>
    <br/><br/>


    <li>GET Method</li>
    <br/>
    <ul>
        <li><b>GET</b> requests retrieve data from the server.</li>
        <br/>
        <li>Typical use cases:</li>
        <ul>
            <li>loading pages</li>
            <li>fetching API resources</li>
            <li>reading query parameters</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">@app.route('/hello')
def hello():
    return 'Hello, World!'
</code></pre>
        <br/>
        <li>GET requests can include query parameters such as <code>?page=2</code> via <code>request.args</code>.</li>
    </ul>
    <br/><br/>


    <li>POST Method</li>
    <br/>
    <ul>
        <li><b>POST</b> is used to submit data, often from forms or JSON clients.</li>
        <br/>
        <li>Reads data via <code>request.form</code> or <code>request.json</code>.</li>
        <br/>
        <li>Example using HTML form data:</li>
<pre><code class="language-python line-numbers">@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    return f'Logged in as {username}'
</code></pre>
        </li>
        <br/>
        <li>JSON POST example:</li>
<pre><code class="language-python line-numbers">@app.route('/api/data', methods=['POST'])
def api_data():
    data = request.json
    return {'received': data}
</code></pre>
        <br/>
        <li>POST is not idempotent — each call may create new data.</li>
    </ul>
    <br/><br/>


    <li>PUT Method</li>
    <br/>
    <ul>
        <li><b>PUT</b> replaces an entire resource.</li>
        <br/>
        <li>Often used in REST APIs.</li>
<pre><code class="language-python line-numbers">@app.route('/profile/&lt;int:id&gt;', methods=['PUT'])
def update_profile(id):
    data = request.json
    return {'id': id, 'updated_profile': data}
</code></pre>
        <br/>
        <li>PUT is idempotent: sending the same request multiple times results in the same final state.</li>
    </ul>
    <br/><br/>


    <li>PATCH Method</li>
    <br/>
    <ul>
        <li><b>PATCH</b> updates <b>part</b> of a resource.</li>
        <br/>
        <li>Used for partial modifications, such as updating a single field.</li>
<pre><code class="language-python line-numbers">@app.route('/profile/&lt;int:id&gt;', methods=['PATCH'])
def patch_profile(id):
    changes = request.json
    return {'id': id, 'changes': changes}
</code></pre>
        <br/>
        <li>PATCH is sometimes non-idempotent (depends on implementation).</li>
    </ul>
    <br/><br/>


    <li>DELETE Method</li>
    <br/>
    <ul>
        <li><b>DELETE</b> removes a resource.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">@app.route('/item/&lt;int:item_id&gt;', methods=['DELETE'])
def delete_item(item_id):
    return {'status': 'deleted', 'id': item_id}
</code></pre>
        <br/>
        <li>DELETE is idempotent — deleting the same resource twice yields the same result.</li>
    </ul>
    <br/><br/>


    <li>HEAD Method</li>
    <br/>
    <ul>
        <li><b>HEAD</b> returns headers only (no body).</li>
        <br/>
        <li>Used for:</li>
        <ul>
            <li>checking if a resource exists</li>
            <li>metadata queries</li>
            <li>lightweight monitoring</li>
        </ul>
        <br/>
        <li>Flask automatically provides a HEAD method for <b>every GET route</b>.</li>
        <br/>
        <li>No extra code needed:</li>
<pre><code class="language-python line-numbers">@app.route('/info')
def info():
    return 'data'
</code></pre>
        <br/>
        <li><code>HEAD /info</code> → same headers, empty body.</li>
    </ul>
    <br/><br/>


    <li>OPTIONS Method</li>
    <br/>
    <ul>
        <li><b>OPTIONS</b> asks the server which HTTP methods are supported.</li>
        <br/>
        <li>Flask automatically provides an OPTIONS response for every route.</li>
        <br/>
        <li>Useful for:
            <ul>
                <li>CORS preflight checks</li>
                <li>API clients</li>
            </ul>
        </li>
        <br/>
        <li>Example client request:</li>
<pre><code class="language-text line-numbers">OPTIONS /user
</code></pre>
    </ul>
    <br/><br/>


    <li>Handling Different Methods Inside a Single View</li>
    <br/>
    <ul>
        <li>You can check the incoming method using <code>request.method</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/settings', methods=['GET', 'POST'])
def settings():
    if request.method == 'POST':
        return 'Settings updated'
    return 'Settings page'
</code></pre>
        <br/>
        <li>Useful for pages that show a form (GET) and process it (POST).</li>
    </ul>
    <br/><br/>


    <li>Using <code>@app.get</code>, <code>@app.post</code>, <code>@app.put</code> (Shorthand Decorators)</li>
    <br/>
    <ul>
        <li>Starting from Flask 2.0, convenient decorators were added:</li>
<pre><code class="language-python line-numbers">@app.get('/hello')
def hello():
    return 'GET request'

@app.post('/submit')
def submit():
    return 'POST request'

@app.delete('/remove/&lt;int:id&gt;')
def remove(id):
    return f'Removed {id}'
</code></pre>
        <br/>
        <li>Each shortcut decorator is equivalent to <code>@app.route(..., methods=['...'])</code>.</li>
    </ul>
    <br/><br/>


    <li>Method-Specific Routing Examples</li>
    <br/>
    <ul>
        <li><b>RESTful user API example:</b></li>
<pre><code class="language-python line-numbers">@app.route('/users', methods=['GET'])
def list_users():
    return 'List users'

@app.route('/users', methods=['POST'])
def create_user():
    return 'Create user'

@app.route('/users/&lt;int:id&gt;', methods=['GET'])
def get_user(id):
    return f'Get user {id}'

@app.route('/users/&lt;int:id&gt;', methods=['PUT'])
def update_user(id):
    return f'Update user {id}'

@app.route('/users/&lt;int:id&gt;', methods=['DELETE'])
def delete_user(id):
    return f'Delete user {id}'
</code></pre>
        <br/>
        <li>This style is common for building full REST APIs.</li>
    </ul>
    <br/><br/>


    <li>405 Method Not Allowed</li>
    <br/>
    <ul>
        <li>If a method is not allowed on a route, Flask returns <b>405</b>.</li>
        <br/>
        <li>Example:</li>
        <ul>
            <li>Route: <code>/login</code> only accepts POST.</li>
            <li>Sending GET → Flask responds 405.</li>
        </ul>
        <br/>
        <li>Flask also includes an <code>Allow</code> header showing valid methods.</li>
    </ul>
    <br/><br/>


    <li>Summary Table of HTTP Methods</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Purpose</th>
                <th>Idempotent?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>GET</b></td>
                <td>Retrieve data</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>POST</b></td>
                <td>Create or submit data</td>
                <td>No</td>
            </tr>
            <tr>
                <td><b>PUT</b></td>
                <td>Replace entire resource</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>PATCH</b></td>
                <td>Modify part of resource</td>
                <td>Sometimes</td>
            </tr>
            <tr>
                <td><b>DELETE</b></td>
                <td>Remove resource</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>HEAD</b></td>
                <td>Headers only</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>OPTIONS</b></td>
                <td>Discover supported methods</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * --
