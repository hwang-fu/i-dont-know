<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Flask</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 28px;
        height: 28px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/flask.svg" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ol style="line-height: 1.8;">
        <li><a href="#flask-introduction">Introduction</a></li>
        <li><a href="#flask-application-overview">Application Overview</a></li>
        <li><a href="#flask-routing">Routing</a></li>
        <li><a href="#flask-variable-rules">variable Rules</a></li>
        <li><a href="#flask-url-building">URL Building</a></li>
        <li><a href="#flask-http-methods">HTTP Methods</a></li>
        <li><a href="#flask-templates">Templates</a></li>
        <li><a href="#flask-static-files">Static Files</a></li>
        <li><a href="#flask-request-object">Request Object</a></li>
        <li><a href="#flask-sending-form-data-to-template">Sending Form Data to Template</a></li>
        <li><a href="#flask-cookies">Cookies</a></li>
        <li><a href="#flask-sessions">Sessions</a></li>
        <li><a href="#flask-redirect-erros">Redirect &amp; Errors</a></li>
        <li><a href="#flask-message-flashing">Message Flashing</a></li>
        <li><a href="#flask-file-uploading">File Uploading</a></li>
        <li><a href="#flask-extensions">Extensions</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-introduction">Introduction to Flask</h3>
<ol>
    <li><b>What Is Flask?</b></li>
    <br/>
    <ul>
        <li><u>Flask</u> is a lightweight, flexible, and minimalistic web framework for Python.</li>
        <br/>
        <li>It follows the <u>WSGI</u> standard and promotes a <u>micro-framework</u> philosophy:
            <ul>
                <li>Keep the core small and simple,</li>
                <li>Allow developers to add only what they need via extensions.</li>
            </ul>
        </li>
        <br/>
        <li>Flask is ideal for:
            <ul>
                <li>Small to medium web applications,</li>
                <li>REST APIs and JSON services,</li>
                <li>Rapid prototyping,</li>
                <li>Learning how HTTP servers work internally.</li>
            </ul>
        </li>
        <br/>
        <li>The philosophy: <b>“Simple core, powerful when extended.”</b></li>
    </ul>
    <br/><br/>

    <li><b>Installing Flask</b></li>
    <br/>
    <ul>
        <li>Create a virtual environment (recommended):</li>
    </ul>

<pre><code class="language-bash line-numbers">python3 -m venv venv
source venv/bin/activate
</code></pre>

    <ul>
        <li>Install Flask:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install flask
</code></pre>
    <br/><br/>

    <li><b>Your First Flask Application</b></li>
    <br/>
    <ul>
        <li>Create a file <code>app.py</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello, Flask!"

if __name__ == "__main__":
    app.run(debug=True)
</code></pre>

    <ul>
        <li>Explanation:
            <ul>
                <li><code>Flask(__name__)</code> creates your web application object.</li>
                <li><code>@app.route("/")</code> maps the URL <code>/</code> to the function <code>home()</code>.</li>
                <li><code>debug=True</code> enables automatic reloading and developer-friendly errors.</li>
            </ul>
        </li>

        <br/>

        <li>Run it:</li>
    </ul>

<pre><code class="language-bash line-numbers">python3 app.py
</code></pre>

    <ul>
        <li>Visit <code>http://127.0.0.1:5000</code> in the browser.</li>
    </ul>
    <br/><br/>

    <li><b>Routing: Connecting URLs to Functions</b></li>
    <br/>
    <ul>
        <li>A <u>route</u> defines how your Flask application responds to a URL.</li>
        <li>Each route corresponds to a view function.</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/hello")
def greet():
    return "Hello!"
</code></pre>

    <br/>
    <ul>
        <li>You can define dynamic routes:</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/user/&lt;name&gt;")
def user(name):
    return f"User: {name}"
</code></pre>

    <br/>
    <ul>
        <li>Flask supports types:</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/square/&lt;int:num&gt;")
def square(num):
    return str(num * num)
</code></pre>
    <br/><br/>

    <li><b>Templates: Rendering HTML with Jinja2</b></li>
    <br/>
    <ul>
        <li>Flask includes the <u>Jinja2 templating engine</u> for generating HTML.</li>
        <li>Folder structure:</li>
    </ul>

<pre><code class="language-text line-numbers">project/
├── app.py
└── templates/
    └── index.html
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- templates/index.html --&gt;
&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;
</code></pre>

<pre><code class="language-python line-numbers">from flask import render_template

@app.route("/hello/&lt;name&gt;")
def hello(name):
    return render_template("index.html", name=name)
</code></pre>

    <br/>
    <ul>
        <li>Jinja2 allows loops, conditions, inheritance, and more.</li>
    </ul>
    <br/><br/>

    <li><b>Handling POST Requests</b></li>
    <br/>
    <ul>
        <li>By default, routes accept GET requests. To handle POST, specify the method:</li>
    </ul>

<pre><code class="language-python line-numbers">@app.route("/submit", methods=["GET", "POST"])
def submit():
    if request.method == "POST":
        data = request.form["username"]
        return f"Received: {data}"
    return "Send a POST request!"
</code></pre>

    <br/><br/>

    <li><b>Using JSON and Building APIs</b></li>
    <br/>
    <ul>
        <li>Flask makes it easy to build REST APIs or JSON endpoints:</li>
    </ul>

<pre><code class="language-python line-numbers">from flask import jsonify

@app.route("/api/user/&lt;int:id&gt;")
def api_user(id):
    return jsonify({"id": id, "name": "Alice"})
</code></pre>

    <br/>
    <ul>
        <li><code>jsonify</code> automatically converts Python dictionaries into JSON responses.</li>
    </ul>
    <br/><br/>

    <li><b>Flask Application Structure (Recommended Layout)</b></li>
    <br/>
    <ul>
        <li>For larger apps, organize code like this:</li>
    </ul>

<pre><code class="language-text line-numbers">myapp/
├── app.py
├── static/
│   └── style.css
├── templates/
│   ├── base.html
│   └── index.html
└── routes/
    └── home.py
</code></pre>

    <br/>
    <ul>
        <li>Flask doesn't force you into a rigid folder structure — this flexibility is one of its strengths.</li>
    </ul>
    <br/><br/>

    <li><b>Development vs. Production</b></li>
    <br/>
    <ul>
        <li>Flask's built-in development server is <b>not</b> meant for production.</li>
        <li>Use a WSGI server such as:
            <ul>
                <li>Gunicorn,</li>
                <li>uWSGI,</li>
                <li>Waitress (Windows).</li>
            </ul>
        </li>
        <li>Then run Flask under the WSGI server.</li>
    </ul>
    <br/><br/>

    <li><b>Flask Extensions (Powerful Add-ons)</b></li>

    <ul>
        <li><b>Flask-SQLAlchemy</b> — ORM for relational databases</li>
        <li><b>Flask-Migrate</b> — database migrations</li>
        <li><b>Flask-Login</b> — authentication and session management</li>
        <li><b>Flask-WTF</b> — form handling and CSRF protection</li>
        <li><b>Flask-Admin</b> — admin dashboard</li>
        <li><b>Flask-RESTful</b> — build REST APIs more easily</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-application-overview">Flask Application Overview</h3>
<ol>

    <li>What Is Flask?</li>
    <br/>
    <ul>
        <li><b>Flask</b> is a lightweight, flexible, and minimalistic Python web framework.</li>
        <br/>
        <li>It follows a <b>micro-framework</b> philosophy:
            <ul>
                <li>no built-in ORM</li>
                <li>no built-in template engine (uses Jinja2)</li>
                <li>no strict project structure</li>
                <li>everything is extensible via extensions</li>
            </ul>
        </li>
        <br/>
        <li>Flask is commonly used for:
            <ul>
                <li>REST APIs</li>
                <li>small to mid-sized web applications</li>
                <li>prototypes and rapid development</li>
                <li>microservices</li>
            </ul>
        </li>
        <br/>
        <li>Main advantages:
            <ul>
                <li>simple and intuitive API</li>
                <li>minimal boilerplate</li>
                <li>easy to integrate with SQLAlchemy, Jinja2, WTForms</li>
                <li>large ecosystem of extensions</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Installing and Running a Flask Application</li>
    <br/>
    <ul>
        <li>Install Flask via pip:</li>
<pre><code class="language-bash line-numbers">pip install Flask</code></pre>
        </li>
        <br/>
        <li>Minimal Flask app (<code>app.py</code>):</li>
<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello, Flask!"

if __name__ == "__main__":
    app.run(debug=True)</code></pre>
        </li>
        <br/>
        <li>Run the app:</li>
<pre><code class="language-bash line-numbers">python app.py</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding the Flask Application Object</li>
    <br/>
    <ul>
        <li>The <code>Flask</code> object represents your application.</li>
        <br/>
        <li>Created using:
<pre><code class="language-python line-numbers">app = Flask(__name__)</code></pre>
        </li>
        <br/>
        <li>Responsibilities:
            <ul>
                <li>handling incoming requests</li>
                <li>mapping URLs to functions (routing)</li>
                <li>managing application-wide configuration</li>
                <li>initializing extensions</li>
                <li>managing Jinja2 templates</li>
            </ul>
        </li>
        <br/>
        <li><code>__name__</code> helps Flask locate resources (templates, static files).</li>
    </ul>
    <br/><br/>


    <li>Routing Fundamentals</li>
    <br/>
    <ul>
        <li>Routes connect URLs to Python functions (called <b>view functions</b>).</li>
        <br/>
        <li>Basic route:</li>
<pre><code class="language-python line-numbers">@app.route("/about")
def about():
    return "About page"</code></pre>
        </li>
        <br/>
        <li>Routes can accept parameters:</li>
<pre><code class="language-python line-numbers">@app.route("/user/&lt;username&gt;")
def profile(username):
    return f"Hello, {username}"</code></pre>
        </li>
        <br/>
        <li>Routes can restrict parameter types:</li>
<pre><code class="language-python line-numbers">@app.route("/item/&lt;int:id&gt;")
def item(id):
    return f"Item {id}"</code></pre>
    </ul>
    <br/><br/>


    <li>Template Rendering</li>
    <br/>
    <ul>
        <li>Flask uses the Jinja2 template engine.</li>
        <br/>
        <li>Render templates:</li>
<pre><code class="language-python line-numbers">from flask import render_template

@app.route("/hello")
def hello():
    return render_template("hello.html", name="Junzhe")</code></pre>
        </li>
        <br/>
        <li>Example <code>templates/hello.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Hello {{ name }}!&lt;/h1&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Handling Requests and Forms</li>
    <br/>
    <ul>
        <li>Flask provides the <code>request</code> object:</li>
<pre><code class="language-python line-numbers">from flask import request

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username")
        return f"Logged in as {username}"
    return render_template("login.html")</code></pre>
        </li>
        <br/>
        <li>Use cases:
            <ul>
                <li>processing HTML forms</li>
                <li>AJAX requests</li>
                <li>JSON APIs</li>
            </ul>
        </li>
        <br/>
        <li>Accessing JSON:</li>
<pre><code class="language-python line-numbers">data = request.get_json()</code></pre>
    </ul>
    <br/><br/>


    <li>Flask Application Configuration</li>
    <br/>
    <ul>
        <li>Configuration values stored in <code>app.config</code>.</li>
        <br/>
        <li>Common settings:</li>
<pre><code class="language-plaintext line-numbers">DEBUG = True
SECRET_KEY = "super-secret"
DATABASE_URI = "sqlite:///app.db"
</code></pre>
        </li>
        <br/>
        <li>Load configuration from Python file:</li>
<pre><code class="language-python line-numbers">app.config.from_pyfile("config.py")</code></pre>
        </li>
        <br/>
        <li>Or from environment variables:</li>
<pre><code class="language-python line-numbers">app.config.from_envvar("APP_SETTINGS")</code></pre>
    </ul>
    <br/><br/>


    <li>Using Flask Extensions</li>
    <br/>
    <ul>
        <li>Flask achieves rich functionality through extensions:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Extension</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Flask-SQLAlchemy</code></td>
            <td>Object-relational mapping (ORM) for database models.</td>
        </tr>
        <tr>
            <td><code>Flask-Migrate</code></td>
            <td>Database migrations built on top of Alembic.</td>
        </tr>
        <tr>
            <td><code>Flask-WTF</code></td>
            <td>Form handling, validation, and CSRF protection.</td>
        </tr>
        <tr>
            <td><code>Flask-Login</code></td>
            <td>User authentication and session management.</td>
        </tr>
        <tr>
            <td><code>Flask-Mail</code></td>
            <td>Email sending integration for Flask applications.</td>
        </tr>
        <tr>
            <td><code>Flask-RESTful</code></td>
            <td>REST API framework for building JSON APIs.</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Extensions typically follow this pattern:</li>
<pre><code class="language-python line-numbers">db = SQLAlchemy()
login = LoginManager()

def create_app():
    app = Flask(__name__)
    db.init_app(app)
    login.init_app(app)
    return app
</code></pre>
    </ul>
    <br/><br/>


    <li>The Application Factory Pattern</li>
    <br/>
    <ul>
        <li>Large applications use a factory to create the app instance.</li>
        <br/>
        <li>Allows:
            <ul>
                <li>testing flexibility</li>
                <li>extension initialization</li>
                <li>different configurations</li>
            </ul>
        </li>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">def create_app(config_name="default"):
    app = Flask(__name__)
    app.config.from_object(config_name)
    return app
</code></pre>
    </ul>
    <br/><br/>


    <li>Blueprints (Modular Applications)</li>
    <br/>
    <ul>
        <li><b>Blueprints</b> allow you to break the application into reusable modules.</li>
        <br/>
        <li>Create a blueprint:</li>
<pre><code class="language-python line-numbers">from flask import Blueprint

bp = Blueprint("auth", __name__)

@bp.route("/login")
def login():
    return "Login page"
</code></pre>
        </li>
        <br/>
        <li>Register it:</li>
<pre><code class="language-python line-numbers">app.register_blueprint(bp, url_prefix="/auth")</code></pre>
    </ul>
    <br/><br/>


    <li>Static Files and Templates</li>
    <br/>
    <ul>
        <li>Default structure:</li>
<pre><code class="language-plaintext line-numbers">project/
    static/
        css/
        js/
        images/
    templates/
        .html files
</code></pre>
        </li>
        <br/>
        <li>Serve static files:</li>
<pre><code class="language-html line-numbers">&lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Error Handling</li>
    <br/>
    <ul>
        <li>Custom error pages:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def not_found(e):
    return render_template("404.html"), 404
</code></pre>
        </li>
        <br/>
        <li>Useful for user experience and debugging.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-routing">Flask Routing</h3>
<ol>

    <li>What Is Routing in Flask?</li>
    <br/>
    <ul>
        <li><b>Routing</b> is the mechanism that maps a URL path to a Python function (called a <b>view function</b>).</li>
        <br/>
        <li>The route determines:
            <ul>
                <li>which function handles which URL</li>
                <li>which HTTP methods are allowed</li>
                <li>how dynamic URL segments are parsed</li>
                <li>how parameters are passed to the function</li>
            </ul>
        </li>
        <br/>
        <li>Defined using the <code>@app.route()</code> decorator.</li>
        <br/>
        <li>Flask uses Werkzeug’s routing system under the hood.</li>
    </ul>
    <br/><br/>


    <li>Basic Route Definition</li>
    <br/>
    <ul>
        <li>Simplest route example:</li>
<pre><code class="language-python line-numbers">@app.route("/")
def home():
    return "Hello!"
</code></pre>
        </li>
        <br/>
        <li>Routes must return either:
            <ul>
                <li>a string</li>
                <li>a Response object</li>
                <li>a tuple (body, status code, headers)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Defining Routes with URLs</li>
    <br/>
    <ul>
        <li>Another simple example:</li>
<pre><code class="language-python line-numbers">@app.route("/about")
def about():
    return "About Page"
</code></pre>
        </li>
        <br/>
        <li>Flask automatically handles trailing slashes:
            <ul>
                <li><code>/about/</code> redirects to <code>/about</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Dynamic URL Parameters</li>
    <br/>
    <ul>
        <li>URLs can contain dynamic segments:</li>
<pre><code class="language-python line-numbers">@app.route("/user/&lt;username&gt;")
def profile(username):
    return f"User: {username}"
</code></pre>
        </li>
        <br/>
        <li>Example request:
<pre><code class="language-plaintext line-numbers">/user/junzhe</code></pre>
        </li>
        <br/>
        <li>Function receives:
<pre><code class="language-plaintext line-numbers">username = "junzhe"</code></pre>
        </li>
        <br/>
        <li>Available converters:
            <ul>
                <li><code>string</code> (default)</li>
                <li><code>int</code></li>
                <li><code>float</code></li>
                <li><code>path</code> (accepts slashes)</li>
                <li><code>uuid</code></li>
            </ul>
        </li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-python line-numbers">@app.route("/item/&lt;int:item_id&gt;")
def item(item_id):
    return f"Item ID = {item_id}"

@app.route("/files/&lt;path:filepath&gt;")
def files(filepath):
    return f"File Path = {filepath}"
</code></pre>
    </ul>
    <br/><br/>


    <li>URL Building with <code>url_for()</code></li>
    <br/>
    <ul>
        <li>Instead of hardcoding URLs, Flask encourages <code>url_for</code>:</li>
<pre><code class="language-python line-numbers">from flask import url_for

@app.route("/")
def index():
    return url_for("hello")

@app.route("/hello")
def hello():
    return "Hi!"
</code></pre>
        </li>
        <br/>
        <li>URL with parameters:</li>
<pre><code class="language-python line-numbers">url_for("profile", username="Alice")
</code></pre>
        </li>
        <br/>
        <li>Benefits:
            <ul>
                <li>automatic URL creation</li>
                <li>avoiding broken links</li>
                <li>routes remain consistent if changed later</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>HTTP Methods (GET, POST, etc.)</li>
    <br/>
    <ul>
        <li>Routes accept only GET by default.</li>
        <br/>
        <li>To enable POST or other methods:</li>
<pre><code class="language-python line-numbers">@app.route("/submit", methods=["POST"])
def submit():
    return "Form submitted"
</code></pre>
        </li>
        <br/>
        <li>Multiple methods:</li>
<pre><code class="language-python line-numbers">@app.route("/api/user", methods=["GET", "POST"])
def api_user():
    if request.method == "POST":
        return "Created"
    return "Listing users"
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Handling Query Parameters</li>
    <br/>
    <ul>
        <li>Access via <code>request.args</code>:</li>
<pre><code class="language-python line-numbers">from flask import request

@app.route("/search")
def search():
    keyword = request.args.get("q")
    return f"Keyword: {keyword}"
</code></pre>
        </li>
        <br/>
        <li>Example request:
<pre><code class="language-plaintext line-numbers">/search?q=python</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Route Defaults</li>
    <br/>
    <ul>
        <li>Set default values for parameters:</li>
<pre><code class="language-python line-numbers">@app.route("/page/&lt;int:num&gt;")
@app.route("/page", defaults={"num": 1})
def page(num):
    return f"Page {num}"
</code></pre>
        </li>
        <br/>
        <li>Useful for pagination or optional params.</li>
    </ul>
    <br/><br/>


    <li>Redirects</li>
    <br/>
    <ul>
        <li>Use <code>redirect</code> together with <code>url_for</code>:</li>
<pre><code class="language-python line-numbers">from flask import redirect

@app.route("/old")
def old():
    return redirect(url_for("new"))

@app.route("/new")
def new():
    return "This is the new page"
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Custom Error Routes</li>
    <br/>
    <ul>
        <li>Define custom error handlers:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def not_found(e):
    return "Page not found!", 404
</code></pre>
        </li>
        <br/>
        <li>Common handlers:
            <ul>
                <li>404 — Not Found</li>
                <li>500 — Server Error</li>
                <li>405 — Method Not Allowed</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Routing Inside Blueprints</li>
    <br/>
    <ul>
        <li>Blueprints let you group related routes.</li>
        <br/>
        <li>Create blueprint:</li>
<pre><code class="language-python line-numbers">from flask import Blueprint

auth = Blueprint("auth", __name__)

@auth.route("/login")
def login():
    return "Login Page"
</code></pre>
        </li>
        <br/>
        <li>Register blueprint:</li>
<pre><code class="language-python line-numbers">app.register_blueprint(auth, url_prefix="/auth")
</code></pre>
        </li>
        <br/>
        <li>Final route becomes:</li>
<pre><code class="language-plaintext line-numbers">/auth/login
</code></pre>
    </ul>
    <br/><br/>


    <li>Advanced Routing Features</li>
    <br/>
    <ul>
        <li>Custom URL Converters:</li>
<pre><code class="language-python line-numbers">from werkzeug.routing import BaseConverter

class EvenIntConverter(BaseConverter):
    regex = r"\d*[02468]"

app.url_map.converters["even"] = EvenIntConverter

@app.route("/number/&lt;even:n&gt;")
def even_number(n):
    return f"Even: {n}"
</code></pre>
        </li>
        <br/>
        <li>Subdomain Routing:</li>
<pre><code class="language-python line-numbers">@app.route("/", subdomain="api")
def api_home():
    return "API Home"
</code></pre>
        </li>
        <br/>
        <li>Strict Slash Control:</li>
<pre><code class="language-python line-numbers">@app.route("/users/", strict_slashes=False)
def users():
    return "Users"
</code></pre>
        </li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-variable-rules">Flask Variable Rules</h3>
<ol>

    <li>What Are Variable Rules in Flask?</li>
    <br/>
    <ul>
        <li>In Flask, <b>variable rules</b> let you capture parts of the URL as parameters and pass them into your view functions.</li>
        <br/>
        <li>They are defined directly inside the route pattern using angle brackets, such as <code>&lt;username&gt;</code> or <code>&lt;int:id&gt;</code>.</li>
        <br/>
        <li>Example idea:</li>
        <ul>
            <li><code>/user/junzhe</code> → passes <code>"junzhe"</code> to the view function</li>
            <li><code>/post/42</code> → passes <code>42</code> as an integer</li>
        </ul>
        <br/>
        <li>Variable rules make routes more dynamic and expressive, which is essential for REST-style APIs.</li>
    </ul>
    <br/><br/>


    <li>Basic Syntax of Variable Rules</li>
    <br/>
    <ul>
        <li>General pattern:</li>
<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)

@app.route('/user/&lt;username&gt;')
def show_user_profile(username):
    return f'User: {username}'
</code></pre>
        <br/>
        <li>Key points:</li>
        <ul>
            <li>Everything inside <code>&lt;...&gt;</code> is treated as a variable name.</li>
            <li>The variable name becomes a parameter of the view function.</li>
            <li>By default, the value is a <b>string</b>.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Built-In Converters</li>
    <br/>
    <ul>
        <li>Flask provides several converters to control the type and shape of URL variables:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Converter</th>
                    <th>Meaning</th>
                    <th>Example URL Rule</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>string</code></td>
                    <td>(default) any text without slashes</td>
                    <td><code>/hello/&lt;string:name&gt;</code></td>
                </tr>
                <tr>
                    <td><code>int</code></td>
                    <td>only integers</td>
                    <td><code>/post/&lt;int:post_id&gt;</code></td>
                </tr>
                <tr>
                    <td><code>float</code></td>
                    <td>floating-point numbers</td>
                    <td><code>/price/&lt;float:value&gt;</code></td>
                </tr>
                <tr>
                    <td><code>path</code></td>
                    <td>string including slashes</td>
                    <td><code>/files/&lt;path:subpath&gt;</code></td>
                </tr>
                <tr>
                    <td><code>uuid</code></td>
                    <td>UUID strings converted to <code>UUID</code> objects</td>
                    <td><code>/item/&lt;uuid:item_id&gt;</code></td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>Syntax with a converter:</li>
<pre><code class="language-python line-numbers">@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    # post_id is already an int
    return f'Post ID: {post_id}'
</code></pre>
    </ul>
    <br/><br/>


    <li>Default Converter: string</li>
    <br/>
    <ul>
        <li>If you omit a converter, Flask uses the <code>string</code> converter by default.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/hello/&lt;name&gt;')
def hello(name):
    # name is a string
    return f'Hello, {name}!'
</code></pre>
        <br/>
        <li>The following are equivalent:</li>
<pre><code class="language-python line-numbers">@app.route('/hello/&lt;name&gt;')
@app.route('/hello/&lt;string:name&gt;')
def hello(name):
    ...
</code></pre>
    </ul>
    <br/><br/>


    <li>Using the int Converter</li>
    <br/>
    <ul>
        <li>The <code>int</code> converter ensures that only integer values match the route.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    # If the URL is /post/abc, this route will NOT match.
    # If the URL is /post/42, post_id == 42 (int).
    return f'Post ID is {post_id}'
</code></pre>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>Automatic type conversion (string → int)</li>
            <li>More precise routing</li>
            <li>Invalid URLs (e.g. non-numeric IDs) return 404 instead of entering the view</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Using the float and path Converters</li>
    <br/>
    <ul>
        <li><b>float</b> converter:</li>
<pre><code class="language-python line-numbers">@app.route('/discount/&lt;float:rate&gt;')
def show_discount(rate):
    return f'Discount rate: {rate:.2f}'
</code></pre>
        <br/>
        <li><b>path</b> converter (includes slashes):</li>
<pre><code class="language-python line-numbers">@app.route('/files/&lt;path:subpath&gt;')
def show_file(subpath):
    # Matches /files/images/logo.png
    # subpath == 'images/logo.png'
    return f'Serving: {subpath}'
</code></pre>
        <br/>
        <li><code>path</code> is useful for nested directories or "catch-all" URLs.</li>
    </ul>
    <br/><br/>


    <li>Using the uuid Converter</li>
    <br/>
    <ul>
        <li>The <code>uuid</code> converter parses a standard UUID string into a Python <code>UUID</code> object.</li>
        <br/>
<pre><code class="language-python line-numbers">from uuid import UUID
from flask import Flask

app = Flask(__name__)

@app.route('/items/&lt;uuid:item_id&gt;')
def get_item(item_id: UUID):
    # item_id is a UUID instance, not a plain string
    return f'Item ID: {item_id}'
</code></pre>
        <br/>
        <li>This is very convenient for REST APIs that use UUIDs as primary identifiers.</li>
    </ul>
    <br/><br/>


    <li>Multiple Variable Rules in One Route</li>
    <br/>
    <ul>
        <li>You can define multiple variables inside the same URL pattern.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/shop/&lt;category&gt;/item/&lt;int:item_id&gt;')
def show_item(category, item_id):
    return f'Category: {category}, Item ID: {item_id}'
</code></pre>
        <br/>
        <li>Flask maps each variable to a separate function parameter in the same order as their appearance.</li>
        <br/>
        <li>Make sure the parameter names in the function <b>match exactly</b> the variable names in the route.</li>
    </ul>
    <br/><br/>


    <li>Variable Rules and url_for()</li>
    <br/>
    <ul>
        <li>When using <code>url_for()</code>, route variables become keyword arguments.</li>
        <br/>
<pre><code class="language-python line-numbers">from flask import url_for

@app.route('/user/&lt;username&gt;')
def profile(username):
    return f'Profile: {username}'

@app.route('/where-is-junzhe')
def where_is_junzhe():
    # Generates /user/Junzhe
    return url_for('profile', username='Junzhe')
</code></pre>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>No hardcoding of URLs</li>
            <li>URLs update automatically if the rule changes</li>
            <li>Safer refactoring</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Trailing Slashes and Variable Rules</li>
    <br/>
    <ul>
        <li>Flask treats routes with and without trailing slashes differently:</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/hello/&lt;name&gt;')    # no trailing slash
def hello(name):
    ...

@app.route('/hello2/&lt;name&gt;/')   # with trailing slash
def hello2(name):
    ...
</code></pre>
        <br/>
        <li>Behavior:</li>
        <ul>
            <li><code>/hello/Bob</code> → works</li>
            <li><code>/hello/Bob/</code> → 404 (by default)</li>
            <li><code>/hello2/Bob/</code> → works</li>
            <li><code>/hello2/Bob</code> → may redirect to <code>/hello2/Bob/</code></li>
        </ul>
        <br/>
        <li>Be consistent with your trailing slash style to avoid confusion.</li>
    </ul>
    <br/><br/>


    <li>Custom Converters (Overview)</li>
    <br/>
    <ul>
        <li>Flask allows you to create <b>custom converters</b> for more complex validation rules.</li>
        <br/>
        <li>Typical use cases:</li>
        <ul>
            <li>restricting strings to certain patterns (e.g. usernames, slugs)</li>
            <li>matching date formats</li>
            <li>matching serialized IDs</li>
        </ul>
        <br/>
        <li>Basic steps to create a custom converter:</li>
        <ul>
            <li>Subclass <code>werkzeug.routing.BaseConverter</code>.</li>
            <li>Register it on <code>app.url_map.converters</code>.</li>
            <li>Use it in routes like <code>&lt;custom:name&gt;</code>.</li>
        </ul>
        <br/>
        <li>Example (slug converter):</li>
<pre><code class="language-python line-numbers">from werkzeug.routing import BaseConverter

class SlugConverter(BaseConverter):
    regex = r'[a-z0-9-]+'

app.url_map.converters['slug'] = SlugConverter

@app.route('/blog/&lt;slug:post_slug&gt;')
def show_blog_post(post_slug):
    return f'Post slug: {post_slug}'
</code></pre>
        <br/>
        <li>Custom converters keep your routes clean and reusable.</li>
    </ul>
    <br/><br/>


    <li>Error Handling with Variable Rules</li>
    <br/>
    <ul>
        <li>If a URL does not match the variable rule, Flask returns a <b>404 Not Found</b> before entering your view.</li>
        <br/>
        <li>Examples:</li>
        <ul>
            <li><code>/post/abc</code> does not match <code>/post/&lt;int:post_id&gt;</code>, so Flask returns 404.</li>
            <li><code>/price/1.23</code> matches <code>/price/&lt;float:value&gt;</code>, but <code>/price/abc</code> does not.</li>
        </ul>
        <br/>
        <li>You can provide a custom 404 handler if you want more user-friendly messages.</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def page_not_found(e):
    return 'Custom 404 page', 404
</code></pre>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-url-building">Flask URL Building</h3>
<ol>

    <li>What Is URL Building in Flask?</li>
    <br/>
    <ul>
        <li><b>URL building</b> means generating URLs from view function names (endpoints) instead of hardcoding paths as strings.</li>
        <br/>
        <li>Flask provides the <code>url_for()</code> helper to build URLs based on:
            <ul>
                <li>the endpoint name (usually the view function name)</li>
                <li>any variable parts (path parameters)</li>
                <li>optional query parameters</li>
            </ul>
        </li>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>no hardcoded URL strings scattered in templates and Python code</li>
            <li>safer refactoring: renaming or changing routes in one place</li>
            <li>supports blueprints, static files, and external URLs</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Basic Usage of <code>url_for()</code> in Python</li>
    <br/>
    <ul>
        <li>Typical pattern inside your Python code:</li>
<pre><code class="language-python line-numbers">from flask import Flask, url_for

app = Flask(__name__)

@app.route('/')
def index():
    # Build URL for the 'hello' endpoint
    return url_for('hello')

@app.route('/hello')
def hello():
    return 'Hello!'
</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>'hello'</code> is the endpoint name (the function name by default).</li>
            <li><code>url_for('hello')</code> returns <code>'/hello'</code>.</li>
        </ul>
        <br/>
        <li>If you later change the route to <code>/greeting</code>, only the route definition needs updating, not every link in your app.</li>
    </ul>
    <br/><br/>


    <li>URL Building with Variable Rules</li>
    <br/>
    <ul>
        <li>For routes with path parameters, pass them as keyword arguments to <code>url_for()</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/user/&lt;username&gt;')
def profile(username):
    return f'Profile: {username}'

@app.route('/where-is-junzhe')
def where_is_junzhe():
    # Generates /user/Junzhe
    return url_for('profile', username='Junzhe')
</code></pre>
        <br/>
        <li>Important:</li>
        <ul>
            <li>Keyword names must match the variable names in the route (<code>username</code> in this example).</li>
            <li>Type converters (like <code>&lt;int:id&gt;</code>) are automatically handled as long as you pass compatible values.</li>
        </ul>
        <br/>
        <li>Example with an <code>int</code> converter:</li>
<pre><code class="language-python line-numbers">@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    return f'Post {post_id}'

url_for('show_post', post_id=42)   # '/post/42'
</code></pre>
    </ul>
    <br/><br/>


    <li>Adding Query Parameters with <code>url_for()</code></li>
    <br/>
    <ul>
        <li>Arguments that do <b>not</b> belong to the route pattern become query parameters:</li>
<pre><code class="language-python line-numbers">@app.route('/search')
def search():
    # Imagine we read request.args['q'] and request.args['page']
    ...

# In Python:
url_for('search', q='flask', page=2)
# Result: '/search?q=flask&amp;page=2'
</code></pre>
        <br/>
        <li>Notes:</li>
        <ul>
            <li>Flask automatically URL-encodes special characters (spaces, &amp;, etc.).</li>
            <li>Combine path variables and query parameters in one call.</li>
        </ul>
<pre><code class="language-python line-numbers">@app.route('/user/&lt;username&gt;/posts')
def user_posts(username):
    ...

url_for('user_posts', username='Junzhe', page=3, sort='latest')
# '/user/Junzhe/posts?page=3&amp;sort=latest'
</code></pre>
    </ul>
    <br/><br/>


    <li>Using <code>url_for()</code> in Templates (Jinja2)</li>
    <br/>
    <ul>
        <li>In Jinja2 templates, use <code>url_for</code> exactly like in Python:</li>
<pre><code class="language-html line-numbers">&lt;a href="{{ url_for('index') }}"&gt;Home&lt;/a&gt;

&lt;a href="{{ url_for('profile', username='Junzhe') }}"&gt;
    View profile
&lt;/a&gt;

&lt;a href="{{ url_for('search', q='flask', page=1) }}"&gt;
    Search for Flask
&lt;/a&gt;
</code></pre>
        <br/>
        <li>Advantages:</li>
        <ul>
            <li>Templates react automatically to route changes.</li>
            <li>Mixing logic (URL building) and HTML stays clean.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>URL Building for Static Files</li>
    <br/>
    <ul>
        <li>Flask automatically serves static files from the <code>static/</code> directory at the <code>/static</code> URL prefix.</li>
        <br/>
        <li>Use <code>url_for('static', ...)</code> to generate links to static resources:</li>
<pre><code class="language-html line-numbers">&lt;!-- In a Jinja2 template --&gt;
&lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" /&gt;

&lt;img src="{{ url_for('static', filename='images/logo.png') }}" alt="Logo" /&gt;
</code></pre>
        <br/>
        <li>Why not write <code>/static/css/style.css</code> directly?</li>
        <ul>
            <li>URL prefix can be changed in app configuration.</li>
            <li>Caches and versioning strategies sometimes modify static URLs.</li>
            <li><code>url_for</code> ensures all links stay correct.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Custom Endpoint Names</li>
    <br/>
    <ul>
        <li>You can override the default endpoint name (function name) using the <code>endpoint</code> argument in <code>route()</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/dashboard', endpoint='user_dashboard')
def show_dashboard():
    return 'Dashboard'

# URL building:
url_for('user_dashboard')   # '/dashboard'
</code></pre>
        <br/>
        <li>Use cases:</li>
        <ul>
            <li>multiple routes pointing to the same function but with different endpoint names</li>
            <li>avoiding name clashes (e.g. in large applications)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>URL Building with Blueprints</li>
    <br/>
    <ul>
        <li>When using blueprints, endpoint names automatically get a prefix: <code>'blueprint_name.view_function'</code>.</li>
<pre><code class="language-python line-numbers">from flask import Blueprint, url_for

bp = Blueprint('admin', __name__, url_prefix='/admin')

@bp.route('/users')
def user_list():
    ...

app.register_blueprint(bp)

# Building URL:
url_for('admin.user_list')    # '/admin/users'
</code></pre>
        <br/>
        <li>In templates, you use the same endpoint:</li>
<pre><code class="language-html line-numbers">&lt;a href="{{ url_for('admin.user_list') }}"&gt;Admin users&lt;/a&gt;
</code></pre>
        <br/>
        <li>Blueprint-aware URL building keeps your routes nicely namespaced.</li>
    </ul>
    <br/><br/>


    <li>Building Absolute URLs (<code>_external</code> and <code>_scheme</code>)</li>
    <br/>
    <ul>
        <li>By default, <code>url_for()</code> returns a <b>relative</b> path (e.g. <code>/user/Junzhe</code>).</li>
        <br/>
        <li>To build an absolute URL (including domain), use <code>_external=True</code>:</li>
<pre><code class="language-python line-numbers">with app.test_request_context():
    url_for('profile', username='Junzhe', _external=True)
    # e.g. 'http://localhost/user/Junzhe'
</code></pre>
        <br/>
        <li>To control the scheme (HTTP/HTTPS), use <code>_scheme</code>:</li>
<pre><code class="language-python line-numbers">with app.test_request_context():
    url_for('profile', username='Junzhe',
            _external=True, _scheme='https')
    # 'https://localhost/user/Junzhe'
</code></pre>
        <br/>
        <li>Absolute URLs are useful for:</li>
        <ul>
            <li>email links</li>
            <li>redirects to your site from external systems</li>
            <li>API callbacks and webhooks</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Using <code>url_for()</code> with <code>redirect()</code></li>
    <br/>
    <ul>
        <li>Flask’s <code>redirect()</code> often works together with <code>url_for()</code>:</li>
<pre><code class="language-python line-numbers">from flask import redirect, url_for

@app.route('/old-home')
def old_home():
    # Redirect to the new route
    return redirect(url_for('index'))

@app.route('/')
def index():
    return 'New homepage'
</code></pre>
        <br/>
        <li>This pattern allows you to:</li>
        <ul>
            <li>migrate URLs gradually</li>
            <li>avoid broken links</li>
            <li>implement login redirects, logout redirects, etc.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Common Pitfalls and Tips</li>
    <br/>
    <ul>
        <li>Mismatch between variable names and parameters:</li>
        <ul>
            <li>Route: <code>/user/&lt;username&gt;</code></li>
            <li><code>url_for('profile', name='Junzhe')</code> → error, should be <code>username</code>.</li>
        </ul>
        <br/>
        <li>Calling <code>url_for()</code> outside a request context: Use <code>with app.test_request_context():</code> in scripts or shell.</li>
        <br/>
        <li>Forgetting query parameters: Always encode filters, pagination, and sorting options via <code>url_for</code> to keep URLs consistent.</li>
        <br/>
        <li>General recommendation: never hardcode URLs when you can use <code>url_for()</code>.</li>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-http-methods">Flask HTTP Methods</h3>
<ol>

    <li>What Are HTTP Methods in Flask?</li>
    <br/>
    <ul>
        <li>HTTP methods define the action a client wants to perform when sending a request to a server.</li>
        <br/>
        <li>Flask allows each route to explicitly define which HTTP methods it accepts.</li>
        <br/>
        <li>If a request uses a method not allowed by the route, Flask returns <b>405 Method Not Allowed</b>.</li>
    </ul>
    <br/><br/>


    <li>Defining Allowed Methods in <code>@app.route()</code></li>
    <br/>
    <ul>
        <li>Use the <code>methods</code> parameter to specify allowed HTTP methods:</li>
<pre><code class="language-python line-numbers">@app.route('/submit', methods=['POST'])
def submit():
    return 'Form submitted!'
</code></pre>
        <br/>
        <li>If <code>methods</code> is not specified, Flask defaults to <b>GET</b>.</li>
        <br/>
        <li>Multiple allowed methods:</li>
<pre><code class="language-python line-numbers">@app.route('/user', methods=['GET', 'POST'])
def user():
    if request.method == 'POST':
        return 'Posted!'
    return 'User page'
</code></pre>
    </ul>
    <br/><br/>


    <li>GET Method</li>
    <br/>
    <ul>
        <li><b>GET</b> requests retrieve data from the server.</li>
        <br/>
        <li>Typical use cases:</li>
        <ul>
            <li>loading pages</li>
            <li>fetching API resources</li>
            <li>reading query parameters</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">@app.route('/hello')
def hello():
    return 'Hello, World!'
</code></pre>
        <br/>
        <li>GET requests can include query parameters such as <code>?page=2</code> via <code>request.args</code>.</li>
    </ul>
    <br/><br/>


    <li>POST Method</li>
    <br/>
    <ul>
        <li><b>POST</b> is used to submit data, often from forms or JSON clients.</li>
        <br/>
        <li>Reads data via <code>request.form</code> or <code>request.json</code>.</li>
        <br/>
        <li>Example using HTML form data:</li>
<pre><code class="language-python line-numbers">@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    return f'Logged in as {username}'
</code></pre>
        </li>
        <br/>
        <li>JSON POST example:</li>
<pre><code class="language-python line-numbers">@app.route('/api/data', methods=['POST'])
def api_data():
    data = request.json
    return {'received': data}
</code></pre>
        <br/>
        <li>POST is not idempotent — each call may create new data.</li>
    </ul>
    <br/><br/>


    <li>PUT Method</li>
    <br/>
    <ul>
        <li><b>PUT</b> replaces an entire resource.</li>
        <br/>
        <li>Often used in REST APIs.</li>
<pre><code class="language-python line-numbers">@app.route('/profile/&lt;int:id&gt;', methods=['PUT'])
def update_profile(id):
    data = request.json
    return {'id': id, 'updated_profile': data}
</code></pre>
        <br/>
        <li>PUT is idempotent: sending the same request multiple times results in the same final state.</li>
    </ul>
    <br/><br/>


    <li>PATCH Method</li>
    <br/>
    <ul>
        <li><b>PATCH</b> updates <b>part</b> of a resource.</li>
        <br/>
        <li>Used for partial modifications, such as updating a single field.</li>
<pre><code class="language-python line-numbers">@app.route('/profile/&lt;int:id&gt;', methods=['PATCH'])
def patch_profile(id):
    changes = request.json
    return {'id': id, 'changes': changes}
</code></pre>
        <br/>
        <li>PATCH is sometimes non-idempotent (depends on implementation).</li>
    </ul>
    <br/><br/>


    <li>DELETE Method</li>
    <br/>
    <ul>
        <li><b>DELETE</b> removes a resource.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">@app.route('/item/&lt;int:item_id&gt;', methods=['DELETE'])
def delete_item(item_id):
    return {'status': 'deleted', 'id': item_id}
</code></pre>
        <br/>
        <li>DELETE is idempotent — deleting the same resource twice yields the same result.</li>
    </ul>
    <br/><br/>


    <li>HEAD Method</li>
    <br/>
    <ul>
        <li><b>HEAD</b> returns headers only (no body).</li>
        <br/>
        <li>Used for:</li>
        <ul>
            <li>checking if a resource exists</li>
            <li>metadata queries</li>
            <li>lightweight monitoring</li>
        </ul>
        <br/>
        <li>Flask automatically provides a HEAD method for <b>every GET route</b>.</li>
        <br/>
        <li>No extra code needed:</li>
<pre><code class="language-python line-numbers">@app.route('/info')
def info():
    return 'data'
</code></pre>
        <br/>
        <li><code>HEAD /info</code> → same headers, empty body.</li>
    </ul>
    <br/><br/>


    <li>OPTIONS Method</li>
    <br/>
    <ul>
        <li><b>OPTIONS</b> asks the server which HTTP methods are supported.</li>
        <br/>
        <li>Flask automatically provides an OPTIONS response for every route.</li>
        <br/>
        <li>Useful for:
            <ul>
                <li>CORS preflight checks</li>
                <li>API clients</li>
            </ul>
        </li>
        <br/>
        <li>Example client request:</li>
<pre><code class="language-text line-numbers">OPTIONS /user
</code></pre>
    </ul>
    <br/><br/>


    <li>Handling Different Methods Inside a Single View</li>
    <br/>
    <ul>
        <li>You can check the incoming method using <code>request.method</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/settings', methods=['GET', 'POST'])
def settings():
    if request.method == 'POST':
        return 'Settings updated'
    return 'Settings page'
</code></pre>
        <br/>
        <li>Useful for pages that show a form (GET) and process it (POST).</li>
    </ul>
    <br/><br/>


    <li>Using <code>@app.get</code>, <code>@app.post</code>, <code>@app.put</code> (Shorthand Decorators)</li>
    <br/>
    <ul>
        <li>Starting from Flask 2.0, convenient decorators were added:</li>
<pre><code class="language-python line-numbers">@app.get('/hello')
def hello():
    return 'GET request'

@app.post('/submit')
def submit():
    return 'POST request'

@app.delete('/remove/&lt;int:id&gt;')
def remove(id):
    return f'Removed {id}'
</code></pre>
        <br/>
        <li>Each shortcut decorator is equivalent to <code>@app.route(..., methods=['...'])</code>.</li>
    </ul>
    <br/><br/>


    <li>Method-Specific Routing Examples</li>
    <br/>
    <ul>
        <li><b>RESTful user API example:</b></li>
<pre><code class="language-python line-numbers">@app.route('/users', methods=['GET'])
def list_users():
    return 'List users'

@app.route('/users', methods=['POST'])
def create_user():
    return 'Create user'

@app.route('/users/&lt;int:id&gt;', methods=['GET'])
def get_user(id):
    return f'Get user {id}'

@app.route('/users/&lt;int:id&gt;', methods=['PUT'])
def update_user(id):
    return f'Update user {id}'

@app.route('/users/&lt;int:id&gt;', methods=['DELETE'])
def delete_user(id):
    return f'Delete user {id}'
</code></pre>
        <br/>
        <li>This style is common for building full REST APIs.</li>
    </ul>
    <br/><br/>


    <li>405 Method Not Allowed</li>
    <br/>
    <ul>
        <li>If a method is not allowed on a route, Flask returns <b>405</b>.</li>
        <br/>
        <li>Example:</li>
        <ul>
            <li>Route: <code>/login</code> only accepts POST.</li>
            <li>Sending GET → Flask responds 405.</li>
        </ul>
        <br/>
        <li>Flask also includes an <code>Allow</code> header showing valid methods.</li>
    </ul>
    <br/><br/>


    <li>Summary Table of HTTP Methods</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Purpose</th>
                <th>Idempotent?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>GET</b></td>
                <td>Retrieve data</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>POST</b></td>
                <td>Create or submit data</td>
                <td>No</td>
            </tr>
            <tr>
                <td><b>PUT</b></td>
                <td>Replace entire resource</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>PATCH</b></td>
                <td>Modify part of resource</td>
                <td>Sometimes</td>
            </tr>
            <tr>
                <td><b>DELETE</b></td>
                <td>Remove resource</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>HEAD</b></td>
                <td>Headers only</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><b>OPTIONS</b></td>
                <td>Discover supported methods</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-templates">Flask Templates</h3>
<ol>

    <li>What Are Templates in Flask?</li>
    <br/>
    <ul>
        <li>Templates in Flask allow you to generate dynamic HTML by mixing static markup with dynamic Python data.</li>
        <br/>
        <li>Flask uses the <b>Jinja2</b> templating engine, which supports:</li>
        <ul>
            <li>variables</li>
            <li>control structures (if, for)</li>
            <li>template inheritance</li>
            <li>filters</li>
            <li>macros and blocks</li>
        </ul>
        <br/>
        <li>Templates help separate:
            <ul>
                <li><b>application logic</b> (Python)</li>
                <li><b>presentation logic</b> (HTML)</li>
            </ul>
        </li>
        <br/>
        <li>By default, Flask looks for template files inside the <code>templates/</code> folder.</li>
    </ul>
    <br/><br/>


    <li>Setting Up the Templates Folder</li>
    <br/>
    <ul>
        <li>Project structure:</li>
<pre><code class="language-plaintext line-numbers">project/
    app.py
    templates/
        index.html
        about.html
</code></pre>
        <br/>
        <li>Flask will automatically search <code>templates/</code> for rendering files.</li>
    </ul>
    <br/><br/>


    <li>Rendering Templates with <code>render_template()</code></li>
    <br/>
    <ul>
        <li>Import and use <code>render_template</code>:</li>
<pre><code class="language-python line-numbers">from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')
</code></pre>
        <br/>
        <li>Flask finds <code>templates/index.html</code> automatically.</li>
    </ul>
    <br/><br/>


    <li>Passing Data to Templates</li>
    <br/>
    <ul>
        <li>Pass variables as keyword arguments:</li>
<pre><code class="language-python line-numbers">@app.route('/user/&lt;name&gt;')
def user_profile(name):
    return render_template('profile.html', username=name)
</code></pre>
        <br/>
        <li>Inside <code>profile.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Hello, {{ username }}!&lt;/h1&gt;
</code></pre>
        <br/>
        <li>Flask automatically injects variables into the Jinja2 context.</li>
    </ul>
    <br/><br/>


    <li>Jinja2 Template Syntax: Variables</li>
    <br/>
    <ul>
        <li>Variables are written using double curly braces:</li>
<pre><code class="language-html line-numbers">&lt;p&gt;Welcome, {{ user }}!&lt;/p&gt;
</code></pre>
        <br/>
        <li>Objects and attributes:</li>
<pre><code class="language-html line-numbers">&lt;p&gt;Your score: {{ stats.score }}&lt;/p&gt;
</code></pre>
        <br/>
        <li>Filter usage:</li>
<pre><code class="language-html line-numbers">&lt;p&gt;Uppercased: {{ username|upper }}&lt;/p&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Jinja2 Control Structures</li>
    <br/>
    <ul>
        <li>Use <code>{% ... %}</code> for logic blocks.</li>
        <br/>
        <li><b>If</b> statement:</li>
<pre><code class="language-html line-numbers">{% if is_admin %}
    &lt;p&gt;Welcome, admin!&lt;/p&gt;
{% else %}
    &lt;p&gt;Welcome, user!&lt;/p&gt;
{% endif %}
</code></pre>
        <br/>
        <li><b>For</b> loop:</li>
<pre><code class="language-html line-numbers">&lt;ul&gt;
{% for item in items %}
    &lt;li&gt;{{ item }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Template Inheritance</li>
    <br/>
    <ul>
        <li>Create a base template to avoid repeating common layout:</li>
<pre><code class="language-html line-numbers">&lt;!-- templates/base.html --&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{% block title %}My Site{% endblock %}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;Header content&lt;/header&gt;

    {% block content %}{% endblock %}

    &lt;footer&gt;Footer&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
        <br/>
        <li>Extend it in other templates:</li>
<pre><code class="language-html line-numbers">{% extends 'base.html' %}

{% block title %}Homepage{% endblock %}

{% block content %}
    &lt;h1&gt;Welcome to the homepage&lt;/h1&gt;
{% endblock %}
</code></pre>
        <br/>
        <li>Template inheritance keeps your project DRY and organized.</li>
    </ul>
    <br/><br/>


    <li>Using Layout Blocks</li>
    <br/>
    <ul>
        <li>Common blocks include:</li>
        <ul>
            <li><code>block title</code></li>
            <li><code>block content</code></li>
            <li><code>block scripts</code></li>
        </ul>
        <br/>
        <li>Block example:</li>
<pre><code class="language-html line-numbers">{% block scripts %}
&lt;script src="{{ url_for('static', filename='js/app.js') }}"&gt;&lt;/script&gt;
{% endblock %}
</code></pre>
    </ul>
    <br/><br/>


    <li>Using Static Files Inside Templates</li>
    <br/>
    <ul>
        <li>Static files live in the <code>static/</code> folder:</li>
<pre><code class="language-plaintext line-numbers">project/
    static/
        css/
        js/
        images/
</code></pre>
        <br/>
        <li>Use <code>url_for()</code> to link them:</li>
<pre><code class="language-html line-numbers">&lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" /&gt;
&lt;img src="{{ url_for('static', filename='images/logo.png') }}" /&gt;
</code></pre>
        <br/>
        <li>Never hardcode <code>/static/...</code> manually.</li>
    </ul>
    <br/><br/>


    <li>Template Filters</li>
    <br/>
    <ul>
        <li>Filters modify values inside templates.</li>
        <br/>
        <li>Common filters:</li>
        <ul>
            <li><code>upper</code> – uppercase text</li>
            <li><code>lower</code> – lowercase</li>
            <li><code>length</code> – length of iterable</li>
            <li><code>safe</code> – mark HTML as safe</li>
            <li><code>join</code> – join lists</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-html line-numbers">{{ ['A', 'B', 'C']|join(', ') }}
</code></pre>
        <br/>
        <li>You can also create custom filters.</li>
    </ul>
    <br/><br/>


    <li>Including Templates</li>
    <br/>
    <ul>
        <li>You can include reusable HTML fragments:</li>
<pre><code class="language-html line-numbers">{% include 'sidebar.html' %}
</code></pre>
        <br/>
        <li>Useful for:
            <ul>
                <li>navigation menus</li>
                <li>headers/footers when not using inheritance</li>
                <li>modular UI components</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Escaping and Safe Rendering</li>
    <br/>
    <ul>
        <li>Jinja2 autoescapes HTML to prevent XSS attacks.</li>
        <br/>
        <li>HTML rendered from variables is escaped:</li>
<pre><code class="language-html line-numbers">{{ user_input }}
</code></pre>
        <br/>
        <li>To render raw HTML, use <code>|safe</code>:</li>
<pre><code class="language-html line-numbers">{{ html_content|safe }}
</code></pre>
        <br/>
        <li>Use <code>safe</code> with caution.</li>
    </ul>
    <br/><br/>


    <li>Macros in Templates</li>
    <br/>
    <ul>
        <li>Macros let you create reusable template functions:</li>
<pre><code class="language-html line-numbers">{% macro button(text) %}
&lt;button&gt;{{ text }}&lt;/button&gt;
{% endmacro %}
</code></pre>
        <br/>
        <li>Call the macro:</li>
<pre><code class="language-html line-numbers">{{ button('Click me') }}
</code></pre>
        <br/>
        <li>Macros improve reusability inside templates.</li>
    </ul>
    <br/><br/>


    <li>Template Comments</li>
    <br/>
    <ul>
        <li>Comment inside Jinja2 with:</li>
<pre><code class="language-html line-numbers">{# This is a comment #}
</code></pre>
        <br/>
        <li>Comments do not appear in the output HTML.</li>
    </ul>
    <br/><br/>


    <li>Using <code>url_for()</code> in Templates</li>
    <br/>
    <ul>
        <li><code>url_for</code> is available directly in every template.</li>
        <br/>
        <li>Example with arguments:</li>
<pre><code class="language-html line-numbers">&lt;a href="{{ url_for('profile', username='Junzhe') }}"&gt;
    View Profile
&lt;/a&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Custom Template Folders</li>
    <br/>
    <ul>
        <li>You can override the default folder:</li>
<pre><code class="language-python line-numbers">app = Flask(__name__, template_folder='views')
</code></pre>
        <br/>
        <li>This allows project-specific organization.</li>
    </ul>
    <br/><br/>


    <li>Rendering Non-HTML Templates</li>
    <br/>
    <ul>
        <li>Templates can render any text-based output:</li>
        <ul>
            <li>XML</li>
            <li>JSON</li>
            <li>Emails</li>
            <li>Markdown</li>
        </ul>
        <br/>
        <li>Example rendering XML:</li>
<pre><code class="language-python line-numbers">@app.route('/sitemap')
def sitemap():
    return render_template('sitemap.xml')
</code></pre>
    </ul>
    <br/><br/>


    <li>Common Mistakes and Best Practices</li>
    <br/>
    <ul>
        <li><b>Always</b> use <code>url_for()</code> for links to avoid broken URLs.</li>
        <br/>
        <li>Use <b>template inheritance</b> for consistent layouts.</li>
        <br/>
        <li>Keep templates clean and move logic to Python whenever possible.</li>
        <br/>
        <li>Store reusable HTML in partials and include them.</li>
        <br/>
        <li>Use custom filters/macros for repeated formatting patterns.</li>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-static-files">Flask Static Files</h3>
<ol>

    <li>What Are Static Files in Flask?</li>
    <br/>
    <ul>
        <li><b>Static files</b> are files that do not change dynamically and are served directly to the client.</li>
        <br/>
        <li>These include:
            <ul>
                <li>CSS files</li>
                <li>JavaScript files</li>
                <li>Images (PNG, JPG, SVG)</li>
                <li>Fonts (TTF, WOFF)</li>
                <li>Static HTML assets</li>
            </ul>
        </li>
        <br/>
        <li>Flask automatically serves static files located inside the <code>static/</code> directory.</li>
        <br/>
        <li>The static folder is essential for building complete web applications with styles and scripts.</li>
    </ul>
    <br/><br/>


    <li>Default Static Folder Structure</li>
    <br/>
    <ul>
        <li>This is the recommended project layout:</li>
<pre><code class="language-plaintext line-numbers">project/
    app.py
    static/
        css/
            style.css
        js/
            app.js
        images/
            logo.png
    templates/
        index.html
</code></pre>
        <br/>
        <li>Flask automatically maps <code>/static/... </code> to the <code>static/</code> directory.</li>
    </ul>
    <br/><br/>


    <li>Using <code>url_for()</code> to Link Static Files</li>
    <br/>
    <ul>
        <li>Never hardcode <code>/static/</code> paths manually — always use <code>url_for</code>.</li>
        <br/>
<pre><code class="language-html line-numbers">&lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" /&gt;

&lt;script src="{{ url_for('static', filename='js/app.js') }}"&gt;&lt;/script&gt;

&lt;img src="{{ url_for('static', filename='images/logo.png') }}" alt="Logo" /&gt;
</code></pre>
        <br/>
        <li><code>url_for('static', filename=...)</code> ensures URLs stay correct even if the static folder or configuration changes.</li>
    </ul>
    <br/><br/>


    <li>Serving Static Files Automatically</li>
    <br/>
    <ul>
        <li>Flask automatically registers a route:</li>
<pre><code class="language-plaintext line-numbers">/static/&lt;path:filename&gt;
</code></pre>
        <br/>
        <li>This handles requests like:</li>
        <ul>
            <li><code>/static/css/style.css</code></li>
            <li><code>/static/js/app.js</code></li>
            <li><code>/static/images/logo.png</code></li>
        </ul>
        <br/>
        <li>No extra code is needed to serve static files.</li>
    </ul>
    <br/><br/>


    <li>Using Static Files in Templates</li>
    <br/>
    <ul>
        <li>Typical HTML template including CSS and JS:</li>
<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" /&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;Welcome&lt;/h1&gt;
    &lt;script src="{{ url_for('static', filename='js/app.js') }}"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
        <br/>
        <li>Static files help define the styling and behavior of web pages.</li>
    </ul>
    <br/><br/>


    <li>Customizing the Static Folder Location</li>
    <br/>
    <ul>
        <li>You can change the default <code>static/</code> folder:</li>
<pre><code class="language-python line-numbers">app = Flask(__name__, static_folder='public_static')
</code></pre>
        <br/>
        <li>Custom static URL path:</li>
<pre><code class="language-python line-numbers">app = Flask(__name__, static_url_path='/assets')
</code></pre>
        <br/>
        <li>Now static files live at:</li>
<pre><code class="language-plaintext line-numbers">/assets/...
</code></pre>
        <br/>
        <li>Example combining both:</li>
<pre><code class="language-python line-numbers">app = Flask(
    __name__,
    static_folder='public',
    static_url_path='/static-files'
)
</code></pre>
        <br/>
        <li>This provides full control over deployment structure.</li>
    </ul>
    <br/><br/>


    <li>Serving Static Files Manually (Advanced)</li>
    <br/>
    <ul>
        <li>Flask provides <code>send_from_directory()</code> for custom static folders.</li>
<pre><code class="language-python line-numbers">from flask import send_from_directory

@app.route('/media/&lt;path:filename&gt;')
def media(filename):
    return send_from_directory('uploads', filename)
</code></pre>
        <br/>
        <li>Use cases:</li>
        <ul>
            <li>uploaded user files</li>
            <li>exported reports</li>
            <li>protected/static-like content</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Static Files Versioning (Cache-Busting)</li>
    <br/>
    <ul>
        <li>Browsers cache static files aggressively.</li>
        <br/>
        <li>To avoid stale caches, use <code>url_for()</code> with a timestamp or version:</li>
<pre><code class="language-html line-numbers">&lt;script src="{{ url_for('static', filename='js/app.js', v=1) }}"&gt;&lt;/script&gt;
</code></pre>
        <br/>
        <li>Resulting URL:</li>
<pre><code class="language-plaintext line-numbers">/static/js/app.js?v=1
</code></pre>
        <br/>
        <li>You can automate this with hashed filenames during deployment.</li>
    </ul>
    <br/><br/>


    <li>Using Static Files in Blueprints</li>
    <br/>
    <ul>
        <li>Blueprints can have their own static folders:</li>
<pre><code class="language-python line-numbers">admin_bp = Blueprint(
    'admin',
    __name__,
    static_folder='static',
    static_url_path='/admin-static'
)
</code></pre>
        <br/>
        <li>Blueprint static file example:</li>
<pre><code class="language-html line-numbers">&lt;img src="{{ url_for('admin.static', filename='images/icon.png') }}" /&gt;
</code></pre>
        <br/>
        <li>This allows module-based static asset organization.</li>
    </ul>
    <br/><br/>


    <li>Static vs Template Files (Important Distinction)</li>
    <br/>
    <ul>
        <li><b>templates/</b>:
            <ul>
                <li>Dynamic content</li>
                <li>Processed by Jinja2</li>
                <li>Rendered with variables</li>
            </ul>
        </li>
        <br/>
        <li><b>static/</b>:
            <ul>
                <li>Unprocessed raw files</li>
                <li>Delivered directly to the browser</li>
                <li>Cannot contain Jinja2 code</li>
            </ul>
        </li>
        <br/>
        <li>You should place:
            <ul>
                <li>HTML → <code>templates/</code></li>
                <li>CSS/JS/Images → <code>static/</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Favicon Handling</li>
    <br/>
    <ul>
        <li>Place your favicon inside <code>static/</code>:</li>
<pre><code class="language-plaintext line-numbers">static/favicon.ico
</code></pre>
        <br/>
        <li>Link in <code>base.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" /&gt;
</code></pre>
        <br/>
        <li>Browsers automatically request <code>/favicon.ico</code>, so some apps map it directly:</li>
<pre><code class="language-python line-numbers">@app.route('/favicon.ico')
def favicon():
    return send_from_directory('static', 'favicon.ico')
</code></pre>
    </ul>
    <br/><br/>


    <li>Best Practices for Static Files</li>
    <br/>
    <ul>
        <li>Always use <code>url_for</code> when referencing static files.</li>
        <br/>
        <li>Organize static assets into folders:
            <ul>
                <li><code>css/</code></li>
                <li><code>js/</code></li>
                <li><code>images/</code></li>
                <li><code>fonts/</code></li>
            </ul>
        </li>
        <br/>
        <li>Use blueprint static folders for modular apps.</li>
        <br/>
        <li>Enable caching but use versioning for updates.</li>
        <br/>
        <li>Serve large media/downloads using <code>send_from_directory</code>.</li>
        <br/>
        <li>Do not expose sensitive files inside the static directory.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-request-object">Flask Request Object</h3>
<ol>

    <li>What Is the Flask Request Object?</li>
    <br/>
    <ul>
        <li>The <code>request</code> object in Flask provides access to all data sent by the client (browser, API client, etc.).</li>
        <br/>
        <li>It includes:
            <ul>
                <li>HTTP method</li>
                <li>Form data</li>
                <li>JSON payload</li>
                <li>Headers</li>
                <li>Cookies</li>
                <li>URL parameters</li>
                <li>Uploaded files</li>
                <li>Client IP</li>
            </ul>
        </li>
        <br/>
        <li>Import it from Flask:</li>
<pre><code class="language-python line-numbers">from flask import request</code></pre>
        <br/>
        <li>The request object is context-aware, meaning it only exists during an active request.</li>
    </ul>
    <br/><br/>


    <li>Accessing HTTP Methods</li>
    <br/>
    <ul>
        <li>Check the method used by the client:</li>
<pre><code class="language-python line-numbers">@app.route('/submit', methods=['GET', 'POST'])
def submit():
    return f"Method used: {request.method}"
</code></pre>
        <br/>
        <li>Common values:
            <ul>
                <li><code>GET</code></li>
                <li><code>POST</code></li>
                <li><code>PUT</code></li>
                <li><code>PATCH</code></li>
                <li><code>DELETE</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Reading Query Parameters (<code>request.args</code>)</li>
    <br/>
    <ul>
        <li>Query parameters come from the URL, e.g. <code>?page=3&amp;sort=asc</code>.</li>
        <br/>
        <li>Use <code>request.args</code> to access them:</li>
<pre><code class="language-python line-numbers">@app.route('/search')
def search():
    query = request.args.get('q')
    page = request.args.get('page', default=1, type=int)
    return f"Search: {query}, Page: {page}"
</code></pre>
        <br/>
        <li><code>request.args</code> is a <b>MultiDict</b> — it supports duplicate keys.</li>
    </ul>
    <br/><br/>


    <li>Reading Form Data (<code>request.form</code>)</li>
    <br/>
    <ul>
        <li>Form data comes from POST requests with <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code>.</li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form.get('password')
    return f"User: {username}"
</code></pre>
        <br/>
        <li><code>request.form</code> is also a MultiDict.</li>
    </ul>
    <br/><br/>


    <li>Reading JSON Data (<code>request.json</code>)</li>
    <br/>
    <ul>
        <li>For clients sending JSON (<code>application/json</code>):</li>
<pre><code class="language-python line-numbers">@app.route('/api/data', methods=['POST'])
def api_data():
    data = request.json      # or request.get_json()
    return {'received': data}
</code></pre>
        <br/>
        <li>Good for RESTful APIs.</li>
    </ul>
    <br/><br/>


    <li>Accessing Form and JSON Together (<code>request.values</code>)</li>
    <br/>
    <ul>
        <li><code>request.values</code> merges:
            <ul>
                <li><code>request.form</code></li>
                <li><code>request.args</code></li>
            </ul>
        </li>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/combined')
def combined():
    return request.values.get('key')
</code></pre>
        <br/>
        <li>Useful when a value may come from GET or POST.</li>
    </ul>
    <br/><br/>


    <li>Accessing Headers (<code>request.headers</code>)</li>
    <br/>
    <ul>
        <li>Retrieve client or browser headers:</li>
<pre><code class="language-python line-numbers">@app.route('/agent')
def agent():
    ua = request.headers.get('User-Agent')
    return f"Your browser: {ua}"
</code></pre>
        <br/>
        <li>Common headers:
            <ul>
                <li><code>Content-Type</code></li>
                <li><code>User-Agent</code></li>
                <li><code>Accept</code></li>
                <li><code>Authorization</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Accessing Cookies (<code>request.cookies</code>)</li>
    <br/>
    <ul>
        <li>Client cookies are handled via <code>request.cookies</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/show-cookie')
def show_cookie():
    token = request.cookies.get('auth_token')
    return f"Cookie: {token}"
</code></pre>
        <br/>
        <li>Cookies can be set in responses (covered in <i>Flask Responses</i> chapter).</li>
    </ul>
    <br/><br/>


    <li>Handling File Uploads (<code>request.files</code>)</li>
    <br/>
    <ul>
        <li>To handle uploaded files from forms:</li>
<pre><code class="language-python line-numbers">@app.route('/upload', methods=['POST'])
def upload():
    file = request.files['photo']
    file.save(f"uploads/{file.filename}")
    return 'Uploaded!'
</code></pre>
        <br/>
        <li>Form requires <code>enctype="multipart/form-data"</code>.</li>
    </ul>
    <br/><br/>


    <li>Reading Route Variables (<code>request.view_args</code>)</li>
    <br/>
    <ul>
        <li>For URLs with variable rules like:</li>
<pre><code class="language-python line-numbers">@app.route('/user/&lt;username&gt;')
def profile(username):
    print(request.view_args)  # {'username': 'Junzhe'}
    return username
</code></pre>
        <br/>
        <li><code>view_args</code> contains the path parameters.</li>
    </ul>
    <br/><br/>


    <li>Getting the Full Request URL</li>
    <br/>
    <ul>
        <li>You can access:</li>
        <ul>
            <li>Full URL — <code>request.url</code></li>
            <li>Base URL — <code>request.base_url</code></li>
            <li>Host URL — <code>request.host_url</code></li>
            <li>URL without query — <code>request.path</code></li>
        </ul>
        <br/>
<pre><code class="language-python line-numbers">@app.route('/info')
def info():
    return {
        "url": request.url,
        "path": request.path,
        "base": request.base_url,
    }
</code></pre>
    </ul>
    <br/><br/>


    <li>Accessing Client IP Address</li>
    <br/>
    <ul>
        <li>Get client IP:</li>
<pre><code class="language-python line-numbers">ip = request.remote_addr</code></pre>
        <br/>
        <li>If behind a proxy, use:</li>
<pre><code class="language-python line-numbers">ip = request.headers.get('X-Forwarded-For', request.remote_addr)</code></pre>
        <br/>
        <li>Often needed for:
            <ul>
                <li>logging</li>
                <li>rate limiting</li>
                <li>security</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Detecting AJAX Requests</li>
    <br/>
    <ul>
        <li>Traditional AJAX requests include a header:</li>
<pre><code class="language-python line-numbers">is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
</code></pre>
        <br/>
        <li>Modern clients often use <code>fetch()</code> without this header, so custom headers may be needed.</li>
    </ul>
    <br/><br/>


    <li>Checking MIME Types</li>
    <br/>
    <ul>
        <li>Access incoming request content type:</li>
<pre><code class="language-python line-numbers">@app.route('/type', methods=['POST'])
def content_type():
    return request.content_type
</code></pre>
        <br/>
        <li>Common MIME types:</li>
        <ul>
            <li><code>application/json</code></li>
            <li><code>application/x-www-form-urlencoded</code></li>
            <li><code>multipart/form-data</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li>Working with Request Data Safely</li>
    <br/>
    <ul>
        <li>Use <code>.get()</code> when values may be missing.</li>
        <br/>
        <li>Prefer <code>request.get_json()</code> over <code>request.json</code> when needing error handling.</li>
        <br/>
        <li>Validate all user input (form, JSON, files).</li>
        <br/>
        <li>Never trust <code>request.headers</code> from the client.</li>
    </ul>
    <br/><br/>


    <li>Summary Table of Common Attributes</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Attribute</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>request.method</code></td>
                <td>HTTP method</td>
            </tr>
            <tr>
                <td><code>request.args</code></td>
                <td>Query parameters</td>
            </tr>
            <tr>
                <td><code>request.form</code></td>
                <td>Form POST data</td>
            </tr>
            <tr>
                <td><code>request.json</code></td>
                <td>JSON payload</td>
            </tr>
            <tr>
                <td><code>request.files</code></td>
                <td>Uploaded files</td>
            </tr>
            <tr>
                <td><code>request.headers</code></td>
                <td>HTTP headers</td>
            </tr>
            <tr>
                <td><code>request.cookies</code></td>
                <td>Client cookies</td>
            </tr>
            <tr>
                <td><code>request.view_args</code></td>
                <td>Route variables</td>
            </tr>
            <tr>
                <td><code>request.url</code></td>
                <td>Full URL</td>
            </tr>
            <tr>
                <td><code>request.remote_addr</code></td>
                <td>Client IP</td>
            </tr>
        </tbody>
    </table>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-sending-form-data-to-template">Flask Sending Form Data to Template</h3>
<ol>

    <li>What Does It Mean to Send Form Data to a Template?</li>
    <br/>
    <ul>
        <li>After a user submits a form (usually via POST), the server receives the data inside <code>request.form</code>.</li>
        <br/>
        <li>To display this submitted data back to the user, you pass it from the route into <code>render_template()</code>.</li>
        <br/>
        <li>This is common for:
            <ul>
                <li>login forms</li>
                <li>registration pages</li>
                <li>profile updates</li>
                <li>search forms</li>
                <li>contact or feedback forms</li>
            </ul>
        </li>
        <br/>
        <li>Flask makes this very easy thanks to the <b>request object</b> and Jinja2 template rendering.</li>
    </ul>
    <br/><br/>


    <li>Typical Workflow for Sending Form Data</li>
    <br/>
    <ul>
        <li>The workflow usually looks like this:</li>
        <br/>
        <ol>
            <li>User fills a form in an HTML template.</li>
            <li>Browser sends a POST request.</li>
            <li>Flask receives the form data via <code>request.form</code>.</li>
            <li>Flask passes this data to another template using <code>render_template()</code>.</li>
            <li>Template displays the submitted values.</li>
        </ol>
    </ul>
    <br/><br/>


    <li>Creating a Simple Form in a Template</li>
    <br/>
    <ul>
        <li>Create a form inside <code>templates/form.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Enter Your Info&lt;/h1&gt;

&lt;form action="{{ url_for('result') }}" method="POST"&gt;
    &lt;label&gt;Name:&lt;/label&gt;
    &lt;input type="text" name="username" /&gt;
    &lt;br/&gt;

    &lt;label&gt;Age:&lt;/label&gt;
    &lt;input type="number" name="age" /&gt;
    &lt;br/&gt;

    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
        <br/>
        <li>The form posts data to the route named <code>result</code>.</li>
    </ul>
    <br/><br/>


    <li>Receiving Form Data in Flask</li>
    <br/>
    <ul>
        <li>In <code>app.py</code>:</li>
<pre><code class="language-python line-numbers">from flask import Flask, render_template, request

app = Flask(__name__)

@app.route('/form')
def form():
    return render_template('form.html')

@app.route('/result', methods=['POST'])
def result():
    username = request.form.get('username')
    age = request.form.get('age')

    return render_template('result.html', username=username, age=age)
</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>request.form</code> contains all submitted form fields.</li>
            <li>Values are passed into <code>result.html</code> template via keyword arguments.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Displaying Form Data in the Template</li>
    <br/>
    <ul>
        <li><code>templates/result.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Submitted Data&lt;/h1&gt;

&lt;p&gt;Name: {{ username }}&lt;/p&gt;
&lt;p&gt;Age: {{ age }}&lt;/p&gt;
</code></pre>
        <br/>
        <li>The variables <code>{{ username }}</code> and <code>{{ age }}</code> come from <code>render_template()</code>.</li>
    </ul>
    <br/><br/>


    <li>Sending Multiple Form Fields</li>
    <br/>
    <ul>
        <li>Flask can pass many fields simply by including them in the context:</li>
<pre><code class="language-python line-numbers">return render_template(
    'profile.html',
    name=request.form.get('name'),
    email=request.form.get('email'),
    address=request.form.get('address')
)
</code></pre>
        <br/>
        <li>A clean approach is sending all form values at once:</li>
<pre><code class="language-python line-numbers">return render_template('profile.html', form=request.form)
</code></pre>
        <br/>
        <li>Then in the template:</li>
<pre><code class="language-html line-numbers">&lt;p&gt;Name: {{ form['name'] }}&lt;/p&gt;
&lt;p&gt;Email: {{ form['email'] }}&lt;/p&gt;
&lt;p&gt;Address: {{ form.get('address') }}&lt;/p&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Handling Empty or Missing Form Fields</li>
    <br/>
    <ul>
        <li>Use <code>get()</code> to avoid errors:</li>
<pre><code class="language-python line-numbers">username = request.form.get('username', 'Unknown')
</code></pre>
        <br/>
        <li>In templates, safely check values:</li>
<pre><code class="language-html line-numbers">{% if username %}
    &lt;p&gt;Hello, {{ username }}!&lt;/p&gt;
{% else %}
    &lt;p&gt;No username provided.&lt;/p&gt;
{% endif %}
</code></pre>
    </ul>
    <br/><br/>


    <li>Sending Form Data to Another Template After Validation</li>
    <br/>
    <ul>
        <li>Validation example:</li>
<pre><code class="language-python line-numbers">@app.route('/signup', methods=['POST'])
def signup():
    username = request.form.get('username')

    if not username:
        error = "Username is required!"
        return render_template('signup.html', error=error)

    return render_template('welcome.html', username=username)
</code></pre>
        <br/>
        <li>Templates:</li>
<pre><code class="language-html line-numbers">&lt;!-- signup.html --&gt;
{% if error %}
    &lt;p style="color: red"&gt;{{ error }}&lt;/p&gt;
{% endif %}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- welcome.html --&gt;
&lt;h1&gt;Welcome, {{ username }}!&lt;/h1&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Sending Form Data to Template Using Jinja2 Loops</li>
    <br/>
    <ul>
        <li>If the form contains repeated fields (e.g., checkboxes, multiple selects), Flask stores them with <code>getlist()</code>:</li>
<pre><code class="language-python line-numbers">choices = request.form.getlist('interests')
return render_template('summary.html', choices=choices)
</code></pre>
        <br/>
        <li>Template:</li>
<pre><code class="language-html line-numbers">&lt;ul&gt;
{% for c in choices %}
    &lt;li&gt;{{ c }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>
        <br/>
        <li>Good for:
            <ul>
                <li>multi-select</li>
                <li>checkbox groups</li>
                <li>tags/categories</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Preserving Form Input After Submission</li>
    <br/>
    <ul>
        <li>Useful to retain form values after errors.</li>
        <br/>
        <li>In route:</li>
<pre><code class="language-python line-numbers">return render_template('signup.html', form=request.form, error=error)
</code></pre>
        <br/>
        <li>In template:</li>
<pre><code class="language-html line-numbers">&lt;input type="text" name="username" value="{{ form.get('username', '') }}" /&gt;
</code></pre>
        <br/>
        <li>This improves usability during validation.</li>
    </ul>
    <br/><br/>


    <li>Passing Form Data with Redirect–POST–Redirect Pattern</li>
    <br/>
    <ul>
        <li>The common pattern to avoid duplicate submissions:</li>
        <ul>
            <li>POST (user submits form)</li>
            <li>Redirect</li>
            <li>GET (display result)</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">from flask import redirect, url_for, session

@app.route('/submit', methods=['POST'])
def submit():
    session['form_data'] = request.form.to_dict()
    return redirect(url_for('result'))

@app.route('/result')
def result():
    data = session.pop('form_data', {})
    return render_template('result.html', data=data)
</code></pre>
        <br/>
        <li>This prevents issues when user refreshes the page after submitting a form.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-cookies">Flask Cookies</h3>
<ol>

    <li>What Are Cookies in Flask?</li>
    <br/>
    <ul>
        <li>Cookies are small pieces of data stored on the client’s browser.</li>
        <br/>
        <li>They are sent automatically with every request to the same server, allowing Flask to:</li>
        <ul>
            <li>remember user preferences</li>
            <li>store session identifiers</li>
            <li>track login status</li>
            <li>implement analytics</li>
            <li>implement "remember me" functionality</li>
        </ul>
        <br/>
        <li>In Flask, cookies are accessed through the <code>request</code> object and set using the <code>Response</code> object.</li>
    </ul>
    <br/><br/>


    <li>Accessing Cookies (<code>request.cookies</code>)</li>
    <br/>
    <ul>
        <li>Retrieve a cookie sent by the client:</li>
<pre><code class="language-python line-numbers">@app.route('/show-cookie')
def show_cookie():
    username = request.cookies.get('username')
    return f"Hello, {username}"
</code></pre>
        <br/>
        <li>If the cookie doesn’t exist, <code>.get()</code> returns <code>None</code> unless a default is supplied:</li>
<pre><code class="language-python line-numbers">username = request.cookies.get('username', 'Guest')</code></pre>
    </ul>
    <br/><br/>


    <li>Setting Cookies in Flask</li>
    <br/>
    <ul>
        <li>Cookies are set on the <b>response</b> object, not directly in the route return value.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">@app.route('/set-cookie')
def set_cookie():
    resp = make_response("Cookie Set!")
    resp.set_cookie('username', 'Junzhe')
    return resp
</code></pre>
        <br/>
        <li>Alternatively, using <code>redirect()</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/login')
def login():
    resp = redirect(url_for('dashboard'))
    resp.set_cookie('logged_in', 'true')
    return resp
</code></pre>
    </ul>
    <br/><br/>


    <li>Cookie Options (Expiration, Path, Domain)</li>
    <br/>
    <ul>
        <li>You can customize how cookies behave using options:</li>
<pre><code class="language-python line-numbers">resp.set_cookie(
    'username',
    'Junzhe',
    max_age=60*60*24,  # 1 day
    path='/',
    secure=True,
    httponly=True,
    samesite='Lax'
)
</code></pre>
        <br/>
        <li>Common cookie parameters:</li>
        <ul>
            <li><b>max_age</b> → expiration (in seconds)</li>
            <li><b>expires</b> → specific expiration date</li>
            <li><b>path</b> → cookie applies only to that path</li>
            <li><b>domain</b> → limit cookie to specific domain/subdomain</li>
            <li><b>secure</b> → only sent over HTTPS</li>
            <li><b>httponly</b> → JavaScript cannot access cookie</li>
            <li><b>samesite</b> → CSRF protection ("Strict", "Lax", "None")</li>
        </ul>
        <br/>
        <li>Security recommendation: always use <code>httponly=True</code> when possible.</li>
    </ul>
    <br/><br/>


    <li>Deleting Cookies</li>
    <br/>
    <ul>
        <li>To delete a cookie, use <code>delete_cookie()</code> on the response:</li>
<pre><code class="language-python line-numbers">@app.route('/logout')
def logout():
    resp = make_response("Logged out")
    resp.delete_cookie('username')
    return resp
</code></pre>
        <br/>
        <li>This sends the browser an expired cookie, effectively removing it.</li>
    </ul>
    <br/><br/>


    <li>Using Cookies to Maintain User Preferences</li>
    <br/>
    <ul>
        <li>Example: storing the user’s preferred theme:</li>
<pre><code class="language-python line-numbers">@app.route('/set-theme/&lt;theme&gt;')
def set_theme(theme):
    resp = redirect(url_for('homepage'))
    resp.set_cookie('theme', theme, max_age=30*24*60*60)
    return resp
</code></pre>
        <br/>
        <li>Using the stored theme in templates:</li>
<pre><code class="language-python line-numbers">@app.route('/')
def homepage():
    theme = request.cookies.get('theme', 'light')
    return render_template('index.html', theme=theme)
</code></pre>
        <br/>
        <li>Inside template:</li>
<pre><code class="language-html line-numbers">&lt;body class="{{ theme }}"&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Storing JSON or Large Data in Cookies</li>
    <br/>
    <ul>
        <li>Cookies can only store <b>small strings</b>.</li>
        <br/>
        <li>If you need to store structured data, serialize it:</li>
<pre><code class="language-python line-numbers">import json

data = json.dumps({'theme': 'dark', 'fontsize': 16})
resp.set_cookie('settings', data)
</code></pre>
        <br/>
        <li>Retrieve and parse:</li>
<pre><code class="language-python line-numbers">settings = json.loads(request.cookies.get('settings', '{}'))</code></pre>
        <br/>
        <li>Avoid storing sensitive data — cookies are visible to users.</li>
    </ul>
    <br/><br/>


    <li>Cookies vs Flask Sessions</li>
    <br/>
    <ul>
        <li>Flask sessions use cookies internally, but with cryptographic signing.</li>
        <br/>
        <li><b>Cookies:</b></li>
        <ul>
            <li>Developer manually manages key-value pairs.</li>
            <li>Values are exposed to the user.</li>
        </ul>
        <br/>
        <li><b>Sessions:</b></li>
        <ul>
            <li>Automatically signed using <code>SECRET_KEY</code>.</li>
            <li>More secure.</li>
            <li>Simpler for storing user-specific data.</li>
        </ul>
        <br/>
        <li>Rule of thumb:
            <ul>
                <li>Use <b>cookies</b> for simple preferences (theme, language).</li>
                <li>Use <b>sessions</b> for authentication or private data.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Checking If a Cookie Exists</li>
    <br/>
    <ul>
        <li>Example route:</li>
<pre><code class="language-python line-numbers">@app.route('/check')
def check():
    if 'username' in request.cookies:
        return 'Cookie exists'
    return 'No cookie found'
</code></pre>
        <br/>
        <li>Useful for login checks, custom preferences, and onboarding flows.</li>
    </ul>
    <br/><br/>


    <li>Security Best Practices for Cookies</li>
    <br/>
    <ul>
        <li>Enable <b>HttpOnly</b> to prevent JavaScript access:</li>
<pre><code class="language-python line-numbers">resp.set_cookie('token', 'abc', httponly=True)</code></pre>
        <br/>
        <li>Use <b>Secure</b> flag to allow sending cookies only over HTTPS:</li>
<pre><code class="language-python line-numbers">resp.set_cookie('token', 'abc', secure=True)</code></pre>
        <br/>
        <li>Use <b>SameSite</b> to mitigate CSRF:</li>
<pre><code class="language-python line-numbers">resp.set_cookie('token', 'abc', samesite='Strict')</code></pre>
        <br/>
        <li>Never store sensitive info (passwords, tokens, personal data).</li>
        <br/>
        <li>Limit cookie scope using <code>path</code> and <code>domain</code>.</li>
        <br/>
        <li>Consider Flask sessions for signed cookie storage.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-sessions">Flask Sessions</h3>
<ol>

    <li>What Are Sessions in Flask?</li>
    <br/>
    <ul>
        <li>A <b>session</b> in Flask is a secure way to store user-specific data across multiple requests.</li>
        <br/>
        <li>Unlike cookies, which store plain text data, Flask sessions store data in a cookie that is:</li>
        <ul>
            <li><b>signed</b> (cannot be modified by the user)</li>
            <li><b>tamper-proof</b> (protected by secret key)</li>
            <li><b>persistent</b> across requests</li>
        </ul>
        <br/>
        <li>Sessions are ideal for:
            <ul>
                <li>login states</li>
                <li>shopping carts</li>
                <li>user preferences</li>
                <li>multi-step forms</li>
                <li>storing temporary user data</li>
            </ul>
        </li>
        <br/>
        <li>Flask stores session data in a cryptographically signed cookie using <code>SECRET_KEY</code>.</li>
    </ul>
    <br/><br/>


    <li>Enabling Sessions (SECRET_KEY)</li>
    <br/>
    <ul>
        <li>To use sessions, you must define a <code>SECRET_KEY</code> in your Flask app:</li>
<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)
app.secret_key = 'super-secret-key'    # Use a strong random value in production
</code></pre>
        <br/>
        <li>Without a secret key, Flask cannot sign session cookies.</li>
        <br/>
        <li>For production, generate a secure key:</li>
<pre><code class="language-python line-numbers">import secrets
secrets.token_hex(32)
</code></pre>
    </ul>
    <br/><br/>


    <li>Storing Data in Session</li>
    <br/>
    <ul>
        <li>Sessions behave like a Python dictionary:</li>
<pre><code class="language-python line-numbers">from flask import session

@app.route('/login')
def login():
    session['user'] = 'Junzhe'
    session['theme'] = 'dark'
    return 'Session data stored!'
</code></pre>
        <br/>
        <li>Data persists across requests as long as the session cookie remains valid.</li>
    </ul>
    <br/><br/>


    <li>Retrieving Session Data</li>
    <br/>
    <ul>
        <li>Use dictionary-style access:</li>
<pre><code class="language-python line-numbers">@app.route('/dashboard')
def dashboard():
    user = session.get('user', 'Guest')
    return f"Welcome, {user}!"
</code></pre>
        <br/>
        <li>Always use <code>session.get()</code> to avoid <code>KeyError</code>.</li>
    </ul>
    <br/><br/>


    <li>Checking If Session Keys Exist</li>
    <br/>
    <ul>
        <li>Check login state example:</li>
<pre><code class="language-python line-numbers">@app.route('/check')
def check():
    if 'user' in session:
        return 'User logged in'
    return 'User not logged in'
</code></pre>
    </ul>
    <br/><br/>


    <li>Removing Items from Session</li>
    <br/>
    <ul>
        <li>Use <code>pop()</code> or <code>del</code>:</li>
<pre><code class="language-python line-numbers">@app.route('/logout')
def logout():
    session.pop('user', None)
    return 'Logged out!'
</code></pre>
        <br/>
        <li>Clear entire session:</li>
<pre><code class="language-python line-numbers">session.clear()</code></pre>
    </ul>
    <br/><br/>


    <li>Session Lifetime (Permanent Sessions)</li>
    <br/>
    <ul>
        <li>By default, Flask sessions last until the browser is closed.</li>
        <br/>
        <li>Enable permanent session:</li>
<pre><code class="language-python line-numbers">from datetime import timedelta

@app.route('/remember')
def remember():
    session.permanent = True
    app.permanent_session_lifetime = timedelta(days=7)
    session['user'] = 'Junzhe'
    return 'Permanent session stored for 7 days!'
</code></pre>
        <br/>
        <li>Permanent sessions store expiration time in the cookie.</li>
    </ul>
    <br/><br/>


    <li>How Flask Stores Sessions Internally</li>
    <br/>
    <ul>
        <li>Flask stores session data inside a cookie in a structure like:</li>
<pre><code class="language-text line-numbers">".eJyrVkrLz1eyUkpKLFKqBQB3DAwN.yh4Y8R5pp0pH2u9dTJAyWF6TA"</code></pre>
        <br/>
        <li>It includes:
            <ul>
                <li>your session data (serialized)</li>
                <li>a secure signature</li>
            </ul>
        </li>
        <br/>
        <li>The user cannot modify session data without breaking the signature, making sessions safe.</li>
    </ul>
    <br/><br/>


    <li>Using Sessions with Forms (Common Use Case)</li>
    <br/>
    <ul>
        <li>Store submitted form data in session:</li>
<pre><code class="language-python line-numbers">@app.route('/submit', methods=['POST'])
def submit():
    session['form_data'] = request.form.to_dict()
    return redirect(url_for('show_form'))
</code></pre>
        <br/>
        <li>Display in template:</li>
<pre><code class="language-python line-numbers">@app.route('/show')
def show_form():
    data = session.get('form_data', {})
    return render_template('show.html', data=data)
</code></pre>
        <br/>
        <li>This pattern supports multi-step workflows.</li>
    </ul>
    <br/><br/>


    <li>Using Sessions for Login Systems</li>
    <br/>
    <ul>
        <li>Simple authentication example:</li>
<pre><code class="language-python line-numbers">@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    if username == 'admin':
        session['user'] = username
        return redirect(url_for('dashboard'))
    return 'Invalid login'
</code></pre>

<pre><code class="language-python line-numbers">@app.route('/dashboard')
def dashboard():
    if 'user' not in session:
        return redirect(url_for('login'))
    return f"Welcome, {session['user']}!"
</code></pre>
        <br/>
        <li>Sessions make it easy to remember authenticated users.</li>
    </ul>
    <br/><br/>


    <li>Securing Sessions</li>
    <br/>
    <ul>
        <li>Flask sessions are secure only if <b>SECRET_KEY</b> is strong.</li>
        <br/>
        <li>Recommended settings:</li>
<pre><code class="language-python line-numbers">resp.set_cookie(
    'session',
    httponly=True,
    secure=True,
    samesite='Lax'
)
</code></pre>
        <br/>
        <li>General security tips:</li>
        <ul>
            <li>Use HTTPS (<code>secure=True</code>)</li>
            <li>Enable <code>HttpOnly</code> to block JavaScript access</li>
            <li>Use <code>SameSite</code> to mitigate CSRF</li>
            <li>Never store passwords or sensitive data in session</li>
        </ul>
    </ul>
    <br/><br/>


    <li>When to Use Sessions vs Cookies</li>
    <br/>
    <ul>
        <li><b>Use sessions when:</b>
            <ul>
                <li>you need secure, tamper-proof data</li>
                <li>you store login information</li>
                <li>you store multi-step form progress</li>
                <li>data should not be readable by users</li>
            </ul>
        </li>
        <br/>
        <li><b>Use cookies when:</b>
            <ul>
                <li>storing simple preferences (theme, language)</li>
                <li>data does not need to be protected</li>
                <li>values are small</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Summary of Session Methods</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Code Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Set session value</td>
                <td><code>session['key'] = value</code></td>
            </tr>
            <tr>
                <td>Get session value</td>
                <td><code>session.get('key')</code></td>
            </tr>
            <tr>
                <td>Check existence</td>
                <td><code>'key' in session</code></td>
            </tr>
            <tr>
                <td>Remove value</td>
                <td><code>session.pop('key')</code></td>
            </tr>
            <tr>
                <td>Clear all</td>
                <td><code>session.clear()</code></td>
            </tr>
            <tr>
                <td>Make session permanent</td>
                <td><code>session.permanent = True</code></td>
            </tr>
        </tbody>
    </table>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-redirect-errors">Flask Redirect &amp; Errors</h3>
<ol>

    <li>Introduction to Redirects and Error Handling in Flask</li>
    <br/>
    <ul>
        <li>Redirects and error handling are essential in every real-world Flask application.</li>
        <br/>
        <li><b>Redirects</b> allow you to send the user from one route to another.</li>
        <br/>
        <li><b>Error handling</b> allows you to show custom pages when something goes wrong (404, 500, etc.).</li>
        <br/>
        <li>Flask provides built-in functions like <code>redirect()</code>, <code>url_for()</code>, and decorators for handling errors.</li>
    </ul>
    <br/><br/>


    <li>Using <code>redirect()</code> with <code>url_for()</code></li>
    <br/>
    <ul>
        <li>The most common way to redirect:</li>
<pre><code class="language-python line-numbers">from flask import redirect, url_for

@app.route('/old')
def old():
    return redirect(url_for('new'))

@app.route('/new')
def new():
    return "You have been redirected!"
</code></pre>
        <br/>
        <li><code>redirect()</code> returns an HTTP 302 response by default.</li>
        <br/>
        <li><code>url_for()</code> builds the correct URL for the target route.</li>
    </ul>
    <br/><br/>


    <li>Redirecting to External URLs</li>
    <br/>
    <ul>
        <li>You can also redirect to websites outside your application:</li>
<pre><code class="language-python line-numbers">@app.route('/github')
def github():
    return redirect("https://github.com")
</code></pre>
        <br/>
        <li>Useful for linking to external services, documentation, or OAuth providers.</li>
    </ul>
    <br/><br/>


    <li>Using Different Redirect Status Codes</li>
    <br/>
    <ul>
        <li>Default: <code>302 Found</code> (temporary redirect).</li>
        <br/>
        <li>Permanent redirect (<code>301</code>):</li>
<pre><code class="language-python line-numbers">return redirect(url_for('new'), code=301)
</code></pre>
        <br/>
        <li>Other redirect codes:
            <ul>
                <li><b>303</b> — See Other</li>
                <li><b>307</b> — Temporary redirect (same method)</li>
                <li><b>308</b> — Permanent redirect (same method)</li>
            </ul>
        </li>
        <br/>
        <li>Flask supports all of them via the <code>code</code> parameter.</li>
    </ul>
    <br/><br/>


    <li>Redirect After Form Submission (POST → Redirect → GET)</li>
    <br/>
    <ul>
        <li>This prevents duplicate form submissions.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-python line-numbers">@app.route('/submit', methods=['POST'])
def submit():
    # Process form...
    return redirect(url_for('thank_you'))

@app.route('/thank-you')
def thank_you():
    return "Form submitted!"
</code></pre>
        <br/>
        <li>This is the recommended pattern for all POST requests.</li>
    </ul>
    <br/><br/>


    <li>Basic Error Handling Using <code>abort()</code></li>
    <br/>
    <ul>
        <li>Flask provides <code>abort()</code> to trigger HTTP errors manually:</li>
<pre><code class="language-python line-numbers">from flask import abort

@app.route('/secret')
def secret():
    abort(403)  # Forbidden
</code></pre>
        <br/>
        <li>Common error codes:</li>
        <ul>
            <li>400 — Bad Request</li>
            <li>401 — Unauthorized</li>
            <li>403 — Forbidden</li>
            <li>404 — Not Found</li>
            <li>500 — Server Error</li>
        </ul>
        <br/>
        <li><code>abort()</code> stops execution immediately and raises an error response.</li>
    </ul>
    <br/><br/>


    <li>Creating Custom Error Pages</li>
    <br/>
    <ul>
        <li>Use the <code>@app.errorhandler</code> decorator:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def not_found(e):
    return render_template('404.html'), 404
</code></pre>
        <br/>
        <li>Custom templates improve user experience.</li>
        <br/>
        <li>Example <code>404.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Page Not Found&lt;/h1&gt;
&lt;p&gt;The page you are looking for does not exist.&lt;/p&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Handling 500 Internal Server Errors</li>
    <br/>
    <ul>
        <li>A custom global error handler:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(500)
def server_error(e):
    return render_template('500.html'), 500
</code></pre>
        <br/>
        <li>You can log the error for debugging:</li>
<pre><code class="language-python line-numbers">import logging
logging.error(e)
</code></pre>
        <br/>
        <li>Custom 500 pages are vital for production apps.</li>
    </ul>
    <br/><br/>


    <li>Handling Multiple Errors in One Place</li>
    <br/>
    <ul>
        <li>You can register handlers for multiple codes:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(403)
@app.errorhandler(401)
@app.errorhandler(400)
def handle_auth_errors(e):
    return render_template('auth_error.html', error=e), e.code
</code></pre>
        <br/>
        <li>Useful for grouping similar errors.</li>
    </ul>
    <br/><br/>


    <li>Raising Custom Error Messages</li>
    <br/>
    <ul>
        <li>You can provide a custom message:</li>
<pre><code class="language-python line-numbers">abort(404, description="User not found")
</code></pre>
        <br/>
        <li>Render description inside templates:</li>
<pre><code class="language-html line-numbers">&lt;p&gt;{{ error.description }}&lt;/p&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Redirecting Instead of Showing an Error</li>
    <br/>
    <ul>
        <li>Sometimes it’s better to redirect the user:</li>
<pre><code class="language-python line-numbers">@app.route('/admin')
def admin():
    if not session.get('is_admin'):
        return redirect(url_for('login'))
    return "Admin page"
</code></pre>
        <br/>
        <li>This avoids exposing internal logic to users.</li>
    </ul>
    <br/><br/>


    <li>Error Pages with Jinja2 and Dynamic Data</li>
    <br/>
    <ul>
        <li>You can pass variables to error templates:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(404)
def not_found(e):
    path = request.path
    return render_template('404.html', path=path), 404
</code></pre>

        <br/>
        <li>Example template:</li>
<pre><code class="language-html line-numbers">&lt;p&gt;The path &lt;b&gt;{{ path }}&lt;/b&gt; does not exist.&lt;/p&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>Using Blueprints for Error Handling</li>
    <br/>
    <ul>
        <li>Blueprint-specific error handlers:</li>
<pre><code class="language-python line-numbers">@bp.errorhandler(404)
def page_not_found(e):
    return render_template('errors/404.html'), 404
</code></pre>
        <br/>
        <li>Allows modular error management.</li>
    </ul>
    <br/><br/>


    <li>Summary of Redirect and Error Functions</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Function</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>redirect()</code></td>
                <td>Send browser to another URL</td>
            </tr>
            <tr>
                <td><code>url_for()</code></td>
                <td>Build a route URL</td>
            </tr>
            <tr>
                <td><code>abort()</code></td>
                <td>Raise an HTTP error</td>
            </tr>
            <tr>
                <td><code>@app.errorhandler()</code></td>
                <td>Custom error page for an HTTP code</td>
            </tr>
        </tbody>
    </table>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-message-flashing">Flask Message Flashing</h3>
<ol>

    <li>What Is Message Flashing in Flask?</li>
    <br/>
    <ul>
        <li><b>Message flashing</b> is a feature in Flask that allows you to store short messages temporarily and display them to the user on the next page.</li>
        <br/>
        <li>Common use cases:</li>
        <ul>
            <li>success messages (e.g., “Profile updated successfully!”)</li>
            <li>error messages (e.g., “Invalid login credentials.”)</li>
            <li>warnings / notices</li>
            <li>confirmation messages</li>
        </ul>
        <br/>
        <li>Flash messages persist only for <b>one request</b> (stored via session cookies).</li>
        <br/>
        <li>Flash messages rely on Flask sessions → requires <code>SECRET_KEY</code>.</li>
    </ul>
    <br/><br/>


    <li>Enabling Flash Messages</li>
    <br/>
    <ul>
        <li>Make sure you set a secret key in your Flask app:</li>
<pre><code class="language-python line-numbers">from flask import Flask

app = Flask(__name__)
app.secret_key = 'my-secret-key'
</code></pre>
        <br/>
        <li>Without a secret key, flash messages will not work because flashing uses sessions internally.</li>
    </ul>
    <br/><br/>


    <li>Flashing a Message</li>
    <br/>
    <ul>
        <li>Use the <code>flash()</code> function:</li>
<pre><code class="language-python line-numbers">from flask import flash

@app.route('/login', methods=['POST'])
def login():
    flash("Login successful!")
    return redirect(url_for('dashboard'))
</code></pre>
        <br/>
        <li>You can call <code>flash()</code> multiple times to store multiple messages.</li>
    </ul>
    <br/><br/>


    <li>Displaying Flash Messages in Templates</li>
    <br/>
    <ul>
        <li>In your template (usually <code>base.html</code>):</li>
<pre><code class="language-html line-numbers">{% with messages = get_flashed_messages() %}
    {% if messages %}
        &lt;ul class="flashes"&gt;
        {% for msg in messages %}
            &lt;li&gt;{{ msg }}&lt;/li&gt;
        {% endfor %}
        &lt;/ul&gt;
    {% endif %}
{% endwith %}
</code></pre>
        <br/>
        <li><code>get_flashed_messages()</code> retrieves all flashed messages and clears them afterward.</li>
    </ul>
    <br/><br/>


    <li>Flashing Messages with Categories</li>
    <br/>
    <ul>
        <li>Messages can be grouped by categories (e.g., error, success, warning):</li>
<pre><code class="language-python line-numbers">flash("Logged in successfully!", "success")
flash("Invalid password!", "error")
</code></pre>
        <br/>
        <li>Retrieve categories in template:</li>
<pre><code class="language-html line-numbers">{% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
        &lt;ul class="flashes"&gt;
        {% for category, msg in messages %}
            &lt;li class="{{ category }}"&gt;{{ msg }}&lt;/li&gt;
        {% endfor %}
        &lt;/ul&gt;
    {% endif %}
{% endwith %}
</code></pre>
        <br/>
        <li>Use categories for UI styling (CSS classes):</li>
<pre><code class="language-css line-numbers">.success { color: green; }
.error   { color: red; }
.warning { color: orange; }
</code></pre>
    </ul>
    <br/><br/>


    <li>Redirect–Flash–Render Pattern</li>
    <br/>
    <ul>
        <li>Flash messages are commonly used after redirecting:</li>
<pre><code class="language-python line-numbers">@app.route('/update', methods=['POST'])
def update():
    flash("Profile updated!", "success")
    return redirect(url_for('settings'))
</code></pre>
        <br/>
        <li>Then the <code>settings</code> page template shows the message.</li>
        <br/>
        <li>This prevents message loss during navigation.</li>
    </ul>
    <br/><br/>


    <li>Using Flash Messages With Forms</li>
    <br/>
    <ul>
        <li>Example for login:</li>
<pre><code class="language-python line-numbers">@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    if username != "admin":
        flash("Incorrect username!", "error")
        return redirect(url_for('login_form'))
    flash("Welcome admin!", "success")
    return redirect(url_for('dashboard'))
</code></pre>
        <br/>
        <li>Messages guide users through form errors or success events.</li>
    </ul>
    <br/><br/>


    <li>Storing Multiple Flash Messages</li>
    <br/>
    <ul>
        <li>You can flash multiple messages before redirecting:</li>
<pre><code class="language-python line-numbers">flash("Settings saved!", "success")
flash("New updates applied.", "info")
flash("Remember to restart the app.", "warning")
</code></pre>
        <br/>
        <li>Templates will automatically list all of them.</li>
    </ul>
    <br/><br/>


    <li>Using Flash Message Filters</li>
    <br/>
    <ul>
        <li>You can filter categories:</li>
<pre><code class="language-python line-numbers">{% with errors = get_flashed_messages(category_filter=["error"]) %}
    {% if errors %}
        &lt;ul class="errors"&gt;
            {% for err in errors %}
                &lt;li&gt;{{ err }}&lt;/li&gt;
            {% endfor %}
        &lt;/ul&gt;
    {% endif %}
{% endwith %}
</code></pre>
        <br/>
        <li>Useful when different parts of the page show different types of messages.</li>
    </ul>
    <br/><br/>


    <li>Displaying Flash Messages Using Bootstrap</li>
    <br/>
    <ul>
        <li>Bootstrap alert example:</li>
<pre><code class="language-html line-numbers">{% with messages = get_flashed_messages(with_categories=true) %}
    {% for category, msg in messages %}
        &lt;div class="alert alert-{{ category }}" role="alert"&gt;
            {{ msg }}
        &lt;/div&gt;
    {% endfor %}
{% endwith %}
</code></pre>
        <br/>
        <li>Use categories matching Bootstrap:</li>
        <ul>
            <li><code>success</code></li>
            <li><code>danger</code></li>
            <li><code>warning</code></li>
            <li><code>info</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li>Flashing Messages in Blueprints</li>
    <br/>
    <ul>
        <li>Flash works normally inside blueprints:</li>
<pre><code class="language-python line-numbers">@bp.route('/action')
def action():
    flash("Action completed!", "info")
    return redirect(url_for('bp.index'))
</code></pre>
        <br/>
        <li>Messages are shared across the entire app via session.</li>
    </ul>
    <br/><br/>


    <li>Advanced: Flashing with Additional Payload</li>
    <br/>
    <ul>
        <li>You can attach structured data (rarely needed):</li>
<pre><code class="language-python line-numbers">flash(("File uploaded", {"size": "2MB"}), "info")</code></pre>
        <br/>
        <li>Template:</li>
<pre><code class="language-html line-numbers">{% for category, data in get_flashed_messages(with_categories=true) %}
    {% set msg, info = data %}
    &lt;p&gt;{{ msg }} ({{ info.size }})&lt;/p&gt;
{% endfor %}
</code></pre>
        <br/>
        <li>Use sparingly—flash messages are meant to be simple.</li>
    </ul>
    <br/><br/>


    <li>Clearing All Flash Messages (Rare Case)</li>
    <br/>
    <ul>
        <li>Flash messages clear automatically after retrieval.</li>
        <br/>
        <li>If needed manually:</li>
<pre><code class="language-python line-numbers">session.pop('_flashes', None)</code></pre>
        <br/>
        <li>Not recommended unless you know what you're doing.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-file-uploading">Flask File Uploading</h3>
<ol>

    <li>Introduction to File Uploading in Flask</li>
    <br/>
    <ul>
        <li>Flask makes it easy to accept uploaded files from users using HTML forms.</li>
        <br/>
        <li>Common upload use cases:</li>
        <ul>
            <li>profile pictures</li>
            <li>documents (PDF, Word)</li>
            <li>CSV or Excel files for processing</li>
            <li>image galleries</li>
            <li>audio/video uploads</li>
        </ul>
        <br/>
        <li>File uploading requires:
            <ul>
                <li>an HTML form with <code>enctype="multipart/form-data"</code></li>
                <li>a file input field</li>
                <li>Flask reading <code>request.files</code></li>
                <li>saving the file safely</li>
            </ul>
        </li>
        <br/>
        <li>Flask stores uploaded files in memory or temporary files before you save them.</li>
    </ul>
    <br/><br/>


    <li>Creating a File Upload Form</li>
    <br/>
    <ul>
        <li>Create <code>templates/upload.html</code>:</li>
<pre><code class="language-html line-numbers">&lt;h1&gt;Upload File&lt;/h1&gt;

&lt;form method="POST" enctype="multipart/form-data" action="{{ url_for('upload_file') }}"&gt;
    &lt;input type="file" name="file" /&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;button type="submit"&gt;Upload&lt;/button&gt;
&lt;/form&gt;
</code></pre>
        <br/>
        <li>Important: <b>Without enctype="multipart/form-data", uploads will not work.</b></li>
    </ul>
    <br/><br/>


    <li>Receiving and Saving Uploaded Files</li>
    <br/>
    <ul>
        <li>Basic upload route in Flask:</li>
<pre><code class="language-python line-numbers">from flask import request, render_template
import os

UPLOAD_FOLDER = "uploads"

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == "POST":
        file = request.files.get('file')

        if not file:
            return "No file uploaded"

        filepath = os.path.join(UPLOAD_FOLDER, file.filename)
        file.save(filepath)

        return f"Uploaded to {filepath}"

    return render_template('upload.html')
</code></pre>
        <br/>
        <li><code>request.files</code> contains uploaded files keyed by the filename alias.</li>
        <br/>
        <li>The file is saved using <code>file.save()</code>.</li>
    </ul>
    <br/><br/>


    <li>Ensuring the Upload Directory Exists</li>
    <br/>
    <ul>
        <li>Create the folder manually:</li>
<pre><code class="language-plaintext line-numbers">project/
    app.py
    uploads/
    templates/
</code></pre>
        <br/>
        <li>Or create it automatically:</li>
<pre><code class="language-python line-numbers">os.makedirs(UPLOAD_FOLDER, exist_ok=True)</code></pre>
    </ul>
    <br/><br/>


    <li>Securing File Uploads with <code>secure_filename()</code></li>
    <br/>
    <ul>
        <li>Never trust filenames sent from clients—sanitize them:</li>
<pre><code class="language-python line-numbers">from werkzeug.utils import secure_filename

filename = secure_filename(file.filename)
file.save(os.path.join(UPLOAD_FOLDER, filename))
</code></pre>
        <br/>
        <li>This prevents dangerous names like:
<pre><code class="language-plaintext line-numbers">../../../../etc/passwd</code></pre>
        </li>
        <br/>
        <li><code>secure_filename()</code> removes risky characters and ensures safety.</li>
    </ul>
    <br/><br/>


    <li>Restricting Allowed File Types</li>
    <br/>
    <ul>
        <li>Define allowed extensions:</li>
<pre><code class="language-python line-numbers">ALLOWED = {'png', 'jpg', 'jpeg', 'gif', 'pdf'}

def allowed(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED
</code></pre>
        <br/>
        <li>Validate before saving:</li>
<pre><code class="language-python line-numbers">if not allowed(file.filename):
    return "File type not allowed"
</code></pre>
        <br/>
        <li>Prevents users from uploading unsafe files.</li>
    </ul>
    <br/><br/>


    <li>Handling Multiple File Uploads</li>
    <br/>
    <ul>
        <li>HTML form:</li>
<pre><code class="language-html line-numbers">&lt;input type="file" name="files" multiple /&gt;</code></pre>
        <br/>
        <li>Flask route:</li>
<pre><code class="language-python line-numbers">files = request.files.getlist('files')

for f in files:
    f.save(os.path.join(UPLOAD_FOLDER, secure_filename(f.filename)))
</code></pre>
        <br/>
        <li>Useful for galleries, attachments, etc.</li>
    </ul>
    <br/><br/>


    <li>Retrieving Uploaded Files (Serving Them)</li>
    <br/>
    <ul>
        <li>Use <code>send_from_directory()</code>:</li>
<pre><code class="language-python line-numbers">from flask import send_from_directory

@app.route('/uploads/&lt;filename&gt;')
def uploaded_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename)
</code></pre>
        <br/>
        <li>This allows users to access uploaded files safely.</li>
    </ul>
    <br/><br/>


    <li>Limiting Maximum File Size</li>
    <br/>
    <ul>
        <li>Flask allows setting a maximum upload size:</li>
<pre><code class="language-python line-numbers">app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB
</code></pre>
        <br/>
        <li>Requests larger than this will raise a <code>413 Request Entity Too Large</code> error.</li>
    </ul>
    <br/><br/>


    <li>Handling Upload Errors</li>
    <br/>
    <ul>
        <li>Capture 413 errors:</li>
<pre><code class="language-python line-numbers">@app.errorhandler(413)
def too_large(e):
    return "File is too large!", 413
</code></pre>
        <br/>
        <li>Other common upload errors:
            <ul>
                <li>no file submitted</li>
                <li>empty filename</li>
                <li>invalid file type</li>
                <li>upload directory missing</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Using Flash Messages for Upload Feedback</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-python line-numbers">flash("File uploaded successfully!", "success")</code></pre>
        <br/>
        <li>This helps guide users during upload operations.</li>
    </ul>
    <br/><br/>


    <li>File Uploading with Blueprints</li>
    <br/>
    <ul>
        <li>You can implement uploads inside a blueprint normally:</li>
<pre><code class="language-python line-numbers">@bp.route('/upload', methods=['POST'])
def bp_upload():
    file = request.files.get('file')
    file.save(os.path.join("bp_uploads", secure_filename(file.filename)))
    return "Uploaded!"
</code></pre>
        <br/>
        <li>Useful for modular applications.</li>
    </ul>
    <br/><br/>


    <li>Security Best Practices for File Uploads</li>
    <br/>
    <ul>
        <li>Always sanitize filenames with <code>secure_filename()</code>.</li>
        <br/>
        <li>Always validate file types and sizes.</li>
        <br/>
        <li>Store uploads outside the project root if possible.</li>
        <br/>
        <li>Do NOT execute or trust uploaded files.</li>
        <br/>
        <li>Configure proper permissions on the upload directory.</li>
        <br/>
        <li>For large uploads, consider background processing (Celery, RQ).</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="flask-extensions">Flask Extensions</h3>
<ol>

    <li>What Are Flask Extensions?</li>
    <br/>
    <ul>
        <li><b>Flask extensions</b> are third-party packages that add extra features to Flask without bloating the core framework.</li>
        <br/>
        <li>They integrate cleanly with Flask’s ecosystem, following common patterns like:</li>
        <ul>
            <li>initializing with the app object</li>
            <li>supporting the application factory pattern via <code>init_app()</code></li>
            <li>using Flask configuration keys like <code>SQLALCHEMY_DATABASE_URI</code>, <code>MAIL_SERVER</code>, etc.</li>
        </ul>
        <br/>
        <li>Typical features provided by extensions:</li>
        <ul>
            <li>database access (ORMs like SQLAlchemy)</li>
            <li>form handling &amp; CSRF protection</li>
            <li>authentication &amp; user management</li>
            <li>email sending</li>
            <li>migrations</li>
            <li>REST APIs</li>
            <li>caching, rate limiting, etc.</li>
        </ul>
        <br/>
        <li>Extensions let you compose a “micro” core into a full-featured web framework.</li>
    </ul>
    <br/><br/>


    <li>Installing Flask Extensions</li>
    <br/>
    <ul>
        <li>Extensions are installed via <code>pip</code> (or similar):</li>
<pre><code class="language-bash line-numbers">pip install Flask-SQLAlchemy
pip install Flask-WTF
pip install Flask-Login
</code></pre>
        <br/>
        <li>After installation, import them in your Python code, usually with a <code>flask_*</code> or <code>Flask-*</code> module name:</li>
<pre><code class="language-python line-numbers">from flask_sqlalchemy import SQLAlchemy
from flask_wtf import FlaskForm
from flask_login import LoginManager
</code></pre>
        <br/>
        <li>Always check the extension’s documentation for exact install and import names.</li>
    </ul>
    <br/><br/>


    <li>Commonly Used Flask Extensions (Overview)</li>
    <br/>
    <ul>
        <li>Some popular extensions in the Flask ecosystem:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Extension</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>Flask-SQLAlchemy</code></td>
                    <td>Database ORM support via SQLAlchemy</td>
                </tr>
                <tr>
                    <td><code>Flask-Migrate</code></td>
                    <td>Database migrations (Alembic integration)</td>
                </tr>
                <tr>
                    <td><code>Flask-WTF</code></td>
                    <td>Form handling &amp; CSRF protection</td>
                </tr>
                <tr>
                    <td><code>Flask-Login</code></td>
                    <td>User session management &amp; authentication</td>
                </tr>
                <tr>
                    <td><code>Flask-Mail</code></td>
                    <td>Email sending via SMTP</td>
                </tr>
                <tr>
                    <td><code>Flask-RESTful</code></td>
                    <td>REST API helpers &amp; resources</td>
                </tr>
                <tr>
                    <td><code>Flask-Caching</code></td>
                    <td>Caching responses &amp; computations</td>
                </tr>
                <tr>
                    <td><code>Flask-Limiter</code></td>
                    <td>Rate limiting (throttling requests)</td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>You can mix and match extensions depending on your project’s needs.</li>
    </ul>
    <br/><br/>


    <li>Basic Extension Initialization (Single-File App)</li>
    <br/>
    <ul>
        <li>Many extensions are initialized directly with the <code>Flask</code> app instance:</li>
<pre><code class="language-python line-numbers">from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'

db = SQLAlchemy(app)
</code></pre>
        <br/>
        <li>Here:</li>
        <ul>
            <li>configuration is set on <code>app.config</code></li>
            <li>the extension reads necessary config values when initialized</li>
        </ul>
        <br/>
        <li>This style is common for small applications or tutorials.</li>
    </ul>
    <br/><br/>


    <li>Application Factory Pattern and <code>init_app()</code></li>
    <br/>
    <ul>
        <li>Larger apps often use the <b>application factory</b> pattern:</li>
        <br/>
<pre><code class="language-python line-numbers"># extensions.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

# app.py
from flask import Flask
from extensions import db

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'

    db.init_app(app)
    return app
</code></pre>
        <br/>
        <li>Pattern:</li>
        <ul>
            <li>create extension instances globally (no app yet)</li>
            <li>inside <code>create_app()</code>, call <code>extension.init_app(app)</code></li>
        </ul>
        <br/>
        <li>Benefits:</li>
        <ul>
            <li>supports multiple apps with same extension</li>
            <li>plays nicely with testing and configuration variations</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Example: Using Flask-SQLAlchemy</li>
    <br/>
    <ul>
        <li>Configuration &amp; model definition:</li>
<pre><code class="language-python line-numbers">from flask import Flask
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///blog.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    db.init_app(app)
    return app

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
</code></pre>
        <br/>
        <li>Usage inside a request context:</li>
<pre><code class="language-python line-numbers">app = create_app()

with app.app_context():
    db.create_all()
</code></pre>
        <br/>
        <li>Flask-SQLAlchemy simplifies DB integration while still using full SQLAlchemy power.</li>
    </ul>
    <br/><br/>


    <li>Example: Flask-WTF (Forms &amp; CSRF)</li>
    <br/>
    <ul>
        <li>Install and configure:</li>
<pre><code class="language-python line-numbers">from flask import Flask, render_template, request
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired

app = Flask(__name__)
app.secret_key = 'change-me'  # needed for CSRF &amp; session
</code></pre>
        <br/>
        <li>Define a form:</li>
<pre><code class="language-python line-numbers">class NameForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')
</code></pre>
        <br/>
        <li>Use the form in a route:</li>
<pre><code class="language-python line-numbers">@app.route('/hello', methods=['GET', 'POST'])
def hello():
    form = NameForm()
    if form.validate_on_submit():
        return f"Hello, {form.name.data}!"
    return render_template('hello.html', form=form)
</code></pre>
        <br/>
        <li>In template:</li>
<pre><code class="language-html line-numbers">&lt;form method="POST"&gt;
    {{ form.hidden_tag() }}
    {{ form.name.label }} {{ form.name() }}&lt;br/&gt;
    {{ form.submit() }}
&lt;/form&gt;
</code></pre>
        <br/>
        <li>Flask-WTF integrates CSRF protection, validation, and HTML rendering helpers.</li>
    </ul>
    <br/><br/>


    <li>Example: Flask-Login (User Sessions)</li>
    <br/>
    <ul>
        <li>Basic setup:</li>
<pre><code class="language-python line-numbers">from flask_login import LoginManager, UserMixin, login_user, login_required, current_user

login_manager = LoginManager()

def create_app():
    app = Flask(__name__)
    app.secret_key = 'secret'
    login_manager.init_app(app)
    return app
</code></pre>
        <br/>
        <li>Define a user model (simplified):</li>
<pre><code class="language-python line-numbers">class User(UserMixin):
    def __init__(self, id):
        self.id = id

@login_manager.user_loader
def load_user(user_id):
    return User(user_id)
</code></pre>
        <br/>
        <li>Using login-required route:</li>
<pre><code class="language-python line-numbers">@app.route('/login')
def login():
    user = User(id="junzhe")
    login_user(user)
    return "Logged in!"

@app.route('/secret')
@login_required
def secret():
    return f"Hello, {current_user.id}"
</code></pre>
        <br/>
        <li>Flask-Login abstracts away session logic and authentication helpers.</li>
    </ul>
    <br/><br/>


    <li>Configuration Patterns for Extensions</li>
    <br/>
    <ul>
        <li>Most extensions read settings from <code>app.config</code> keys:</li>
        <ul>
            <li><code>SQLALCHEMY_DATABASE_URI</code> for Flask-SQLAlchemy</li>
            <li><code>MAIL_SERVER</code>, <code>MAIL_PORT</code>, <code>MAIL_USERNAME</code> for Flask-Mail</li>
            <li><code>CACHE_TYPE</code> for Flask-Caching</li>
        </ul>
        <br/>
        <li>Example centralized config:</li>
<pre><code class="language-python line-numbers">class Config:
    SQLALCHEMY_DATABASE_URI = 'sqlite:///app.db'
    MAIL_SERVER = 'smtp.example.com'
    MAIL_PORT = 587

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    # init extensions here...
    return app
</code></pre>
        <br/>
        <li>Storing config in a class or separate file keeps extensions consistent and maintainable.</li>
    </ul>
    <br/><br/>


    <li>Finding and Evaluating Flask Extensions</li>
    <br/>
    <ul>
        <li>Where to look:</li>
        <ul>
            <li>PyPI (search for <code>Flask-*</code>)</li>
            <li>Flask extension registry (in official docs)</li>
            <li>GitHub repositories and stars/issues</li>
        </ul>
        <br/>
        <li>When choosing an extension, consider:</li>
        <ul>
            <li>maintenance status (recent commits, open issues)</li>
            <li>documentation quality</li>
            <li>community usage/popularity</li>
            <li>compatibility with your Flask version</li>
        </ul>
        <br/>
        <li>If an extension looks abandoned, be careful about using it in production.</li>
    </ul>
    <br/><br/>


    <li>Writing Your Own Simple Extension (Overview)</li>
    <br/>
    <ul>
        <li>Custom extensions usually follow a pattern:</li>
        <br/>
<pre><code class="language-python line-numbers">class MyExtension:
    def __init__(self, app=None):
        if app is not None:
            self.init_app(app)

    def init_app(self, app):
        # setup logic, read app.config, register handlers, etc.
        app.my_ext = self
</code></pre>
        <br/>
        <li>Usage:</li>
<pre><code class="language-python line-numbers">my_ext = MyExtension()

def create_app():
    app = Flask(__name__)
    my_ext.init_app(app)
    return app
</code></pre>
        <br/>
        <li>This pattern mirrors existing extensions, so your own tools integrate nicely with Flask.</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * --
