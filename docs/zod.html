<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>zod</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/zod.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#zod-primitive-types">Primitive Types</a></li>
        <li><a href="#zod-string-validators">String Validators</a></li>
        <li><a href="#zod-number-validators">Number Validators</a></li>
        <li><a href="#zod-composite-types">Composite Types</a></li>
        <li><a href="#zod-modifiers">Modifiers</a></li>
        <li><a href="#zod-object-utilities">Object Utilities</a></li>
        <li><a href="#zod-transformations-refinements">Transformations Refinements</a></li>
        <li><a href="#zod-parsing">Parsing</a></li>
        <li><a href="#zod-"></a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-primitive-types">Primitive Types</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Zod is a TypeScript-first schema declaration and validation library.</li>
        <br/>
        <li>Primitive types are the foundational schemas that validate basic JavaScript values.</li>
        <br/>
        <li>All primitive schemas are created via factory functions on the <code>z</code> namespace.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>z.string()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.string(): ZodString</code></li>
        <br/>
        <li>Validates that a value is of type <code>string</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string();

schema.parse("hello");      // ✅ Returns "hello"
schema.parse("");           // ✅ Returns ""
schema.parse(123);          // ❌ Throws ZodError: Expected string, received number
schema.parse(null);         // ❌ Throws ZodError: Expected string, received null
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.number()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.number(): ZodNumber</code></li>
        <br/>
        <li>Validates that a value is of type <code>number</code>. Rejects <code>NaN</code> by default.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number();

schema.parse(42);           // ✅ Returns 42
schema.parse(3.14);         // ✅ Returns 3.14
schema.parse(-100);         // ✅ Returns -100
schema.parse(Infinity);     // ✅ Returns Infinity
schema.parse("42");         // ❌ Throws ZodError: Expected number, received string
schema.parse(NaN);          // ❌ Throws ZodError: Expected number, received nan
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.boolean()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.boolean(): ZodBoolean</code></li>
        <br/>
        <li>Validates that a value is <code>true</code> or <code>false</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.boolean();

schema.parse(true);         // ✅ Returns true
schema.parse(false);        // ✅ Returns false
schema.parse(1);            // ❌ Throws ZodError: Expected boolean, received number
schema.parse("true");       // ❌ Throws ZodError: Expected boolean, received string
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.bigint()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.bigint(): ZodBigInt</code></li>
        <br/>
        <li>Validates that a value is a JavaScript <code>BigInt</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.bigint();

schema.parse(10n);          // ✅ Returns 10n
schema.parse(BigInt(999));  // ✅ Returns 999n
schema.parse(10);           // ❌ Throws ZodError: Expected bigint, received number
schema.parse("10");         // ❌ Throws ZodError: Expected bigint, received string
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.date()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.date(): ZodDate</code></li>
        <br/>
        <li>Validates that a value is a JavaScript <code>Date</code> object. Rejects invalid dates.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.date();

schema.parse(new Date());                    // ✅ Returns Date object
schema.parse(new Date("2024-01-15"));        // ✅ Returns Date object
schema.parse(new Date("invalid"));           // ❌ Throws ZodError: Invalid date
schema.parse("2024-01-15");                  // ❌ Throws ZodError: Expected date, received string
schema.parse(1705276800000);                 // ❌ Throws ZodError: Expected date, received number
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.undefined()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.undefined(): ZodUndefined</code></li>
        <br/>
        <li>Validates that a value is exactly <code>undefined</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.undefined();

schema.parse(undefined);    // ✅ Returns undefined
schema.parse(void 0);       // ✅ Returns undefined
schema.parse(null);         // ❌ Throws ZodError: Expected undefined, received null
schema.parse("");           // ❌ Throws ZodError: Expected undefined, received string
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.null()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.null(): ZodNull</code></li>
        <br/>
        <li>Validates that a value is exactly <code>null</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.null();

schema.parse(null);         // ✅ Returns null
schema.parse(undefined);    // ❌ Throws ZodError: Expected null, received undefined
schema.parse(0);            // ❌ Throws ZodError: Expected null, received number
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.any()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.any(): ZodAny</code></li>
        <br/>
        <li>Accepts any value. No validation is performed.</li>
        <br/>
        <li>The inferred TypeScript type is <code>any</code>.</li>
        <br/>
        <li><b>Note:</b> Use sparingly — defeats the purpose of type safety.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.any();

schema.parse("hello");      // ✅ Returns "hello"
schema.parse(123);          // ✅ Returns 123
schema.parse(null);         // ✅ Returns null
schema.parse(undefined);    // ✅ Returns undefined
schema.parse({ a: 1 });     // ✅ Returns { a: 1 }
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.unknown()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.unknown(): ZodUnknown</code></li>
        <br/>
        <li>Accepts any value (like <code>z.any()</code>), but infers TypeScript type as <code>unknown</code>.</li>
        <br/>
        <li>Forces you to narrow the type before use.</li>
        <br/>
        <li><b>Prefer <code>z.unknown()</code> over <code>z.any()</code></b> for type-safe handling of arbitrary data.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.unknown();

schema.parse("hello");      // ✅ Returns "hello"
schema.parse(123);          // ✅ Returns 123
schema.parse(null);         // ✅ Returns null

// TypeScript behavior:
const result = schema.parse(someData);
result.toUpperCase();       // ❌ TypeScript error: 'result' is of type 'unknown'

// Must narrow first:
if (typeof result === "string") {
    result.toUpperCase();   // ✅ OK
}
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.never()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.never(): ZodNever</code></li>
        <br/>
        <li>Always fails validation.</li>
        <br/>
        <li>Useful for exhaustive checks or marking impossible branches.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.never();

schema.parse("anything");   // ❌ Throws ZodError
schema.parse(undefined);    // ❌ Throws ZodError
schema.parse(null);         // ❌ Throws ZodError

// Practical use: exhaustive switch
type Status = "active" | "inactive";
function handleStatus(status: Status) {
    switch (status) {
        case "active": return "on";
        case "inactive": return "off";
        default:
            z.never().parse(status); // Compile-time + runtime check for unhandled cases
    }
}
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.void()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.void(): ZodVoid</code></li>
        <br/>
        <li>Validates that a value is <code>undefined</code>.</li>
        <br/>
        <li>Semantically used for functions that return nothing.</li>
        <br/>
        <li><b>Note:</b> Functionally identical to <code>z.undefined()</code>, but conveys intent for return types.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.void();

schema.parse(undefined);    // ✅ Returns undefined
schema.parse(null);         // ❌ Throws ZodError: Expected void, received null
schema.parse("hello");      // ❌ Throws ZodError: Expected void, received string

// Typical use: function return type
const fnSchema = z.function().args(z.string()).returns(z.void());
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-string-validators">String Validators</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>All methods below are chained on a <code>ZodString</code> instance (returned by <code>z.string()</code>).</li>
        <br/>
        <li>Some are <u>validators</u> (check conditions), others are <u>transformers</u> (modify output).</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.min()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.min(length: number, message?: string): ZodString</code></li>
        <br/>
        <li>Requires string to have at least <code>length</code> characters.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().min(3);

schema.parse("hello");   // ✅ Returns "hello"
schema.parse("abc");     // ✅ Returns "abc"
schema.parse("ab");      // ❌ ZodError: String must contain at least 3 character(s)
schema.parse("");        // ❌ ZodError

// Custom message
z.string().min(3, "Too short").parse("ab");  // ❌ ZodError: Too short
</code></pre>
    <br/>
    <br/>


    <li><b><code>.max()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.max(length: number, message?: string): ZodString</code></li>
        <br/>
        <li>Requires string to have at most <code>length</code> characters.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().max(5);

schema.parse("hi");      // ✅ Returns "hi"
schema.parse("hello");   // ✅ Returns "hello"
schema.parse("hello!");  // ❌ ZodError: String must contain at most 5 character(s)
</code></pre>
    <br/>
    <br/>


    <li><b><code>.length()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.length(length: number, message?: string): ZodString</code></li>
        <br/>
        <li>Requires string to have exactly <code>length</code> characters.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().length(4);

schema.parse("abcd");    // ✅ Returns "abcd"
schema.parse("abc");     // ❌ ZodError: String must contain exactly 4 character(s)
schema.parse("abcde");   // ❌ ZodError
</code></pre>
    <br/>
    <br/>


    <li><b><code>.email()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.email(message?: string): ZodString</code></li>
        <br/>
        <li>Validates that string is a valid email format.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().email();

schema.parse("user@example.com");    // ✅ Returns "user@example.com"
schema.parse("test@sub.domain.org"); // ✅ Returns "test@sub.domain.org"
schema.parse("invalid");             // ❌ ZodError: Invalid email
schema.parse("user@");               // ❌ ZodError: Invalid email
schema.parse("@example.com");        // ❌ ZodError: Invalid email
</code></pre>
    <br/>
    <br/>


    <li><b><code>.url()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.url(message?: string): ZodString</code></li>
        <br/>
        <li>Validates that string is a valid URL.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().url();

schema.parse("https://example.com");       // ✅
schema.parse("http://localhost:3000");     // ✅
schema.parse("ftp://files.example.com");   // ✅
schema.parse("example.com");               // ❌ ZodError: Invalid url
schema.parse("not a url");                 // ❌ ZodError: Invalid url
</code></pre>
    <br/>
    <br/>


    <li><b><code>.uuid()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.uuid(message?: string): ZodString</code></li>
        <br/>
        <li>Validates that string is a valid UUID (v1–v5 format).</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().uuid();

schema.parse("550e8400-e29b-41d4-a716-446655440000");  // ✅
schema.parse("123e4567-e89b-12d3-a456-426614174000");  // ✅
schema.parse("not-a-uuid");                            // ❌ ZodError: Invalid uuid
schema.parse("550e8400-e29b-41d4-a716");               // ❌ ZodError: Invalid uuid
</code></pre>
    <br/>
    <br/>


    <li><b><code>.regex()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.regex(regex: RegExp, message?: string): ZodString</code></li>
        <br/>
        <li>Validates that string matches the given regular expression.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().regex(/^[A-Z]{3}-\d{3}$/);

schema.parse("ABC-123");   // ✅ Returns "ABC-123"
schema.parse("XYZ-999");   // ✅ Returns "XYZ-999"
schema.parse("abc-123");   // ❌ ZodError: Invalid
schema.parse("ABCD-12");   // ❌ ZodError: Invalid

// Custom message
z.string().regex(/^\d+$/, "Numbers only").parse("abc");  // ❌ ZodError: Numbers only
</code></pre>
    <br/>
    <br/>


    <li><b><code>.startsWith()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.startsWith(prefix: string, message?: string): ZodString</code></li>
        <br/>
        <li>Requires string to start with the given prefix.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().startsWith("https://");

schema.parse("https://example.com");  // ✅
schema.parse("https://");             // ✅
schema.parse("http://example.com");   // ❌ ZodError: Invalid input: must start with "https://"
</code></pre>
    <br/>
    <br/>


    <li><b><code>.endsWith()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.endsWith(suffix: string, message?: string): ZodString</code></li>
        <br/>
        <li>Requires string to end with the given suffix.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().endsWith(".json");

schema.parse("config.json");    // ✅
schema.parse("data.json");      // ✅
schema.parse("config.yaml");    // ❌ ZodError: Invalid input: must end with ".json"
</code></pre>
    <br/>
    <br/>


    <li><b><code>.trim()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.trim(): ZodString</code></li>
        <br/>
        <li><b>Transforms</b> the string by removing leading and trailing whitespace.</li>
        <br/>
        <li>This is a transformation, not a validation.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().trim();

schema.parse("  hello  ");   // ✅ Returns "hello"
schema.parse("\n\tworld\n"); // ✅ Returns "world"
schema.parse("no spaces");   // ✅ Returns "no spaces"

// Often combined with .min() to reject empty/whitespace-only
const nonEmpty = z.string().trim().min(1);
nonEmpty.parse("   ");       // ❌ ZodError: String must contain at least 1 character(s)
</code></pre>
    <br/>
    <br/>


    <li><b><code>.toLowerCase()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.toLowerCase(): ZodString</code></li>
        <br/>
        <li><b>Transforms</b> the string to lowercase.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().toLowerCase();

schema.parse("HELLO");       // ✅ Returns "hello"
schema.parse("HeLLo WoRLD"); // ✅ Returns "hello world"
schema.parse("already");     // ✅ Returns "already"
</code></pre>
    <br/>
    <br/>


    <li><b><code>.toUpperCase()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodString.toUpperCase(): ZodString</code></li>
        <br/>
        <li><b>Transforms</b> the string to uppercase.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().toUpperCase();

schema.parse("hello");       // ✅ Returns "HELLO"
schema.parse("HeLLo WoRLD"); // ✅ Returns "HELLO WORLD"
schema.parse("ALREADY");     // ✅ Returns "ALREADY"
</code></pre>
    <br/>
    <br/>


    <li><b>Chaining Example</b></li>
    <br/>
    <ul>
        <li>String validators can be chained:</li>
    </ul>
<pre><code class="language-ts line-numbers">const usernameSchema = z.string()
    .trim()
    .toLowerCase()
    .min(3)
    .max(20)
    .regex(/^[a-z0-9_]+$/);

usernameSchema.parse("  John_Doe123  ");  // ✅ Returns "john_doe123"
usernameSchema.parse("  AB  ");           // ❌ ZodError: min 3
usernameSchema.parse("invalid-name!");    // ❌ ZodError: regex fails
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-number-validators">Number Validators</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>All methods below are called on a <code>ZodNumber</code> instance (returned by <code>z.number()</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.min()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.min(value: number, message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be greater than or equal to <code>value</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().min(5);

schema.parse(5);     // ✅ Returns 5
schema.parse(10);    // ✅ Returns 10
schema.parse(4.99);  // ❌ ZodError: Number must be greater than or equal to 5
schema.parse(-10);   // ❌ ZodError
</code></pre>
    <br/>
    <br/>


    <li><b><code>.max()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.max(value: number, message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be less than or equal to <code>value</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().max(100);

schema.parse(100);   // ✅ Returns 100
schema.parse(50);    // ✅ Returns 50
schema.parse(101);   // ❌ ZodError: Number must be less than or equal to 100
</code></pre>
    <br/>
    <br/>


    <li><b><code>.int()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.int(message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be an integer (no decimal part).</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().int();

schema.parse(42);    // ✅ Returns 42
schema.parse(-10);   // ✅ Returns -10
schema.parse(0);     // ✅ Returns 0
schema.parse(3.14);  // ❌ ZodError: Expected integer, received float
schema.parse(5.0);   // ✅ Returns 5 (5.0 === 5 in JS)
</code></pre>
    <br/>
    <br/>


    <li><b><code>.positive()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.positive(message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be greater than 0.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().positive();

schema.parse(1);     // ✅ Returns 1
schema.parse(0.001); // ✅ Returns 0.001
schema.parse(0);     // ❌ ZodError: Number must be greater than 0
schema.parse(-5);    // ❌ ZodError
</code></pre>
    <br/>
    <br/>


    <li><b><code>.negative()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.negative(message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be less than 0.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().negative();

schema.parse(-1);    // ✅ Returns -1
schema.parse(-0.01); // ✅ Returns -0.01
schema.parse(0);     // ❌ ZodError: Number must be less than 0
schema.parse(5);     // ❌ ZodError
</code></pre>
    <br/>
    <br/>


    <li><b><code>.nonnegative()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.nonnegative(message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be greater than or equal to 0.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().nonnegative();

schema.parse(0);     // ✅ Returns 0
schema.parse(100);   // ✅ Returns 100
schema.parse(-1);    // ❌ ZodError: Number must be greater than or equal to 0
schema.parse(-0.01); // ❌ ZodError
</code></pre>
    <br/>
    <ul>
        <li><b>Note:</b> There's also <code>.nonpositive()</code> (≤ 0).</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.finite()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.finite(message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Requires number to be finite (rejects <code>Infinity</code> and <code>-Infinity</code>).</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().finite();

schema.parse(999999999);   // ✅ Returns 999999999
schema.parse(-999999999);  // ✅ Returns -999999999
schema.parse(0);           // ✅ Returns 0
schema.parse(Infinity);    // ❌ ZodError: Number must be finite
schema.parse(-Infinity);   // ❌ ZodError
</code></pre>
    <br/>
    <br/>


    <li><b><code>.safe()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodNumber.safe(message?: string | { message?: string }): ZodNumber</code></li>
        <br/>
        <li>Restricts the number to JavaScript's "safe integer" range:</li>
        <br/>
        <li><code>-9007199254740991</code> to <code>9007199254740991</code></li>
        <br/>
        <li>(<code>Number.MIN_SAFE_INTEGER</code> to <code>Number.MAX_SAFE_INTEGER</code>)</li>
        <br/>
        <li><b>Why it exists:</b> JavaScript's <code>number</code> type loses precision for integers outside this range.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number().safe();

schema.parse(9007199254740991);   // ✅ MAX_SAFE_INTEGER
schema.parse(-9007199254740991);  // ✅ MIN_SAFE_INTEGER
schema.parse(9007199254740992);   // ❌ ZodError: Number must be safe

// Why this matters:
console.log(9007199254740992 === 9007199254740993);  // true (precision lost!)
</code></pre>
    <br/>
    <br/>


    <li><b>Additional Number Validators</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Signature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>.gt(n)</code></td>
                <td><code>ZodNumber.gt(value: number, message?): ZodNumber</code></td>
                <td>Greater than (exclusive)</td>
            </tr>
            <tr>
                <td><code>.gte(n)</code></td>
                <td><code>ZodNumber.gte(value: number, message?): ZodNumber</code></td>
                <td>Alias for <code>.min()</code></td>
            </tr>
            <tr>
                <td><code>.lt(n)</code></td>
                <td><code>ZodNumber.lt(value: number, message?): ZodNumber</code></td>
                <td>Less than (exclusive)</td>
            </tr>
            <tr>
                <td><code>.lte(n)</code></td>
                <td><code>ZodNumber.lte(value: number, message?): ZodNumber</code></td>
                <td>Alias for <code>.max()</code></td>
            </tr>
            <tr>
                <td><code>.multipleOf(n)</code></td>
                <td><code>ZodNumber.multipleOf(value: number, message?): ZodNumber</code></td>
                <td>Must be divisible by <code>n</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Chaining Example</b></li>
<pre><code class="language-ts line-numbers">const ageSchema = z.number().int().nonnegative().max(120);

ageSchema.parse(25);    // ✅ Returns 25
ageSchema.parse(25.5);  // ❌ Not an integer
ageSchema.parse(-1);    // ❌ Negative
ageSchema.parse(150);   // ❌ Exceeds max
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-composite-types">Composite Types</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Composite types allow you to create schemas for complex data structures.</li>
        <br/>
        <li>All below are factory functions on the <code>z</code> namespace.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>z.object()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.object&lt;T extends ZodRawShape&gt;(shape: T): ZodObject&lt;T&gt;</code></li>
        <br/>
        <li>Where <code>ZodRawShape = { [key: string]: ZodTypeAny }</code></li>
        <br/>
        <li>Creates a schema for an object with specified keys and their types.</li>
        <br/>
        <li>By default, unknown keys are stripped from output.</li>
    </ul>
<pre><code class="language-ts line-numbers">const UserSchema = z.object({
    name: z.string(),
    age: z.number(),
});

UserSchema.parse({ name: "Alice", age: 30 });
// ✅ Returns { name: "Alice", age: 30 }

UserSchema.parse({ name: "Bob", age: 25, extra: "ignored" });
// ✅ Returns { name: "Bob", age: 25 } — extra key stripped

UserSchema.parse({ name: "Charlie" });
// ❌ ZodError: age is required

UserSchema.parse({ name: "Dave", age: "thirty" });
// ❌ ZodError: age expected number, received string

// Type inference
type User = z.infer&lt;typeof UserSchema&gt;;
// { name: string; age: number }
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.array()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.array&lt;T extends ZodTypeAny&gt;(schema: T): ZodArray&lt;T&gt;</code></li>
        <br/>
        <li>Creates a schema for an array where each element matches the given schema.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.array(z.number());

schema.parse([1, 2, 3]);       // ✅ Returns [1, 2, 3]
schema.parse([]);              // ✅ Returns []
schema.parse([1, "two", 3]);   // ❌ ZodError: Expected number at index 1
schema.parse("not array");     // ❌ ZodError: Expected array

// Array-specific validators
z.array(z.string()).min(1);          // At least 1 element
z.array(z.string()).max(5);          // At most 5 elements
z.array(z.string()).length(3);       // Exactly 3 elements
z.array(z.string()).nonempty();      // Alias for .min(1), also narrows type
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.tuple()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">z.tuple&lt;T extends [ZodTypeAny, ...ZodTypeAny[]]&gt;(items: T): ZodTuple&lt;T&gt;

// With rest element
z.tuple&lt;T, R extends ZodTypeAny&gt;(items: T).rest(rest: R): ZodTuple&lt;T, R&gt;
</code></pre>
    <br/>
    <ul>
        <li>Creates a schema for a fixed-length array with specific types at each index.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.tuple([z.string(), z.number(), z.boolean()]);

schema.parse(["hello", 42, true]);   // ✅ Returns ["hello", 42, true]
schema.parse(["hi", 1, false]);      // ✅
schema.parse(["hello", 42]);         // ❌ ZodError: Expected 3 items, received 2
schema.parse([42, "hello", true]);   // ❌ ZodError: Type mismatch at index 0

// With rest element
const withRest = z.tuple([z.string(), z.number()]).rest(z.boolean());
withRest.parse(["a", 1]);                    // ✅
withRest.parse(["a", 1, true, false, true]); // ✅
withRest.parse(["a", 1, "nope"]);            // ❌ Rest element must be boolean
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.record()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">// Value-only (keys are strings)
z.record&lt;V extends ZodTypeAny&gt;(valueSchema: V): ZodRecord&lt;ZodString, V&gt;

// Key and value
z.record&lt;K extends ZodString | ZodEnum | ZodUnion, V extends ZodTypeAny&gt;(
    keySchema: K,
    valueSchema: V
): ZodRecord&lt;K, V&gt;
</code></pre>
    <br/>
    <ul>
        <li>Creates a schema for an object with arbitrary keys.</li>
        <br/>
        <li>Like TypeScript's <code>Record&lt;K, V&gt;</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">// String keys, number values
const scores = z.record(z.number());

scores.parse({ alice: 100, bob: 85 });  // ✅
scores.parse({});                        // ✅
scores.parse({ alice: "high" });         // ❌ Value must be number

// Constrained keys with enum
const StatusMap = z.record(
    z.enum(["pending", "active", "done"]),
    z.boolean()
);

StatusMap.parse({ pending: true, active: false });  // ✅
StatusMap.parse({ invalid: true });                 // ❌ Invalid key
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.map()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.map&lt;K extends ZodTypeAny, V extends ZodTypeAny&gt;(keySchema: K, valueSchema: V): ZodMap&lt;K, V&gt;</code></li>
        <br/>
        <li>Creates a schema for JavaScript <code>Map</code> objects.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.map(z.string(), z.number());

const validMap = new Map([["a", 1], ["b", 2]]);
const invalidMap = new Map([["a", "one"]]);

schema.parse(validMap);     // ✅ Returns Map { "a" => 1, "b" => 2 }
schema.parse(invalidMap);   // ❌ ZodError: Value must be number
schema.parse({});           // ❌ ZodError: Expected Map
schema.parse(new Map());    // ✅ Empty map is valid
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.set()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.set&lt;T extends ZodTypeAny&gt;(valueSchema: T): ZodSet&lt;T&gt;</code></li>
        <br/>
        <li>Creates a schema for JavaScript <code>Set</code> objects.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.set(z.number());

schema.parse(new Set([1, 2, 3]));      // ✅ Returns Set { 1, 2, 3 }
schema.parse(new Set());               // ✅ Empty set
schema.parse(new Set([1, "two"]));     // ❌ ZodError: Expected number
schema.parse([1, 2, 3]);               // ❌ ZodError: Expected Set

// Size constraints
z.set(z.string()).min(1);    // At least 1 element
z.set(z.string()).max(10);   // At most 10 elements
z.set(z.string()).size(5);   // Exactly 5 elements
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.enum()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.enum&lt;T extends [string, ...string[]]&gt;(values: T): ZodEnum&lt;T&gt;</code></li>
        <br/>
        <li>Creates a schema for a set of allowed string literals.</li>
        <br/>
        <li>Provides autocomplete and type safety.</li>
    </ul>
<pre><code class="language-ts line-numbers">const Status = z.enum(["pending", "active", "completed"]);

Status.parse("active");      // ✅ Returns "active"
Status.parse("pending");     // ✅
Status.parse("invalid");     // ❌ ZodError: Invalid enum value
Status.parse(123);           // ❌ ZodError: Expected string

// Access enum values
Status.options;              // ["pending", "active", "completed"]
Status.enum.active;          // "active" (for autocomplete)

// Type inference
type Status = z.infer&lt;typeof Status&gt;;  // "pending" | "active" | "completed"
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.nativeEnum()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.nativeEnum&lt;T extends EnumLike&gt;(enum: T): ZodNativeEnum&lt;T&gt;</code></li>
        <br/>
        <li>Where <code>EnumLike = { [key: string]: string | number }</code></li>
        <br/>
        <li>Creates a schema from an existing TypeScript <code>enum</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}

const schema = z.nativeEnum(Direction);

schema.parse("UP");           // ✅ Returns "UP"
schema.parse(Direction.Up);   // ✅ Returns "UP"
schema.parse("DIAGONAL");     // ❌ ZodError: Invalid enum value

// Numeric enums
enum StatusCode {
    OK = 200,
    NotFound = 404,
}

const codeSchema = z.nativeEnum(StatusCode);
codeSchema.parse(200);        // ✅
codeSchema.parse(500);        // ❌
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.union()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.union&lt;T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]&gt;(types: T): ZodUnion&lt;T&gt;</code></li>
        <br/>
        <li>Creates a schema that accepts any of the given types.</li>
        <br/>
        <li>Tries each in order.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.union([z.string(), z.number()]);

schema.parse("hello");   // ✅ Returns "hello"
schema.parse(42);        // ✅ Returns 42
schema.parse(true);      // ❌ ZodError: Invalid input

// Shorthand with .or()
const same = z.string().or(z.number());

// Complex union
const Response = z.union([
    z.object({ success: z.literal(true), data: z.string() }),
    z.object({ success: z.literal(false), error: z.string() }),
]);
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.discriminatedUnion()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">z.discriminatedUnion&lt;
    Discriminator extends string,
    Types extends [ZodObject&lt;any&gt;, ...ZodObject&lt;any&gt;[]]
&gt;(discriminator: Discriminator, types: Types): ZodDiscriminatedUnion&lt;Discriminator, Types&gt;
</code></pre>
    <br/>
    <ul>
        <li>Optimized union for objects sharing a common discriminator key.</li>
        <br/>
        <li>Better performance and error messages than <code>z.union()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const Result = z.discriminatedUnion("status", [
    z.object({ status: z.literal("success"), data: z.string() }),
    z.object({ status: z.literal("error"), message: z.string() }),
]);

Result.parse({ status: "success", data: "hello" });
// ✅ Returns { status: "success", data: "hello" }

Result.parse({ status: "error", message: "failed" });
// ✅

Result.parse({ status: "error", data: "wrong field" });
// ❌ ZodError: message is required (knows which branch based on "status")

Result.parse({ status: "unknown" });
// ❌ ZodError: Invalid discriminator value
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.intersection()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.intersection&lt;L extends ZodTypeAny, R extends ZodTypeAny&gt;(left: L, right: R): ZodIntersection&lt;L, R&gt;</code></li>
        <br/>
        <li>Combines two schemas — value must satisfy both.</li>
        <br/>
        <li>Like TypeScript's <code>A &amp; B</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const A = z.object({ a: z.string() });
const B = z.object({ b: z.number() });

const schema = z.intersection(A, B);

schema.parse({ a: "hello", b: 42 });  // ✅ Returns { a: "hello", b: 42 }
schema.parse({ a: "hello" });          // ❌ ZodError: b is required
schema.parse({ b: 42 });               // ❌ ZodError: a is required

// Shorthand with .and()
const same = A.and(B);
</code></pre>
    <br/>
    <ul>
        <li><b>Note:</b> For merging objects, <code>.merge()</code> is often preferred over intersection.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>z.literal()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.literal&lt;T extends Primitive&gt;(value: T): ZodLiteral&lt;T&gt;</code></li>
        <br/>
        <li>Where <code>Primitive = string | number | boolean | bigint | symbol | null | undefined</code></li>
        <br/>
        <li>Creates a schema that matches exactly one specific primitive value.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.literal("hello");

schema.parse("hello");   // ✅ Returns "hello"
schema.parse("Hello");   // ❌ ZodError: Expected "hello"
schema.parse("bye");     // ❌ ZodError

// Other literal types
z.literal(42).parse(42);         // ✅
z.literal(true).parse(true);     // ✅
z.literal(null).parse(null);     // ✅

// Commonly used in discriminated unions
const Event = z.discriminatedUnion("type", [
    z.object({ type: z.literal("click"), x: z.number(), y: z.number() }),
    z.object({ type: z.literal("keydown"), key: z.string() }),
]);
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-modifiers">Modifiers</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Modifiers change how a schema handles optional, nullable, or default values.</li>
        <br/>
        <li>All methods below can be called on any <code>ZodType</code> instance.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.optional()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.optional(): ZodOptional&lt;ZodType&lt;T&gt;&gt;</code></li>
        <br/>
        <li>Resulting type: <code>T | undefined</code></li>
        <br/>
        <li>Makes the value optional — <code>undefined</code> is accepted.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().optional();

schema.parse("hello");    // ✅ Returns "hello"
schema.parse(undefined);  // ✅ Returns undefined
schema.parse(null);       // ❌ ZodError: Expected string, received null

// In objects
const User = z.object({
    name: z.string(),
    bio: z.string().optional(),
});

User.parse({ name: "Alice" });                  // ✅ { name: "Alice" }
User.parse({ name: "Bob", bio: "Developer" }); // ✅ { name: "Bob", bio: "Developer" }
</code></pre>
    <br/>
    <br/>


    <li><b><code>.nullable()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.nullable(): ZodNullable&lt;ZodType&lt;T&gt;&gt;</code></li>
        <br/>
        <li>Resulting type: <code>T | null</code></li>
        <br/>
        <li>Allows <code>null</code> as a valid value.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().nullable();

schema.parse("hello");    // ✅ Returns "hello"
schema.parse(null);       // ✅ Returns null
schema.parse(undefined);  // ❌ ZodError: Expected string, received undefined
</code></pre>
    <br/>
    <br/>


    <li><b><code>.nullish()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.nullish(): ZodOptional&lt;ZodNullable&lt;ZodType&lt;T&gt;&gt;&gt;</code></li>
        <br/>
        <li>Resulting type: <code>T | null | undefined</code></li>
        <br/>
        <li>Allows both <code>null</code> and <code>undefined</code>.</li>
        <br/>
        <li>Equivalent to <code>.nullable().optional()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().nullish();

schema.parse("hello");    // ✅ Returns "hello"
schema.parse(null);       // ✅ Returns null
schema.parse(undefined);  // ✅ Returns undefined
schema.parse(123);        // ❌ ZodError
</code></pre>
    <br/>
    <br/>


    <li><b><code>.default()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodType&lt;T&gt;.default(defaultValue: T): ZodDefault&lt;ZodType&lt;T&gt;&gt;
ZodType&lt;T&gt;.default(defaultFn: () =&gt; T): ZodDefault&lt;ZodType&lt;T&gt;&gt;
</code></pre>
    <br/>
    <ul>
        <li>Provides a default value when input is <code>undefined</code>.</li>
        <br/>
        <li>Accepts a value or a function (for mutable/dynamic defaults).</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().default("anonymous");

schema.parse("Alice");     // ✅ Returns "Alice"
schema.parse(undefined);   // ✅ Returns "anonymous"
schema.parse(null);        // ❌ ZodError (null ≠ undefined)

// Function form (avoids shared mutable reference)
const withArray = z.array(z.string()).default(() => []);
withArray.parse(undefined);  // ✅ Returns [] (new array each time)

// In objects — missing keys are undefined
const Config = z.object({
    port: z.number().default(3000),
    host: z.string().default("localhost"),
});

Config.parse({});  // ✅ { port: 3000, host: "localhost" }
</code></pre>
    <br/>
    <br/>


    <li><b><code>.catch()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodType&lt;T&gt;.catch(catchValue: T): ZodCatch&lt;ZodType&lt;T&gt;&gt;
ZodType&lt;T&gt;.catch(catchFn: (ctx: { error: ZodError; input: unknown }) =&gt; T): ZodCatch&lt;ZodType&lt;T&gt;&gt;
</code></pre>
    <br/>
    <ul>
        <li>Returns a fallback value when validation fails (instead of throwing).</li>
        <br/>
        <li>Unlike <code>.default()</code>, this catches <b>any</b> invalid input, not just <code>undefined</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().catch("fallback");

schema.parse("hello");     // ✅ Returns "hello"
schema.parse(undefined);   // ✅ Returns "fallback"
schema.parse(null);        // ✅ Returns "fallback"
schema.parse(123);         // ✅ Returns "fallback"

// Function form with context
const smart = z.number().catch((ctx) => {
    console.log("Invalid input:", ctx.input);
    return 0;
});
smart.parse("bad");  // ✅ Returns 0, logs "Invalid input: bad"
</code></pre>
    <br/>
    <ul>
        <li><b>Comparison:</b></li>
    </ul>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Input</th>
                <th><code>.default("x")</code></th>
                <th><code>.catch("x")</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>undefined</code></td>
                <td><code>"x"</code></td>
                <td><code>"x"</code></td>
            </tr>
            <tr>
                <td><code>null</code></td>
                <td>❌ throws</td>
                <td><code>"x"</code></td>
            </tr>
            <tr>
                <td><code>123</code></td>
                <td>❌ throws</td>
                <td><code>"x"</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b><code>.readonly()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.readonly(): ZodReadonly&lt;ZodType&lt;T&gt;&gt;</code></li>
        <br/>
        <li>Resulting type: <code>Readonly&lt;T&gt;</code> (for objects/arrays)</li>
        <br/>
        <li>Marks the output type as <code>readonly</code> in TypeScript.</li>
        <br/>
        <li>No runtime effect — purely for type inference.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.object({
    name: z.string(),
    tags: z.array(z.string()),
}).readonly();

type Result = z.infer&lt;typeof schema&gt;;
// {
//   readonly name: string;
//   readonly tags: readonly string[];
// }

const data = schema.parse({ name: "Test", tags: ["a", "b"] });
data.name = "New";      // ❌ TypeScript error: Cannot assign to 'name'
data.tags.push("c");    // ❌ TypeScript error: Property 'push' does not exist

// Runtime: no enforcement
(data as any).name = "Mutated";  // Works at runtime
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-object-utilities">Object Utilities</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>All methods below are called on a <code>ZodObject</code> instance.</li>
        <br/>
        <li>They allow you to derive new schemas from existing object schemas.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.extend()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.extend&lt;U extends ZodRawShape&gt;(shape: U): ZodObject&lt;T &amp; U&gt;</code></li>
        <br/>
        <li>Adds new fields to an object schema.</li>
        <br/>
        <li>Overwrites existing keys if duplicated.</li>
    </ul>
<pre><code class="language-ts line-numbers">const Base = z.object({ name: z.string() });
const Extended = Base.extend({ age: z.number() });

Extended.parse({ name: "Alice", age: 30 });  // ✅
Extended.parse({ name: "Bob" });              // ❌ age required

// Overwriting keys
const Overwritten = Base.extend({ name: z.number() });
Overwritten.parse({ name: 123 });  // ✅ name is now number
</code></pre>
    <br/>
    <br/>


    <li><b><code>.merge()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.merge&lt;U extends ZodObject&gt;(other: U): ZodObject&lt;T &amp; U["shape"]&gt;</code></li>
        <br/>
        <li>Merges two object schemas.</li>
        <br/>
        <li>Similar to <code>.extend()</code>, but takes a <code>ZodObject</code> instead of a raw shape.</li>
    </ul>
<pre><code class="language-ts line-numbers">const A = z.object({ a: z.string() });
const B = z.object({ b: z.number() });
const Merged = A.merge(B);

Merged.parse({ a: "hello", b: 42 });  // ✅
Merged.parse({ a: "hello" });          // ❌ b required

// Type: { a: string; b: number }
</code></pre>
    <br/>
    <ul>
        <li><b>Note:</b> <code>.merge()</code> doesn't preserve modifiers like <code>.strict()</code>. Use <code>.extend()</code> if you need that.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.pick()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.pick&lt;K extends keyof T&gt;(keys: { [k in K]: true }): ZodObject&lt;Pick&lt;T, K&gt;&gt;</code></li>
        <br/>
        <li>Creates a new schema with only the specified keys.</li>
    </ul>
<pre><code class="language-ts line-numbers">const User = z.object({
    id: z.number(),
    name: z.string(),
    email: z.string(),
    password: z.string(),
});

const PublicUser = User.pick({ name: true, email: true });

PublicUser.parse({ name: "Alice", email: "a@b.com" });  // ✅
PublicUser.parse({ name: "Alice", email: "a@b.com", password: "x" });
// ✅ Returns { name, email } — extra keys stripped
</code></pre>
    <br/>
    <br/>


    <li><b><code>.omit()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.omit&lt;K extends keyof T&gt;(keys: { [k in K]: true }): ZodObject&lt;Omit&lt;T, K&gt;&gt;</code></li>
        <br/>
        <li>Creates a new schema without the specified keys.</li>
    </ul>
<pre><code class="language-ts line-numbers">const User = z.object({
    id: z.number(),
    name: z.string(),
    password: z.string(),
});

const SafeUser = User.omit({ password: true });

SafeUser.parse({ id: 1, name: "Alice" });  // ✅
// Type: { id: number; name: string }
</code></pre>
    <br/>
    <br/>


    <li><b><code>.partial()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodObject&lt;T&gt;.partial(): ZodObject&lt;{ [K in keyof T]: ZodOptional&lt;T[K]&gt; }&gt;
ZodObject&lt;T&gt;.partial&lt;K extends keyof T&gt;(keys: { [k in K]: true }): ZodObject&lt;...&gt;
</code></pre>
    <br/>
    <ul>
        <li>Makes all (or specified) keys optional.</li>
    </ul>
<pre><code class="language-ts line-numbers">const User = z.object({
    name: z.string(),
    age: z.number(),
});

const PartialUser = User.partial();
PartialUser.parse({});                    // ✅
PartialUser.parse({ name: "Alice" });     // ✅
PartialUser.parse({ age: 30 });           // ✅

// Partial specific keys
const PartialAge = User.partial({ age: true });
PartialAge.parse({ name: "Alice" });      // ✅ age optional
PartialAge.parse({});                     // ❌ name required
</code></pre>
    <br/>
    <br/>


    <li><b><code>.deepPartial()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.deepPartial(): ZodObject&lt;DeepPartial&lt;T&gt;&gt;</code></li>
        <br/>
        <li>Recursively makes all nested object keys optional.</li>
    </ul>
<pre><code class="language-ts line-numbers">const Schema = z.object({
    user: z.object({
        name: z.string(),
        address: z.object({
            city: z.string(),
        }),
    }),
});

const Deep = Schema.deepPartial();

Deep.parse({});                          // ✅
Deep.parse({ user: {} });                // ✅
Deep.parse({ user: { address: {} } });   // ✅
</code></pre>
    <br/>
    <br/>


    <li><b><code>.required()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodObject&lt;T&gt;.required(): ZodObject&lt;{ [K in keyof T]: ZodNonOptional&lt;T[K]&gt; }&gt;
ZodObject&lt;T&gt;.required&lt;K extends keyof T&gt;(keys: { [k in K]: true }): ZodObject&lt;...&gt;
</code></pre>
    <br/>
    <ul>
        <li>Makes all (or specified) optional keys required.</li>
        <br/>
        <li>Opposite of <code>.partial()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const Base = z.object({
    name: z.string().optional(),
    age: z.number().optional(),
});

const Required = Base.required();
Required.parse({ name: "Alice", age: 30 });  // ✅
Required.parse({ name: "Alice" });            // ❌ age required

// Specific keys
const NameRequired = Base.required({ name: true });
NameRequired.parse({ name: "Alice" });        // ✅ age still optional
</code></pre>
    <br/>
    <br/>


    <li><b><code>.passthrough()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.passthrough(): ZodObject&lt;T, "passthrough"&gt;</code></li>
        <br/>
        <li>Preserves unknown keys in output (default behavior strips them).</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.object({ name: z.string() }).passthrough();

schema.parse({ name: "Alice", extra: "kept" });
// ✅ Returns { name: "Alice", extra: "kept" }

// Compare to default
z.object({ name: z.string() }).parse({ name: "Alice", extra: "stripped" });
// ✅ Returns { name: "Alice" } — extra removed
</code></pre>
    <br/>
    <br/>


    <li><b><code>.strict()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.strict(): ZodObject&lt;T, "strict"&gt;</code></li>
        <br/>
        <li>Fails validation if unknown keys are present.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.object({ name: z.string() }).strict();

schema.parse({ name: "Alice" });              // ✅
schema.parse({ name: "Alice", extra: 1 });    // ❌ ZodError: Unrecognized key "extra"
</code></pre>
    <br/>
    <br/>


    <li><b><code>.strip()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.strip(): ZodObject&lt;T, "strip"&gt;</code></li>
        <br/>
        <li>Removes unknown keys from output.</li>
        <br/>
        <li>This is the default behavior, but useful to reset after <code>.passthrough()</code> or <code>.strict()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">const passthrough = z.object({ a: z.string() }).passthrough();
const stripped = passthrough.strip();

stripped.parse({ a: "hi", b: "removed" });  // ✅ { a: "hi" }
</code></pre>
    <br/>
    <br/>


    <li><b><code>.keyof()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodObject&lt;T&gt;.keyof(): ZodEnum&lt;[keyof T, ...Array&lt;keyof T&gt;]&gt;</code></li>
        <br/>
        <li>Returns a <code>ZodEnum</code> of the object's keys.</li>
    </ul>
<pre><code class="language-ts line-numbers">const User = z.object({
    id: z.number(),
    name: z.string(),
    email: z.string(),
});

const UserKey = User.keyof();

UserKey.parse("id");       // ✅
UserKey.parse("name");     // ✅
UserKey.parse("password"); // ❌ Invalid enum value

// Type: "id" | "name" | "email"
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-transformations-refinements">Transformations &amp; Refinements</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>All methods below can be called on any <code>ZodType</code> instance.</li>
        <br/>
        <li>Refinements add custom validation logic.</li>
        <br/>
        <li>Transformations change the output value or type.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.transform()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.transform&lt;U&gt;(fn: (value: T, ctx: RefinementCtx) =&gt; U): ZodEffects&lt;ZodType&lt;T&gt;, U&gt;</code></li>
        <br/>
        <li>Transforms the validated value into a different value/type.</li>
        <br/>
        <li>Runs after validation passes.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().transform((val) =&gt; val.length);

schema.parse("hello");   // ✅ Returns 5 (number)
schema.parse("");        // ✅ Returns 0

// String to Date
const dateSchema = z.string().transform((val) =&gt; new Date(val));
dateSchema.parse("2024-01-15");  // ✅ Returns Date object

// Type changes
type Input = z.input&lt;typeof schema&gt;;   // string
type Output = z.output&lt;typeof schema&gt;; // number

// Chained transforms
const chain = z.string()
    .transform((s) =&gt; s.trim())
    .transform((s) =&gt; s.toUpperCase())
    .transform((s) =&gt; s.split(""));

chain.parse("  hi  ");  // ✅ Returns ["H", "I"]
</code></pre>
    <br/>
    <br/>


    <li><b><code>.refine()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodType&lt;T&gt;.refine(
    check: (value: T) =&gt; boolean | Promise&lt;boolean&gt;,
    message?: string | { message?: string; path?: (string | number)[]; params?: object }
): ZodEffects&lt;ZodType&lt;T&gt;, T&gt;
</code></pre>
    <br/>
    <ul>
        <li>Adds custom validation logic.</li>
        <br/>
        <li>Returns <code>true</code> to pass, <code>false</code> to fail.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().refine((val) =&gt; val.includes("@"), {
    message: "Must contain @",
});

schema.parse("user@example.com");  // ✅
schema.parse("invalid");            // ❌ ZodError: Must contain @

// Multiple refinements
const password = z.string()
    .min(8)
    .refine((val) =&gt; /[A-Z]/.test(val), "Must contain uppercase")
    .refine((val) =&gt; /[0-9]/.test(val), "Must contain number");

password.parse("weakpass");   // ❌ Must contain uppercase
password.parse("Weakpass");   // ❌ Must contain number
password.parse("Strong1x");   // ✅

// Object-level refinement
const Form = z.object({
    password: z.string(),
    confirm: z.string(),
}).refine((data) =&gt; data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"],  // Error appears on confirm field
});
</code></pre>
    <br/>
    <br/>


    <li><b><code>.superRefine()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodType&lt;T&gt;.superRefine(
    fn: (value: T, ctx: RefinementCtx) =&gt; void | Promise&lt;void&gt;
): ZodEffects&lt;ZodType&lt;T&gt;, T&gt;
</code></pre>
    <br/>
    <ul>
        <li>Advanced refinement with full control.</li>
        <br/>
        <li>Add multiple errors, custom error codes, or abort early.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().superRefine((val, ctx) =&gt; {
    if (val.length &lt; 3) {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "Too short",
        });
    }
    if (!val.includes("@")) {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "Must contain @",
        });
    }
});

schema.parse("ab");  // ❌ Two errors: "Too short" AND "Must contain @"

// Abort early with fatal flag
const abortEarly = z.string().superRefine((val, ctx) =&gt; {
    if (val.length === 0) {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "Required",
            fatal: true,  // Stops further refinements
        });
        return z.NEVER;
    }
});
</code></pre>
    <br/>
    <br/>


    <li><b><code>z.preprocess()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>z.preprocess&lt;T extends ZodTypeAny&gt;(fn: (value: unknown) =&gt; unknown, schema: T): ZodEffects&lt;T&gt;</code></li>
        <br/>
        <li>Transforms input <b>before</b> validation.</li>
        <br/>
        <li>Useful for coercion from unknown input.</li>
    </ul>
<pre><code class="language-ts line-numbers">// Coerce string to number
const numSchema = z.preprocess(
    (val) =&gt; (typeof val === "string" ? parseInt(val, 10) : val),
    z.number()
);

numSchema.parse("42");   // ✅ Returns 42
numSchema.parse(42);     // ✅ Returns 42
numSchema.parse("abc");  // ❌ NaN fails z.number()

// Normalize empty strings to undefined
const optionalString = z.preprocess(
    (val) =&gt; (val === "" ? undefined : val),
    z.string().optional()
);

optionalString.parse("");         // ✅ Returns undefined
optionalString.parse("hello");    // ✅ Returns "hello"

// Parse JSON
const jsonSchema = z.preprocess(
    (val) =&gt; (typeof val === "string" ? JSON.parse(val) : val),
    z.object({ name: z.string() })
);

jsonSchema.parse('{"name":"Alice"}');  // ✅ { name: "Alice" }
</code></pre>
    <br/>
    <ul>
        <li><b>Note:</b> Zod also provides <code>z.coerce.*</code> shortcuts: <code>z.coerce.number()</code>, <code>z.coerce.string()</code>, etc.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.pipe()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.pipe&lt;U extends ZodTypeAny&gt;(schema: U): ZodPipeline&lt;ZodType&lt;T&gt;, U&gt;</code></li>
        <br/>
        <li>Chains schemas — output of first becomes input of second.</li>
        <br/>
        <li>Useful for transform → validate sequences.</li>
    </ul>
<pre><code class="language-ts line-numbers">// Transform then validate
const schema = z.string()
    .transform((val) =&gt; val.length)
    .pipe(z.number().min(3));

schema.parse("hello");  // ✅ Returns 5
schema.parse("hi");     // ❌ ZodError: Number must be &gt;= 3

// Coerce and validate
const dateSchema = z.coerce.date().pipe(
    z.date().min(new Date("2020-01-01"))
);

dateSchema.parse("2024-01-01");  // ✅
dateSchema.parse("2019-01-01");  // ❌ Too early
</code></pre>
    <br/>
    <br/>


    <li><b>Comparison Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>When it runs</th>
                <th>Input</th>
                <th>Use case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>z.preprocess()</code></td>
                <td>Before validation</td>
                <td><code>unknown</code></td>
                <td>Coerce raw input</td>
            </tr>
            <tr>
                <td><code>.refine()</code></td>
                <td>After validation</td>
                <td><code>T</code></td>
                <td>Custom validation</td>
            </tr>
            <tr>
                <td><code>.superRefine()</code></td>
                <td>After validation</td>
                <td><code>T</code></td>
                <td>Multiple errors, complex logic</td>
            </tr>
            <tr>
                <td><code>.transform()</code></td>
                <td>After validation</td>
                <td><code>T</code></td>
                <td>Change value/type</td>
            </tr>
            <tr>
                <td><code>.pipe()</code></td>
                <td>After first schema</td>
                <td>Output of first</td>
                <td>Chain schemas</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="zod-parsing">Parsing</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>All methods below can be called on any <code>ZodType</code> instance.</li>
        <br/>
        <li>These methods validate input and return typed output.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>.parse()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.parse(data: unknown): T</code></li>
        <br/>
        <li>Validates input and returns typed output.</li>
        <br/>
        <li>Throws <code>ZodError</code> on failure.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string();

schema.parse("hello");   // ✅ Returns "hello"
schema.parse(123);       // ❌ Throws ZodError

// Catching errors
try {
    schema.parse(123);
} catch (e) {
    if (e instanceof z.ZodError) {
        console.log(e.errors);  // [{ code, message, path, ... }]
    }
}
</code></pre>
    <br/>
    <br/>


    <li><b><code>.safeParse()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodType&lt;T&gt;.safeParse(data: unknown):
    | { success: true; data: T }
    | { success: false; error: ZodError }
</code></pre>
    <br/>
    <ul>
        <li>Validates without throwing.</li>
        <br/>
        <li>Returns a discriminated union result.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.number();

const good = schema.safeParse(42);
// { success: true, data: 42 }

const bad = schema.safeParse("oops");
// { success: false, error: ZodError }

// Usage pattern
const result = schema.safeParse(input);
if (result.success) {
    console.log(result.data);  // Typed as number
} else {
    console.log(result.error.errors);
}
</code></pre>
    <br/>
    <br/>


    <li><b><code>.parseAsync()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b> <code>ZodType&lt;T&gt;.parseAsync(data: unknown): Promise&lt;T&gt;</code></li>
        <br/>
        <li>Async version of <code>.parse()</code>.</li>
        <br/>
        <li>Required when schema uses async refinements or transforms.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().refine(async (val) =&gt; {
    const exists = await checkDatabase(val);
    return !exists;
}, "Already taken");

await schema.parseAsync("newuser");  // ✅ Returns "newuser"
await schema.parseAsync("existing"); // ❌ Throws ZodError

// Note: calling .parse() on async schema throws
schema.parse("test");  // ❌ Throws: "Async refinement encountered"
</code></pre>
    <br/>
    <br/>


    <li><b><code>.safeParseAsync()</code></b></li>
    <br/>
    <ul>
        <li><b>Signature:</b></li>
    </ul>
<pre><code class="language-ts line-numbers">ZodType&lt;T&gt;.safeParseAsync(data: unknown): Promise&lt;
    | { success: true; data: T }
    | { success: false; error: ZodError }
&gt;
</code></pre>
    <br/>
    <ul>
        <li>Async version of <code>.safeParse()</code>.</li>
        <br/>
        <li>Non-throwing async validation.</li>
    </ul>
<pre><code class="language-ts line-numbers">const schema = z.string().transform(async (val) =&gt; {
    const user = await fetchUser(val);
    return user;
});

const result = await schema.safeParseAsync("user123");

if (result.success) {
    console.log(result.data);  // User object
} else {
    console.log(result.error);
}
</code></pre>
    <br/>
    <br/>


    <li><b>When to Use Each</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Throws</th>
                <th>Async</th>
                <th>Use case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>.parse()</code></td>
                <td>Yes</td>
                <td>No</td>
                <td>Simple validation, let errors propagate</td>
            </tr>
            <tr>
                <td><code>.safeParse()</code></td>
                <td>No</td>
                <td>No</td>
                <td>Handle errors locally, form validation</td>
            </tr>
            <tr>
                <td><code>.parseAsync()</code></td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Async refinements/transforms</td>
            </tr>
            <tr>
                <td><code>.safeParseAsync()</code></td>
                <td>No</td>
                <td>Yes</td>
                <td>Async + local error handling</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
