<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Angular</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    ins {
        background-color: #d4fcbc;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }

    del::before,
    ins::before {
        position: absolute;
        left: 0.5rem;
        font-family: monospace;
    }

    del::before {
        content: "−";
    }

    ins::before {
        content: "+";
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Angular</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Tips</h3>
<ol>
    <li>Separate words within a file name with hyphens (<code>-</code>). For example, a component named <code>UserProfile</code> has a file name <code>user-profile.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>For unit tests, end file names with <code>.spec.ts</code>.
        For example, the unit test file for the <code>UserProfile</code> component has the file name <code>user-profile.spec.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>All of your Angular UI code (TypeScript, HTML, and styles) should live inside a directory named <code>src</code>.<br/><br/>
        Code that's not related to UI, such as configuration files or scripts, should live outside the <code>src</code> directory.</li>
    <br/>
    <br/>
    <br/>
    <li>The code to start up, or bootstrap, an Angular application should always live in a file named <code>main.ts</code>.<br/><br/>
        This represents the primary entry point to the application.</li>
    <br/>
    <br/>
    <br/>
    <li>Angular components consist of a TypeScript file and, optionally, a template and one or more style files. You should group these together in the same directory.</li>
    <br/>
    <br/>
    <br/>
    <li>Avoid creating subdirectories based on the type of code that lives in those directories.<br/><br/>
        For example, avoid creating directories like <code>components/</code>, <code>directives/</code>, and <code>services/</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>Prefer the <code>inject()</code> function over constructor parameter injection.</li>
    <br/>
    <br/>
    <br/>
    <li>Use <code>protected</code> on class members that are only used by a component's template.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({
    ...,
    template: `<p>{{ fullName() }}</p>`,
})
export class UserProfile {
    firstName = input();
    lastName  = input();
    // `fullName` is not part of the component's public API, but is used in the template.
    protected fullName = computed(() =&gt; `${this.firstName()} ${this.lastName()}`);
}
</code></pre>
    <br/>
    <br/>
    <br/>
    <li>Use <code>readonly</code> for properties that shouldn't change.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({/* ... */})
export class UserProfile {
    readonly userId    = input();
    readonly userSaved = output();
    readonly userName  = model();
}
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Signals</h3>
<ol>
    <li><b>What is a signal?</b><br/><br/>
        A <code>signal</code> is a reactive value container that automatically notifies Angular when its content changes.<br/><br/>
        Unlike normal class properties, signals are tracked by Angular's change detection system — any component using them updates automatically.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, Component } from '@angular/core';

@Component({
    selector: 'counter-example',
    template: `
        &lt;h3&gt;Count: {{ count() }}&lt;/h3&gt;
        &lt;button (click)="increment()"&gt;+&lt;/button&gt;
    `,
    standalone: true,
})
export class CounterExample {
    count = signal(0);
    increment() {
        this.count.update(v =&gt; v + 1);
    }
}
</code></pre>
        <br/>
        Signals are functions — you read them by calling like <code>count()</code>, not <code>count</code>.
    </li>

    <br/><br/><br/>

    <li><b>Writable signals</b><br/><br/>
        A writable signal is a normal signal created with <code>signal()</code>. It can be changed with:
        <ul>
            <br/>
            <li><code>.set(newValue)</code> – replace the value directly</li>
            <br/>
            <li><code>.update(fn)</code> – change it based on its current value</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const counter = signal(0);

counter.set(10);          // sets value to 10
counter.update(v =&gt; v+1); // now 11
console.log(counter());   // prints 11
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Computed signals</b><br/><br/>
        Computed signals are read-only values derived from one or more other signals.
        They automatically recalculate when any of their dependencies change.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, computed } from '@angular/core';

const first = signal('Hwang');
const last  = signal('Fu');

const fullName = computed(() =&gt; `${first()} ${last()}`);

console.log(fullName());   // "Hwang Fu"

last.set('Fucius');
console.log(fullName());   // "Hwang Fucius" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Effects</b><br/><br/>
        An <code>effect()</code> runs a piece of code automatically whenever the signals it reads change.
        Useful for logging, animations, or syncing values.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, effect } from '@angular/core';

const count = signal(0);

effect(() =&gt; {
    console.log('Count changed:', count());
});

count.set(1);  // console logs: Count changed: 1
count.set(2);  // console logs: Count changed: 2
</code></pre>
        <br/>
        Angular automatically cleans up effects when their owner component is destroyed.
    </li>

    <br/><br/><br/>

    <li><b>Inputs and signals</b><br/><br/>
        You can also create component inputs that behave like signals using <code>input()</code>.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'user-card',
    template: `&lt;p&gt;Hello, {{ name() }}!&lt;/p&gt;`,
})
export class UserCard {
    name = input('Anonymous');   // signal-style input with default
}
</code></pre>
        <br/>
        <ul>
            <li><code>input()</code> → for reading input signals</li>
            <li><code>output()</code> → for emitting events</li>
            <li><code>model()</code> → for two-way binding (v18+)</li>
        </ul>
    </li>

    <br/><br/><br/>

    <li><b>Readonly vs writable signals</b><br/><br/>
        A computed signal is <code>readonly</code> by design, meaning you cannot call <code>.set()</code> or <code>.update()</code> on it.<br/><br/>
        Writable signals (<code>signal()</code>) can both be read and updated.
    </li>

    <br/><br/><br/>

    <li><b>Accessing signals from the template</b><br/><br/>
        In templates, signals behave like functions — you must call them:
<pre class="line-numbers"><code class="language-html">&lt;h2&gt;{{ count() }}&lt;/h2&gt;   &lt;!-- ✅ correct --&gt;
&lt;h2&gt;{{ count }}&lt;/h2&gt;     &lt;!-- ❌ won't update --&gt;
</code></pre>
        <br/>
        Angular automatically re-renders that part of the template when the signal changes.
    </li>

    <br/><br/><br/>

    <li><b>When to use signals?</b><br/><br/>
        <ul>
            <li>For local component state (form inputs, toggles, UI flags)</li>
            <br/>
            <li>For derived/computed data</li>
            <br/>
            <li>For lightweight reactivity without external stores</li>
            <br/>
            <li>Instead of RxJS <code>BehaviorSubject</code> for simple cases</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Linked Signals</h3>
<ol>
    <li><b>What is a linked signal?</b><br/><br/>
        A <code>linkedSignal()</code> is a special kind of signal that stays connected to another signal.<br/><br/>
        When the source signal changes, the linked one also updates automatically.<br/><br/>
        Think of it as a "live copy" or a "mirror" of another signal — but one that can also transform or filter the value.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, linkedSignal } from '@angular/core';

const name = signal('Hwangfu');

// Linked signal that always follows `name`
const upperName = linkedSignal(() =&gt; name().toUpperCase());

console.log(upperName()); // "HWANGFU"

name.set('Fucius');
console.log(upperName()); // "FUCIUS" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Why not just use <code>computed()</code>?</b><br/><br/>
        <code>computed()</code> and <code>linkedSignal()</code> look similar, but there's one key difference:<br/><br/>
        <ul>
            <li><code>computed()</code> → read-only, you can't change its value directly</li>
            <br/>
            <li><code>linkedSignal()</code> → can also be written to (you can modify it)</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const count = signal(0);

// Computed: only reads from count
const double = computed(() =&gt; count() * 2);

// Linked: can read and write
const mirror = linkedSignal(() =&gt; count(), {
    // define how writing back should work
    set: (newVal) =&gt; count.set(newVal),
});

mirror.set(5);
console.log(count()); // 5
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>When to use linked signals?</b><br/><br/>
        Linked signals are useful when two parts of your code need to share the same data, but maybe in a slightly different form.<br/><br/>
        For example, if you want to edit a copy of a user object without losing the original right away:
<pre class="line-numbers"><code class="language-ts">const activeUser = signal({ id: 1, name: 'Alice' });

// Create a linked version for editing
const editUser = linkedSignal(() =&gt; activeUser(), {
    // treat users with the same id as the same object
    equal: (a, b) =&gt; a.id === b.id,
});

console.log(editUser());  // { id: 1, name: 'Alice' }

editUser.update(u =&gt; ({ ...u, name: 'Alicia' }));
console.log(editUser().name);  // "Alicia"

// if `activeUser` changes, `editUser` also updates
activeUser.set({ id: 1, name: 'Alina' });
console.log(editUser().name);  // "Alina"
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Basic syntax patterns</b><br/><br/>
        You can define a linked signal in two common ways:
        <br/><br/>
        <b>1. Simple form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal(() =&gt; source());
</code></pre>
        <b>2. Detailed form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal({
    source: source,
    computation: (value) =&gt; value,
    equal: (a, b) =&gt; a.id === b.id,
});
</code></pre>
        <br/>
        The detailed form gives you more control: you can define how values are compared, or how they're computed.
    </li>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What does a CSS selector component do?</h3>
<ol>
    <li>When you write <code>@Component({ selector: 'button[type="reset"]' })</code>, Angular matches all elements in the DOM that fit this CSS selector.</li>
    <br/><br/>

    <li>If an element matches, Angular creates your component and attaches it to that element.</li>
    <br/><br/>

    <li>The element is NOT replaced. It stays the original tag. Angular just uses it as the host.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'button[type="reset"]',
    template: '<ng-content></ng-content>',
})
export class ResetButton {}
</code></pre>
    <br/>
    Any <code>&lt;button type="reset"&gt;</code> becomes a <code>ResetButton</code> component host.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Extend the example: make the reset button actually do things</h3>
<ol>
    <li>Below is a <code>ResetButton</code> component that:
        <ul>
            <br/>
            <li>adds classes (for styling)</li>
            <br/>
            <li>supports variants (<code>primary</code> / <code>ghost</code>)</li>
            <br/>
            <li>supports a <code>loading</code> state (shows a spinner, disables clicks)</li>
            <br/>
            <li>sets accessibility attributes (<code>aria-disabled</code>, <code>aria-busy</code>)</li>
            <br/>
            <li>keeps the original button text via <code>&lt;ng-content&gt;</code></li>
        </ul>
    </li>

    <br/><br/>

    <li>TypeScript (component):
<pre class="line-numbers"><code class="language-ts">import { Component, HostBinding, HostListener, Input } from '@angular/core';

@Component({
    selector: 'button[type="reset"]',
    // The host element IS the &lt;button&gt;. We only render inside it.
    template: `
        &lt;span class="content" [class.hidden]="loading"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/span&gt;
        &lt;span class="spinner" *ngIf="loading" aria-hidden="true"&gt;⏳&lt;/span&gt;
    `,
    styles: [`
        :host {
            /* base look */
            font: inherit;
            border-radius: 6px;
            padding: .5rem .9rem;
            cursor: pointer;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: .5rem;
            transition: background-color .15s ease, border-color .15s ease, color .15s ease;
        }

        /* variants via classes on :host */
        :host(.primary) {
            background: #0d6efd;
            color: white;
        }
        :host(.primary:hover) { background: #0b5ed7; }

        :host(.ghost) {
            background: transparent;
            color: #0d6efd;
            border-color: #0d6efd;
        }
        :host(.ghost:hover) { background: rgba(13,110,253,.08); }

        /* disabled look */
        :host(.disabled) {
            opacity: .55;
            cursor: not-allowed;
            pointer-events: none;
        }

        .spinner { display: inline-flex; }
        .content.hidden { visibility: hidden; } /* reserve space so width doesn't jump */
    `],
    standalone: true,
})
export class ResetButton {
    /** Visual variant */
    @Input() variant: 'primary' | 'ghost' = 'primary';

    /** Loading state: blocks clicks, shows spinner, updates aria */
    @Input() loading = false;

    /** Disable state (useful if you want to disable the reset button) */
    @Input() disabled = false;

    /** Reflect variant and states as CSS classes on the host &lt;button&gt; */
    @HostBinding('class')
    get hostClasses(): string {
        const v = this.variant ?? 'primary';
        return [v, this.disabled || this.loading ? 'disabled' : ''].filter(Boolean).join(' ');
    }

    /** Keep native semantics but add A11y hints */
    @HostBinding('attr.aria-disabled') get ariaDisabled() { return String(this.disabled); }
    @HostBinding('attr.aria-busy')     get ariaBusy()     { return String(this.loading); }

    /** Optional: ensure the host has type="reset" (safety if HTML missed it) */
    @HostBinding('attr.type') readonly type = 'reset';

    /** Block clicks when disabled/loading */
    @HostListener('click', ['$event'])
    onClick(ev: MouseEvent) {
        if (this.disabled || this.loading) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
        }
    }
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage examples:
<pre class="line-numbers"><code class="language-html">&lt;!-- Matches selector because it's a button[type="reset"] --&gt;
&lt;button type="reset" variant="primary"&gt;Reset form&lt;/button&gt;

&lt;!-- Switch variant --&gt;
&lt;button type="reset" variant="ghost"&gt;Clear&lt;/button&gt;

&lt;!-- Loading state --&gt;
&lt;button type="reset" variant="primary" [loading]="true"&gt;Resetting…&lt;/button&gt;

&lt;!-- Disabled state --&gt;
&lt;button type="reset" [disabled]="true"&gt;Disabled reset&lt;/button&gt;

&lt;!-- With projected rich content --&gt;
&lt;button type="reset" variant="primary"&gt;
    &lt;span class="hl-grey-fg"&gt;↺&lt;/span&gt;
    Reset filters
&lt;/button&gt;
</code></pre>
    </li>
    <br/><br/>

    <li>What changed compared to the minimal skeleton:
        <ul>
            <br/>
            <li><code>@Input()</code> values (<code>variant</code>, <code>loading</code>, <code>disabled</code>) so templates can control the button.</li>
            <br/>
            <li><code>@HostBinding</code> adds/removes CSS classes on the host <code>&lt;button&gt;</code>.</li>
            <br/>
            <li><code>@HostListener('click')</code> prevents clicks when disabled/loading.</li>
            <br/>
            <li><code>type="reset"</code> is enforced, so even if HTML forgot it, it behaves as a reset button.</li>
            <br/>
            <li>Simple styles are scoped to this component only.</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What does <code>selector: 'drop-zone, [dropzone]'</code> mean?</h3>
<ol>
    <li>This selector matches two things:
        <ul>
            <br/>
            <li><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;</code></li>
            <br/>
            <li>Any element with a <code>dropzone</code> attribute, like <code>&lt;div dropzone&gt;</code></li>
        </ul>
    </li>

    <br/>
    <br/>
    <br/>

    <li>Both become hosts for the <code>DropZone</code> component.</li>

    <br/>
    <br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '<ng-content></ng-content>',
})
export class DropZone {}
</code></pre>
    </li>

    <br/><br/>

    <li>The host element is NOT replaced, the component renders inside it.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to define a custom attribute (Angular Input)?</h3>
<ol>
    <li>You define a custom attribute using <code>@Input()</code>.</li>

    <br/><br/>

    <li>This does not create a real DOM attribute unless you bind it.</li>

    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone',
    template: '<ng-content></ng-content>',
})
export class DropZone {
    @Input() mode: 'files' | 'links' | 'images' = 'files';
}
</code></pre>

    Usage:
<pre><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;                (uses default: mode = "files")
&lt;drop-zone mode="links"&gt;&lt;/drop-zone&gt;   (sets mode = "links")
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to show the custom Input as a real HTML attribute?</h3>
<ol>
    <li>Use <code>@HostBinding('attr.&lt;attribute-name&gt;')</code>.</li>
    <br/><br/>

    <li>This makes the Input appear in the DOM inspector.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[dropzone]',
})
export class DropzoneDirective {
    @Input() dropzone: string = 'files';

    @HostBinding('attr.dropzone')
    get attrValue() {
        return this.dropzone;
    }
}
</code></pre>

    Resulting DOM:
<pre><code>&lt;div dropzone="files"&gt;&lt;/div&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Default boolean attribute with true/false behavior</h3>
<ol>
    <li>Use <code>booleanAttribute</code> transform.</li>
    <br/><br/>

    <li>This makes <code>appResizable</code> behave like a proper boolean.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[appResizable]',
})
export class ResizableDirective {
    @Input({ alias: 'appResizable', transform: booleanAttribute })
    resizable = true;

    @HostBinding('attr.data-resizable')
    get data() {
        return String(this.resizable);
    }
}
</code></pre>

    Usage:
<pre><code>&lt;div appResizable&gt;&lt;/div&gt;            (true by default)
&lt;div appResizable="true"&gt;&lt;/div&gt;     (true)
&lt;div [appResizable]="false"&gt;&lt;/div&gt;  (false)
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Setting a default DOM attribute directly</h3>
<ol>
    <li>If you just want an element to always have an attribute, bind it with HostBinding.</li>
    <br/><br/>

    <li>Example: default <code>type="reset"</code> for any button with a directive.
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: 'button[appResetDefault]',
})
export class ResetDefaultDirective {
    @HostBinding('attr.type') type = 'reset';
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage:
<pre><code>&lt;button appResetDefault&gt;Clear&lt;/button&gt;</code></pre>

    This becomes:
<pre><code>&lt;button type="reset"&gt;Clear&lt;/button&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Can multiple components be applied to one element?</h3>
<ol>
    <li>No — only one component can attach to a single element.</li>
    <br/><br/>

    <li>Directives can stack, but components cannot.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Component Selectors</h3>
<ol>
    <li><b>What is a component selector?</b></li>
    <br/>
    <ul>
        <li>The <code>selector</code> tells Angular where to place a component in the DOM.</li>
        <br/>
        <li>It lives in the <code>@Component({ ... })</code> metadata:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User card works&lt;/p&gt;`,
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Every time Angular sees <code>&lt;app-user-card&gt;</code> in a template, it creates a <code>UserCard</code> component there.</li>
        <br/>
        <li>The element itself becomes the host of the component. It is not replaced.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Element selectors</b></li>
    <br/>
    <ul>
        <li>This is the most common style.</li>
        <br/>
        <li>The selector looks like a custom HTML tag name:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-profile',
    template: `&lt;h2&gt;Profile&lt;/h2&gt;`,
})
export class ProfileComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Usage in another template --&gt;
&lt;app-profile&gt;&lt;/app-profile&gt;
</code></pre>
    <br/>
    <ul>
        <li>Use <b>kebab-case</b> (lowercase with dashes): <code>app-profile</code>, <code>user-card</code>, etc.</li>
        <br/>
        <li>Start with a prefix like <code>app-</code> (you can customize your own) to avoid conflicts with future HTML tags.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Attribute selectors</b></li>
    <br/>
    <ul>
        <li>An attribute selector matches normal HTML elements that have a certain attribute.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: '[appPanel]',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class PanelComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;section appPanel&gt;
    Panel content
&lt;/section&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the host is the existing <code>&lt;section&gt;</code> element.</li>
        <br/>
        <li>Use attribute selectors when you want to "enhance" an existing element, not introduce a new tag.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Multiple selectors</b></li>
    <br/>
    <ul>
        <li>You can combine selectors with commas.</li>
        <br/>
        <li>Example (similar to your drop zone example):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '&lt;ng-content&gt;&lt;/ng-content&gt;',
})
export class DropZoneComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Both usages match the same component --&gt;
&lt;drop-zone&gt;Drop files here&lt;/drop-zone&gt;

&lt;div dropzone&gt;Drop files here&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Both an element <code>&lt;drop-zone&gt;</code> and any element with the <code>dropzone</code> attribute become hosts for the same component.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CSS selectors</b></li>
    <br/>
    <ul>
        <li>The <code>selector</code> field accepts valid CSS selectors.</li>
        <br/>
        <li>For example, matching all reset buttons:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'button[type="reset"]',
    template: '&lt;ng-content&gt;&lt;/ng-content&gt;',
})
export class ResetButtonComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;button type="reset"&gt;Reset form&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li>Every <code>&lt;button type="reset"&gt;</code> now becomes a <code>ResetButtonComponent</code> host.</li>
        <br/>
        <li>Be careful with very broad selectors like <code>div</code> or <code>button</code>, they can match too many elements and make templates confusing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>One component per element</b></li>
    <br/>
    <ul>
        <li>Only one component can attach to a single element.</li>
        <br/>
        <li>Directives (like attribute directives) can stack, but components cannot.</li>
        <br/>
        <li>If two component selectors both match the same element, Angular will throw an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Naming and best practices</b></li>
    <br/>
    <ul>
        <li>Use a clear prefix (e.g. <code>app-</code>, <code>admin-</code>, <code>shared-</code>).</li>
        <br/>
        <li>Element selectors for main UI blocks:
<pre><code class="language-text">
app-header, app-footer, app-user-card
</code></pre>
        </li>
        <br/>
        <li>Attribute selectors for behavior-like components or directive-style helpers:
<pre><code class="language-text">
[appPanel], [appResetDefault], [dropzone]
</code></pre>
        </li>
        <br/>
        <li>Keep selectors specific enough so it is obvious where a component is used.</li>
        <br/>
        <li>Do not reuse the same selector name for different components.</li>
    </ul>
    <br/>
    <br/>


    <li><b>How Angular uses the selector</b></li>
    <br/>
    <ul>
        <li>During compilation, Angular scans your templates.</li>
        <br/>
        <li>When it finds something that matches a component's selector, it:
            <ul>
                <li>Creates an instance of that component,</li>
                <li>Attaches it to the matching DOM element (host),</li>
                <li>Renders the component's template inside that host.</li>
            </ul>
        </li>
        <br/>
        <li>The host element is kept. Angular only controls what is rendered inside it and its attributes / classes.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Styling Components</h3>
<ol>
    <li><b>Where do component styles live?</b></li>
    <br/>
    <ul>
        <li>You can write styles directly in the component, or in a separate file.</li>
        <br/>
        <li>Inline styles (small components):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;div class="card"&gt;User card&lt;/div&gt;`,
    styles: [`
        .card {
            padding: 1rem;
            border-radius: .5rem;
            border: 1px solid #ddd;
        }
    `],
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Separate CSS/SCSS file (bigger components):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    templateUrl: './user-card.component.html',
    styleUrls: ['./user-card.component.css'],
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Use inline <code>styles</code> for quick examples or tiny components.</li>
        <br/>
        <li>Use <code>styleUrls</code> with a <code>.css</code> or <code>.scss</code> file for anything non-trivial.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Component styles are local</b></li>
    <br/>
    <ul>
        <li>By default, styles in a component only apply to that component's template.</li>
        <br/>
        <li>This means:
            <ul>
                <li>They do not "leak" into other components.</li>
                <li>You can reuse simple class names like <code>.title</code> in many components without conflicts.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-a',
    template: `&lt;h2 class="title"&gt;A&lt;/h2&gt;`,
    styles: [`.title { color: red; }`],
})
export class AComponent {}

@Component({
    selector: 'app-b',
    template: `&lt;h2 class="title"&gt;B&lt;/h2&gt;`,
    styles: [`.title { color: blue; }`],
})
export class BComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-a&gt;&lt;/app-a&gt;
&lt;app-b&gt;&lt;/app-b&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>A</code> is red and <code>B</code> is blue, even though both use the same class name.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Styling the host element with <code>:host</code></b></li>
    <br/>
    <ul>
        <li>The <code>:host</code> selector targets the <u>outer element</u> that holds your component.</li>
        <br/>
        <li>Example (similar to your reset button):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-pill-badge',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: inline-block;
            padding: .2rem .6rem;
            border-radius: 999px;
            background: #f0f4ff;
            color: #1f3b8f;
            font-size: .8rem;
        }
    `],
    standalone: true,
})
export class PillBadge {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-pill-badge&gt;New&lt;/app-pill-badge&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>:host</code> styles the <code>&lt;app-pill-badge&gt;</code> element itself.</li>
        <br/>
        <li>Use <code>:host</code> for width, padding, display, border, etc. of the component's root element.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Styling based on host classes: <code>:host(.some-class)</code></b></li>
    <br/>
    <ul>
        <li>You can change styles depending on classes applied to the host element.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: .75rem 1rem;
            border-radius: 4px;
        }

        :host(.info) {
            background: #e7f1ff;
            color: #0b4f9c;
        }

        :host(.error) {
            background: #ffe5e5;
            color: #a30000;
        }
    `],
    standalone: true,
})
export class AlertComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-alert class="info"&gt;Information&lt;/app-alert&gt;
&lt;app-alert class="error"&gt;Something went wrong&lt;/app-alert&gt;
</code></pre>
    <br/>
    <ul>
        <li>The same component can look different based on classes you add.</li>
        <br/>
        <li>This pattern is nice for variants like <code>primary</code>, <code>ghost</code>, <code>warning</code>, etc.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding classes and styles from TypeScript</b></li>
    <br/>
    <ul>
        <li>You can toggle CSS classes using property bindings.</li>
        <br/>
        <li>Simple class binding:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button
    class="btn"
    [class.btn-primary]="primary"
    [class.btn-disabled]="disabled"
&gt;
    Save
&lt;/button&gt;
</code></pre>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-save-button',
    templateUrl: './save-button.component.html',
})
export class SaveButtonComponent {
    primary = true;
    disabled = false;
}
</code></pre>
    <br/>
    <ul>
        <li>Style binding works similarly:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div [style.opacity]="disabled ? 0.5 : 1"&gt;Content&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Use these bindings when styles depend on component state (loading, error, active, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Component styles vs global styles</b></li>
    <br/>
    <ul>
        <li>Global styles live in files like <code>styles.css</code> at the root of your app.</li>
        <br/>
        <li>Use global styles for:
            <ul>
                <li>Page background, base font, body margin, etc.</li>
                <li>Theme variables (colors, spacing, typography).</li>
                <li>Reset/normalize styles.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-css line-numbers">/* styles.css */
html, body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #fafafa;
}
</code></pre>
    <br/>
    <ul>
        <li>Use component styles for:
            <ul>
                <li>Buttons, cards, forms, and layout that belong to one component.</li>
                <li>Anything that should not affect the whole app.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Light introduction to <code>:host-context()</code></b></li>
    <br/>
    <ul>
        <li><code>:host-context()</code> lets you style a component differently depending on something outside of it.</li>
        <br/>
        <li>Example: dark mode class on a parent element:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-box',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: 1rem;
            background: white;
            color: black;
        }

        :host-context(.dark-mode) {
            background: #1f2933;
            color: #f9fafb;
        }
    `],
})
export class BoxComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;div class="dark-mode"&gt;
    &lt;app-box&gt;This box appears in dark mode&lt;/app-box&gt;
&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>This is helpful if you have a global "theme" class but still want components to react to it.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Input properties</h3>
<ol>
    <li><b>What are input properties?</b></li>
    <br/>
    <ul>
        <li><code>@Input()</code> lets a parent component send data down to a child component.</li>
        <br/>
        <li>It works just like passing arguments into a function, but through HTML attributes.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-greeting',
    template: `&lt;h3&gt;Hello, {{ name }}!&lt;/h3&gt;`,
})
export class GreetingComponent {
    @Input() name = 'Guest';   // receives value from parent
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent template --&gt;
&lt;app-greeting name="Alice"&gt;&lt;/app-greeting&gt;
&lt;app-greeting name="Bob"&gt;&lt;/app-greeting&gt;
</code></pre>
    <br/>
    <ul>
        <li>The parent sets <code>name</code> just like a normal HTML attribute.</li>
        <br/>
        <li>Angular automatically passes that value into the child component's <code>@Input()</code> field.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding expressions to inputs</b></li>
    <br/>
    <ul>
        <li>You can also bind dynamic data using square brackets <code>[]</code>.</li>
        <br/>
        <li>This lets you send variables, not just strings.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-parent',
    template: `
        &lt;app-greeting [name]="userName"&gt;&lt;/app-greeting&gt;
    `,
})
export class ParentComponent {
    userName = 'Hwangfucius';
}
</code></pre>
    <br/>
    <br/>


    <li><b>Setting default values</b></li>
    <br/>
    <ul>
        <li>If the parent does not pass a value, the default value in the child is used.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User: {{ name }} ({{ role }})&lt;/p&gt;`,
})
export class UserCardComponent {
    @Input() name = 'Anonymous';
    @Input() role = 'Viewer';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-user-card&gt;&lt;/app-user-card&gt;
&lt;app-user-card name="Alice" role="Admin"&gt;&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>The first card uses defaults. The second one overrides both values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Renaming an input</b></li>
    <br/>
    <ul>
        <li>Sometimes, you want to expose a different name in HTML than in your class.</li>
        <br/>
        <li>You can do this by giving <code>@Input()</code> a string argument:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-book',
    template: `&lt;p&gt;Title: {{ title }}&lt;/p&gt;`,
})
export class BookComponent {
    @Input('bookTitle') title = '';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-book bookTitle="The Hobbit"&gt;&lt;/app-book&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the HTML uses <code>bookTitle</code>, but inside the component, the field name is <code>title</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Input type conversion (transforms)</b></li>
    <br/>
    <ul>
        <li>Starting from Angular 16+, you can add simple type transformations directly in the <code>@Input()</code> decorator.</li>
        <br/>
        <li>Example — converting attribute values into booleans:</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, Input, booleanAttribute } from '@angular/core';

@Component({
    selector: 'app-toggle',
    template: `&lt;button&gt;Enabled: {{ enabled }}&lt;/button&gt;`,
})
export class ToggleComponent {
    @Input({ transform: booleanAttribute }) enabled = false;
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-toggle enabled&gt;&lt;/app-toggle&gt;
&lt;app-toggle enabled="false"&gt;&lt;/app-toggle&gt;
&lt;app-toggle&gt;&lt;/app-toggle&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>booleanAttribute</code> helper makes <code>enabled</code> behave like a real HTML boolean attribute.</li>
        <br/>
        <li>The first one is <code>true</code>, the others are <code>false</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Signal-style inputs (Angular 17+)</b></li>
    <br/>
    <ul>
        <li>You can also define inputs as reactive signals using <code>input()</code>.</li>
        <br/>
        <li>This makes them automatically re-render when updated, no need for change detection tricks.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, input } from '@angular/core';

@Component({
    selector: 'app-profile',
    template: `&lt;p&gt;Welcome, {{ name() }}!&lt;/p&gt;`,
})
export class ProfileComponent {
    name = input('Guest');
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-profile name="Hwangfucius"&gt;&lt;/app-profile&gt;
</code></pre>
    <br/>
    <ul>
        <li>It behaves like <code>@Input()</code>, but integrates perfectly with the Angular signals system.</li>
        <br/>
        <li>In templates, signal inputs must be called like functions (<code>{{ name() }}</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Validating and reacting to input changes</b></li>
    <br/>
    <ul>
        <li>Sometimes, you want to run logic whenever an input changes.</li>
        <br/>
        <li>Two simple ways:</li>
    </ul>
<pre><code class="language-ts line-numbers">// 1. Use a setter
@Input()
set count(value: number) {
    console.log('Count changed to', value);
}

// 2. Use ngOnChanges (classic lifecycle hook)
ngOnChanges(changes: SimpleChanges) {
    console.log(changes);
}
</code></pre>
    <br/>
    <ul>
        <li>Setters are simpler for one property, <code>ngOnChanges</code> works if you have many inputs.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
<!-- * * * * * * * * * * * * * * -->
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
