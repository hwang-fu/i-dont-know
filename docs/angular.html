<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Angular</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    ins {
        background-color: #d4fcbc;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }

    del::before,
    ins::before {
        position: absolute;
        left: 0.5rem;
        font-family: monospace;
    }

    del::before {
        content: "−";
    }

    ins::before {
        content: "+";
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Angular</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Tips</h3>
<ol>
    <li>Separate words within a file name with hyphens (<code>-</code>). For example, a component named <code>UserProfile</code> has a file name <code>user-profile.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>For unit tests, end file names with <code>.spec.ts</code>.
        For example, the unit test file for the <code>UserProfile</code> component has the file name <code>user-profile.spec.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>All of your Angular UI code (TypeScript, HTML, and styles) should live inside a directory named <code>src</code>.<br/><br/>
        Code that's not related to UI, such as configuration files or scripts, should live outside the <code>src</code> directory.</li>
    <br/>
    <br/>
    <br/>
    <li>The code to start up, or bootstrap, an Angular application should always live in a file named <code>main.ts</code>.<br/><br/>
        This represents the primary entry point to the application.</li>
    <br/>
    <br/>
    <br/>
    <li>Angular components consist of a TypeScript file and, optionally, a template and one or more style files. You should group these together in the same directory.</li>
    <br/>
    <br/>
    <br/>
    <li>Avoid creating subdirectories based on the type of code that lives in those directories.<br/><br/>
        For example, avoid creating directories like <code>components/</code>, <code>directives/</code>, and <code>services/</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>Prefer the <code>inject()</code> function over constructor parameter injection.</li>
    <br/>
    <br/>
    <br/>
    <li>Use <code>protected</code> on class members that are only used by a component's template.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({
    ...,
    template: `<p>{{ fullName() }}</p>`,
})
export class UserProfile {
    firstName = input();
    lastName  = input();
    // `fullName` is not part of the component's public API, but is used in the template.
    protected fullName = computed(() =&gt; `${this.firstName()} ${this.lastName()}`);
}
</code></pre>
    <br/>
    <br/>
    <br/>
    <li>Use <code>readonly</code> for properties that shouldn't change.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({/* ... */})
export class UserProfile {
    readonly userId    = input();
    readonly userSaved = output();
    readonly userName  = model();
}
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Signals</h3>
<ol>
    <li><b>What is a signal?</b><br/><br/>
        A <code>signal</code> is a reactive value container that automatically notifies Angular when its content changes.<br/><br/>
        Unlike normal class properties, signals are tracked by Angular's change detection system — any component using them updates automatically.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, Component } from '@angular/core';

@Component({
    selector: 'counter-example',
    template: `
        &lt;h3&gt;Count: {{ count() }}&lt;/h3&gt;
        &lt;button (click)="increment()"&gt;+&lt;/button&gt;
    `,
    standalone: true,
})
export class CounterExample {
    count = signal(0);
    increment() {
        this.count.update(v =&gt; v + 1);
    }
}
</code></pre>
        <br/>
        Signals are functions — you read them by calling like <code>count()</code>, not <code>count</code>.
    </li>

    <br/><br/><br/>

    <li><b>Writable signals</b><br/><br/>
        A writable signal is a normal signal created with <code>signal()</code>. It can be changed with:
        <ul>
            <br/>
            <li><code>.set(newValue)</code> – replace the value directly</li>
            <br/>
            <li><code>.update(fn)</code> – change it based on its current value</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const counter = signal(0);

counter.set(10);          // sets value to 10
counter.update(v =&gt; v+1); // now 11
console.log(counter());   // prints 11
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Computed signals</b><br/><br/>
        Computed signals are read-only values derived from one or more other signals.
        They automatically recalculate when any of their dependencies change.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, computed } from '@angular/core';

const first = signal('Hwang');
const last  = signal('Fu');

const fullName = computed(() =&gt; `${first()} ${last()}`);

console.log(fullName());   // "Hwang Fu"

last.set('Fucius');
console.log(fullName());   // "Hwang Fucius" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Effects</b><br/><br/>
        An <code>effect()</code> runs a piece of code automatically whenever the signals it reads change.
        Useful for logging, animations, or syncing values.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, effect } from '@angular/core';

const count = signal(0);

effect(() =&gt; {
    console.log('Count changed:', count());
});

count.set(1);  // console logs: Count changed: 1
count.set(2);  // console logs: Count changed: 2
</code></pre>
        <br/>
        Angular automatically cleans up effects when their owner component is destroyed.
    </li>

    <br/><br/><br/>

    <li><b>Inputs and signals</b><br/><br/>
        You can also create component inputs that behave like signals using <code>input()</code>.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'user-card',
    template: `&lt;p&gt;Hello, {{ name() }}!&lt;/p&gt;`,
})
export class UserCard {
    name = input('Anonymous');   // signal-style input with default
}
</code></pre>
        <br/>
        <ul>
            <li><code>input()</code> → for reading input signals</li>
            <li><code>output()</code> → for emitting events</li>
            <li><code>model()</code> → for two-way binding (v18+)</li>
        </ul>
    </li>

    <br/><br/><br/>

    <li><b>Readonly vs writable signals</b><br/><br/>
        A computed signal is <code>readonly</code> by design, meaning you cannot call <code>.set()</code> or <code>.update()</code> on it.<br/><br/>
        Writable signals (<code>signal()</code>) can both be read and updated.
    </li>

    <br/><br/><br/>

    <li><b>Accessing signals from the template</b><br/><br/>
        In templates, signals behave like functions — you must call them:
<pre class="line-numbers"><code class="language-html">&lt;h2&gt;{{ count() }}&lt;/h2&gt;   &lt;!-- ✅ correct --&gt;
&lt;h2&gt;{{ count }}&lt;/h2&gt;     &lt;!-- ❌ won't update --&gt;
</code></pre>
        <br/>
        Angular automatically re-renders that part of the template when the signal changes.
    </li>

    <br/><br/><br/>

    <li><b>When to use signals?</b><br/><br/>
        <ul>
            <li>For local component state (form inputs, toggles, UI flags)</li>
            <br/>
            <li>For derived/computed data</li>
            <br/>
            <li>For lightweight reactivity without external stores</li>
            <br/>
            <li>Instead of RxJS <code>BehaviorSubject</code> for simple cases</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Linked Signals</h3>
<ol>
    <li><b>What is a linked signal?</b><br/><br/>
        A <code>linkedSignal()</code> is a special kind of signal that stays connected to another signal.<br/><br/>
        When the source signal changes, the linked one also updates automatically.<br/><br/>
        Think of it as a "live copy" or a "mirror" of another signal — but one that can also transform or filter the value.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, linkedSignal } from '@angular/core';

const name = signal('Hwangfu');

// Linked signal that always follows `name`
const upperName = linkedSignal(() =&gt; name().toUpperCase());

console.log(upperName()); // "HWANGFU"

name.set('Fucius');
console.log(upperName()); // "FUCIUS" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Why not just use <code>computed()</code>?</b><br/><br/>
        <code>computed()</code> and <code>linkedSignal()</code> look similar, but there's one key difference:<br/><br/>
        <ul>
            <li><code>computed()</code> → read-only, you can't change its value directly</li>
            <br/>
            <li><code>linkedSignal()</code> → can also be written to (you can modify it)</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const count = signal(0);

// Computed: only reads from count
const double = computed(() =&gt; count() * 2);

// Linked: can read and write
const mirror = linkedSignal(() =&gt; count(), {
    // define how writing back should work
    set: (newVal) =&gt; count.set(newVal),
});

mirror.set(5);
console.log(count()); // 5
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>When to use linked signals?</b><br/><br/>
        Linked signals are useful when two parts of your code need to share the same data, but maybe in a slightly different form.<br/><br/>
        For example, if you want to edit a copy of a user object without losing the original right away:
<pre class="line-numbers"><code class="language-ts">const activeUser = signal({ id: 1, name: 'Alice' });

// Create a linked version for editing
const editUser = linkedSignal(() =&gt; activeUser(), {
    // treat users with the same id as the same object
    equal: (a, b) =&gt; a.id === b.id,
});

console.log(editUser());  // { id: 1, name: 'Alice' }

editUser.update(u =&gt; ({ ...u, name: 'Alicia' }));
console.log(editUser().name);  // "Alicia"

// if `activeUser` changes, `editUser` also updates
activeUser.set({ id: 1, name: 'Alina' });
console.log(editUser().name);  // "Alina"
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Basic syntax patterns</b><br/><br/>
        You can define a linked signal in two common ways:
        <br/><br/>
        <b>1. Simple form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal(() =&gt; source());
</code></pre>
        <b>2. Detailed form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal({
    source: source,
    computation: (value) =&gt; value,
    equal: (a, b) =&gt; a.id === b.id,
});
</code></pre>
        <br/>
        The detailed form gives you more control: you can define how values are compared, or how they're computed.
    </li>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What does a CSS selector component do?</h3>
<ol>
    <li>When you write <code>@Component({ selector: 'button[type="reset"]' })</code>, Angular matches all elements in the DOM that fit this CSS selector.</li>
    <br/><br/>

    <li>If an element matches, Angular creates your component and attaches it to that element.</li>
    <br/><br/>

    <li>The element is NOT replaced. It stays the original tag. Angular just uses it as the host.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'button[type="reset"]',
    template: '<ng-content></ng-content>',
})
export class ResetButton {}
</code></pre>
    <br/>
    Any <code>&lt;button type="reset"&gt;</code> becomes a <code>ResetButton</code> component host.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Extend the example: make the reset button actually do things</h3>
<ol>
    <li>Below is a <code>ResetButton</code> component that:
        <ul>
            <br/>
            <li>adds classes (for styling)</li>
            <br/>
            <li>supports variants (<code>primary</code> / <code>ghost</code>)</li>
            <br/>
            <li>supports a <code>loading</code> state (shows a spinner, disables clicks)</li>
            <br/>
            <li>sets accessibility attributes (<code>aria-disabled</code>, <code>aria-busy</code>)</li>
            <br/>
            <li>keeps the original button text via <code>&lt;ng-content&gt;</code></li>
        </ul>
    </li>

    <br/><br/>

    <li>TypeScript (component):
<pre class="line-numbers"><code class="language-ts">import { Component, HostBinding, HostListener, Input } from '@angular/core';

@Component({
    selector: 'button[type="reset"]',
    // The host element IS the &lt;button&gt;. We only render inside it.
    template: `
        &lt;span class="content" [class.hidden]="loading"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/span&gt;
        &lt;span class="spinner" *ngIf="loading" aria-hidden="true"&gt;⏳&lt;/span&gt;
    `,
    styles: [`
        :host {
            /* base look */
            font: inherit;
            border-radius: 6px;
            padding: .5rem .9rem;
            cursor: pointer;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: .5rem;
            transition: background-color .15s ease, border-color .15s ease, color .15s ease;
        }

        /* variants via classes on :host */
        :host(.primary) {
            background: #0d6efd;
            color: white;
        }
        :host(.primary:hover) { background: #0b5ed7; }

        :host(.ghost) {
            background: transparent;
            color: #0d6efd;
            border-color: #0d6efd;
        }
        :host(.ghost:hover) { background: rgba(13,110,253,.08); }

        /* disabled look */
        :host(.disabled) {
            opacity: .55;
            cursor: not-allowed;
            pointer-events: none;
        }

        .spinner { display: inline-flex; }
        .content.hidden { visibility: hidden; } /* reserve space so width doesn't jump */
    `],
    standalone: true,
})
export class ResetButton {
    /** Visual variant */
    @Input() variant: 'primary' | 'ghost' = 'primary';

    /** Loading state: blocks clicks, shows spinner, updates aria */
    @Input() loading = false;

    /** Disable state (useful if you want to disable the reset button) */
    @Input() disabled = false;

    /** Reflect variant and states as CSS classes on the host &lt;button&gt; */
    @HostBinding('class')
    get hostClasses(): string {
        const v = this.variant ?? 'primary';
        return [v, this.disabled || this.loading ? 'disabled' : ''].filter(Boolean).join(' ');
    }

    /** Keep native semantics but add A11y hints */
    @HostBinding('attr.aria-disabled') get ariaDisabled() { return String(this.disabled); }
    @HostBinding('attr.aria-busy')     get ariaBusy()     { return String(this.loading); }

    /** Optional: ensure the host has type="reset" (safety if HTML missed it) */
    @HostBinding('attr.type') readonly type = 'reset';

    /** Block clicks when disabled/loading */
    @HostListener('click', ['$event'])
    onClick(ev: MouseEvent) {
        if (this.disabled || this.loading) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
        }
    }
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage examples:
<pre class="line-numbers"><code class="language-html">&lt;!-- Matches selector because it's a button[type="reset"] --&gt;
&lt;button type="reset" variant="primary"&gt;Reset form&lt;/button&gt;

&lt;!-- Switch variant --&gt;
&lt;button type="reset" variant="ghost"&gt;Clear&lt;/button&gt;

&lt;!-- Loading state --&gt;
&lt;button type="reset" variant="primary" [loading]="true"&gt;Resetting…&lt;/button&gt;

&lt;!-- Disabled state --&gt;
&lt;button type="reset" [disabled]="true"&gt;Disabled reset&lt;/button&gt;

&lt;!-- With projected rich content --&gt;
&lt;button type="reset" variant="primary"&gt;
    &lt;span class="hl-grey-fg"&gt;↺&lt;/span&gt;
    Reset filters
&lt;/button&gt;
</code></pre>
    </li>
    <br/><br/>

    <li>What changed compared to the minimal skeleton:
        <ul>
            <br/>
            <li><code>@Input()</code> values (<code>variant</code>, <code>loading</code>, <code>disabled</code>) so templates can control the button.</li>
            <br/>
            <li><code>@HostBinding</code> adds/removes CSS classes on the host <code>&lt;button&gt;</code>.</li>
            <br/>
            <li><code>@HostListener('click')</code> prevents clicks when disabled/loading.</li>
            <br/>
            <li><code>type="reset"</code> is enforced, so even if HTML forgot it, it behaves as a reset button.</li>
            <br/>
            <li>Simple styles are scoped to this component only.</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What does <code>selector: 'drop-zone, [dropzone]'</code> mean?</h3>
<ol>
    <li>This selector matches two things:
        <ul>
            <br/>
            <li><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;</code></li>
            <br/>
            <li>Any element with a <code>dropzone</code> attribute, like <code>&lt;div dropzone&gt;</code></li>
        </ul>
    </li>

    <br/>
    <br/>
    <br/>

    <li>Both become hosts for the <code>DropZone</code> component.</li>

    <br/>
    <br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '<ng-content></ng-content>',
})
export class DropZone {}
</code></pre>
    </li>

    <br/><br/>

    <li>The host element is NOT replaced, the component renders inside it.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to define a custom attribute (Angular Input)?</h3>
<ol>
    <li>You define a custom attribute using <code>@Input()</code>.</li>

    <br/><br/>

    <li>This does not create a real DOM attribute unless you bind it.</li>

    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone',
    template: '<ng-content></ng-content>',
})
export class DropZone {
    @Input() mode: 'files' | 'links' | 'images' = 'files';
}
</code></pre>

    Usage:
<pre><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;                (uses default: mode = "files")
&lt;drop-zone mode="links"&gt;&lt;/drop-zone&gt;   (sets mode = "links")
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to show the custom Input as a real HTML attribute?</h3>
<ol>
    <li>Use <code>@HostBinding('attr.&lt;attribute-name&gt;')</code>.</li>
    <br/><br/>

    <li>This makes the Input appear in the DOM inspector.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[dropzone]',
})
export class DropzoneDirective {
    @Input() dropzone: string = 'files';

    @HostBinding('attr.dropzone')
    get attrValue() {
        return this.dropzone;
    }
}
</code></pre>

    Resulting DOM:
<pre><code>&lt;div dropzone="files"&gt;&lt;/div&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Default boolean attribute with true/false behavior</h3>
<ol>
    <li>Use <code>booleanAttribute</code> transform.</li>
    <br/><br/>

    <li>This makes <code>appResizable</code> behave like a proper boolean.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[appResizable]',
})
export class ResizableDirective {
    @Input({ alias: 'appResizable', transform: booleanAttribute })
    resizable = true;

    @HostBinding('attr.data-resizable')
    get data() {
        return String(this.resizable);
    }
}
</code></pre>

    Usage:
<pre><code>&lt;div appResizable&gt;&lt;/div&gt;            (true by default)
&lt;div appResizable="true"&gt;&lt;/div&gt;     (true)
&lt;div [appResizable]="false"&gt;&lt;/div&gt;  (false)
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Setting a default DOM attribute directly</h3>
<ol>
    <li>If you just want an element to always have an attribute, bind it with HostBinding.</li>
    <br/><br/>

    <li>Example: default <code>type="reset"</code> for any button with a directive.
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: 'button[appResetDefault]',
})
export class ResetDefaultDirective {
    @HostBinding('attr.type') type = 'reset';
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage:
<pre><code>&lt;button appResetDefault&gt;Clear&lt;/button&gt;</code></pre>

    This becomes:
<pre><code>&lt;button type="reset"&gt;Clear&lt;/button&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Can multiple components be applied to one element?</h3>
<ol>
    <li>No — only one component can attach to a single element.</li>
    <br/><br/>

    <li>Directives can stack, but components cannot.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Component Selectors</h3>
<ol>
    <li><b>What is a component selector?</b></li>
    <br/>
    <ul>
        <li>The <code>selector</code> tells Angular where to place a component in the DOM.</li>
        <br/>
        <li>It lives in the <code>@Component({ ... })</code> metadata:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User card works&lt;/p&gt;`,
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Every time Angular sees <code>&lt;app-user-card&gt;</code> in a template, it creates a <code>UserCard</code> component there.</li>
        <br/>
        <li>The element itself becomes the host of the component. It is not replaced.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Element selectors</b></li>
    <br/>
    <ul>
        <li>This is the most common style.</li>
        <br/>
        <li>The selector looks like a custom HTML tag name:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-profile',
    template: `&lt;h2&gt;Profile&lt;/h2&gt;`,
})
export class ProfileComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Usage in another template --&gt;
&lt;app-profile&gt;&lt;/app-profile&gt;
</code></pre>
    <br/>
    <ul>
        <li>Use <b>kebab-case</b> (lowercase with dashes): <code>app-profile</code>, <code>user-card</code>, etc.</li>
        <br/>
        <li>Start with a prefix like <code>app-</code> (you can customize your own) to avoid conflicts with future HTML tags.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Attribute selectors</b></li>
    <br/>
    <ul>
        <li>An attribute selector matches normal HTML elements that have a certain attribute.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: '[appPanel]',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class PanelComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;section appPanel&gt;
    Panel content
&lt;/section&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the host is the existing <code>&lt;section&gt;</code> element.</li>
        <br/>
        <li>Use attribute selectors when you want to "enhance" an existing element, not introduce a new tag.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Multiple selectors</b></li>
    <br/>
    <ul>
        <li>You can combine selectors with commas.</li>
        <br/>
        <li>Example (similar to your drop zone example):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '&lt;ng-content&gt;&lt;/ng-content&gt;',
})
export class DropZoneComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Both usages match the same component --&gt;
&lt;drop-zone&gt;Drop files here&lt;/drop-zone&gt;

&lt;div dropzone&gt;Drop files here&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Both an element <code>&lt;drop-zone&gt;</code> and any element with the <code>dropzone</code> attribute become hosts for the same component.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CSS selectors</b></li>
    <br/>
    <ul>
        <li>The <code>selector</code> field accepts valid CSS selectors.</li>
        <br/>
        <li>For example, matching all reset buttons:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'button[type="reset"]',
    template: '&lt;ng-content&gt;&lt;/ng-content&gt;',
})
export class ResetButtonComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;button type="reset"&gt;Reset form&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li>Every <code>&lt;button type="reset"&gt;</code> now becomes a <code>ResetButtonComponent</code> host.</li>
        <br/>
        <li>Be careful with very broad selectors like <code>div</code> or <code>button</code>, they can match too many elements and make templates confusing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>One component per element</b></li>
    <br/>
    <ul>
        <li>Only one component can attach to a single element.</li>
        <br/>
        <li>Directives (like attribute directives) can stack, but components cannot.</li>
        <br/>
        <li>If two component selectors both match the same element, Angular will throw an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Naming and best practices</b></li>
    <br/>
    <ul>
        <li>Use a clear prefix (e.g. <code>app-</code>, <code>admin-</code>, <code>shared-</code>).</li>
        <br/>
        <li>Element selectors for main UI blocks:
<pre><code class="language-text">
app-header, app-footer, app-user-card
</code></pre>
        </li>
        <br/>
        <li>Attribute selectors for behavior-like components or directive-style helpers:
<pre><code class="language-text">
[appPanel], [appResetDefault], [dropzone]
</code></pre>
        </li>
        <br/>
        <li>Keep selectors specific enough so it is obvious where a component is used.</li>
        <br/>
        <li>Do not reuse the same selector name for different components.</li>
    </ul>
    <br/>
    <br/>


    <li><b>How Angular uses the selector</b></li>
    <br/>
    <ul>
        <li>During compilation, Angular scans your templates.</li>
        <br/>
        <li>When it finds something that matches a component's selector, it:
            <ul>
                <li>Creates an instance of that component,</li>
                <li>Attaches it to the matching DOM element (host),</li>
                <li>Renders the component's template inside that host.</li>
            </ul>
        </li>
        <br/>
        <li>The host element is kept. Angular only controls what is rendered inside it and its attributes / classes.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics on Styling Components</h3>
<ol>
    <li><b>Where do component styles live?</b></li>
    <br/>
    <ul>
        <li>You can write styles directly in the component, or in a separate file.</li>
        <br/>
        <li>Inline styles (small components):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;div class="card"&gt;User card&lt;/div&gt;`,
    styles: [`
        .card {
            padding: 1rem;
            border-radius: .5rem;
            border: 1px solid #ddd;
        }
    `],
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Separate CSS/SCSS file (bigger components):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    templateUrl: './user-card.component.html',
    styleUrls: ['./user-card.component.css'],
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Use inline <code>styles</code> for quick examples or tiny components.</li>
        <br/>
        <li>Use <code>styleUrls</code> with a <code>.css</code> or <code>.scss</code> file for anything non-trivial.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Component styles are local</b></li>
    <br/>
    <ul>
        <li>By default, styles in a component only apply to that component's template.</li>
        <br/>
        <li>This means:
            <ul>
                <li>They do not "leak" into other components.</li>
                <li>You can reuse simple class names like <code>.title</code> in many components without conflicts.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-a',
    template: `&lt;h2 class="title"&gt;A&lt;/h2&gt;`,
    styles: [`.title { color: red; }`],
})
export class AComponent {}

@Component({
    selector: 'app-b',
    template: `&lt;h2 class="title"&gt;B&lt;/h2&gt;`,
    styles: [`.title { color: blue; }`],
})
export class BComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-a&gt;&lt;/app-a&gt;
&lt;app-b&gt;&lt;/app-b&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>A</code> is red and <code>B</code> is blue, even though both use the same class name.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Styling the host element with <code>:host</code></b></li>
    <br/>
    <ul>
        <li>The <code>:host</code> selector targets the <u>outer element</u> that holds your component.</li>
        <br/>
        <li>Example (similar to your reset button):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-pill-badge',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: inline-block;
            padding: .2rem .6rem;
            border-radius: 999px;
            background: #f0f4ff;
            color: #1f3b8f;
            font-size: .8rem;
        }
    `],
    standalone: true,
})
export class PillBadge {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-pill-badge&gt;New&lt;/app-pill-badge&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>:host</code> styles the <code>&lt;app-pill-badge&gt;</code> element itself.</li>
        <br/>
        <li>Use <code>:host</code> for width, padding, display, border, etc. of the component's root element.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Styling based on host classes: <code>:host(.some-class)</code></b></li>
    <br/>
    <ul>
        <li>You can change styles depending on classes applied to the host element.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: .75rem 1rem;
            border-radius: 4px;
        }

        :host(.info) {
            background: #e7f1ff;
            color: #0b4f9c;
        }

        :host(.error) {
            background: #ffe5e5;
            color: #a30000;
        }
    `],
    standalone: true,
})
export class AlertComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-alert class="info"&gt;Information&lt;/app-alert&gt;
&lt;app-alert class="error"&gt;Something went wrong&lt;/app-alert&gt;
</code></pre>
    <br/>
    <ul>
        <li>The same component can look different based on classes you add.</li>
        <br/>
        <li>This pattern is nice for variants like <code>primary</code>, <code>ghost</code>, <code>warning</code>, etc.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding classes and styles from TypeScript</b></li>
    <br/>
    <ul>
        <li>You can toggle CSS classes using property bindings.</li>
        <br/>
        <li>Simple class binding:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button
    class="btn"
    [class.btn-primary]="primary"
    [class.btn-disabled]="disabled"
&gt;
    Save
&lt;/button&gt;
</code></pre>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-save-button',
    templateUrl: './save-button.component.html',
})
export class SaveButtonComponent {
    primary = true;
    disabled = false;
}
</code></pre>
    <br/>
    <ul>
        <li>Style binding works similarly:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div [style.opacity]="disabled ? 0.5 : 1"&gt;Content&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Use these bindings when styles depend on component state (loading, error, active, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Component styles vs global styles</b></li>
    <br/>
    <ul>
        <li>Global styles live in files like <code>styles.css</code> at the root of your app.</li>
        <br/>
        <li>Use global styles for:
            <ul>
                <li>Page background, base font, body margin, etc.</li>
                <li>Theme variables (colors, spacing, typography).</li>
                <li>Reset/normalize styles.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-css line-numbers">/* styles.css */
html, body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #fafafa;
}
</code></pre>
    <br/>
    <ul>
        <li>Use component styles for:
            <ul>
                <li>Buttons, cards, forms, and layout that belong to one component.</li>
                <li>Anything that should not affect the whole app.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Light introduction to <code>:host-context()</code></b></li>
    <br/>
    <ul>
        <li><code>:host-context()</code> lets you style a component differently depending on something outside of it.</li>
        <br/>
        <li>Example: dark mode class on a parent element:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-box',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: 1rem;
            background: white;
            color: black;
        }

        :host-context(.dark-mode) {
            background: #1f2933;
            color: #f9fafb;
        }
    `],
})
export class BoxComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;div class="dark-mode"&gt;
    &lt;app-box&gt;This box appears in dark mode&lt;/app-box&gt;
&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>This is helpful if you have a global "theme" class but still want components to react to it.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics on Input properties</h3>
<ol>
    <li><b>What are input properties?</b></li>
    <br/>
    <ul>
        <li><code>@Input()</code> lets a parent component send data down to a child component.</li>
        <br/>
        <li>It works just like passing arguments into a function, but through HTML attributes.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-greeting',
    template: `&lt;h3&gt;Hello, {{ name }}!&lt;/h3&gt;`,
})
export class GreetingComponent {
    @Input() name = 'Guest';   // receives value from parent
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent template --&gt;
&lt;app-greeting name="Alice"&gt;&lt;/app-greeting&gt;
&lt;app-greeting name="Bob"&gt;&lt;/app-greeting&gt;
</code></pre>
    <br/>
    <ul>
        <li>The parent sets <code>name</code> just like a normal HTML attribute.</li>
        <br/>
        <li>Angular automatically passes that value into the child component's <code>@Input()</code> field.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding expressions to inputs</b></li>
    <br/>
    <ul>
        <li>You can also bind dynamic data using square brackets <code>[]</code>.</li>
        <br/>
        <li>This lets you send variables, not just strings.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-parent',
    template: `
        &lt;app-greeting [name]="userName"&gt;&lt;/app-greeting&gt;
    `,
})
export class ParentComponent {
    userName = 'Hwangfucius';
}
</code></pre>
    <br/>
    <br/>


    <li><b>Setting default values</b></li>
    <br/>
    <ul>
        <li>If the parent does not pass a value, the default value in the child is used.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User: {{ name }} ({{ role }})&lt;/p&gt;`,
})
export class UserCardComponent {
    @Input() name = 'Anonymous';
    @Input() role = 'Viewer';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-user-card&gt;&lt;/app-user-card&gt;
&lt;app-user-card name="Alice" role="Admin"&gt;&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>The first card uses defaults. The second one overrides both values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Renaming an input</b></li>
    <br/>
    <ul>
        <li>Sometimes, you want to expose a different name in HTML than in your class.</li>
        <br/>
        <li>You can do this by giving <code>@Input()</code> a string argument:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-book',
    template: `&lt;p&gt;Title: {{ title }}&lt;/p&gt;`,
})
export class BookComponent {
    @Input('bookTitle') title = '';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-book bookTitle="The Hobbit"&gt;&lt;/app-book&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the HTML uses <code>bookTitle</code>, but inside the component, the field name is <code>title</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Input type conversion (transforms)</b></li>
    <br/>
    <ul>
        <li>Starting from Angular 16+, you can add simple type transformations directly in the <code>@Input()</code> decorator.</li>
        <br/>
        <li>Example — converting attribute values into booleans:</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, Input, booleanAttribute } from '@angular/core';

@Component({
    selector: 'app-toggle',
    template: `&lt;button&gt;Enabled: {{ enabled }}&lt;/button&gt;`,
})
export class ToggleComponent {
    @Input({ transform: booleanAttribute }) enabled = false;
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-toggle enabled&gt;&lt;/app-toggle&gt;
&lt;app-toggle enabled="false"&gt;&lt;/app-toggle&gt;
&lt;app-toggle&gt;&lt;/app-toggle&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>booleanAttribute</code> helper makes <code>enabled</code> behave like a real HTML boolean attribute.</li>
        <br/>
        <li>The first one is <code>true</code>, the others are <code>false</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Signal-style inputs (Angular 17+)</b></li>
    <br/>
    <ul>
        <li>You can also define inputs as reactive signals using <code>input()</code>.</li>
        <br/>
        <li>This makes them automatically re-render when updated, no need for change detection tricks.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, input } from '@angular/core';

@Component({
    selector: 'app-profile',
    template: `&lt;p&gt;Welcome, {{ name() }}!&lt;/p&gt;`,
})
export class ProfileComponent {
    name = input('Guest');
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-profile name="Hwangfucius"&gt;&lt;/app-profile&gt;
</code></pre>
    <br/>
    <ul>
        <li>It behaves like <code>@Input()</code>, but integrates perfectly with the Angular signals system.</li>
        <br/>
        <li>In templates, signal inputs must be called like functions (<code>{{ name() }}</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Validating and reacting to input changes</b></li>
    <br/>
    <ul>
        <li>Sometimes, you want to run logic whenever an input changes.</li>
        <br/>
        <li>Two simple ways:</li>
    </ul>
<pre><code class="language-ts line-numbers">// 1. Use a setter
@Input()
set count(value: number) {
    console.log('Count changed to', value);
}

// 2. Use ngOnChanges (classic lifecycle hook)
ngOnChanges(changes: SimpleChanges) {
    console.log(changes);
}
</code></pre>
    <br/>
    <ul>
        <li>Setters are simpler for one property, <code>ngOnChanges</code> works if you have many inputs.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics on Output properties</h3>
<ol>
    <li><b>What are output properties?</b></li>
    <br/>
    <ul>
        <li><code>@Output()</code> lets a child component send data back to its parent.</li>
        <br/>
        <li>They are used for <u>custom events</u> — things that happen inside the child component that the parent wants to know about.</li>
        <br/>
        <li>For example: a button click, a form submission, or a value change.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, Output, EventEmitter } from '@angular/core';

@Component({
    selector: 'app-like-button',
    template: `&lt;button (click)="like()"&gt;Like&lt;/button&gt;`,
})
export class LikeButtonComponent {
    @Output() liked = new EventEmitter&lt;void&gt;();

    like() {
        console.log('Button clicked!');
        this.liked.emit();
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-like-button (liked)="onLiked()"&gt;&lt;/app-like-button&gt;
</code></pre>
    <br/>
    <ul>
        <li>The child emits an event, and the parent listens with parentheses <code>(liked)</code>.</li>
        <br/>
        <li>This is the exact reverse of how <code>@Input()</code> works.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Sending data with the event</b></li>
    <br/>
    <ul>
        <li>You can include data when you emit an event, not just a signal that something happened.</li>
        <br/>
        <li>Example: passing the current like count.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-like-counter',
    template: `&lt;button (click)="addLike()"&gt;{{ count }}&lt;/button&gt;`,
})
export class LikeCounterComponent {
    count = 0;
    @Output() countChange = new EventEmitter&lt;number&gt;();

    addLike() {
        this.count++;
        this.countChange.emit(this.count);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-like-counter (countChange)="onCountUpdated($event)"&gt;&lt;/app-like-counter&gt;
</code></pre>
<pre><code class="language-ts line-numbers">// Parent component
onCountUpdated(newCount: number) {
    console.log('New like count:', newCount);
}
</code></pre>
    <br/>
    <ul>
        <li>The special variable <code>$event</code> contains whatever data was emitted.</li>
        <br/>
        <li>Here, it's the number sent from <code>this.countChange.emit(this.count)</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Renaming an output event</b></li>
    <br/>
    <ul>
        <li>You can rename the event name seen in HTML by passing a string to <code>@Output()</code>.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-toggle',
    template: `
        &lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt;
    `,
})
export class ToggleComponent {
    private on = false;

    @Output('toggled') stateChanged = new EventEmitter&lt;boolean&gt;();

    toggle() {
        this.on = !this.on;
        this.stateChanged.emit(this.on);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent uses the alias name --&gt;
&lt;app-toggle (toggled)="onToggled($event)"&gt;&lt;/app-toggle&gt;
</code></pre>
    <br/>
    <ul>
        <li>In TypeScript it's called <code>stateChanged</code>, but in the template it appears as <code>(toggled)</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining inputs and outputs</b></li>
    <br/>
    <ul>
        <li>It is very common to have both — one for incoming data, one for outgoing events.</li>
        <br/>
        <li>Example: a simple custom checkbox component.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-checkbox',
    template: `
        &lt;label&gt;
            &lt;input type="checkbox" [checked]="checked" (change)="onChange($event)" /&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/label&gt;
    `,
})
export class CheckboxComponent {
    @Input()  checked = false;
    @Output() checkedChange = new EventEmitter&lt;boolean&gt;();

    onChange(event: Event) {
        const input = event.target as HTMLInputElement;
        this.checkedChange.emit(input.checked);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-checkbox [(checked)]="subscribed"&gt;Subscribe&lt;/app-checkbox&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>[(checked)]</code> syntax is shorthand for combining <code>[checked]</code> and <code>(checkedChange)</code>.</li>
        <br/>
        <li>This two-way binding works automatically because the names follow the pattern <code>value</code> / <code>valueChange</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Signal-style outputs (Angular 17+)</b></li>
    <br/>
    <ul>
        <li>With the new signal system, you can define outputs using <code>output()</code> instead of <code>@Output()</code>.</li>
        <br/>
        <li>This keeps your code consistent with signal-style inputs.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, output } from '@angular/core';

@Component({
    selector: 'app-delete-button',
    template: `&lt;button (click)="onDelete()"&gt;Delete&lt;/button&gt;`,
})
export class DeleteButtonComponent {
    deleted = output&lt;string&gt;();

    onDelete() {
        this.deleted.emit('item-42');
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-delete-button (deleted)="handleDelete($event)"&gt;&lt;/app-delete-button&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>output()</code> works almost the same as <code>@Output()</code>, but is simpler to read alongside <code>input()</code>.</li>
        <br/>
        <li>Use it when writing modern Angular components that already use signals.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Content projection with <code>&lt;ng-content&gt;</code></h3>
<ol>
    <li><b>What is content projection?</b></li>
    <br/>
    <ul>
        <li>Content projection means letting the parent component <b>insert</b> its own HTML into the child component's template.</li>
        <br/>
        <li>Think of it like a "placeholder" where outside content will appear.</li>
        <br/>
        <li>Angular uses the special tag <code>&lt;ng-content&gt;</code> for this purpose.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-card',
    template: `
        &lt;div class="card"&gt;
            &lt;h3&gt;Header&lt;/h3&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;   &lt;!-- projected content here --&gt;
        &lt;/div&gt;
    `,
    styles: [`
        .card {
            border: 1px solid #ddd;
            border-radius: .5rem;
            padding: 1rem;
            margin: .5rem 0;
        }
    `],
})
export class CardComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-card&gt;
    &lt;p&gt;This paragraph comes from the parent.&lt;/p&gt;
&lt;/app-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>The paragraph inside <code>&lt;app-card&gt;</code> replaces <code>&lt;ng-content&gt;</code> in the child template.</li>
        <br/>
        <li>This lets you make reusable "container" components that still display custom content.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Projecting multiple content sections</b></li>
    <br/>
    <ul>
        <li>You can have more than one <code>&lt;ng-content&gt;</code> in a component, each with a CSS selector.</li>
        <br/>
        <li>This is called <b>selective content projection</b>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-dialog',
    template: `
        &lt;div class="dialog"&gt;
            &lt;header&gt;
                &lt;ng-content select="[dialog-title]"&gt;&lt;/ng-content&gt;
            &lt;/header&gt;

            &lt;section&gt;
                &lt;ng-content&gt;&lt;/ng-content&gt;   &lt;!-- default slot --&gt;
            &lt;/section&gt;

            &lt;footer&gt;
                &lt;ng-content select="[dialog-actions]"&gt;&lt;/ng-content&gt;
            &lt;/footer&gt;
        &lt;/div&gt;
    `,
})
export class DialogComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-dialog&gt;
    &lt;h2 dialog-title&gt;Delete file?&lt;/h2&gt;

    &lt;p&gt;This action cannot be undone.&lt;/p&gt;

    &lt;div dialog-actions&gt;
        &lt;button&gt;Cancel&lt;/button&gt;
        &lt;button&gt;Confirm&lt;/button&gt;
    &lt;/div&gt;
&lt;/app-dialog&gt;
</code></pre>
    <br/>
    <ul>
        <li>Each <code>&lt;ng-content&gt;</code> selects the elements that match its selector.</li>
        <br/>
        <li>Anything not matching any selector goes into the "default" <code>&lt;ng-content&gt;</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>ngProjectAs</code> for flexibility</b></li>
    <br/>
    <ul>
        <li>Sometimes, an element's tag can't be changed to match the selector — for example, it's a shared component or library element.</li>
        <br/>
        <li>You can use the attribute <code>ngProjectAs</code> to "pretend" it matches a selector.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;app-dialog&gt;
    &lt;app-title ngProjectAs="[dialog-title]"&gt;Edit profile&lt;/app-title&gt;

    &lt;p&gt;Form fields go here...&lt;/p&gt;

    &lt;app-footer ngProjectAs="[dialog-actions]"&gt;
        &lt;button&gt;Close&lt;/button&gt;
    &lt;/app-footer&gt;
&lt;/app-dialog&gt;
</code></pre>
    <br/>
    <ul>
        <li>Even though the elements are <code>&lt;app-title&gt;</code> and <code>&lt;app-footer&gt;</code>, Angular projects them into the right slots.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Projecting multiple components</b></li>
    <br/>
    <ul>
        <li>You can project any combination of text, HTML, or components.</li>
        <br/>
        <li>This makes powerful layouts easy to build.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;app-card&gt;
    &lt;app-user-info [user]="user"&gt;&lt;/app-user-info&gt;
    &lt;app-user-stats [user]="user"&gt;&lt;/app-user-stats&gt;
&lt;/app-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>Both <code>&lt;app-user-info&gt;</code> and <code>&lt;app-user-stats&gt;</code> are rendered inside the card's <code>&lt;ng-content&gt;</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Component Host Elements</h3>
<ol>
    <li><b>What is a host element?</b></li>
    <br/>
    <ul>
        <li>Every Angular component is attached to a real DOM element, this is called its <u>host element</u>.</li>
        <br/>
        <li>The host element is the HTML tag where Angular creates your component instance.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User: {{ name }}&lt;/p&gt;`,
})
export class UserCardComponent {
    name = 'Hwangfucius';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent template --&gt;
&lt;app-user-card&gt;&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the <code>&lt;app-user-card&gt;</code> tag is the <u>host element</u> for the <code>UserCardComponent</code>.</li>
        <br/>
        <li>Angular attaches your component's rendered template (<code>&lt;p&gt;User: ...&lt;/p&gt;</code>) inside this element.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Host element vs child elements</b></li>
    <br/>
    <ul>
        <li>The host element is the outer shell of your component.</li>
        <br/>
        <li>Everything you write inside the component's template becomes its <u>child elements</u>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;!-- In the browser --&gt;
&lt;app-user-card&gt;                     &lt;!-- 👈 host element --&gt;
    &lt;p&gt;User: Hwangfucius&lt;/p&gt;        &lt;!-- 👈 child content --&gt;
&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <br/>


    <li><b>Styling the host element</b></li>
    <br/>
    <ul>
        <li>You can style your host element directly from inside the component using the <code>:host</code> selector.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: 1rem;
            border-radius: .5rem;
            background: #f9f9f9;
        }

        :host(.warning) {
            background: #fff3cd;
            color: #856404;
        }

        :host(.error) {
            background: #f8d7da;
            color: #842029;
        }
    `],
})
export class AlertComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-alert class="warning"&gt;Low battery&lt;/app-alert&gt;
&lt;app-alert class="error"&gt;System failure&lt;/app-alert&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>:host</code> selector targets the component's own tag — its host element.</li>
        <br/>
        <li>Each <code>app-alert</code> element gets styled according to its class.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding attributes and classes to the host element</b></li>
    <br/>
    <ul>
        <li>Inside your component class, you can bind properties and attributes directly to the host element using <code>@HostBinding()</code>.</li>
        <br/>
        <li>This allows your code to dynamically update how the host element looks or behaves.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostBinding, Input } from '@angular/core';

@Component({
    selector: 'app-status-indicator',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class StatusIndicatorComponent {
    @Input() status: 'online' | 'offline' = 'offline';

    @HostBinding('class')
    get hostClass(): string {
        return this.status;
    }

    @HostBinding('attr.role') role = 'status';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-status-indicator status="online"&gt;Connected&lt;/app-status-indicator&gt;
&lt;app-status-indicator status="offline"&gt;Disconnected&lt;/app-status-indicator&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>@HostBinding('class')</code> dynamically sets classes on the host element.</li>
        <li><code>@HostBinding('attr.role')</code> adds an accessibility attribute directly to the host.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Listening to events on the host</b></li>
    <br/>
    <ul>
        <li>You can also listen for host element events (like <code>click</code>) using <code>@HostListener()</code>.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostListener } from '@angular/core';

@Component({
    selector: 'app-clickable',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class ClickableComponent {
    @HostListener('click', ['$event'])
    handleClick(event: MouseEvent) {
        console.log('Host element clicked!', event);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-clickable&gt;Click me!&lt;/app-clickable&gt;
</code></pre>
    <br/>
    <ul>
        <li>Clicking anywhere on the component's host element triggers the listener inside the class.</li>
        <br/>
        <li>This is often used for buttons, custom inputs, or clickable cards.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing the host element in code</b></li>
    <br/>
    <ul>
        <li>Sometimes you may need to interact with the real DOM element that hosts your component.</li>
        <br/>
        <li>You can inject an <code>ElementRef</code> to access it directly.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class BoxComponent {
    constructor(private host: ElementRef&lt;HTMLElement&gt;) {}

    ngAfterViewInit() {
        this.host.nativeElement.style.border = '2px solid blue';
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-box&gt;Styled from code&lt;/app-box&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>ElementRef</code> gives you direct access to the DOM node — useful for low-level manipulations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Difference between host and parent elements</b></li>
    <br/>
    <ul>
        <li>The host element belongs to the parent template, but it's controlled by the component.</li>
        <br/>
        <li>The parent element is the one that wraps the component in the DOM, not the same thing as the host.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div class="wrapper"&gt;         &lt;!-- parent element --&gt;
    &lt;app-card&gt;&lt;/app-card&gt;     &lt;!-- host element --&gt;
&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Inside <code>app-card</code>, <code>:host</code> styles apply to <code>&lt;app-card&gt;</code> — not to the outer <code>&lt;div class="wrapper"&gt;</code>.</li>
        <br/>
        <li>If you want to react to a parent's class (e.g. a theme), use <code>:host-context(.dark-mode)</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Component Lifecycle</h3>
<ol>
    <li><b>What is a component lifecycle?</b></li>
    <br/>
    <ul>
        <li>Every Angular component goes through a <b>series of steps</b> from creation to destruction.</li>
        <br/>
        <li>Angular lets you run your own code at specific moments, like when the component is created, updated, or removed.</li>
        <br/>
        <li>These moments are called <u>lifecycle hooks</u>.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
    selector: 'app-timer',
    template: `&lt;p&gt;Seconds: {{ seconds }}&lt;/p&gt;`,
})
export class TimerComponent implements OnInit, OnDestroy {
    seconds = 0;
    private intervalId: any;

    ngOnInit() {
        console.log('Timer created');
        this.intervalId = setInterval(() =&gt; this.seconds++, 1000);
    }

    ngOnDestroy() {
        console.log('Timer destroyed');
        clearInterval(this.intervalId);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- When <app-timer> is created, ngOnInit runs. When it's removed, ngOnDestroy runs. --&gt;
&lt;app-timer *ngIf="showTimer"&gt;&lt;/app-timer&gt;
&lt;button (click)="showTimer = !showTimer"&gt;Toggle Timer&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>ngOnInit()</code> runs once when the component is first displayed.</li>
        <br/>
        <li><code>ngOnDestroy()</code> runs right before the component is removed from the DOM.</li>
        <br/>
        <li>Perfect for starting or cleaning up resources like timers, event listeners, or subscriptions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The full lifecycle order</b></li>
    <br/>
    <ul>
        <li>Angular calls hooks in this order when a component is created, updated, and destroyed:</li>
    </ul>
<pre><code class="language-text">1. ngOnChanges()
2. ngOnInit()
3. ngDoCheck()
4. ngAfterContentInit()
5. ngAfterContentChecked()
6. ngAfterViewInit()
7. ngAfterViewChecked()
8. ngOnDestroy()
</code></pre>
    <br/>
    <ul>
        <li>You don't have to implement all of them (just the ones you need).</li>
        <br/>
        <li>Each one has a clear purpose in the component's lifecycle.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngOnChanges()</b></li>
    <br/>
    <ul>
        <li>Runs whenever an <code>@Input()</code> property changes.</li>
        <br/>
        <li>It also runs once right before <code>ngOnInit()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-counter',
    template: `&lt;p&gt;Count: {{ count }}&lt;/p&gt;`,
})
export class CounterComponent implements OnChanges {
    @Input() count = 0;

    ngOnChanges(changes: SimpleChanges) {
        console.log('Changes:', changes);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-counter [count]="num"&gt;&lt;/app-counter&gt;
&lt;button (click)="num++"&gt;Increment&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>SimpleChanges</code> tells you what changed, its previous value, and new value.</li>
        <br/>
        <li>Useful when reacting to updated inputs from a parent component.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngOnInit()</b></li>
    <br/>
    <ul>
        <li>Called once, after Angular initializes all <code>@Input()</code> values.</li>
        <br/>
        <li>Use it to set up data, start fetching from APIs, or initialize variables.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngOnInit() {
    console.log('Component ready to use!');
    this.loadData();
}
</code></pre>
    <br/>
    <ul>
        <li>Think of it as your component's "startup" moment.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngDoCheck()</b></li>
    <br/>
    <ul>
        <li>Called during every change detection cycle.</li>
        <br/>
        <li>Most apps don't need it, because Angular's normal data binding handles most updates automatically.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngDoCheck() {
    console.log('Change detection running...');
}
</code></pre>
    <br/>
    <br/>


    <li><b>ngAfterContentInit() and ngAfterContentChecked()</b></li>
    <br/>
    <ul>
        <li>These run when projected content (via <code>&lt;ng-content&gt;</code>) is first inserted, and after every subsequent check.</li>
        <br/>
        <li>Use them when your component needs to interact with projected child content.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngAfterContentInit() {
    console.log('Projected content has been initialized.');
}

ngAfterContentChecked() {
    console.log('Projected content checked again.');
}
</code></pre>
    <br/>
    <ul>
        <li>"Content" means anything that was passed between your component tags in the parent template.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngAfterViewInit() and ngAfterViewChecked()</b></li>
    <br/>
    <ul>
        <li>These run when the component's own view (its template) is initialized and rechecked.</li>
        <br/>
        <li>Good for code that needs to access the rendered DOM using <code>@ViewChild()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@ViewChild('box') box!: ElementRef;

ngAfterViewInit() {
    console.log('Template view ready:', this.box.nativeElement);
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;div #box&gt;Hello box&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Don't try to access DOM elements in <code>ngOnInit()</code> — they're not ready yet. Use <code>ngAfterViewInit()</code> instead.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngOnDestroy()</b></li>
    <br/>
    <ul>
        <li>Called right before Angular removes the component from the DOM.</li>
        <br/>
        <li>Use it to clean up resources (unsubscribe from Observables, clear timers, detach listeners, etc.).</li>
    </ul>
<pre><code class="language-ts line-numbers">ngOnDestroy() {
    console.log('Cleaning up...');
    this.subscription.unsubscribe();
}
</code></pre>
    <br/>
    <ul>
        <li>Forgetting cleanup can cause memory leaks, so <code>ngOnDestroy()</code> is important.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Visual summary</b></li>
<pre><code class="language-text">
 ┌──────────────────────────────────────┐
 │ Component Created                    │
 │  ├─ ngOnChanges()                    │
 │  ├─ ngOnInit()                       │
 │  ├─ ngDoCheck()                      │
 │  ├─ ngAfterContentInit()             │
 │  ├─ ngAfterContentChecked()          │
 │  ├─ ngAfterViewInit()                │
 │  └─ ngAfterViewChecked()             │
 │                                      │
 │ Component Updated                    │
 │  ├─ ngDoCheck()                      │
 │  ├─ ngAfterContentChecked()          │
 │  └─ ngAfterViewChecked()             │
 │                                      │
 │ Component Destroyed                  │
 │  └─ ngOnDestroy()                    │
 └──────────────────────────────────────┘
</code></pre>
    <br/>
    <ul>
        <li>Angular calls these in the same predictable order every time.</li>
        <br/>
        <li>Use them to control setup, updates, and cleanup in your component's life.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Referencing component children with queries</h3>
<ol>
    <li><b>What are queries?</b></li>
    <br/>
    <ul>
        <li>Sometimes, you need direct access to elements or components inside your template — for example, to read a property, call a method, or focus an input.</li>
        <br/>
        <li>Angular provides <u>queries</u> for this purpose —
            A query "asks" Angular for a reference to a matching element or component in your view.</li>
        <br/>
        <li>The most common query decorators are:</li>
        <ul>
            <li><code>@ViewChild()</code> — finds one element or component inside the component's own template.</li>
            <li><code>@ViewChildren()</code> — finds multiple matching elements or components in the view.</li>
            <li><code>@ContentChild()</code> and <code>@ContentChildren()</code> — find projected content (passed in via <code>&lt;ng-content&gt;</code>).</li>
        </ul>
    </ul>
    <br/>
    <br/>


    <li><b>@ViewChild() — getting a single child element</b></li>
    <br/>
    <ul>
        <li>Use <code>@ViewChild()</code> to get a reference to one element or component inside your template.</li>
        <br/>
        <li>Example: focusing an input after the component appears.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
    selector: 'app-focus-input',
    template: `&lt;input #userInput type="text" placeholder="Type something..." /&gt;`,
})
export class FocusInputComponent implements AfterViewInit {
    @ViewChild('userInput') inputElement!: ElementRef&lt;HTMLInputElement&gt;;

    ngAfterViewInit() {
        this.inputElement.nativeElement.focus();  // focus when ready
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>#userInput</code> in the template defines a <u>template reference variable</u>.</li>
        <li><code>@ViewChild('userInput')</code> finds that element after the view is created.</li>
        <li>Always access it in <code>ngAfterViewInit()</code>, not <code>ngOnInit()</code>, because the view isn't ready before that.</li>
    </ul>
    <br/>
    <br/>


    <li><b>@ViewChild() — getting a child component instance</b></li>
    <br/>
    <ul>
        <li>You can also use <code>@ViewChild()</code> to access another component that is part of your template.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-child',
    template: `&lt;p&gt;Child works!&lt;/p&gt;`,
})
export class ChildComponent {
    sayHello() {
        console.log('Hello from Child!');
    }
}

@Component({
    selector: 'app-parent',
    template: `
        &lt;app-child&gt;&lt;/app-child&gt;
        &lt;button (click)="callChild()"&gt;Call Child&lt;/button&gt;
    `,
})
export class ParentComponent {
    @ViewChild(ChildComponent) child!: ChildComponent;

    callChild() {
        this.child.sayHello();
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>@ViewChild(ChildComponent)</code> looks for the first <code>&lt;app-child&gt;</code> element in the view.</li>
        <li>You can then access its public properties and methods directly.</li>
        <li>Angular keeps this reference updated automatically whenever the view changes.</li>
    </ul>
    <br/>
    <br/>


    <li><b>@ViewChildren() — getting multiple elements or components</b></li>
    <br/>
    <ul>
        <li>Use <code>@ViewChildren()</code> when you need to handle several matching items — for example, a list of child components.</li>
        <br/>
        <li>Angular returns a <code>QueryList</code> that you can loop over.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-item',
    template: `&lt;li&gt;Item&lt;/li&gt;`,
})
export class ItemComponent {}

@Component({
    selector: 'app-list',
    template: `
        &lt;ul&gt;
            &lt;app-item *ngFor="let i of [1,2,3]"&gt;&lt;/app-item&gt;
        &lt;/ul&gt;
        &lt;button (click)="logItems()"&gt;Log items&lt;/button&gt;
    `,
})
export class ListComponent implements AfterViewInit {
    @ViewChildren(ItemComponent) items!: QueryList&lt;ItemComponent&gt;;

    ngAfterViewInit() {
        console.log('Found items:', this.items.length);
    }

    logItems() {
        this.items.forEach((item, index) =&gt; console.log('Item', index + 1, item));
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>QueryList</code> acts like a live array — it updates automatically if the view changes (for example, if <code>*ngIf</code> adds or removes elements).</li>
    </ul>
    <br/>
    <br/>


    <li><b>@ContentChild() and @ContentChildren() — projected content</b></li>
    <br/>
    <ul>
        <li>Use these for elements or components that are <b>projected into</b> your component through <code>&lt;ng-content&gt;</code>.</li>
        <br/>
        <li>This is for content that the <b>parent passes in</b>, not what the component itself defines.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-panel',
    template: `
        &lt;div class="panel"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
    `,
})
export class PanelComponent implements AfterContentInit {
    @ContentChild('projected') content!: ElementRef;

    ngAfterContentInit() {
        console.log('Projected element:', this.content.nativeElement);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-panel&gt;
    &lt;p #projected&gt;Hello projected world!&lt;/p&gt;
&lt;/app-panel&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>@ContentChild()</code> finds a matching reference inside the projected content (the part between <code>&lt;app-panel&gt;...&lt;/app-panel&gt;</code>).</li>
        <li>Access it in <code>ngAfterContentInit()</code>, not <code>ngOnInit()</code>, since the content is only inserted after initialization.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to use each hook</b></li>
    <br/>
    <ul>
        <li><code>@ViewChild</code> / <code>@ViewChildren</code> → for elements or components declared inside your own template. Access them in <code>ngAfterViewInit()</code>.</li>
        <br/>
        <li><code>@ContentChild</code> / <code>@ContentChildren</code> → for content projected from a parent. Access them in <code>ngAfterContentInit()</code>.</li>
    </ul>
<pre><code class="language-text">
ViewChild       → single element in template
ViewChildren    → multiple elements in template
ContentChild    → single projected element (via &lt;ng-content&gt;)
ContentChildren → multiple projected elements
</code></pre>
    <br/>
    <br/>


    <li><b>Practical use cases</b></li>
    <br/>
    <ul>
        <li>Auto-focusing or measuring DOM elements after view init.</li>
        <li>Calling methods on child components (e.g., <code>reset()</code>, <code>validate()</code>).</li>
        <li>Collecting or managing groups of dynamic child components.</li>
        <li>Reacting to projected content, like tabs, cards, or custom slots.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Using DOM APIs in Angular</h3>
<ol>
    <li><b>Why use DOM APIs?</b></li>
    <br/>
    <ul>
        <li>Sometimes you need to interact directly with the browser's Document Object Model (DOM) — for example, to focus an input, measure an element's size, scroll smoothly, or change a style dynamically.</li>
        <br/>
        <li>Angular normally manages the DOM for you through templates and bindings, but you can safely access it when necessary.</li>
        <br/>
        <li>Direct DOM access should be done carefully to keep your app safe and compatible with server-side rendering (Angular Universal).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing elements with ElementRef</b></li>
    <br/>
    <ul>
        <li><code>ElementRef</code> is the simplest way to get a reference to a DOM element.</li>
        <br/>
        <li>It wraps the real DOM node inside a <code>nativeElement</code> property.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;div #box class="blue-box"&gt;Hello Box&lt;/div&gt;`,
    styles: [`.blue-box { width: 100px; height: 100px; background: lightblue; }`]
})
export class BoxComponent implements AfterViewInit {
    @ViewChild('box') box!: ElementRef&lt;HTMLDivElement&gt;;

    ngAfterViewInit() {
        console.log(this.box.nativeElement); // &lt;div&gt; element itself
        this.box.nativeElement.style.border = '2px solid navy';
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>nativeElement</code> gives direct access to the DOM node.</li>
        <li>You can read or set properties like <code>textContent</code>, <code>classList</code>, <code>style</code>, etc.</li>
        <li>Always access it in <code>ngAfterViewInit()</code> so the view is ready.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Modifying styles and classes</b></li>
    <br/>
    <ul>
        <li>Angular provides the <code>Renderer2</code> service for safer DOM manipulation.</li>
        <br/>
        <li><code>Renderer2</code> works even when your app runs outside the browser (like in a server environment).</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef, Renderer2, ViewChild, AfterViewInit } from '@angular/core';

@Component({
    selector: 'app-colored-box',
    template: `&lt;div #box&gt;Click me!&lt;/div&gt;`
})
export class ColoredBoxComponent implements AfterViewInit {
    @ViewChild('box') box!: ElementRef;
    constructor(private renderer: Renderer2) {}

    ngAfterViewInit() {
        this.renderer.setStyle(this.box.nativeElement, 'background', 'pink');
        this.renderer.setStyle(this.box.nativeElement, 'padding', '10px');
        this.renderer.addClass(this.box.nativeElement, 'rounded');
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>setStyle()</code>, <code>addClass()</code>, <code>removeClass()</code>, and <code>setAttribute()</code> are cross-platform safe.</li>
        <li>This avoids direct DOM access and works well with Angular Universal.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Listening to DOM events</b></li>
    <br/>
    <ul>
        <li>You can use <code>Renderer2.listen()</code> to attach an event listener directly to an element.</li>
        <br/>
        <li>This gives more control than template bindings when you need dynamic event management.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngAfterViewInit() {
    this.renderer.listen(this.box.nativeElement, 'click', () =&gt; {
        alert('Box clicked!');
    });
}
</code></pre>
    <br/>
    <ul>
        <li><code>listen()</code> automatically cleans up when the element is destroyed — you don't need to remove listeners manually.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Reading sizes and positions</b></li>
    <br/>
    <ul>
        <li>Use normal DOM properties like <code>offsetWidth</code>, <code>offsetHeight</code>, or <code>getBoundingClientRect()</code> to measure elements.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngAfterViewInit() {
    const rect = this.box.nativeElement.getBoundingClientRect();
    console.log('Width:', rect.width, 'Height:', rect.height);
}
</code></pre>
    <br/>
    <ul>
        <li>This is useful for animations, positioning, or responsive logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Scrolling and focusing</b></li>
    <br/>
    <ul>
        <li>Many DOM elements have built-in methods like <code>scrollIntoView()</code> and <code>focus()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">scrollToBox() {
    this.box.nativeElement.scrollIntoView({ behavior: 'smooth' });
}
</code></pre>
    <br/>
    <ul>
        <li>You can call these safely once the view exists.</li>
        <li>Combine with buttons or triggers to make smooth navigation experiences.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using @HostListener for simple DOM events</b></li>
    <br/>
    <ul>
        <li>Instead of manually using <code>Renderer2.listen()</code>, Angular offers the <code>@HostListener()</code> decorator to respond to DOM events directly on your component's host element.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostListener } from '@angular/core';

@Component({
    selector: 'app-click-alert',
    template: `&lt;div&gt;Click anywhere on me!&lt;/div&gt;`,
})
export class ClickAlertComponent {
    @HostListener('click')
    handleClick() {
        console.log('Host element clicked!');
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>@HostListener()</code> automatically registers and cleans up event handlers.</li>
        <li>It's the easiest way to respond to host events without touching <code>Renderer2</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Safety notes</b></li>
    <br/>
    <ul>
        <li>Avoid direct DOM manipulation when possible — it can bypass Angular's rendering and cause inconsistencies.</li>
        <br/>
        <li>Use <code>Renderer2</code> or <code>@HostListener</code> for most operations — they work in web workers and server rendering.</li>
        <br/>
        <li>If you must access <code>window</code> or <code>document</code>, do it only inside browser-safe conditions (e.g., check <code>isPlatformBrowser()</code>).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
<!-- * * * * * * * * * * * * * * -->
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
