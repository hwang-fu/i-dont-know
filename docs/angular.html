<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Angular</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-size: 14px;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    ins {
        background-color: #d4fcbc;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    .nav-icon {
        width: 18px;
        height: 18px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }

    del::before,
    ins::before {
        position: absolute;
        left: 0.5rem;
        font-family: monospace;
    }

    del::before {
        content: "−";
    }

    ins::before {
        content: "+";
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/angular.png" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ol style="line-height: 1.8;">
        <li><a href="#ng-tips">Tips</a></li>
        <li><a href="#ng-signal-basics">Signal Basics</a></li>
        <li><a href="#ng-linked-signals">Linked Signals</a></li>
        <li><a href="#ng-css-selector-component">CSS Selector Component</a></li>
        <li><a href="#ng-make-the-reset-button-actually-do-things">Extend the example: make the reset button actually do things</a></li>
        <li><a href="#ng-select-drop-zone">What does <code>selector: 'drop-zone, [dropzone]'</code> mean?</a></li>
        <li><a href="#ng-define-a-custom-attr-ng-input">How to define a custom attribute (Angular Input)?</a></li>
        <li><a href="#ng-show-the-custom-input-as-real-html-attr">How to show the custom Input as a real HTML attribute?</a></li>
        <li><a href="#ng-default-boolean-attr-with-true-false-behavior">Default boolean attribute with true/false behavior</a></li>
        <li><a href="#ng-setting-a-default-dom-attr-directly">Setting a default DOM attribute directly</a></li>
        <li><a href="#ng-can-multi-elem-be-applied-to-one-elem">Can multiple components be applied to one element?</a></li>
        <li><a href="#ng-component-selectors">Component Selectors</a></li>
        <li><a href="#ng-basics-on-styling-components">Basics on Styling Components</a></li>
        <li><a href="#ng-basics-on-input-props">Basics on Input Properties</a></li>
        <li><a href="#ng-basics-on-output-props">Basics on Output Properties</a></li>
        <li><a href="#ng-content-proj">Content projection with <code>&lt;ng-content&gt;</code></a></li>
        <li><a href="#ng-component-host-elems">Component Host Elements</a></li>
        <li><a href="#ng-component-lifecycle">Component Lifecycle</a></li>
        <li><a href="#ng-referencing-component-children-with-queries">Referencing component children with queries</a></li>
        <li><a href="#ng-dom-apis-in-ng">Using DOM APIs in Angular</a></li>
        <li><a href="#ng-inheritance">Inheritance in Angular</a></li>
        <li><a href="#ng-programmatically-rendering-components">Programmatically rendering components</a></li>
        <li><a href="#ng-adv-component-config">Advanced component configuration</a></li>
        <li><a href="#ng-binding-dynamic-text-props-attrs">Binding dynamic text, properties, and attributes</a></li>
        <li><a href="#ng-adding-event-listeners-in-ng">Adding Event Listeners in Angular</a></li>
        <li><a href="#ng-two-way-binding">Two-way binding in Angular</a></li>
        <li><a href="#ng-control-flow-in-ng">Control Flow in Angular</a></li>
        <li><a href="#ng-pipes">Pipes in Angular</a></li>
        <li><a href="#ng-creating-custom-pipes">Creating Custom Pipes in Angular</a></li>
        <li><a href="#ng-render-templates-from-a-parent-component">Render Templates from a Parent Component with <code>&lt;ng-content&gt;</code> (sorted of repeated)</a></li>
        <li><a href="#ng-create-template-fragments-with-ng-template">Create Template Fragments with <code>&lt;ng-template&gt;</code></a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="#ng-tips">Tips</h3>
<ol>
    <li>Separate words within a file name with hyphens (<code>-</code>). For example, a component named <code>UserProfile</code> has a file name <code>user-profile.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>For unit tests, end file names with <code>.spec.ts</code>.
        For example, the unit test file for the <code>UserProfile</code> component has the file name <code>user-profile.spec.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>All of your Angular UI code (TypeScript, HTML, and styles) should live inside a directory named <code>src</code>.<br/><br/>
        Code that's not related to UI, such as configuration files or scripts, should live outside the <code>src</code> directory.</li>
    <br/>
    <br/>
    <br/>
    <li>The code to start up, or bootstrap, an Angular application should always live in a file named <code>main.ts</code>.<br/><br/>
        This represents the primary entry point to the application.</li>
    <br/>
    <br/>
    <br/>
    <li>Angular components consist of a TypeScript file and, optionally, a template and one or more style files. You should group these together in the same directory.</li>
    <br/>
    <br/>
    <br/>
    <li>Avoid creating subdirectories based on the type of code that lives in those directories.<br/><br/>
        For example, avoid creating directories like <code>components/</code>, <code>directives/</code>, and <code>services/</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>Prefer the <code>inject()</code> function over constructor parameter injection.</li>
    <br/>
    <br/>
    <br/>
    <li>Use <code>protected</code> on class members that are only used by a component's template.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({
    ...,
    template: `<p>{{ fullName() }}</p>`,
})
export class UserProfile {
    firstName = input();
    lastName  = input();
    // `fullName` is not part of the component's public API, but is used in the template.
    protected fullName = computed(() =&gt; `${this.firstName()} ${this.lastName()}`);
}
</code></pre>
    <br/>
    <br/>
    <br/>
    <li>Use <code>readonly</code> for properties that shouldn't change.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({/* ... */})
export class UserProfile {
    readonly userId    = input();
    readonly userSaved = output();
    readonly userName  = model();
}
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-signal-basics">Basics about Signals</h3>
<ol>
    <li><b>What is a signal?</b><br/><br/>
        A <code>signal</code> is a reactive value container that automatically notifies Angular when its content changes.<br/><br/>
        Unlike normal class properties, signals are tracked by Angular's change detection system — any component using them updates automatically.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, Component } from '@angular/core';

@Component({
    selector: 'counter-example',
    template: `
        &lt;h3&gt;Count: {{ count() }}&lt;/h3&gt;
        &lt;button (click)="increment()"&gt;+&lt;/button&gt;
    `,
    standalone: true,
})
export class CounterExample {
    count = signal(0);
    increment() {
        this.count.update(v =&gt; v + 1);
    }
}
</code></pre>
        <br/>
        Signals are functions — you read them by calling like <code>count()</code>, not <code>count</code>.
    </li>

    <br/><br/><br/>

    <li><b>Writable signals</b><br/><br/>
        A writable signal is a normal signal created with <code>signal()</code>. It can be changed with:
        <ul>
            <br/>
            <li><code>.set(newValue)</code> – replace the value directly</li>
            <br/>
            <li><code>.update(fn)</code> – change it based on its current value</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const counter = signal(0);

counter.set(10);          // sets value to 10
counter.update(v =&gt; v+1); // now 11
console.log(counter());   // prints 11
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Computed signals</b><br/><br/>
        Computed signals are read-only values derived from one or more other signals.
        They automatically recalculate when any of their dependencies change.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, computed } from '@angular/core';

const first = signal('Hwang');
const last  = signal('Fu');

const fullName = computed(() =&gt; `${first()} ${last()}`);

console.log(fullName());   // "Hwang Fu"

last.set('Fucius');
console.log(fullName());   // "Hwang Fucius" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Effects</b><br/><br/>
        An <code>effect()</code> runs a piece of code automatically whenever the signals it reads change.
        Useful for logging, animations, or syncing values.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, effect } from '@angular/core';

const count = signal(0);

effect(() =&gt; {
    console.log('Count changed:', count());
});

count.set(1);  // console logs: Count changed: 1
count.set(2);  // console logs: Count changed: 2
</code></pre>
        <br/>
        Angular automatically cleans up effects when their owner component is destroyed.
    </li>

    <br/><br/><br/>

    <li><b>Inputs and signals</b><br/><br/>
        You can also create component inputs that behave like signals using <code>input()</code>.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'user-card',
    template: `&lt;p&gt;Hello, {{ name() }}!&lt;/p&gt;`,
})
export class UserCard {
    name = input('Anonymous');   // signal-style input with default
}
</code></pre>
        <br/>
        <ul>
            <li><code>input()</code> → for reading input signals</li>
            <li><code>output()</code> → for emitting events</li>
            <li><code>model()</code> → for two-way binding (v18+)</li>
        </ul>
    </li>

    <br/><br/><br/>

    <li><b>Readonly vs writable signals</b><br/><br/>
        A computed signal is <code>readonly</code> by design, meaning you cannot call <code>.set()</code> or <code>.update()</code> on it.<br/><br/>
        Writable signals (<code>signal()</code>) can both be read and updated.
    </li>

    <br/><br/><br/>

    <li><b>Accessing signals from the template</b><br/><br/>
        In templates, signals behave like functions — you must call them:
<pre class="line-numbers"><code class="language-html">&lt;h2&gt;{{ count() }}&lt;/h2&gt;   &lt;!-- ✅ correct --&gt;
&lt;h2&gt;{{ count }}&lt;/h2&gt;     &lt;!-- ❌ won't update --&gt;
</code></pre>
        <br/>
        Angular automatically re-renders that part of the template when the signal changes.
    </li>

    <br/><br/><br/>

    <li><b>When to use signals?</b><br/><br/>
        <ul>
            <li>For local component state (form inputs, toggles, UI flags)</li>
            <br/>
            <li>For derived/computed data</li>
            <br/>
            <li>For lightweight reactivity without external stores</li>
            <br/>
            <li>Instead of RxJS <code>BehaviorSubject</code> for simple cases</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-linked-signals">Linked Signals</h3>
<ol>
    <li><b>What is a linked signal?</b><br/><br/>
        A <code>linkedSignal()</code> is a special kind of signal that stays connected to another signal.<br/><br/>
        When the source signal changes, the linked one also updates automatically.<br/><br/>
        Think of it as a "live copy" or a "mirror" of another signal — but one that can also transform or filter the value.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, linkedSignal } from '@angular/core';

const name = signal('Hwangfu');

// Linked signal that always follows `name`
const upperName = linkedSignal(() =&gt; name().toUpperCase());

console.log(upperName()); // "HWANGFU"

name.set('Fucius');
console.log(upperName()); // "FUCIUS" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Why not just use <code>computed()</code>?</b><br/><br/>
        <code>computed()</code> and <code>linkedSignal()</code> look similar, but there's one key difference:<br/><br/>
        <ul>
            <li><code>computed()</code> → read-only, you can't change its value directly</li>
            <br/>
            <li><code>linkedSignal()</code> → can also be written to (you can modify it)</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const count = signal(0);

// Computed: only reads from count
const double = computed(() =&gt; count() * 2);

// Linked: can read and write
const mirror = linkedSignal(() =&gt; count(), {
    // define how writing back should work
    set: (newVal) =&gt; count.set(newVal),
});

mirror.set(5);
console.log(count()); // 5
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>When to use linked signals?</b><br/><br/>
        Linked signals are useful when two parts of your code need to share the same data, but maybe in a slightly different form.<br/><br/>
        For example, if you want to edit a copy of a user object without losing the original right away:
<pre class="line-numbers"><code class="language-ts">const activeUser = signal({ id: 1, name: 'Alice' });

// Create a linked version for editing
const editUser = linkedSignal(() =&gt; activeUser(), {
    // treat users with the same id as the same object
    equal: (a, b) =&gt; a.id === b.id,
});

console.log(editUser());  // { id: 1, name: 'Alice' }

editUser.update(u =&gt; ({ ...u, name: 'Alicia' }));
console.log(editUser().name);  // "Alicia"

// if `activeUser` changes, `editUser` also updates
activeUser.set({ id: 1, name: 'Alina' });
console.log(editUser().name);  // "Alina"
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Basic syntax patterns</b><br/><br/>
        You can define a linked signal in two common ways:
        <br/><br/>
        <b>1. Simple form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal(() =&gt; source());
</code></pre>
        <b>2. Detailed form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal({
    source: source,
    computation: (value) =&gt; value,
    equal: (a, b) =&gt; a.id === b.id,
});
</code></pre>
        <br/>
        The detailed form gives you more control: you can define how values are compared, or how they're computed.
    </li>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-css-selector-component">What does a CSS selector component do?</h3>
<ol>
    <li>When you write <code>@Component({ selector: 'button[type="reset"]' })</code>, Angular matches all elements in the DOM that fit this CSS selector.</li>
    <br/><br/>

    <li>If an element matches, Angular creates your component and attaches it to that element.</li>
    <br/><br/>

    <li>The element is NOT replaced. It stays the original tag. Angular just uses it as the host.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'button[type="reset"]',
    template: '<ng-content></ng-content>',
})
export class ResetButton {}
</code></pre>
    <br/>
    Any <code>&lt;button type="reset"&gt;</code> becomes a <code>ResetButton</code> component host.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-make-the-reset-button-actually-do-things">Extend the example: make the reset button actually do things</h3>
<ol>
    <li>Below is a <code>ResetButton</code> component that:
        <ul>
            <br/>
            <li>adds classes (for styling)</li>
            <br/>
            <li>supports variants (<code>primary</code> / <code>ghost</code>)</li>
            <br/>
            <li>supports a <code>loading</code> state (shows a spinner, disables clicks)</li>
            <br/>
            <li>sets accessibility attributes (<code>aria-disabled</code>, <code>aria-busy</code>)</li>
            <br/>
            <li>keeps the original button text via <code>&lt;ng-content&gt;</code></li>
        </ul>
    </li>

    <br/><br/>

    <li>TypeScript (component):
<pre class="line-numbers"><code class="language-ts">import { Component, HostBinding, HostListener, Input } from '@angular/core';

@Component({
    selector: 'button[type="reset"]',
    // The host element IS the &lt;button&gt;. We only render inside it.
    template: `
        &lt;span class="content" [class.hidden]="loading"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/span&gt;
        &lt;span class="spinner" *ngIf="loading" aria-hidden="true"&gt;⏳&lt;/span&gt;
    `,
    styles: [`
        :host {
            /* base look */
            font: inherit;
            border-radius: 6px;
            padding: .5rem .9rem;
            cursor: pointer;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: .5rem;
            transition: background-color .15s ease, border-color .15s ease, color .15s ease;
        }

        /* variants via classes on :host */
        :host(.primary) {
            background: #0d6efd;
            color: white;
        }
        :host(.primary:hover) { background: #0b5ed7; }

        :host(.ghost) {
            background: transparent;
            color: #0d6efd;
            border-color: #0d6efd;
        }
        :host(.ghost:hover) { background: rgba(13,110,253,.08); }

        /* disabled look */
        :host(.disabled) {
            opacity: .55;
            cursor: not-allowed;
            pointer-events: none;
        }

        .spinner { display: inline-flex; }
        .content.hidden { visibility: hidden; } /* reserve space so width doesn't jump */
    `],
    standalone: true,
})
export class ResetButton {
    /** Visual variant */
    @Input() variant: 'primary' | 'ghost' = 'primary';

    /** Loading state: blocks clicks, shows spinner, updates aria */
    @Input() loading = false;

    /** Disable state (useful if you want to disable the reset button) */
    @Input() disabled = false;

    /** Reflect variant and states as CSS classes on the host &lt;button&gt; */
    @HostBinding('class')
    get hostClasses(): string {
        const v = this.variant ?? 'primary';
        return [v, this.disabled || this.loading ? 'disabled' : ''].filter(Boolean).join(' ');
    }

    /** Keep native semantics but add A11y hints */
    @HostBinding('attr.aria-disabled') get ariaDisabled() { return String(this.disabled); }
    @HostBinding('attr.aria-busy')     get ariaBusy()     { return String(this.loading); }

    /** Optional: ensure the host has type="reset" (safety if HTML missed it) */
    @HostBinding('attr.type') readonly type = 'reset';

    /** Block clicks when disabled/loading */
    @HostListener('click', ['$event'])
    onClick(ev: MouseEvent) {
        if (this.disabled || this.loading) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
        }
    }
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage examples:
<pre class="line-numbers"><code class="language-html">&lt;!-- Matches selector because it's a button[type="reset"] --&gt;
&lt;button type="reset" variant="primary"&gt;Reset form&lt;/button&gt;

&lt;!-- Switch variant --&gt;
&lt;button type="reset" variant="ghost"&gt;Clear&lt;/button&gt;

&lt;!-- Loading state --&gt;
&lt;button type="reset" variant="primary" [loading]="true"&gt;Resetting…&lt;/button&gt;

&lt;!-- Disabled state --&gt;
&lt;button type="reset" [disabled]="true"&gt;Disabled reset&lt;/button&gt;

&lt;!-- With projected rich content --&gt;
&lt;button type="reset" variant="primary"&gt;
    &lt;span class="hl-grey-fg"&gt;↺&lt;/span&gt;
    Reset filters
&lt;/button&gt;
</code></pre>
    </li>
    <br/><br/>

    <li>What changed compared to the minimal skeleton:
        <ul>
            <br/>
            <li><code>@Input()</code> values (<code>variant</code>, <code>loading</code>, <code>disabled</code>) so templates can control the button.</li>
            <br/>
            <li><code>@HostBinding</code> adds/removes CSS classes on the host <code>&lt;button&gt;</code>.</li>
            <br/>
            <li><code>@HostListener('click')</code> prevents clicks when disabled/loading.</li>
            <br/>
            <li><code>type="reset"</code> is enforced, so even if HTML forgot it, it behaves as a reset button.</li>
            <br/>
            <li>Simple styles are scoped to this component only.</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-select-drop-zone">What does <code>selector: 'drop-zone, [dropzone]'</code> mean?</h3>
<ol>
    <li>This selector matches two things:
        <ul>
            <br/>
            <li><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;</code></li>
            <br/>
            <li>Any element with a <code>dropzone</code> attribute, like <code>&lt;div dropzone&gt;</code></li>
        </ul>
    </li>

    <br/>
    <br/>
    <br/>

    <li>Both become hosts for the <code>DropZone</code> component.</li>

    <br/>
    <br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '<ng-content></ng-content>',
})
export class DropZone {}
</code></pre>
    </li>

    <br/><br/>

    <li>The host element is NOT replaced, the component renders inside it.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-define-a-custom-attr-ng-input">How to define a custom attribute (Angular Input)?</h3>
<ol>
    <li>You define a custom attribute using <code>@Input()</code>.</li>

    <br/><br/>

    <li>This does not create a real DOM attribute unless you bind it.</li>

    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone',
    template: '<ng-content></ng-content>',
})
export class DropZone {
    @Input() mode: 'files' | 'links' | 'images' = 'files';
}
</code></pre>

    Usage:
<pre><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;                (uses default: mode = "files")
&lt;drop-zone mode="links"&gt;&lt;/drop-zone&gt;   (sets mode = "links")
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-show-the-custom-input-as-real-html-attr">How to show the custom Input as a real HTML attribute?</h3>
<ol>
    <li>Use <code>@HostBinding('attr.&lt;attribute-name&gt;')</code>.</li>
    <br/><br/>

    <li>This makes the Input appear in the DOM inspector.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[dropzone]',
})
export class DropzoneDirective {
    @Input() dropzone: string = 'files';

    @HostBinding('attr.dropzone')
    get attrValue() {
        return this.dropzone;
    }
}
</code></pre>

    Resulting DOM:
<pre><code>&lt;div dropzone="files"&gt;&lt;/div&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-default-boolean-attr-with-true-false-behavior">Default boolean attribute with true/false behavior</h3>
<ol>
    <li>Use <code>booleanAttribute</code> transform.</li>
    <br/><br/>

    <li>This makes <code>appResizable</code> behave like a proper boolean.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[appResizable]',
})
export class ResizableDirective {
    @Input({ alias: 'appResizable', transform: booleanAttribute })
    resizable = true;

    @HostBinding('attr.data-resizable')
    get data() {
        return String(this.resizable);
    }
}
</code></pre>

    Usage:
<pre><code>&lt;div appResizable&gt;&lt;/div&gt;            (true by default)
&lt;div appResizable="true"&gt;&lt;/div&gt;     (true)
&lt;div [appResizable]="false"&gt;&lt;/div&gt;  (false)
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-setting-a-default-dom-attr-directly">Setting a default DOM attribute directly</h3>
<ol>
    <li>If you just want an element to always have an attribute, bind it with HostBinding.</li>
    <br/><br/>

    <li>Example: default <code>type="reset"</code> for any button with a directive.
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: 'button[appResetDefault]',
})
export class ResetDefaultDirective {
    @HostBinding('attr.type') type = 'reset';
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage:
<pre><code>&lt;button appResetDefault&gt;Clear&lt;/button&gt;</code></pre>

    This becomes:
<pre><code>&lt;button type="reset"&gt;Clear&lt;/button&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-can-multi-elem-be-applied-to-one-elem">Can multiple components be applied to one element?</h3>
<ol>
    <li>No — only one component can attach to a single element.</li>
    <br/><br/>

    <li>Directives can stack, but components cannot.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-component-selectors">Component Selectors</h3>
<ol>
    <li><b>What is a component selector?</b></li>
    <br/>
    <ul>
        <li>The <code>selector</code> tells Angular where to place a component in the DOM.</li>
        <br/>
        <li>It lives in the <code>@Component({ ... })</code> metadata:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User card works&lt;/p&gt;`,
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Every time Angular sees <code>&lt;app-user-card&gt;</code> in a template, it creates a <code>UserCard</code> component there.</li>
        <br/>
        <li>The element itself becomes the host of the component. It is not replaced.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Element selectors</b></li>
    <br/>
    <ul>
        <li>This is the most common style.</li>
        <br/>
        <li>The selector looks like a custom HTML tag name:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-profile',
    template: `&lt;h2&gt;Profile&lt;/h2&gt;`,
})
export class ProfileComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Usage in another template --&gt;
&lt;app-profile&gt;&lt;/app-profile&gt;
</code></pre>
    <br/>
    <ul>
        <li>Use <b>kebab-case</b> (lowercase with dashes): <code>app-profile</code>, <code>user-card</code>, etc.</li>
        <br/>
        <li>Start with a prefix like <code>app-</code> (you can customize your own) to avoid conflicts with future HTML tags.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Attribute selectors</b></li>
    <br/>
    <ul>
        <li>An attribute selector matches normal HTML elements that have a certain attribute.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: '[appPanel]',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class PanelComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;section appPanel&gt;
    Panel content
&lt;/section&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the host is the existing <code>&lt;section&gt;</code> element.</li>
        <br/>
        <li>Use attribute selectors when you want to "enhance" an existing element, not introduce a new tag.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Multiple selectors</b></li>
    <br/>
    <ul>
        <li>You can combine selectors with commas.</li>
        <br/>
        <li>Example (similar to your drop zone example):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '&lt;ng-content&gt;&lt;/ng-content&gt;',
})
export class DropZoneComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Both usages match the same component --&gt;
&lt;drop-zone&gt;Drop files here&lt;/drop-zone&gt;

&lt;div dropzone&gt;Drop files here&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Both an element <code>&lt;drop-zone&gt;</code> and any element with the <code>dropzone</code> attribute become hosts for the same component.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CSS selectors</b></li>
    <br/>
    <ul>
        <li>The <code>selector</code> field accepts valid CSS selectors.</li>
        <br/>
        <li>For example, matching all reset buttons:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'button[type="reset"]',
    template: '&lt;ng-content&gt;&lt;/ng-content&gt;',
})
export class ResetButtonComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;button type="reset"&gt;Reset form&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li>Every <code>&lt;button type="reset"&gt;</code> now becomes a <code>ResetButtonComponent</code> host.</li>
        <br/>
        <li>Be careful with very broad selectors like <code>div</code> or <code>button</code>, they can match too many elements and make templates confusing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>One component per element</b></li>
    <br/>
    <ul>
        <li>Only one component can attach to a single element.</li>
        <br/>
        <li>Directives (like attribute directives) can stack, but components cannot.</li>
        <br/>
        <li>If two component selectors both match the same element, Angular will throw an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Naming and best practices</b></li>
    <br/>
    <ul>
        <li>Use a clear prefix (e.g. <code>app-</code>, <code>admin-</code>, <code>shared-</code>).</li>
        <br/>
        <li>Element selectors for main UI blocks:
<pre><code class="language-text">
app-header, app-footer, app-user-card
</code></pre>
        </li>
        <br/>
        <li>Attribute selectors for behavior-like components or directive-style helpers:
<pre><code class="language-text">
[appPanel], [appResetDefault], [dropzone]
</code></pre>
        </li>
        <br/>
        <li>Keep selectors specific enough so it is obvious where a component is used.</li>
        <br/>
        <li>Do not reuse the same selector name for different components.</li>
    </ul>
    <br/>
    <br/>


    <li><b>How Angular uses the selector</b></li>
    <br/>
    <ul>
        <li>During compilation, Angular scans your templates.</li>
        <br/>
        <li>When it finds something that matches a component's selector, it:
            <ul>
                <li>Creates an instance of that component,</li>
                <li>Attaches it to the matching DOM element (host),</li>
                <li>Renders the component's template inside that host.</li>
            </ul>
        </li>
        <br/>
        <li>The host element is kept. Angular only controls what is rendered inside it and its attributes / classes.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-basics-on-styling-components">Basics on Styling Components</h3>
<ol>
    <li><b>Where do component styles live?</b></li>
    <br/>
    <ul>
        <li>You can write styles directly in the component, or in a separate file.</li>
        <br/>
        <li>Inline styles (small components):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;div class="card"&gt;User card&lt;/div&gt;`,
    styles: [`
        .card {
            padding: 1rem;
            border-radius: .5rem;
            border: 1px solid #ddd;
        }
    `],
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Separate CSS/SCSS file (bigger components):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    templateUrl: './user-card.component.html',
    styleUrls: ['./user-card.component.css'],
})
export class UserCard {}
</code></pre>
    <br/>
    <ul>
        <li>Use inline <code>styles</code> for quick examples or tiny components.</li>
        <br/>
        <li>Use <code>styleUrls</code> with a <code>.css</code> or <code>.scss</code> file for anything non-trivial.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Component styles are local</b></li>
    <br/>
    <ul>
        <li>By default, styles in a component only apply to that component's template.</li>
        <br/>
        <li>This means:
            <ul>
                <li>They do not "leak" into other components.</li>
                <li>You can reuse simple class names like <code>.title</code> in many components without conflicts.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-a',
    template: `&lt;h2 class="title"&gt;A&lt;/h2&gt;`,
    styles: [`.title { color: red; }`],
})
export class AComponent {}

@Component({
    selector: 'app-b',
    template: `&lt;h2 class="title"&gt;B&lt;/h2&gt;`,
    styles: [`.title { color: blue; }`],
})
export class BComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-a&gt;&lt;/app-a&gt;
&lt;app-b&gt;&lt;/app-b&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>A</code> is red and <code>B</code> is blue, even though both use the same class name.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Styling the host element with <code>:host</code></b></li>
    <br/>
    <ul>
        <li>The <code>:host</code> selector targets the <u>outer element</u> that holds your component.</li>
        <br/>
        <li>Example (similar to your reset button):</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-pill-badge',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: inline-block;
            padding: .2rem .6rem;
            border-radius: 999px;
            background: #f0f4ff;
            color: #1f3b8f;
            font-size: .8rem;
        }
    `],
    standalone: true,
})
export class PillBadge {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-pill-badge&gt;New&lt;/app-pill-badge&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>:host</code> styles the <code>&lt;app-pill-badge&gt;</code> element itself.</li>
        <br/>
        <li>Use <code>:host</code> for width, padding, display, border, etc. of the component's root element.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Styling based on host classes: <code>:host(.some-class)</code></b></li>
    <br/>
    <ul>
        <li>You can change styles depending on classes applied to the host element.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: .75rem 1rem;
            border-radius: 4px;
        }

        :host(.info) {
            background: #e7f1ff;
            color: #0b4f9c;
        }

        :host(.error) {
            background: #ffe5e5;
            color: #a30000;
        }
    `],
    standalone: true,
})
export class AlertComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-alert class="info"&gt;Information&lt;/app-alert&gt;
&lt;app-alert class="error"&gt;Something went wrong&lt;/app-alert&gt;
</code></pre>
    <br/>
    <ul>
        <li>The same component can look different based on classes you add.</li>
        <br/>
        <li>This pattern is nice for variants like <code>primary</code>, <code>ghost</code>, <code>warning</code>, etc.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding classes and styles from TypeScript</b></li>
    <br/>
    <ul>
        <li>You can toggle CSS classes using property bindings.</li>
        <br/>
        <li>Simple class binding:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button
    class="btn"
    [class.btn-primary]="primary"
    [class.btn-disabled]="disabled"
&gt;
    Save
&lt;/button&gt;
</code></pre>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-save-button',
    templateUrl: './save-button.component.html',
})
export class SaveButtonComponent {
    primary = true;
    disabled = false;
}
</code></pre>
    <br/>
    <ul>
        <li>Style binding works similarly:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div [style.opacity]="disabled ? 0.5 : 1"&gt;Content&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Use these bindings when styles depend on component state (loading, error, active, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Component styles vs global styles</b></li>
    <br/>
    <ul>
        <li>Global styles live in files like <code>styles.css</code> at the root of your app.</li>
        <br/>
        <li>Use global styles for:
            <ul>
                <li>Page background, base font, body margin, etc.</li>
                <li>Theme variables (colors, spacing, typography).</li>
                <li>Reset/normalize styles.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-css line-numbers">/* styles.css */
html, body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #fafafa;
}
</code></pre>
    <br/>
    <ul>
        <li>Use component styles for:
            <ul>
                <li>Buttons, cards, forms, and layout that belong to one component.</li>
                <li>Anything that should not affect the whole app.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Light introduction to <code>:host-context()</code></b></li>
    <br/>
    <ul>
        <li><code>:host-context()</code> lets you style a component differently depending on something outside of it.</li>
        <br/>
        <li>Example: dark mode class on a parent element:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-box',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: 1rem;
            background: white;
            color: black;
        }

        :host-context(.dark-mode) {
            background: #1f2933;
            color: #f9fafb;
        }
    `],
})
export class BoxComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;div class="dark-mode"&gt;
    &lt;app-box&gt;This box appears in dark mode&lt;/app-box&gt;
&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>This is helpful if you have a global "theme" class but still want components to react to it.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-basics-on-input-props">Basics on Input Properties</h3>
<ol>
    <li><b>What are input properties?</b></li>
    <br/>
    <ul>
        <li><code>@Input()</code> lets a parent component send data down to a child component.</li>
        <br/>
        <li>It works just like passing arguments into a function, but through HTML attributes.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-greeting',
    template: `&lt;h3&gt;Hello, {{ name }}!&lt;/h3&gt;`,
})
export class GreetingComponent {
    @Input() name = 'Guest';   // receives value from parent
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent template --&gt;
&lt;app-greeting name="Alice"&gt;&lt;/app-greeting&gt;
&lt;app-greeting name="Bob"&gt;&lt;/app-greeting&gt;
</code></pre>
    <br/>
    <ul>
        <li>The parent sets <code>name</code> just like a normal HTML attribute.</li>
        <br/>
        <li>Angular automatically passes that value into the child component's <code>@Input()</code> field.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding expressions to inputs</b></li>
    <br/>
    <ul>
        <li>You can also bind dynamic data using square brackets <code>[]</code>.</li>
        <br/>
        <li>This lets you send variables, not just strings.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-parent',
    template: `
        &lt;app-greeting [name]="userName"&gt;&lt;/app-greeting&gt;
    `,
})
export class ParentComponent {
    userName = 'Hwangfucius';
}
</code></pre>
    <br/>
    <br/>


    <li><b>Setting default values</b></li>
    <br/>
    <ul>
        <li>If the parent does not pass a value, the default value in the child is used.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User: {{ name }} ({{ role }})&lt;/p&gt;`,
})
export class UserCardComponent {
    @Input() name = 'Anonymous';
    @Input() role = 'Viewer';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-user-card&gt;&lt;/app-user-card&gt;
&lt;app-user-card name="Alice" role="Admin"&gt;&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>The first card uses defaults. The second one overrides both values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Renaming an input</b></li>
    <br/>
    <ul>
        <li>Sometimes, you want to expose a different name in HTML than in your class.</li>
        <br/>
        <li>You can do this by giving <code>@Input()</code> a string argument:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-book',
    template: `&lt;p&gt;Title: {{ title }}&lt;/p&gt;`,
})
export class BookComponent {
    @Input('bookTitle') title = '';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-book bookTitle="The Hobbit"&gt;&lt;/app-book&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the HTML uses <code>bookTitle</code>, but inside the component, the field name is <code>title</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Input type conversion (transforms)</b></li>
    <br/>
    <ul>
        <li>Starting from Angular 16+, you can add simple type transformations directly in the <code>@Input()</code> decorator.</li>
        <br/>
        <li>Example — converting attribute values into booleans:</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, Input, booleanAttribute } from '@angular/core';

@Component({
    selector: 'app-toggle',
    template: `&lt;button&gt;Enabled: {{ enabled }}&lt;/button&gt;`,
})
export class ToggleComponent {
    @Input({ transform: booleanAttribute }) enabled = false;
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-toggle enabled&gt;&lt;/app-toggle&gt;
&lt;app-toggle enabled="false"&gt;&lt;/app-toggle&gt;
&lt;app-toggle&gt;&lt;/app-toggle&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>booleanAttribute</code> helper makes <code>enabled</code> behave like a real HTML boolean attribute.</li>
        <br/>
        <li>The first one is <code>true</code>, the others are <code>false</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Signal-style inputs (Angular 17+)</b></li>
    <br/>
    <ul>
        <li>You can also define inputs as reactive signals using <code>input()</code>.</li>
        <br/>
        <li>This makes them automatically re-render when updated, no need for change detection tricks.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, input } from '@angular/core';

@Component({
    selector: 'app-profile',
    template: `&lt;p&gt;Welcome, {{ name() }}!&lt;/p&gt;`,
})
export class ProfileComponent {
    name = input('Guest');
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-profile name="Hwangfucius"&gt;&lt;/app-profile&gt;
</code></pre>
    <br/>
    <ul>
        <li>It behaves like <code>@Input()</code>, but integrates perfectly with the Angular signals system.</li>
        <br/>
        <li>In templates, signal inputs must be called like functions (<code>{{ name() }}</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Validating and reacting to input changes</b></li>
    <br/>
    <ul>
        <li>Sometimes, you want to run logic whenever an input changes.</li>
        <br/>
        <li>Two simple ways:</li>
    </ul>
<pre><code class="language-ts line-numbers">// 1. Use a setter
@Input()
set count(value: number) {
    console.log('Count changed to', value);
}

// 2. Use ngOnChanges (classic lifecycle hook)
ngOnChanges(changes: SimpleChanges) {
    console.log(changes);
}
</code></pre>
    <br/>
    <ul>
        <li>Setters are simpler for one property, <code>ngOnChanges</code> works if you have many inputs.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-basics-on-output-props">Basics on Output Properties</h3>
<ol>
    <li><b>What are output properties?</b></li>
    <br/>
    <ul>
        <li><code>@Output()</code> lets a child component send data back to its parent.</li>
        <br/>
        <li>They are used for <u>custom events</u> — things that happen inside the child component that the parent wants to know about.</li>
        <br/>
        <li>For example: a button click, a form submission, or a value change.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, Output, EventEmitter } from '@angular/core';

@Component({
    selector: 'app-like-button',
    template: `&lt;button (click)="like()"&gt;Like&lt;/button&gt;`,
})
export class LikeButtonComponent {
    @Output() liked = new EventEmitter&lt;void&gt;();

    like() {
        console.log('Button clicked!');
        this.liked.emit();
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-like-button (liked)="onLiked()"&gt;&lt;/app-like-button&gt;
</code></pre>
    <br/>
    <ul>
        <li>The child emits an event, and the parent listens with parentheses <code>(liked)</code>.</li>
        <br/>
        <li>This is the exact reverse of how <code>@Input()</code> works.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Sending data with the event</b></li>
    <br/>
    <ul>
        <li>You can include data when you emit an event, not just a signal that something happened.</li>
        <br/>
        <li>Example: passing the current like count.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-like-counter',
    template: `&lt;button (click)="addLike()"&gt;{{ count }}&lt;/button&gt;`,
})
export class LikeCounterComponent {
    count = 0;
    @Output() countChange = new EventEmitter&lt;number&gt;();

    addLike() {
        this.count++;
        this.countChange.emit(this.count);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-like-counter (countChange)="onCountUpdated($event)"&gt;&lt;/app-like-counter&gt;
</code></pre>
<pre><code class="language-ts line-numbers">// Parent component
onCountUpdated(newCount: number) {
    console.log('New like count:', newCount);
}
</code></pre>
    <br/>
    <ul>
        <li>The special variable <code>$event</code> contains whatever data was emitted.</li>
        <br/>
        <li>Here, it's the number sent from <code>this.countChange.emit(this.count)</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Renaming an output event</b></li>
    <br/>
    <ul>
        <li>You can rename the event name seen in HTML by passing a string to <code>@Output()</code>.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-toggle',
    template: `
        &lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt;
    `,
})
export class ToggleComponent {
    private on = false;

    @Output('toggled') stateChanged = new EventEmitter&lt;boolean&gt;();

    toggle() {
        this.on = !this.on;
        this.stateChanged.emit(this.on);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent uses the alias name --&gt;
&lt;app-toggle (toggled)="onToggled($event)"&gt;&lt;/app-toggle&gt;
</code></pre>
    <br/>
    <ul>
        <li>In TypeScript it's called <code>stateChanged</code>, but in the template it appears as <code>(toggled)</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining inputs and outputs</b></li>
    <br/>
    <ul>
        <li>It is very common to have both — one for incoming data, one for outgoing events.</li>
        <br/>
        <li>Example: a simple custom checkbox component.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-checkbox',
    template: `
        &lt;label&gt;
            &lt;input type="checkbox" [checked]="checked" (change)="onChange($event)" /&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/label&gt;
    `,
})
export class CheckboxComponent {
    @Input()  checked = false;
    @Output() checkedChange = new EventEmitter&lt;boolean&gt;();

    onChange(event: Event) {
        const input = event.target as HTMLInputElement;
        this.checkedChange.emit(input.checked);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-checkbox [(checked)]="subscribed"&gt;Subscribe&lt;/app-checkbox&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>[(checked)]</code> syntax is shorthand for combining <code>[checked]</code> and <code>(checkedChange)</code>.</li>
        <br/>
        <li>This two-way binding works automatically because the names follow the pattern <code>value</code> / <code>valueChange</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Signal-style outputs (Angular 17+)</b></li>
    <br/>
    <ul>
        <li>With the new signal system, you can define outputs using <code>output()</code> instead of <code>@Output()</code>.</li>
        <br/>
        <li>This keeps your code consistent with signal-style inputs.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, output } from '@angular/core';

@Component({
    selector: 'app-delete-button',
    template: `&lt;button (click)="onDelete()"&gt;Delete&lt;/button&gt;`,
})
export class DeleteButtonComponent {
    deleted = output&lt;string&gt;();

    onDelete() {
        this.deleted.emit('item-42');
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-delete-button (deleted)="handleDelete($event)"&gt;&lt;/app-delete-button&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>output()</code> works almost the same as <code>@Output()</code>, but is simpler to read alongside <code>input()</code>.</li>
        <br/>
        <li>Use it when writing modern Angular components that already use signals.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-content-proj">Content projection with <code>&lt;ng-content&gt;</code></h3>
<ol>
    <li><b>What is content projection?</b></li>
    <br/>
    <ul>
        <li>Content projection means letting the parent component <b>insert</b> its own HTML into the child component's template.</li>
        <br/>
        <li>Think of it like a "placeholder" where outside content will appear.</li>
        <br/>
        <li>Angular uses the special tag <code>&lt;ng-content&gt;</code> for this purpose.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-card',
    template: `
        &lt;div class="card"&gt;
            &lt;h3&gt;Header&lt;/h3&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;   &lt;!-- projected content here --&gt;
        &lt;/div&gt;
    `,
    styles: [`
        .card {
            border: 1px solid #ddd;
            border-radius: .5rem;
            padding: 1rem;
            margin: .5rem 0;
        }
    `],
})
export class CardComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-card&gt;
    &lt;p&gt;This paragraph comes from the parent.&lt;/p&gt;
&lt;/app-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>The paragraph inside <code>&lt;app-card&gt;</code> replaces <code>&lt;ng-content&gt;</code> in the child template.</li>
        <br/>
        <li>This lets you make reusable "container" components that still display custom content.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Projecting multiple content sections</b></li>
    <br/>
    <ul>
        <li>You can have more than one <code>&lt;ng-content&gt;</code> in a component, each with a CSS selector.</li>
        <br/>
        <li>This is called <b>selective content projection</b>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-dialog',
    template: `
        &lt;div class="dialog"&gt;
            &lt;header&gt;
                &lt;ng-content select="[dialog-title]"&gt;&lt;/ng-content&gt;
            &lt;/header&gt;

            &lt;section&gt;
                &lt;ng-content&gt;&lt;/ng-content&gt;   &lt;!-- default slot --&gt;
            &lt;/section&gt;

            &lt;footer&gt;
                &lt;ng-content select="[dialog-actions]"&gt;&lt;/ng-content&gt;
            &lt;/footer&gt;
        &lt;/div&gt;
    `,
})
export class DialogComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-dialog&gt;
    &lt;h2 dialog-title&gt;Delete file?&lt;/h2&gt;

    &lt;p&gt;This action cannot be undone.&lt;/p&gt;

    &lt;div dialog-actions&gt;
        &lt;button&gt;Cancel&lt;/button&gt;
        &lt;button&gt;Confirm&lt;/button&gt;
    &lt;/div&gt;
&lt;/app-dialog&gt;
</code></pre>
    <br/>
    <ul>
        <li>Each <code>&lt;ng-content&gt;</code> selects the elements that match its selector.</li>
        <br/>
        <li>Anything not matching any selector goes into the "default" <code>&lt;ng-content&gt;</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>ngProjectAs</code> for flexibility</b></li>
    <br/>
    <ul>
        <li>Sometimes, an element's tag can't be changed to match the selector — for example, it's a shared component or library element.</li>
        <br/>
        <li>You can use the attribute <code>ngProjectAs</code> to "pretend" it matches a selector.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;app-dialog&gt;
    &lt;app-title ngProjectAs="[dialog-title]"&gt;Edit profile&lt;/app-title&gt;

    &lt;p&gt;Form fields go here...&lt;/p&gt;

    &lt;app-footer ngProjectAs="[dialog-actions]"&gt;
        &lt;button&gt;Close&lt;/button&gt;
    &lt;/app-footer&gt;
&lt;/app-dialog&gt;
</code></pre>
    <br/>
    <ul>
        <li>Even though the elements are <code>&lt;app-title&gt;</code> and <code>&lt;app-footer&gt;</code>, Angular projects them into the right slots.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Projecting multiple components</b></li>
    <br/>
    <ul>
        <li>You can project any combination of text, HTML, or components.</li>
        <br/>
        <li>This makes powerful layouts easy to build.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;app-card&gt;
    &lt;app-user-info [user]="user"&gt;&lt;/app-user-info&gt;
    &lt;app-user-stats [user]="user"&gt;&lt;/app-user-stats&gt;
&lt;/app-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>Both <code>&lt;app-user-info&gt;</code> and <code>&lt;app-user-stats&gt;</code> are rendered inside the card's <code>&lt;ng-content&gt;</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-component-host-elems">Component Host Elements</h3>
<ol>
    <li><b>What is a host element?</b></li>
    <br/>
    <ul>
        <li>Every Angular component is attached to a real DOM element, this is called its <u>host element</u>.</li>
        <br/>
        <li>The host element is the HTML tag where Angular creates your component instance.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-user-card',
    template: `&lt;p&gt;User: {{ name }}&lt;/p&gt;`,
})
export class UserCardComponent {
    name = 'Hwangfucius';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent template --&gt;
&lt;app-user-card&gt;&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, the <code>&lt;app-user-card&gt;</code> tag is the <u>host element</u> for the <code>UserCardComponent</code>.</li>
        <br/>
        <li>Angular attaches your component's rendered template (<code>&lt;p&gt;User: ...&lt;/p&gt;</code>) inside this element.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Host element vs child elements</b></li>
    <br/>
    <ul>
        <li>The host element is the outer shell of your component.</li>
        <br/>
        <li>Everything you write inside the component's template becomes its <u>child elements</u>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;!-- In the browser --&gt;
&lt;app-user-card&gt;                     &lt;!-- 👈 host element --&gt;
    &lt;p&gt;User: Hwangfucius&lt;/p&gt;        &lt;!-- 👈 child content --&gt;
&lt;/app-user-card&gt;
</code></pre>
    <br/>
    <br/>


    <li><b>Styling the host element</b></li>
    <br/>
    <ul>
        <li>You can style your host element directly from inside the component using the <code>:host</code> selector.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
    styles: [`
        :host {
            display: block;
            padding: 1rem;
            border-radius: .5rem;
            background: #f9f9f9;
        }

        :host(.warning) {
            background: #fff3cd;
            color: #856404;
        }

        :host(.error) {
            background: #f8d7da;
            color: #842029;
        }
    `],
})
export class AlertComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-alert class="warning"&gt;Low battery&lt;/app-alert&gt;
&lt;app-alert class="error"&gt;System failure&lt;/app-alert&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>:host</code> selector targets the component's own tag — its host element.</li>
        <br/>
        <li>Each <code>app-alert</code> element gets styled according to its class.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding attributes and classes to the host element</b></li>
    <br/>
    <ul>
        <li>Inside your component class, you can bind properties and attributes directly to the host element using <code>@HostBinding()</code>.</li>
        <br/>
        <li>This allows your code to dynamically update how the host element looks or behaves.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostBinding, Input } from '@angular/core';

@Component({
    selector: 'app-status-indicator',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class StatusIndicatorComponent {
    @Input() status: 'online' | 'offline' = 'offline';

    @HostBinding('class')
    get hostClass(): string {
        return this.status;
    }

    @HostBinding('attr.role') role = 'status';
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-status-indicator status="online"&gt;Connected&lt;/app-status-indicator&gt;
&lt;app-status-indicator status="offline"&gt;Disconnected&lt;/app-status-indicator&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>@HostBinding('class')</code> dynamically sets classes on the host element.</li>
        <li><code>@HostBinding('attr.role')</code> adds an accessibility attribute directly to the host.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Listening to events on the host</b></li>
    <br/>
    <ul>
        <li>You can also listen for host element events (like <code>click</code>) using <code>@HostListener()</code>.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostListener } from '@angular/core';

@Component({
    selector: 'app-clickable',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class ClickableComponent {
    @HostListener('click', ['$event'])
    handleClick(event: MouseEvent) {
        console.log('Host element clicked!', event);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-clickable&gt;Click me!&lt;/app-clickable&gt;
</code></pre>
    <br/>
    <ul>
        <li>Clicking anywhere on the component's host element triggers the listener inside the class.</li>
        <br/>
        <li>This is often used for buttons, custom inputs, or clickable cards.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing the host element in code</b></li>
    <br/>
    <ul>
        <li>Sometimes you may need to interact with the real DOM element that hosts your component.</li>
        <br/>
        <li>You can inject an <code>ElementRef</code> to access it directly.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class BoxComponent {
    constructor(private host: ElementRef&lt;HTMLElement&gt;) {}

    ngAfterViewInit() {
        this.host.nativeElement.style.border = '2px solid blue';
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-box&gt;Styled from code&lt;/app-box&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>ElementRef</code> gives you direct access to the DOM node — useful for low-level manipulations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Difference between host and parent elements</b></li>
    <br/>
    <ul>
        <li>The host element belongs to the parent template, but it's controlled by the component.</li>
        <br/>
        <li>The parent element is the one that wraps the component in the DOM, not the same thing as the host.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div class="wrapper"&gt;         &lt;!-- parent element --&gt;
    &lt;app-card&gt;&lt;/app-card&gt;     &lt;!-- host element --&gt;
&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Inside <code>app-card</code>, <code>:host</code> styles apply to <code>&lt;app-card&gt;</code> — not to the outer <code>&lt;div class="wrapper"&gt;</code>.</li>
        <br/>
        <li>If you want to react to a parent's class (e.g. a theme), use <code>:host-context(.dark-mode)</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-component-lifecycle">Component Lifecycle</h3>
<ol>
    <li><b>What is a component lifecycle?</b></li>
    <br/>
    <ul>
        <li>Every Angular component goes through a <b>series of steps</b> from creation to destruction.</li>
        <br/>
        <li>Angular lets you run your own code at specific moments, like when the component is created, updated, or removed.</li>
        <br/>
        <li>These moments are called <u>lifecycle hooks</u>.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
    selector: 'app-timer',
    template: `&lt;p&gt;Seconds: {{ seconds }}&lt;/p&gt;`,
})
export class TimerComponent implements OnInit, OnDestroy {
    seconds = 0;
    private intervalId: any;

    ngOnInit() {
        console.log('Timer created');
        this.intervalId = setInterval(() =&gt; this.seconds++, 1000);
    }

    ngOnDestroy() {
        console.log('Timer destroyed');
        clearInterval(this.intervalId);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- When <app-timer> is created, ngOnInit runs. When it's removed, ngOnDestroy runs. --&gt;
&lt;app-timer *ngIf="showTimer"&gt;&lt;/app-timer&gt;
&lt;button (click)="showTimer = !showTimer"&gt;Toggle Timer&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>ngOnInit()</code> runs once when the component is first displayed.</li>
        <br/>
        <li><code>ngOnDestroy()</code> runs right before the component is removed from the DOM.</li>
        <br/>
        <li>Perfect for starting or cleaning up resources like timers, event listeners, or subscriptions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The full lifecycle order</b></li>
    <br/>
    <ul>
        <li>Angular calls hooks in this order when a component is created, updated, and destroyed:</li>
    </ul>
<pre><code class="language-text">1. ngOnChanges()
2. ngOnInit()
3. ngDoCheck()
4. ngAfterContentInit()
5. ngAfterContentChecked()
6. ngAfterViewInit()
7. ngAfterViewChecked()
8. ngOnDestroy()
</code></pre>
    <br/>
    <ul>
        <li>You don't have to implement all of them (just the ones you need).</li>
        <br/>
        <li>Each one has a clear purpose in the component's lifecycle.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngOnChanges()</b></li>
    <br/>
    <ul>
        <li>Runs whenever an <code>@Input()</code> property changes.</li>
        <br/>
        <li>It also runs once right before <code>ngOnInit()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-counter',
    template: `&lt;p&gt;Count: {{ count }}&lt;/p&gt;`,
})
export class CounterComponent implements OnChanges {
    @Input() count = 0;

    ngOnChanges(changes: SimpleChanges) {
        console.log('Changes:', changes);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-counter [count]="num"&gt;&lt;/app-counter&gt;
&lt;button (click)="num++"&gt;Increment&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>SimpleChanges</code> tells you what changed, its previous value, and new value.</li>
        <br/>
        <li>Useful when reacting to updated inputs from a parent component.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngOnInit()</b></li>
    <br/>
    <ul>
        <li>Called once, after Angular initializes all <code>@Input()</code> values.</li>
        <br/>
        <li>Use it to set up data, start fetching from APIs, or initialize variables.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngOnInit() {
    console.log('Component ready to use!');
    this.loadData();
}
</code></pre>
    <br/>
    <ul>
        <li>Think of it as your component's "startup" moment.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngDoCheck()</b></li>
    <br/>
    <ul>
        <li>Called during every change detection cycle.</li>
        <br/>
        <li>Most apps don't need it, because Angular's normal data binding handles most updates automatically.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngDoCheck() {
    console.log('Change detection running...');
}
</code></pre>
    <br/>
    <br/>


    <li><b>ngAfterContentInit() and ngAfterContentChecked()</b></li>
    <br/>
    <ul>
        <li>These run when projected content (via <code>&lt;ng-content&gt;</code>) is first inserted, and after every subsequent check.</li>
        <br/>
        <li>Use them when your component needs to interact with projected child content.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngAfterContentInit() {
    console.log('Projected content has been initialized.');
}

ngAfterContentChecked() {
    console.log('Projected content checked again.');
}
</code></pre>
    <br/>
    <ul>
        <li>"Content" means anything that was passed between your component tags in the parent template.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngAfterViewInit() and ngAfterViewChecked()</b></li>
    <br/>
    <ul>
        <li>These run when the component's own view (its template) is initialized and rechecked.</li>
        <br/>
        <li>Good for code that needs to access the rendered DOM using <code>@ViewChild()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@ViewChild('box') box!: ElementRef;

ngAfterViewInit() {
    console.log('Template view ready:', this.box.nativeElement);
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;div #box&gt;Hello box&lt;/div&gt;
</code></pre>
    <br/>
    <ul>
        <li>Don't try to access DOM elements in <code>ngOnInit()</code> — they're not ready yet. Use <code>ngAfterViewInit()</code> instead.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ngOnDestroy()</b></li>
    <br/>
    <ul>
        <li>Called right before Angular removes the component from the DOM.</li>
        <br/>
        <li>Use it to clean up resources (unsubscribe from Observables, clear timers, detach listeners, etc.).</li>
    </ul>
<pre><code class="language-ts line-numbers">ngOnDestroy() {
    console.log('Cleaning up...');
    this.subscription.unsubscribe();
}
</code></pre>
    <br/>
    <ul>
        <li>Forgetting cleanup can cause memory leaks, so <code>ngOnDestroy()</code> is important.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Visual summary</b></li>
<pre><code class="language-text">
 ┌──────────────────────────────────────┐
 │ Component Created                    │
 │  ├─ ngOnChanges()                    │
 │  ├─ ngOnInit()                       │
 │  ├─ ngDoCheck()                      │
 │  ├─ ngAfterContentInit()             │
 │  ├─ ngAfterContentChecked()          │
 │  ├─ ngAfterViewInit()                │
 │  └─ ngAfterViewChecked()             │
 │                                      │
 │ Component Updated                    │
 │  ├─ ngDoCheck()                      │
 │  ├─ ngAfterContentChecked()          │
 │  └─ ngAfterViewChecked()             │
 │                                      │
 │ Component Destroyed                  │
 │  └─ ngOnDestroy()                    │
 └──────────────────────────────────────┘
</code></pre>
    <br/>
    <ul>
        <li>Angular calls these in the same predictable order every time.</li>
        <br/>
        <li>Use them to control setup, updates, and cleanup in your component's life.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-referencing-component-children-with-queries">Referencing Component Children with Queries</h3>
<ol>
    <li><b>What are queries?</b></li>
    <br/>
    <ul>
        <li>Sometimes, you need direct access to elements or components inside your template — for example, to read a property, call a method, or focus an input.</li>
        <br/>
        <li>Angular provides <u>queries</u> for this purpose —
            A query "asks" Angular for a reference to a matching element or component in your view.</li>
        <br/>
        <li>The most common query decorators are:</li>
        <ul>
            <li><code>@ViewChild()</code> — finds one element or component inside the component's own template.</li>
            <li><code>@ViewChildren()</code> — finds multiple matching elements or components in the view.</li>
            <li><code>@ContentChild()</code> and <code>@ContentChildren()</code> — find projected content (passed in via <code>&lt;ng-content&gt;</code>).</li>
        </ul>
    </ul>
    <br/>
    <br/>


    <li><b>@ViewChild() — getting a single child element</b></li>
    <br/>
    <ul>
        <li>Use <code>@ViewChild()</code> to get a reference to one element or component inside your template.</li>
        <br/>
        <li>Example: focusing an input after the component appears.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
    selector: 'app-focus-input',
    template: `&lt;input #userInput type="text" placeholder="Type something..." /&gt;`,
})
export class FocusInputComponent implements AfterViewInit {
    @ViewChild('userInput') inputElement!: ElementRef&lt;HTMLInputElement&gt;;

    ngAfterViewInit() {
        this.inputElement.nativeElement.focus();  // focus when ready
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>#userInput</code> in the template defines a <u>template reference variable</u>.</li>
        <li><code>@ViewChild('userInput')</code> finds that element after the view is created.</li>
        <li>Always access it in <code>ngAfterViewInit()</code>, not <code>ngOnInit()</code>, because the view isn't ready before that.</li>
    </ul>
    <br/>
    <br/>


    <li><b>@ViewChild() — getting a child component instance</b></li>
    <br/>
    <ul>
        <li>You can also use <code>@ViewChild()</code> to access another component that is part of your template.</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-child',
    template: `&lt;p&gt;Child works!&lt;/p&gt;`,
})
export class ChildComponent {
    sayHello() {
        console.log('Hello from Child!');
    }
}

@Component({
    selector: 'app-parent',
    template: `
        &lt;app-child&gt;&lt;/app-child&gt;
        &lt;button (click)="callChild()"&gt;Call Child&lt;/button&gt;
    `,
})
export class ParentComponent {
    @ViewChild(ChildComponent) child!: ChildComponent;

    callChild() {
        this.child.sayHello();
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>@ViewChild(ChildComponent)</code> looks for the first <code>&lt;app-child&gt;</code> element in the view.</li>
        <li>You can then access its public properties and methods directly.</li>
        <li>Angular keeps this reference updated automatically whenever the view changes.</li>
    </ul>
    <br/>
    <br/>


    <li><b>@ViewChildren() — getting multiple elements or components</b></li>
    <br/>
    <ul>
        <li>Use <code>@ViewChildren()</code> when you need to handle several matching items — for example, a list of child components.</li>
        <br/>
        <li>Angular returns a <code>QueryList</code> that you can loop over.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-item',
    template: `&lt;li&gt;Item&lt;/li&gt;`,
})
export class ItemComponent {}

@Component({
    selector: 'app-list',
    template: `
        &lt;ul&gt;
            &lt;app-item *ngFor="let i of [1,2,3]"&gt;&lt;/app-item&gt;
        &lt;/ul&gt;
        &lt;button (click)="logItems()"&gt;Log items&lt;/button&gt;
    `,
})
export class ListComponent implements AfterViewInit {
    @ViewChildren(ItemComponent) items!: QueryList&lt;ItemComponent&gt;;

    ngAfterViewInit() {
        console.log('Found items:', this.items.length);
    }

    logItems() {
        this.items.forEach((item, index) =&gt; console.log('Item', index + 1, item));
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>QueryList</code> acts like a live array — it updates automatically if the view changes (for example, if <code>*ngIf</code> adds or removes elements).</li>
    </ul>
    <br/>
    <br/>


    <li><b>@ContentChild() and @ContentChildren() — projected content</b></li>
    <br/>
    <ul>
        <li>Use these for elements or components that are <b>projected into</b> your component through <code>&lt;ng-content&gt;</code>.</li>
        <br/>
        <li>This is for content that the <b>parent passes in</b>, not what the component itself defines.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-panel',
    template: `
        &lt;div class="panel"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
    `,
})
export class PanelComponent implements AfterContentInit {
    @ContentChild('projected') content!: ElementRef;

    ngAfterContentInit() {
        console.log('Projected element:', this.content.nativeElement);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-panel&gt;
    &lt;p #projected&gt;Hello projected world!&lt;/p&gt;
&lt;/app-panel&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>@ContentChild()</code> finds a matching reference inside the projected content (the part between <code>&lt;app-panel&gt;...&lt;/app-panel&gt;</code>).</li>
        <li>Access it in <code>ngAfterContentInit()</code>, not <code>ngOnInit()</code>, since the content is only inserted after initialization.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to use each hook</b></li>
    <br/>
    <ul>
        <li><code>@ViewChild</code> / <code>@ViewChildren</code> → for elements or components declared inside your own template. Access them in <code>ngAfterViewInit()</code>.</li>
        <br/>
        <li><code>@ContentChild</code> / <code>@ContentChildren</code> → for content projected from a parent. Access them in <code>ngAfterContentInit()</code>.</li>
    </ul>
<pre><code class="language-text">
ViewChild       → single element in template
ViewChildren    → multiple elements in template
ContentChild    → single projected element (via &lt;ng-content&gt;)
ContentChildren → multiple projected elements
</code></pre>
    <br/>
    <br/>


    <li><b>Practical use cases</b></li>
    <br/>
    <ul>
        <li>Auto-focusing or measuring DOM elements after view init.</li>
        <li>Calling methods on child components (e.g., <code>reset()</code>, <code>validate()</code>).</li>
        <li>Collecting or managing groups of dynamic child components.</li>
        <li>Reacting to projected content, like tabs, cards, or custom slots.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-dom-apis-in-ng">Using DOM APIs in Angular</h3>
<ol>
    <li><b>Why use DOM APIs?</b></li>
    <br/>
    <ul>
        <li>Sometimes you need to interact directly with the browser's Document Object Model (DOM) — for example, to focus an input, measure an element's size, scroll smoothly, or change a style dynamically.</li>
        <br/>
        <li>Angular normally manages the DOM for you through templates and bindings, but you can safely access it when necessary.</li>
        <br/>
        <li>Direct DOM access should be done carefully to keep your app safe and compatible with server-side rendering (Angular Universal).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing elements with ElementRef</b></li>
    <br/>
    <ul>
        <li><code>ElementRef</code> is the simplest way to get a reference to a DOM element.</li>
        <br/>
        <li>It wraps the real DOM node inside a <code>nativeElement</code> property.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;div #box class="blue-box"&gt;Hello Box&lt;/div&gt;`,
    styles: [`.blue-box { width: 100px; height: 100px; background: lightblue; }`]
})
export class BoxComponent implements AfterViewInit {
    @ViewChild('box') box!: ElementRef&lt;HTMLDivElement&gt;;

    ngAfterViewInit() {
        console.log(this.box.nativeElement); // &lt;div&gt; element itself
        this.box.nativeElement.style.border = '2px solid navy';
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>nativeElement</code> gives direct access to the DOM node.</li>
        <li>You can read or set properties like <code>textContent</code>, <code>classList</code>, <code>style</code>, etc.</li>
        <li>Always access it in <code>ngAfterViewInit()</code> so the view is ready.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Modifying styles and classes</b></li>
    <br/>
    <ul>
        <li>Angular provides the <code>Renderer2</code> service for safer DOM manipulation.</li>
        <br/>
        <li><code>Renderer2</code> works even when your app runs outside the browser (like in a server environment).</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ElementRef, Renderer2, ViewChild, AfterViewInit } from '@angular/core';

@Component({
    selector: 'app-colored-box',
    template: `&lt;div #box&gt;Click me!&lt;/div&gt;`
})
export class ColoredBoxComponent implements AfterViewInit {
    @ViewChild('box') box!: ElementRef;
    constructor(private renderer: Renderer2) {}

    ngAfterViewInit() {
        this.renderer.setStyle(this.box.nativeElement, 'background', 'pink');
        this.renderer.setStyle(this.box.nativeElement, 'padding', '10px');
        this.renderer.addClass(this.box.nativeElement, 'rounded');
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>setStyle()</code>, <code>addClass()</code>, <code>removeClass()</code>, and <code>setAttribute()</code> are cross-platform safe.</li>
        <li>This avoids direct DOM access and works well with Angular Universal.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Listening to DOM events</b></li>
    <br/>
    <ul>
        <li>You can use <code>Renderer2.listen()</code> to attach an event listener directly to an element.</li>
        <br/>
        <li>This gives more control than template bindings when you need dynamic event management.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngAfterViewInit() {
    this.renderer.listen(this.box.nativeElement, 'click', () =&gt; {
        alert('Box clicked!');
    });
}
</code></pre>
    <br/>
    <ul>
        <li><code>listen()</code> automatically cleans up when the element is destroyed — you don't need to remove listeners manually.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Reading sizes and positions</b></li>
    <br/>
    <ul>
        <li>Use normal DOM properties like <code>offsetWidth</code>, <code>offsetHeight</code>, or <code>getBoundingClientRect()</code> to measure elements.</li>
    </ul>
<pre><code class="language-ts line-numbers">ngAfterViewInit() {
    const rect = this.box.nativeElement.getBoundingClientRect();
    console.log('Width:', rect.width, 'Height:', rect.height);
}
</code></pre>
    <br/>
    <ul>
        <li>This is useful for animations, positioning, or responsive logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Scrolling and focusing</b></li>
    <br/>
    <ul>
        <li>Many DOM elements have built-in methods like <code>scrollIntoView()</code> and <code>focus()</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">scrollToBox() {
    this.box.nativeElement.scrollIntoView({ behavior: 'smooth' });
}
</code></pre>
    <br/>
    <ul>
        <li>You can call these safely once the view exists.</li>
        <li>Combine with buttons or triggers to make smooth navigation experiences.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using @HostListener for simple DOM events</b></li>
    <br/>
    <ul>
        <li>Instead of manually using <code>Renderer2.listen()</code>, Angular offers the <code>@HostListener()</code> decorator to respond to DOM events directly on your component's host element.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostListener } from '@angular/core';

@Component({
    selector: 'app-click-alert',
    template: `&lt;div&gt;Click anywhere on me!&lt;/div&gt;`,
})
export class ClickAlertComponent {
    @HostListener('click')
    handleClick() {
        console.log('Host element clicked!');
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>@HostListener()</code> automatically registers and cleans up event handlers.</li>
        <li>It's the easiest way to respond to host events without touching <code>Renderer2</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Safety notes</b></li>
    <br/>
    <ul>
        <li>Avoid direct DOM manipulation when possible — it can bypass Angular's rendering and cause inconsistencies.</li>
        <br/>
        <li>Use <code>Renderer2</code> or <code>@HostListener</code> for most operations — they work in web workers and server rendering.</li>
        <br/>
        <li>If you must access <code>window</code> or <code>document</code>, do it only inside browser-safe conditions (e.g., check <code>isPlatformBrowser()</code>).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-inheritance">Inheritance in Angular</h3>
<ol>
    <li><b>Using inheritance between Angular components</b></li>
    <br/>
    <ul>
        <li>Suppose you have multiple components that display data and log user actions — you can extract this logic into a base class.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component } from '@angular/core';

export class BaseLogger {
    log(message: string) {
        console.log(`[LOG]: ${message}`);
    }
}

@Component({
    selector: 'app-user',
    template: `&lt;p&gt;User Component&lt;/p&gt;`,
})
export class UserComponent extends BaseLogger {
    constructor() {
        super();
        this.log('User component initialized');
    }
}

@Component({
    selector: 'app-admin',
    template: `&lt;p&gt;Admin Component&lt;/p&gt;`,
})
export class AdminComponent extends BaseLogger {
    constructor() {
        super();
        this.log('Admin component initialized');
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Both components now reuse <code>log()</code> from <code>BaseLogger</code>.</li>
        <li>You can call <code>super()</code> to use methods or constructor logic from the parent.</li>
        <li>This is a clean way to share reusable class-level logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extending a base component with lifecycle hooks</b></li>
    <br/>
    <ul>
        <li>You can also move common lifecycle logic to a base class — for example, cleanup code or initial setup.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { OnInit, OnDestroy } from '@angular/core';

export abstract class BaseComponent implements OnInit, OnDestroy {
    ngOnInit() {
        console.log('Component initialized.');
    }

    ngOnDestroy() {
        console.log('Component destroyed.');
    }
}

@Component({
    selector: 'app-profile',
    template: `&lt;p&gt;Profile&lt;/p&gt;`,
})
export class ProfileComponent extends BaseComponent {
    ngOnInit() {
        super.ngOnInit(); // Call base logic
        console.log('Profile-specific init.');
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The base class handles shared setup/cleanup, and child components can extend it with their own behavior.</li>
        <li>Use <code>super.ngOnInit()</code> to keep the parent's logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Sharing injected services across subclasses</b></li>
    <br/>
    <ul>
        <li>Services can also be shared using inheritance.</li>
        <br/>
        <li>The parent class can inject dependencies, and the child automatically inherits them.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

export class BaseDataComponent {
    constructor(protected http: HttpClient) {}

    fetchData(url: string) {
        return this.http.get(url);
    }
}

@Component({
    selector: 'app-users',
    template: `&lt;button (click)="load()"&gt;Load Users&lt;/button&gt;`,
})
export class UsersComponent extends BaseDataComponent {
    load() {
        this.fetchData('/api/users').subscribe(data =&gt; console.log(data));
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>UsersComponent</code> inherits both the injected <code>HttpClient</code> and the <code>fetchData()</code> method.</li>
        <li>This pattern is great for components that share similar service interactions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inheritance for directives</b></li>
    <br/>
    <ul>
        <li>You can also extend one directive from another to reuse behavior.</li>
        <br/>
        <li>Example: create a base directive that listens for hover events, then extend it to style specific elements.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Directive, HostListener, ElementRef } from '@angular/core';

@Directive()
export class HoverBase {
    constructor(protected el: ElementRef) {}

    @HostListener('mouseenter')
    onEnter() {
        this.el.nativeElement.style.opacity = '0.8';
    }

    @HostListener('mouseleave')
    onLeave() {
        this.el.nativeElement.style.opacity = '1';
    }
}

@Directive({
    selector: '[highlightOnHover]'
})
export class HighlightDirective extends HoverBase {
    @HostListener('mouseenter')
    override onEnter() {
        super.onEnter();
        this.el.nativeElement.style.background = 'lightyellow';
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>HighlightDirective</code> extends <code>HoverBase</code>, keeping its hover logic but adding a highlight effect.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When not to use inheritance</b></li>
    <br/>
    <ul>
        <li>Inheritance is great for sharing core logic, but not for everything.</li>
        <br/>
        <li>Prefer <b>composition</b> (injecting a service) if:
            <ul>
                <li>Different components need similar but not identical features.</li>
                <li>You want to avoid deep inheritance chains.</li>
                <li>The shared behavior doesn't rely on component lifecycles.</li>
            </ul>
        </li>
        <br/>
        <li>For example, instead of a <code>BaseLogger</code>, you could inject a <code>LoggerService</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-programmatically-rendering-components">Programmatically Rendering Components</h3>
<ol>
    <li><b>What does "programmatically rendering" mean?</b></li>
    <br/>
    <ul>
        <li>Normally, you add components to your template using HTML tags, like <code>&lt;app-card&gt;&lt;/app-card&gt;</code>.</li>
        <br/>
        <li>But sometimes, you want to create components <b>with code</b> — for example:
            <ul>
                <li>Show a popup or dialog dynamically.</li>
                <li>Render components from a list of types.</li>
                <li>Build a dashboard where widgets can appear or disappear.</li>
            </ul>
        </li>
        <br/>
        <li>This is called <b>programmatic component rendering</b>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic idea</b></li>
    <br/>
    <ul>
        <li>To insert a component manually, Angular gives you a <code>ViewContainerRef</code>.</li>
        <br/>
        <li>This reference represents a "place" in the DOM where new views (templates or components) can be created.</li>
        <br/>
        <li>Then, you use <code>createComponent()</code> to insert your component at runtime.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Setup: create a target placeholder</b></li>
    <br/>
    <ul>
        <li>You first mark where in the template you want to insert components using <code>#container</code>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div&gt;Dynamic Area:&lt;/div&gt;
&lt;ng-container #container&gt;&lt;/ng-container&gt;
&lt;button (click)="addCard()"&gt;Add Card&lt;/button&gt;
</code></pre>
    <br/>
    <ul>
        <li>The <code>&lt;ng-container&gt;</code> is invisible in the DOM — it just holds a view.</li>
        <li>The <code>#container</code> gives you a reference in TypeScript.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Getting the container in TypeScript</b></li>
    <br/>
    <ul>
        <li>Use <code>@ViewChild()</code> with <code>ViewContainerRef</code> to access the container.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ViewChild, ViewContainerRef } from '@angular/core';
import { CardComponent } from './card.component';

@Component({
    selector: 'app-dynamic-host',
    templateUrl: './dynamic-host.component.html',
})
export class DynamicHostComponent {
    @ViewChild('container', { read: ViewContainerRef }) container!: ViewContainerRef;

    addCard() {
        this.container.createComponent(CardComponent);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Every time you click the button, Angular will create a new <code>CardComponent</code> inside the container.</li>
        <li>That's all it takes to render a component programmatically!</li>
    </ul>
    <br/>
    <br/>


    <li><b>Passing data to the created component</b></li>
    <br/>
    <ul>
        <li>After you create a component, you can access its instance and set its inputs.</li>
    </ul>
<pre><code class="language-ts line-numbers">addCard() {
    const cardRef = this.container.createComponent(CardComponent);
    cardRef.instance.title = 'Dynamic card created at ' + new Date().toLocaleTimeString();
}
</code></pre>
    <br/>
    <ul>
        <li>The returned object (<code>ComponentRef</code>) has an <code>instance</code> property — that's the component itself.</li>
        <li>You can set its public fields or call methods directly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Clearing or removing components</b></li>
    <br/>
    <ul>
        <li>To remove all dynamically created components, just clear the container:</li>
    </ul>
<pre><code class="language-ts line-numbers">clearAll() {
    this.container.clear();
}
</code></pre>
    <br/>
    <ul>
        <li>To remove one specific component, destroy it manually:</li>
    </ul>
<pre><code class="language-ts line-numbers">const ref = this.container.createComponent(CardComponent);
// later...
ref.destroy();
</code></pre>
    <br/>
    <ul>
        <li>When destroyed, Angular also removes its DOM and unsubscribes from any observables automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: a dynamic alert system</b></li>
    <br/>
    <ul>
        <li>Here's a small, complete example of dynamically creating alert components:</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `&lt;div class="alert"&gt;{{ message }}&lt;/div&gt;`,
    styles: [`.alert { background: #ffe4b5; padding: .5rem; margin: .25rem 0; }`],
    standalone: true,
})
export class AlertComponent {
    message = '';
}

@Component({
    selector: 'app-alert-demo',
    template: `
        &lt;button (click)="showAlert('Something happened!')"&gt;Show Alert&lt;/button&gt;
        &lt;ng-container #alertHost&gt;&lt;/ng-container&gt;
    `,
})
export class AlertDemoComponent {
    @ViewChild('alertHost', { read: ViewContainerRef }) host!: ViewContainerRef;

    showAlert(text: string) {
        const ref = this.host.createComponent(AlertComponent);
        ref.instance.message = text;
        setTimeout(() =&gt; ref.destroy(), 3000); // auto remove after 3s
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Each alert appears when the button is clicked, and disappears automatically after 3 seconds.</li>
        <li>This pattern is often used in real applications for toast notifications, modals, or temporary messages.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Advanced: creating from a component type variable</b></li>
    <br/>
    <ul>
        <li>You can store component types in variables and render them dynamically at runtime.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Type } from '@angular/core';

const components: Type&lt;any&gt;[] = [AlertComponent, CardComponent, WidgetComponent];

addRandom() {
    const randomType = components[Math.floor(Math.random() * components.length)];
    this.container.createComponent(randomType);
}
</code></pre>
    <br/>
    <ul>
        <li>This makes it easy to load different components conditionally — for example, from configuration or user choices.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Lifecycle and cleanup</b></li>
    <br/>
    <ul>
        <li>Dynamically created components still run all normal Angular lifecycles (<code>ngOnInit</code>, <code>ngOnDestroy</code>, etc.).</li>
        <br/>
        <li>When you clear or destroy them, Angular cleans up automatically — no need to remove DOM elements manually.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-adv-component-config">Advanced component configuration</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>When you write a component, the <code>@Component()</code> decorator can do much more than just define a template and selector.</li>
        <br/>
        <li>Angular components can be customized through many options that control:
            <ul>
                <li>How they are compiled and rendered,</li>
                <li>How they detect data changes,</li>
                <li>How styles are applied,</li>
                <li>And what other components, directives, or pipes they can use.</li>
            </ul>
        </li>
        <br/>
        <li>These advanced configurations give you performance and architectural control.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Standalone components</b></li>
    <br/>
    <ul>
        <li>Starting from Angular 14, you can create components that don't belong to any <code>@NgModule</code>.</li>
        <br/>
        <li>You simply mark them with <code>standalone: true</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-hello',
    standalone: true,
    template: `&lt;p&gt;Hello from a standalone component!&lt;/p&gt;`,
})
export class HelloComponent {}
</code></pre>
    <br/>
    <ul>
        <li>Standalone components can directly import other standalone components, directives, and pipes.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-parent',
    standalone: true,
    imports: [HelloComponent],
    template: `&lt;app-hello&gt;&lt;/app-hello&gt;`,
})
export class ParentComponent {}
</code></pre>
    <br/>
    <br/>


    <li><b>Change detection strategies</b></li>
    <br/>
    <ul>
        <li>Angular automatically updates your template when data changes.
            But you can control how often it checks for changes using <code>changeDetection</code>.
        </li>
        <br/>
        <li>There are two modes:</li>
        <ul>
            <li><code>ChangeDetectionStrategy.Default</code> — Angular checks all components below whenever something might have changed.</li>
            <li><code>ChangeDetectionStrategy.OnPush</code> &nbsp; — Angular only re-checks when <u>input references change</u> or <u>an event happens</u> inside the component.</li>
        </ul>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ChangeDetectionStrategy } from '@angular/core';

@Component({
    selector: 'app-optimized',
    template: `&lt;p&gt;Optimized Component&lt;/p&gt;`,
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OptimizedComponent {}
</code></pre>
    <br/>
    <ul>
        <li>Use <code>OnPush</code> for better performance, especially in large apps where data doesn't change often.</li>
        <li>Angular then skips unnecessary checks for unchanged components.</li>
    </ul>
    <br/>
    <br/>


    <li><b>View encapsulation modes</b></li>
    <br/>
    <ul>
        <li>By default, Angular <b>encapsulates</b> component styles so they only apply to that component's template.</li>
        <br/>
        <li>You can control this with <code>encapsulation</code>:</li>
        <ul>
            <li><code>ViewEncapsulation.Emulated</code> — (default) Angular emulates Shadow DOM by adding unique attributes to selectors.</li>
            <li><code>ViewEncapsulation.ShadowDom</code> — uses the browser's real Shadow DOM.</li>
            <li><code>ViewEncapsulation.None</code> — no encapsulation, styles are global.</li>
        </ul>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ViewEncapsulation } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;div&gt;I'm a box&lt;/div&gt;`,
    styles: [`div { color: red; }`],
    encapsulation: ViewEncapsulation.None,
})
export class BoxComponent {}
</code></pre>
    <br/>
    <ul>
        <li>Here, the <code>div { color: red; }</code> style will affect every <code>&lt;div&gt;</code> in your app — not just inside this component.</li>
        <li>Use <code>None</code> for global styles or theming, and <code>ShadowDom</code> for true style isolation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using providers inside a component</b></li>
    <br/>
    <ul>
        <li>You can declare <u>providers</u> directly in a component.</li>
        <br/>
        <li>This is helpful when you want a new service instance for each component.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component } from '@angular/core';
import { CounterService } from './counter.service';

@Component({
    selector: 'app-counter',
    template: `
        &lt;p&gt;Count: {{ service.count }}&lt;/p&gt;
        &lt;button (click)="service.increment()"&gt;+&lt;/button&gt;
    `,
    providers: [CounterService]
})
export class CounterComponent {
    constructor(public service: CounterService) {}
}
</code></pre>
    <br/>
    <ul>
        <li>Each <code>&lt;app-counter&gt;</code> gets its own instance of <code>CounterService</code>.</li>
        <li>This is called <u>component-level dependency injection</u>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Controlling change detection manually</b></li>
    <br/>
    <ul>
        <li>Sometimes you want to run change detection yourself — for example, after an external API updates data asynchronously.</li>
        <br/>
        <li>You can inject <code>ChangeDetectorRef</code> and call its methods:</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, ChangeDetectorRef } from '@angular/core';

@Component({
    selector: 'app-manual-refresh',
    template: `
        &lt;p&gt;Last updated: {{ time }}&lt;/p&gt;
        &lt;button (click)="refresh()"&gt;Refresh&lt;/button&gt;
    `
})
export class ManualRefreshComponent {
    time = new Date().toLocaleTimeString();

    constructor(private cdr: ChangeDetectorRef) {}

    refresh() {
        this.time = new Date().toLocaleTimeString();
        this.cdr.detectChanges();  // manually trigger view update
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Manual control is rarely needed, but useful when integrating with external libraries that don't trigger Angular's normal checks.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Host bindings and host listeners</b></li>
    <br/>
    <ul>
        <li>These decorators let you bind properties or events directly to the component's host element.</li>
        <br/>
        <li>This is considered an advanced configuration because it changes how the component behaves in the DOM.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostBinding, HostListener } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
})
export class BoxComponent {
    @HostBinding('class.active') isActive = false;

    @HostListener('click')
    toggle() {
        this.isActive = !this.isActive;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Clicking the box toggles the <code>active</code> class on its host element.</li>
        <li>This lets the component manage its appearance or behavior without external CSS selectors.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Importing dependencies directly</b></li>
    <br/>
    <ul>
        <li>In standalone components, you can import everything the component needs — directives, pipes, or even modules — directly through the <code>imports</code> field.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { CommonModule } from '@angular/common';

@Component({
    selector: 'app-list',
    standalone: true,
    imports: [CommonModule],
    template: `
        &lt;ul&gt;
            &lt;li *ngFor="let item of items"&gt;{{ item }}&lt;/li&gt;
        &lt;/ul&gt;
    `,
})
export class ListComponent {
    items = ['A', 'B', 'C'];
}
</code></pre>
    <br/>
    <ul>
        <li>Standalone imports make each component self-contained and easy to reuse anywhere in your project.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-binding-dynamic-text-props-attrs">Binding dynamic text, properties, and attributes</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Angular templates let you connect your component's data to the HTML view — this is called <b>data binding</b>.</li>
        <br/>
        <li>Instead of hard-coding text or attributes, you can bind them dynamically to variables, expressions, or functions.</li>
        <br/>
        <li>Angular updates the DOM automatically when the bound data changes, keeping your view and logic in sync.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Interpolating text ({{ }})</b></li>
    <br/>
    <ul>
        <li>The simplest type of binding is text interpolation using double curly braces <code>{{ }}</code>.</li>
        <br/>
        <li>It inserts the value of a component property or expression directly into the HTML text.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-greeter',
    template: `
        &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
        &lt;p&gt;Today is {{ date | date:'fullDate' }}.&lt;/p&gt;
    `,
})
export class GreeterComponent {
    name = 'Hwangfucius';
    date = new Date();
}
</code></pre>
    <br/>
    <ul>
        <li>Angular automatically escapes text to prevent security issues (no HTML injection).</li>
        <li>You can also use pipes (like <code>date</code>) inside interpolation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding to DOM properties</b></li>
    <br/>
    <ul>
        <li>HTML elements have many DOM properties like <code>disabled</code>, <code>checked</code>, <code>value</code>, and <code>hidden</code>.</li>
        <br/>
        <li>You can bind them dynamically using square brackets: <code>[property]="expression"</code>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button [disabled]="isLoading"&gt;Save&lt;/button&gt;
&lt;input [value]="username" /&gt;
&lt;img [src]="imageUrl" [alt]="description" /&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class ExampleComponent {
    isLoading = true;
    username = 'Alice';
    imageUrl = '/assets/avatar.png';
    description = 'Profile picture';
}
</code></pre>
    <br/>
    <ul>
        <li>When <code>isLoading</code> changes to <code>false</code>, Angular automatically re-enables the button.</li>
        <li>This is a one-way binding from your component → view.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding to attributes</b></li>
    <br/>
    <ul>
        <li>Not all attributes have matching DOM properties (for example, <code>aria-*</code> and <code>data-*</code> attributes).</li>
        <br/>
        <li>To bind those, use the <code>attr.</code> prefix:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button [attr.aria-label]="label"&gt;Click&lt;/button&gt;
&lt;div [attr.data-id]="uniqueId"&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class AttrExampleComponent {
    label = 'Action button';
    uniqueId = 12345;
}
</code></pre>
    <br/>
    <ul>
        <li>Angular creates or removes the attribute based on the value:
            <ul>
                <li>If the bound value is <code>null</code> or <code>undefined</code>, the attribute is removed.</li>
                <li>If it has a value, it is added or updated.</li>
            </ul>
        </li>
        <br/>
        <li>Use this for accessibility (ARIA), analytics (data-attributes), or SVG properties.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Class and style bindings</b></li>
    <br/>
    <ul>
        <li>You can dynamically change CSS classes or styles with <code>[class]</code> and <code>[style]</code>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div [class.active]="isActive"&gt;Active box&lt;/div&gt;
&lt;div [style.background-color]="color"&gt;Colored box&lt;/div&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class StyleExampleComponent {
    isActive = true;
    color = 'lightgreen';
}
</code></pre>
    <br/>
    <ul>
        <li>Angular adds or removes the class automatically depending on the boolean expression.</li>
        <li>You can bind multiple styles or classes using objects:
<pre><code class="language-html line-numbers">&lt;div [ngClass]="{ active: isActive, highlight: hasFocus }"&gt;&lt;/div&gt;
&lt;div [ngStyle]="{ 'font-size': size + 'px', color: textColor }"&gt;&lt;/div&gt;
</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Event binding + property binding = interactivity</b></li>
    <br/>
    <ul>
        <li>To make bindings interactive, combine property binding and event binding.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input [value]="username" (input)="username = $event.target.value" /&gt;
&lt;p&gt;Current username: {{ username }}&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class TwoWayComponent {
    username = 'Guest';
}
</code></pre>
    <br/>
    <ul>
        <li>This is manual one-way binding plus an event handler.</li>
        <li>Angular's <code>[(ngModel)]</code> is just a shorthand for this two-way pattern.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding HTML safely</b></li>
    <br/>
    <ul>
        <li>By default, Angular escapes all interpolated text, so tags like <code>&lt;script&gt;</code> or <code>&lt;b&gt;</code> are shown as text — not executed.</li>
        <br/>
        <li>If you intentionally want to display HTML, bind to <code>[innerHTML]</code> — but do it carefully.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div [innerHTML]="htmlSnippet"&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class HtmlExampleComponent {
    htmlSnippet = '&lt;b&gt;Bold text&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt;';
}
</code></pre>
    <br/>
    <ul>
        <li>Angular sanitizes unsafe HTML automatically, but for complete trust (e.g. known safe content), you can use <code>DomSanitizer</code>.</li>
        <li>Be careful — don't bind user-provided HTML directly without sanitization!</li>
    </ul>
    <br/>
    <br/>


    <li><b>Binding SVG or custom attributes</b></li>
    <br/>
    <ul>
        <li>SVG elements often use attributes that aren't standard HTML properties (like <code>fill</code>, <code>cx</code>, <code>r</code>).</li>
        <br/>
        <li>You can bind them just like HTML attributes — Angular handles SVG correctly.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;svg width="100" height="100"&gt;
    &lt;circle [attr.cx]="50" [attr.cy]="50" [attr.r]="radius" [attr.fill]="color"&gt;&lt;/circle&gt;
&lt;/svg&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class SvgExampleComponent {
    radius = 30;
    color = 'lightblue';
}
</code></pre>
    <br/>
    <ul>
        <li>Angular updates SVG bindings the same way as normal DOM bindings.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-adding-event-listeners-in-ng">Adding Event Listeners in Angular</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Event listeners let your components react to user actions such as clicks, typing, mouse movements, or key presses.</li>
        <br/>
        <li>Instead of using <code>addEventListener()</code> manually, Angular provides a simpler, declarative way to attach events in templates using parentheses <code>()</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic syntax</b></li>
    <br/>
    <ul>
        <li>The general syntax is:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;element (eventName)="expression"&gt;&lt;/element&gt;
</code></pre>
    <br/>
    <ul>
        <li>Example: listening for a button click.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button (click)="onClick()"&gt;Click me&lt;/button&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class ClickExampleComponent {
    onClick() {
        console.log('Button clicked!');
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Whenever the button is clicked, Angular calls the <code>onClick()</code> method in the component.</li>
        <li>You don't need to query the element or manually add listeners — Angular handles it for you.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing the event object</b></li>
    <br/>
    <ul>
        <li>Angular passes the native browser event as a special variable named <code>$event</code>.</li>
        <br/>
        <li>You can use it to inspect or react to event details like mouse position or keyboard keys.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input (input)="onInput($event)" placeholder="Type something..." /&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class InputExampleComponent {
    onInput(event: Event) {
        const input = event.target as HTMLInputElement;
        console.log('You typed:', input.value);
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>$event</code> gives full access to the original DOM event (the same object you'd get from <code>addEventListener</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Passing custom arguments</b></li>
    <br/>
    <ul>
        <li>You can mix custom arguments and the event object freely.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;button (click)="sayHello('Hwangfucius', $event)"&gt;Greet&lt;/button&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class HelloComponent {
    sayHello(name: string, event: MouseEvent) {
        console.log(`Hello, ${name}!`, event);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>This allows flexible event handlers that take both static and dynamic input.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Keyboard events</b></li>
    <br/>
    <ul>
        <li>Angular supports all standard DOM keyboard events such as <code>keydown</code>, <code>keyup</code>, and <code>keypress</code>.</li>
        <br/>
        <li>You can use <u>key modifiers</u> to listen for specific keys directly.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input (keyup.enter)="onEnter($event)" placeholder="Press Enter" /&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class KeyExampleComponent {
    onEnter(event: KeyboardEvent) {
        const input = event.target as HTMLInputElement;
        console.log('Entered:', input.value);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Angular automatically detects modifier keys like <code>.enter</code>, <code>.esc</code>, <code>.tab</code>, <code>.shift</code>, <code>.alt</code>, and others.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Mouse events</b></li>
    <br/>
    <ul>
        <li>Angular also supports mouse events such as <code>mouseenter</code>, <code>mouseleave</code>, <code>mousemove</code>, <code>mousedown</code>, <code>mouseup</code>, etc.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div
    (mouseenter)="onHover(true)"
    (mouseleave)="onHover(false)"
    [class.active]="hovered"
&gt;
    Hover over me!
&lt;/div&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class MouseExampleComponent {
    hovered = false;

    onHover(isHovering: boolean) {
        this.hovered = isHovering;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Here, the element gains a class when hovered, and Angular removes it when the mouse leaves.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Event filtering with templates</b></li>
    <br/>
    <ul>
        <li>You can write conditions directly inside the template binding to control when a handler runs.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input (keydown)="($event.key === 'Enter') &amp;&amp; submit()" /&gt;
</code></pre>
    <br/>
    <ul>
        <li>This uses a short-circuit expression, <code>submit()</code> runs only when the pressed key is Enter.</li>
        <li>Be careful not to put too much logic inside the template, prefer keeping code in the component.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using @HostListener for host element events</b></li>
    <br/>
    <ul>
        <li>You can attach listeners to the component's own host element using the <code>@HostListener()</code> decorator.</li>
        <br/>
        <li>This is especially useful in directives and reusable UI components.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, HostListener } from '@angular/core';

@Component({
    selector: 'app-box',
    template: `&lt;div&gt;Click anywhere on me&lt;/div&gt;`,
})
export class BoxComponent {
    @HostListener('click', ['$event'])
    handleClick(event: MouseEvent) {
        console.log('Box clicked!', event);
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>@HostListener()</code> automatically handles registration and cleanup.</li>
        <li>It can also listen to global events like <code>window:scroll</code> or <code>document:keydown</code>:</li>
    </ul>
<pre><code class="language-ts line-numbers">@HostListener('window:scroll', ['$event'])
onScroll(event: Event) {
    console.log('Scrolling detected!');
}
</code></pre>
    <br/>
    <ul>
        <li>This is how many Angular libraries implement resize or scroll tracking internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Event binding vs DOM addEventListener</b></li>
    <br/>
    <ul>
        <li>In plain JavaScript, you'd do:
<pre><code class="language-js line-numbers">document.querySelector('button').addEventListener('click', handler);
</code></pre>
        </li>
        <li>But in Angular, the framework:
            <ul>
                <li>Sets up the listeners when the view is created,</li>
                <li>Removes them when the component is destroyed,</li>
                <li>Runs them inside Angular's change detection zone (so your UI updates automatically).</li>
            </ul>
        </li>
        <li>This means you don't need to worry about memory leaks or manual cleanup.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining events with data binding</b></li>
    <br/>
    <ul>
        <li>Event binding is often combined with property binding to create interactive UIs.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input [value]="text" (input)="text = $event.target.value" /&gt;
&lt;p&gt;You typed: {{ text }}&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class CombineExampleComponent {
    text = '';
}
</code></pre>
    <br/>
    <ul>
        <li>This pattern underlies Angular's two-way binding (<code>[(ngModel)]</code>).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-two-way-binding">Two-way binding in Angular</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Two-way binding lets data flow both ways — from your component class to the template, and from the template back to the class.</li>
        <br/>
        <li>It's commonly used for form inputs, switches, checkboxes, and other user-editable fields.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic concept</b></li>
    <br/>
    <ul>
        <li>Two-way binding combines:
            <ul>
                <li><b>Property binding</b> &nbsp; — <code>[value]="username"</code> (data → UI)</li>
                <li><b>Event binding</b> &nbsp; &nbsp; &nbsp; — <code>(input)="username = $event.target.value"</code> (UI → data)</li>
            </ul>
        </li>
        <br/>
        <li>Angular provides a special shorthand for this pattern: <code>[( )]</code> — known as the <b>banana-in-a-box</b> syntax.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input [(ngModel)]="username" /&gt;
&lt;p&gt;Hello, {{ username }}!&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class TwoWayExampleComponent {
    username = 'Alice';
}
</code></pre>
    <br/>
    <ul>
        <li>When the input changes, <code>username</code> updates instantly; when the component changes <code>username</code>, the input field updates automatically too.</li>
    </ul>
    <br/>
    <br/>


    <li><b>How ngModel works internally</b></li>
    <br/>
    <ul>
        <li>The syntax <code>[(ngModel)]="username"</code> is just sugar for combining two bindings:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;input
    [ngModel]="username"
    (ngModelChange)="username = $event"
/&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>[ngModel]</code> → sets the initial value (one-way binding).</li>
        <li><code>(ngModelChange)</code> → fires whenever the value changes in the UI.</li>
        <li>Together, they synchronize both sides automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using ngModel (FormsModule required)</b></li>
    <br/>
    <ul>
        <li>To use <code>ngModel</code>, you must import the <code>FormsModule</code> in your component or application (or add it to <code>imports</code> for standalone components).</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
    selector: 'app-form-demo',
    standalone: true,
    imports: [FormsModule],
    template: `
        &lt;input [(ngModel)]="name" placeholder="Enter your name" /&gt;
        &lt;p&gt;Hello, {{ name || 'stranger' }}!&lt;/p&gt;
    `
})
export class FormDemoComponent {
    name = '';
}
</code></pre>
    <br/>
    <ul>
        <li>If you forget to import <code>FormsModule</code>, Angular will show an error:
            <code>NG0303: Can't bind to 'ngModel' since it isn't a known property...</code></li>
    </ul>
    <br/>
    <br/>


    <li><b>Two-way binding with custom components</b></li>
    <br/>
    <ul>
        <li>You can create your own components that support <code>[(...)]</code> syntax, just like <code>ngModel</code>.</li>
        <br/>
        <li>All you need is an <b>@Input()</b> and an <b>@Output()</b> following a specific naming pattern:
            <code>name</code> and <code>nameChange</code>.
        </li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-toggle',
    template: `
        &lt;button (click)="toggle()"&gt;
            {{ on ? 'ON' : 'OFF' }}
        &lt;/button&gt;
    `,
    standalone: true
})
export class ToggleComponent {
    @Input() on = false;
    @Output() onChange = new EventEmitter&lt;boolean&gt;();

    toggle() {
        this.on = !this.on;
        this.onChange.emit(this.on);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-toggle [(on)]="enabled"&gt;&lt;/app-toggle&gt;
&lt;p&gt;Feature is: {{ enabled ? 'Enabled' : 'Disabled' }}&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class ParentComponent {
    enabled = true;
}
</code></pre>
    <br/>
    <ul>
        <li>Angular automatically recognizes <code>on</code> + <code>onChange</code> as a two-way binding pair.</li>
        <li>So <code>[(on)]</code> expands into <code>[on]</code> and <code>(onChange)</code> internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Two-way binding with checkboxes and select boxes</b></li>
    <br/>
    <ul>
        <li>Two-way binding is very common in forms — it works with input types, checkboxes, selects, and textareas.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;label&gt;
    &lt;input type="checkbox" [(ngModel)]="subscribed" /&gt; Subscribe to newsletter
&lt;/label&gt;

&lt;select [(ngModel)]="language"&gt;
    &lt;option value="en"&gt;English&lt;/option&gt;
    &lt;option value="de"&gt;German&lt;/option&gt;
    &lt;option value="zh"&gt;Chinese&lt;/option&gt;
&lt;/select&gt;

&lt;p&gt;Subscribed: {{ subscribed }}&lt;/p&gt;
&lt;p&gt;Language: {{ language }}&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class PreferencesComponent {
    subscribed = false;
    language = 'en';
}
</code></pre>
    <br/>
    <ul>
        <li>As you check/uncheck or change the dropdown, Angular updates the component variables instantly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using standalone signals instead of ngModel (modern alternative)</b></li>
    <br/>
    <ul>
        <li>Starting in Angular 17, you can achieve two-way reactivity using <u>signals</u> instead of <code>ngModel</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Component, signal } from '@angular/core';

@Component({
    selector: 'app-signal-demo',
    template: `
        &lt;input [value]="name()" (input)="name.set($event.target.value)" /&gt;
        &lt;p&gt;Name: {{ name() }}&lt;/p&gt;
    `,
    standalone: true
})
export class SignalDemoComponent {
    name = signal('Hwangfucius');
}
</code></pre>
    <br/>
    <ul>
        <li>Signals provide reactive state without needing the FormsModule — and are fully type-safe.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-control-flow-in-ng">Control Flow in Angular</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Control flow in Angular templates lets you conditionally render elements, repeat lists, or choose between alternatives — just like <code>if</code>, <code>for</code>, and <code>switch</code> in programming languages.</li>
        <br/>
        <li>Before Angular 17, we used structural directives like <code>*ngIf</code>, <code>*ngFor</code>, and <code>*ngSwitch</code>.</li>
        <br/>
        <li>Now Angular provides a modern, clearer syntax using <u>control flow blocks</u>:
            <ul>
                <li><code>@if</code> / <code>@else</code></li>
                <li><code>@for</code></li>
                <li><code>@switch</code> / <code>@case</code> / <code>@default</code></li>
            </ul>
        </li>
        <br/>
        <li>This syntax is cleaner, faster, and works natively with the Angular compiler.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Conditional rendering with @if</b></li>
    <br/>
    <ul>
        <li>Use <code>@if</code> to render elements only when a condition is true.</li>
    </ul>
<pre><code class="language-html line-numbers">@if (loggedIn) {
    &lt;p&gt;Welcome back, {{ username }}!&lt;/p&gt;
} @else {
    &lt;p&gt;Please log in to continue.&lt;/p&gt;
}
</code></pre>
<pre><code class="language-ts line-numbers">export class LoginExampleComponent {
    loggedIn = false;
    username = 'Hwangfucius';
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>@if</code> block conditionally includes or removes elements from the DOM.</li>
        <li><code>@else</code> is optional and provides an alternate view.</li>
        <li>Unlike <code>*ngIf</code>, this new syntax doesn't require a wrapper element like <code>&lt;ng-container&gt;</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using @else if</b></li>
    <br/>
    <ul>
        <li>You can chain multiple conditions using <code>@else if</code> just like in JavaScript.</li>
    </ul>
<pre><code class="language-html line-numbers">@if (role === 'admin') {
    &lt;p&gt;Welcome, admin!&lt;/p&gt;
} @else if (role === 'editor') {
    &lt;p&gt;Hello, editor!&lt;/p&gt;
} @else {
    &lt;p&gt;Guest access only.&lt;/p&gt;
}
</code></pre>
<pre><code class="language-ts line-numbers">export class RoleExampleComponent {
    role = 'editor';
}
</code></pre>
    <br/>
    <ul>
        <li>This makes conditional rendering much clearer than nesting multiple <code>*ngIf</code> blocks.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Repeating elements with @for</b></li>
    <br/>
    <ul>
        <li>Use <code>@for</code> to loop through arrays and render each item.</li>
    </ul>
<pre><code class="language-html line-numbers">@for (item of items; track item.id) {
    &lt;li&gt;{{ item.name }}&lt;/li&gt;
}
</code></pre>
<pre><code class="language-ts line-numbers">export class ListExampleComponent {
    items = [
        { id: 1, name: 'Angular' },
        { id: 2, name: 'React' },
        { id: 3, name: 'Vue' },
    ];
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>track</code> clause tells Angular how to identify list items efficiently (similar to <code>trackBy</code> in <code>*ngFor</code>).</li>
        <li>If the list changes, Angular can reuse DOM elements instead of re-rendering everything.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using index, count, and even/odd values in @for</b></li>
    <br/>
    <ul>
        <li>You can access extra context variables inside a <code>@for</code> block.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;ul&gt;
    @for (user of users; let i = $index; let count = $count; let even = $even) {
        &lt;li [class.even]="even"&gt;{{ i + 1 }}/{{ count }}: {{ user }}&lt;/li&gt;
    }
&lt;/ul&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class UsersExampleComponent {
    users = ['Alice', 'Bob', 'Charlie'];
}
</code></pre>
    <br/>
    <ul>
        <li><code>$index</code> — the current index (starting from 0).</li>
        <li><code>$count</code> — total number of items.</li>
        <li><code>$even</code>, <code>$odd</code> — booleans for alternating styles.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Switching between multiple options with @switch</b></li>
    <br/>
    <ul>
        <li>Use <code>@switch</code> to choose one block to render based on a single expression.</li>
    </ul>
<pre><code class="language-html line-numbers">@switch (status) {
    @case ('loading') {
        &lt;p&gt;Loading...&lt;/p&gt;
    }
    @case ('success') {
        &lt;p&gt;Data loaded successfully!&lt;/p&gt;
    }
    @case ('error') {
        &lt;p&gt;Something went wrong.&lt;/p&gt;
    }
    @default {
        &lt;p&gt;Idle state.&lt;/p&gt;
    }
}
</code></pre>
<pre><code class="language-ts line-numbers">export class SwitchExampleComponent {
    status = 'loading';
}
</code></pre>
    <br/>
    <ul>
        <li><code>@switch</code> works similarly to JavaScript's <code>switch</code> statement.</li>
        <li>Only the matching <code>@case</code> block is rendered in the DOM.</li>
        <li>The <code>@default</code> block is optional but recommended.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Grouping elements with @let</b></li>
    <br/>
    <ul>
        <li><code>@let</code> lets you declare and reuse a local variable inside the template.</li>
        <li>This is helpful for readability or avoiding repeated expressions.</li>
    </ul>
<pre><code class="language-html line-numbers">@let fullName = firstName + ' ' + lastName;
&lt;p&gt;Hello, {{ fullName }}!&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class LetExampleComponent {
    firstName = 'Hwangfucius';
    lastName = 'Wang';
}
</code></pre>
    <br/>
    <ul>
        <li>Unlike a component variable, <code>@let</code> only exists inside the template block where it's declared.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Older syntax: *ngIf, *ngFor, *ngSwitch</b></li>
    <br/>
    <ul>
        <li>Before Angular 17, we wrote:</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div *ngIf="loggedIn; else loggedOut"&gt;
    Welcome!
&lt;/div&gt;
&lt;ng-template #loggedOut&gt;Please log in.&lt;/ng-template&gt;

&lt;ul&gt;
    &lt;li *ngFor="let item of items; index as i"&gt;{{ i + 1 }} - {{ item }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
    <br/>
    <ul>
        <li>The new control flow syntax is easier to read and integrates better with TypeScript expressions.</li>
        <li>However, <code>*ngIf</code> and its friends still work for backward compatibility.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining control flow blocks</b></li>
    <br/>
    <ul>
        <li>You can nest control flow statements as needed.</li>
    </ul>
<pre><code class="language-html line-numbers">@if (users.length &gt; 0) {
    &lt;ul&gt;
        @for (user of users) {
            &lt;li&gt;{{ user }}&lt;/li&gt;
        }
    &lt;/ul&gt;
} @else {
    &lt;p&gt;No users found.&lt;/p&gt;
}
</code></pre>
<pre><code class="language-ts line-numbers">export class NestedExampleComponent {
    users: string[] = [];
}
</code></pre>
    <br/>
    <ul>
        <li>Angular efficiently updates the DOM when the list or condition changes — you don't need to manage it manually.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-pipes">Pipes in Angular</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>pipe</b> in Angular is a simple way to <u>transform data directly in the template</u> — for example, changing text to uppercase, formatting dates, or displaying numbers nicely.</li>
        <br/>
        <li>Pipes let you keep your component logic clean by doing small formatting tasks in HTML instead of TypeScript.</li>
        <br/>
        <li>Angular comes with many <b>built-in pipes</b> (like <code>date</code>, <code>uppercase</code>, <code>currency</code>), and you can also <b>create your own custom pipes</b>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic syntax</b></li>
    <br/>
    <ul>
        <li>You apply a pipe using the vertical bar (<code>|</code>) symbol inside interpolation (<code>{{ }}</code>).</li>
    </ul>
<pre><code class="language-html line-numbers">{{ value | pipeName }}</code></pre>
    <br/>
    <ul>
        <li>Example:</li>
    </ul>
<pre><code class="language-html line-numbers">{{ username | uppercase }}</code></pre>
    <br/>
    <ul>
        <li>This will display <code>username</code> in all capital letters, without modifying the variable itself.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Chaining multiple pipes</b></li>
    <br/>
    <ul>
        <li>You can chain multiple pipes together, and Angular applies them from left to right.</li>
    </ul>
<pre><code class="language-html line-numbers">{{ birthday | date:'longDate' | uppercase }}</code></pre>
    <br/>
    <ul>
        <li>First, the <code>date</code> pipe formats <code>birthday</code>, and then <code>uppercase</code> converts it to capital letters.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using pipe arguments</b></li>
    <br/>
    <ul>
        <li>Some pipes accept one or more arguments to customize the result.</li>
    </ul>
<pre><code class="language-html line-numbers">{{ amount | currency:'EUR':'symbol':'1.2-2' }}</code></pre>
<pre><code class="language-ts line-numbers">export class PipeExampleComponent {
    amount = 1234.5;
}
</code></pre>
    <br/>
    <ul>
        <li>This formats <code>1234.5</code> as <code>€1,234.50</code>.</li>
        <li>Arguments are separated by colons (<code>:</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Common built-in pipes</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Pipe</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>uppercase</code></td>
                <td><code>{{ 'hello' | uppercase }}</code></td>
                <td>Converts text to uppercase.</td>
            </tr>
            <tr>
                <td><code>lowercase</code></td>
                <td><code>{{ 'HELLO' | lowercase }}</code></td>
                <td>Converts text to lowercase.</td>
            </tr>
            <tr>
                <td><code>titlecase</code></td>
                <td><code>{{ 'hello world' | titlecase }}</code></td>
                <td>Capitalizes the first letter of each word.</td>
            </tr>
            <tr>
                <td><code>date</code></td>
                <td><code>{{ today | date:'fullDate' }}</code></td>
                <td>Formats a Date object into a readable string.</td>
            </tr>
            <tr>
                <td><code>currency</code></td>
                <td><code>{{ price | currency:'USD' }}</code></td>
                <td>Formats numbers as currencies.</td>
            </tr>
            <tr>
                <td><code>percent</code></td>
                <td><code>{{ 0.25 | percent }}</code></td>
                <td>Converts a decimal to a percentage (e.g. 0.25 → 25%).</td>
            </tr>
            <tr>
                <td><code>number</code></td>
                <td><code>{{ 1234.567 | number:'1.0-1' }}</code></td>
                <td>Formats numbers with control over decimal places.</td>
            </tr>
            <tr>
                <td><code>json</code></td>
                <td><code>{{ obj | json }}</code></td>
                <td>Pretty-prints objects as JSON text (for debugging).</td>
            </tr>
            <tr>
                <td><code>slice</code></td>
                <td><code>{{ list | slice:1:3 }}</code></td>
                <td>Extracts part of an array or string (start:end).</td>
            </tr>
            <tr>
                <td><code>async</code></td>
                <td><code>{{ user$ | async }}</code></td>
                <td>Subscribes to an Observable or Promise and shows its value automatically.</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>The async pipe (special case)</b></li>
    <br/>
    <ul>
        <li>The <code>async</code> pipe is one of the most powerful — it automatically subscribes to Observables or Promises and updates the template when new data arrives.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;p&gt;User: {{ user$ | async }}&lt;/p&gt;
</code></pre>
<pre><code class="language-ts line-numbers">import { Component } from '@angular/core';
import { of } from 'rxjs';

@Component({
    selector: 'app-async-demo',
    templateUrl: './async-demo.component.html',
})
export class AsyncDemoComponent {
    user$ = of('Hwangfucius');
}
</code></pre>
    <br/>
    <ul>
        <li>No need to manually subscribe or unsubscribe — Angular handles it for you.</li>
        <li>When the observable emits a new value, the UI updates automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Pure vs Impure pipes</b></li>
    <br/>
    <ul>
        <li>By default, pipes are <b>pure</b>: they run only when the input value changes.</li>
        <li>An <b>impure</b> pipe runs on every change detection cycle (which can be slower).</li>
    </ul>
<pre><code class="language-ts line-numbers">@Pipe({
    name: 'myPipe',
    pure: true, // default
})
export class MyPipe {
    transform(value: string) {
        return value.toUpperCase();
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Use pure pipes for simple formatting.</li>
        <li>Use impure pipes only if you need to react to changes inside complex objects or arrays that mutate frequently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating a custom pipe</b></li>
    <br/>
    <ul>
        <li>You can create your own pipe using the <code>@Pipe</code> decorator.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
    name: 'greet'
})
export class GreetPipe implements PipeTransform {
    transform(name: string): string {
        return `Hello, ${name}!`;
    }
}
</code></pre>
<pre><code class="language-html line-numbers">{{ 'Hwangfucius' | greet }}</code></pre>
    <br/>
    <ul>
        <li>The pipe class must implement the <code>PipeTransform</code> interface and define a <code>transform()</code> method.</li>
        <li>Angular calls this method every time the value (or arguments) change.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Custom pipe with parameters</b></li>
    <br/>
    <ul>
        <li>Your custom pipe can accept parameters, just like built-in ones.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Pipe({ name: 'repeat' })
export class RepeatPipe implements PipeTransform {
    transform(value: string, times: number = 2): string {
        return value.repeat(times);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">{{ 'Hi' | repeat:3 }}</code></pre>
    <br/>
    <ul>
        <li>This displays <code>HiHiHi</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to use pipes</b></li>
    <br/>
    <ul>
        <li>Use pipes for:
            <ul>
                <li>Formatting or displaying data (dates, currency, etc.)</li>
                <li>Simple text transformations</li>
                <li>Displaying filtered or transformed lists</li>
            </ul>
        </li>
        <br/>
        <li>Avoid pipes for:
            <ul>
                <li>Heavy computation or large data filtering (do that in TypeScript)</li>
                <li>Functions that depend on external asynchronous calls (use services instead)</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-creating-custom-pipes">Creating Custom Pipes in Angular</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Sometimes the built-in Angular pipes are not enough, you may want to transform your data in a way that fits your own app logic.</li>
        <br/>
        <li>In such cases, you can easily create a <u>custom pipe</u> with the <code>@Pipe</code> decorator.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic structure of a custom pipe</b></li>
    <br/>
    <ul>
        <li>A custom pipe is simply a class that implements the <code>PipeTransform</code> interface.</li>
        <li>This interface requires you to define one method: <code>transform(value: any, ...args: any[]): any</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
    name: 'example'  // The pipe name used in templates: {{ value | example }}
})
export class ExamplePipe implements PipeTransform {
    transform(value: any): any {
        // modify the value and return it
        return value;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>You then use it like any other pipe:</li>
    </ul>
<pre><code class="language-html line-numbers">{{ 'Hello' | example }}</code></pre>
    <br/>
    <ul>
        <li>This structure is the foundation for every custom pipe you'll make.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: A "greet" pipe</b></li>
    <br/>
    <ul>
        <li>Let's start with a simple example: a pipe that adds a greeting before a name.</li>
    </ul>
<pre><code class="language-ts line-numbers">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({ name: 'greet' })
export class GreetPipe implements PipeTransform {
    transform(name: string): string {
        return `Hello, ${name}!`;
    }
}
</code></pre>
<pre><code class="language-html line-numbers">{{ 'Hwangfucius' | greet }}</code></pre>
    <br/>
    <ul>
        <li>Output: <b>Hello, Hwangfucius!</b></li>
        <li>Notice that you didn't change the original value, pipes only transform the display, not the data itself.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Passing parameters to your pipe</b></li>
    <br/>
    <ul>
        <li>Your custom pipe can also accept arguments, separated by colons (<code>:</code>).</li>
    </ul>
<pre><code class="language-ts line-numbers">@Pipe({ name: 'repeat' })
export class RepeatPipe implements PipeTransform {
    transform(value: string, times: number = 2): string {
        return value.repeat(times);
    }
}
</code></pre>
<pre><code class="language-html line-numbers">{{ 'Hi' | repeat:3 }}</code></pre>
    <br/>
    <ul>
        <li>Output: <b>HiHiHi</b></li>
        <li>Angular automatically passes the extra arguments to your <code>transform()</code> method after the first parameter.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Capitalize only the first letter</b></li>
    <br/>
    <ul>
        <li>This pipe transforms the first letter to uppercase while keeping the rest lowercase.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Pipe({ name: 'capitalize' })
export class CapitalizePipe implements PipeTransform {
    transform(value: string): string {
        if (!value) return '';
        return value[0].toUpperCase() + value.slice(1).toLowerCase();
    }
}
</code></pre>
<pre><code class="language-html line-numbers">{{ 'aNGuLAr' | capitalize }}</code></pre>
    <br/>
    <ul>
        <li>Output: <b>Angular</b></li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Filtering a list</b></li>
    <br/>
    <ul>
        <li>This pipe filters an array based on a text input (a bit more advanced).</li>
    </ul>
<pre><code class="language-ts line-numbers">@Pipe({ name: 'filter' })
export class FilterPipe implements PipeTransform {
    transform(items: string[], search: string): string[] {
        if (!items || !search) return items;
        const lower = search.toLowerCase();
        return items.filter(item =&gt; item.toLowerCase().includes(lower));
    }
}
</code></pre>
<pre><code class="language-html line-numbers">&lt;input [(ngModel)]="keyword" placeholder="Search..." /&gt;
&lt;ul&gt;
    @for (name of (names | filter:keyword)) {
        &lt;li&gt;{{ name }}&lt;/li&gt;
    }
&lt;/ul&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class FilterExampleComponent {
    keyword = '';
    names = ['Alice', 'Bob', 'Charlie', 'David'];
}
</code></pre>
    <br/>
    <ul>
        <li>As the user types, the pipe filters the list automatically.</li>
        <li>Remember that pipes are only for presentation — for very large data sets, prefer filtering in the component or backend.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Pure vs Impure custom pipes</b></li>
    <br/>
    <ul>
        <li>By default, custom pipes are <b>pure</b>, meaning Angular only calls them when the input value changes.</li>
        <li>If you need the pipe to run every time change detection happens (for example, if you mutate the same array), mark it as <b>impure</b> by setting <code>pure: false</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Pipe({
    name: 'impureFilter',
    pure: false
})
export class ImpureFilterPipe implements PipeTransform {
    transform(items: string[], search: string): string[] {
        // runs on every change detection
        return items.filter(item =&gt; item.includes(search));
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Impure pipes re-run often, so use them sparingly — they can slow down performance if overused.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using custom pipes in standalone components</b></li>
    <br/>
    <ul>
        <li>If your component is standalone, you must add the pipe to its <code>imports</code> array.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-greet-demo',
    standalone: true,
    imports: [GreetPipe],
    template: `&lt;p&gt;{{ 'Hwangfucius' | greet }}&lt;/p&gt;`
})
export class GreetDemoComponent {}
</code></pre>
    <br/>
    <ul>
        <li>Now the component can use <code>greet</code> in its template.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using custom pipes in NgModules (non-standalone apps)</b></li>
    <br/>
    <ul>
        <li>If you're using Angular with NgModules, declare your pipe inside the <code>declarations</code> array of a module.</li>
    </ul>
<pre><code class="language-ts line-numbers">@NgModule({
    declarations: [CapitalizePipe],
    exports: [CapitalizePipe]
})
export class SharedPipesModule {}
</code></pre>
    <br/>
    <ul>
        <li>Then import <code>SharedPipesModule</code> into any module that needs those pipes.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-render-templates-from-a-parent-component">Render Templates from a Parent Component with <code>&lt;ng-content&gt;</code> (sorted of repeated)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>&lt;ng-content&gt;</code> tag allows a child component to display <u>content provided by its parent</u>.</li>
        <br/>
        <li>This technique is called <u>content projection</u>.</li>
        <br/>
        <li>It lets the parent control what appears inside the child component's template — useful for cards, dialogs, alerts, and any reusable layout components.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic example</b></li>
    <br/>
    <ul>
        <li>Imagine a reusable alert component that displays custom text provided by its parent.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-alert',
    template: `
        &lt;div class="alert"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
    `,
    styles: [`.alert { background: #ffe5e5; padding: 1rem; border-radius: 4px; }`],
    standalone: true,
})
export class AlertComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component template --&gt;
&lt;app-alert&gt;
    Something went wrong! Please try again.
&lt;/app-alert&gt;
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>&lt;ng-content&gt;</code> is a placeholder where the parent's content will be inserted.</li>
        <li>The parent's message appears inside the alert box without the child knowing what the message is.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Projecting multiple content areas</b></li>
    <br/>
    <ul>
        <li>You can project multiple parts of the parent's template into specific places using <b>selectors</b>.</li>
        <li>Use the <code>select</code> attribute to match HTML elements or CSS classes.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-card',
    template: `
        &lt;div class="card"&gt;
            &lt;div class="card-header"&gt;
                &lt;ng-content select="[card-title]"&gt;&lt;/ng-content&gt;
            &lt;/div&gt;

            &lt;div class="card-body"&gt;
                &lt;ng-content&gt;&lt;/ng-content&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `,
    styles: [`
        .card { border: 1px solid #ccc; border-radius: 8px; padding: 1rem; margin: .5rem 0; }
        .card-header { font-weight: bold; margin-bottom: .5rem; }
    `],
    standalone: true,
})
export class CardComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;!-- Parent component --&gt;
&lt;app-card&gt;
    &lt;span card-title&gt;User Info&lt;/span&gt;
    &lt;p&gt;Name: Alice&lt;/p&gt;
    &lt;p&gt;Email: alice@example.com&lt;/p&gt;
&lt;/app-card&gt;
</code></pre>
    <br/>
    <ul>
        <li>The content inside <code>&lt;span card-title&gt;</code> goes into the header area.</li>
        <li>The rest of the content is projected into the body area.</li>
        <li>This gives a lot of flexibility while keeping the component's structure consistent.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Default content fallback</b></li>
    <br/>
    <ul>
        <li>If the parent doesn't provide anything, you can display a default message inside <code>&lt;ng-content&gt;</code>.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-message-box',
    template: `
        &lt;div class="message-box"&gt;
            &lt;ng-content&gt;No message provided.&lt;/ng-content&gt;
        &lt;/div&gt;
    `,
    styles: [`.message-box { border: 1px dashed #888; padding: .5rem; }`],
    standalone: true,
})
export class MessageBoxComponent {}
</code></pre>
<pre><code class="language-html line-numbers">&lt;app-message-box&gt;&lt;/app-message-box&gt;
&lt;!-- Renders "No message provided." --&gt;
</code></pre>
    <br/>
    <ul>
        <li>Anything written between <code>&lt;ng-content&gt;</code> tags acts as fallback content when the parent provides nothing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Projecting content dynamically</b></li>
    <br/>
    <ul>
        <li>You can combine <code>&lt;ng-content&gt;</code> with Angular control flow directives like <code>@if</code> or <code>@for</code> to conditionally render projected content.</li>
    </ul>
<pre><code class="language-ts line-numbers">@Component({
    selector: 'app-section',
    template: `
        &lt;div class="section"&gt;
            @if (visible) {
                &lt;ng-content&gt;&lt;/ng-content&gt;
            } @else {
                &lt;p&gt;(Hidden)&lt;/p&gt;
            }
        &lt;/div&gt;
    `,
    standalone: true,
})
export class SectionComponent {
    visible = true;
}
</code></pre>
    <br/>
    <ul>
        <li>The projected content only appears when <code>visible</code> is true.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Lifecycle of projected content</b></li>
    <br/>
    <ul>
        <li>Angular provides special lifecycle hooks for when projected content appears or changes:</li>
        <ul>
            <li><code>ngAfterContentInit()</code> — runs once when the content is first inserted.</li>
            <li><code>ngAfterContentChecked()</code> — runs after every update to the projected content.</li>
        </ul>
    </ul>
<pre><code class="language-ts line-numbers">export class CardComponent implements AfterContentInit, AfterContentChecked {
    ngAfterContentInit() {
        console.log('Projected content initialized');
    }

    ngAfterContentChecked() {
        console.log('Projected content checked');
    }
}
</code></pre>
    <br/>
    <ul>
        <li>These hooks let your component react when the parent changes its projected data.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ng-create-template-fragments-with-ng-template">Create Template Fragments with <code>&lt;ng-template&gt;</code></h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>&lt;ng-template&gt;</code> tag defines a chunk of HTML that Angular <u>does not render right away</u>.</li>
        <br/>
        <li>It is a <u>template fragment</u> — a block of markup that Angular can insert, reuse, or render later under certain conditions.</li>
        <br/>
        <li>It's often used for:
            <ul>
                <li>Conditionally showing or hiding parts of the template,</li>
                <li>Customizing reusable components (like dialogs or cards),</li>
                <li>Rendering content dynamically using <code>ngTemplateOutlet</code>.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic example</b></li>
    <br/>
    <ul>
        <li>Angular doesn't render an <code>&lt;ng-template&gt;</code> until you explicitly tell it to.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;ng-template&gt;
    &lt;p&gt;This is hidden by default.&lt;/p&gt;
&lt;/ng-template&gt;
</code></pre>
    <br/>
    <ul>
        <li>The browser will not display anything — it's stored as a "template instruction" for Angular.</li>
        <li>To show it, you must render it manually using <code>*ngIf</code> or <code>ngTemplateOutlet</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using with *ngIf</b></li>
    <br/>
    <ul>
        <li><code>*ngIf</code> can take an <code>else</code> block that points to an <code>&lt;ng-template&gt;</code>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;div *ngIf="loggedIn; else loginPrompt"&gt;
    Welcome back, user!
&lt;/div&gt;

&lt;ng-template #loginPrompt&gt;
    &lt;p&gt;Please log in to continue.&lt;/p&gt;
&lt;/ng-template&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class LoginExampleComponent {
    loggedIn = false;
}
</code></pre>
    <br/>
    <ul>
        <li>If <code>loggedIn</code> is <code>false</code>, Angular will render the <code>loginPrompt</code> template instead.</li>
        <li>The <code>#loginPrompt</code> gives the template a reference name.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using with @for (or *ngFor)</b></li>
    <br/>
    <ul>
        <li>Every <code>@for</code> loop internally uses <code>&lt;ng-template&gt;</code> to repeat DOM fragments.</li>
        <li>You can also define your own template for each repeated item.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;ng-template #userTemplate let-name&gt;
    &lt;li&gt;{{ name }}&lt;/li&gt;
&lt;/ng-template&gt;

&lt;ul&gt;
    @for (name of users) {
        &lt;ng-container [ngTemplateOutlet]="userTemplate" [ngTemplateOutletContext]="{ $implicit: name }"&gt;&lt;/ng-container&gt;
    }
&lt;/ul&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class UserListComponent {
    users = ['Alice', 'Bob', 'Charlie'];
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>let-name</code> variable receives the value passed by the context (<code>$implicit: name</code>).</li>
        <li><code>ngTemplateOutlet</code> renders the same template multiple times with different data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Rendering manually with ngTemplateOutlet</b></li>
    <br/>
    <ul>
        <li>You can insert a template manually anywhere in the DOM using <code>&lt;ng-container&gt;</code> and <code>ngTemplateOutlet</code>.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;ng-template #alertTemplate&gt;
    &lt;div class="alert"&gt;This is an alert message!&lt;/div&gt;
&lt;/ng-template&gt;

&lt;ng-container [ngTemplateOutlet]="alertTemplate"&gt;&lt;/ng-container&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>ngTemplateOutlet</code> acts like a function call — it "renders" the referenced template in that place.</li>
        <li><code>&lt;ng-container&gt;</code> is a structural wrapper that doesn't create any extra HTML element.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Passing data into a template</b></li>
    <br/>
    <ul>
        <li>Templates can accept contextual data using the <code>ngTemplateOutletContext</code> input.</li>
        <li>You can define a variable in the template using <code>let-</code> syntax.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;ng-template #greetTemplate let-person&gt;
    &lt;p&gt;Hello, {{ person }}!&lt;/p&gt;
&lt;/ng-template&gt;

&lt;ng-container
    [ngTemplateOutlet]="greetTemplate"
    [ngTemplateOutletContext]="{ person: 'Hwangfucius' }"&gt;
&lt;/ng-container&gt;
</code></pre>
    <br/>
    <ul>
        <li>This outputs: <b>Hello, Hwangfucius!</b></li>
        <li>You can think of <code>ngTemplateOutletContext</code> as "passing parameters" to the template.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using multiple templates dynamically</b></li>
    <br/>
    <ul>
        <li>You can switch between different templates based on component state.</li>
    </ul>
<pre><code class="language-html line-numbers">&lt;ng-template #loading&gt;&lt;p&gt;Loading...&lt;/p&gt;&lt;/ng-template&gt;
&lt;ng-template #success&gt;&lt;p&gt;Data loaded successfully!&lt;/p&gt;&lt;/ng-template&gt;
&lt;ng-template #error&gt;&lt;p&gt;Something went wrong.&lt;/p&gt;&lt;/ng-template&gt;

&lt;ng-container [ngTemplateOutlet]="currentTemplate"&gt;&lt;/ng-container&gt;
</code></pre>
<pre><code class="language-ts line-numbers">export class TemplateSwitcherComponent {
    state: 'loading' | 'success' | 'error' = 'loading';

    get currentTemplate() {
        if (this.state === 'success') return this.success;
        if (this.state === 'error') return this.error;
        return this.loading;
    }

    @ViewChild('loading', { static: true }) loading!: TemplateRef&lt;any&gt;;
    @ViewChild('success', { static: true }) success!: TemplateRef&lt;any&gt;;
    @ViewChild('error', { static: true }) error!: TemplateRef&lt;any&gt;;
}
</code></pre>
    <br/>
    <ul>
        <li>This technique is useful for conditional UI — for example, showing loading spinners, error messages, or success content.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
<!-- * * * * * * * * * * * * * * -->
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
