<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Angular</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    ins {
        background-color: #d4fcbc;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }

    del::before,
    ins::before {
        position: absolute;
        left: 0.5rem;
        font-family: monospace;
    }

    del::before {
        content: "−";
    }

    ins::before {
        content: "+";
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Angular</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Tips</h3>
<ol>
    <li>Separate words within a file name with hyphens (<code>-</code>). For example, a component named <code>UserProfile</code> has a file name <code>user-profile.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>For unit tests, end file names with <code>.spec.ts</code>.
        For example, the unit test file for the <code>UserProfile</code> component has the file name <code>user-profile.spec.ts</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>All of your Angular UI code (TypeScript, HTML, and styles) should live inside a directory named <code>src</code>.<br/><br/>
        Code that's not related to UI, such as configuration files or scripts, should live outside the <code>src</code> directory.</li>
    <br/>
    <br/>
    <br/>
    <li>The code to start up, or bootstrap, an Angular application should always live in a file named <code>main.ts</code>.<br/><br/>
        This represents the primary entry point to the application.</li>
    <br/>
    <br/>
    <br/>
    <li>Angular components consist of a TypeScript file and, optionally, a template and one or more style files. You should group these together in the same directory.</li>
    <br/>
    <br/>
    <br/>
    <li>Avoid creating subdirectories based on the type of code that lives in those directories.<br/><br/>
        For example, avoid creating directories like <code>components/</code>, <code>directives/</code>, and <code>services/</code>.</li>
    <br/>
    <br/>
    <br/>
    <li>Prefer the <code>inject()</code> function over constructor parameter injection.</li>
    <br/>
    <br/>
    <br/>
    <li>Use <code>protected</code> on class members that are only used by a component's template.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({
    ...,
    template: `<p>{{ fullName() }}</p>`,
})
export class UserProfile {
    firstName = input();
    lastName  = input();
    // `fullName` is not part of the component's public API, but is used in the template.
    protected fullName = computed(() =&gt; `${this.firstName()} ${this.lastName()}`);
}
</code></pre>
    <br/>
    <br/>
    <br/>
    <li>Use <code>readonly</code> for properties that shouldn't change.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">@Component({/* ... */})
export class UserProfile {
    readonly userId    = input();
    readonly userSaved = output();
    readonly userName  = model();
}
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Signals</h3>
<ol>
    <li><b>What is a signal?</b><br/><br/>
        A <code>signal</code> is a reactive value container that automatically notifies Angular when its content changes.<br/><br/>
        Unlike normal class properties, signals are tracked by Angular's change detection system — any component using them updates automatically.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, Component } from '@angular/core';

@Component({
    selector: 'counter-example',
    template: `
        &lt;h3&gt;Count: {{ count() }}&lt;/h3&gt;
        &lt;button (click)="increment()"&gt;+&lt;/button&gt;
    `,
    standalone: true,
})
export class CounterExample {
    count = signal(0);
    increment() {
        this.count.update(v =&gt; v + 1);
    }
}
</code></pre>
        <br/>
        Signals are functions — you read them by calling like <code>count()</code>, not <code>count</code>.
    </li>

    <br/><br/><br/>

    <li><b>Writable signals</b><br/><br/>
        A writable signal is a normal signal created with <code>signal()</code>. It can be changed with:
        <ul>
            <br/>
            <li><code>.set(newValue)</code> – replace the value directly</li>
            <br/>
            <li><code>.update(fn)</code> – change it based on its current value</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const counter = signal(0);

counter.set(10);          // sets value to 10
counter.update(v =&gt; v+1); // now 11
console.log(counter());   // prints 11
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Computed signals</b><br/><br/>
        Computed signals are read-only values derived from one or more other signals.
        They automatically recalculate when any of their dependencies change.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, computed } from '@angular/core';

const first = signal('Hwang');
const last  = signal('Fu');

const fullName = computed(() =&gt; `${first()} ${last()}`);

console.log(fullName());   // "Hwang Fu"

last.set('Fucius');
console.log(fullName());   // "Hwang Fucius" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Effects</b><br/><br/>
        An <code>effect()</code> runs a piece of code automatically whenever the signals it reads change.
        Useful for logging, animations, or syncing values.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, effect } from '@angular/core';

const count = signal(0);

effect(() =&gt; {
    console.log('Count changed:', count());
});

count.set(1);  // console logs: Count changed: 1
count.set(2);  // console logs: Count changed: 2
</code></pre>
        <br/>
        Angular automatically cleans up effects when their owner component is destroyed.
    </li>

    <br/><br/><br/>

    <li><b>Inputs and signals</b><br/><br/>
        You can also create component inputs that behave like signals using <code>input()</code>.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'user-card',
    template: `&lt;p&gt;Hello, {{ name() }}!&lt;/p&gt;`,
})
export class UserCard {
    name = input('Anonymous');   // signal-style input with default
}
</code></pre>
        <br/>
        <ul>
            <li><code>input()</code> → for reading input signals</li>
            <li><code>output()</code> → for emitting events</li>
            <li><code>model()</code> → for two-way binding (v18+)</li>
        </ul>
    </li>

    <br/><br/><br/>

    <li><b>Readonly vs writable signals</b><br/><br/>
        A computed signal is <code>readonly</code> by design, meaning you cannot call <code>.set()</code> or <code>.update()</code> on it.<br/><br/>
        Writable signals (<code>signal()</code>) can both be read and updated.
    </li>

    <br/><br/><br/>

    <li><b>Accessing signals from the template</b><br/><br/>
        In templates, signals behave like functions — you must call them:
<pre class="line-numbers"><code class="language-html">&lt;h2&gt;{{ count() }}&lt;/h2&gt;   &lt;!-- ✅ correct --&gt;
&lt;h2&gt;{{ count }}&lt;/h2&gt;     &lt;!-- ❌ won't update --&gt;
</code></pre>
        <br/>
        Angular automatically re-renders that part of the template when the signal changes.
    </li>

    <br/><br/><br/>

    <li><b>When to use signals?</b><br/><br/>
        <ul>
            <li>For local component state (form inputs, toggles, UI flags)</li>
            <br/>
            <li>For derived/computed data</li>
            <br/>
            <li>For lightweight reactivity without external stores</li>
            <br/>
            <li>Instead of RxJS <code>BehaviorSubject</code> for simple cases</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Linked Signals</h3>
<ol>
    <li><b>What is a linked signal?</b><br/><br/>
        A <code>linkedSignal()</code> is a special kind of signal that stays connected to another signal.<br/><br/>
        When the source signal changes, the linked one also updates automatically.<br/><br/>
        Think of it as a "live copy" or a "mirror" of another signal — but one that can also transform or filter the value.
        <br/><br/>
        Example:
<pre class="line-numbers"><code class="language-ts">import { signal, linkedSignal } from '@angular/core';

const name = signal('Hwangfu');

// Linked signal that always follows `name`
const upperName = linkedSignal(() =&gt; name().toUpperCase());

console.log(upperName()); // "HWANGFU"

name.set('Fucius');
console.log(upperName()); // "FUCIUS" – updated automatically
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Why not just use <code>computed()</code>?</b><br/><br/>
        <code>computed()</code> and <code>linkedSignal()</code> look similar, but there's one key difference:<br/><br/>
        <ul>
            <li><code>computed()</code> → read-only, you can't change its value directly</li>
            <br/>
            <li><code>linkedSignal()</code> → can also be written to (you can modify it)</li>
        </ul>
        <br/>
        Example:
<pre class="line-numbers"><code class="language-ts">const count = signal(0);

// Computed: only reads from count
const double = computed(() =&gt; count() * 2);

// Linked: can read and write
const mirror = linkedSignal(() =&gt; count(), {
    // define how writing back should work
    set: (newVal) =&gt; count.set(newVal),
});

mirror.set(5);
console.log(count()); // 5
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>When to use linked signals?</b><br/><br/>
        Linked signals are useful when two parts of your code need to share the same data, but maybe in a slightly different form.<br/><br/>
        For example, if you want to edit a copy of a user object without losing the original right away:
<pre class="line-numbers"><code class="language-ts">const activeUser = signal({ id: 1, name: 'Alice' });

// Create a linked version for editing
const editUser = linkedSignal(() =&gt; activeUser(), {
    // treat users with the same id as the same object
    equal: (a, b) =&gt; a.id === b.id,
});

console.log(editUser());  // { id: 1, name: 'Alice' }

editUser.update(u =&gt; ({ ...u, name: 'Alicia' }));
console.log(editUser().name);  // "Alicia"

// if `activeUser` changes, `editUser` also updates
activeUser.set({ id: 1, name: 'Alina' });
console.log(editUser().name);  // "Alina"
</code></pre>
    </li>

    <br/><br/><br/>

    <li><b>Basic syntax patterns</b><br/><br/>
        You can define a linked signal in two common ways:
        <br/><br/>
        <b>1. Simple form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal(() =&gt; source());
</code></pre>
        <b>2. Detailed form</b>
<pre class="line-numbers"><code class="language-ts">const copy = linkedSignal({
    source: source,
    computation: (value) =&gt; value,
    equal: (a, b) =&gt; a.id === b.id,
});
</code></pre>
        <br/>
        The detailed form gives you more control: you can define how values are compared, or how they're computed.
    </li>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What does a CSS selector component do?</h3>
<ol>
    <li>When you write <code>@Component({ selector: 'button[type="reset"]' })</code>, Angular matches all elements in the DOM that fit this CSS selector.</li>
    <br/><br/>

    <li>If an element matches, Angular creates your component and attaches it to that element.</li>
    <br/><br/>

    <li>The element is NOT replaced. It stays the original tag. Angular just uses it as the host.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'button[type="reset"]',
    template: '<ng-content></ng-content>',
})
export class ResetButton {}
</code></pre>
    <br/>
    Any <code>&lt;button type="reset"&gt;</code> becomes a <code>ResetButton</code> component host.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Extend the example: make the reset button actually do things</h3>
<ol>
    <li>Below is a <code>ResetButton</code> component that:
        <ul>
            <br/>
            <li>adds classes (for styling)</li>
            <br/>
            <li>supports variants (<code>primary</code> / <code>ghost</code>)</li>
            <br/>
            <li>supports a <code>loading</code> state (shows a spinner, disables clicks)</li>
            <br/>
            <li>sets accessibility attributes (<code>aria-disabled</code>, <code>aria-busy</code>)</li>
            <br/>
            <li>keeps the original button text via <code>&lt;ng-content&gt;</code></li>
        </ul>
    </li>

    <br/><br/>

    <li>TypeScript (component):
<pre class="line-numbers"><code class="language-ts">import { Component, HostBinding, HostListener, Input } from '@angular/core';

@Component({
    selector: 'button[type="reset"]',
    // The host element IS the &lt;button&gt;. We only render inside it.
    template: `
        &lt;span class="content" [class.hidden]="loading"&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/span&gt;
        &lt;span class="spinner" *ngIf="loading" aria-hidden="true"&gt;⏳&lt;/span&gt;
    `,
    styles: [`
        :host {
            /* base look */
            font: inherit;
            border-radius: 6px;
            padding: .5rem .9rem;
            cursor: pointer;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: .5rem;
            transition: background-color .15s ease, border-color .15s ease, color .15s ease;
        }

        /* variants via classes on :host */
        :host(.primary) {
            background: #0d6efd;
            color: white;
        }
        :host(.primary:hover) { background: #0b5ed7; }

        :host(.ghost) {
            background: transparent;
            color: #0d6efd;
            border-color: #0d6efd;
        }
        :host(.ghost:hover) { background: rgba(13,110,253,.08); }

        /* disabled look */
        :host(.disabled) {
            opacity: .55;
            cursor: not-allowed;
            pointer-events: none;
        }

        .spinner { display: inline-flex; }
        .content.hidden { visibility: hidden; } /* reserve space so width doesn't jump */
    `],
    standalone: true,
})
export class ResetButton {
    /** Visual variant */
    @Input() variant: 'primary' | 'ghost' = 'primary';

    /** Loading state: blocks clicks, shows spinner, updates aria */
    @Input() loading = false;

    /** Disable state (useful if you want to disable the reset button) */
    @Input() disabled = false;

    /** Reflect variant and states as CSS classes on the host &lt;button&gt; */
    @HostBinding('class')
    get hostClasses(): string {
        const v = this.variant ?? 'primary';
        return [v, this.disabled || this.loading ? 'disabled' : ''].filter(Boolean).join(' ');
    }

    /** Keep native semantics but add A11y hints */
    @HostBinding('attr.aria-disabled') get ariaDisabled() { return String(this.disabled); }
    @HostBinding('attr.aria-busy')     get ariaBusy()     { return String(this.loading); }

    /** Optional: ensure the host has type="reset" (safety if HTML missed it) */
    @HostBinding('attr.type') readonly type = 'reset';

    /** Block clicks when disabled/loading */
    @HostListener('click', ['$event'])
    onClick(ev: MouseEvent) {
        if (this.disabled || this.loading) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
        }
    }
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage examples:
<pre class="line-numbers"><code class="language-html">&lt;!-- Matches selector because it's a button[type="reset"] --&gt;
&lt;button type="reset" variant="primary"&gt;Reset form&lt;/button&gt;

&lt;!-- Switch variant --&gt;
&lt;button type="reset" variant="ghost"&gt;Clear&lt;/button&gt;

&lt;!-- Loading state --&gt;
&lt;button type="reset" variant="primary" [loading]="true"&gt;Resetting…&lt;/button&gt;

&lt;!-- Disabled state --&gt;
&lt;button type="reset" [disabled]="true"&gt;Disabled reset&lt;/button&gt;

&lt;!-- With projected rich content --&gt;
&lt;button type="reset" variant="primary"&gt;
    &lt;span class="hl-grey-fg"&gt;↺&lt;/span&gt;
    Reset filters
&lt;/button&gt;
</code></pre>
    </li>
    <br/><br/>

    <li>What changed compared to the minimal skeleton:
        <ul>
            <br/>
            <li><code>@Input()</code> values (<code>variant</code>, <code>loading</code>, <code>disabled</code>) so templates can control the button.</li>
            <br/>
            <li><code>@HostBinding</code> adds/removes CSS classes on the host <code>&lt;button&gt;</code>.</li>
            <br/>
            <li><code>@HostListener('click')</code> prevents clicks when disabled/loading.</li>
            <br/>
            <li><code>type="reset"</code> is enforced, so even if HTML forgot it, it behaves as a reset button.</li>
            <br/>
            <li>Simple styles are scoped to this component only.</li>
        </ul>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What does <code>selector: 'drop-zone, [dropzone]'</code> mean?</h3>
<ol>
    <li>This selector matches two things:
        <ul>
            <br/>
            <li><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;</code></li>
            <br/>
            <li>Any element with a <code>dropzone</code> attribute, like <code>&lt;div dropzone&gt;</code></li>
        </ul>
    </li>

    <br/>
    <br/>
    <br/>

    <li>Both become hosts for the <code>DropZone</code> component.</li>

    <br/>
    <br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone, [dropzone]',
    template: '<ng-content></ng-content>',
})
export class DropZone {}
</code></pre>
    </li>

    <br/><br/>

    <li>The host element is NOT replaced, the component renders inside it.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to define a custom attribute (Angular Input)?</h3>
<ol>
    <li>You define a custom attribute using <code>@Input()</code>.</li>

    <br/><br/>

    <li>This does not create a real DOM attribute unless you bind it.</li>

    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Component({
    selector: 'drop-zone',
    template: '<ng-content></ng-content>',
})
export class DropZone {
    @Input() mode: 'files' | 'links' | 'images' = 'files';
}
</code></pre>

    Usage:
<pre><code>&lt;drop-zone&gt;&lt;/drop-zone&gt;                (uses default: mode = "files")
&lt;drop-zone mode="links"&gt;&lt;/drop-zone&gt;   (sets mode = "links")
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to show the custom Input as a real HTML attribute?</h3>
<ol>
    <li>Use <code>@HostBinding('attr.&lt;attribute-name&gt;')</code>.</li>
    <br/><br/>

    <li>This makes the Input appear in the DOM inspector.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[dropzone]',
})
export class DropzoneDirective {
    @Input() dropzone: string = 'files';

    @HostBinding('attr.dropzone')
    get attrValue() {
        return this.dropzone;
    }
}
</code></pre>

    Resulting DOM:
<pre><code>&lt;div dropzone="files"&gt;&lt;/div&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Default boolean attribute with true/false behavior</h3>
<ol>
    <li>Use <code>booleanAttribute</code> transform.</li>
    <br/><br/>

    <li>This makes <code>appResizable</code> behave like a proper boolean.</li>
    <br/><br/>

    <li>Example:
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: '[appResizable]',
})
export class ResizableDirective {
    @Input({ alias: 'appResizable', transform: booleanAttribute })
    resizable = true;

    @HostBinding('attr.data-resizable')
    get data() {
        return String(this.resizable);
    }
}
</code></pre>

    Usage:
<pre><code>&lt;div appResizable&gt;&lt;/div&gt;            (true by default)
&lt;div appResizable="true"&gt;&lt;/div&gt;     (true)
&lt;div [appResizable]="false"&gt;&lt;/div&gt;  (false)
</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Setting a default DOM attribute directly</h3>
<ol>
    <li>If you just want an element to always have an attribute, bind it with HostBinding.</li>
    <br/><br/>

    <li>Example: default <code>type="reset"</code> for any button with a directive.
<pre class="line-numbers"><code class="language-ts">@Directive({
    selector: 'button[appResetDefault]',
})
export class ResetDefaultDirective {
    @HostBinding('attr.type') type = 'reset';
}
</code></pre>
    </li>

    <br/><br/>

    <li>Usage:
<pre><code>&lt;button appResetDefault&gt;Clear&lt;/button&gt;</code></pre>

    This becomes:
<pre><code>&lt;button type="reset"&gt;Clear&lt;/button&gt;</code></pre>
    </li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Can multiple components be applied to one element?</h3>
<ol>
    <li>No — only one component can attach to a single element.</li>
    <br/><br/>

    <li>Directives can stack, but components cannot.</li>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
<!-- * * * * * * * * * * * * * * -->
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
