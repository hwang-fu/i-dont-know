<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>SAP ABAP</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 58px;
        height: 58px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/abap.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#abap-introduction">SAP ABAP</a></li>
        <li><a href="#abap-basic-syntax">Basic Syntax</a></li>
        <li><a href="#abap-data-types">Data Types</a></li>
        <li><a href="#abap-variables">Variables</a></li>
        <li><a href="#abap-constants-literals">Constants and Literals</a></li>
        <li><a href="#abap-operators">Operators</a></li>
        <li><a href="#abap-control-flow">Contrl Flow</a></li>
        <li><a href="#abap-strings">Strings</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-introduction">Introduction to SAP ABAP</h3>
<ol>

    <li>What is ABAP</li>
    <br/>
    <ul>
        <li>ABAP overview:</li>
<pre><code class="language-abap line-numbers">* ABAP = Advanced Business Application Programming
* Proprietary language developed by SAP
* Runs exclusively on SAP Application Server (NetWeaver)

* Key characteristics:
* - Strongly typed, statically checked
* - Built-in database integration (Open SQL)
* - Event-driven programming model
* - Backwards compatible (code from 1990s still runs)

* Two syntax forms exist:
* 1. Classic ABAP (statement-based)
* 2. ABAP 7.40+ (expression-based, more modern)
</code></pre>
        <br/>
        <li>ABAP in the SAP landscape:</li>
        <svg width="600" height="220" xmlns="http://www.w3.org/2000/svg" style="background: #fafafa; border: 1px solid #ddd; border-radius: 4px;">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                </marker>
            </defs>

            <!-- Title -->
            <text x="300" y="25" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold">SAP Three-Tier Architecture</text>

            <!-- Presentation Layer -->
            <rect x="30" y="50" width="160" height="60" fill="#cce5ff" stroke="#0066cc" stroke-width="2" rx="5"/>
            <text x="110" y="75" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Presentation Layer</text>
            <text x="110" y="95" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">SAP GUI / Fiori / Web</text>

            <!-- Application Layer -->
            <rect x="220" y="50" width="160" height="60" fill="#ccffcc" stroke="#009900" stroke-width="2" rx="5"/>
            <text x="300" y="75" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Application Layer</text>
            <text x="300" y="95" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">ABAP runs here</text>

            <!-- Database Layer -->
            <rect x="410" y="50" width="160" height="60" fill="#ffe6cc" stroke="#cc6600" stroke-width="2" rx="5"/>
            <text x="490" y="75" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Database Layer</text>
            <text x="490" y="95" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">HANA / Oracle / DB2</text>

            <!-- Arrows -->
            <line x1="190" y1="80" x2="215" y2="80" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
            <line x1="380" y1="80" x2="405" y2="80" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>

            <!-- ABAP detail box -->
            <rect x="180" y="130" width="240" height="75" fill="#e6ffe6" stroke="#009900" stroke-width="1" rx="3"/>
            <text x="300" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" font-weight="bold">ABAP Application Server</text>
            <text x="200" y="170" font-family="Arial, sans-serif" font-size="9">• Work processes execute ABAP</text>
            <text x="200" y="185" font-family="Arial, sans-serif" font-size="9">• Shared memory for data buffering</text>
            <text x="200" y="200" font-family="Arial, sans-serif" font-size="9">• Open SQL translates to native DB</text>
        </svg>
        <br/><br/>
        <li>ABAP program types:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Code</th>
            <th>Purpose</th>
            <th>Execution</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Executable Program</td>
            <td><code>1</code></td>
            <td>Reports, batch jobs</td>
            <td>Direct (SE38, SA38)</td>
        </tr>
        <tr>
            <td>Module Pool</td>
            <td><code>M</code></td>
            <td>Dialog programs with screens</td>
            <td>Via transaction code</td>
        </tr>
        <tr>
            <td>Function Group</td>
            <td><code>F</code></td>
            <td>Container for function modules</td>
            <td>Called by other programs</td>
        </tr>
        <tr>
            <td>Class Pool</td>
            <td><code>K</code></td>
            <td>Global ABAP class</td>
            <td>Instantiated/called</td>
        </tr>
        <tr>
            <td>Interface Pool</td>
            <td><code>J</code></td>
            <td>Global interface definition</td>
            <td>Implemented by classes</td>
        </tr>
        <tr>
            <td>Include</td>
            <td><code>I</code></td>
            <td>Reusable code fragment</td>
            <td>Included in other programs</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Development Environment</li>
    <br/>
    <ul>
        <li>SE80 - ABAP Workbench (classic):</li>
<pre><code class="language-text line-numbers">Transaction Codes for Development:
SE80  - Object Navigator (main development hub)
SE38  - ABAP Editor (programs only)
SE37  - Function Builder
SE24  - Class Builder
SE11  - Data Dictionary (tables, structures, data elements)
SE16  - Data Browser (view table contents)
ST22  - ABAP Dump Analysis (runtime errors)
SE91  - Message Maintenance

Navigation in SE80:
1. Enter program/class/function group name
2. Double-click to navigate to definitions
3. F3 = Back, Ctrl+F3 = Check syntax
4. Ctrl+F2 = Activate, F8 = Execute
</code></pre>
        <br/>
        <li>ABAP Development Tools (ADT) - Eclipse-based:</li>
<pre><code class="language-text line-numbers">Modern IDE features:
- Code completion (Ctrl+Space)
- Inline error checking
- Refactoring tools
- Git integration
- Multiple system connections

Installation:
1. Download Eclipse (latest supported version)
2. Help → Install New Software
3. Add SAP repository: https://tools.hana.ondemand.com/latest
4. Install "ABAP Development Tools"

Project setup:
1. File → New → ABAP Project
2. Enter system connection details
3. Provide SAP credentials
4. Select package for development
</code></pre>
        <br/>
        <li>Transport system overview:</li>
        <svg width="600" height="200" xmlns="http://www.w3.org/2000/svg" style="background: #fafafa; border: 1px solid #ddd; border-radius: 4px;">
            <!-- Title -->
            <text x="300" y="25" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold">SAP Transport Landscape</text>

            <!-- DEV -->
            <rect x="50" y="60" width="120" height="70" fill="#ccffcc" stroke="#009900" stroke-width="2" rx="5"/>
            <text x="110" y="85" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Development</text>
            <text x="110" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">(DEV)</text>
            <text x="110" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">Write code here</text>

            <!-- QAS -->
            <rect x="240" y="60" width="120" height="70" fill="#ffffcc" stroke="#999900" stroke-width="2" rx="5"/>
            <text x="300" y="85" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Quality</text>
            <text x="300" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">(QAS)</text>
            <text x="300" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">Test here</text>

            <!-- PRD -->
            <rect x="430" y="60" width="120" height="70" fill="#ffcccc" stroke="#cc0000" stroke-width="2" rx="5"/>
            <text x="490" y="85" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Production</text>
            <text x="490" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">(PRD)</text>
            <text x="490" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="9">Live system</text>

            <!-- Arrows -->
            <line x1="170" y1="95" x2="235" y2="95" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
            <text x="202" y="88" text-anchor="middle" font-family="Arial, sans-serif" font-size="8">Transport</text>

            <line x1="360" y1="95" x2="425" y2="95" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
            <text x="392" y="88" text-anchor="middle" font-family="Arial, sans-serif" font-size="8">Transport</text>

            <!-- Note -->
            <rect x="100" y="150" width="400" height="35" fill="#f5f5f5" stroke="#ccc" stroke-width="1" rx="3"/>
            <text x="300" y="172" text-anchor="middle" font-family="Arial, sans-serif" font-size="10">All changes are recorded in transport requests and moved through the landscape</text>
        </svg>
        <br/><br/>
        <li>Package and transport request:</li>
<pre><code class="language-abap line-numbers">* When creating any object, you specify:
* 1. Package - logical container for related objects
* 2. Transport request - moves objects between systems

* Package types:
* $TMP        - Local, temporary (not transportable)
* ZPACKAGE    - Customer package (Z/Y namespace)
* /NAMESPACE/ - Registered namespace

* Transport request format: &lt;SID&gt;K9&lt;number&gt;
* Example: DEVK900123

* Best practice:
* - Use meaningful package names (Z_FI_REPORTING)
* - One transport per logical change
* - Document transport descriptions clearly
</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Syntax</li>
    <br/>
    <ul>
        <li>Statement structure:</li>
<pre><code class="language-abap line-numbers">* Every ABAP statement ends with a period
DATA lv_name TYPE string.

* Statements can span multiple lines
DATA lv_long_variable_name
     TYPE string
     VALUE 'Initial value'.

* Chain statements (classic, less preferred now)
DATA: lv_var1 TYPE i,
      lv_var2 TYPE string,
      lv_var3 TYPE c LENGTH 10.

* Comments
* This is a full-line comment (asterisk in column 1)
DATA lv_x TYPE i. "This is an end-of-line comment

* Case insensitivity
* DATA, Data, data are all the same
* But convention: KEYWORDS uppercase, variables lowercase
</code></pre>
        <br/>
        <li>Variable declaration:</li>
<pre><code class="language-abap line-numbers">* Classic declaration
DATA lv_counter TYPE i.           "Integer
DATA lv_amount TYPE p DECIMALS 2. "Packed decimal
DATA lv_name TYPE string.         "Variable length string
DATA lv_flag TYPE c LENGTH 1.     "Fixed character

* With initial value
DATA lv_status TYPE c LENGTH 1 VALUE 'A'.
DATA lv_pi TYPE p DECIMALS 5 VALUE '3.14159'.

* Modern inline declaration (ABAP 7.40+)
DATA(lv_result) = 100.            "Type inferred as i
DATA(lv_text) = |Hello World|.    "Type inferred as string

* Constants
CONSTANTS c_max_items TYPE i VALUE 999.
CONSTANTS c_company TYPE c LENGTH 4 VALUE 'SAP'.

* Field symbols (like pointers/references)
FIELD-SYMBOLS &lt;fs_any&gt; TYPE any.
FIELD-SYMBOLS &lt;fs_line&gt; TYPE mara.  "Typed field symbol
</code></pre>
        <br/>
        <li>Elementary data types:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Description</th>
            <th>Default Length</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>C</code></td>
            <td>Fixed-length character</td>
            <td>1</td>
            <td><code>'ABCD'</code></td>
        </tr>
        <tr>
            <td><code>N</code></td>
            <td>Numeric text (digits only)</td>
            <td>1</td>
            <td><code>'001234'</code></td>
        </tr>
        <tr>
            <td><code>I</code></td>
            <td>Integer (4 bytes)</td>
            <td>4</td>
            <td><code>12345</code></td>
        </tr>
        <tr>
            <td><code>P</code></td>
            <td>Packed decimal</td>
            <td>8</td>
            <td><code>123.45</code></td>
        </tr>
        <tr>
            <td><code>F</code></td>
            <td>Floating point (8 bytes)</td>
            <td>8</td>
            <td><code>'3.14E+00'</code></td>
        </tr>
        <tr>
            <td><code>D</code></td>
            <td>Date (YYYYMMDD)</td>
            <td>8</td>
            <td><code>'20241215'</code></td>
        </tr>
        <tr>
            <td><code>T</code></td>
            <td>Time (HHMMSS)</td>
            <td>6</td>
            <td><code>'143052'</code></td>
        </tr>
        <tr>
            <td><code>STRING</code></td>
            <td>Variable-length string</td>
            <td>Variable</td>
            <td><code>`Any length`</code></td>
        </tr>
        <tr>
            <td><code>XSTRING</code></td>
            <td>Variable-length byte sequence</td>
            <td>Variable</td>
            <td>Binary data</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>String templates (ABAP 7.40+):</li>
<pre><code class="language-abap line-numbers">* String templates use | delimiters
DATA(lv_greeting) = |Hello World|.

* Embedded expressions in { }
DATA(lv_name) = 'Alice'.
DATA(lv_msg) = |Hello { lv_name }!|. "Hello Alice!

* Formatting options
DATA(lv_num) = 1234567.
DATA(lv_formatted) = |Amount: { lv_num NUMBER = USER }|.

* Date formatting
DATA(lv_date) = sy-datum.
DATA(lv_date_str) = |Today: { lv_date DATE = USER }|.

* Width and alignment
DATA(lv_padded) = |{ lv_name WIDTH = 10 ALIGN = LEFT PAD = '_' }|.
" Result: 'Alice_____'

* Combining multiple expressions
DATA(lv_full) = |Name: { lv_name }, Date: { sy-datum DATE = ISO }|.
</code></pre>
        <br/>
        <li>Control structures:</li>
<pre><code class="language-abap line-numbers">* IF statement
IF lv_amount &gt; 1000.
  lv_status = 'H'.  "High
ELSEIF lv_amount &gt; 100.
  lv_status = 'M'.  "Medium
ELSE.
  lv_status = 'L'.  "Low
ENDIF.

* CASE statement
CASE lv_status.
  WHEN 'H'.
    WRITE: / 'High value'.
  WHEN 'M'.
    WRITE: / 'Medium value'.
  WHEN 'L'.
    WRITE: / 'Low value'.
  WHEN OTHERS.
    WRITE: / 'Unknown'.
ENDCASE.

* DO loop (fixed iterations)
DO 10 TIMES.
  WRITE: / sy-index.  "sy-index = current iteration (1-based)
ENDDO.

* WHILE loop
lv_counter = 0.
WHILE lv_counter &lt; 10.
  lv_counter = lv_counter + 1.
ENDWHILE.

* LOOP AT (for internal tables - see later section)
LOOP AT lt_data INTO ls_line.
  WRITE: / ls_line-field1.
ENDLOOP.
</code></pre>
        <br/>
        <li>Modern expressions (ABAP 7.40+):</li>
<pre><code class="language-abap line-numbers">* Conditional expression (COND)
DATA(lv_grade) = COND string(
  WHEN lv_score &gt;= 90 THEN 'A'
  WHEN lv_score &gt;= 80 THEN 'B'
  WHEN lv_score &gt;= 70 THEN 'C'
  ELSE 'F' ).

* Switch expression (SWITCH)
DATA(lv_day_name) = SWITCH string( lv_day_num
  WHEN 1 THEN 'Monday'
  WHEN 2 THEN 'Tuesday'
  WHEN 3 THEN 'Wednesday'
  WHEN 4 THEN 'Thursday'
  WHEN 5 THEN 'Friday'
  ELSE 'Weekend' ).

* Constructor expressions
DATA(lt_numbers) = VALUE int4_table( ( 1 ) ( 2 ) ( 3 ) ).

* Iteration expression
DATA(lt_doubled) = VALUE int4_table(
  FOR wa IN lt_numbers ( wa * 2 ) ).

* Corresponding - map fields by name
ls_target = CORRESPONDING #( ls_source ).
</code></pre>
    </ul>
    <br/><br/>


    <li>Program Structure</li>
    <br/>
    <ul>
        <li>Minimal executable program:</li>
<pre><code class="language-abap line-numbers">REPORT zmy_first_program.

* Global data declarations
DATA: gv_message TYPE string.

* Initialization event (runs once at start)
INITIALIZATION.
  gv_message = 'Program started'.

* Start of selection (main processing)
START-OF-SELECTION.
  WRITE: / gv_message.
  WRITE: / 'Hello, ABAP World!'.
  WRITE: / 'Current date:', sy-datum.
  WRITE: / 'Current time:', sy-uzeit.
</code></pre>
        <br/>
        <li>Report events (execution order):</li>
        <svg width="600" height="300" xmlns="http://www.w3.org/2000/svg" style="background: #fafafa; border: 1px solid #ddd; border-radius: 4px;">
            <!-- Title -->
            <text x="300" y="25" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold">Report Event Sequence</text>

            <!-- Event boxes -->
            <rect x="200" y="45" width="200" height="35" fill="#e6e6ff" stroke="#6600cc" stroke-width="2" rx="5"/>
            <text x="300" y="68" text-anchor="middle" font-family="Arial, sans-serif" font-size="11">LOAD-OF-PROGRAM</text>

            <rect x="200" y="90" width="200" height="35" fill="#cce5ff" stroke="#0066cc" stroke-width="2" rx="5"/>
            <text x="300" y="113" text-anchor="middle" font-family="Arial, sans-serif" font-size="11">INITIALIZATION</text>

            <rect x="200" y="135" width="200" height="35" fill="#ffffcc" stroke="#999900" stroke-width="2" rx="5"/>
            <text x="300" y="158" text-anchor="middle" font-family="Arial, sans-serif" font-size="11">AT SELECTION-SCREEN</text>

            <rect x="200" y="180" width="200" height="35" fill="#ccffcc" stroke="#009900" stroke-width="2" rx="5"/>
            <text x="300" y="203" text-anchor="middle" font-family="Arial, sans-serif" font-size="11">START-OF-SELECTION</text>

            <rect x="200" y="225" width="200" height="35" fill="#ffe6cc" stroke="#cc6600" stroke-width="2" rx="5"/>
            <text x="300" y="248" text-anchor="middle" font-family="Arial, sans-serif" font-size="11">END-OF-SELECTION</text>

            <!-- Arrows -->
            <line x1="300" y1="80" x2="300" y2="88" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
            <line x1="300" y1="125" x2="300" y2="133" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
            <line x1="300" y1="170" x2="300" y2="178" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
            <line x1="300" y1="215" x2="300" y2="223" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>

            <!-- Descriptions -->
            <text x="420" y="68" font-family="Arial, sans-serif" font-size="9" fill="#666">Program loaded into memory</text>
            <text x="420" y="113" font-family="Arial, sans-serif" font-size="9" fill="#666">Set default values</text>
            <text x="420" y="158" font-family="Arial, sans-serif" font-size="9" fill="#666">Validate selection screen</text>
            <text x="420" y="203" font-family="Arial, sans-serif" font-size="9" fill="#666">Main processing logic</text>
            <text x="420" y="248" font-family="Arial, sans-serif" font-size="9" fill="#666">Final processing</text>

            <!-- Note -->
            <text x="300" y="285" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">Most programs only use INITIALIZATION and START-OF-SELECTION</text>
        </svg>
        <br/><br/>
        <li>Selection screen (user input):</li>
<pre><code class="language-abap line-numbers">REPORT zmy_report.

* Single parameters
PARAMETERS: p_matnr TYPE matnr,               "Material number
            p_date  TYPE sy-datum DEFAULT sy-datum,
            p_check AS CHECKBOX DEFAULT 'X'.

* Select-options (ranges)
SELECT-OPTIONS: s_werks FOR mara-werks,       "Plant range
                s_mtart FOR mara-mtart.       "Material type range

* Selection screen blocks
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-001.
  PARAMETERS p_name TYPE string LOWER CASE.
SELECTION-SCREEN END OF BLOCK b1.

* Initialization - set defaults
INITIALIZATION.
  s_mtart-sign   = 'I'.
  s_mtart-option = 'EQ'.
  s_mtart-low    = 'FERT'.
  APPEND s_mtart.

* Validate input
AT SELECTION-SCREEN.
  IF p_matnr IS INITIAL.
    MESSAGE 'Please enter material number' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  " Use parameters and select-options in queries
  SELECT * FROM mara
    WHERE matnr = @p_matnr
      AND werks IN @s_werks
    INTO TABLE @DATA(lt_mara).
</code></pre>
        <br/>
        <li>Modularization with subroutines (FORM):</li>
<pre><code class="language-abap line-numbers">REPORT zmodular_program.

DATA: gv_result TYPE i.

START-OF-SELECTION.
  PERFORM calculate_sum USING 10 20 CHANGING gv_result.
  WRITE: / 'Sum:', gv_result.

  PERFORM display_message USING 'Processing complete'.

*&amp;---------------------------------------------------------------------*
*&amp; Form calculate_sum
*&amp;---------------------------------------------------------------------*
FORM calculate_sum USING pv_a TYPE i
                         pv_b TYPE i
                   CHANGING pv_result TYPE i.
  pv_result = pv_a + pv_b.
ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp; Form display_message
*&amp;---------------------------------------------------------------------*
FORM display_message USING pv_text TYPE string.
  WRITE: / pv_text.
ENDFORM.
</code></pre>
        <br/>
        <li>Modularization with methods (preferred):</li>
<pre><code class="language-abap line-numbers">REPORT zmethod_example.

* Local class definition
CLASS lcl_calculator DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      add IMPORTING iv_a TYPE i
                    iv_b TYPE i
          RETURNING VALUE(rv_result) TYPE i,

      multiply IMPORTING iv_a TYPE i
                         iv_b TYPE i
               RETURNING VALUE(rv_result) TYPE i.
ENDCLASS.

* Local class implementation
CLASS lcl_calculator IMPLEMENTATION.
  METHOD add.
    rv_result = iv_a + iv_b.
  ENDMETHOD.

  METHOD multiply.
    rv_result = iv_a * iv_b.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA(lv_sum) = lcl_calculator=&gt;add( iv_a = 10 iv_b = 20 ).
  DATA(lv_product) = lcl_calculator=&gt;multiply( iv_a = 5 iv_b = 6 ).

  WRITE: / 'Sum:', lv_sum.
  WRITE: / 'Product:', lv_product.
</code></pre>
    </ul>
    <br/><br/>


    <li>Internal Tables</li>
    <br/>
    <ul>
        <li>Internal table concept:</li>
<pre><code class="language-abap line-numbers">* Internal tables = dynamic arrays in memory
* Fundamental ABAP data structure for handling multiple records

* Three components:
* 1. Line type - structure of each row
* 2. Table type - how data is organized (standard/sorted/hashed)
* 3. Key - fields for identification

* Memory visualization:
* +--------+--------+--------+
* | MATNR  | MAKTX  | MEINS  |  &lt;-- Header (optional, deprecated)
* +--------+--------+--------+
* | MAT001 | Widget | EA     |  &lt;-- Line 1
* | MAT002 | Gadget | PC     |  &lt;-- Line 2
* | MAT003 | Part   | KG     |  &lt;-- Line 3
* +--------+--------+--------+
</code></pre>
        <br/>
        <li>Table type comparison:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Access</th>
            <th>Key</th>
            <th>Duplicates</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>STANDARD</td>
            <td>Index or key (linear search)</td>
            <td>Non-unique</td>
            <td>Allowed</td>
            <td>General purpose, small tables</td>
        </tr>
        <tr>
            <td>SORTED</td>
            <td>Index or key (binary search)</td>
            <td>Unique or non-unique</td>
            <td>Depends on key</td>
            <td>Frequent key access, medium tables</td>
        </tr>
        <tr>
            <td>HASHED</td>
            <td>Key only (hash algorithm)</td>
            <td>Unique only</td>
            <td>Not allowed</td>
            <td>Large tables, fast key lookup</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Declaration methods:</li>
<pre><code class="language-abap line-numbers">* Work area (structure) for single line
DATA: ls_material TYPE mara.

* Classic declaration - internal table with header line (obsolete)
DATA: lt_old TYPE TABLE OF mara WITH HEADER LINE.

* Modern declaration - separate work area
DATA: lt_materials TYPE TABLE OF mara,      "Standard table
      ls_mat       TYPE mara.               "Work area

* Sorted table with unique key
DATA: lt_sorted TYPE SORTED TABLE OF mara
        WITH UNIQUE KEY matnr.

* Hashed table
DATA: lt_hashed TYPE HASHED TABLE OF mara
        WITH UNIQUE KEY matnr.

* Inline declaration (7.40+)
SELECT * FROM mara INTO TABLE @DATA(lt_mara_new).

* Table type definition (reusable)
TYPES: tt_materials TYPE STANDARD TABLE OF mara
         WITH NON-UNIQUE KEY matnr.
DATA: lt_mat TYPE tt_materials.
</code></pre>
        <br/>
        <li>Basic operations:</li>
<pre><code class="language-abap line-numbers">* Append a line
ls_material-matnr = 'MAT001'.
ls_material-mtart = 'FERT'.
APPEND ls_material TO lt_materials.

* Modern append with VALUE
APPEND VALUE #( matnr = 'MAT002' mtart = 'HALB' ) TO lt_materials.

* Insert at specific index
INSERT ls_material INTO lt_materials INDEX 1.

* Read by index
READ TABLE lt_materials INTO ls_material INDEX 1.
IF sy-subrc = 0.
  " Found
ENDIF.

* Read by key
READ TABLE lt_materials INTO ls_material
  WITH KEY matnr = 'MAT001'.

* Modern read with inline result (7.40+)
DATA(ls_found) = lt_materials[ matnr = 'MAT001' ].

* Safe read with line_exists (avoid dump on not found)
IF line_exists( lt_materials[ matnr = 'MAT001' ] ).
  DATA(ls_safe) = lt_materials[ matnr = 'MAT001' ].
ENDIF.

* Modify
ls_material-mtart = 'ROH'.
MODIFY TABLE lt_materials FROM ls_material.

* Delete
DELETE lt_materials WHERE mtart = 'ROH'.
DELETE lt_materials INDEX 1.

* Clear table
CLEAR lt_materials.   "Keeps memory allocated
FREE lt_materials.    "Releases memory
</code></pre>
        <br/>
        <li>Loop processing:</li>
<pre><code class="language-abap line-numbers">* Classic loop with work area
LOOP AT lt_materials INTO ls_material.
  WRITE: / ls_material-matnr, ls_material-mtart.
ENDLOOP.

* Loop with field symbol (better performance, direct access)
LOOP AT lt_materials ASSIGNING FIELD-SYMBOL(&lt;fs_mat&gt;).
  &lt;fs_mat&gt;-mtart = 'NEW'.  "Directly modifies table
  WRITE: / &lt;fs_mat&gt;-matnr.
ENDLOOP.

* Loop with inline declaration (7.40+)
LOOP AT lt_materials INTO DATA(ls_line).
  WRITE: / ls_line-matnr.
ENDLOOP.

* Loop with index
LOOP AT lt_materials INTO ls_material.
  WRITE: / sy-tabix, ls_material-matnr.  "sy-tabix = current index
ENDLOOP.

* Loop with condition
LOOP AT lt_materials INTO ls_material
  WHERE mtart = 'FERT'.
  WRITE: / ls_material-matnr.
ENDLOOP.

* Parallel cursor (efficient nested loops)
LOOP AT lt_header INTO DATA(ls_header).
  LOOP AT lt_item INTO DATA(ls_item)
    WHERE docnum = ls_header-docnum.
    " Process item
  ENDLOOP.
ENDLOOP.
</code></pre>
        <br/>
        <li>Table expressions and operations (7.40+):</li>
<pre><code class="language-abap line-numbers">* VALUE constructor - create table with data
DATA(lt_numbers) = VALUE int4_table(
  ( 10 ) ( 20 ) ( 30 ) ( 40 ) ).

* Create table of structures
DATA(lt_persons) = VALUE tt_person(
  ( name = 'Alice' age = 30 )
  ( name = 'Bob'   age = 25 )
  ( name = 'Carol' age = 35 ) ).

* CORRESPONDING - copy matching fields
DATA(lt_target) = CORRESPONDING tt_target( lt_source ).

* FOR iteration expression
DATA(lt_doubled) = VALUE int4_table(
  FOR wa IN lt_numbers ( wa * 2 ) ).

* FOR with WHERE condition
DATA(lt_adults) = VALUE tt_person(
  FOR wa IN lt_persons WHERE ( age &gt;= 18 )
  ( wa ) ).

* FILTER - extract matching entries
DATA(lt_filtered) = FILTER #( lt_persons
  WHERE age &gt; 25 ).

* REDUCE - aggregate values
DATA(lv_sum) = REDUCE i(
  INIT sum = 0
  FOR wa IN lt_numbers
  NEXT sum = sum + wa ).

" Result: 100

* Line exists and line index
IF line_exists( lt_persons[ name = 'Alice' ] ).
  DATA(lv_idx) = line_index( lt_persons[ name = 'Alice' ] ).
ENDIF.
</code></pre>
        <br/>
        <li>Internal table visualization:</li>
        <svg width="600" height="280" xmlns="http://www.w3.org/2000/svg" style="background: #fafafa; border: 1px solid #ddd; border-radius: 4px;">
            <!-- Title -->
            <text x="300" y="25" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold">Internal Table Access Methods</text>

            <!-- Standard Table -->
            <rect x="30" y="50" width="160" height="110" fill="#cce5ff" stroke="#0066cc" stroke-width="2" rx="5"/>
            <text x="110" y="70" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">STANDARD TABLE</text>
            <text x="50" y="90" font-family="Arial, sans-serif" font-size="9">Index: O(1)</text>
            <text x="50" y="105" font-family="Arial, sans-serif" font-size="9">Key: O(n) linear</text>
            <text x="50" y="125" font-family="Arial, sans-serif" font-size="9">Insert: O(1) at end</text>
            <text x="50" y="145" font-family="Arial, sans-serif" font-size="9">Memory: Dynamic</text>

            <!-- Sorted Table -->
            <rect x="220" y="50" width="160" height="110" fill="#ccffcc" stroke="#009900" stroke-width="2" rx="5"/>
            <text x="300" y="70" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">SORTED TABLE</text>
            <text x="240" y="90" font-family="Arial, sans-serif" font-size="9">Index: O(1)</text>
            <text x="240" y="105" font-family="Arial, sans-serif" font-size="9">Key: O(log n) binary</text>
            <text x="240" y="125" font-family="Arial, sans-serif" font-size="9">Insert: O(n) sorted</text>
            <text x="240" y="145" font-family="Arial, sans-serif" font-size="9">Always sorted by key</text>

            <!-- Hashed Table -->
            <rect x="410" y="50" width="160" height="110" fill="#ffe6cc" stroke="#cc6600" stroke-width="2" rx="5"/>
            <text x="490" y="70" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">HASHED TABLE</text>
            <text x="430" y="90" font-family="Arial, sans-serif" font-size="9">Index: Not supported</text>
            <text x="430" y="105" font-family="Arial, sans-serif" font-size="9">Key: O(1) hash</text>
            <text x="430" y="125" font-family="Arial, sans-serif" font-size="9">Insert: O(1) average</text>
            <text x="430" y="145" font-family="Arial, sans-serif" font-size="9">Unique keys only</text>

            <!-- Recommendation box -->
            <rect x="30" y="180" width="540" height="85" fill="#f5f5f5" stroke="#ccc" stroke-width="1" rx="3"/>
            <text x="300" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold">When to Use Each Type</text>
            <text x="50" y="220" font-family="Arial, sans-serif" font-size="9">• STANDARD: Small tables (&lt;100 rows), sequential processing, append-heavy</text>
            <text x="50" y="237" font-family="Arial, sans-serif" font-size="9">• SORTED: Medium tables, need both index and key access, range reads</text>
            <text x="50" y="254" font-family="Arial, sans-serif" font-size="9">• HASHED: Large tables (&gt;1000 rows), key-only access, unique key requirement</text>
        </svg>
    </ul>
    <br/><br/>


    <li>Database Operations (Open SQL)</li>
    <br/>
    <ul>
        <li>Open SQL overview:</li>
<pre><code class="language-abap line-numbers">* Open SQL = SAP's database abstraction layer
* Translates to native SQL for any supported database
* Provides syntax checking at compile time

* Key features:
* - Database-independent syntax
* - Integrated with ABAP type system
* - Automatic client handling (multi-tenant)
* - Buffer integration

* Supported statements:
* SELECT, INSERT, UPDATE, DELETE, MODIFY
</code></pre>
        <br/>
        <li>SELECT basics:</li>
<pre><code class="language-abap line-numbers">* Select single record
SELECT SINGLE * FROM mara
  WHERE matnr = 'MAT001'
  INTO @DATA(ls_material).

IF sy-subrc = 0.
  WRITE: / 'Found:', ls_material-matnr.
ENDIF.

* Select into internal table
SELECT * FROM mara
  WHERE mtart = 'FERT'
  INTO TABLE @DATA(lt_materials).

* Select specific fields
SELECT matnr, mtart, meins
  FROM mara
  WHERE mtart IN @s_mtart
  INTO TABLE @DATA(lt_result).

* Select with join
SELECT m~matnr, m~mtart, t~maktx
  FROM mara AS m
  INNER JOIN makt AS t ON t~matnr = m~matnr
  WHERE m~mtart = 'FERT'
    AND t~spras = @sy-langu
  INTO TABLE @DATA(lt_with_text).

* Select with aggregation
SELECT mtart, COUNT(*) AS count
  FROM mara
  GROUP BY mtart
  INTO TABLE @DATA(lt_counts).
</code></pre>
        <br/>
        <li>Classic vs modern syntax:</li>
<pre><code class="language-abap line-numbers">* Classic syntax (still valid)
SELECT * FROM mara INTO TABLE lt_materials
  WHERE mtart = 'FERT'.

* Modern syntax (7.40+) - @ escapes host variables
SELECT * FROM mara
  INTO TABLE @lt_materials
  WHERE mtart = @lv_type.

* Classic field list
SELECT matnr mtart meins FROM mara INTO TABLE lt_result.

* Modern field list (comma separated)
SELECT matnr, mtart, meins FROM mara INTO TABLE @lt_result.

* Classic - work area loop
SELECT * FROM mara INTO ls_material
  WHERE mtart = 'FERT'.
  WRITE: / ls_material-matnr.
ENDSELECT.

* Modern - package processing (better for large data)
SELECT * FROM mara
  WHERE mtart = 'FERT'
  INTO TABLE @DATA(lt_package) PACKAGE SIZE 1000.
  " Process lt_package
ENDSELECT.
</code></pre>
        <br/>
        <li>INSERT, UPDATE, DELETE:</li>
<pre><code class="language-abap line-numbers">* Insert single row
DATA(ls_new) = VALUE zmytable(
  key_field = 'KEY01'
  data_field = 'Some value'
  created_on = sy-datum ).

INSERT zmytable FROM @ls_new.
IF sy-subrc = 0.
  WRITE: / 'Insert successful'.
ENDIF.

* Insert multiple rows
INSERT zmytable FROM TABLE @lt_new_entries.
" sy-dbcnt = number of rows inserted

* Update by key
ls_new-data_field = 'Updated value'.
UPDATE zmytable FROM @ls_new.

* Update with SET
UPDATE zmytable SET data_field = 'New value'
  WHERE key_field = 'KEY01'.

* Delete by key
DELETE zmytable FROM @ls_new.

* Delete with condition
DELETE FROM zmytable WHERE created_on &lt; @lv_cutoff_date.

* Modify = Insert or Update (upsert)
MODIFY zmytable FROM @ls_data.
MODIFY zmytable FROM TABLE @lt_data.
</code></pre>
        <br/>
        <li>FOR ALL ENTRIES (common pattern):</li>
<pre><code class="language-abap line-numbers">* Get related data for entries in an internal table
* CRITICAL: Always check if driver table is not empty!

IF lt_orders IS NOT INITIAL.
  SELECT vbeln, posnr, matnr, kwmeng
    FROM vbap
    FOR ALL ENTRIES IN @lt_orders
    WHERE vbeln = @lt_orders-vbeln
    INTO TABLE @DATA(lt_items).
ENDIF.

* How it works:
* 1. ABAP sends multiple queries to database
* 2. Results are collected and duplicates removed
* 3. If driver table is empty, ALL records are returned!

* Best practices:
* - Always check IF ... IS NOT INITIAL
* - Remove duplicates from driver table
* - Use for mass data retrieval
* - Consider JOINs for better performance with SAP HANA
</code></pre>
        <br/>
        <li>Open SQL quick reference:</li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Syntax</th>
            <th>sy-subrc</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Select single</td>
            <td><code>SELECT SINGLE ... WHERE ...</code></td>
            <td>0=found, 4=not found</td>
        </tr>
        <tr>
            <td>Select multiple</td>
            <td><code>SELECT ... INTO TABLE ...</code></td>
            <td>0=found, 4=empty</td>
        </tr>
        <tr>
            <td>Insert</td>
            <td><code>INSERT &lt;table&gt; FROM ...</code></td>
            <td>0=success, 4=duplicate key</td>
        </tr>
        <tr>
            <td>Update</td>
            <td><code>UPDATE &lt;table&gt; FROM/SET ...</code></td>
            <td>0=success, 4=not found</td>
        </tr>
        <tr>
            <td>Delete</td>
            <td><code>DELETE &lt;table&gt; FROM/WHERE ...</code></td>
            <td>0=deleted, 4=not found</td>
        </tr>
        <tr>
            <td>Modify</td>
            <td><code>MODIFY &lt;table&gt; FROM ...</code></td>
            <td>Always 0 (insert or update)</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>System Fields</li>
    <br/>
    <ul>
        <li>Commonly used system fields (sy-*):</li>
<pre><code class="language-abap line-numbers">* System fields are in structure SYST, accessed via SY-*

* Return codes
sy-subrc    "Return code (0 = success, others = various errors)
sy-dbcnt    "Number of database rows processed

* Loop counters
sy-tabix    "Current line index in LOOP AT
sy-index    "Current iteration in DO/WHILE

* Date and time
sy-datum    "Current date (YYYYMMDD)
sy-uzeit    "Current time (HHMMSS)
sy-timezone "User's time zone

* User and system
sy-uname    "Current username
sy-langu    "User's logon language
sy-mandt    "Current client (tenant)
sy-sysid    "System ID (DEV, QAS, PRD)

* Program information
sy-repid    "Current program name
sy-tcode    "Current transaction code
sy-cprog    "Calling program name

* Screen-related
sy-dynnr    "Current screen number
sy-pfkey    "Current GUI status

* Message handling
sy-msgty    "Message type (E/W/I/S/A)
sy-msgid    "Message class
sy-msgno    "Message number
sy-msgv1-4  "Message variables
</code></pre>
        <br/>
        <li>Using system fields:</li>
<pre><code class="language-abap line-numbers">* Check operation success
SELECT * FROM mara INTO TABLE @DATA(lt_mara)
  WHERE mtart = 'FERT'.

IF sy-subrc &lt;&gt; 0.
  WRITE: / 'No materials found'.
ELSE.
  WRITE: / 'Found', sy-dbcnt, 'materials'.
ENDIF.

* Loop index usage
LOOP AT lt_mara INTO DATA(ls_mara).
  IF sy-tabix = 1.
    WRITE: / 'First item:', ls_mara-matnr.
  ENDIF.
  WRITE: / sy-tabix, ls_mara-matnr.
ENDLOOP.

* Date calculations
DATA(lv_yesterday) = sy-datum - 1.
DATA(lv_next_month) = sy-datum + 30.

* User and system info
WRITE: / 'User:', sy-uname.
WRITE: / 'Client:', sy-mandt.
WRITE: / 'System:', sy-sysid.
WRITE: / 'Program:', sy-repid.
</code></pre>
    </ul>
    <br/><br/>


    <li>Error Handling</li>
    <br/>
    <ul>
        <li>Messages:</li>
<pre><code class="language-abap line-numbers">* Message types
* E - Error     (stops processing, requires correction)
* W - Warning   (can be overridden)
* I - Info      (popup, continues after OK)
* S - Success   (status bar, continues)
* A - Abend     (terminates transaction)
* X - Exit      (short dump with message)

* Direct message
MESSAGE 'Material not found' TYPE 'E'.

* Message from message class (SE91)
MESSAGE e001(zmsg_class) WITH lv_matnr.

* Modern syntax
MESSAGE e001(zmsg_class) WITH lv_matnr INTO DATA(lv_msg).

* Inline message (often used with exceptions)
MESSAGE |Material { lv_matnr } not found| TYPE 'E'.
</code></pre>
        <br/>
        <li>Exception handling (TRY-CATCH):</li>
<pre><code class="language-abap line-numbers">* Class-based exceptions (modern approach)
TRY.
    DATA(lv_result) = 100 / lv_divisor.
    WRITE: / 'Result:', lv_result.

  CATCH cx_sy_zerodivide INTO DATA(lx_error).
    WRITE: / 'Error:', lx_error-&gt;get_text( ).

  CATCH cx_root INTO DATA(lx_any).
    " Catch any exception
    WRITE: / 'Unexpected error:', lx_any-&gt;get_text( ).

  CLEANUP.
    " Always executed before leaving TRY block on exception
    " Use for resource cleanup
ENDTRY.

* Raise exception
IF lv_input IS INITIAL.
  RAISE EXCEPTION TYPE cx_sy_illegal_argument
    EXPORTING textid = cx_sy_illegal_argument=&gt;value_missing.
ENDIF.

* Propagate exception (in method signature)
METHODS process
  IMPORTING iv_data TYPE string
  RAISING   cx_custom_exception.
</code></pre>
        <br/>
        <li>Classic exception handling (for older code):</li>
<pre><code class="language-abap line-numbers">* CATCH SYSTEM-EXCEPTIONS (classic, limited)
DATA lv_result TYPE i.

CATCH SYSTEM-EXCEPTIONS arithmetic_errors = 1
                         others = 2.
  lv_result = 100 / 0.
ENDCATCH.

CASE sy-subrc.
  WHEN 1.
    WRITE: / 'Arithmetic error'.
  WHEN 2.
    WRITE: / 'Other error'.
ENDCASE.

* Function module exceptions (classic)
CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
  EXPORTING
    input  = lv_input
  IMPORTING
    output = lv_output
  EXCEPTIONS
    not_found = 1
    OTHERS    = 2.

IF sy-subrc &lt;&gt; 0.
  " Handle error
ENDIF.
</code></pre>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-basic-syntax">Basic Syntax in ABAP</h3>
<ol>

    <li>Statement Structure</li>
    <br/>
    <ul>
        <li>The period rule:</li>
<pre><code class="language-abap line-numbers">* Every statement ends with a period. No exceptions.
DATA lv_count TYPE i.
lv_count = 42.
WRITE lv_count.
</code></pre>
        <br/>
        <li>Statements can span lines freely:</li>
<pre><code class="language-abap line-numbers">DATA lv_very_long_variable_name
     TYPE string
     VALUE 'Hello'.
</code></pre>
        <br/>
        <li>Chain statements (colon + commas):</li>
<pre><code class="language-abap line-numbers">* Instead of:
DATA lv_a TYPE i.
DATA lv_b TYPE i.
DATA lv_c TYPE i.

* You can write:
DATA: lv_a TYPE i,
      lv_b TYPE i,
      lv_c TYPE i.

* Also works with WRITE:
WRITE: / lv_a, / lv_b, / lv_c.
</code></pre>
        <br/>
        <li>Comments:</li>
<pre><code class="language-abap line-numbers">* Asterisk in column 1 = full line comment
DATA lv_x TYPE i. "Double quote = end of line comment
</code></pre>
        <br/>
        <li>Case insensitivity:</li>
<pre><code class="language-abap line-numbers">* These are identical:
DATA lv_name TYPE string.
data lv_name type string.
Data Lv_Name Type String.

* Convention: KEYWORDS uppercase, variables lowercase
</code></pre>
    </ul>
    <br/><br/>


    <li>Variables and Types</li>
    <br/>
    <ul>
        <li>Declaration:</li>
<pre><code class="language-abap line-numbers">DATA lv_count  TYPE i.              "integer (4 bytes)
DATA lv_amount TYPE p DECIMALS 2.   "packed decimal (BCD)
DATA lv_name   TYPE string.         "variable length
DATA lv_code   TYPE c LENGTH 10.    "fixed length char
DATA lv_date   TYPE d.              "date: YYYYMMDD
DATA lv_time   TYPE t.              "time: HHMMSS
</code></pre>
        <br/>
        <li>Elementary types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Meaning</th>
            <th>Similar to</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>i</code></td>
            <td>Integer</td>
            <td>int32</td>
        </tr>
        <tr>
            <td><code>int8</code></td>
            <td>64-bit integer</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><code>p</code></td>
            <td>Packed decimal (BCD)</td>
            <td>decimal (C#)</td>
        </tr>
        <tr>
            <td><code>f</code></td>
            <td>Floating point</td>
            <td>double</td>
        </tr>
        <tr>
            <td><code>c</code></td>
            <td>Fixed-length character</td>
            <td>char[n]</td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>Numeric text (digits only)</td>
            <td>—</td>
        </tr>
        <tr>
            <td><code>string</code></td>
            <td>Variable-length string</td>
            <td>std::string</td>
        </tr>
        <tr>
            <td><code>d</code></td>
            <td>Date (8 chars: YYYYMMDD)</td>
            <td>—</td>
        </tr>
        <tr>
            <td><code>t</code></td>
            <td>Time (6 chars: HHMMSS)</td>
            <td>—</td>
        </tr>
        <tr>
            <td><code>x</code></td>
            <td>Fixed-length byte</td>
            <td>byte[n]</td>
        </tr>
        <tr>
            <td><code>xstring</code></td>
            <td>Variable-length byte</td>
            <td>byte[]</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Initial values and constants:</li>
<pre><code class="language-abap line-numbers">DATA lv_status TYPE c LENGTH 1 VALUE 'A'.
DATA lv_pi     TYPE p DECIMALS 5 VALUE '3.14159'.

CONSTANTS c_max TYPE i VALUE 100.

* Check if variable has default value
IF lv_count IS INITIAL.
  " i is initial when = 0, string when empty, etc.
ENDIF.
</code></pre>
        <br/>
        <li>Inline declaration (ABAP 7.40+):</li>
<pre><code class="language-abap line-numbers">* Type inferred from right side
DATA(lv_num) = 42.            "i
DATA(lv_txt) = 'Hello'.       "c (length 5)
DATA(lv_str) = |Hello|.       "string
</code></pre>
    </ul>
    <br/><br/>


    <li>Operators</li>
    <br/>
    <ul>
        <li>Arithmetic:</li>
<pre><code class="language-abap line-numbers">lv_result = lv_a + lv_b.
lv_result = lv_a - lv_b.
lv_result = lv_a * lv_b.
lv_result = lv_a / lv_b.
lv_result = lv_a MOD lv_b.    "modulo
lv_result = lv_a DIV lv_b.    "integer division
lv_result = lv_a ** 2.        "power
</code></pre>
        <br/>
        <li>Comparison:</li>
<pre><code class="language-abap line-numbers">* Symbolic         or    Keyword
lv_a = lv_b              lv_a EQ lv_b
lv_a &lt;&gt; lv_b             lv_a NE lv_b
lv_a &lt; lv_b              lv_a LT lv_b
lv_a &gt; lv_b              lv_a GT lv_b
lv_a &lt;= lv_b             lv_a LE lv_b
lv_a &gt;= lv_b             lv_a GE lv_b

* String specific
lv_s CS 'abc'           "contains string
lv_s CP '*test*'        "covers pattern (wildcard)
lv_s CO '0123456789'    "contains only
</code></pre>
        <br/>
        <li>Logical:</li>
<pre><code class="language-abap line-numbers">IF lv_a &gt; 0 AND lv_b &gt; 0.
IF lv_a &gt; 0 OR  lv_b &gt; 0.
IF NOT lv_flag IS INITIAL.
</code></pre>
    </ul>
    <br/><br/>


    <li>Control Flow</li>
    <br/>
    <ul>
        <li>IF:</li>
<pre><code class="language-abap line-numbers">IF lv_amount &gt; 1000.
  lv_status = 'H'.
ELSEIF lv_amount &gt; 100.
  lv_status = 'M'.
ELSE.
  lv_status = 'L'.
ENDIF.
</code></pre>
        <br/>
        <li>CASE:</li>
<pre><code class="language-abap line-numbers">CASE lv_status.
  WHEN 'H'.
    WRITE 'High'.
  WHEN 'M' OR 'L'.
    WRITE 'Not high'.
  WHEN OTHERS.
    WRITE 'Unknown'.
ENDCASE.
</code></pre>
        <br/>
        <li>Loops:</li>
<pre><code class="language-abap line-numbers">* Fixed count
DO 10 TIMES.
  WRITE sy-index.  "1, 2, 3, ... 10
ENDDO.

* Conditional
WHILE lv_count < 10.
  lv_count = lv_count + 1.
ENDWHILE.

* Exit and continue
DO 100 TIMES.
  IF sy-index = 5.
    CONTINUE.  "skip to next iteration
  ENDIF.
  IF sy-index = 50.
    EXIT.      "break out of loop
  ENDIF.
ENDDO.
</code></pre>
    </ul>
    <br/><br/>


    <li>Strings</li>
    <br/>
    <ul>
        <li>Literals:</li>
<pre><code class="language-abap line-numbers">'Text literal'      "type c, trailing spaces trimmed
`Text literal`      "type string, spaces preserved
|Text literal|      "string template (see below)
</code></pre>
        <br/>
        <li>String templates (7.40+):</li>
<pre><code class="language-abap line-numbers">DATA(lv_name) = 'Alice'.
DATA(lv_age)  = 30.

* Embedded expressions with { }
DATA(lv_msg) = |Hello { lv_name }, you are { lv_age }|.

* Formatting
DATA(lv_formatted) = |Date: { sy-datum DATE = USER }|.
DATA(lv_padded)    = |{ lv_name WIDTH = 10 ALIGN = RIGHT }|.
</code></pre>
        <br/>
        <li>Concatenation:</li>
<pre><code class="language-abap line-numbers">* Classic
CONCATENATE lv_first lv_last INTO lv_full SEPARATED BY ' '.

* Modern
lv_full = lv_first &amp;&amp; ' ' &amp;&amp; lv_last.
lv_full = |{ lv_first } { lv_last }|.
</code></pre>
        <br/>
        <li>Common operations:</li>
<pre><code class="language-abap line-numbers">DATA(lv_len)   = strlen( lv_str ).
DATA(lv_upper) = to_upper( lv_str ).
DATA(lv_lower) = to_lower( lv_str ).
DATA(lv_part)  = substring( val = lv_str off = 0 len = 5 ).

* Find and replace
FIND 'abc' IN lv_str MATCH OFFSET DATA(lv_pos).
REPLACE ALL OCCURRENCES OF 'old' IN lv_str WITH 'new'.
</code></pre>
    </ul>
    <br/><br/>


    <li>System Fields</li>
    <br/>
    <ul>
        <li>The sy- structure:</li>
<pre><code class="language-abap line-numbers">* Accessed as sy-fieldname, always available

sy-subrc     "return code of last operation (0 = success)
sy-datum     "current date
sy-uzeit     "current time
sy-uname     "current user
sy-index     "loop counter in DO/WHILE
sy-tabix     "current row in LOOP AT internal table
sy-dbcnt     "rows affected by database operation
</code></pre>
        <br/>
        <li>sy-subrc is everywhere:</li>
<pre><code class="language-abap line-numbers">READ TABLE lt_data INTO ls_row INDEX 5.
IF sy-subrc &lt;&gt; 0.
  WRITE 'Not found'.
ENDIF.

SELECT SINGLE * FROM mara WHERE matnr = 'X' INTO @DATA(ls_mat).
IF sy-subrc &lt;&gt; 0.
  WRITE 'No such material'.
ENDIF.
</code></pre>
    </ul>
    <br/><br/>


    <li>Structures</li>
    <br/>
    <ul>
        <li>Like a C struct:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_person,
         name TYPE string,
         age  TYPE i,
         city TYPE string,
       END OF ty_person.

DATA ls_person TYPE ty_person.

ls_person-name = 'Alice'.
ls_person-age  = 30.
ls_person-city = 'Berlin'.
</code></pre>
        <br/>
        <li>Using dictionary types:</li>
<pre><code class="language-abap line-numbers">* Instead of defining your own structure,
* use existing table structures from the database
DATA ls_material TYPE mara.   "structure of MARA table

ls_material-matnr = 'MAT001'.
ls_material-mtart = 'FERT'.
</code></pre>
    </ul>
    <br/><br/>


    <li>Modern Expression Syntax (7.40+)</li>
    <br/>
    <ul>
        <li>Conditional expressions:</li>
<pre><code class="language-abap line-numbers">* COND - like ternary operator, but chainable
DATA(lv_grade) = COND string(
  WHEN lv_score &gt;= 90 THEN 'A'
  WHEN lv_score &gt;= 80 THEN 'B'
  WHEN lv_score &gt;= 70 THEN 'C'
  ELSE 'F' ).

* SWITCH - pattern matching on single value
DATA(lv_name) = SWITCH string( lv_day
  WHEN 1 THEN 'Monday'
  WHEN 2 THEN 'Tuesday'
  ELSE 'Other' ).
</code></pre>
        <br/>
        <li>Why both styles exist:</li>
<pre><code class="language-text line-numbers">Classic syntax: 1980s-2012
Modern syntax:  ABAP 7.40 (2013) onwards

Existing SAP systems have millions of lines of classic code.
You'll read classic, but write modern when your system supports it.
</code></pre>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-data-types">Data Types in ABAP</h3>
<ol>

    <li>Syntax Basics</li>
    <br/>
    <ul>
        <li>Period (<code>.</code>) - statement terminator:</li>
<pre><code class="language-abap line-numbers">DATA lv_a TYPE i.
DATA lv_b TYPE i.
lv_a = 10.
</code></pre>
<p>Every ABAP statement ends with a period. Forgetting it causes syntax errors.</p>
        <br/>
        <li>Colon (<code>:</code>) and comma (<code>,</code>) - chain statements:</li>
<pre><code class="language-abap line-numbers">* Without chaining:
DATA lv_a TYPE i.
DATA lv_b TYPE i.
DATA lv_c TYPE i.

* With chaining (equivalent):
DATA: lv_a TYPE i,
      lv_b TYPE i,
      lv_c TYPE i.
</code></pre>
<p>Colon after keyword, commas between items, period at end.</p>
        <br/>
        <li>Slash (<code>/</code>) in WRITE - new line:</li>
<pre><code class="language-abap line-numbers">WRITE 'One'.
WRITE 'Two'.
WRITE 'Three'.
</code></pre>
<pre><code class="language-text line-numbers">OneTwoThree
</code></pre>
<pre><code class="language-abap line-numbers">WRITE / 'One'.
WRITE / 'Two'.
WRITE / 'Three'.
</code></pre>
<pre><code class="language-text line-numbers">
One
Two
Three
</code></pre>
<p><code>/</code> means "start new line before printing".</p>
        <br/>
        <li>WRITE with multiple values:</li>
<pre><code class="language-abap line-numbers">DATA lv_a TYPE i VALUE 10.
DATA lv_b TYPE i VALUE 20.

WRITE: / lv_a, lv_b.        "new line, then both values
WRITE: / 'Sum:', lv_a + lv_b.
</code></pre>
<pre><code class="language-text line-numbers">10         20
Sum:       30
</code></pre>
    </ul>
    <br/><br/>


    <li>Type System Overview</li>
    <br/>
    <ul>
        <li>Three categories:</li>
<pre><code class="language-text line-numbers">Elementary types   - single values (integer, string, date)
Complex types      - structures (records) and internal tables (arrays)
Reference types    - pointers to data or objects
</code></pre>
        <br/>
        <li>Two sources of types:</li>
<pre><code class="language-abap line-numbers">* Built-in types (i, c, n, string, d, t, etc.)
DATA lv_num TYPE i.

* DDIC types (defined in Data Dictionary, shared across system)
DATA lv_matnr TYPE matnr.   "material number - defined in SE11
DATA ls_material TYPE mara. "structure of table MARA
</code></pre>
    </ul>
    <br/><br/>


    <li>Integer Types</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE i.      "32-bit signed
DATA &lt;name&gt; TYPE int8.   "64-bit signed (ABAP 7.40+)
</code></pre>
        <br/>
        <li>Type i (32-bit):</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i.

lv_num = 2147483647.       "max value
WRITE: / lv_num.

lv_num = lv_num + 1.       "overflow
WRITE: / lv_num.
</code></pre>
<pre><code class="language-text line-numbers">2147483647
-2147483648
</code></pre>
<p>Range: -2,147,483,648 to 2,147,483,647. Overflow wraps around.</p>
        <br/>
        <li>Type int8 (64-bit):</li>
<pre><code class="language-abap line-numbers">DATA lv_big TYPE int8.

lv_big = 9223372036854775807.  "max value
WRITE: / lv_big.
</code></pre>
<pre><code class="language-text line-numbers">9223372036854775807
</code></pre>
<p>Range: -9.2×10¹⁸ to 9.2×10¹⁸. Use for very large integers.</p>
    </ul>
    <br/><br/>


    <li>Packed Decimal (BCD)</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE p [LENGTH &lt;bytes&gt;] [DECIMALS &lt;places&gt;].

LENGTH  = storage size in bytes (1-16, default 8)
DECIMALS = digits after decimal point (0-14, default 0)
</code></pre>
<p>Each byte holds 2 digits (BCD encoding). Max digits ≈ LENGTH × 2 - 1.</p>
        <br/>
        <li>How LENGTH and DECIMALS work:</li>
<pre><code class="language-abap line-numbers">DATA lv_p1 TYPE p LENGTH 4 DECIMALS 2.  "max ~7 digits, 2 after decimal
DATA lv_p2 TYPE p LENGTH 8 DECIMALS 2.  "max ~15 digits, 2 after decimal

lv_p1 = '12345.67'.
lv_p2 = '1234567890123.45'.

WRITE: / lv_p1.
WRITE: / lv_p2.
</code></pre>
<pre><code class="language-text line-numbers">12345.67
1234567890123.45
</code></pre>
        <br/>
        <li>Rounding behavior:</li>
<pre><code class="language-abap line-numbers">DATA lv_money TYPE p LENGTH 8 DECIMALS 2.

lv_money = '100.456'.
WRITE: / lv_money.

lv_money = '100.454'.
WRITE: / lv_money.
</code></pre>
<pre><code class="language-text line-numbers">100.46
100.45
</code></pre>
<p>Rounds to specified decimal places. Banker's rounding (round half to even).</p>
        <br/>
        <li>Why use packed decimal:</li>
<pre><code class="language-abap line-numbers">DATA lv_float TYPE f.
DATA lv_packed TYPE p DECIMALS 2.

lv_float = '0.1'.
lv_packed = '0.1'.

DO 10 TIMES.
  lv_float = lv_float + '0.1'.
  lv_packed = lv_packed + '0.1'.
ENDDO.

WRITE: / 'Float:', lv_float.
WRITE: / 'Packed:', lv_packed.
</code></pre>
<pre><code class="language-text line-numbers">Float: 1.0999999999999999E+00
Packed: 1.10
</code></pre>
<p>Floating point has precision errors. Packed decimal is exact. Use packed for money.</p>
    </ul>
    <br/><br/>


    <li>Floating Point</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE f.           "64-bit IEEE 754 binary
DATA &lt;name&gt; TYPE decfloat16.  "IEEE 754 decimal, 16 significant digits
DATA &lt;name&gt; TYPE decfloat34.  "IEEE 754 decimal, 34 significant digits
</code></pre>
        <br/>
        <li>Type f (binary float):</li>
<pre><code class="language-abap line-numbers">DATA lv_f TYPE f.

lv_f = '3.14159265358979'.
WRITE: / lv_f.

lv_f = '1.23E+10'.   "scientific notation
WRITE: / lv_f.
</code></pre>
<pre><code class="language-text line-numbers">3.1415926535897900E+00
1.2300000000000000E+10
</code></pre>
<p>~15-17 significant digits. Has precision errors like C/Java double. Use for scientific calculations only.</p>
        <br/>
        <li>Decimal floating point:</li>
<pre><code class="language-abap line-numbers">DATA lv_d16 TYPE decfloat16.
DATA lv_d34 TYPE decfloat34.

lv_d16 = '1234567890123456'.       "16 significant digits
lv_d34 = '1234567890123456789012345678901234'.  "34 significant digits

WRITE: / lv_d16.
WRITE: / lv_d34.
</code></pre>
<pre><code class="language-text line-numbers">1234567890123456
1234567890123456789012345678901234
</code></pre>
<p>"Significant digits" means total digits that matter, regardless of decimal position:</p>
<pre><code class="language-abap line-numbers">DATA lv_d16 TYPE decfloat16.

lv_d16 = '0.0000000000000001'.    "16th digit after zeros - OK
WRITE: / lv_d16.

lv_d16 = '1234567890.123456'.     "10 before + 6 after = 16 - OK
WRITE: / lv_d16.
</code></pre>
<pre><code class="language-text line-numbers">0.0000000000000001
1234567890.123456
</code></pre>
    </ul>
    <br/><br/>


    <li>Character Types</li>
    <br/>
    <ul>
        <li>Type c - fixed length character:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE c [LENGTH &lt;n&gt;].

LENGTH = exact number of characters (1-262143, default 1)
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 10.

lv_c = 'Hello'.
WRITE: / '&gt;', lv_c, '&lt;'.

lv_c = 'Hello World!!!'.
WRITE: / '&gt;', lv_c, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
&gt;Hello Worl
</code></pre>
<p>Short values are right-padded with spaces. Long values are truncated.</p>
        <br/>
        <li>Type string - variable length:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE string.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = 'Hello'.
WRITE: / '&gt;', lv_str, '&lt;'.

lv_str = 'This can be any length without truncation or padding'.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
This can be any length without truncation or padding
</code></pre>
<p>No padding, no truncation. Preferred for text processing.</p>
        <br/>
        <li>Type n - numeric text:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE n [LENGTH &lt;n&gt;].

LENGTH = exact number of digits (1-262143, default 1)
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_n TYPE n LENGTH 10.

lv_n = '123'.
WRITE: / lv_n.

lv_n = 456.          "numeric also works
WRITE: / lv_n.

lv_n = 'ABC123'.     "non-digits become 0
WRITE: / lv_n.
</code></pre>
<pre><code class="language-text line-numbers">0000000123
0000000456
0000000123
</code></pre>
<p>Left-padded with zeros. Only stores digits 0-9. Used for document numbers, IDs.</p>
        <br/>
        <li>Literals - single quote vs backtick vs pipe:</li>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 10.
DATA lv_str TYPE string.

lv_c = 'Hello'.      "type c, trailing spaces trimmed
lv_str = 'Hello'.    "converted to string

lv_str = `Hello  `.  "type string, spaces preserved
WRITE: / '&gt;', lv_str, '&lt;'.

lv_str = |Hello|.    "string template, allows expressions
DATA(lv_name) = 'World'.
lv_str = |Hello { lv_name }|.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
Hello World
</code></pre>
<table>
    <thead>
        <tr>
            <th>Literal</th>
            <th>Type</th>
            <th>Spaces</th>
            <th>Expressions</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>'...'</code></td>
            <td>c</td>
            <td>Trailing trimmed</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>`...`</code></td>
            <td>string</td>
            <td>Preserved</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>|...|</code></td>
            <td>string</td>
            <td>Preserved</td>
            <td>Yes <code>{ }</code></td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Date and Time</li>
    <br/>
    <ul>
        <li>Type d - date:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE d.

Always 8 characters: YYYYMMDD
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_date TYPE d.

lv_date = sy-datum.      "current date
WRITE: / 'Today:', lv_date.

lv_date = '20241225'.    "Christmas 2024
WRITE: / 'Christmas:', lv_date.
</code></pre>
<pre><code class="language-text line-numbers">Today: 20241215
Christmas: 20241225
</code></pre>
        <br/>
        <li>Date arithmetic:</li>
<pre><code class="language-abap line-numbers">DATA lv_date TYPE d VALUE '20241215'.

lv_date = lv_date + 7.    "add 7 days
WRITE: / '+7 days:', lv_date.

lv_date = lv_date - 30.   "subtract 30 days
WRITE: / '-30 days:', lv_date.
</code></pre>
<pre><code class="language-text line-numbers">+7 days: 20241222
-30 days: 20241122
</code></pre>
        <br/>
        <li>Extracting parts (substring):</li>
<pre><code class="language-abap line-numbers">DATA lv_date TYPE d VALUE '20241215'.

DATA(lv_year)  = lv_date+0(4).   "offset 0, length 4
DATA(lv_month) = lv_date+4(2).   "offset 4, length 2
DATA(lv_day)   = lv_date+6(2).   "offset 6, length 2

WRITE: / 'Year:', lv_year, 'Month:', lv_month, 'Day:', lv_day.
</code></pre>
<pre><code class="language-text line-numbers">Year: 2024 Month: 12 Day: 15
</code></pre>
<p>Syntax: <code>variable+offset(length)</code> extracts substring.</p>
        <br/>
        <li>Type t - time:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE t.

Always 6 characters: HHMMSS
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_time TYPE t.

lv_time = sy-uzeit.      "current time
WRITE: / 'Now:', lv_time.

lv_time = '143052'.      "14:30:52
WRITE: / 'Set:', lv_time.

lv_time = lv_time + 3600.  "add 1 hour (3600 seconds)
WRITE: / '+1 hour:', lv_time.
</code></pre>
<pre><code class="language-text line-numbers">Now: 102345
Set: 143052
+1 hour: 153052
</code></pre>
        <br/>
        <li>Timestamp:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE timestamp.    "YYYYMMDDhhmmss as packed decimal
DATA &lt;name&gt; TYPE timestampl.   "with microseconds
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_ts TYPE timestamp.

GET TIME STAMP FIELD lv_ts.
WRITE: / lv_ts.
</code></pre>
<pre><code class="language-text line-numbers">20241215102345
</code></pre>
    </ul>
    <br/><br/>


    <li>Byte Types</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE x [LENGTH &lt;n&gt;].   "fixed length bytes
DATA &lt;name&gt; TYPE xstring.           "variable length bytes
</code></pre>
        <br/>
        <li>Usage:</li>
<pre><code class="language-abap line-numbers">DATA lv_x TYPE x LENGTH 4.
DATA lv_xs TYPE xstring.

lv_x = 'DEADBEEF'.       "hex literal
lv_xs = '48454C4C4F'.    "hex for 'HELLO'

WRITE: / lv_x.
WRITE: / lv_xs.
</code></pre>
<pre><code class="language-text line-numbers">DEADBEEF
48454C4C4F
</code></pre>
<p>For binary data: files, hashes, encoded content. Each byte shown as 2 hex digits.</p>
    </ul>
    <br/><br/>


    <li>Structures</li>
    <br/>
    <ul>
        <li>Syntax - define type then use:</li>
<pre><code class="language-text line-numbers">TYPES: BEGIN OF &lt;type_name&gt;,
         &lt;field1&gt; TYPE &lt;type&gt;,
         &lt;field2&gt; TYPE &lt;type&gt;,
         ...
       END OF &lt;type_name&gt;.

DATA &lt;variable&gt; TYPE &lt;type_name&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_person,
         name TYPE string,
         age  TYPE i,
         city TYPE string,
       END OF ty_person.

DATA ls_person TYPE ty_person.

ls_person-name = 'Alice'.
ls_person-age = 30.
ls_person-city = 'Berlin'.

WRITE: / ls_person-name, ls_person-age, ls_person-city.
</code></pre>
<pre><code class="language-text line-numbers">Alice         30 Berlin
</code></pre>
        <br/>
        <li>Syntax - inline (no separate TYPES):</li>
<pre><code class="language-text line-numbers">DATA: BEGIN OF &lt;name&gt;,
        &lt;field1&gt; TYPE &lt;type&gt;,
        ...
      END OF &lt;name&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">DATA: BEGIN OF ls_point,
        x TYPE i,
        y TYPE i,
      END OF ls_point.

ls_point-x = 10.
ls_point-y = 20.

WRITE: / ls_point-x, ls_point-y.
</code></pre>
<pre><code class="language-text line-numbers">        10         20
</code></pre>
<p>Inline is quick but type not reusable. Prefer TYPES for shared definitions.</p>
        <br/>
        <li>Using DDIC structures:</li>
<pre><code class="language-abap line-numbers">DATA ls_material TYPE mara.   "structure from table MARA

ls_material-matnr = 'MAT001'.
ls_material-mtart = 'FERT'.

WRITE: / ls_material-matnr, ls_material-mtart.
</code></pre>
<pre><code class="language-text line-numbers">MAT001     FERT
</code></pre>
        <br/>
        <li>Nested structures:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_address,
         street TYPE string,
         city   TYPE string,
       END OF ty_address.

TYPES: BEGIN OF ty_person,
         name    TYPE string,
         address TYPE ty_address,
       END OF ty_person.

DATA ls_person TYPE ty_person.

ls_person-name = 'Bob'.
ls_person-address-street = '123 Main St'.
ls_person-address-city = 'Munich'.

WRITE: / ls_person-name.
WRITE: / ls_person-address-city.
</code></pre>
<pre><code class="language-text line-numbers">Bob
Munich
</code></pre>
    </ul>
    <br/><br/>


    <li>Internal Tables</li>
    <br/>
    <ul>
        <li>What they are:</li>
<p>Dynamic arrays in memory. Can grow/shrink. Most important ABAP data structure.</p>
        <br/>
        <li>Syntax - table type:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE [STANDARD|SORTED|HASHED] TABLE OF &lt;row_type&gt;
            [WITH &lt;key_spec&gt;].
</code></pre>
        <br/>
        <li>STANDARD TABLE (default):</li>
<pre><code class="language-abap line-numbers">DATA lt_names TYPE TABLE OF string.

APPEND 'Alice' TO lt_names.
APPEND 'Bob' TO lt_names.
APPEND 'Carol' TO lt_names.

LOOP AT lt_names INTO DATA(lv_name).
  WRITE: / sy-tabix, lv_name.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">         1 Alice
         2 Bob
         3 Carol
</code></pre>
<p>Access by index: O(1). Access by key: O(n) linear scan. Duplicates allowed.</p>
        <br/>
        <li>SORTED TABLE:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_emp,
         id   TYPE i,
         name TYPE string,
       END OF ty_emp.

DATA lt_emp TYPE SORTED TABLE OF ty_emp WITH UNIQUE KEY id.

INSERT VALUE #( id = 3 name = 'Carol' ) INTO TABLE lt_emp.
INSERT VALUE #( id = 1 name = 'Alice' ) INTO TABLE lt_emp.
INSERT VALUE #( id = 2 name = 'Bob' ) INTO TABLE lt_emp.

LOOP AT lt_emp INTO DATA(ls_emp).
  WRITE: / ls_emp-id, ls_emp-name.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">         1 Alice
         2 Bob
         3 Carol
</code></pre>
<p>Automatically sorted by key. Access by key: O(log n) binary search. UNIQUE KEY prevents duplicates.</p>
        <br/>
        <li>HASHED TABLE:</li>
<pre><code class="language-abap line-numbers">DATA lt_emp_hash TYPE HASHED TABLE OF ty_emp WITH UNIQUE KEY id.

INSERT VALUE #( id = 100 name = 'Alice' ) INTO TABLE lt_emp_hash.
INSERT VALUE #( id = 200 name = 'Bob' ) INTO TABLE lt_emp_hash.

READ TABLE lt_emp_hash INTO DATA(ls_found) WITH KEY id = 200.
WRITE: / ls_found-name.
</code></pre>
<pre><code class="language-text line-numbers">Bob
</code></pre>
<p>Access by key: O(1) hash lookup. No index access. Must have UNIQUE KEY.</p>
        <br/>
        <li>Comparison:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Key access</th>
            <th>Index access</th>
            <th>Duplicates</th>
            <th>Best for</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>STANDARD</td>
            <td>O(n)</td>
            <td>O(1)</td>
            <td>Yes</td>
            <td>Small tables, sequential</td>
        </tr>
        <tr>
            <td>SORTED</td>
            <td>O(log n)</td>
            <td>O(1)</td>
            <td>Optional</td>
            <td>Medium, need both</td>
        </tr>
        <tr>
            <td>HASHED</td>
            <td>O(1)</td>
            <td>No</td>
            <td>No</td>
            <td>Large, key-only</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>References</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE REF TO &lt;type&gt;.   "reference to specific type
DATA &lt;name&gt; TYPE REF TO data.     "reference to any data
DATA &lt;name&gt; TYPE REF TO object.   "reference to any object
</code></pre>
        <br/>
        <li>Data references (pointers):</li>
<pre><code class="language-abap line-numbers">DATA lv_value TYPE i VALUE 10.
DATA lr_ref TYPE REF TO i.

lr_ref = REF #( lv_value ).   "get reference

WRITE: / 'Original:', lv_value.
WRITE: / 'Via ref:', lr_ref-&gt;*.

lr_ref-&gt;* = 99.               "modify through reference

WRITE: / 'After:', lv_value.
</code></pre>
<pre><code class="language-text line-numbers">Original:         10
Via ref:         10
After:         99
</code></pre>
<p><code>REF #( )</code> gets address. <code>-&gt;*</code> dereferences.</p>
        <br/>
        <li>Object references:</li>
<pre><code class="language-abap line-numbers">DATA lo_obj TYPE REF TO zcl_myclass.

lo_obj = NEW zcl_myclass( ).      "create instance
lo_obj-&gt;some_method( ).           "call method
</code></pre>
    </ul>
    <br/><br/>


    <li>Field Symbols</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">FIELD-SYMBOLS &lt;&lt;name&gt;&gt; TYPE &lt;type&gt;.
ASSIGN &lt;variable&gt; TO &lt;&lt;name&gt;&gt;.
</code></pre>
<p>Like a pointer that's always dereferenced. Changes affect original variable.</p>
        <br/>
        <li>Basic usage:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 10.
FIELD-SYMBOLS <fs_num> TYPE i.

ASSIGN lv_num TO <fs_num>.

WRITE: / 'Original:', lv_num.
WRITE: / 'Field symbol:', <fs_num>.

<fs_num> = 99.

WRITE: / 'After:', lv_num.
</code></pre>
<pre><code class="language-text line-numbers">Original:         10
Field symbol:         10
After:         99
</code></pre>
        <br/>
        <li>Main use - efficient table loops:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_data,
         id   TYPE i,
         name TYPE string,
       END OF ty_data.

DATA lt_data TYPE TABLE OF ty_data.
APPEND VALUE #( id = 1 name = 'alice' ) TO lt_data.
APPEND VALUE #( id = 2 name = 'bob' ) TO lt_data.

* With INTO - copies each row (slow, changes don't affect table)
LOOP AT lt_data INTO DATA(ls_row).
  ls_row-name = to_upper( ls_row-name ).  "only changes the copy!
ENDLOOP.

LOOP AT lt_data INTO ls_row.
  WRITE: / ls_row-name.   "still lowercase
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">alice
bob
</code></pre>
<pre><code class="language-abap line-numbers">* With ASSIGNING - direct access (fast, changes affect table)
LOOP AT lt_data ASSIGNING FIELD-SYMBOL(<fs_row>).
  <fs_row>-name = to_upper( <fs_row>-name ).  "modifies table directly
ENDLOOP.

LOOP AT lt_data INTO ls_row.
  WRITE: / ls_row-name.   "now uppercase
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">ALICE
BOB
</code></pre>
        <br/>
        <li>Check if assigned:</li>
<pre><code class="language-abap line-numbers">FIELD-SYMBOLS <fs_any> TYPE any.

IF <fs_any> IS ASSIGNED.
  " safe to use
ELSE.
  " not pointing to anything
ENDIF.
</code></pre>
    </ul>
    <br/><br/>


    <li>Type Conversions</li>
    <br/>
    <ul>
        <li>Implicit - automatic:</li>
<pre><code class="language-abap line-numbers">DATA lv_int TYPE i.
DATA lv_str TYPE string.

lv_int = '123'.      "string to int
lv_str = 456.        "int to string

WRITE: / lv_int, lv_str.
</code></pre>
<pre><code class="language-text line-numbers">       123 456
</code></pre>
<p>ABAP converts between compatible types automatically. Can cause silent truncation or unexpected results.</p>
        <br/>
        <li>CONV - explicit conversion:</li>
<pre><code class="language-text line-numbers">CONV &lt;type&gt;( &lt;value&gt; )
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_int TYPE i VALUE 42.

DATA(lv_str) = CONV string( lv_int ).
WRITE: / lv_str.

DATA(lv_back) = CONV i( '999' ).
WRITE: / lv_back.
</code></pre>
<pre><code class="language-text line-numbers">42
       999
</code></pre>
        <br/>
        <li>CORRESPONDING - copy matching fields:</li>
<pre><code class="language-text line-numbers">CORRESPONDING &lt;type&gt;( &lt;source&gt; )
</code></pre>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_source,
         a TYPE i,
         b TYPE i,
         c TYPE i,
       END OF ty_source.

TYPES: BEGIN OF ty_target,
         a TYPE i,
         b TYPE i,
         x TYPE i,
       END OF ty_target.

DATA ls_source TYPE ty_source.
ls_source-a = 1.
ls_source-b = 2.
ls_source-c = 3.

DATA(ls_target) = CORRESPONDING ty_target( ls_source ).

WRITE: / 'a:', ls_target-a.
WRITE: / 'b:', ls_target-b.
WRITE: / 'x:', ls_target-x.
</code></pre>
<pre><code class="language-text line-numbers">a:          1
b:          2
x:          0
</code></pre>
<p>Fields <code>a</code> and <code>b</code> copied (same name). Field <code>c</code> ignored (not in target). Field <code>x</code> initial (not in source).</p>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-variables">Variables in ABAP</h3>
<ol>

    <li>DATA Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE &lt;type&gt; [LENGTH &lt;n&gt;] [DECIMALS &lt;d&gt;] [VALUE &lt;initial&gt;].
</code></pre>
        <br/>
        <li>Basic declaration:</li>
<pre><code class="language-abap line-numbers">DATA lv_count TYPE i.
DATA lv_name TYPE string.

lv_count = 42.
lv_name = 'Alice'.

WRITE: / lv_count, lv_name.
</code></pre>
<pre><code class="language-text line-numbers">42 Alice
</code></pre>
        <br/>
        <li>With initial value:</li>
<pre><code class="language-abap line-numbers">DATA lv_count TYPE i VALUE 100.
DATA lv_name TYPE string VALUE 'Bob'.

WRITE: / lv_count, lv_name.
</code></pre>
<pre><code class="language-text line-numbers">100 Bob
</code></pre>
        <br/>
        <li>With length (for c, n, x types):</li>
<pre><code class="language-abap line-numbers">DATA lv_code TYPE c LENGTH 5.
DATA lv_docnum TYPE n LENGTH 10.

lv_code = 'ABCDEFGH'.    "too long
lv_docnum = '123'.       "too short

WRITE: / lv_code, / lv_docnum.
</code></pre>
<pre><code class="language-text line-numbers">ABCDE
0000000123
</code></pre>
<p><code>c</code> truncates from right. <code>n</code> pads with zeros from left.</p>
        <br/>
        <li>With decimals (for packed decimal):</li>
<pre><code class="language-abap line-numbers">DATA lv_amount TYPE p LENGTH 8 DECIMALS 2.

lv_amount = '1234.567'.

WRITE: / lv_amount.
</code></pre>
<pre><code class="language-text line-numbers">1234.57
</code></pre>
<p>Rounded to 2 decimal places. LENGTH 8 means 8 bytes storage (up to 15 digits).</p>
        <br/>
        <li>Chain declaration:</li>
<pre><code class="language-abap line-numbers">DATA: lv_a TYPE i VALUE 1,
      lv_b TYPE i VALUE 2,
      lv_c TYPE i VALUE 3.

WRITE: / lv_a, lv_b, lv_c.
</code></pre>
<pre><code class="language-text line-numbers">1          2          3
</code></pre>
    </ul>
    <br/><br/>


    <li>Inline Declaration (ABAP 7.40+)</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DATA(&lt;name&gt;) = &lt;expression&gt;.
</code></pre>
<p>Type is inferred from the right side. Cannot specify type or initial value separately.</p>
        <br/>
        <li>From literal:</li>
<pre><code class="language-abap line-numbers">DATA(lv_int) = 42.
DATA(lv_char) = 'Hello'.
DATA(lv_str) = |Hello|.

WRITE: / lv_int, / lv_char, / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">42
Hello
Hello
</code></pre>
<p><code>'Hello'</code> becomes type <code>c LENGTH 5</code>. <code>|Hello|</code> becomes type <code>string</code>.</p>
        <br/>
        <li>From SELECT:</li>
<pre><code class="language-abap line-numbers">SELECT * FROM mara WHERE mtart = 'FERT' INTO TABLE @DATA(lt_materials).

WRITE: / lines( lt_materials ), 'rows'.
</code></pre>
<pre><code class="language-text line-numbers">127 rows
</code></pre>
<p><code>lt_materials</code> gets type <code>TABLE OF mara</code> automatically.</p>
        <br/>
        <li>From LOOP:</li>
<pre><code class="language-abap line-numbers">LOOP AT lt_materials INTO DATA(ls_mat).
  WRITE: / ls_mat-matnr.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">MAT001
MAT002
MAT003
...
</code></pre>
<p><code>ls_mat</code> gets the row type of <code>lt_materials</code>.</p>
    </ul>
    <br/><br/>


    <li>CONSTANTS Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">CONSTANTS &lt;name&gt; TYPE &lt;type&gt; VALUE &lt;value&gt;.
</code></pre>
<p>VALUE is mandatory. Cannot be changed after declaration.</p>
        <br/>
        <li>Usage:</li>
<pre><code class="language-abap line-numbers">CONSTANTS lc_max TYPE i VALUE 100.
CONSTANTS lc_pi TYPE p DECIMALS 5 VALUE '3.14159'.

WRITE: / lc_max, / lc_pi.
</code></pre>
<pre><code class="language-text line-numbers">100
3.14159
</code></pre>
        <br/>
        <li>Attempting to change:</li>
<pre><code class="language-abap line-numbers">lc_max = 200.
</code></pre>
<pre><code class="language-text line-numbers">Syntax error: "LC_MAX" cannot be changed.
</code></pre>
    </ul>
    <br/><br/>


    <li>TYPE vs LIKE</li>
    <br/>
    <ul>
        <li>TYPE - refers to a type definition:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE &lt;type&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i.              "built-in type
DATA lv_matnr TYPE matnr.        "DDIC data element
DATA ls_mat TYPE mara.           "DDIC structure
DATA lt_mat TYPE TABLE OF mara.  "table of DDIC structure
</code></pre>
        <br/>
        <li>LIKE - copies type from existing variable:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; LIKE &lt;variable&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_original TYPE i VALUE 100.
DATA lv_copy LIKE lv_original.

WRITE: / 'original:', lv_original.
WRITE: / 'copy:', lv_copy.
</code></pre>
<pre><code class="language-text line-numbers">original:        100
copy:          0
</code></pre>
<p>Same type (<code>i</code>), but VALUE is not copied. <code>lv_copy</code> gets initial value 0.</p>
        <br/>
        <li>LIKE LINE OF - row type from table:</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; LIKE LINE OF &lt;internal_table&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lt_materials TYPE TABLE OF mara.
DATA ls_single LIKE LINE OF lt_materials.

ls_single-matnr = 'TEST01'.
WRITE: / ls_single-matnr.
</code></pre>
<pre><code class="language-text line-numbers">TEST01
</code></pre>
<p><code>ls_single</code> has type <code>mara</code> (the row type of the table).</p>
    </ul>
    <br/><br/>


    <li>TYPES Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">TYPES &lt;name&gt; TYPE &lt;type&gt; [LENGTH &lt;n&gt;] [DECIMALS &lt;d&gt;].
</code></pre>
<p>Defines a reusable type. No memory allocated. No VALUE allowed.</p>
        <br/>
        <li>Simple type alias:</li>
<pre><code class="language-abap line-numbers">TYPES ty_money TYPE p LENGTH 8 DECIMALS 2.

DATA lv_price TYPE ty_money VALUE '19.99'.
DATA lv_tax TYPE ty_money VALUE '1.60'.
DATA lv_total TYPE ty_money.

lv_total = lv_price + lv_tax.
WRITE: / lv_total.
</code></pre>
<pre><code class="language-text line-numbers">21.59
</code></pre>
        <br/>
        <li>Structure type:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_person,
         name TYPE string,
         age  TYPE i,
       END OF ty_person.

DATA ls_person TYPE ty_person.

ls_person-name = 'Alice'.
ls_person-age = 30.

WRITE: / ls_person-name, ls_person-age.
</code></pre>
<pre><code class="language-text line-numbers">Alice         30
</code></pre>
        <br/>
        <li>Table type:</li>
<pre><code class="language-abap line-numbers">TYPES ty_person_tab TYPE TABLE OF ty_person WITH DEFAULT KEY.

DATA lt_people TYPE ty_person_tab.

APPEND VALUE #( name = 'Alice' age = 30 ) TO lt_people.
APPEND VALUE #( name = 'Bob' age = 25 ) TO lt_people.

WRITE: / lines( lt_people ), 'people'.
</code></pre>
<pre><code class="language-text line-numbers">2 people
</code></pre>
    </ul>
    <br/><br/>


    <li>STATICS Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">STATICS &lt;name&gt; TYPE &lt;type&gt; [VALUE &lt;initial&gt;].
</code></pre>
<p>Like DATA, but retains value between calls. Only inside FORM/METHOD.</p>
        <br/>
        <li>Usage:</li>
<pre><code class="language-abap line-numbers">FORM count_calls.
  STATICS sv_count TYPE i.
  sv_count = sv_count + 1.
  WRITE: / 'Call number:', sv_count.
ENDFORM.

PERFORM count_calls.
PERFORM count_calls.
PERFORM count_calls.
</code></pre>
<pre><code class="language-text line-numbers">Call number:          1
Call number:          2
Call number:          3
</code></pre>
        <br/>
        <li>Compare with DATA:</li>
<pre><code class="language-abap line-numbers">FORM count_calls_data.
  DATA lv_count TYPE i.
  lv_count = lv_count + 1.
  WRITE: / 'Call number:', lv_count.
ENDFORM.

PERFORM count_calls_data.
PERFORM count_calls_data.
PERFORM count_calls_data.
</code></pre>
<pre><code class="language-text line-numbers">Call number:          1
Call number:          1
Call number:          1
</code></pre>
<p>DATA resets to initial value (0) each call. STATICS persists.</p>
    </ul>
    <br/><br/>


    <li>Scope</li>
    <br/>
    <ul>
        <li>Global scope (top of program):</li>
<pre><code class="language-abap line-numbers">REPORT ztest.

DATA gv_global TYPE i VALUE 10.

START-OF-SELECTION.
  WRITE: / 'Before:', gv_global.
  PERFORM change_it.
  WRITE: / 'After:', gv_global.

FORM change_it.
  gv_global = 99.
ENDFORM.
</code></pre>
<pre><code class="language-text line-numbers">Before:         10
After:         99
</code></pre>
        <br/>
        <li>Local scope (inside FORM/METHOD):</li>
<pre><code class="language-abap line-numbers">FORM my_form.
  DATA lv_local TYPE i VALUE 5.
  WRITE: / lv_local.
ENDFORM.

PERFORM my_form.
WRITE: / lv_local.  "syntax error
</code></pre>
<pre><code class="language-text line-numbers">Syntax error: "LV_LOCAL" is unknown.
</code></pre>
        <br/>
        <li>No block scope (important!):</li>
<pre><code class="language-abap line-numbers">FORM test.
  DATA lv_outside TYPE i VALUE 1.

  IF lv_outside = 1.
    DATA lv_inside TYPE i VALUE 100.
  ENDIF.

  WRITE: / lv_inside.  "works!
ENDFORM.
</code></pre>
<pre><code class="language-text line-numbers">100
</code></pre>
<p>DATA is hoisted to the procedure level. There is no block scope in ABAP. The variable exists throughout the entire FORM, regardless of where it's declared.</p>
    </ul>
    <br/><br/>


    <li>Initial Values and CLEAR</li>
    <br/>
    <ul>
        <li>Every type has a default initial value:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Initial value</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>i</code>, <code>int8</code>, <code>p</code>, <code>f</code></td>
            <td>0</td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>c</code></td>
            <td>spaces</td>
            <td><code>'    '</code></td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>zeros</td>
            <td><code>'0000'</code></td>
        </tr>
        <tr>
            <td><code>string</code></td>
            <td>empty</td>
            <td><code>''</code></td>
        </tr>
        <tr>
            <td><code>d</code></td>
            <td>zero date</td>
            <td><code>'00000000'</code></td>
        </tr>
        <tr>
            <td><code>t</code></td>
            <td>zero time</td>
            <td><code>'000000'</code></td>
        </tr>
        <tr>
            <td>reference</td>
            <td>unbound (null)</td>
            <td>—</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>IS INITIAL test:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i.
DATA lv_str TYPE string.

IF lv_num IS INITIAL.
  WRITE: / 'lv_num is initial'.
ENDIF.

lv_str = 'Hello'.
IF lv_str IS NOT INITIAL.
  WRITE: / 'lv_str has value'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">lv_num is initial
lv_str has value
</code></pre>
        <br/>
        <li>CLEAR - reset to initial:</li>
<pre><code class="language-text line-numbers">CLEAR &lt;variable&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 100.
WRITE: / 'Before:', lv_num.
CLEAR lv_num.
WRITE: / 'After:', lv_num.
</code></pre>
<pre><code class="language-text line-numbers">Before:        100
After:          0
</code></pre>
        <br/>
        <li>CLEAR on structures:</li>
<pre><code class="language-abap line-numbers">DATA: BEGIN OF ls_person,
        name TYPE string VALUE 'Alice',
        age  TYPE i VALUE 30,
      END OF ls_person.

WRITE: / ls_person-name, ls_person-age.
CLEAR ls_person.
WRITE: / ls_person-name, ls_person-age.
</code></pre>
<pre><code class="language-text line-numbers">Alice         30
              0
</code></pre>
        <br/>
        <li>CLEAR vs FREE on tables:</li>
<pre><code class="language-abap line-numbers">DATA lt_data TYPE TABLE OF i.
APPEND 1 TO lt_data.
APPEND 2 TO lt_data.

CLEAR lt_data.  "rows removed, memory still allocated
FREE lt_data.   "rows removed, memory released
</code></pre>
<p>Use CLEAR for tables you'll refill. Use FREE when done with the table entirely.</p>
    </ul>
    <br/><br/>


    <li>System Variables (sy-)</li>
    <br/>
    <ul>
        <li>What they are:</li>
<p>Predefined read-only variables in structure <code>SYST</code>. Accessed as <code>sy-&lt;field&gt;</code>. Automatically filled by the runtime.</p>
        <br/>
        <li>Return codes:</li>
<pre><code class="language-abap line-numbers">DATA lt_mat TYPE TABLE OF mara.
SELECT * FROM mara WHERE mtart = 'XXXX' INTO TABLE @lt_mat.

WRITE: / 'sy-subrc:', sy-subrc.
WRITE: / 'sy-dbcnt:', sy-dbcnt.
</code></pre>
<pre><code class="language-text line-numbers">sy-subrc:          4
sy-dbcnt:          0
</code></pre>
<p><code>sy-subrc = 0</code> means success. Non-zero means something went wrong or nothing found. <code>sy-dbcnt</code> = rows affected.</p>
        <br/>
        <li>Date and time:</li>
<pre><code class="language-abap line-numbers">WRITE: / 'Date:', sy-datum.
WRITE: / 'Time:', sy-uzeit.
WRITE: / 'User:', sy-uname.
</code></pre>
<pre><code class="language-text line-numbers">Date: 20241215
Time: 143052
User: JSMITH
</code></pre>
        <br/>
        <li>Loop counters:</li>
<pre><code class="language-abap line-numbers">DO 3 TIMES.
  WRITE: / 'DO iteration:', sy-index.
ENDDO.

DATA lt_nums TYPE TABLE OF i.
APPEND 10 TO lt_nums.
APPEND 20 TO lt_nums.

LOOP AT lt_nums INTO DATA(lv_num).
  WRITE: / 'LOOP row:', sy-tabix, 'value:', lv_num.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">DO iteration:          1
DO iteration:          2
DO iteration:          3
LOOP row:          1 value:         10
LOOP row:          2 value:         20
</code></pre>
<p><code>sy-index</code> for DO/WHILE. <code>sy-tabix</code> for LOOP AT.</p>
        <br/>
        <li>Common pattern:</li>
<pre><code class="language-abap line-numbers">READ TABLE lt_nums INTO DATA(lv_found) INDEX 99.
IF sy-subrc &lt;&gt; 0.
  WRITE: / 'Not found'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Not found
</code></pre>
    </ul>
    <br/><br/>


    <li>Naming Conventions</li>
    <br/>
    <ul>
        <li>Rules:</li>
<pre><code class="language-text line-numbers">- Maximum 30 characters
- Must start with letter
- Only letters, digits, underscore
- Case insensitive (LV_NAME = lv_name)
- Cannot use ABAP reserved words
</code></pre>
        <br/>
        <li>Hungarian notation (widely used):</li>
<table>
    <thead>
        <tr>
            <th>Prefix</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>lv_</code></td>
            <td>Local variable</td>
        </tr>
        <tr>
            <td><code>gv_</code></td>
            <td>Global variable</td>
        </tr>
        <tr>
            <td><code>ls_</code></td>
            <td>Local structure</td>
        </tr>
        <tr>
            <td><code>gs_</code></td>
            <td>Global structure</td>
        </tr>
        <tr>
            <td><code>lt_</code></td>
            <td>Local table</td>
        </tr>
        <tr>
            <td><code>gt_</code></td>
            <td>Global table</td>
        </tr>
        <tr>
            <td><code>lr_</code></td>
            <td>Local reference (data)</td>
        </tr>
        <tr>
            <td><code>lo_</code></td>
            <td>Local object reference</td>
        </tr>
        <tr>
            <td><code>lc_</code></td>
            <td>Local constant</td>
        </tr>
        <tr>
            <td><code>iv_</code></td>
            <td>Importing parameter (value)</td>
        </tr>
        <tr>
            <td><code>ev_</code></td>
            <td>Exporting parameter</td>
        </tr>
        <tr>
            <td><code>cv_</code></td>
            <td>Changing parameter</td>
        </tr>
        <tr>
            <td><code>rv_</code></td>
            <td>Returning value</td>
        </tr>
        <tr>
            <td><code>ty_</code></td>
            <td>Local type</td>
        </tr>
        <tr>
            <td><code>tt_</code></td>
            <td>Table type</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-constants-literals">Constants and Literals in ABAP</h3>
<ol>

    <li>Literals vs Constants</li>
    <br/>
    <ul>
        <li>Definitions:</li>
<pre><code class="language-text line-numbers">Literal  = a value written directly in code (no name)
Constant = a named value that cannot change
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_x TYPE i.

lv_x = 42.           "42 is a literal

CONSTANTS lc_max TYPE i VALUE 100.
lv_x = lc_max.       "lc_max is a constant
</code></pre>
    </ul>
    <br/><br/>


    <li>Numeric Literals</li>
    <br/>
    <ul>
        <li>Integer literals:</li>
<pre><code class="language-abap line-numbers">DATA lv_i TYPE i.

lv_i = 42.
lv_i = -100.
lv_i = 0.

WRITE: / lv_i.
</code></pre>
<pre><code class="language-text line-numbers">0
</code></pre>
<p>No quotes. Just the digits. Negative with minus sign.</p>
        <br/>
        <li>Decimal literals:</li>
<pre><code class="language-abap line-numbers">DATA lv_p TYPE p DECIMALS 2.

lv_p = '123.45'.     "quotes required for decimal
lv_p = '-99.99'.

WRITE: / lv_p.
</code></pre>
<pre><code class="language-text line-numbers">99.99-
</code></pre>
<p>Decimal point requires quotes. Without quotes, <code>123.45</code> is a syntax error.</p>
        <br/>
        <li>Scientific notation:</li>
<pre><code class="language-abap line-numbers">DATA lv_f TYPE f.

lv_f = '1.5E+03'.    "1500
lv_f = '2.5E-02'.    "0.025

WRITE: / lv_f.
</code></pre>
<pre><code class="language-text line-numbers">2.5000000000000001E-02
</code></pre>
    </ul>
    <br/><br/>


    <li>Character Literals</li>
    <br/>
    <ul>
        <li>Three forms:</li>
<table>
    <thead>
        <tr>
            <th>Syntax</th>
            <th>Type</th>
            <th>Trailing spaces</th>
            <th>Expressions</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>'...'</code></td>
            <td>c (fixed length)</td>
            <td>Trimmed</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>`...`</code></td>
            <td>string</td>
            <td>Preserved</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>|...|</code></td>
            <td>string</td>
            <td>Preserved</td>
            <td>Yes <code>{ }</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Single quotes (<code>'...'</code>) - text field literal:</li>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 10.
DATA lv_str TYPE string.

lv_c = 'Hello'.
lv_str = 'Hello'.

WRITE: / '&gt;', lv_c, '&lt;'.
WRITE: / '&gt;', lv_str, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
&gt;Hello
</code></pre>
<p>Type <code>c</code> pads to declared length. When assigned to <code>string</code>, trailing spaces are trimmed.</p>
        <br/>
        <li>Single quotes - trailing spaces trimmed:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = 'Hello   '.    "3 trailing spaces

WRITE: / '&gt;', lv_str, '&lt;'.
WRITE: / 'Length:', strlen( lv_str ).
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
Length:          5
</code></pre>
<p>Spaces at end disappear. This is often unexpected.</p>
        <br/>
        <li>Backticks (<code>`...`</code>) - string literal:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = `Hello   `.    "3 trailing spaces

WRITE: / '&gt;', lv_str, '&lt;'.
WRITE: / 'Length:', strlen( lv_str ).
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
Length:          8
</code></pre>
<p>Spaces preserved. Use backticks when spaces matter.</p>
        <br/>
        <li>Pipes (<code>|...|</code>) - string template:</li>
<pre><code class="language-abap line-numbers">DATA lv_name TYPE string VALUE 'Alice'.
DATA lv_age TYPE i VALUE 30.

DATA(lv_msg) = |Name: { lv_name }, Age: { lv_age }|.

WRITE: / lv_msg.
</code></pre>
<pre><code class="language-text line-numbers">Name: Alice, Age: 30
</code></pre>
<p>Expressions inside <code>{ }</code> are evaluated. Like f-strings in Python or template literals in JavaScript.</p>
        <br/>
        <li>String template formatting:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE p DECIMALS 2 VALUE '1234.50'.
DATA lv_date TYPE d VALUE '20241215'.

WRITE: / |Number: { lv_num }|.
WRITE: / |Formatted: { lv_num NUMBER = USER }|.
WRITE: / |Date: { lv_date }|.
WRITE: / |Formatted: { lv_date DATE = USER }|.
</code></pre>
<pre><code class="language-text line-numbers">Number: 1234.50
Formatted: 1,234.50
Date: 20241215
Formatted: 12/15/2024
</code></pre>
<p><code>NUMBER = USER</code> and <code>DATE = USER</code> format according to user settings.</p>
        <br/>
        <li>String template - width and alignment:</li>
<pre><code class="language-abap line-numbers">DATA lv_name TYPE string VALUE 'Bob'.

WRITE: / |>{ lv_name WIDTH = 10 }<|.
WRITE: / |>{ lv_name WIDTH = 10 ALIGN = LEFT }<|.
WRITE: / |>{ lv_name WIDTH = 10 ALIGN = RIGHT }<|.
WRITE: / |>{ lv_name WIDTH = 10 ALIGN = CENTER }<|.
WRITE: / |>{ lv_name WIDTH = 10 PAD = '_' }<|.
</code></pre>
<pre><code class="language-text line-numbers">>Bob
>Bob
>       Bob
>   Bob
>Bob_______
</code></pre>
        <br/>
        <li>Escaping special characters:</li>
<pre><code class="language-abap line-numbers">* In single quotes - double the quote
DATA(lv_1) = 'It''s OK'.
WRITE: / lv_1.

* In backticks - double the backtick
DATA(lv_2) = `Say ``hello``.
WRITE: / lv_2.

* In pipes - use backslash
DATA(lv_3) = |Pipe: \|, Brace: \{, Backslash: \\|.
WRITE: / lv_3.
</code></pre>
<pre><code class="language-text line-numbers">It's OK
Say `hello`
Pipe: |, Brace: {, Backslash: \
</code></pre>
    </ul>
    <br/><br/>


    <li>Hexadecimal Literals</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">X'&lt;hex_digits&gt;'     "for type x (fixed bytes)
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_x TYPE x LENGTH 4.
DATA lv_xs TYPE xstring.

lv_x = 'DEADBEEF'.
lv_xs = '48454C4C4F'.    "hex for ASCII 'HELLO'

WRITE: / lv_x.
WRITE: / lv_xs.
</code></pre>
<pre><code class="language-text line-numbers">DEADBEEF
48454C4C4F
</code></pre>
<p>Each byte is 2 hex characters. For binary data, raw bytes, hashes.</p>
    </ul>
    <br/><br/>


    <li>CONSTANTS Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">CONSTANTS &lt;name&gt; TYPE &lt;type&gt; VALUE &lt;value&gt;.
CONSTANTS &lt;name&gt; TYPE &lt;type&gt; LENGTH &lt;n&gt; VALUE &lt;value&gt;.
</code></pre>
<p>VALUE is mandatory. Cannot be changed after declaration.</p>
        <br/>
        <li>Basic usage:</li>
<pre><code class="language-abap line-numbers">CONSTANTS lc_pi TYPE p DECIMALS 5 VALUE '3.14159'.
CONSTANTS lc_max_rows TYPE i VALUE 1000.
CONSTANTS lc_company TYPE c LENGTH 4 VALUE 'SAP'.

WRITE: / lc_pi.
WRITE: / lc_max_rows.
WRITE: / lc_company.
</code></pre>
<pre><code class="language-text line-numbers">3.14159
      1000
SAP
</code></pre>
        <br/>
        <li>Attempting to change:</li>
<pre><code class="language-abap line-numbers">CONSTANTS lc_max TYPE i VALUE 100.
lc_max = 200.
</code></pre>
<pre><code class="language-text line-numbers">Syntax error: "LC_MAX" cannot be changed.
</code></pre>
        <br/>
        <li>Chain syntax:</li>
<pre><code class="language-abap line-numbers">CONSTANTS: lc_status_new    TYPE c VALUE 'N',
           lc_status_open   TYPE c VALUE 'O',
           lc_status_closed TYPE c VALUE 'C'.
</code></pre>
        <br/>
        <li>Structure constants:</li>
<pre><code class="language-abap line-numbers">CONSTANTS: BEGIN OF lc_defaults,
             max_items TYPE i VALUE 100,
             currency  TYPE c LENGTH 3 VALUE 'EUR',
           END OF lc_defaults.

WRITE: / lc_defaults-max_items.
WRITE: / lc_defaults-currency.
</code></pre>
<pre><code class="language-text line-numbers">       100
EUR
</code></pre>
    </ul>
    <br/><br/>


    <li>Built-in Constants</li>
    <br/>
    <ul>
        <li>Boolean constants:</li>
<pre><code class="language-abap line-numbers">DATA lv_flag TYPE abap_bool.

lv_flag = abap_true.
WRITE: / 'True:', lv_flag.

lv_flag = abap_false.
WRITE: / 'False:', lv_flag.
</code></pre>
<pre><code class="language-text line-numbers">True: X
False:
</code></pre>
<p><code>abap_true</code> = 'X', <code>abap_false</code> = ' ' (space). Type <code>abap_bool</code> is <code>c LENGTH 1</code>.</p>
        <br/>
        <li>Common usage:</li>
<pre><code class="language-abap line-numbers">DATA lv_success TYPE abap_bool.

lv_success = abap_true.

IF lv_success = abap_true.
  WRITE: / 'Success'.
ENDIF.

* Also works (but less readable)
IF lv_success = 'X'.
  WRITE: / 'Also success'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Success
Also success
</code></pre>
        <br/>
        <li>Other built-in constants:</li>
<table>
    <thead>
        <tr>
            <th>Constant</th>
            <th>Value</th>
            <th>Use</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>abap_true</code></td>
            <td>'X'</td>
            <td>Boolean true</td>
        </tr>
        <tr>
            <td><code>abap_false</code></td>
            <td>' '</td>
            <td>Boolean false</td>
        </tr>
        <tr>
            <td><code>abap_undefined</code></td>
            <td>'-'</td>
            <td>Undefined/not applicable</td>
        </tr>
        <tr>
            <td><code>space</code></td>
            <td>' '</td>
            <td>Single space character</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Using space constant:</li>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 1 VALUE 'X'.

IF lv_c = space.
  WRITE: / 'Empty'.
ELSE.
  WRITE: / 'Has value'.
ENDIF.

lv_c = space.    "clear to space
WRITE: / '&gt;', lv_c, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">Has value
&gt;
</code></pre>
    </ul>
    <br/><br/>


    <li>IS INITIAL vs Comparing to space</li>
    <br/>
    <ul>
        <li>The difference:</li>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 1.
DATA lv_str TYPE string.

* For type c, initial value IS space
lv_c = space.
IF lv_c IS INITIAL.
  WRITE: / 'c is initial'.
ENDIF.
IF lv_c = space.
  WRITE: / 'c = space'.
ENDIF.

* For string, initial is empty (not space)
lv_str = ``.
IF lv_str IS INITIAL.
  WRITE: / 'string is initial'.
ENDIF.

lv_str = ` `.    "one space
IF lv_str IS INITIAL.
  WRITE: / 'string with space is initial'.
ELSE.
  WRITE: / 'string with space is NOT initial'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">c is initial
c = space
string is initial
string with space is NOT initial
</code></pre>
<p>For <code>c</code>: initial = filled with spaces.<br/>For <code>string</code>: initial = zero length (empty).</p>
    </ul>
    <br/><br/>


    <li>Literal Type Inference</li>
    <br/>
    <ul>
        <li>What type does a literal have?</li>
<pre><code class="language-abap line-numbers">* Integer literal → type i
DATA(lv_1) = 42.
cl_abap_typedescr=&gt;describe_by_data( lv_1 )-&gt;get_relative_name( ).  "I

* Quoted number → type c
DATA(lv_2) = '42'.
cl_abap_typedescr=&gt;describe_by_data( lv_2 )-&gt;get_relative_name( ).  "C

* Backtick → type string
DATA(lv_3) = `42`.
cl_abap_typedescr=&gt;describe_by_data( lv_3 )-&gt;get_relative_name( ).  "STRING

* Pipe → type string
DATA(lv_4) = |42|.
cl_abap_typedescr=&gt;describe_by_data( lv_4 )-&gt;get_relative_name( ).  "STRING
</code></pre>
        <br/>
        <li>Why it matters:</li>
<pre><code class="language-abap line-numbers">* These are NOT the same
DATA(lv_a) = 42.       "type i (integer)
DATA(lv_b) = '42'.     "type c LENGTH 2 (character)

* Comparison works but types differ
IF lv_a = lv_b.
  WRITE: / 'Equal value'.
ENDIF.

* But behavior differs
DATA(lv_sum_a) = lv_a + 8.    "50 (math)
DATA(lv_sum_b) = lv_b + 8.    "50 (converted then math)

DATA(lv_cat_a) = |{ lv_a }X|.   "'42X'
DATA(lv_cat_b) = lv_b &amp;&amp; 'X'.   "'42X'

WRITE: / lv_sum_a, lv_sum_b.
WRITE: / lv_cat_a, lv_cat_b.
</code></pre>
<pre><code class="language-text line-numbers">        50         50
42X 42X
</code></pre>
    </ul>
    <br/><br/>


    <li>Constants vs Literals - When to Use</li>
    <br/>
    <ul>
        <li>Use constants when:</li>
<pre><code class="language-text line-numbers">- Value is used multiple times
- Value has meaning (give it a name)
- Value might change in future (single place to update)
</code></pre>
<pre><code class="language-abap line-numbers">* Bad - magic numbers
IF lv_status = 'A'.
IF lv_count &gt; 100.

* Good - named constants
CONSTANTS lc_status_active TYPE c VALUE 'A'.
CONSTANTS lc_max_items TYPE i VALUE 100.

IF lv_status = lc_status_active.
IF lv_count &gt; lc_max_items.
</code></pre>
        <br/>
        <li>Use literals when:</li>
<pre><code class="language-text line-numbers">- Value is obvious (0, 1, '', etc.)
- Used only once
- In string templates
</code></pre>
<pre><code class="language-abap line-numbers">lv_count = 0.                    "obvious reset
lv_msg = |Error in line { sy-tabix }|.  "template
</code></pre>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-operators">Operators in ABAP</h3>
<ol>

    <li>Assignment Operator</li>
    <br/>
    <ul>
        <li>Single equals (<code>=</code>):</li>
<pre><code class="language-abap line-numbers">DATA lv_a TYPE i.
DATA lv_b TYPE i.

lv_a = 10.
lv_b = lv_a.

WRITE: / lv_a, lv_b.
</code></pre>
<pre><code class="language-text line-numbers">        10         10
</code></pre>
<p>In ABAP, <code>=</code> is both assignment and comparison. Context determines which.</p>
        <br/>
        <li>Chained assignment (not supported):</li>
<pre><code class="language-abap line-numbers">* This does NOT work in ABAP
lv_a = lv_b = lv_c = 10.   "syntax error

* Must assign separately
lv_a = 10.
lv_b = 10.
lv_c = 10.
</code></pre>
        <br/>
        <li>MOVE - classic alternative:</li>
<pre><code class="language-abap line-numbers">MOVE 10 TO lv_a.       "same as: lv_a = 10.
MOVE lv_a TO lv_b.     "same as: lv_b = lv_a.

WRITE: / lv_a, lv_b.
</code></pre>
<pre><code class="language-text line-numbers">        10         10
</code></pre>
<p><code>MOVE</code> is older syntax. <code>=</code> is preferred in modern code.</p>
    </ul>
    <br/><br/>


    <li>Arithmetic Operators</li>
    <br/>
    <ul>
        <li>Basic operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>+</code></td>
            <td>Addition</td>
            <td><code>5 + 3</code></td>
            <td>8</td>
        </tr>
        <tr>
            <td><code>-</code></td>
            <td>Subtraction</td>
            <td><code>5 - 3</code></td>
            <td>2</td>
        </tr>
        <tr>
            <td><code>*</code></td>
            <td>Multiplication</td>
            <td><code>5 * 3</code></td>
            <td>15</td>
        </tr>
        <tr>
            <td><code>/</code></td>
            <td>Division</td>
            <td><code>7 / 2</code></td>
            <td>3.5</td>
        </tr>
        <tr>
            <td><code>DIV</code></td>
            <td>Integer division</td>
            <td><code>7 DIV 2</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td><code>MOD</code></td>
            <td>Modulo (remainder)</td>
            <td><code>7 MOD 2</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td><code>**</code></td>
            <td>Power</td>
            <td><code>2 ** 3</code></td>
            <td>8</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Examples:</li>
<pre><code class="language-abap line-numbers">DATA lv_result TYPE p DECIMALS 2.

lv_result = 5 + 3.
WRITE: / '5 + 3 =', lv_result.

lv_result = 5 - 3.
WRITE: / '5 - 3 =', lv_result.

lv_result = 5 * 3.
WRITE: / '5 * 3 =', lv_result.

lv_result = 7 / 2.
WRITE: / '7 / 2 =', lv_result.
</code></pre>
<pre><code class="language-text line-numbers">5 + 3 =                 8.00
5 - 3 =                 2.00
5 * 3 =                15.00
7 / 2 =                 3.50
</code></pre>
        <br/>
        <li>DIV vs / (division):</li>
<pre><code class="language-abap line-numbers">DATA lv_i TYPE i.
DATA lv_p TYPE p DECIMALS 2.

lv_i = 7 / 2.        "result truncated to integer
lv_p = 7 / 2.        "result kept as decimal

WRITE: / '7 / 2 into i:', lv_i.
WRITE: / '7 / 2 into p:', lv_p.

lv_i = 7 DIV 2.      "explicit integer division
WRITE: / '7 DIV 2:', lv_i.
</code></pre>
<pre><code class="language-text line-numbers">7 / 2 into i:          3
7 / 2 into p:                 3.50
7 DIV 2:          3
</code></pre>
<p><code>/</code> does decimal division, result depends on target type. <code>DIV</code> always integer division.</p>
        <br/>
        <li>MOD (modulo):</li>
<pre><code class="language-abap line-numbers">DATA lv_i TYPE i.

lv_i = 7 MOD 2.
WRITE: / '7 MOD 2 =', lv_i.

lv_i = 10 MOD 3.
WRITE: / '10 MOD 3 =', lv_i.

lv_i = 8 MOD 4.
WRITE: / '8 MOD 4 =', lv_i.

* Common use: check if even/odd
IF 7 MOD 2 = 0.
  WRITE: / '7 is even'.
ELSE.
  WRITE: / '7 is odd'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">7 MOD 2 =          1
10 MOD 3 =          1
8 MOD 4 =          0
7 is odd
</code></pre>
        <br/>
        <li>Power (**):</li>
<pre><code class="language-abap line-numbers">DATA lv_result TYPE p DECIMALS 2.

lv_result = 2 ** 3.
WRITE: / '2 ** 3 =', lv_result.

lv_result = 10 ** 2.
WRITE: / '10 ** 2 =', lv_result.

lv_result = 9 ** '0.5'.    "square root
WRITE: / '9 ** 0.5 =', lv_result.
</code></pre>
<pre><code class="language-text line-numbers">2 ** 3 =                 8.00
10 ** 2 =               100.00
9 ** 0.5 =                 3.00
</code></pre>
        <br/>
        <li>Operator precedence:</li>
<pre><code class="language-text line-numbers">Highest to lowest:
1. **           (power)
2. *, /, DIV, MOD
3. +, -
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_i TYPE i.

lv_i = 2 + 3 * 4.      "3 * 4 first, then + 2
WRITE: / '2 + 3 * 4 =', lv_i.

lv_i = ( 2 + 3 ) * 4.  "parentheses first
WRITE: / '(2 + 3) * 4 =', lv_i.
</code></pre>
<pre><code class="language-text line-numbers">2 + 3 * 4 =         14
(2 + 3) * 4 =         20
</code></pre>
        <br/>
        <li>Spaces required:</li>
<pre><code class="language-abap line-numbers">* ABAP requires spaces around operators
lv_i = 5+3.    "syntax error
lv_i = 5 + 3.  "correct

lv_i = 10/2.   "syntax error
lv_i = 10 / 2. "correct
</code></pre>
    </ul>
    <br/><br/>


    <li>Comparison Operators</li>
    <br/>
    <ul>
        <li>Two forms (symbol and keyword):</li>
<table>
    <thead>
        <tr>
            <th>Symbol</th>
            <th>Keyword</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>=</code></td>
            <td><code>EQ</code></td>
            <td>Equal</td>
        </tr>
        <tr>
            <td><code>&lt;&gt;</code></td>
            <td><code>NE</code></td>
            <td>Not equal</td>
        </tr>
        <tr>
            <td><code>&lt;</code></td>
            <td><code>LT</code></td>
            <td>Less than</td>
        </tr>
        <tr>
            <td><code>&gt;</code></td>
            <td><code>GT</code></td>
            <td>Greater than</td>
        </tr>
        <tr>
            <td><code>&lt;=</code></td>
            <td><code>LE</code></td>
            <td>Less than or equal</td>
        </tr>
        <tr>
            <td><code>&gt;=</code></td>
            <td><code>GE</code></td>
            <td>Greater than or equal</td>
        </tr>
    </tbody>
</table>
<p>Both forms are equivalent. Use whichever is clearer.</p>
        <br/>
        <li>Examples:</li>
<pre><code class="language-abap line-numbers">DATA lv_a TYPE i VALUE 10.
DATA lv_b TYPE i VALUE 20.

IF lv_a = lv_b.
  WRITE: / 'a = b'.
ENDIF.

IF lv_a &lt;&gt; lv_b.
  WRITE: / 'a &lt;&gt; b'.
ENDIF.

IF lv_a &lt; lv_b.
  WRITE: / 'a &lt; b'.
ENDIF.

IF lv_a &lt;= lv_b.
  WRITE: / 'a &lt;= b'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">a &lt;&gt; b
a &lt; b
a &lt;= b
</code></pre>
        <br/>
        <li>Using keyword form:</li>
<pre><code class="language-abap line-numbers">IF lv_a EQ lv_b.
  WRITE: / 'Equal'.
ENDIF.

IF lv_a NE lv_b.
  WRITE: / 'Not equal'.
ENDIF.

IF lv_a LT lv_b.
  WRITE: / 'Less than'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Not equal
Less than
</code></pre>
        <br/>
        <li>String comparison:</li>
<pre><code class="language-abap line-numbers">DATA lv_s1 TYPE string VALUE 'ABC'.
DATA lv_s2 TYPE string VALUE 'ABD'.

IF lv_s1 &lt; lv_s2.
  WRITE: / 'ABC &lt; ABD'.
ENDIF.

IF 'apple' &lt; 'banana'.
  WRITE: / 'apple &lt; banana'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">ABC < ABD
apple &lt; banana
</code></pre>
<p>Strings compared lexicographically (character by character).</p>
        <br/>
        <li>Type c comparison - trailing spaces:</li>
<pre><code class="language-abap line-numbers">DATA lv_c1 TYPE c LENGTH 10 VALUE 'ABC'.
DATA lv_c2 TYPE c LENGTH 5 VALUE 'ABC'.

IF lv_c1 = lv_c2.
  WRITE: / 'Equal (spaces ignored)'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Equal (spaces ignored)
</code></pre>
<p>For type <code>c</code>, trailing spaces are ignored in comparison.</p>
    </ul>
    <br/><br/>


    <li>Logical Operators</li>
    <br/>
    <ul>
        <li>Operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>AND</code></td>
            <td>Both must be true</td>
        </tr>
        <tr>
            <td><code>OR</code></td>
            <td>At least one must be true</td>
        </tr>
        <tr>
            <td><code>NOT</code></td>
            <td>Negation</td>
        </tr>
        <tr>
            <td><code>EQUIV</code></td>
            <td>Both same (both true or both false)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>AND:</li>
<pre><code class="language-abap line-numbers">DATA lv_a TYPE i VALUE 10.
DATA lv_b TYPE i VALUE 20.

IF lv_a &gt; 5 AND lv_b &gt; 15.
  WRITE: / 'Both conditions true'.
ENDIF.

IF lv_a &gt; 5 AND lv_b &gt; 25.
  WRITE: / 'This will not print'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Both conditions true
</code></pre>
        <br/>
        <li>OR:</li>
<pre><code class="language-abap line-numbers">DATA lv_status TYPE c VALUE 'A'.

IF lv_status = 'A' OR lv_status = 'B'.
  WRITE: / 'Status is A or B'.
ENDIF.

IF lv_status = 'X' OR lv_status = 'Y'.
  WRITE: / 'This will not print'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Status is A or B
</code></pre>
        <br/>
        <li>NOT:</li>
<pre><code class="language-abap line-numbers">DATA lv_flag TYPE abap_bool VALUE abap_false.

IF NOT lv_flag = abap_true.
  WRITE: / 'Flag is not true'.
ENDIF.

* Cleaner way
IF lv_flag &lt;&gt; abap_true.
  WRITE: / 'Flag is not true (cleaner)'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Flag is not true
Flag is not true (cleaner)
</code></pre>
        <br/>
        <li>Combining operators:</li>
<pre><code class="language-abap line-numbers">DATA lv_age TYPE i VALUE 25.
DATA lv_status TYPE c VALUE 'A'.

IF ( lv_age &gt;= 18 AND lv_age &lt;= 65 ) AND lv_status = 'A'.
  WRITE: / 'Adult with active status'.
ENDIF.

IF lv_age &lt; 18 OR lv_age &gt; 65 OR lv_status &lt;&gt; 'A'.
  WRITE: / 'Does not qualify'.
ELSE.
  WRITE: / 'Qualifies'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Adult with active status
Qualifies
</code></pre>
        <br/>
        <li>Precedence:</li>
<pre><code class="language-text line-numbers">Highest to lowest:
1. NOT
2. AND
3. OR
</code></pre>
<pre><code class="language-abap line-numbers">* These are different:
IF a OR b AND c.       "means: a OR (b AND c)
IF ( a OR b ) AND c.   "means: (a OR b) AND c

* Use parentheses to be explicit
</code></pre>
    </ul>
    <br/><br/>


    <li>Special Comparison Operators</li>
    <br/>
    <ul>
        <li>IS INITIAL:</li>
<pre><code class="language-abap line-numbers">DATA lv_i TYPE i.
DATA lv_s TYPE string.

IF lv_i IS INITIAL.
  WRITE: / 'Integer is initial (0)'.
ENDIF.

IF lv_s IS INITIAL.
  WRITE: / 'String is initial (empty)'.
ENDIF.

lv_s = 'Hello'.
IF lv_s IS NOT INITIAL.
  WRITE: / 'String has value'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Integer is initial (0)
String is initial (empty)
String has value
</code></pre>
        <br/>
        <li>IS BOUND (for references):</li>
<pre><code class="language-abap line-numbers">DATA lr_ref TYPE REF TO i.

IF lr_ref IS INITIAL.
  WRITE: / 'Reference is initial (null)'.
ENDIF.

IF lr_ref IS NOT BOUND.
  WRITE: / 'Reference is not bound'.
ENDIF.

DATA lv_num TYPE i VALUE 10.
lr_ref = REF #( lv_num ).

IF lr_ref IS BOUND.
  WRITE: / 'Reference is bound'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Reference is initial (null)
Reference is not bound
Reference is bound
</code></pre>
        <br/>
        <li>IS ASSIGNED (for field symbols):</li>
<pre><code class="language-abap line-numbers">FIELD-SYMBOLS <fs> TYPE i.

IF <fs> IS NOT ASSIGNED.
  WRITE: / 'Field symbol not assigned'.
ENDIF.

DATA lv_num TYPE i VALUE 42.
ASSIGN lv_num TO <fs>.

IF <fs> IS ASSIGNED.
  WRITE: / 'Field symbol assigned, value:', <fs>.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Field symbol not assigned
Field symbol assigned, value:         42
</code></pre>
        <br/>
        <li>IS INSTANCE OF (for objects):</li>
<pre><code class="language-abap line-numbers">DATA lo_obj TYPE REF TO object.

lo_obj = NEW zcl_child( ).

IF lo_obj IS INSTANCE OF zcl_parent.
  WRITE: / 'Object is instance of zcl_parent'.
ENDIF.

IF lo_obj IS INSTANCE OF zcl_child.
  WRITE: / 'Object is instance of zcl_child'.
ENDIF.
</code></pre>
        <br/>
        <li>BETWEEN:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 50.

IF lv_num BETWEEN 1 AND 100.
  WRITE: / 'Number is between 1 and 100'.
ENDIF.

IF lv_num NOT BETWEEN 60 AND 70.
  WRITE: / 'Number is not between 60 and 70'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Number is between 1 and 100
Number is not between 60 and 70
</code></pre>
<p><code>BETWEEN</code> is inclusive on both ends.</p>
        <br/>
        <li>IN (for ranges/select-options):</li>
<pre><code class="language-abap line-numbers">DATA lt_range TYPE RANGE OF i.

lt_range = VALUE #(
  ( sign = 'I' option = 'BT' low = 1 high = 10 )
  ( sign = 'I' option = 'EQ' low = 50 )
).

DATA lv_num TYPE i VALUE 5.
IF lv_num IN lt_range.
  WRITE: / '5 is in range'.
ENDIF.

lv_num = 50.
IF lv_num IN lt_range.
  WRITE: / '50 is in range'.
ENDIF.

lv_num = 25.
IF lv_num NOT IN lt_range.
  WRITE: / '25 is not in range'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">5 is in range
50 is in range
25 is not in range
</code></pre>
    </ul>
    <br/><br/>


    <li>String Operators</li>
    <br/>
    <ul>
        <li>Concatenation (<code>&amp;&amp;</code>):</li>
<pre><code class="language-abap line-numbers">DATA lv_full TYPE string.

lv_full = 'Hello' &amp;&amp; ' ' &amp;&amp; 'World'.
WRITE: / lv_full.

DATA lv_first TYPE string VALUE 'John'.
DATA lv_last TYPE string VALUE 'Doe'.
lv_full = lv_first &amp;&amp; | | &amp;&amp; lv_last.
WRITE: / lv_full.
</code></pre>
<pre><code class="language-text line-numbers">Hello World
John Doe
</code></pre>
        <br/>
        <li>String comparison operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
            <th>True when</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>CO</code></td>
            <td>Contains Only</td>
            <td>Left contains only characters from right</td>
        </tr>
        <tr>
            <td><code>CN</code></td>
            <td>Contains Not only</td>
            <td>Left contains characters not in right</td>
        </tr>
        <tr>
            <td><code>CA</code></td>
            <td>Contains Any</td>
            <td>Left contains at least one char from right</td>
        </tr>
        <tr>
            <td><code>NA</code></td>
            <td>contains No Any</td>
            <td>Left contains no characters from right</td>
        </tr>
        <tr>
            <td><code>CS</code></td>
            <td>Contains String</td>
            <td>Left contains right as substring</td>
        </tr>
        <tr>
            <td><code>NS</code></td>
            <td>contains No String</td>
            <td>Left does not contain right</td>
        </tr>
        <tr>
            <td><code>CP</code></td>
            <td>Covers Pattern</td>
            <td>Left matches pattern in right</td>
        </tr>
        <tr>
            <td><code>NP</code></td>
            <td>No Pattern</td>
            <td>Left does not match pattern</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>CO (Contains Only):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = '12345'.
IF lv_str CO '0123456789'.
  WRITE: / 'Contains only digits'.
ENDIF.

lv_str = '123A5'.
IF lv_str CN '0123456789'.
  WRITE: / 'Contains non-digit characters'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Contains only digits
Contains non-digit characters
</code></pre>
        <br/>
        <li>CA (Contains Any):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

IF lv_str CA 'aeiou'.
  WRITE: / 'Contains at least one vowel'.
ENDIF.

IF lv_str NA 'xyz'.
  WRITE: / 'Contains no x, y, or z'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Contains at least one vowel
Contains no x, y, or z
</code></pre>
        <br/>
        <li>CS (Contains String):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

IF lv_str CS 'World'.
  WRITE: / 'Contains "World"'.
ENDIF.

IF lv_str CS 'world'.    "case insensitive!
  WRITE: / 'Contains "world" (case insensitive)'.
ENDIF.

IF lv_str NS 'xyz'.
  WRITE: / 'Does not contain "xyz"'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Contains "World"
Contains "world" (case insensitive)
Does not contain "xyz"
</code></pre>
<p><code>CS</code> is case-insensitive by default.</p>
        <br/>
        <li>CP (Covers Pattern):</li>
<pre><code class="language-text line-numbers">Pattern wildcards:
*  = any sequence of characters (including empty)
+  = exactly one character
#  = escape next character (to match literal * or +)
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'HELLO123'.

IF lv_str CP 'HELLO*'.
  WRITE: / 'Starts with HELLO'.
ENDIF.

IF lv_str CP '*123'.
  WRITE: / 'Ends with 123'.
ENDIF.

IF lv_str CP 'HELLO+++'.
  WRITE: / 'HELLO followed by exactly 3 chars'.
ENDIF.

IF lv_str CP '*LO*'.
  WRITE: / 'Contains LO somewhere'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Starts with HELLO
Ends with 123
HELLO followed by exactly 3 chars
Contains LO somewhere
</code></pre>
        <br/>
        <li>sy-fdpos - position found:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

IF lv_str CS 'World'.
  WRITE: / 'Found at position:', sy-fdpos.
ENDIF.

IF lv_str CA 'W'.
  WRITE: / 'W found at position:', sy-fdpos.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Found at position:          6
W found at position:          6
</code></pre>
<p>After <code>CO</code>, <code>CA</code>, <code>CS</code>, <code>CP</code>, <code>sy-fdpos</code> contains the position (0-based).</p>
    </ul>
    <br/><br/>


    <li>Bit Operators</li>
    <br/>
    <ul>
        <li>Operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>BIT-AND</code></td>
            <td>Bitwise AND</td>
        </tr>
        <tr>
            <td><code>BIT-OR</code></td>
            <td>Bitwise OR</td>
        </tr>
        <tr>
            <td><code>BIT-XOR</code></td>
            <td>Bitwise exclusive OR</td>
        </tr>
        <tr>
            <td><code>BIT-NOT</code></td>
            <td>Bitwise NOT (complement)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Usage:</li>
<pre><code class="language-abap line-numbers">DATA lv_a TYPE x LENGTH 1 VALUE 'F0'.    "11110000
DATA lv_b TYPE x LENGTH 1 VALUE '0F'.    "00001111
DATA lv_result TYPE x LENGTH 1.

lv_result = lv_a BIT-AND lv_b.
WRITE: / 'F0 AND 0F =', lv_result.

lv_result = lv_a BIT-OR lv_b.
WRITE: / 'F0 OR 0F =', lv_result.

lv_result = lv_a BIT-XOR lv_b.
WRITE: / 'F0 XOR 0F =', lv_result.

lv_result = BIT-NOT lv_a.
WRITE: / 'NOT F0 =', lv_result.
</code></pre>
<pre><code class="language-text line-numbers">F0 AND 0F = 00
F0 OR 0F = FF
F0 XOR 0F = FF
NOT F0 = 0F
</code></pre>
        <br/>
        <li>Setting and checking flags:</li>
<pre><code class="language-abap line-numbers">CONSTANTS: lc_flag_read   TYPE x VALUE '01',   "00000001
           lc_flag_write  TYPE x VALUE '02',   "00000010
           lc_flag_delete TYPE x VALUE '04'.   "00000100

DATA lv_permissions TYPE x VALUE '00'.

* Set read and write flags
lv_permissions = lv_permissions BIT-OR lc_flag_read.
lv_permissions = lv_permissions BIT-OR lc_flag_write.
WRITE: / 'Permissions:', lv_permissions.

* Check if read flag is set
DATA lv_check TYPE x.
lv_check = lv_permissions BIT-AND lc_flag_read.
IF lv_check &lt;&gt; '00'.
  WRITE: / 'Read permission is set'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Permissions: 03
Read permission is set
</code></pre>
    </ul>
    <br/><br/>


    <li>Calculation Assignments</li>
    <br/>
    <ul>
        <li>Compound assignment operators (ABAP 7.54+):</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 10.

lv_num += 5.     "same as: lv_num = lv_num + 5.
WRITE: / '+= 5:', lv_num.

lv_num -= 3.     "same as: lv_num = lv_num - 3.
WRITE: / '-= 3:', lv_num.

lv_num *= 2.     "same as: lv_num = lv_num * 2.
WRITE: / '*= 2:', lv_num.

lv_num /= 4.     "same as: lv_num = lv_num / 4.
WRITE: / '/= 4:', lv_num.
</code></pre>
<pre><code class="language-text line-numbers">+= 5:         15
-= 3:         12
*= 2:         24
/= 4:          6
</code></pre>
        <br/>
        <li>String concatenation assignment:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello'.

lv_str &amp;&amp;= ' World'.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">Hello World
</code></pre>
        <br/>
        <li>If not available (older systems):</li>
<pre><code class="language-abap line-numbers">* Use explicit form
lv_num = lv_num + 5.
lv_str = lv_str &amp;&amp; ' World'.
</code></pre>
    </ul>
    <br/><br/>


    <li>Operator Summary</li>
    <br/>
    <ul>
        <li>Quick reference:</li>
<table>
    <thead>
        <tr>
            <th>Category</th>
            <th>Operators</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Arithmetic</td>
            <td><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>DIV</code> <code>MOD</code> <code>**</code></td>
        </tr>
        <tr>
            <td>Comparison</td>
            <td><code>=</code> <code>&lt;&gt;</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td>
        </tr>
        <tr>
            <td>Comparison (keyword)</td>
            <td><code>EQ</code> <code>NE</code> <code>LT</code> <code>GT</code> <code>LE</code> <code>GE</code></td>
        </tr>
        <tr>
            <td>Logical</td>
            <td><code>AND</code> <code>OR</code> <code>NOT</code> <code>EQUIV</code></td>
        </tr>
        <tr>
            <td>Special comparison</td>
            <td><code>BETWEEN</code> <code>IN</code> <code>IS INITIAL</code> <code>IS BOUND</code> <code>IS ASSIGNED</code></td>
        </tr>
        <tr>
            <td>String</td>
            <td><code>&amp;&amp;</code> <code>CO</code> <code>CN</code> <code>CA</code> <code>NA</code> <code>CS</code> <code>NS</code> <code>CP</code> <code>NP</code></td>
        </tr>
        <tr>
            <td>Bit</td>
            <td><code>BIT-AND</code> <code>BIT-OR</code> <code>BIT-XOR</code> <code>BIT-NOT</code></td>
        </tr>
        <tr>
            <td>Assignment</td>
            <td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>&amp;&amp;=</code></td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-control-flow">Control Flow in ABAP</h3>
<ol>

    <li>IF Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">IF &lt;condition&gt;.
  &lt;statements&gt;
ENDIF.

IF &lt;condition&gt;.
  &lt;statements&gt;
ELSE.
  &lt;statements&gt;
ENDIF.

IF &lt;condition1&gt;.
  &lt;statements&gt;
ELSEIF &lt;condition2&gt;.
  &lt;statements&gt;
ELSEIF &lt;condition3&gt;.
  &lt;statements&gt;
ELSE.
  &lt;statements&gt;
ENDIF.
</code></pre>
        <br/>
        <li>Basic IF:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 10.

IF lv_num &gt; 5.
  WRITE: / 'Greater than 5'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Greater than 5
</code></pre>
        <br/>
        <li>IF-ELSE:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 3.

IF lv_num &gt; 5.
  WRITE: / 'Greater than 5'.
ELSE.
  WRITE: / 'Not greater than 5'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Not greater than 5
</code></pre>
        <br/>
        <li>IF-ELSEIF-ELSE:</li>
<pre><code class="language-abap line-numbers">DATA lv_score TYPE i VALUE 75.

IF lv_score &gt;= 90.
  WRITE: / 'Grade: A'.
ELSEIF lv_score &gt;= 80.
  WRITE: / 'Grade: B'.
ELSEIF lv_score &gt;= 70.
  WRITE: / 'Grade: C'.
ELSEIF lv_score &gt;= 60.
  WRITE: / 'Grade: D'.
ELSE.
  WRITE: / 'Grade: F'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Grade: C
</code></pre>
<p>Conditions checked top to bottom. First true branch executes, rest skipped.</p>
        <br/>
        <li>Nested IF:</li>
<pre><code class="language-abap line-numbers">DATA lv_age TYPE i VALUE 25.
DATA lv_status TYPE c VALUE 'A'.

IF lv_age &gt;= 18.
  IF lv_status = 'A'.
    WRITE: / 'Adult, Active'.
  ELSE.
    WRITE: / 'Adult, Inactive'.
  ENDIF.
ELSE.
  WRITE: / 'Minor'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Adult, Active
</code></pre>
        <br/>
        <li>Combining conditions:</li>
<pre><code class="language-abap line-numbers">DATA lv_age TYPE i VALUE 25.
DATA lv_status TYPE c VALUE 'A'.

IF lv_age &gt;= 18 AND lv_status = 'A'.
  WRITE: / 'Adult and Active'.
ENDIF.

IF lv_age &lt; 18 OR lv_status = 'I'.
  WRITE: / 'Minor or Inactive'.
ELSE.
  WRITE: / 'Adult and not Inactive'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Adult and Active
Adult and not Inactive
</code></pre>
    </ul>
    <br/><br/>


    <li>CASE Statement</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">CASE &lt;variable&gt;.
  WHEN &lt;value1&gt;.
    &lt;statements&gt;
  WHEN &lt;value2&gt;.
    &lt;statements&gt;
  WHEN &lt;value3&gt; OR &lt;value4&gt;.
    &lt;statements&gt;
  WHEN OTHERS.
    &lt;statements&gt;
ENDCASE.
</code></pre>
        <br/>
        <li>Basic CASE:</li>
<pre><code class="language-abap line-numbers">DATA lv_day TYPE i VALUE 3.

CASE lv_day.
  WHEN 1.
    WRITE: / 'Monday'.
  WHEN 2.
    WRITE: / 'Tuesday'.
  WHEN 3.
    WRITE: / 'Wednesday'.
  WHEN 4.
    WRITE: / 'Thursday'.
  WHEN 5.
    WRITE: / 'Friday'.
  WHEN 6 OR 7.
    WRITE: / 'Weekend'.
  WHEN OTHERS.
    WRITE: / 'Invalid day'.
ENDCASE.
</code></pre>
<pre><code class="language-text line-numbers">Wednesday
</code></pre>
        <br/>
        <li>Multiple values with OR:</li>
<pre><code class="language-abap line-numbers">DATA lv_char TYPE c VALUE 'A'.

CASE lv_char.
  WHEN 'A' OR 'E' OR 'I' OR 'O' OR 'U'.
    WRITE: / 'Vowel'.
  WHEN OTHERS.
    WRITE: / 'Consonant or other'.
ENDCASE.
</code></pre>
<pre><code class="language-text line-numbers">Vowel
</code></pre>
        <br/>
        <li>CASE with strings:</li>
<pre><code class="language-abap line-numbers">DATA lv_status TYPE string VALUE 'ACTIVE'.

CASE lv_status.
  WHEN 'ACTIVE'.
    WRITE: / 'Status is active'.
  WHEN 'INACTIVE'.
    WRITE: / 'Status is inactive'.
  WHEN 'PENDING'.
    WRITE: / 'Status is pending'.
  WHEN OTHERS.
    WRITE: / 'Unknown status'.
ENDCASE.
</code></pre>
<pre><code class="language-text line-numbers">Status is active
</code></pre>
        <br/>
        <li>WHEN OTHERS is optional but recommended:</li>
<pre><code class="language-abap line-numbers">DATA lv_x TYPE i VALUE 99.

CASE lv_x.
  WHEN 1.
    WRITE: / 'One'.
  WHEN 2.
    WRITE: / 'Two'.
ENDCASE.

WRITE: / 'Done'.
</code></pre>
<pre><code class="language-text line-numbers">Done
</code></pre>
<p>No match, no output from CASE. Program continues.</p>
    </ul>
    <br/><br/>


    <li>DO Loop</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">DO [&lt;n&gt; TIMES].
  &lt;statements&gt;
ENDDO.
</code></pre>
        <br/>
        <li>Fixed iterations:</li>
<pre><code class="language-abap line-numbers">DO 5 TIMES.
  WRITE: / 'Iteration:', sy-index.
ENDDO.
</code></pre>
<pre><code class="language-text line-numbers">Iteration:          1
Iteration:          2
Iteration:          3
Iteration:          4
Iteration:          5
</code></pre>
<p><code>sy-index</code> is the current iteration number (1-based).</p>
        <br/>
        <li>Infinite loop (with EXIT):</li>
<pre><code class="language-abap line-numbers">DATA lv_count TYPE i VALUE 0.

DO.
  lv_count = lv_count + 1.
  WRITE: / 'Count:', lv_count.
  IF lv_count &gt;= 3.
    EXIT.   "break out of loop
  ENDIF.
ENDDO.

WRITE: / 'Loop ended'.
</code></pre>
<pre><code class="language-text line-numbers">Count:          1
Count:          2
Count:          3
Loop ended
</code></pre>
<p><code>DO.</code> without <code>TIMES</code> loops forever until <code>EXIT</code>.</p>
        <br/>
        <li>Using sy-index for calculations:</li>
<pre><code class="language-abap line-numbers">DATA lv_sum TYPE i VALUE 0.

DO 10 TIMES.
  lv_sum = lv_sum + sy-index.
ENDDO.

WRITE: / 'Sum 1-10:', lv_sum.
</code></pre>
<pre><code class="language-text line-numbers">Sum 1-10:         55
</code></pre>
    </ul>
    <br/><br/>


    <li>WHILE Loop</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">WHILE &lt;condition&gt;.
  &lt;statements&gt;
ENDWHILE.
</code></pre>
        <br/>
        <li>Basic WHILE:</li>
<pre><code class="language-abap line-numbers">DATA lv_count TYPE i VALUE 1.

WHILE lv_count &lt;= 5.
  WRITE: / 'Count:', lv_count.
  lv_count = lv_count + 1.
ENDWHILE.
</code></pre>
<pre><code class="language-text line-numbers">Count:          1
Count:          2
Count:          3
Count:          4
Count:          5
</code></pre>
        <br/>
        <li>WHILE with sy-index:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 1.

WHILE lv_num &lt; 100.
  lv_num = lv_num * 2.
  WRITE: / 'Iteration:', sy-index, 'Value:', lv_num.
ENDWHILE.
</code></pre>
<pre><code class="language-text line-numbers">Iteration:          1 Value:          2
Iteration:          2 Value:          4
Iteration:          3 Value:          8
Iteration:          4 Value:         16
Iteration:          5 Value:         32
Iteration:          6 Value:         64
Iteration:          7 Value:        128
</code></pre>
        <br/>
        <li>Condition checked before each iteration:</li>
<pre><code class="language-abap line-numbers">DATA lv_x TYPE i VALUE 10.

WHILE lv_x &lt; 5.
  WRITE: / 'This never prints'.
ENDWHILE.

WRITE: / 'Done'.
</code></pre>
<pre><code class="language-text line-numbers">Done
</code></pre>
<p>If condition is false initially, loop body never executes.</p>
    </ul>
    <br/><br/>


    <li>LOOP AT (Internal Tables)</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">LOOP AT &lt;itab&gt; INTO &lt;work_area&gt;.
  &lt;statements&gt;
ENDLOOP.

LOOP AT &lt;itab&gt; ASSIGNING FIELD-SYMBOL(&lt;&lt;fs&gt;&gt;).
  &lt;statements&gt;
ENDLOOP.

LOOP AT &lt;itab&gt; REFERENCE INTO DATA(&lt;lr_ref&gt;).
  &lt;statements&gt;
ENDLOOP.
</code></pre>
        <br/>
        <li>INTO (copies each row):</li>
<pre><code class="language-abap line-numbers">DATA lt_nums TYPE TABLE OF i.
APPEND 10 TO lt_nums.
APPEND 20 TO lt_nums.
APPEND 30 TO lt_nums.

LOOP AT lt_nums INTO DATA(lv_num).
  WRITE: / 'Row:', sy-tabix, 'Value:', lv_num.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">Row:          1 Value:         10
Row:          2 Value:         20
Row:          3 Value:         30
</code></pre>
<p><code>sy-tabix</code> is the current row index (1-based).</p>
        <br/>
        <li>ASSIGNING (direct access, no copy):</li>
<pre><code class="language-abap line-numbers">DATA lt_nums TYPE TABLE OF i.
APPEND 10 TO lt_nums.
APPEND 20 TO lt_nums.
APPEND 30 TO lt_nums.

LOOP AT lt_nums ASSIGNING FIELD-SYMBOL(&lt;fs_num&gt;).
  &lt;fs_num&gt; = &lt;fs_num&gt; * 2.   "modifies table directly
ENDLOOP.

LOOP AT lt_nums INTO DATA(lv_num).
  WRITE: / lv_num.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">        20
        40
        60
</code></pre>
<p><code>ASSIGNING</code> is faster (no copy) and changes affect the table.</p>
        <br/>
        <li>INTO vs ASSIGNING comparison:</li>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>INTO</th>
            <th>ASSIGNING</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Creates copy</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Changes affect table</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Performance</td>
            <td>Slower</td>
            <td>Faster</td>
        </tr>
        <tr>
            <td>Use when</td>
            <td>Read only, need separate copy</td>
            <td>Modify in place, large rows</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>LOOP with WHERE:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_person,
         name TYPE string,
         age  TYPE i,
       END OF ty_person.

DATA lt_people TYPE TABLE OF ty_person.
APPEND VALUE #( name = 'Alice' age = 30 ) TO lt_people.
APPEND VALUE #( name = 'Bob' age = 17 ) TO lt_people.
APPEND VALUE #( name = 'Carol' age = 25 ) TO lt_people.

LOOP AT lt_people INTO DATA(ls_person) WHERE age &gt;= 18.
  WRITE: / ls_person-name, 'is an adult'.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">Alice is an adult
Carol is an adult
</code></pre>
        <br/>
        <li>LOOP with FROM/TO:</li>
<pre><code class="language-abap line-numbers">DATA lt_nums TYPE TABLE OF i.
DO 10 TIMES.
  APPEND sy-index TO lt_nums.
ENDDO.

LOOP AT lt_nums INTO DATA(lv_num) FROM 3 TO 6.
  WRITE: / 'Index:', sy-tabix, 'Value:', lv_num.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">Index:          3 Value:          3
Index:          4 Value:          4
Index:          5 Value:          5
Index:          6 Value:          6
</code></pre>
        <br/>
        <li>LOOP with GROUP BY (ABAP 7.40+):</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_order,
         customer TYPE string,
         amount   TYPE i,
       END OF ty_order.

DATA lt_orders TYPE TABLE OF ty_order.
APPEND VALUE #( customer = 'A' amount = 100 ) TO lt_orders.
APPEND VALUE #( customer = 'B' amount = 200 ) TO lt_orders.
APPEND VALUE #( customer = 'A' amount = 150 ) TO lt_orders.
APPEND VALUE #( customer = 'B' amount = 50 ) TO lt_orders.

LOOP AT lt_orders INTO DATA(ls_order)
     GROUP BY ls_order-customer INTO DATA(lv_customer).

  DATA(lv_total) = 0.
  LOOP AT GROUP lv_customer INTO DATA(ls_member).
    lv_total = lv_total + ls_member-amount.
  ENDLOOP.

  WRITE: / 'Customer:', lv_customer, 'Total:', lv_total.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">Customer: A Total:        250
Customer: B Total:        250
</code></pre>
    </ul>
    <br/><br/>


    <li>Loop Control: EXIT, CONTINUE, CHECK</li>
    <br/>
    <ul>
        <li>EXIT - break out of loop:</li>
<pre><code class="language-abap line-numbers">DO 10 TIMES.
  IF sy-index = 5.
    EXIT.
  ENDIF.
  WRITE: / sy-index.
ENDDO.

WRITE: / 'After loop'.
</code></pre>
<pre><code class="language-text line-numbers">         1
         2
         3
         4
After loop
</code></pre>
<p><code>EXIT</code> immediately leaves the innermost loop.</p>
        <br/>
        <li>CONTINUE - skip to next iteration:</li>
<pre><code class="language-abap line-numbers">DO 5 TIMES.
  IF sy-index = 3.
    CONTINUE.
  ENDIF.
  WRITE: / sy-index.
ENDDO.
</code></pre>
<pre><code class="language-text line-numbers">         1
         2
         4
         5
</code></pre>
<p><code>CONTINUE</code> skips rest of current iteration, goes to next.</p>
        <br/>
        <li>CHECK - conditional CONTINUE:</li>
<pre><code class="language-text line-numbers">CHECK &lt;condition&gt;.

If condition is false, acts like CONTINUE.
If condition is true, continues execution.
</code></pre>
<pre><code class="language-abap line-numbers">DO 5 TIMES.
  CHECK sy-index &lt;&gt; 3.   "skip when index = 3
  WRITE: / sy-index.
ENDDO.
</code></pre>
<pre><code class="language-text line-numbers">         1
         2
         4
         5
</code></pre>
<p>Same result as CONTINUE example. <code>CHECK</code> is shorter for simple conditions.</p>
        <br/>
        <li>CHECK vs IF-CONTINUE:</li>
<pre><code class="language-abap line-numbers">* These are equivalent:

* Using CHECK
DO 5 TIMES.
  CHECK sy-index MOD 2 = 0.   "only even numbers
  WRITE: / sy-index.
ENDDO.

* Using IF-CONTINUE
DO 5 TIMES.
  IF sy-index MOD 2 &lt;&gt; 0.
    CONTINUE.
  ENDIF.
  WRITE: / sy-index.
ENDDO.
</code></pre>
<pre><code class="language-text line-numbers">         2
         4
         2
         4
</code></pre>
        <br/>
        <li>EXIT in nested loops:</li>
<pre><code class="language-abap line-numbers">DO 3 TIMES.
  DATA(lv_outer) = sy-index.
  DO 3 TIMES.
    DATA(lv_inner) = sy-index.
    IF lv_inner = 2.
      EXIT.   "only exits inner loop
    ENDIF.
    WRITE: / 'Outer:', lv_outer, 'Inner:', lv_inner.
  ENDDO.
ENDDO.
</code></pre>
<pre><code class="language-text line-numbers">Outer:          1 Inner:          1
Outer:          2 Inner:          1
Outer:          3 Inner:          1
</code></pre>
<p><code>EXIT</code> only exits the innermost loop. Outer loop continues.</p>
    </ul>
    <br/><br/>


    <li>EXIT, CHECK, RETURN Outside Loops</li>
    <br/>
    <ul>
        <li>EXIT outside loop - exits processing block:</li>
<pre><code class="language-abap line-numbers">START-OF-SELECTION.
  WRITE: / 'Before EXIT'.
  EXIT.
  WRITE: / 'After EXIT'.   "never reached
</code></pre>
<pre><code class="language-text line-numbers">Before EXIT
</code></pre>
        <br/>
        <li>CHECK outside loop - exits if false:</li>
<pre><code class="language-abap line-numbers">DATA lv_flag TYPE c VALUE ' '.

START-OF-SELECTION.
  WRITE: / 'Before CHECK'.
  CHECK lv_flag = 'X'.
  WRITE: / 'After CHECK'.   "skipped because flag is not X
</code></pre>
<pre><code class="language-text line-numbers">Before CHECK
</code></pre>
        <br/>
        <li>RETURN - exits current processing unit:</li>
<pre><code class="language-abap line-numbers">FORM my_subroutine.
  WRITE: / 'Before RETURN'.
  RETURN.
  WRITE: / 'After RETURN'.   "never reached
ENDFORM.

START-OF-SELECTION.
  PERFORM my_subroutine.
  WRITE: / 'Back in main'.
</code></pre>
<pre><code class="language-text line-numbers">Before RETURN
Back in main
</code></pre>
    </ul>
    <br/><br/>


    <li>COND Expression (ABAP 7.40+)</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">COND &lt;type&gt;(
  WHEN &lt;condition1&gt; THEN &lt;value1&gt;
  WHEN &lt;condition2&gt; THEN &lt;value2&gt;
  ...
  ELSE &lt;default_value&gt; ).
</code></pre>
<p>Returns a value based on conditions. Like a conditional expression.</p>
        <br/>
        <li>Basic usage:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 75.

DATA(lv_grade) = COND string(
  WHEN lv_num &gt;= 90 THEN 'A'
  WHEN lv_num &gt;= 80 THEN 'B'
  WHEN lv_num &gt;= 70 THEN 'C'
  WHEN lv_num &gt;= 60 THEN 'D'
  ELSE 'F' ).

WRITE: / 'Grade:', lv_grade.
</code></pre>
<pre><code class="language-text line-numbers">Grade: C
</code></pre>
        <br/>
        <li>Using # for type inference:</li>
<pre><code class="language-abap line-numbers">DATA lv_result TYPE string.

lv_result = COND #(
  WHEN sy-datum+4(2) &lt;= '03' THEN 'Q1'
  WHEN sy-datum+4(2) &lt;= '06' THEN 'Q2'
  WHEN sy-datum+4(2) &lt;= '09' THEN 'Q3'
  ELSE 'Q4' ).

WRITE: / 'Quarter:', lv_result.
</code></pre>
<pre><code class="language-text line-numbers">Quarter: Q4
</code></pre>
<p><code>#</code> infers type from target variable (<code>lv_result</code> is string).</p>
        <br/>
        <li>In string templates:</li>
<pre><code class="language-abap line-numbers">DATA lv_count TYPE i VALUE 1.

WRITE: / |{ lv_count } item{ COND string( WHEN lv_count &lt;&gt; 1 THEN 's' ) }|.

lv_count = 5.
WRITE: / |{ lv_count } item{ COND string( WHEN lv_count &lt;&gt; 1 THEN 's' ) }|.
</code></pre>
<pre><code class="language-text line-numbers">1 item
5 items
</code></pre>
    </ul>
    <br/><br/>


    <li>SWITCH Expression (ABAP 7.40+)</li>
    <br/>
    <ul>
        <li>Syntax:</li>
<pre><code class="language-text line-numbers">SWITCH &lt;type&gt;( &lt;variable&gt;
  WHEN &lt;value1&gt; THEN &lt;result1&gt;
  WHEN &lt;value2&gt; THEN &lt;result2&gt;
  ...
  ELSE &lt;default_result&gt; ).
</code></pre>
<p>Like CASE but returns a value.</p>
        <br/>
        <li>Basic usage:</li>
<pre><code class="language-abap line-numbers">DATA lv_day TYPE i VALUE 3.

DATA(lv_name) = SWITCH string( lv_day
  WHEN 1 THEN 'Monday'
  WHEN 2 THEN 'Tuesday'
  WHEN 3 THEN 'Wednesday'
  WHEN 4 THEN 'Thursday'
  WHEN 5 THEN 'Friday'
  WHEN 6 THEN 'Saturday'
  WHEN 7 THEN 'Sunday'
  ELSE 'Invalid' ).

WRITE: / 'Day:', lv_name.
</code></pre>
<pre><code class="language-text line-numbers">Day: Wednesday
</code></pre>
        <br/>
        <li>Multiple values per WHEN:</li>
<pre><code class="language-abap line-numbers">DATA lv_day TYPE i VALUE 6.

DATA(lv_type) = SWITCH string( lv_day
  WHEN 1 OR 2 OR 3 OR 4 OR 5 THEN 'Weekday'
  WHEN 6 OR 7 THEN 'Weekend'
  ELSE 'Invalid' ).

WRITE: / lv_type.
</code></pre>
<pre><code class="language-text line-numbers">Weekend
</code></pre>
        <br/>
        <li>COND vs SWITCH:</li>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>COND</th>
            <th>SWITCH</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Tests</td>
            <td>Any conditions</td>
            <td>Single variable against values</td>
        </tr>
        <tr>
            <td>Like</td>
            <td>IF-ELSEIF-ELSE</td>
            <td>CASE-WHEN</td>
        </tr>
        <tr>
            <td>Use when</td>
            <td>Complex conditions</td>
            <td>Matching against discrete values</td>
        </tr>
    </tbody>
</table>
<pre><code class="language-abap line-numbers">* COND - any conditions allowed
DATA(lv_a) = COND string(
  WHEN lv_x &gt; 10 AND lv_y &lt; 5 THEN 'A'
  WHEN lv_x BETWEEN 5 AND 10 THEN 'B'
  ELSE 'C' ).

* SWITCH - only equality checks on one variable
DATA(lv_b) = SWITCH string( lv_x
  WHEN 1 THEN 'One'
  WHEN 2 THEN 'Two'
  ELSE 'Other' ).
</code></pre>
    </ul>
    <br/><br/>


    <li>Conditional Loops: WHERE Clause</li>
    <br/>
    <ul>
        <li>LOOP AT with WHERE:</li>
<pre><code class="language-abap line-numbers">TYPES: BEGIN OF ty_item,
         id     TYPE i,
         status TYPE c,
         amount TYPE i,
       END OF ty_item.

DATA lt_items TYPE TABLE OF ty_item.
APPEND VALUE #( id = 1 status = 'A' amount = 100 ) TO lt_items.
APPEND VALUE #( id = 2 status = 'I' amount = 200 ) TO lt_items.
APPEND VALUE #( id = 3 status = 'A' amount = 150 ) TO lt_items.
APPEND VALUE #( id = 4 status = 'A' amount = 50 ) TO lt_items.

* Filter by status
LOOP AT lt_items INTO DATA(ls_item) WHERE status = 'A'.
  WRITE: / 'Active item:', ls_item-id, ls_item-amount.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">Active item:          1        100
Active item:          3        150
Active item:          4         50
</code></pre>
        <br/>
        <li>Multiple conditions in WHERE:</li>
<pre><code class="language-abap line-numbers">LOOP AT lt_items INTO DATA(ls_item) WHERE status = 'A' AND amount > 75.
  WRITE: / 'Filtered:', ls_item-id.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">Filtered:          1
Filtered:          3
</code></pre>
    </ul>
    <br/><br/>


    <li>LOOP AT with STEP</li>
    <br/>
    <ul>
        <li>Process every nth row (ABAP 7.40+):</li>
<pre><code class="language-abap line-numbers">DATA lt_nums TYPE TABLE OF i.
DO 10 TIMES.
  APPEND sy-index TO lt_nums.
ENDDO.

* Every second row
LOOP AT lt_nums INTO DATA(lv_num) STEP 2.
  WRITE: / lv_num.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">         1
         3
         5
         7
         9
</code></pre>
        <br/>
        <li>Reverse loop (negative STEP):</li>
<pre><code class="language-abap line-numbers">LOOP AT lt_nums INTO DATA(lv_num) STEP -1.
  WRITE: / lv_num.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">        10
         9
         8
         7
         6
         5
         4
         3
         2
         1
</code></pre>
    </ul>
    <br/><br/>


    <li>Control Flow Summary</li>
    <br/>
    <ul>
        <li>Statement forms:</li>
<table>
    <thead>
        <tr>
            <th>Statement</th>
            <th>Purpose</th>
            <th>Counter</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>IF...ENDIF</code></td>
            <td>Conditional execution</td>
            <td>—</td>
        </tr>
        <tr>
            <td><code>CASE...ENDCASE</code></td>
            <td>Match value against options</td>
            <td>—</td>
        </tr>
        <tr>
            <td><code>DO...ENDDO</code></td>
            <td>Fixed or infinite loop</td>
            <td><code>sy-index</code></td>
        </tr>
        <tr>
            <td><code>WHILE...ENDWHILE</code></td>
            <td>Conditional loop</td>
            <td><code>sy-index</code></td>
        </tr>
        <tr>
            <td><code>LOOP AT...ENDLOOP</code></td>
            <td>Iterate internal table</td>
            <td><code>sy-tabix</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Loop control:</li>
<table>
    <thead>
        <tr>
            <th>Statement</th>
            <th>In loop</th>
            <th>Outside loop</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>EXIT</code></td>
            <td>Break out of loop</td>
            <td>Exit processing block</td>
        </tr>
        <tr>
            <td><code>CONTINUE</code></td>
            <td>Skip to next iteration</td>
            <td>Skip rest of block</td>
        </tr>
        <tr>
            <td><code>CHECK &lt;cond&gt;</code></td>
            <td>CONTINUE if false</td>
            <td>Exit block if false</td>
        </tr>
        <tr>
            <td><code>RETURN</code></td>
            <td colspan="2">Exit subroutine/method</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Expression forms (7.40+):</li>
<table>
    <thead>
        <tr>
            <th>Expression</th>
            <th>Like statement</th>
            <th>Returns</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>COND</code></td>
            <td>IF-ELSEIF-ELSE</td>
            <td>Value based on conditions</td>
        </tr>
        <tr>
            <td><code>SWITCH</code></td>
            <td>CASE-WHEN</td>
            <td>Value based on match</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="abap-strings">Strings in ABAP</h3>
<ol>

    <li>String Types</li>
    <br/>
    <ul>
        <li>Three character-based types:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Length</th>
            <th>Padding</th>
            <th>Use case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>c</code></td>
            <td>Fixed</td>
            <td>Spaces (right)</td>
            <td>Fixed-format fields, flags</td>
        </tr>
        <tr>
            <td><code>string</code></td>
            <td>Variable</td>
            <td>None</td>
            <td>General text processing</td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>Fixed</td>
            <td>Zeros (left)</td>
            <td>Numeric IDs, document numbers</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Type c (fixed-length character):</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE c [LENGTH &lt;n&gt;].

Default length is 1. Maximum is 262143.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 10.

lv_c = 'Hello'.
WRITE: / '&gt;', lv_c, '&lt;'.
WRITE: / 'Length:', strlen( lv_c ).

lv_c = 'Hello World!!!'.
WRITE: / '&gt;', lv_c, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
Length:          5
&gt;Hello Worl
</code></pre>
<p>Short values padded with spaces. Long values truncated. <code>strlen()</code> returns length without trailing spaces.</p>
        <br/>
        <li>Type string (variable-length):</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE string.

No length limit. No padding. No truncation.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = 'Hello'.
WRITE: / '&gt;', lv_str, '&lt;'.
WRITE: / 'Length:', strlen( lv_str ).

lv_str = 'This can be any length without truncation'.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
Length:          5
This can be any length without truncation
</code></pre>
        <br/>
        <li>Type n (numeric text):</li>
<pre><code class="language-text line-numbers">DATA &lt;name&gt; TYPE n [LENGTH &lt;n&gt;].

Only digits 0-9. Left-padded with zeros.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_n TYPE n LENGTH 10.

lv_n = '123'.
WRITE: / lv_n.

lv_n = 456.
WRITE: / lv_n.

lv_n = 'ABC123'.    "non-digits become 0
WRITE: / lv_n.
</code></pre>
<pre><code class="language-text line-numbers">0000000123
0000000456
0000000123
</code></pre>
    </ul>
    <br/><br/>


    <li>String Literals</li>
    <br/>
    <ul>
        <li>Three forms:</li>
<table>
    <thead>
        <tr>
            <th>Syntax</th>
            <th>Type</th>
            <th>Trailing spaces</th>
            <th>Embedded expressions</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>'...'</code></td>
            <td>c</td>
            <td>Trimmed</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>`...`</code></td>
            <td>string</td>
            <td>Preserved</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>|...|</code></td>
            <td>string</td>
            <td>Preserved</td>
            <td>Yes <code>{ }</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Single quotes (<code>'...'</code>):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = 'Hello   '.    "3 trailing spaces
WRITE: / '&gt;', lv_str, '&lt;'.
WRITE: / 'Length:', strlen( lv_str ).
</code></pre>
<pre><code class="language-text line-numbers">>Hello
Length:          5
</code></pre>
<p>Trailing spaces removed when assigned to string.</p>
        <br/>
        <li>Backticks (<code>`...`</code>):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = `Hello   `.    "3 trailing spaces
WRITE: / '&gt;', lv_str, '&lt;'.
WRITE: / 'Length:', strlen( lv_str ).
</code></pre>
<pre><code class="language-text line-numbers">>Hello
Length:          8
</code></pre>
<p>Spaces preserved. Use when whitespace matters.</p>
        <br/>
        <li>Pipes (<code>|...|</code>) - string templates:</li>
<pre><code class="language-abap line-numbers">DATA lv_name TYPE string VALUE 'Alice'.
DATA lv_age TYPE i VALUE 30.

DATA(lv_msg) = |Name: { lv_name }, Age: { lv_age }|.
WRITE: / lv_msg.
</code></pre>
<pre><code class="language-text line-numbers">Name: Alice, Age: 30
</code></pre>
<p>Expressions inside <code>{ }</code> are evaluated and inserted.</p>
        <br/>
        <li>Escaping special characters:</li>
<pre><code class="language-abap line-numbers">* Single quote in single quotes - double it
DATA(lv_1) = 'It''s OK'.
WRITE: / lv_1.

* Backtick in backticks - double it
DATA(lv_2) = `Say ``hello`` `.
WRITE: / lv_2.

* In pipes - use backslash
DATA(lv_3) = |Pipe: \|, Brace: \{, Backslash: \\|.
WRITE: / lv_3.
</code></pre>
<pre><code class="language-text line-numbers">It's OK
Say `hello`
Pipe: |, Brace: {, Backslash: \
</code></pre>
        <br/>
        <li>Newline and tab in string templates:</li>
<pre><code class="language-abap line-numbers">DATA(lv_multiline) = |Line 1\nLine 2\nLine 3|.
WRITE: / lv_multiline.

DATA(lv_tabbed) = |Col1\tCol2\tCol3|.
WRITE: / lv_tabbed.
</code></pre>
<pre><code class="language-text line-numbers">Line 1
Line 2
Line 3
Col1    Col2    Col3
</code></pre>
<table>
    <thead>
        <tr>
            <th>Escape</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>\n</code></td>
            <td>Newline</td>
        </tr>
        <tr>
            <td><code>\r</code></td>
            <td>Carriage return</td>
        </tr>
        <tr>
            <td><code>\t</code></td>
            <td>Tab</td>
        </tr>
        <tr>
            <td><code>\\</code></td>
            <td>Backslash</td>
        </tr>
        <tr>
            <td><code>\|</code></td>
            <td>Pipe</td>
        </tr>
        <tr>
            <td><code>\{</code></td>
            <td>Open brace</td>
        </tr>
        <tr>
            <td><code>\}</code></td>
            <td>Close brace</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>String Template Formatting</li>
    <br/>
    <ul>
        <li>Basic expression:</li>
<pre><code class="language-text line-numbers">|{ &lt;expression&gt; [&lt;formatting_options&gt;] }|
</code></pre>
        <br/>
        <li>WIDTH and ALIGN:</li>
<pre><code class="language-abap line-numbers">DATA lv_name TYPE string VALUE 'Bob'.

WRITE: / |&gt;{ lv_name }&lt;|.
WRITE: / |&gt;{ lv_name WIDTH = 10 }&lt;|.
WRITE: / |&gt;{ lv_name WIDTH = 10 ALIGN = LEFT }&lt;|.
WRITE: / |&gt;{ lv_name WIDTH = 10 ALIGN = RIGHT }&lt;|.
WRITE: / |&gt;{ lv_name WIDTH = 10 ALIGN = CENTER }&lt;|.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Bob
&gt;Bob
&gt;Bob
&gt;       Bob
&gt;   Bob
</code></pre>
        <br/>
        <li>PAD:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE i VALUE 42.

WRITE: / |&gt;{ lv_num WIDTH = 6 PAD = '0' }&lt;|.
WRITE: / |&gt;{ lv_num WIDTH = 6 PAD = '_' ALIGN = RIGHT }&lt;|.
</code></pre>
<pre><code class="language-text line-numbers">&gt;000042
&gt;____42
</code></pre>
        <br/>
        <li>CASE - upper/lower:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

WRITE: / |{ lv_str CASE = UPPER }|.
WRITE: / |{ lv_str CASE = LOWER }|.
WRITE: / |{ lv_str CASE = RAW }|.
</code></pre>
<pre><code class="language-text line-numbers">HELLO WORLD
hello world
Hello World
</code></pre>
        <br/>
        <li>Number formatting:</li>
<pre><code class="language-abap line-numbers">DATA lv_num TYPE p DECIMALS 2 VALUE '1234567.89'.

WRITE: / |{ lv_num }|.
WRITE: / |{ lv_num NUMBER = RAW }|.
WRITE: / |{ lv_num NUMBER = USER }|.
WRITE: / |{ lv_num NUMBER = ENVIRONMENT }|.
WRITE: / |{ lv_num DECIMALS = 1 }|.
WRITE: / |{ lv_num SIGN = LEFT }|.
WRITE: / |{ lv_num SIGN = LEFTPLUS }|.
</code></pre>
<pre><code class="language-text line-numbers">1234567.89
1234567.89
1,234,567.89
1,234,567.89
1234567.9
1234567.89
+1234567.89
</code></pre>
<p><code>NUMBER = USER</code> formats according to user's locale settings.</p>
        <br/>
        <li>Date formatting:</li>
<pre><code class="language-abap line-numbers">DATA lv_date TYPE d VALUE '20241215'.

WRITE: / |{ lv_date }|.
WRITE: / |{ lv_date DATE = RAW }|.
WRITE: / |{ lv_date DATE = USER }|.
WRITE: / |{ lv_date DATE = ISO }|.
WRITE: / |{ lv_date DATE = ENVIRONMENT }|.
</code></pre>
<pre><code class="language-text line-numbers">20241215
20241215
12/15/2024
2024-12-15
12/15/2024
</code></pre>
        <br/>
        <li>Time formatting:</li>
<pre><code class="language-abap line-numbers">DATA lv_time TYPE t VALUE '143052'.

WRITE: / |{ lv_time }|.
WRITE: / |{ lv_time TIME = RAW }|.
WRITE: / |{ lv_time TIME = USER }|.
WRITE: / |{ lv_time TIME = ISO }|.
</code></pre>
<pre><code class="language-text line-numbers">143052
143052
2:30:52 PM
14:30:52
</code></pre>
        <br/>
        <li>Timestamp formatting:</li>
<pre><code class="language-abap line-numbers">DATA lv_ts TYPE timestamp VALUE '20241215143052'.

WRITE: / |{ lv_ts TIMESTAMP = ISO }|.
WRITE: / |{ lv_ts TIMESTAMP = USER }|.
WRITE: / |{ lv_ts TIMESTAMP = SPACE }|.
</code></pre>
<pre><code class="language-text line-numbers">2024-12-15T14:30:52
12/15/2024 2:30:52 PM
2024-12-15 14:30:52
</code></pre>
        <br/>
        <li>ALPHA - add/remove leading zeros:</li>
<pre><code class="language-abap line-numbers">DATA lv_matnr TYPE c LENGTH 18 VALUE '000000000001234567'.

WRITE: / |{ lv_matnr }|.
WRITE: / |{ lv_matnr ALPHA = OUT }|.    "remove leading zeros

DATA lv_short TYPE c LENGTH 10 VALUE '1234567'.
WRITE: / |{ lv_short ALPHA = IN WIDTH = 18 }|.    "add leading zeros
</code></pre>
<pre><code class="language-text line-numbers">000000000001234567
1234567
000000000001234567
</code></pre>
    </ul>
    <br/><br/>


    <li>Concatenation</li>
    <br/>
    <ul>
        <li>Using <code>&amp;&amp;</code> operator:</li>
<pre><code class="language-abap line-numbers">DATA lv_first TYPE string VALUE 'Hello'.
DATA lv_second TYPE string VALUE 'World'.

DATA(lv_result) = lv_first &amp;&amp; ' ' &amp;&amp; lv_second.
WRITE: / lv_result.
</code></pre>
<pre><code class="language-text line-numbers">Hello World
</code></pre>
        <br/>
        <li>Using string template:</li>
<pre><code class="language-abap line-numbers">DATA lv_first TYPE string VALUE 'Hello'.
DATA lv_second TYPE string VALUE 'World'.

DATA(lv_result) = |{ lv_first } { lv_second }|.
WRITE: / lv_result.
</code></pre>
<pre><code class="language-text line-numbers">Hello World
</code></pre>
        <br/>
        <li>CONCATENATE statement (classic):</li>
<pre><code class="language-text line-numbers">CONCATENATE &lt;s1&gt; &lt;s2&gt; ... INTO &lt;result&gt; [SEPARATED BY &lt;sep&gt;].
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_result TYPE string.

CONCATENATE 'Hello' 'World' INTO lv_result SEPARATED BY ' '.
WRITE: / lv_result.

CONCATENATE 'A' 'B' 'C' INTO lv_result.
WRITE: / lv_result.
</code></pre>
<pre><code class="language-text line-numbers">Hello World
ABC
</code></pre>
        <br/>
        <li>concat_lines_of - join table rows:</li>
<pre><code class="language-abap line-numbers">DATA lt_words TYPE TABLE OF string.
APPEND 'One' TO lt_words.
APPEND 'Two' TO lt_words.
APPEND 'Three' TO lt_words.

DATA(lv_joined) = concat_lines_of( table = lt_words sep = ', ' ).
WRITE: / lv_joined.
</code></pre>
<pre><code class="language-text line-numbers">One, Two, Three
</code></pre>
    </ul>
    <br/><br/>


    <li>Substrings</li>
    <br/>
    <ul>
        <li>Offset/length syntax:</li>
<pre><code class="language-text line-numbers">&lt;string&gt;+&lt;offset&gt;(&lt;length&gt;)

offset = starting position (0-based)
length = number of characters
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

WRITE: / lv_str+0(5).    "first 5 chars
WRITE: / lv_str+6(5).    "chars 6-10
WRITE: / lv_str+6(*).    "from position 6 to end
</code></pre>
<pre><code class="language-text line-numbers">Hello
World
World
</code></pre>
        <br/>
        <li>substring function:</li>
<pre><code class="language-text line-numbers">substring( val = &lt;string&gt; off = &lt;offset&gt; len = &lt;length&gt; )
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

DATA(lv_sub1) = substring( val = lv_str off = 0 len = 5 ).
WRITE: / lv_sub1.

DATA(lv_sub2) = substring( val = lv_str off = 6 len = 5 ).
WRITE: / lv_sub2.
</code></pre>
<pre><code class="language-text line-numbers">Hello
World
</code></pre>
        <br/>
        <li>Related functions:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

DATA(lv_from) = substring_from( val = lv_str sub = 'Wo' ).
WRITE: / 'From "Wo":', lv_from.

DATA(lv_after) = substring_after( val = lv_str sub = 'o ' ).
WRITE: / 'After "o ":', lv_after.

DATA(lv_before) = substring_before( val = lv_str sub = ' Wo' ).
WRITE: / 'Before " Wo":', lv_before.

DATA(lv_to) = substring_to( val = lv_str sub = 'o W' ).
WRITE: / 'To "o W":', lv_to.
</code></pre>
<pre><code class="language-text line-numbers">From "Wo": World
After "o ": World
Before " Wo": Hell
To "o W": Hello W
</code></pre>
    </ul>
    <br/><br/>


    <li>String Length</li>
    <br/>
    <ul>
        <li>strlen function:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello'.
DATA lv_c TYPE c LENGTH 10 VALUE 'Hello'.

WRITE: / 'string length:', strlen( lv_str ).
WRITE: / 'c length:', strlen( lv_c ).
</code></pre>
<pre><code class="language-text line-numbers">string length:          5
c length:          5
</code></pre>
<p>For type <code>c</code>, <code>strlen()</code> excludes trailing spaces.</p>
        <br/>
        <li>numofchar - actual characters:</li>
<pre><code class="language-abap line-numbers">DATA lv_c TYPE c LENGTH 10 VALUE 'Hello'.

WRITE: / 'strlen:', strlen( lv_c ).
WRITE: / 'numofchar:', numofchar( lv_c ).
</code></pre>
<pre><code class="language-text line-numbers">strlen:          5
numofchar:          5
</code></pre>
<p>Same for most cases. <code>numofchar()</code> handles multi-byte characters.</p>
    </ul>
    <br/><br/>


    <li>Case Conversion</li>
    <br/>
    <ul>
        <li>Functions:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

DATA(lv_upper) = to_upper( lv_str ).
WRITE: / lv_upper.

DATA(lv_lower) = to_lower( lv_str ).
WRITE: / lv_lower.

DATA(lv_mixed) = to_mixed( val = 'HELLO_WORLD' sep = '_' ).
WRITE: / lv_mixed.
</code></pre>
<pre><code class="language-text line-numbers">HELLO WORLD
hello world
HelloWorld
</code></pre>
        <br/>
        <li>Classic statements:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

TRANSLATE lv_str TO UPPER CASE.
WRITE: / lv_str.

TRANSLATE lv_str TO LOWER CASE.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">HELLO WORLD
hello world
</code></pre>
    </ul>
    <br/><br/>


    <li>Trimming and Shifting</li>
    <br/>
    <ul>
        <li>condense - remove extra spaces:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE '  Hello   World  '.

DATA(lv_condensed) = condense( lv_str ).
WRITE: / '&gt;', lv_condensed, '&lt;'.

DATA(lv_no_gaps) = condense( val = lv_str del = ' ' ).
WRITE: / '&gt;', lv_no_gaps, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello World
&gt;&gt;HelloWorld
</code></pre>
<p>Default: trims ends and reduces multiple spaces to single space.</p>
        <br/>
        <li>shift_left, shift_right:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE '  Hello  '.

DATA(lv_left) = shift_left( val = lv_str sub = ' ' ).
WRITE: / '&gt;', lv_left, '&lt;'.

DATA(lv_right) = shift_right( val = lv_str sub = ' ' ).
WRITE: / '&gt;', lv_right, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">&gt;Hello
&gt;  Hello
</code></pre>
        <br/>
        <li>SHIFT statement (classic):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE c LENGTH 10 VALUE '  Hello'.

SHIFT lv_str LEFT DELETING LEADING ' '.
WRITE: / '&gt;', lv_str, '&lt;'.

lv_str = 'Hello  '.
SHIFT lv_str RIGHT DELETING TRAILING ' '.
WRITE: / '&gt;', lv_str, '&lt;'.
</code></pre>
<pre><code class="language-text line-numbers">>Hello
>     Hello
</code></pre>
        <br/>
        <li>SHIFT by positions:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE c LENGTH 10 VALUE 'ABCDEFGHIJ'.

SHIFT lv_str BY 3 PLACES LEFT.
WRITE: / lv_str.

lv_str = 'ABCDEFGHIJ'.
SHIFT lv_str BY 3 PLACES RIGHT.
WRITE: / lv_str.

lv_str = 'ABCDEFGHIJ'.
SHIFT lv_str BY 3 PLACES CIRCULAR.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">DEFGHIJ
   ABCDEFG
DEFGHIJABC
</code></pre>
    </ul>
    <br/><br/>


    <li>Find and Replace</li>
    <br/>
    <ul>
        <li>find function:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

DATA(lv_pos) = find( val = lv_str sub = 'World' ).
WRITE: / 'Position of "World":', lv_pos.

lv_pos = find( val = lv_str sub = 'xyz' ).
WRITE: / 'Position of "xyz":', lv_pos.
</code></pre>
<pre><code class="language-text line-numbers">Position of "World":          6
Position of "xyz":         -1
</code></pre>
<p>Returns 0-based position. -1 if not found.</p>
        <br/>
        <li>find with options:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World World'.

DATA(lv_pos) = find( val = lv_str sub = 'World' occ = 2 ).
WRITE: / 'Second "World" at:', lv_pos.

lv_pos = find( val = lv_str sub = 'WORLD' case = abap_false ).
WRITE: / 'Case insensitive:', lv_pos.
</code></pre>
<pre><code class="language-text line-numbers">Second "World" at:         12
Case insensitive:          6
</code></pre>
        <br/>
        <li>count:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'abracadabra'.

DATA(lv_count) = count( val = lv_str sub = 'a' ).
WRITE: / 'Count of "a":', lv_count.

lv_count = count( val = lv_str sub = 'bra' ).
WRITE: / 'Count of "bra":', lv_count.
</code></pre>
<pre><code class="language-text line-numbers">Count of "a":          5
Count of "bra":          2
</code></pre>
        <br/>
        <li>replace function:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

DATA(lv_new) = replace( val = lv_str sub = 'World' with = 'ABAP' ).
WRITE: / lv_new.

lv_str = 'aaa bbb aaa'.
DATA(lv_all) = replace( val = lv_str sub = 'aaa' with = 'xxx' occ = 0 ).
WRITE: / lv_all.
</code></pre>
<pre><code class="language-text line-numbers">Hello ABAP
xxx bbb xxx
</code></pre>
<p><code>occ = 0</code> replaces all occurrences.</p>
        <br/>
        <li>FIND statement (classic):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

FIND 'World' IN lv_str MATCH OFFSET DATA(lv_off) MATCH LENGTH DATA(lv_len).
IF sy-subrc = 0.
  WRITE: / 'Found at offset:', lv_off, 'length:', lv_len.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Found at offset:          6 length:          5
</code></pre>
        <br/>
        <li>REPLACE statement (classic):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World World'.

REPLACE 'World' IN lv_str WITH 'ABAP'.
WRITE: / lv_str.

lv_str = 'Hello World World'.
REPLACE ALL OCCURRENCES OF 'World' IN lv_str WITH 'ABAP'.
WRITE: / lv_str.
</code></pre>
<pre><code class="language-text line-numbers">Hello ABAP World
Hello ABAP ABAP
</code></pre>
    </ul>
    <br/><br/>


    <li>String Comparison Operators</li>
    <br/>
    <ul>
        <li>CO (Contains Only):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string.

lv_str = '12345'.
IF lv_str CO '0123456789'.
  WRITE: / 'Only digits'.
ENDIF.

lv_str = '123A5'.
IF lv_str CN '0123456789'.
  WRITE: / 'Contains non-digits at position:', sy-fdpos.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Only digits
Contains non-digits at position:          3
</code></pre>
        <br/>
        <li>CA (Contains Any):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

IF lv_str CA 'aeiou'.
  WRITE: / 'Has vowel at position:', sy-fdpos.
ENDIF.

IF lv_str NA '0123456789'.
  WRITE: / 'Contains no digits'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Has vowel at position:          1
Contains no digits
</code></pre>
        <br/>
        <li>CS (Contains String):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello World'.

IF lv_str CS 'World'.
  WRITE: / 'Contains "World" at:', sy-fdpos.
ENDIF.

IF lv_str CS 'WORLD'.    "case insensitive!
  WRITE: / 'CS is case insensitive'.
ENDIF.

IF lv_str NS 'xyz'.
  WRITE: / 'Does not contain "xyz"'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Contains "World" at:          6
CS is case insensitive
Does not contain "xyz"
</code></pre>
        <br/>
        <li>CP (Covers Pattern):</li>
<pre><code class="language-text line-numbers">Pattern wildcards:
*  = any characters (including none)
+  = exactly one character
#  = escape (to match literal * + #)
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'HELLO123'.

IF lv_str CP 'HELLO*'.
  WRITE: / 'Starts with HELLO'.
ENDIF.

IF lv_str CP '*123'.
  WRITE: / 'Ends with 123'.
ENDIF.

IF lv_str CP 'HELLO+++'.
  WRITE: / 'HELLO + exactly 3 chars'.
ENDIF.

IF lv_str CP '*LO*'.
  WRITE: / 'Contains LO'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Starts with HELLO
Ends with 123
HELLO + exactly 3 chars
Contains LO
</code></pre>
        <br/>
        <li>Summary table:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>True when</th>
            <th>Negative</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>CO</code></td>
            <td>Contains Only chars from right</td>
            <td><code>CN</code></td>
        </tr>
        <tr>
            <td><code>CA</code></td>
            <td>Contains Any char from right</td>
            <td><code>NA</code></td>
        </tr>
        <tr>
            <td><code>CS</code></td>
            <td>Contains String (case insensitive)</td>
            <td><code>NS</code></td>
        </tr>
        <tr>
            <td><code>CP</code></td>
            <td>Covers Pattern (wildcards)</td>
            <td><code>NP</code></td>
        </tr>
    </tbody>
</table>
<p>After these operators, <code>sy-fdpos</code> contains the position found (or first mismatch for CO).</p>
    </ul>
    <br/><br/>


    <li>Regular Expressions</li>
    <br/>
    <ul>
        <li>find with regex:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Order 12345 confirmed'.

DATA(lv_pos) = find( val = lv_str regex = '\d+' ).
WRITE: / 'Digits found at:', lv_pos.
</code></pre>
<pre><code class="language-text line-numbers">Digits found at:          6
</code></pre>
        <br/>
        <li>replace with regex:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Price: $100 or $200'.

DATA(lv_new) = replace( val = lv_str regex = '\$\d+' with = 'XXX' occ = 0 ).
WRITE: / lv_new.
</code></pre>
<pre><code class="language-text line-numbers">Price: XXX or XXX
</code></pre>
        <br/>
        <li>FIND with REGEX (classic):</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Email: test@example.com'.
DATA lv_email TYPE string.

FIND REGEX '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
     IN lv_str MATCH OFFSET DATA(lv_off) MATCH LENGTH DATA(lv_len).

IF sy-subrc = 0.
  lv_email = lv_str+lv_off(lv_len).
  WRITE: / 'Email found:', lv_email.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Email found: test@example.com
</code></pre>
        <br/>
        <li>contains/matches predicates:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'ABC123'.

IF contains( val = lv_str regex = '^\d+$' ).
  WRITE: / 'Only digits'.
ELSE.
  WRITE: / 'Not only digits'.
ENDIF.

IF matches( val = lv_str regex = '^[A-Z]+\d+$' ).
  WRITE: / 'Letters followed by digits'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Not only digits
Letters followed by digits
</code></pre>
<p><code>contains</code> checks if regex matches anywhere. <code>matches</code> checks if entire string matches.</p>
    </ul>
    <br/><br/>


    <li>Split and Join</li>
    <br/>
    <ul>
        <li>SPLIT statement:</li>
<pre><code class="language-text line-numbers">SPLIT &lt;string&gt; AT &lt;separator&gt; INTO &lt;v1&gt; &lt;v2&gt; ... .
SPLIT &lt;string&gt; AT &lt;separator&gt; INTO TABLE &lt;itab&gt;.
</code></pre>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'One,Two,Three'.
DATA lt_parts TYPE TABLE OF string.

SPLIT lv_str AT ',' INTO TABLE lt_parts.

LOOP AT lt_parts INTO DATA(lv_part).
  WRITE: / lv_part.
ENDLOOP.
</code></pre>
<pre><code class="language-text line-numbers">One
Two
Three
</code></pre>
        <br/>
        <li>Split into variables:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE '2024-12-15'.
DATA: lv_year TYPE string,
      lv_month TYPE string,
      lv_day TYPE string.

SPLIT lv_str AT '-' INTO lv_year lv_month lv_day.

WRITE: / 'Year:', lv_year.
WRITE: / 'Month:', lv_month.
WRITE: / 'Day:', lv_day.
</code></pre>
<pre><code class="language-text line-numbers">Year: 2024
Month: 12
Day: 15
</code></pre>
        <br/>
        <li>Join with concat_lines_of:</li>
<pre><code class="language-abap line-numbers">DATA lt_parts TYPE TABLE OF string.
APPEND 'One' TO lt_parts.
APPEND 'Two' TO lt_parts.
APPEND 'Three' TO lt_parts.

DATA(lv_joined) = concat_lines_of( table = lt_parts sep = ',' ).
WRITE: / lv_joined.

DATA(lv_lines) = concat_lines_of( table = lt_parts sep = cl_abap_char_utilities=&gt;newline ).
WRITE: / lv_lines.
</code></pre>
<pre><code class="language-text line-numbers">One,Two,Three
One
Two
Three
</code></pre>
    </ul>
    <br/><br/>


    <li>Reverse</li>
    <br/>
    <ul>
        <li>reverse function:</li>
<pre><code class="language-abap line-numbers">DATA lv_str TYPE string VALUE 'Hello'.

DATA(lv_rev) = reverse( lv_str ).
WRITE: / lv_rev.

* Check palindrome
DATA lv_word TYPE string VALUE 'radar'.
IF lv_word = reverse( lv_word ).
  WRITE: / lv_word, 'is a palindrome'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">olleH
radar is a palindrome
</code></pre>
    </ul>
    <br/><br/>


    <li>Repeat</li>
    <br/>
    <ul>
        <li>repeat function:</li>
<pre><code class="language-abap line-numbers">DATA(lv_line) = repeat( val = '-' occ = 20 ).
WRITE: / lv_line.

DATA(lv_pattern) = repeat( val = 'AB' occ = 5 ).
WRITE: / lv_pattern.
</code></pre>
<pre><code class="language-text line-numbers">--------------------
ABABABABAB
</code></pre>
    </ul>
    <br/><br/>


    <li>Character Utilities</li>
    <br/>
    <ul>
        <li>cl_abap_char_utilities constants:</li>
<pre><code class="language-abap line-numbers">* Newline
DATA(lv_with_newline) = |Line1{ cl_abap_char_utilities=&gt;newline }Line2|.
WRITE: / lv_with_newline.

* Carriage return + line feed (Windows)
DATA(lv_crlf) = cl_abap_char_utilities=&gt;cr_lf.

* Tab
DATA(lv_with_tab) = |Col1{ cl_abap_char_utilities=&gt;horizontal_tab }Col2|.
WRITE: / lv_with_tab.

* Check for digits only
IF cl_abap_char_utilities=&gt;str_is_digit( '12345' ) = abap_true.
  WRITE: / 'Only digits'.
ENDIF.
</code></pre>
<pre><code class="language-text line-numbers">Line1
Line2
Col1    Col2
Only digits
</code></pre>
    </ul>
    <br/><br/>


    <li>String Function Summary</li>
    <br/>
    <ul>
        <li>Quick reference:</li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>strlen( )</code></td>
            <td>Length excluding trailing spaces</td>
        </tr>
        <tr>
            <td><code>substring( )</code></td>
            <td>Extract part of string</td>
        </tr>
        <tr>
            <td><code>to_upper( )</code></td>
            <td>Convert to uppercase</td>
        </tr>
        <tr>
            <td><code>to_lower( )</code></td>
            <td>Convert to lowercase</td>
        </tr>
        <tr>
            <td><code>to_mixed( )</code></td>
            <td>Convert to mixed case</td>
        </tr>
        <tr>
            <td><code>condense( )</code></td>
            <td>Remove extra spaces</td>
        </tr>
        <tr>
            <td><code>shift_left( )</code></td>
            <td>Remove leading characters</td>
        </tr>
        <tr>
            <td><code>shift_right( )</code></td>
            <td>Remove trailing characters</td>
        </tr>
        <tr>
            <td><code>find( )</code></td>
            <td>Find substring position</td>
        </tr>
        <tr>
            <td><code>count( )</code></td>
            <td>Count occurrences</td>
        </tr>
        <tr>
            <td><code>replace( )</code></td>
            <td>Replace substring</td>
        </tr>
        <tr>
            <td><code>reverse( )</code></td>
            <td>Reverse string</td>
        </tr>
        <tr>
            <td><code>repeat( )</code></td>
            <td>Repeat string n times</td>
        </tr>
        <tr>
            <td><code>concat_lines_of( )</code></td>
            <td>Join table rows</td>
        </tr>
        <tr>
            <td><code>contains( )</code></td>
            <td>Check if contains substring/regex</td>
        </tr>
        <tr>
            <td><code>matches( )</code></td>
            <td>Check if entire string matches regex</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
