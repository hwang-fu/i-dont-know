<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Rust</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>

    .token.comment {
        color: #888;
    }
    .token.keyword {
        font-weight: 500;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    body {
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<nav id="toc" style="margin-bottom: 2rem;">
    <h2>üìò Rust Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#rust-cargo-create-project">Create Project with Cargo</a></li>
        <li><a href="#rust-comments">Comments</a></li>
        <li><a href="#rust-formatted-print">Formatted Print</a></li>
        <li><a href="#rust-primitives">Primitive</a></li>
        <li><a href="#rust-structs">Structs</a></li>
        <li><a href="#rust-enums">Enums</a></li>
        <li><a href="#rust-constants">Constants</a></li>
        <li><a href="#rust-variable-bindings">Variable Bindings</a></li>
        <li><a href="#rust-types">Types</a></li>
        <li><a href="#rust-conversion">Conversion</a></li>
    </ul>
</nav>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-cargo-create-project">Create Project with Cargo</h3>
<ol>
    <li><b>What Is Cargo?</b></li>
    <br/>
    <ul>
        <li><code>Cargo</code> is Rust's official build and package manager, similar to <code>npm</code> (JS), <code>pip</code> (Python), or <code>maven</code> (Java).</li>
        <br/>
        <li>It helps you:
            <ul>
                <li>create new projects</li>
                <li>build and run your code</li>
                <li>manage dependencies (crates)</li>
                <li>run tests, benchmarks, and more</li>
            </ul>
        </li>
        <br/>
        <li>You'll use Cargo for almost every non-trivial Rust project.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Check If Cargo Is Installed</b></li>
<pre><code class="language-bash line-numbers">$ cargo --version
cargo 1.80.0 (or similar)
</code></pre>
    <br/>
    <ul>
        <li>If Cargo is not found, install Rust using <code>rustup</code> from the official Rust website.</li>
        <br/>
        <li><code>rustup</code> will install:
            <ul>
                <li><code>rustc</code> ‚Äî the Rust compiler</li>
                <li><code>cargo</code> ‚Äî the package manager</li>
                <li><code>rustdoc</code> ‚Äî documentation tool</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Create a New Binary Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo new hello-rust
     Created binary (application) `hello-rust` package
</code></pre>
    <br/>
    <ul>
        <li>This creates a new directory <code>hello-rust/</code> containing a ready-to-build Rust project.</li>
        <br/>
        <li><code>cargo new &lt;name&gt;</code> by default creates a <u>binary crate</u> (an executable program).</li>
        <br/>
        <li>Move into the project directory:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ cd hello-rust
</code></pre>
    <br/>
    <br/>


    <li><b>Project Layout (Created by Cargo)</b></li>
<pre><code class="language-bash line-numbers">hello-rust/
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
    <br/>
    <ul>
        <li><code>Cargo.toml</code> ‚Äî project metadata and dependencies (TOML format).</li>
        <li><code>src/main.rs</code> ‚Äî entry point of the binary crate (contains <code>fn main()</code>).</li>
        <br/>
        <li>This is the minimal standard layout that Cargo expects.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inspecting <code>src/main.rs</code></b></li>
<pre><code class="language-rust line-numbers">fn main() {
    println!("Hello, world!");
}
</code></pre>
    <br/>
    <ul>
        <li>This is the default "Hello, world!" program generated by Cargo.</li>
        <br/>
        <li><code>fn main()</code> is the entry point; the program starts executing here.</li>
        <br/>
        <li>You can change the message or add more logic as needed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inspecting <code>Cargo.toml</code></b></li>
<pre><code class="language-toml line-numbers">[package]
name = "hello-rust"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
    <br/>
    <ul>
        <li><code>[package]</code> section:
            <ul>
                <li><code>name</code> ‚Äî crate name (used on crates.io if published).</li>
                <li><code>version</code> ‚Äî semantic version of your crate.</li>
                <li><code>edition</code> ‚Äî Rust edition (e.g. 2018, 2021).</li>
            </ul>
        </li>
        <br/>
        <li><code>[dependencies]</code> ‚Äî list of external crates your project uses (initially empty).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Build the Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo build
   Compiling hello-rust v0.1.0 (path/to/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
    <br/>
    <ul>
        <li>By default, Cargo builds in <u>debug mode</u> (fast compile, slower runtime).</li>
        <br/>
        <li>Build artifacts are placed under <code>target/debug/</code>:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ ls target/debug
hello-rust   # executable
</code></pre>
    <br/>
    <br/>


    <li><b>Run the Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo run
   Compiling hello-rust v0.1.0 (path/to/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target/debug/hello-rust`
Hello, world!
</code></pre>
    <br/>
    <ul>
        <li><code>cargo run</code> = <code>cargo build</code> + run the resulting binary.</li>
        <br/>
        <li>If nothing changed since last build, Cargo skips recompiling and just runs the existing executable.</li>
        <br/>
        <li>You can pass arguments after <code>--</code>:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ cargo run -- --help
</code></pre>
    <br/>
    <br/>


    <li><b>Create a Library Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo new my-lib --lib
     Created library `my-lib` package
</code></pre>
    <br/>
    <ul>
        <li><code>--lib</code> creates a <u>library crate</u> instead of a binary.</li>
        <br/>
        <li>Layout is slightly different:</li>
    </ul>
<pre><code class="language-bash line-numbers">my-lib/
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
    <br/>
    <ul>
        <li><code>src/lib.rs</code> is the library entry file, defining public functions, types, etc., that other crates can use.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Use <code>cargo init</code> in an Existing Directory</b></li>
<pre><code class="language-bash line-numbers">$ mkdir existing-project
$ cd existing-project
$ cargo init
     Created binary (application) `existing-project` package
</code></pre>
    <br/>
    <ul>
        <li><code>cargo init</code> turns the <u>current directory</u> into a Cargo project.</li>
        <br/>
        <li>Useful when you already have files and want to add Cargo support later.</li>
        <br/>
        <li>Use <code>cargo init --lib</code> to create a library crate instead.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Debug vs Release Builds</b></li>
<pre><code class="language-bash line-numbers"># Debug build (default)
$ cargo build

# Release build (optimized, slower compile)
$ cargo build --release
</code></pre>
    <br/>
    <ul>
        <li>Debug artifacts: <code>target/debug/...</code></li>
        <li>Release artifacts: <code>target/release/...</code></li>
        <br/>
        <li>Use <code>--release</code> when you care about <u>performance</u> (benchmarks, production builds).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Add Dependencies to Your Project</b></li>
<pre><code class="language-toml line-numbers">[dependencies]
rand = "0.8"
</code></pre>
    <br/>
    <ul>
        <li>Add crates under <code>[dependencies]</code> in <code>Cargo.toml</code>.</li>
        <br/>
        <li>Then use them in your code:</li>
    </ul>
<pre><code class="language-rust line-numbers">use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    let n: u8 = rng.gen_range(0..=9);
    println!("Random number: {n}");
}
</code></pre>
    <br/>
    <ul>
        <li>On next <code>cargo build</code> or <code>cargo run</code>, Cargo will:
            <ul>
                <li>download <code>rand</code> and its dependencies</li>
                <li>compile them and your project</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Cargo Commands for a New Project</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>cargo new &lt;name&gt;</code></td>
                <td>Create a new project directory with Cargo files</td>
            </tr>
            <tr>
                <td><code>cargo init</code></td>
                <td>Initialize Cargo in the current directory</td>
            </tr>
            <tr>
                <td><code>cargo build</code></td>
                <td>Compile the project (debug mode)</td>
            </tr>
            <tr>
                <td><code>cargo run</code></td>
                <td>Build and run the binary</td>
            </tr>
            <tr>
                <td><code>cargo check</code></td>
                <td>Type-check without producing binaries (faster feedback)</td>
            </tr>
            <tr>
                <td><code>cargo test</code></td>
                <td>Run tests (if any exist in <code>tests/</code> or <code>src</code>)</td>
            </tr>
            <tr>
                <td><code>cargo clean</code></td>
                <td>Remove the <code>target/</code> directory</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>For everyday development, you'll mostly use: <code>cargo run</code>, <code>cargo check</code>, and <code>cargo test</code>.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-comments">Comments in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust supports several kinds of comments, each serving a different purpose:</li>
        <br/>
        <ul>
            <li><b>Line comments</b> ‚Äî for normal explanations</li>
            <li><b>Block comments</b> ‚Äî for multi-line notes or temporarily disabling code</li>
            <li><b>Documentation comments</b> ‚Äî generate HTML docs and appear in <code>rustdoc</code></li>
        </ul>
        <br/>
        <li>Comments are ignored by the compiler (except documentation comments, which are processed by <code>rustdoc</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Line Comments (<code>//</code>)</b></li>
<pre><code class="language-rust line-numbers">// This is a single-line comment
let x = 10; // you can also put comments at the end of a line
</code></pre>
    <br/>
    <ul>
        <li>Starts with <code>//</code> and continues until the end of the line.</li>
        <li>Most common form of comments in Rust.</li>
        <li>Great for explaining logic or adding short descriptions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Block Comments (<code>/* ... */</code>)</b></li>
<pre><code class="language-rust line-numbers">/*
   This is a block comment.
   It can span multiple lines.
*/
let x = 5;
</code></pre>
    <br/>
    <ul>
        <li>Useful for larger explanations or temporarily disabling code.</li>
        <li>Can contain nested block comments ‚Äî Rust supports nesting!</li>
    </ul>

<pre><code class="language-rust line-numbers">/*
    Outer comment
    /*
        Nested comment ‚Äî valid!
    */
*/
</code></pre>

    <br/>
    <ul>
        <li>This makes large-scale commenting-out safer compared to languages like C/C++.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Documentation Comments (<code>///</code> and <code>//! </code>)</b></li>
    <br/>
    <ul>
        <li>Rust has two styles of documentation comments:</li>
        <ul>
            <li><b><code>///</code></b> ‚Äî for documenting items <u>that follow</u>.</li>
            <li><b><code>//! </code></b> ‚Äî for documenting containers (crate/module) <u>from within</u>.</li>
        </ul>
        <br/>
        <li>They support Markdown formatting and are used by <code>rustdoc</code> to generate HTML documentation.</li>
    </ul>
    <br/>

    <li><b>Documentation for Functions (<code>///</code>)</b></li>
<pre><code class="language-rust line-numbers">/// Adds two numbers together.
///
/// # Examples
/// ```
/// let sum = add(2, 3);
/// assert_eq!(sum, 5);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
    <br/>
    <ul>
        <li>Supports Markdown sections like:</li>
        <ul>
            <li><code># Examples</code></li>
            <li><code># Panics</code></li>
            <li><code># Safety</code></li>
            <li><code># Errors</code></li>
        </ul>
        <br/>
        <li>The examples are actually <u>compiled and tested</u> when running <code>cargo test</code>!</li>
    </ul>
    <br/>
    <br/>

    <li><b>Documentation for Modules or Crates (<code>//! </code>)</b></li>
<pre><code class="language-rust line-numbers">//! This is documentation for the entire module or crate.
//! It describes the purpose and structure at a high level.

//! You typically put this at the top of `lib.rs` or inside a module.
</code></pre>
    <br/>
    <ul>
        <li><code>//! </code> comments apply to the <u>enclosing item</u> (crate or module).</li>
        <li>Ideal for explaining architecture or high-level concepts.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inner vs Outer Documentation Comments</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Kind</th>
                <th>Syntax</th>
                <th>Applies To</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Outer doc</td>
                <td><code>///</code></td>
                <td>Item that follows</td>
            </tr>
            <tr>
                <td>Inner doc</td>
                <td><code>//! </code></td>
                <td>Enclosing module or crate</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Doc Comments Support Markdown</b></li>
<pre><code class="language-rust line-numbers">/// # Title
/// - Bullet point
/// - Another
///
/// `inline code`
///
/// ```rust
/// let x = 5;
/// println!("{}", x);
/// ```
fn demo() {}
</code></pre>
    <br/>
    <ul>
        <li>This Markdown is rendered into HTML when running <code>cargo doc</code>.</li>
        <li>You can use bold, italic, links, headings, code blocks, and tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generate Docs and Open Them</b></li>
<pre><code class="language-bash line-numbers">$ cargo doc --open
</code></pre>
    <br/>
    <ul>
        <li>Builds documentation using <code>rustdoc</code> and opens it in your browser.</li>
        <li>Includes documentation for your dependencies too.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Temporary Disabling Code with Block Comments</b></li>
<pre><code class="language-rust line-numbers">/*
fn calculate() {
    // temporarily disabled
}
*/
</code></pre>
    <br/>
    <ul>
        <li>Because Rust supports nested block comments, disabling large sections is safe:</li>
    </ul>
<pre><code class="language-rust line-numbers">/*
fn a() {}

/*
fn b() {}
*/

fn c() {}
*/
</code></pre>
    <br/>
    <ul>
        <li>Unlike C/C++, nested comments won't break the code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing the Right Comment Style</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use Case</th>
                <th>Style</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Explain a line of code</td>
                <td><code>//</code></td>
                <td><code>// explanation</code></td>
            </tr>
            <tr>
                <td>Explain a block or disable code</td>
                <td><code>/* ... */</code></td>
                <td><code>/* long comment */</code></td>
            </tr>
            <tr>
                <td>Document a function/struct/enum</td>
                <td><code>///</code></td>
                <td><code>/// Adds two numbers</code></td>
            </tr>
            <tr>
                <td>Document a module/crate</td>
                <td><code>//! </code></td>
                <td><code>//! Top-level docs</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-formatted-print">Formatted Print</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust provides a powerful and type-safe formatting system through <code>println!</code>, <code>print!</code>, <code>format!</code>, and related macros.</li>
        <br/>
        <li>The formatting engine is part of the <code>std::fmt</code> module and uses <u>traits</u> like <code>Display</code> and <code>Debug</code> to render values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Printing</b></li>
<pre><code class="language-rust line-numbers">fn main() {
    println!("Hello, world!");
    print!("No newline here");
}
</code></pre>
    <br/>
    <ul>
        <li><code>println!</code> appends a newline, <code>print!</code> does not.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing with Placeholder <code>{}</code></b></li>
<pre><code class="language-rust line-numbers">fn main() {
    let name = "Alice";
    let age = 30;

    println!("Name: {}, Age: {}", name, age);
}
</code></pre>
    <br/>
    <ul>
        <li><code>{}</code> is a placeholder for values implementing the <code>Display</code> trait.</li>
        <li>Strings, numbers, chars, and many built-in types support <code>Display</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Debug Formatting (<code>{:?}</code>)</b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug)]
struct User {
    id: u32,
    name: String,
}

fn main() {
    let u = User { id: 1, name: "Alice".into() };
    println!("{:?}", u);
}
</code></pre>
    <br/>
    <ul>
        <li><code>{:?}</code> requires the <code>Debug</code> trait.</li>
        <li>Use <code>{:#?}</code> for pretty-printed (multi-line) debug output.</li>
    </ul>
<pre><code class="language-rust line-numbers">println!("{:#?}", u);  // pretty debug
</code></pre>
    <br/>
    <br/>


    <li><b>Named Arguments</b></li>
<pre><code class="language-rust line-numbers">println!("x = {x}, y = {y}", x = 5, y = 10);
</code></pre>
    <br/>
    <ul>
        <li>Named arguments improve clarity in complex prints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Positional Arguments</b></li>
<pre><code class="language-rust line-numbers">println!("{0} + {0} = {1}", 5, 10);
</code></pre>
    <br/>
    <ul>
        <li>Use numeric indices to reuse arguments.</li>
        <li><code>{0}</code> refers to the first argument, <code>{1}</code> to the second.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting Numbers</b></li>
<pre><code class="language-rust line-numbers">println!("{:b}", 10);   // binary
println!("{:o}", 10);   // octal
println!("{:x}", 255);  // hex (lower)
println!("{:X}", 255);  // hex (upper)
println!("{:e}", 10.5); // scientific
</code></pre>
    <br/>
    <ul>
        <li>Format specifiers after a colon (<code>:</code>) control number formatting.</li>
        <li>Supported types depend on the <code>Display</code> or <code>Debug</code> implementation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Padding and Alignment</b></li>
<pre><code class="language-rust line-numbers">println!("{:&gt;10}", 42);   // right-align
println!("{:&lt;10}", 42);   // left-align
println!("{:^10}", 42);   // center-align
</code></pre>
    <br/>
    <ul>
        <li>Numbers specify the width of the formatted field.</li>
        <li>Alignment is controlled before the width:
            <ul>
                <li><code>&lt;</code> left-align</li>
                <li><code>&gt;</code> right-align</li>
                <li><code>^</code> center</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Custom Fill Characters</b></li>
<pre><code class="language-rust line-numbers">println!("{:*^10}", "hi");   // ****hi****
println!("{:-&lt;10}", "rust"); // rust------
</code></pre>
    <br/>
    <ul>
        <li>The first character before the alignment specifier becomes the fill.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Floating-Point Precision</b></li>
<pre><code class="language-rust line-numbers">println!("{:.2}", 3.14159);   // 3.14
println!("{:8.3}", 3.14159);  // '   3.142' (width + precision)
</code></pre>
    <br/>
    <ul>
        <li><code>.2</code> means 2 digits after the decimal.</li>
        <li>You can combine precision with width.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Format Strings with <code>format!</code></b></li>
<pre><code class="language-rust line-numbers">let msg = format!("Hello, {}", "world");
println!("{}", msg);
</code></pre>
    <br/>
    <ul>
        <li><code>format!</code> works like <code>println!</code> but returns a <code>String</code> instead of printing.</li>
        <li>Useful for building messages, logs, or UI output.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing to stderr (<code>eprintln!</code>)</b></li>
<pre><code class="language-rust line-numbers">eprintln!("This is an error message.");
</code></pre>
    <br/>
    <ul>
        <li><code>eprintln!</code> prints to standard error instead of stdout.</li>
        <li>Important for error reporting when stdout is used for program output.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Implementing <code>Display</code> for Custom Types</b></li>
<pre><code class="language-rust line-numbers">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 3, y: 4 };
    println!("{}", p);
}
</code></pre>
    <br/>
    <ul>
        <li>Implement <code>Display</code> when you want clean, user-friendly printing.</li>
        <li><code>Debug</code> (<code>{:?}</code>) is for debugging ‚Äî <code>Display</code> (<code>{}</code>) is for end-users.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Escape Sequences</b></li>
<pre><code class="language-rust line-numbers">println!("Line 1\nLine 2");
println!("Tab\tSeparated");
println!("Quote: \"text\"");
println!("Backslash: \\");
</code></pre>
    <br/>
    <ul>
        <li>Rust supports common escape sequences from C-like languages.</li>
        <li>Newlines, tabs, quotes, and backslashes must be escaped.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Raw Strings (No Escaping)</b></li>
<pre><code class="language-rust line-numbers">println!(r"Path: C:\Users\Alice\Documents");
println!(r#"He said, "Hello!""#);
println!(r##"Multiple # signs can be used"##);
</code></pre>
    <br/>
    <ul>
        <li>Raw strings start with <code>r"..."</code> or <code>r#"..."#</code>.</li>
        <li>Add more <code>#</code> signs when your string contains both quotes and <code>#</code> characters.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Format Specifier Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Specifier</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>{}</code></td>
                <td>Display</td>
                <td><code>"{}"</code></td>
            </tr>
            <tr>
                <td><code>{:?}</code></td>
                <td>Debug</td>
                <td><code>"{:?}"</code></td>
            </tr>
            <tr>
                <td><code>{:#?}</code></td>
                <td>Pretty Debug</td>
                <td><code>"{:#?}"</code></td>
            </tr>
            <tr>
                <td><code>{:b}</code></td>
                <td>Binary</td>
                <td><code>10 ‚Üí 1010</code></td>
            </tr>
            <tr>
                <td><code>{:x}</code></td>
                <td>Hex (lowercase)</td>
                <td><code>255 ‚Üí ff</code></td>
            </tr>
            <tr>
                <td><code>{:X}</code></td>
                <td>Hex (uppercase)</td>
                <td><code>255 ‚Üí FF</code></td>
            </tr>
            <tr>
                <td><code>{:o}</code></td>
                <td>Octal</td>
                <td><code>10 ‚Üí 12</code></td>
            </tr>
            <tr>
                <td><code>{:.N}</code></td>
                <td>Floating precision</td>
                <td><code>3.14</code></td>
            </tr>
            <tr>
                <td><code>{:width}</code></td>
                <td>Minimum field width</td>
                <td><code>"{:5}"</code></td>
            </tr>
            <tr>
                <td><code>{:&lt;}</code></td>
                <td>Left align</td>
                <td><code>"{:&lt;10}"</code></td>
            </tr>
            <tr>
                <td><code>{:&gt;}</code></td>
                <td>Right align</td>
                <td><code>"{:&gt;10}"</code></td>
            </tr>
            <tr>
                <td><code>{:^}</code></td>
                <td>Center align</td>
                <td><code>"{:^10}"</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Formatted output in Rust is powerful, flexible, and entirely type-checked at compile time.</li>
        <li>Understanding <code>{}</code>, <code>{:?}</code>, and format specifiers unlocks rich console logging and string formatting.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-primitives">Primitives in Rust</h3>
<ol>
    <li>Rust provides a set of <b>primitive types</b> (built-in types) that form the foundation of all Rust programs.</li>
    <br/>
    <li>Primitives are:
        <ul>
            <li><u>Copy</u> by default (except types containing heap allocations)</li>
            <li>Fast and efficient</li>
        </ul>
    </li>
    <br/>
    <li>Primitive categories include:
        <ul>
            <li>Scalar types</li>
            <li>Compound types</li>
            <li>Special types</li>
        </ul>
    </li>
    <br/>
    <br/>


    <li><b>Integer Types</b></li>
<pre><code class="language-rust line-numbers">let a: i32 = 10;    // signed 32-bit integer
let b: u64 = 20;    // unsigned 64-bit integer
let c = 100usize;   // machine pointer-sized unsigned integer
</code></pre>
    <br/>
    <ul>
        <li>Integer sizes:</li>
        <ul>
            <li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></li>
            <li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></li>
        </ul>
        <br/>
        <li><code>isize</code> and <code>usize</code> depend on platform pointer width (32-bit or 64-bit).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Number Literals</b></li>
<pre><code class="language-rust line-numbers">let dec = 98_222;
let hex = 0xff;
let oct = 0o77;
let bin = 0b1111_0000;
let byte = b'A'; // u8 only
</code></pre>
    <br/>
    <ul>
        <li>Underscores improve readability (<code>98_222</code>).</li>
        <li><code>b'A'</code> is a byte literal (<code>u8</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Floating-Point Types</b></li>
<pre><code class="language-rust line-numbers">let x = 3.14f32;    // 32-bit float
let y: f64 = 2.718; // 64-bit float (default)
</code></pre>
    <br/>
    <ul>
        <li>Floats use IEEE-754 format.</li>
        <li><code>f64</code> is the default because it is more precise.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean</b></li>
<pre><code class="language-rust line-numbers">let is_active: bool = true;
let is_valid = false;
</code></pre>
    <br/>
    <ul>
        <li>Boolean values: <code>true</code>, <code>false</code>.</li>
        <li>Used in conditions (<code>if</code>, <code>while</code>, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Character (Unicode Scalar Value)</b></li>
<pre><code class="language-rust line-numbers">let a = 'A';
let heart = '‚ù§';
let chinese = '‰∏≠';
let emoji = 'üöÄ';
</code></pre>
    <br/>
    <ul>
        <li><code>char</code> is <u>4 bytes</u> and stores a Unicode scalar value.</li>
        <li>Supports emoji and all languages.</li>
        <li>Not a byte ‚Äî that is <code>u8</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Tuples</b></li>
<pre><code class="language-rust line-numbers">let tup: (i32, f64, bool) = (10, 3.14, true);

let (x, y, z) = tup;  // destructuring

println!("y = {}", tup.1);
</code></pre>
    <br/>
    <ul>
        <li>Tuples group values of different types.</li>
        <li>Access with dot syntax (<code>tup.1</code>).</li>
        <li>Useful for returning multiple values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Arrays</b></li>
<pre><code class="language-rust line-numbers">let nums: [i32; 3] = [1, 2, 3];
let zeros = [0; 5]; // [0, 0, 0, 0, 0]
</code></pre>
    <br/>
    <ul>
        <li>Arrays have:
            <ul>
                <li>elements of the same type</li>
                <li>fixed length</li>
            </ul>
        </li>
        <br/>
        <li>Length is part of the type (<code>[i32; 3]</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Slices</b></li>
<pre><code class="language-rust line-numbers">let arr = [1, 2, 3, 4];
let slice: &amp;[i32] = &amp;arr[1..3];  // [2, 3]
</code></pre>
    <br/>
    <ul>
        <li>Slices are <u>references</u> to contiguous sequences.</li>
        <li><code>&amp;arr[..]</code> = slice of whole array.</li>
        <li>Slices do not own data, they borrow.</li>
    </ul>
    <br/>
    <br/>


    <li><b>String Slices</b></li>
<pre><code class="language-rust line-numbers">let s: &amp;str = "Hello";      // string slice
let part = &amp;s[0..2];        // slice bytes, careful with UTF-8
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;str</code> is an immutable UTF-8 string slice.</li>
        <li>Remember Rust strings are UTF-8 ‚Äî slicing must align with char boundaries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Owned String (<code>String</code>)</b></li>
<pre><code class="language-rust line-numbers">let mut s = String::from("Hello");
s.push_str(" World");
</code></pre>
    <br/>
    <ul>
        <li><code>String</code> owns the heap-allocated text.</li>
        <li>Growable and mutable.</li>
        <li>Frequently used in application code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Special Primitive: Unit (<code>()</code>)</b></li>
<pre><code class="language-rust line-numbers">fn do_something() {
    // returns () implicitly
}
</code></pre>
    <br/>
    <ul>
        <li><code>()</code> is a type with exactly one value: <code>()</code>.</li>
        <li>Used as the default return type for functions that return nothing.</li>
        <li>Similar to <code>void</code> in other languages but still a real type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Special Primitive: Never (<code>!</code>)</b></li>
<pre><code class="language-rust line-numbers">fn fail() -&gt; ! {
    panic!("Something went wrong");
}
</code></pre>
    <br/>
    <ul>
        <li><code>!</code> represents computations that never return.</li>
        <li>Examples:
            <ul>
                <li><code>panic!</code></li>
                <li>infinite loops</li>
                <li>functions that always <code>return Err</code> or <code>exit</code></li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Primitive Type Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Integer</td>
                <td><code>i*, u*</code></td>
                <td>Signed/unsigned integers</td>
            </tr>
            <tr>
                <td>Float</td>
                <td><code>f32, f64</code></td>
                <td>Floating-point numbers</td>
            </tr>
            <tr>
                <td>Boolean</td>
                <td><code>bool</code></td>
                <td><code>true</code>, <code>false</code></td>
            </tr>
            <tr>
                <td>Character</td>
                <td><code>char</code></td>
                <td>Unicode scalar value</td>
            </tr>
            <tr>
                <td>Tuple</td>
                <td><code>(T1, T2, ...)</code></td>
                <td>Fixed-size heterogeneous values</td>
            </tr>
            <tr>
                <td>Array</td>
                <td><code>[T; N]</code></td>
                <td>Fixed-size homogeneous values</td>
            </tr>
            <tr>
                <td>Slice</td>
                <td><code>&amp;[T]</code></td>
                <td>View into contiguous memory</td>
            </tr>
            <tr>
                <td>String Slice</td>
                <td><code>&amp;str</code></td>
                <td>UTF-8 string reference</td>
            </tr>
            <tr>
                <td>Owned String</td>
                <td><code>String</code></td>
                <td>Growable heap string</td>
            </tr>
            <tr>
                <td>Unit</td>
                <td><code>()</code></td>
                <td>No meaningful value</td>
            </tr>
            <tr>
                <td>Never</td>
                <td><code>!</code></td>
                <td>Function never returns</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>These primitives form the basis of all memory, data, and control flow in Rust programs.</li>
        <li>Understanding them is essential for mastering ownership, lifetime rules, and type safety.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-structs">Structs</h3>
<ol>
    <li>In Rust, a <u>struct</u> is a custom data type that groups related values together.</li>
    <br/>
    <li>Structs are similar to classes in other languages but without inheritance.</li>
    <br/>
    <li>Rust provides several types of structs:
        <ul>
            <li><b>Classic struct</b> (named fields)</li>
            <li><b>Tuple struct</b></li>
            <li><b>Unit-like struct</b></li>
        </ul>
    </li>
    <br/><br/>


    <li><b>Classic Structs (Named Fields)</b></li>
<pre><code class="language-rust line-numbers">struct User {
    id: u32,
    name: String,
    active: bool,
}

fn main() {
    let u = User {
        id: 1,
        name: String::from("Alice"),
        active: true,
    };

    println!("Name: {}", u.name);
}
</code></pre>
    <br/>
    <ul>
        <li>Fields must be initialized when creating the struct.</li>
        <li>Order of fields during initialization does not matter.</li>
        <li>Ownership rules apply: values like <code>String</code> are moved into the struct.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable Struct Instances</b></li>
<pre><code class="language-rust line-numbers">let mut user = User {
    id: 1,
    name: String::from("Alice"),
    active: true,
};

user.name = String::from("Bob");
</code></pre>
    <br/>
    <ul>
        <li>Use <code>mut</code> to modify struct fields.</li>
    </ul>
    <br/><br/>


    <li><b>Field Init Shorthand</b></li>
<pre><code class="language-rust line-numbers">let id = 1;
let name = String::from("Alice");

let user = User {
    id,
    name,
    active: true,
};
</code></pre>
    <br/>
    <ul>
        <li>If local variable names match field names, Rust allows shorter syntax.</li>
    </ul>
    <br/><br/>


    <li><b>Struct Update Syntax</b></li>
<pre><code class="language-rust line-numbers">let user1 = User {
    id: 1,
    name: String::from("Alice"),
    active: true,
};

let user2 = User {
    name: String::from("Bob"),
    ..user1
};
</code></pre>
    <br/>
    <ul>
        <li><code>..user1</code> copies all remaining fields from <code>user1</code>.</li>
        <li>Moves fields unless they implement <code>Copy</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Tuple Structs</b></li>
<pre><code class="language-rust line-numbers">struct Color(u8, u8, u8);
struct Point(f64, f64);

fn main() {
    let c = Color(255, 0, 128);
    let p = Point(10.5, 3.2);

    println!("Red = {}", c.0);
}
</code></pre>
    <br/>
    <ul>
        <li>Tuple structs act like tuples but with type names.</li>
        <li>Useful when giving meaning to tuple data.</li>
    </ul>
    <br/><br/>


    <li><b>Unit-Like Structs</b></li>
<pre><code class="language-rust line-numbers">struct Marker;

fn main() {
    let m = Marker;
}
</code></pre>
    <br/>
    <ul>
        <li>Contain no data.</li>
        <li>Often used as markers, traits, or zero-sized types.</li>
    </ul>
    <br/><br/>


    <li><b>Implementing Methods for Structs</b></li>
<pre><code class="language-rust line-numbers">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 20 };
    println!("Area: {}", rect.area());
}
</code></pre>
    <br/>
    <ul>
        <li>Methods are defined inside an <code>impl</code> block.</li>
        <li><code>&amp;self</code> means the method borrows the struct immutably.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable Methods</b></li>
<pre><code class="language-rust line-numbers">impl Rectangle {
    fn double_size(&amp;mut self) {
        self.width *= 2;
        self.height *= 2;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;mut self</code> means the method can modify the struct.</li>
    </ul>
    <br/><br/>


    <li><b>Associated Functions (Static Methods)</b></li>
<pre><code class="language-rust line-numbers">impl Rectangle {
    fn new(width: u32, height: u32) -&gt; Self {
        Self { width, height }
    }
}

let rect = Rectangle::new(5, 10);
</code></pre>
    <br/>
    <ul>
        <li>Associated functions use <code>Self</code> to construct new instances.</li>
        <li>Equivalent to "static factory methods" in other languages.</li>
    </ul>
    <br/><br/>


    <li><b>Debug Printing with <code>#[derive(Debug)]</code></b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug)]
struct User {
    id: u32,
    name: String,
}

fn main() {
    let u = User { id: 1, name: "Alice".into() };
    println!("{:?}", u);
    println!("{:#?}", u); // pretty-print
}
</code></pre>
    <br/>
    <ul>
        <li>Enables debug formatting using <code>{:?}</code> and <code>{:#?}</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Ownership and Structs</b></li>
<pre><code class="language-rust line-numbers">struct User {
    name: String,
}

let u1 = User { name: String::from("Alice") };
let u2 = u1;                // move occurs
// println!("{}", u1.name); // ERROR: moved
</code></pre>
    <br/>
    <ul>
        <li>Rust moves ownership when assigning or passing structs that contain heap data.</li>
        <li>Types implementing <code>Copy</code> (e.g., <code>i32</code>) behave differently.</li>
    </ul>
    <br/><br/>


    <li><b>Struct Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Struct Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Classic</td>
                <td>Named fields</td>
                <td><code>struct User { id: u32 }</code></td>
            </tr>
            <tr>
                <td>Tuple</td>
                <td>Unnamed fields</td>
                <td><code>struct Point(i32, i32)</code></td>
            </tr>
            <tr>
                <td>Unit-like</td>
                <td>No fields</td>
                <td><code>struct Marker;</code></td>
            </tr>
            <tr>
                <td>With methods</td>
                <td>Use <code>impl</code> for methods</td>
                <td><code>impl User { fn new() {} }</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Structs are the main building blocks for modeling data in Rust.</li>
        <li>Combine them with <code>impl</code> blocks for powerful and expressive types.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-enums">Enums</h3>
<ol>
    <li>Rust's <b>enum</b> (short for *enumeration*) is one of its most powerful and expressive features.</li>
    <br/>
    <li>Enums allow you to define a type that can be one of several variants.</li>
    <br/>
    <li>Unlike enums in languages like C, Rust enums can store <u>data inside each variant</u>.</li>
    <br/>
    <li>Combined with <code>match</code>, enums enable expressive and type-safe control flow.</li>
    <br/><br/>


    <li><b>Basic Enum</b></li>
<pre><code class="language-rust line-numbers">enum Direction {
    Up,
    Down,
    Left,
    Right,
}

fn main() {
    let d = Direction::Up;
}
</code></pre>
    <br/>
    <ul>
        <li>Each variant is namespaced under the enum type: <code>Direction::Up</code>.</li>
        <li>Variants have no associated data in this form.</li>
    </ul>
    <br/><br/>


    <li><b>Enums with Data</b></li>
<pre><code class="language-rust line-numbers">enum Message {
    Quit,                    // no data
    Move { x: i32, y: i32 }, // named fields
    Write(String),           // tuple-like
    ChangeColor(u8, u8, u8), // tuple-like with multiple values
}
</code></pre>
    <br/>
    <ul>
        <li>Rust enums can contain:
            <ul>
                <li>struct-like variants</li>
                <li>tuple-like variants</li>
                <li>unit variants</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Using Enums with <code>match</code></b></li>
<pre><code class="language-rust line-numbers">fn process(msg: Message) {
    match msg {
        Message::Quit           =&gt; println!("Quit"),
        Message::Move { x, y }  =&gt; println!("Move to ({}, {})", x, y),
        Message::Write(text)    =&gt; println!("Text: {}", text),
        Message::ChangeColor(r, g, b) =&gt;
            println!("Color change: ({}, {}, {})", r, g, b),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>match</code> enforces exhaustive handling.</li>
        <li>Pattern matching allows extraction of data from variants.</li>
    </ul>
    <br/><br/>


    <li><b>Enum with Methods</b></li>
<pre><code class="language-rust line-numbers">enum Shape {
    Circle(f64),
    Rectangle { w: f64, h: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Circle(r)          =&gt; std::f64::consts::PI * r * r,
            Shape::Rectangle { w, h } =&gt; w * h,
        }
    }
}

fn main() {
    let c = Shape::Circle(3.0);
    println!("Area: {}", c.area());
}
</code></pre>
    <br/>
    <ul>
        <li>Enums can have <code>impl</code> blocks just like structs.</li>
        <li>Methods receive <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code>.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>Option&lt;T&gt;</code> Enum</b></li>
<pre><code class="language-rust line-numbers">enum Option&lt;T&gt; {
    Some(T),
    None,
}

let x: Option&lt;i32&gt; = Some(10);
let y: Option&lt;i32&gt; = None;
</code></pre>
    <br/>
    <ul>
        <li>Rust does not have null.</li>
        <li><code>Option&lt;T&gt;</code> is the safe alternative.</li>
        <li>It prevents null pointer errors at compile time.</li>
    </ul>
    <br/><br/>


    <li><b>Matching on Option</b></li>
<pre><code class="language-rust line-numbers">fn print_number(n: Option&lt;i32&gt;) {
    match n {
        Some(value) =&gt; println!("Value = {}", value),
        None        =&gt; println!("No value"),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>match</code> is used to safely handle both possibilities.</li>
    </ul>
    <br/><br/>


    <li><b><code>if let</code> for Convenience</b></li>
<pre><code class="language-rust line-numbers">let n = Some(10);

if let Some(value) = n {
    println!("Value = {}", value);
}
</code></pre>
    <br/>
    <ul>
        <li><code>if let</code> handles one pattern and ignores others.</li>
        <li>Useful for simple matches.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>Result&lt;T, E&gt;</code> Enum</b></li>
<pre><code class="language-rust line-numbers">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err(String::from("Divide by zero"))
    } else {
        Ok(a / b)
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>Result</code> is Rust's standard error-handling type.</li>
        <li><code>Ok</code> stores success values.</li>
        <li><code>Err</code> stores error values.</li>
    </ul>
    <br/><br/>


    <li><b>C-like Enums (Discriminants)</b></li>
<pre><code class="language-rust line-numbers">enum Status {
    Ready = 1,
    Busy  = 2,
    Error = 3,
}

let x = Status::Busy as i32;
</code></pre>
    <br/>
    <ul>
        <li>Variants may have explicit integer values.</li>
        <li>Useful for FFI, bitflags, or low-level work.</li>
    </ul>
    <br/><br/>


    <li><b>Enums with <code>#[derive]</code></b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug, Clone, Copy)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
</code></pre>
    <br/>
    <ul>
        <li><code>derive</code> enables traits like:
            <ul>
                <li><code>Debug</code></li>
                <li><code>Copy</code></li>
                <li><code>Clone</code></li>
                <li><code>Eq</code></li>
                <li><code>Hash</code></li>
            </ul>
        </li>
        <li>Useful when variants have no owned heap data.</li>
    </ul>
    <br/><br/>


    <li><b>Enum Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Enum Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Unit Variant</td>
                <td>No data</td>
                <td><code>Quit</code></td>
            </tr>
            <tr>
                <td>Tuple Variant</td>
                <td>Unnamed fields</td>
                <td><code>Write(String)</code></td>
            </tr>
            <tr>
                <td>Struct Variant</td>
                <td>Named fields</td>
                <td><code>Move { x: i32, y: i32 }</code></td>
            </tr>
            <tr>
                <td>Methods on Enums</td>
                <td>Via <code>impl</code> block</td>
                <td><code>fn area(&amp;self)</code></td>
            </tr>
            <tr>
                <td><code>Option&lt;T&gt;</code></td>
                <td>Nullable alternative</td>
                <td><code>Some(10), None</code></td>
            </tr>
            <tr>
                <td><code>Result&lt;T, E&gt;</code></td>
                <td>Error handling</td>
                <td><code>Ok(x), Err(e)</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Enums allow modeling of all possible states of a value in a type-safe way.</li>
        <li>They work seamlessly with <code>match</code> and pattern matching.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-constants">Constants in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust provides <code>const</code> and <code>static</code> for defining values that are known for the entire program runtime.</li>
        <br/>
        <li>They differ from <code>let</code> bindings:
            <ul>
                <li><code>let</code> creates variables on the stack (by default immutable, but can be <code>mut</code>).</li>
                <li><code>const</code> creates inlined compile-time constants.</li>
                <li><code>static</code> creates a single <u>global memory location</u> with a fixed address.</li>
            </ul>
        </li>
        <br/>
        <li>Both <code>const</code> and <code>static</code> must have an explicit type annotation and a value that can be evaluated at compile time.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Defining a <code>const</code> Value</b></li>
<pre><code class="language-rust line-numbers">const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.141_592_653_589;
</code></pre>
    <br/>
    <ul>
        <li><code>const</code> items:
            <ul>
                <li>Must have a type: <code>MAX_POINTS: u32</code>.</li>
                <li>Must be initialized with a compile-time expression.</li>
            </ul>
        </li>
        <br/>
        <li>By convention, constant names use <b>SCREAMING_SNAKE_CASE</b> (<code>MAX_POINTS</code>, <code>DEFAULT_TIMEOUT</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constants vs <code>let</code> Variables</b></li>
<pre><code class="language-rust line-numbers">const MAX_USERS: u32 = 1_000;

fn main() {
    let current_users = 10;    // runtime variable
    println!("Current: {}, max: {}", current_users, MAX_USERS);
}
</code></pre>
    <br/>
    <ul>
        <li><code>MAX_USERS</code> is usable <u>everywhere</u> in the crate where it is visible, including in other <code>const</code> expressions and array sizes.</li>
        <br/>
        <li><code>let current_users</code>:
            <ul>
                <li>Lives only in <code>main</code>.</li>
                <li>Is created at runtime.</li>
            </ul>
        </li>
        <br/>
        <li>Constants are often used for:
            <ul>
                <li>Configuration values</li>
                <li>Array lengths</li>
                <li>Compile-time flags and limits</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Scope of Constants</b></li>
<pre><code class="language-rust line-numbers">const GLOBAL_LIMIT: u32 = 10_000;

fn main() {
    const LOCAL_FACTOR: u32 = 2;
    println!("Global = {}, local = {}", GLOBAL_LIMIT, LOCAL_FACTOR);
}
</code></pre>
    <br/>
    <ul>
        <li><code>const</code> can be declared:
            <ul>
                <li>At the module/root level (like <code>GLOBAL_LIMIT</code>).</li>
                <li>Inside functions (like <code>LOCAL_FACTOR</code>).</li>
            </ul>
        </li>
        <br/>
        <li>Scope rules are similar to <code>let</code> bindings: a <code>const</code> defined in a function is visible only inside that function.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constants in Types and Array Sizes</b></li>
<pre><code class="language-rust line-numbers">const ROWS: usize = 3;
const COLS: usize = 4;

fn main() {
    let matrix: [[i32; COLS]; ROWS] = [[0; COLS]; ROWS];
    println!("Matrix has {} rows and {} cols", ROWS, COLS);
}
</code></pre>
    <br/>
    <ul>
        <li>Constants can be used in:
            <ul>
                <li>Array lengths</li>
                <li>Generic parameters</li>
                <li>Other <code>const</code> expressions</li>
            </ul>
        </li>
        <br/>
        <li>This is something <code>let</code> bindings cannot do, because they are not available at compile time.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>static</code> Variables (Global Storage)</b></li>
<pre><code class="language-rust line-numbers">static APP_NAME: &amp;str = "My Rust App";
static MAX_CONNECTIONS: u32 = 1024;
</code></pre>
    <br/>
    <ul>
        <li><code>static</code> defines a <u>single location in memory</u> with a fixed address.</li>
        <br/>
        <li>Properties of <code>static</code> items:
            <ul>
                <li>Have a <code>'static</code> lifetime (live for the entire duration of the program).</li>
                <li>May be accessed from anywhere in the program where they are visible.</li>
                <li>Must have a type annotation and a compile-time initializer, just like <code>const</code>.</li>
            </ul>
        </li>
        <br/>
        <li>A common pattern is to store a <code>&amp;'static str</code>:
<pre><code class="language-rust line-numbers">static WELCOME: &amp;str = "Welcome to Rust!";
</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b><code>static mut</code> and Safety</b></li>
<pre><code class="language-rust line-numbers">static mut COUNTER: u32 = 0;

fn main() {
    unsafe {
        COUNTER += 1;
        println!("COUNTER = {}", COUNTER);
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>static mut</code> allows mutable global state.</li>
        <br/>
        <li>However, reading or writing a <code>static mut</code> is <b>unsafe</b>:
            <ul>
                <li>Requires an <code>unsafe</code> block.</li>
                <li>Can easily introduce data races in concurrent code.</li>
            </ul>
        </li>
        <br/>
        <li>Recommended approach:
            <ul>
                <li>Avoid <code>static mut</code> when possible.</li>
                <li>Prefer safe wrappers like <code>Mutex&lt;T&gt;</code>, <code>RwLock&lt;T&gt;</code> or atomic types in <code>std::sync</code> and <code>std::sync::atomic</code> inside a <code>static</code>.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>static</code> with Interior Mutability</b></li>
<pre><code class="language-rust line-numbers">use std::sync::Mutex;

static COUNTER: Mutex&lt;u32&gt; = Mutex::new(0);

fn main() {
    let mut n = COUNTER.lock().unwrap();
    *n += 1;
    println!("COUNTER = {}", *n);
}
</code></pre>
    <br/>
    <ul>
        <li>Here <code>COUNTER</code> is <b>not</b> <code>mut</code>, but the data <u>inside</u> the <code>Mutex</code> can change.</li>
        <br/>
        <li>This pattern:
            <ul>
                <li>Stays thread-safe.</li>
                <li>Avoids <code>unsafe</code>.</li>
                <li>Is the idiomatic way to represent mutable global state.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b><code>const fn</code> and Computed Constants</b></li>
<pre><code class="language-rust line-numbers">const fn square(x: i32) -&gt; i32 {
    x * x
}

const FOUR: i32 = square(2);
const SIXTEEN: i32 = square(4);
</code></pre>
    <br/>
    <ul>
        <li><code>const fn</code> defines a function that can be evaluated at compile time (under certain rules).</li>
        <br/>
        <li>Such functions can be used in:
            <ul>
                <li><code>const</code> initializers</li>
                <li><code>static</code> initializers</li>
                <li>Array sizes and other compile-time contexts</li>
            </ul>
        </li>
        <br/>
        <li>Not all operations are allowed inside <code>const fn</code>, but the set of allowed operations grows with newer Rust versions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Summary: <code>const</code> vs <code>static</code> vs <code>let</code></b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Keyword</th>
                <th>When Evaluated</th>
                <th>Storage</th>
                <th>Mutability</th>
                <th>Typical Use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>let</code></td>
                <td>Runtime</td>
                <td>Stack (or moved to heap inside types)</td>
                <td>Immutable by default, can be <code>mut</code></td>
                <td>Normal variables, function-local state</td>
            </tr>
            <tr>
                <td><code>const</code></td>
                <td>Compile time</td>
                <td>Inlined, no single fixed address</td>
                <td>Always immutable</td>
                <td>Global configuration, array sizes, generic parameters</td>
            </tr>
            <tr>
                <td><code>static</code></td>
                <td>Compile-time initialization</td>
                <td>Single fixed memory location</td>
                <td>Immutable by default, <code>static mut</code> is unsafe</td>
                <td>Global data with <code>'static</code> lifetime</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Use <code>let</code> for ordinary values, <code>const</code> for compile-time constants, and <code>static</code> only when you truly need a global memory location.</li>
        <li>For mutable global state, prefer safe wrappers (like <code>Mutex</code> or atomics) inside <code>static</code> instead of <code>static mut</code>.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-variable-bindings">Variable Bindings</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Rust, variables are created using <code>let</code> and are called <u>bindings</u>.</li>
        <br/>
        <li>Bindings are immutable by default, meaning their value cannot be changed after assignment.</li>
        <br/>
        <li>Rust encourages immutability for safety and ease of reasoning, but allows mutation with <code>mut</code> when needed.</li>
        <br/>
        <li>Bindings can also use patterns, shadowing, type annotations, and destructuring.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Immutable Binding</b></li>
<pre><code class="language-rust line-numbers">let x = 10;
println!("x = {}", x);
</code></pre>
    <br/>
    <ul>
        <li><code>let x = 10;</code> binds <code>x</code> to the value <code>10</code>.</li>
        <li>The binding is immutable ‚Äî <code>x</code> cannot be changed after this point.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable Binding</b></li>
<pre><code class="language-rust line-numbers">let mut count = 0;
count += 1;
println!("count = {}", count);
</code></pre>
    <br/>
    <ul>
        <li><code>mut</code> allows changing the value of the binding.</li>
        <li>Mutation affects only the binding, not necessarily the value's ownership rules.</li>
        <li>Use mutation only when necessary.</li>
    </ul>
    <br/><br/>


    <li><b>Type Annotations</b></li>
<pre><code class="language-rust line-numbers">let x: i32 = 42;
let name: &amp;str = "Alice";
</code></pre>
    <br/>
    <ul>
        <li>Rust usually infers types automatically.</li>
        <li>Type annotations are needed when:
            <ul>
                <li>Type inference is ambiguous.</li>
                <li>You want to guide or constrain the type.</li>
                <li>Working with generics or traits.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Shadowing</b></li>
<pre><code class="language-rust line-numbers">let x = 5;
let x = x + 1;   // shadows the previous x
{
    let x = x * 2;
    println!("x inside block = {}", x); // 12
}
println!("x outside block = {}", x);     // 6
</code></pre>
    <br/>
    <ul>
        <li>Shadowing allows creating a <u>new binding</u> with the same name.</li>
        <li>The new binding <u>replaces</u> the previous one within that scope.</li>
        <li>Unlike <code>mut</code>, shadowing can change:
            <ul>
                <li>the type</li>
                <li>the mutability</li>
                <li>the structure of the value</li>
            </ul>
        </li>
        <br/>
        <li>Shadowing is useful for transformations:</li>
<pre><code class="language-rust line-numbers">let spaces = "    ";
let spaces = spaces.len();
</code></pre>
        <li>Here, a <code>&amp;str</code> becomes a <code>usize</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Destructuring Bindings</b></li>
<pre><code class="language-rust line-numbers">let (a, b, c) = (1, 2, 3);
println!("a = {}, b = {}, c = {}", a, b, c);
</code></pre>
    <br/>
    <ul>
        <li>Rust allows <u>pattern matching</u> in variable bindings.</li>
        <li>Patterns include:
            <ul>
                <li>Tuples</li>
                <li>Structs</li>
                <li>Enums</li>
                <li>Nested patterns</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-rust line-numbers">struct Point { x: i32, y: i32 }

let p = Point { x: 10, y: 20 };
let Point { x, y } = p;
println!("x = {}, y = {}", x, y);
</code></pre>

    <br/>
    <ul>
        <li>Use <code>_</code> to ignore values:</li>
    </ul>

<pre><code class="language-rust line-numbers">let (x, _) = (10, 99);
</code></pre>
    <br/><br/>


    <li><b>Binding by Reference</b></li>
<pre><code class="language-rust line-numbers">let x     = 10;
let ref_x = &amp;x;

println!("ref_x = {}", ref_x);
</code></pre>
    <br/>
    <ul>
        <li>Bindings can store references.</li>
        <li>You can also destructure references:</li>
<pre><code class="language-rust line-numbers">let value = 5;
let &amp;ref_to_value = &amp;value;
// let ref_to_value = value;  // same end result for Copy types

println!("{}", ref_to_value); // 5
</code></pre>
    </ul>
    <br/><br/>


    <li><b>Mutable References as Bindings</b></li>
<pre><code class="language-rust line-numbers">let mut x = 10;
let y     = &amp;mut x;
*y += 5;
println!("x = {}", x);
</code></pre>
    <br/>
    <ul>
        <li>Mutable references require the original binding to be <code>mut</code>.</li>
        <li>The borrowchecker enforces rules: only <u>one</u> mutable reference allowed at a time.</li>
    </ul>
    <br/><br/>


    <li><b>Binding with <code>match</code> Patterns</b></li>
<pre><code class="language-rust line-numbers">let numbers = vec![1, 2, 3];

match numbers.as_slice() {
    [first, .., last] =&gt; println!("first = {}, last = {}", first, last),
    _                 =&gt; println!("Too short"),
}
</code></pre>
    <br/><br/>


    <li><b>Using <code>let</code> in <code>if</code> and <code>while let</code></b></li>
<pre><code class="language-rust line-numbers">if let Some(n) = Some(5) {
    println!("n = {}", n);
}
</code></pre>

<pre><code class="language-rust line-numbers">let mut v = vec![1, 2, 3];

while let Some(n) = v.pop() {
    println!("popped {}", n);
}
</code></pre>
    <br/>
    <ul>
        <li><code>if let</code> is for matching a single pattern.</li>
        <li><code>while let</code> runs repeatedly as long as the pattern matches.</li>
        <li>Both rely on variable binding through patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Freezing via Immutable Binding</b></li>
<pre><code class="language-rust line-numbers">let mut x = 10;
let y     = &amp;x;

println!("y = {}", y);

// x += 1; // ERROR: x frozen while y exists
</code></pre>
    <br/>
    <ul>
        <li>An immutable reference "freezes" the original variable: it cannot be mutated while the reference exists.</li>
        <li>Rules enforced by the borrowchecker guarantee safe access.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Variable Binding Rules</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Binding Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Immutable by default</td>
                <td>Cannot change value</td>
                <td><code>let x = 5;</code></td>
            </tr>
            <tr>
                <td>Mutable binding</td>
                <td>Explicit <code>mut</code> required</td>
                <td><code>let mut x = 5;</code></td>
            </tr>
            <tr>
                <td>Shadowing</td>
                <td>Create new binding with same name</td>
                <td><code>let x = x + 1;</code></td>
            </tr>
            <tr>
                <td>Pattern binding</td>
                <td>Destructure tuples, structs, enums</td>
                <td><code>let (a, b) = pair;</code></td>
            </tr>
            <tr>
                <td>Move semantics</td>
                <td>Non-Copy values move on assignment</td>
                <td><code>let t = s;</code></td>
            </tr>
            <tr>
                <td>Binding references</td>
                <td>Store <code>&amp;</code> or <code>&amp;mut</code></td>
                <td><code>let r = &amp;x;</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-types">Types</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust is a <u>statically typed</u> language, meaning every value has a known type at compile time.</li>
        <br/>
        <li>Most types fall into these categories:
            <ul>
                <li>Primitive types</li>
                <li>Compound types</li>
                <li>User-defined types (structs, enums)</li>
                <li>Reference types</li>
                <li>Function and closure types</li>
                <li>Generic and trait object types</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Type Inference</b></li>
<pre><code class="language-rust line-numbers">let x    = 10;          // inferred as i32
let name = "Alice";     // inferred as &amp;str
</code></pre>
    <br/><br/>


    <li><b>Annotating Types Explicitly</b></li>
<pre><code class="language-rust line-numbers">let x: i64 = 100;
let flag: bool = true;
let scores: [i32; 3] = [10, 20, 30];
</code></pre>
    <br/>
    <ul>
        <li>Type annotations follow the pattern: <code>let name: Type</code>.</li>
        <li>Annotations improve clarity and integration in complex codebases.</li>
    </ul>
    <br/><br/>


    <li><b>Type Aliases</b></li>
<pre><code class="language-rust line-numbers">type Kilometers = i32;

let distance: Kilometers = 50;
</code></pre>
    <br/>
    <ul>
        <li>Aliases introduce new names for existing types.</li>
        <li>This does <u>not</u> create a new type ‚Äî only a new label.</li>
        <li>Useful for readability, domain-specific naming, or complex types.</li>
    </ul>

<pre><code class="language-rust line-numbers">type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;
</code></pre>
    <br/><br/>


    <li><b>Primitive Types (Built-in)</b></li>
    <br/>
    <ul>
        <li>Primitive types include:
            <ul>
                <li>Integers: <code>i8</code>.. <code>i128</code>, <code>u8</code>.. <code>u128</code>, <code>isize</code>, <code>usize</code></li>
                <li>Floating: <code>f32</code>, <code>f64</code></li>
                <li>Boolean: <code>bool</code></li>
                <li>Character: <code>char</code></li>
                <li>Tuples: <code>(T1, T2, ...)</code></li>
                <li>Arrays: <code>[T; N]</code></li>
                <li>Slices: <code>&amp;[T]</code></li>
                <li>String slice: <code>&amp;str</code></li>
                <li>String: <code>String</code></li>
                <li>Unit: <code>()</code></li>
                <li>Never: <code>!</code></li>
            </ul>
        </li>
        <br/>
        <li>Primitive types are covered in detail in the ‚ÄúPrimitives‚Äù chapter.</li>
    </ul>
    <br/><br/>


    <li><b>Compound Types</b></li>
<pre><code class="language-rust line-numbers">let tup: (i32, &amp;str) = (10, "Hi");
let arr: [u8; 4] = [1, 2, 3, 4];
</code></pre>
    <br/>
    <ul>
        <li>Compound types group multiple values together.</li>
        <li>Rust supports tuples and arrays as built-in compound types.</li>
        <li>More expressive types can be created with structs and enums.</li>
    </ul>
    <br/><br/>


    <li><b>User-Defined Types</b></li>
<pre><code class="language-rust line-numbers">struct User {
    id: u32,
    name: String,
}

enum Direction {
    Up,
    Down,
    Left,
    Right,
}

type Id = u64;
</code></pre>
    <br/><br/>


    <li><b>Reference Types</b></li>
<pre><code class="language-rust line-numbers">let x = 10;
let r1: &amp;i32 = &amp;x;

let mut y = 20;
let r2: &amp;mut i32 = &amp;mut y;
</code></pre>
    <br/>
    <ul>
        <li>References allow borrowing values without taking ownership.</li>
        <br/>
        <li>Two main reference types:
            <ul>
                <li><code>&amp;T</code> ‚Äî shared reference (immutable)</li>
                <li><code>&amp;mut T</code> ‚Äî mutable reference</li>
            </ul>
        </li>
        <br/>
        <li>Rules enforced by borrowchecker ensure memory safety:
            <ul>
                <li>Any number of immutable borrows</li>
                <li>Exactly one mutable borrow</li>
                <li>Mutable and immutable borrows cannot coexist</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Function Types</b></li>
<pre><code class="language-rust line-numbers">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
    <br/>
    <ul>
        <li>Function items have a unique type based on their signature.</li>
        <li>They can be referenced using <code>fn</code> pointer types:</li>
<pre><code class="language-rust line-numbers">let f: fn(i32, i32) -&gt; i32 = add;
println!("{}", f(3, 4));
</code></pre>
        <li>Function types:
            <ul>
                <li>Are zero-sized</li>
                <li>Can be passed around like values</li>
                <li>Useful for callbacks and functional programming patterns</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Closure Types</b></li>
<pre><code class="language-rust line-numbers">let add = |x: i32, y: i32| x + y;
println!("{}", add(2, 3));
</code></pre>
    <br/>
    <ul>
        <li>Closures capture their environment.</li>
        <li>Different closure traits:
            <ul>
                <li><code>Fn</code> ‚Äî captures immutably</li>
                <li><code>FnMut</code> ‚Äî captures mutably</li>
                <li><code>FnOnce</code> ‚Äî consumes captured values</li>
            </ul>
        </li>
        <br/>
        <li>Closures have unique anonymous types generated by the compiler.</li>
        <li>Used heavily in iterator pipelines and functional patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Generic Types</b></li>
<pre><code class="language-rust line-numbers">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let p = Point { x: 1.0, y: 2.0 };
</code></pre>
    <br/>
    <ul>
        <li>Generics allow writing code that works with many types.</li>
        <br/>
        <li>Rust performs monomorphization:
            <ul>
                <li>The compiler generates concrete specialized versions.</li>
                <li>No runtime overhead.</li>
            </ul>
        </li>
        <br/>
        <li>Generics appear in:
            <ul>
                <li>Structs</li>
                <li>Enums</li>
                <li>Functions</li>
                <li>Traits</li>
                <li>Implementations</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Trait Object Types (<code>dyn Trait</code>)</b></li>
<pre><code class="language-rust line-numbers">trait Speak {
    fn speak(&amp;self);
}

struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) { println!("Woof"); }
}

let animal: &amp;dyn Speak = &amp;Dog;
animal.speak();
</code></pre>
    <br/>
    <ul>
        <li>Trait objects enable dynamic dispatch through <code>dyn Trait</code>.</li>
        <br/>
        <li>Used when:
            <ul>
                <li>The exact type is not known at compile time.</li>
                <li>You need heterogeneous collections of different types.</li>
            </ul>
        </li>
        <br/>
        <li>Requires the trait to be <u>object-safe</u>.</li>
    </ul>
    <br/><br/>


    <li><b>Never Type (<code>!</code>)</b></li>
<pre><code class="language-rust line-numbers">fn crash() -&gt; ! {
    panic!("boom");
}
</code></pre>
    <br/>
    <ul>
        <li><code>!</code> means a function never returns.</li>
        <li>Used for:
            <ul>
                <li>panics</li>
                <li>infinite loops</li>
                <li>process termination</li>
            </ul>
        </li>
        <li>The never type can coerce into any other type.</li>
    </ul>
    <br/><br/>


    <li><b>Type Coercions</b></li>
<pre><code class="language-rust line-numbers">let s: &amp;str = "Hello";
let slice: &amp;[u8] = s.as_bytes();
</code></pre>
    <br/>
    <ul>
        <li>Rust performs very limited implicit coercions.</li>
        <br/>
        <li>Allowed coercions:
            <ul>
                <li><code>&amp;String</code> ‚Üí <code>&amp;str</code></li>
                <li><code>&amp;Vec&lt;T&gt;</code> ‚Üí <code>&amp;[T]</code></li>
                <li><code>T</code> ‚Üí <code>dyn Trait</code> (trait object)</li>
                <li><code>! </code> ‚Üí any type</li>
            </ul>
        </li>
        <br/>
        <li>Unlike languages like C/C++, Rust does not do:
            <ul>
                <li>integer promotions</li>
                <li>implicit float conversions</li>
                <li>pointer arithmetic</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Summary of Rust Type Categories</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Description</th>
                <th>Examples</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Primitive</td>
                <td>Built-in low-level types</td>
                <td><code>i32</code>, <code>bool</code>, <code>char</code>, <code>&amp;str</code></td>
            </tr>
            <tr>
                <td>User-defined</td>
                <td>Custom structs, enums, aliases</td>
                <td><code>struct User</code>, <code>enum Option</code></td>
            </tr>
            <tr>
                <td>Reference</td>
                <td>Borrows without ownership</td>
                <td><code>&amp;T</code>, <code>&amp;mut T</code></td>
            </tr>
            <tr>
                <td>Function / Closure</td>
                <td>Callable values</td>
                <td><code>fn(i32)-&gt;i32</code>, <code>Fn</code> closures</td>
            </tr>
            <tr>
                <td>Generic</td>
                <td>Parameterized types</td>
                <td><code>Vec&lt;T&gt;</code>, <code>Option&lt;T&gt;</code></td>
            </tr>
            <tr>
                <td>Trait objects</td>
                <td>Dynamic dispatch</td>
                <td><code>dyn Write</code>, <code>dyn Display</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-conversion">Conversion</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust enforces <u>explicit</u> and <u>type-safe</u> conversions to avoid unexpected behavior.</li>
        <br/>
        <li>Unlike languages such as C/C++, Rust does <u>not</u> perform implicit numeric conversions (e.g. <code>i32</code> ‚Üí <code>i64</code>).</li>
        <br/>
        <li>Rust provides several mechanisms for converting values:
            <ul>
                <li><code>as</code> keyword for primitive casts</li>
                <li><code>From</code> and <code>Into</code> traits for safe and idiomatic conversions</li>
                <li><code>TryFrom</code> and <code>TryInto</code> for fallible conversions</li>
                <li>String conversions (<code>to_string</code>, <code>parse</code>, <code>format!</code>)</li>
                <li>Reference conversions (<code>AsRef</code>, <code>AsMut</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Casting with <code>as</code></b></li>
<pre><code class="language-rust line-numbers">let a = 10_i32;
let b = a as i64;       // widen
let c = 300_u16 as u8;  // truncate
let d = 3.14_f32 as i32;
</code></pre>
    <br/>
    <ul>
        <li>The <code>as</code> keyword performs:
            <ul>
                <li>numeric casts</li>
                <li>pointer casts (*unsafe*)</li>
                <li>enum-to-integer casts</li>
            </ul>
        </li>
        <br/>
        <li><b>WARNING:</b> numeric casts may cause truncation:</li>
<pre><code class="language-rust line-numbers">let x = 1000_u16 as u8; // 1000 % 256 = 232
</code></pre>
        <li>Use <code>TryFrom</code> for safe checking (see below).</li>
    </ul>
    <br/><br/>


    <li><b>The <code>From</code> Trait (Preferred for Safe Conversions)</b></li>
<pre><code class="language-rust line-numbers">let s = String::from("hello");
let v = Vec::from([1, 2, 3]);
let n = i32::from(42_u8);
</code></pre>
    <br/>
    <ul>
        <li><code>From</code> guarantees <u>infallible</u> conversion ‚Äî it cannot fail.</li>
        <li>If a conversion is always possible, Rust implements <code>From</code> for it.</li>
        <li>Common examples:
            <ul>
                <li><code>String::from(&amp;str)</code></li>
                <li><code>Vec::from(array)</code></li>
                <li><code>i32::from(u8)</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>The <code>Into</code> Trait (Auto-Implemented from <code>From</code>)</b></li>
<pre><code class="language-rust line-numbers">fn greet(name: impl Into&lt;String&gt;) {
    let s: String = name.into();
    println!("Hello {}", s);
}

greet("Alice");              // &amp;str   ‚Üí String
greet(String::from("Bob"));  // String ‚Üí String
</code></pre>
    <br/>
    <ul>
        <li><code>Into</code> is the inverse of <code>From</code>:</li>
        <li>If <code>From&lt;A&gt; for B</code> is implemented, then <code>Into&lt;B&gt; for A</code> is automatically implemented.</li>
        <li>Use <code>Into</code> in function parameters to accept flexible input types.</li>
    </ul>
    <br/><br/>


    <li><b>Fallible Conversions: <code>TryFrom</code> and <code>TryInto</code></b></li>
<pre><code class="language-rust line-numbers">use std::convert::TryFrom;

let x: u8  = 200;
let result = i8::try_from(x);

match result {
    Ok(n)  =&gt; println!("n = {}", n),
    Err(e) =&gt; println!("Error: {}", e),
}
</code></pre>

<pre><code class="language-rust line-numbers">use std::convert::TryInto;

let val: i16 = (-5).try_into().unwrap(); // will panic!
</code></pre>
    <br/>
    <ul>
        <li>Use these traits when conversion <u>may fail</u>.</li>
        <li>Returns <code>Result&lt;T, E&gt;</code>.</li>
        <li>Never use <code>as</code> for fallible situations unless you want truncation.</li>
    </ul>
    <br/><br/><br/>


    <li><b>String Conversions</b></li><br/>

    <b>A. To</b> <code>String</code>
<pre><code class="language-rust line-numbers">let n  = 123;
let s1 = n.to_string();
let s2 = format!("Number: {}", n);
let s3: String = "hello".into();
</code></pre>
    <br/>
    <ul>
        <li>Any type implementing <code>Display</code> or <code>Debug</code> also implements <code>ToString</code>.</li>
        <li><code>format!</code> is the most flexible method.</li>
    </ul>

    <br/><br/>

    <b>B. From</b> <code>String</code> <b>(Parsing)</b>
<pre><code class="language-rust line-numbers">let s = "42";
let n: i32 = s.parse().unwrap();
</code></pre>
    <br/>
    <ul>
        <li><code>parse()</code> uses the <code>FromStr</code> trait.</li>
        <li>Returns <code>Result&lt;T, E&gt;</code>.</li>
        <li>Valid for:
            <ul>
                <li>numbers</li>
                <li>booleans</li>
                <li>IPs</li>
                <li>custom types implementing <code>FromStr</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>

    <b>C. String Slice &lt;-&gt; String</b>
<pre><code class="language-rust line-numbers">let s: &amp;str = "hello";
let owned: String = s.to_string();

let another: &amp;str = &amp;owned;    // &amp;String ‚Üí &amp;str
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;String</code> automatically coerces to <code>&amp;str</code> (one of Rust‚Äôs few implicit conversions).</li>
    </ul>
    <br/><br/><br/>


    <li><b>Reference Conversions: <code>AsRef</code> and <code>AsMut</code></b></li>
<pre><code class="language-rust line-numbers">fn print_bytes<T: AsRef&lt;[u8]&gt;>(input: T) {
    let bytes = input.as_ref();
    println!("{:?}", bytes);
}

print_bytes("hello");            // &amp;str ‚Üí &amp;[u8]
print_bytes(String::from("hi")); // String ‚Üí &amp;[u8]
</code></pre>
    <br/>
    <ul>
        <li><code>AsRef</code> is used for cheap reference conversions. Commonly used in APIs requiring flexible inputs.</li>
        <li><code>AsMut</code> is the mutable twin of <code>AsRef</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Pointer Conversions (Unsafe)</b></li>
<pre><code class="language-rust line-numbers">let x = 10;
let ptr = &amp;x as *const i32;
let addr = ptr as usize;
</code></pre>
    <br/>
    <ul>
        <li>Rust allows pointer conversion using <code>as</code>, but <u>dereferencing raw pointers is unsafe</u>.</li>
        <li>These conversions are required for:
            <ul>
                <li>FFI (C interop)</li>
                <li>Low-level memory manipulation</li>
                <li>Embedded and systems programming</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Enum Discriminant Conversions</b></li>
<pre><code class="language-rust line-numbers">#[repr(u8)]
enum Status {
    Ok    = 1,
    Error = 2,
}

let x = Status::Ok as u8;
</code></pre>
    <br/>
    <ul>
        <li>Enums can be cast to integers using <code>as</code>.</li>
        <li>Use <code>#[repr(...)]</code> to control the layout for FFI or embedded systems.</li>
    </ul>
    <br/><br/>


    <li><b>Custom Conversion Implementations</b></li>
<pre><code class="language-rust line-numbers">struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from(t: (i32, i32)) -&gt; Self {
        Point { x: t.0, y: t.1 }
    }
}

let p = Point::from((3, 4));
</code></pre>
    <br/>
    <ul>
        <li>Implement <code>From</code> for infallible conversions.</li>
        <li>Implement <code>TryFrom</code> for conversions that may fail.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Rust Conversion Mechanisms</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Mechanism</th>
                <th>Description</th>
                <th>Fallible?</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>as</code></td>
                <td>Primitive casts, sometimes unsafe</td>
                <td>No (may truncate)</td>
                <td><code>x as u8</code></td>
            </tr>
            <tr>
                <td><code>From</code></td>
                <td>Idiomatic, guaranteed success</td>
                <td>No</td>
                <td><code>String::from(&amp;str)</code></td>
            </tr>
            <tr>
                <td><code>Into</code></td>
                <td>Auto-implemented reciprocal of <code>From</code></td>
                <td>No</td>
                <td><code>let s: String = str.into()</code></td>
            </tr>
            <tr>
                <td><code>TryFrom</code></td>
                <td>Checked conversions</td>
                <td>Yes</td>
                <td><code>i8::try_from(200)</code></td>
            </tr>
            <tr>
                <td><code>TryInto</code></td>
                <td>Auto-implemented reciprocal of <code>TryFrom</code></td>
                <td>Yes</td>
                <td><code>(-5).try_into()</code></td>
            </tr>
            <tr>
                <td><code>parse()</code></td>
                <td>String parsing via <code>FromStr</code></td>
                <td>Yes</td>
                <td><code>"42".parse()</code></td>
            </tr>
            <tr>
                <td><code>AsRef</code></td>
                <td>Cheap reference conversion</td>
                <td>No</td>
                <td><code>path.as_ref()</code></td>
            </tr>
            <tr>
                <td><code>AsMut</code></td>
                <td>Mutable reference conversion</td>
                <td>No</td>
                <td><code>buf.as_mut()</code></td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>Use <code>as</code> for simple numeric casts, <code>From/Into</code> for idiomatic conversions, and <code>TryFrom/TryInto</code> wherever failure is possible.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
