<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Rust</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    .token.comment {
        color: #888;
    }

    .token.keyword {
        font-weight: 500;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    body {
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/rust.png" alt="Rust Logo" class="nav-icon"/> Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#rust-cargo-create-project">Create Project with Cargo</a></li>
        <li><a href="#rust-comments">Comments</a></li>
        <li><a href="#rust-formatted-print">Formatted Print</a></li>
        <li><a href="#rust-primitives">Primitive</a></li>
        <li><a href="#rust-structs">Structs</a></li>
        <li><a href="#rust-enums">Enums</a></li>
        <li><a href="#rust-constants">Constants</a></li>
        <li><a href="#rust-variable-bindings">Variable Bindings</a></li>
        <li><a href="#rust-types">Types</a></li>
        <li><a href="#rust-conversion">Conversion</a></li>
        <li><a href="#rust-if-else">If / Else</a></li>
        <li><a href="#rust-loop">Loop</a></li>
        <li><a href="#rust-while">While</a></li>
        <li><a href="#rust-for-range">For and Range</a></li>
        <li><a href="#rust-match">Match</a></li>
        <li><a href="#rust-if-let">If Let</a></li>
        <li><a href="#rust-let-else">Let Else</a></li>
        <li><a href="#rust-while-let">While Let</a></li>
        <li><a href="#rust-methods">Methods</a></li>
        <li><a href="#rust-closures">Closures</a></li>
        <li><a href="#rust-higher-order-functions">Higher Order Functions</a></li>
        <li><a href="#rust-diverging-functions">Diverging Functions</a></li>
        <li><a href="#rust-modules">Modules</a></li>
        <li><a href="#rust-module-visibility">Visibility in Module</a></li>
        <li><a href="#rust-use">Keyword <code>use</code> in Rust</a></li>
        <li><a href="#rust-crates">Crates</a></li>
        <li><a href="#rust-attributes">Attributes</a></li>
        <li><a href="#rust-custom-attributes-beginner">Defining Custom Attributes (Beginners Level)</a></li>
        <li><a href="#rust-dead-code">The <code>dead_code</code> Attribute</a></li>
        <li><a href="#rust-cfg">The <code>cfg</code> Attribute</a></li>
    </ul>
</nav>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-cargo-create-project">Create Project with Cargo</h3>
<ol>
    <li><b>What Is Cargo?</b></li>
    <br/>
    <ul>
        <li><code>Cargo</code> is Rust's official build and package manager, similar to <code>npm</code> (JS), <code>pip</code> (Python), or <code>maven</code> (Java).</li>
        <br/>
        <li>It helps you:
            <ul>
                <li>create new projects</li>
                <li>build and run your code</li>
                <li>manage dependencies (crates)</li>
                <li>run tests, benchmarks, and more</li>
            </ul>
        </li>
        <br/>
        <li>You'll use Cargo for almost every non-trivial Rust project.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Check If Cargo Is Installed</b></li>
<pre><code class="language-bash line-numbers">$ cargo --version
cargo 1.80.0 (or similar)
</code></pre>
    <br/>
    <ul>
        <li>If Cargo is not found, install Rust using <code>rustup</code> from the official Rust website.</li>
        <br/>
        <li><code>rustup</code> will install:
            <ul>
                <li><code>rustc</code> ‚Äî the Rust compiler</li>
                <li><code>cargo</code> ‚Äî the package manager</li>
                <li><code>rustdoc</code> ‚Äî documentation tool</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Create a New Binary Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo new hello-rust
     Created binary (application) `hello-rust` package
</code></pre>
    <br/>
    <ul>
        <li>This creates a new directory <code>hello-rust/</code> containing a ready-to-build Rust project.</li>
        <br/>
        <li><code>cargo new &lt;name&gt;</code> by default creates a <u>binary crate</u> (an executable program).</li>
        <br/>
        <li>Move into the project directory:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ cd hello-rust
</code></pre>
    <br/>
    <br/>


    <li><b>Project Layout (Created by Cargo)</b></li>
<pre><code class="language-bash line-numbers">hello-rust/
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
    <br/>
    <ul>
        <li><code>Cargo.toml</code> ‚Äî project metadata and dependencies (TOML format).</li>
        <li><code>src/main.rs</code> ‚Äî entry point of the binary crate (contains <code>fn main()</code>).</li>
        <br/>
        <li>This is the minimal standard layout that Cargo expects.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inspecting <code>src/main.rs</code></b></li>
<pre><code class="language-rust line-numbers">fn main() {
    println!("Hello, world!");
}
</code></pre>
    <br/>
    <ul>
        <li>This is the default "Hello, world!" program generated by Cargo.</li>
        <br/>
        <li><code>fn main()</code> is the entry point; the program starts executing here.</li>
        <br/>
        <li>You can change the message or add more logic as needed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inspecting <code>Cargo.toml</code></b></li>
<pre><code class="language-toml line-numbers">[package]
name = "hello-rust"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
    <br/>
    <ul>
        <li><code>[package]</code> section:
            <ul>
                <li><code>name</code> ‚Äî crate name (used on crates.io if published).</li>
                <li><code>version</code> ‚Äî semantic version of your crate.</li>
                <li><code>edition</code> ‚Äî Rust edition (e.g. 2018, 2021).</li>
            </ul>
        </li>
        <br/>
        <li><code>[dependencies]</code> ‚Äî list of external crates your project uses (initially empty).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Build the Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo build
   Compiling hello-rust v0.1.0 (path/to/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
    <br/>
    <ul>
        <li>By default, Cargo builds in <u>debug mode</u> (fast compile, slower runtime).</li>
        <br/>
        <li>Build artifacts are placed under <code>target/debug/</code>:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ ls target/debug
hello-rust   # executable
</code></pre>
    <br/>
    <br/>


    <li><b>Run the Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo run
   Compiling hello-rust v0.1.0 (path/to/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target/debug/hello-rust`
Hello, world!
</code></pre>
    <br/>
    <ul>
        <li><code>cargo run</code> = <code>cargo build</code> + run the resulting binary.</li>
        <br/>
        <li>If nothing changed since last build, Cargo skips recompiling and just runs the existing executable.</li>
        <br/>
        <li>You can pass arguments after <code>--</code>:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ cargo run -- --help
</code></pre>
    <br/>
    <br/>


    <li><b>Create a Library Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo new my-lib --lib
     Created library `my-lib` package
</code></pre>
    <br/>
    <ul>
        <li><code>--lib</code> creates a <u>library crate</u> instead of a binary.</li>
        <br/>
        <li>Layout is slightly different:</li>
    </ul>
<pre><code class="language-bash line-numbers">my-lib/
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
    <br/>
    <ul>
        <li><code>src/lib.rs</code> is the library entry file, defining public functions, types, etc., that other crates can use.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Use <code>cargo init</code> in an Existing Directory</b></li>
<pre><code class="language-bash line-numbers">$ mkdir existing-project
$ cd existing-project
$ cargo init
     Created binary (application) `existing-project` package
</code></pre>
    <br/>
    <ul>
        <li><code>cargo init</code> turns the <u>current directory</u> into a Cargo project.</li>
        <br/>
        <li>Useful when you already have files and want to add Cargo support later.</li>
        <br/>
        <li>Use <code>cargo init --lib</code> to create a library crate instead.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Debug vs Release Builds</b></li>
<pre><code class="language-bash line-numbers"># Debug build (default)
$ cargo build

# Release build (optimized, slower compile)
$ cargo build --release
</code></pre>
    <br/>
    <ul>
        <li>Debug artifacts: <code>target/debug/...</code></li>
        <li>Release artifacts: <code>target/release/...</code></li>
        <br/>
        <li>Use <code>--release</code> when you care about <u>performance</u> (benchmarks, production builds).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Add Dependencies to Your Project</b></li>
<pre><code class="language-toml line-numbers">[dependencies]
rand = "0.8"
</code></pre>
    <br/>
    <ul>
        <li>Add crates under <code>[dependencies]</code> in <code>Cargo.toml</code>.</li>
        <br/>
        <li>Then use them in your code:</li>
    </ul>
<pre><code class="language-rust line-numbers">use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    let n: u8 = rng.gen_range(0..=9);
    println!("Random number: {n}");
}
</code></pre>
    <br/>
    <ul>
        <li>On next <code>cargo build</code> or <code>cargo run</code>, Cargo will:
            <ul>
                <li>download <code>rand</code> and its dependencies</li>
                <li>compile them and your project</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Cargo Commands for a New Project</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>cargo new &lt;name&gt;</code></td>
                <td>Create a new project directory with Cargo files</td>
            </tr>
            <tr>
                <td><code>cargo init</code></td>
                <td>Initialize Cargo in the current directory</td>
            </tr>
            <tr>
                <td><code>cargo build</code></td>
                <td>Compile the project (debug mode)</td>
            </tr>
            <tr>
                <td><code>cargo run</code></td>
                <td>Build and run the binary</td>
            </tr>
            <tr>
                <td><code>cargo check</code></td>
                <td>Type-check without producing binaries (faster feedback)</td>
            </tr>
            <tr>
                <td><code>cargo test</code></td>
                <td>Run tests (if any exist in <code>tests/</code> or <code>src</code>)</td>
            </tr>
            <tr>
                <td><code>cargo clean</code></td>
                <td>Remove the <code>target/</code> directory</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>For everyday development, you'll mostly use: <code>cargo run</code>, <code>cargo check</code>, and <code>cargo test</code>.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-comments">Comments in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust supports several kinds of comments, each serving a different purpose:</li>
        <br/>
        <ul>
            <li><b>Line comments</b> ‚Äî for normal explanations</li>
            <li><b>Block comments</b> ‚Äî for multi-line notes or temporarily disabling code</li>
            <li><b>Documentation comments</b> ‚Äî generate HTML docs and appear in <code>rustdoc</code></li>
        </ul>
        <br/>
        <li>Comments are ignored by the compiler (except documentation comments, which are processed by <code>rustdoc</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Line Comments (<code>//</code>)</b></li>
<pre><code class="language-rust line-numbers">// This is a single-line comment
let x = 10; // you can also put comments at the end of a line
</code></pre>
    <br/>
    <ul>
        <li>Starts with <code>//</code> and continues until the end of the line.</li>
        <li>Most common form of comments in Rust.</li>
        <li>Great for explaining logic or adding short descriptions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Block Comments (<code>/* ... */</code>)</b></li>
<pre><code class="language-rust line-numbers">/*
   This is a block comment.
   It can span multiple lines.
*/
let x = 5;
</code></pre>
    <br/>
    <ul>
        <li>Useful for larger explanations or temporarily disabling code.</li>
        <li>Can contain nested block comments ‚Äî Rust supports nesting!</li>
    </ul>

<pre><code class="language-rust line-numbers">/*
    Outer comment
    /*
        Nested comment ‚Äî valid!
    */
*/
</code></pre>

    <br/>
    <ul>
        <li>This makes large-scale commenting-out safer compared to languages like C/C++.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Documentation Comments (<code>///</code> and <code>//! </code>)</b></li>
    <br/>
    <ul>
        <li>Rust has two styles of documentation comments:</li>
        <ul>
            <li><b><code>///</code></b> ‚Äî for documenting items <u>that follow</u>.</li>
            <li><b><code>//! </code></b> ‚Äî for documenting containers (crate/module) <u>from within</u>.</li>
        </ul>
        <br/>
        <li>They support Markdown formatting and are used by <code>rustdoc</code> to generate HTML documentation.</li>
    </ul>
    <br/>

    <li><b>Documentation for Functions (<code>///</code>)</b></li>
<pre><code class="language-rust line-numbers">/// Adds two numbers together.
///
/// # Examples
/// ```
/// let sum = add(2, 3);
/// assert_eq!(sum, 5);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
    <br/>
    <ul>
        <li>Supports Markdown sections like:</li>
        <ul>
            <li><code># Examples</code></li>
            <li><code># Panics</code></li>
            <li><code># Safety</code></li>
            <li><code># Errors</code></li>
        </ul>
        <br/>
        <li>The examples are actually <u>compiled and tested</u> when running <code>cargo test</code>!</li>
    </ul>
    <br/>
    <br/>

    <li><b>Documentation for Modules or Crates (<code>//! </code>)</b></li>
<pre><code class="language-rust line-numbers">//! This is documentation for the entire module or crate.
//! It describes the purpose and structure at a high level.

//! You typically put this at the top of `lib.rs` or inside a module.
</code></pre>
    <br/>
    <ul>
        <li><code>//! </code> comments apply to the <u>enclosing item</u> (crate or module).</li>
        <li>Ideal for explaining architecture or high-level concepts.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inner vs Outer Documentation Comments</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Kind</th>
                <th>Syntax</th>
                <th>Applies To</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Outer doc</td>
                <td><code>///</code></td>
                <td>Item that follows</td>
            </tr>
            <tr>
                <td>Inner doc</td>
                <td><code>//! </code></td>
                <td>Enclosing module or crate</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Doc Comments Support Markdown</b></li>
<pre><code class="language-rust line-numbers">/// # Title
/// - Bullet point
/// - Another
///
/// `inline code`
///
/// ```rust
/// let x = 5;
/// println!("{}", x);
/// ```
fn demo() {}
</code></pre>
    <br/>
    <ul>
        <li>This Markdown is rendered into HTML when running <code>cargo doc</code>.</li>
        <li>You can use bold, italic, links, headings, code blocks, and tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generate Docs and Open Them</b></li>
<pre><code class="language-bash line-numbers">$ cargo doc --open
</code></pre>
    <br/>
    <ul>
        <li>Builds documentation using <code>rustdoc</code> and opens it in your browser.</li>
        <li>Includes documentation for your dependencies too.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Temporary Disabling Code with Block Comments</b></li>
<pre><code class="language-rust line-numbers">/*
fn calculate() {
    // temporarily disabled
}
*/
</code></pre>
    <br/>
    <ul>
        <li>Because Rust supports nested block comments, disabling large sections is safe:</li>
    </ul>
<pre><code class="language-rust line-numbers">/*
fn a() {}

/*
fn b() {}
*/

fn c() {}
*/
</code></pre>
    <br/>
    <ul>
        <li>Unlike C/C++, nested comments won't break the code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing the Right Comment Style</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use Case</th>
                <th>Style</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Explain a line of code</td>
                <td><code>//</code></td>
                <td><code>// explanation</code></td>
            </tr>
            <tr>
                <td>Explain a block or disable code</td>
                <td><code>/* ... */</code></td>
                <td><code>/* long comment */</code></td>
            </tr>
            <tr>
                <td>Document a function/struct/enum</td>
                <td><code>///</code></td>
                <td><code>/// Adds two numbers</code></td>
            </tr>
            <tr>
                <td>Document a module/crate</td>
                <td><code>//! </code></td>
                <td><code>//! Top-level docs</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-formatted-print">Formatted Print</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust provides a powerful and type-safe formatting system through <code>println!</code>, <code>print!</code>, <code>format!</code>, and related macros.</li>
        <br/>
        <li>The formatting engine is part of the <code>std::fmt</code> module and uses <u>traits</u> like <code>Display</code> and <code>Debug</code> to render values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Printing</b></li>
<pre><code class="language-rust line-numbers">fn main() {
    println!("Hello, world!");
    print!("No newline here");
}
</code></pre>
    <br/>
    <ul>
        <li><code>println!</code> appends a newline, <code>print!</code> does not.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing with Placeholder <code>{}</code></b></li>
<pre><code class="language-rust line-numbers">fn main() {
    let name = "Alice";
    let age = 30;

    println!("Name: {}, Age: {}", name, age);
}
</code></pre>
    <br/>
    <ul>
        <li><code>{}</code> is a placeholder for values implementing the <code>Display</code> trait.</li>
        <li>Strings, numbers, chars, and many built-in types support <code>Display</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Debug Formatting (<code>{:?}</code>)</b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug)]
struct User {
    id: u32,
    name: String,
}

fn main() {
    let u = User { id: 1, name: "Alice".into() };
    println!("{:?}", u);
}
</code></pre>
    <br/>
    <ul>
        <li><code>{:?}</code> requires the <code>Debug</code> trait.</li>
        <li>Use <code>{:#?}</code> for pretty-printed (multi-line) debug output.</li>
    </ul>
<pre><code class="language-rust line-numbers">println!("{:#?}", u);  // pretty debug
</code></pre>
    <br/>
    <br/>


    <li><b>Named Arguments</b></li>
<pre><code class="language-rust line-numbers">println!("x = {x}, y = {y}", x = 5, y = 10);
</code></pre>
    <br/>
    <ul>
        <li>Named arguments improve clarity in complex prints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Positional Arguments</b></li>
<pre><code class="language-rust line-numbers">println!("{0} + {0} = {1}", 5, 10);
</code></pre>
    <br/>
    <ul>
        <li>Use numeric indices to reuse arguments.</li>
        <li><code>{0}</code> refers to the first argument, <code>{1}</code> to the second.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting Numbers</b></li>
<pre><code class="language-rust line-numbers">println!("{:b}", 10);   // binary
println!("{:o}", 10);   // octal
println!("{:x}", 255);  // hex (lower)
println!("{:X}", 255);  // hex (upper)
println!("{:e}", 10.5); // scientific
</code></pre>
    <br/>
    <ul>
        <li>Format specifiers after a colon (<code>:</code>) control number formatting.</li>
        <li>Supported types depend on the <code>Display</code> or <code>Debug</code> implementation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Padding and Alignment</b></li>
<pre><code class="language-rust line-numbers">println!("{:&gt;10}", 42);   // right-align
println!("{:&lt;10}", 42);   // left-align
println!("{:^10}", 42);   // center-align
</code></pre>
    <br/>
    <ul>
        <li>Numbers specify the width of the formatted field.</li>
        <li>Alignment is controlled before the width:
            <ul>
                <li><code>&lt;</code> left-align</li>
                <li><code>&gt;</code> right-align</li>
                <li><code>^</code> center</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Custom Fill Characters</b></li>
<pre><code class="language-rust line-numbers">println!("{:*^10}", "hi");   // ****hi****
println!("{:-&lt;10}", "rust"); // rust------
</code></pre>
    <br/>
    <ul>
        <li>The first character before the alignment specifier becomes the fill.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Floating-Point Precision</b></li>
<pre><code class="language-rust line-numbers">println!("{:.2}", 3.14159);   // 3.14
println!("{:8.3}", 3.14159);  // '   3.142' (width + precision)
</code></pre>
    <br/>
    <ul>
        <li><code>.2</code> means 2 digits after the decimal.</li>
        <li>You can combine precision with width.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Format Strings with <code>format!</code></b></li>
<pre><code class="language-rust line-numbers">let msg = format!("Hello, {}", "world");
println!("{}", msg);
</code></pre>
    <br/>
    <ul>
        <li><code>format!</code> works like <code>println!</code> but returns a <code>String</code> instead of printing.</li>
        <li>Useful for building messages, logs, or UI output.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing to stderr (<code>eprintln!</code>)</b></li>
<pre><code class="language-rust line-numbers">eprintln!("This is an error message.");
</code></pre>
    <br/>
    <ul>
        <li><code>eprintln!</code> prints to standard error instead of stdout.</li>
        <li>Important for error reporting when stdout is used for program output.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Implementing <code>Display</code> for Custom Types</b></li>
<pre><code class="language-rust line-numbers">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 3, y: 4 };
    println!("{}", p);
}
</code></pre>
    <br/>
    <ul>
        <li>Implement <code>Display</code> when you want clean, user-friendly printing.</li>
        <li><code>Debug</code> (<code>{:?}</code>) is for debugging ‚Äî <code>Display</code> (<code>{}</code>) is for end-users.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Escape Sequences</b></li>
<pre><code class="language-rust line-numbers">println!("Line 1\nLine 2");
println!("Tab\tSeparated");
println!("Quote: \"text\"");
println!("Backslash: \\");
</code></pre>
    <br/>
    <ul>
        <li>Rust supports common escape sequences from C-like languages.</li>
        <li>Newlines, tabs, quotes, and backslashes must be escaped.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Raw Strings (No Escaping)</b></li>
<pre><code class="language-rust line-numbers">println!(r"Path: C:\Users\Alice\Documents");
println!(r#"He said, "Hello!""#);
println!(r##"Multiple # signs can be used"##);
</code></pre>
    <br/>
    <ul>
        <li>Raw strings start with <code>r"..."</code> or <code>r#"..."#</code>.</li>
        <li>Add more <code>#</code> signs when your string contains both quotes and <code>#</code> characters.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Format Specifier Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Specifier</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>{}</code></td>
                <td>Display</td>
                <td><code>"{}"</code></td>
            </tr>
            <tr>
                <td><code>{:?}</code></td>
                <td>Debug</td>
                <td><code>"{:?}"</code></td>
            </tr>
            <tr>
                <td><code>{:#?}</code></td>
                <td>Pretty Debug</td>
                <td><code>"{:#?}"</code></td>
            </tr>
            <tr>
                <td><code>{:b}</code></td>
                <td>Binary</td>
                <td><code>10 ‚Üí 1010</code></td>
            </tr>
            <tr>
                <td><code>{:x}</code></td>
                <td>Hex (lowercase)</td>
                <td><code>255 ‚Üí ff</code></td>
            </tr>
            <tr>
                <td><code>{:X}</code></td>
                <td>Hex (uppercase)</td>
                <td><code>255 ‚Üí FF</code></td>
            </tr>
            <tr>
                <td><code>{:o}</code></td>
                <td>Octal</td>
                <td><code>10 ‚Üí 12</code></td>
            </tr>
            <tr>
                <td><code>{:.N}</code></td>
                <td>Floating precision</td>
                <td><code>3.14</code></td>
            </tr>
            <tr>
                <td><code>{:width}</code></td>
                <td>Minimum field width</td>
                <td><code>"{:5}"</code></td>
            </tr>
            <tr>
                <td><code>{:&lt;}</code></td>
                <td>Left align</td>
                <td><code>"{:&lt;10}"</code></td>
            </tr>
            <tr>
                <td><code>{:&gt;}</code></td>
                <td>Right align</td>
                <td><code>"{:&gt;10}"</code></td>
            </tr>
            <tr>
                <td><code>{:^}</code></td>
                <td>Center align</td>
                <td><code>"{:^10}"</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Formatted output in Rust is powerful, flexible, and entirely type-checked at compile time.</li>
        <li>Understanding <code>{}</code>, <code>{:?}</code>, and format specifiers unlocks rich console logging and string formatting.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-primitives">Primitives in Rust</h3>
<ol>
    <li>Rust provides a set of <b>primitive types</b> (built-in types) that form the foundation of all Rust programs.</li>
    <br/>
    <li>Primitives are:
        <ul>
            <li><u>Copy</u> by default (except types containing heap allocations)</li>
            <li>Fast and efficient</li>
        </ul>
    </li>
    <br/>
    <li>Primitive categories include:
        <ul>
            <li>Scalar types</li>
            <li>Compound types</li>
            <li>Special types</li>
        </ul>
    </li>
    <br/>
    <br/>


    <li><b>Integer Types</b></li>
<pre><code class="language-rust line-numbers">let a: i32 = 10;    // signed 32-bit integer
let b: u64 = 20;    // unsigned 64-bit integer
let c = 100usize;   // machine pointer-sized unsigned integer
</code></pre>
    <br/>
    <ul>
        <li>Integer sizes:</li>
        <ul>
            <li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></li>
            <li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></li>
        </ul>
        <br/>
        <li><code>isize</code> and <code>usize</code> depend on platform pointer width (32-bit or 64-bit).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Number Literals</b></li>
<pre><code class="language-rust line-numbers">let dec = 98_222;
let hex = 0xff;
let oct = 0o77;
let bin = 0b1111_0000;
let byte = b'A'; // u8 only
</code></pre>
    <br/>
    <ul>
        <li>Underscores improve readability (<code>98_222</code>).</li>
        <li><code>b'A'</code> is a byte literal (<code>u8</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Floating-Point Types</b></li>
<pre><code class="language-rust line-numbers">let x = 3.14f32;    // 32-bit float
let y: f64 = 2.718; // 64-bit float (default)
</code></pre>
    <br/>
    <ul>
        <li>Floats use IEEE-754 format.</li>
        <li><code>f64</code> is the default because it is more precise.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean</b></li>
<pre><code class="language-rust line-numbers">let is_active: bool = true;
let is_valid = false;
</code></pre>
    <br/>
    <ul>
        <li>Boolean values: <code>true</code>, <code>false</code>.</li>
        <li>Used in conditions (<code>if</code>, <code>while</code>, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Character (Unicode Scalar Value)</b></li>
<pre><code class="language-rust line-numbers">let a = 'A';
let heart = '‚ù§';
let chinese = '‰∏≠';
let emoji = 'üöÄ';
</code></pre>
    <br/>
    <ul>
        <li><code>char</code> is <u>4 bytes</u> and stores a Unicode scalar value.</li>
        <li>Supports emoji and all languages.</li>
        <li>Not a byte ‚Äî that is <code>u8</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Tuples</b></li>
<pre><code class="language-rust line-numbers">let tup: (i32, f64, bool) = (10, 3.14, true);

let (x, y, z) = tup;  // destructuring

println!("y = {}", tup.1);
</code></pre>
    <br/>
    <ul>
        <li>Tuples group values of different types.</li>
        <li>Access with dot syntax (<code>tup.1</code>).</li>
        <li>Useful for returning multiple values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Arrays</b></li>
<pre><code class="language-rust line-numbers">let nums: [i32; 3] = [1, 2, 3];
let zeros = [0; 5]; // [0, 0, 0, 0, 0]
</code></pre>
    <br/>
    <ul>
        <li>Arrays have:
            <ul>
                <li>elements of the same type</li>
                <li>fixed length</li>
            </ul>
        </li>
        <br/>
        <li>Length is part of the type (<code>[i32; 3]</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Slices</b></li>
<pre><code class="language-rust line-numbers">let arr = [1, 2, 3, 4];
let slice: &amp;[i32] = &amp;arr[1..3];  // [2, 3]
</code></pre>
    <br/>
    <ul>
        <li>Slices are <u>references</u> to contiguous sequences.</li>
        <li><code>&amp;arr[..]</code> = slice of whole array.</li>
        <li>Slices do not own data, they borrow.</li>
    </ul>
    <br/>
    <br/>


    <li><b>String Slices</b></li>
<pre><code class="language-rust line-numbers">let s: &amp;str = "Hello";      // string slice
let part = &amp;s[0..2];        // slice bytes, careful with UTF-8
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;str</code> is an immutable UTF-8 string slice.</li>
        <li>Remember Rust strings are UTF-8 ‚Äî slicing must align with char boundaries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Owned String (<code>String</code>)</b></li>
<pre><code class="language-rust line-numbers">let mut s = String::from("Hello");
s.push_str(" World");
</code></pre>
    <br/>
    <ul>
        <li><code>String</code> owns the heap-allocated text.</li>
        <li>Growable and mutable.</li>
        <li>Frequently used in application code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Special Primitive: Unit (<code>()</code>)</b></li>
<pre><code class="language-rust line-numbers">fn do_something() {
    // returns () implicitly
}
</code></pre>
    <br/>
    <ul>
        <li><code>()</code> is a type with exactly one value: <code>()</code>.</li>
        <li>Used as the default return type for functions that return nothing.</li>
        <li>Similar to <code>void</code> in other languages but still a real type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Special Primitive: Never (<code>!</code>)</b></li>
<pre><code class="language-rust line-numbers">fn fail() -&gt; ! {
    panic!("Something went wrong");
}
</code></pre>
    <br/>
    <ul>
        <li><code>!</code> represents computations that never return.</li>
        <li>Examples:
            <ul>
                <li><code>panic!</code></li>
                <li>infinite loops</li>
                <li>functions that always <code>return Err</code> or <code>exit</code></li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Primitive Type Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Integer</td>
                <td><code>i*, u*</code></td>
                <td>Signed/unsigned integers</td>
            </tr>
            <tr>
                <td>Float</td>
                <td><code>f32, f64</code></td>
                <td>Floating-point numbers</td>
            </tr>
            <tr>
                <td>Boolean</td>
                <td><code>bool</code></td>
                <td><code>true</code>, <code>false</code></td>
            </tr>
            <tr>
                <td>Character</td>
                <td><code>char</code></td>
                <td>Unicode scalar value</td>
            </tr>
            <tr>
                <td>Tuple</td>
                <td><code>(T1, T2, ...)</code></td>
                <td>Fixed-size heterogeneous values</td>
            </tr>
            <tr>
                <td>Array</td>
                <td><code>[T; N]</code></td>
                <td>Fixed-size homogeneous values</td>
            </tr>
            <tr>
                <td>Slice</td>
                <td><code>&amp;[T]</code></td>
                <td>View into contiguous memory</td>
            </tr>
            <tr>
                <td>String Slice</td>
                <td><code>&amp;str</code></td>
                <td>UTF-8 string reference</td>
            </tr>
            <tr>
                <td>Owned String</td>
                <td><code>String</code></td>
                <td>Growable heap string</td>
            </tr>
            <tr>
                <td>Unit</td>
                <td><code>()</code></td>
                <td>No meaningful value</td>
            </tr>
            <tr>
                <td>Never</td>
                <td><code>!</code></td>
                <td>Function never returns</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>These primitives form the basis of all memory, data, and control flow in Rust programs.</li>
        <li>Understanding them is essential for mastering ownership, lifetime rules, and type safety.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-structs">Structs</h3>
<ol>
    <li>In Rust, a <u>struct</u> is a custom data type that groups related values together.</li>
    <br/>
    <li>Structs are similar to classes in other languages but without inheritance.</li>
    <br/>
    <li>Rust provides several types of structs:
        <ul>
            <li><b>Classic struct</b> (named fields)</li>
            <li><b>Tuple struct</b></li>
            <li><b>Unit-like struct</b></li>
        </ul>
    </li>
    <br/><br/>


    <li><b>Classic Structs (Named Fields)</b></li>
<pre><code class="language-rust line-numbers">struct User {
    id: u32,
    name: String,
    active: bool,
}

fn main() {
    let u = User {
        id: 1,
        name: String::from("Alice"),
        active: true,
    };

    println!("Name: {}", u.name);
}
</code></pre>
    <br/>
    <ul>
        <li>Fields must be initialized when creating the struct.</li>
        <li>Order of fields during initialization does not matter.</li>
        <li>Ownership rules apply: values like <code>String</code> are moved into the struct.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable Struct Instances</b></li>
<pre><code class="language-rust line-numbers">let mut user = User {
    id: 1,
    name: String::from("Alice"),
    active: true,
};

user.name = String::from("Bob");
</code></pre>
    <br/>
    <ul>
        <li>Use <code>mut</code> to modify struct fields.</li>
    </ul>
    <br/><br/>


    <li><b>Field Init Shorthand</b></li>
<pre><code class="language-rust line-numbers">let id = 1;
let name = String::from("Alice");

let user = User {
    id,
    name,
    active: true,
};
</code></pre>
    <br/>
    <ul>
        <li>If local variable names match field names, Rust allows shorter syntax.</li>
    </ul>
    <br/><br/>


    <li><b>Struct Update Syntax</b></li>
<pre><code class="language-rust line-numbers">let user1 = User {
    id: 1,
    name: String::from("Alice"),
    active: true,
};

let user2 = User {
    name: String::from("Bob"),
    ..user1
};
</code></pre>
    <br/>
    <ul>
        <li><code>..user1</code> copies all remaining fields from <code>user1</code>.</li>
        <li>Moves fields unless they implement <code>Copy</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Tuple Structs</b></li>
<pre><code class="language-rust line-numbers">struct Color(u8, u8, u8);
struct Point(f64, f64);

fn main() {
    let c = Color(255, 0, 128);
    let p = Point(10.5, 3.2);

    println!("Red = {}", c.0);
}
</code></pre>
    <br/>
    <ul>
        <li>Tuple structs act like tuples but with type names.</li>
        <li>Useful when giving meaning to tuple data.</li>
    </ul>
    <br/><br/>


    <li><b>Unit-Like Structs</b></li>
<pre><code class="language-rust line-numbers">struct Marker;

fn main() {
    let m = Marker;
}
</code></pre>
    <br/>
    <ul>
        <li>Contain no data.</li>
        <li>Often used as markers, traits, or zero-sized types.</li>
    </ul>
    <br/><br/>


    <li><b>Implementing Methods for Structs</b></li>
<pre><code class="language-rust line-numbers">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 20 };
    println!("Area: {}", rect.area());
}
</code></pre>
    <br/>
    <ul>
        <li>Methods are defined inside an <code>impl</code> block.</li>
        <li><code>&amp;self</code> means the method borrows the struct immutably.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable Methods</b></li>
<pre><code class="language-rust line-numbers">impl Rectangle {
    fn double_size(&amp;mut self) {
        self.width *= 2;
        self.height *= 2;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;mut self</code> means the method can modify the struct.</li>
    </ul>
    <br/><br/>


    <li><b>Associated Functions (Static Methods)</b></li>
<pre><code class="language-rust line-numbers">impl Rectangle {
    fn new(width: u32, height: u32) -&gt; Self {
        Self { width, height }
    }
}

let rect = Rectangle::new(5, 10);
</code></pre>
    <br/>
    <ul>
        <li>Associated functions use <code>Self</code> to construct new instances.</li>
        <li>Equivalent to "static factory methods" in other languages.</li>
    </ul>
    <br/><br/>


    <li><b>Debug Printing with <code>#[derive(Debug)]</code></b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug)]
struct User {
    id: u32,
    name: String,
}

fn main() {
    let u = User { id: 1, name: "Alice".into() };
    println!("{:?}", u);
    println!("{:#?}", u); // pretty-print
}
</code></pre>
    <br/>
    <ul>
        <li>Enables debug formatting using <code>{:?}</code> and <code>{:#?}</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Ownership and Structs</b></li>
<pre><code class="language-rust line-numbers">struct User {
    name: String,
}

let u1 = User { name: String::from("Alice") };
let u2 = u1;                // move occurs
// println!("{}", u1.name); // ERROR: moved
</code></pre>
    <br/>
    <ul>
        <li>Rust moves ownership when assigning or passing structs that contain heap data.</li>
        <li>Types implementing <code>Copy</code> (e.g., <code>i32</code>) behave differently.</li>
    </ul>
    <br/><br/>


    <li><b>Struct Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Struct Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Classic</td>
                <td>Named fields</td>
                <td><code>struct User { id: u32 }</code></td>
            </tr>
            <tr>
                <td>Tuple</td>
                <td>Unnamed fields</td>
                <td><code>struct Point(i32, i32)</code></td>
            </tr>
            <tr>
                <td>Unit-like</td>
                <td>No fields</td>
                <td><code>struct Marker;</code></td>
            </tr>
            <tr>
                <td>With methods</td>
                <td>Use <code>impl</code> for methods</td>
                <td><code>impl User { fn new() {} }</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Structs are the main building blocks for modeling data in Rust.</li>
        <li>Combine them with <code>impl</code> blocks for powerful and expressive types.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-enums">Enums</h3>
<ol>
    <li>Rust's <b>enum</b> (short for *enumeration*) is one of its most powerful and expressive features.</li>
    <br/>
    <li>Enums allow you to define a type that can be one of several variants.</li>
    <br/>
    <li>Unlike enums in languages like C, Rust enums can store <u>data inside each variant</u>.</li>
    <br/>
    <li>Combined with <code>match</code>, enums enable expressive and type-safe control flow.</li>
    <br/><br/>


    <li><b>Basic Enum</b></li>
<pre><code class="language-rust line-numbers">enum Direction {
    Up,
    Down,
    Left,
    Right,
}

fn main() {
    let d = Direction::Up;
}
</code></pre>
    <br/>
    <ul>
        <li>Each variant is namespaced under the enum type: <code>Direction::Up</code>.</li>
        <li>Variants have no associated data in this form.</li>
    </ul>
    <br/><br/>


    <li><b>Enums with Data</b></li>
<pre><code class="language-rust line-numbers">enum Message {
    Quit,                    // no data
    Move { x: i32, y: i32 }, // named fields
    Write(String),           // tuple-like
    ChangeColor(u8, u8, u8), // tuple-like with multiple values
}
</code></pre>
    <br/>
    <ul>
        <li>Rust enums can contain:
            <ul>
                <li>struct-like variants</li>
                <li>tuple-like variants</li>
                <li>unit variants</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Using Enums with <code>match</code></b></li>
<pre><code class="language-rust line-numbers">fn process(msg: Message) {
    match msg {
        Message::Quit           =&gt; println!("Quit"),
        Message::Move { x, y }  =&gt; println!("Move to ({}, {})", x, y),
        Message::Write(text)    =&gt; println!("Text: {}", text),
        Message::ChangeColor(r, g, b) =&gt;
            println!("Color change: ({}, {}, {})", r, g, b),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>match</code> enforces exhaustive handling.</li>
        <li>Pattern matching allows extraction of data from variants.</li>
    </ul>
    <br/><br/>


    <li><b>Enum with Methods</b></li>
<pre><code class="language-rust line-numbers">enum Shape {
    Circle(f64),
    Rectangle { w: f64, h: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Circle(r)          =&gt; std::f64::consts::PI * r * r,
            Shape::Rectangle { w, h } =&gt; w * h,
        }
    }
}

fn main() {
    let c = Shape::Circle(3.0);
    println!("Area: {}", c.area());
}
</code></pre>
    <br/>
    <ul>
        <li>Enums can have <code>impl</code> blocks just like structs.</li>
        <li>Methods receive <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code>.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>Option&lt;T&gt;</code> Enum</b></li>
<pre><code class="language-rust line-numbers">enum Option&lt;T&gt; {
    Some(T),
    None,
}

let x: Option&lt;i32&gt; = Some(10);
let y: Option&lt;i32&gt; = None;
</code></pre>
    <br/>
    <ul>
        <li>Rust does not have null.</li>
        <li><code>Option&lt;T&gt;</code> is the safe alternative.</li>
        <li>It prevents null pointer errors at compile time.</li>
    </ul>
    <br/><br/>


    <li><b>Matching on Option</b></li>
<pre><code class="language-rust line-numbers">fn print_number(n: Option&lt;i32&gt;) {
    match n {
        Some(value) =&gt; println!("Value = {}", value),
        None        =&gt; println!("No value"),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>match</code> is used to safely handle both possibilities.</li>
    </ul>
    <br/><br/>


    <li><b><code>if let</code> for Convenience</b></li>
<pre><code class="language-rust line-numbers">let n = Some(10);

if let Some(value) = n {
    println!("Value = {}", value);
}
</code></pre>
    <br/>
    <ul>
        <li><code>if let</code> handles one pattern and ignores others.</li>
        <li>Useful for simple matches.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>Result&lt;T, E&gt;</code> Enum</b></li>
<pre><code class="language-rust line-numbers">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err(String::from("Divide by zero"))
    } else {
        Ok(a / b)
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>Result</code> is Rust's standard error-handling type.</li>
        <li><code>Ok</code> stores success values.</li>
        <li><code>Err</code> stores error values.</li>
    </ul>
    <br/><br/>


    <li><b>C-like Enums (Discriminants)</b></li>
<pre><code class="language-rust line-numbers">enum Status {
    Ready = 1,
    Busy  = 2,
    Error = 3,
}

let x = Status::Busy as i32;
</code></pre>
    <br/>
    <ul>
        <li>Variants may have explicit integer values.</li>
        <li>Useful for FFI, bitflags, or low-level work.</li>
    </ul>
    <br/><br/>


    <li><b>Enums with <code>#[derive]</code></b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug, Clone, Copy)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
</code></pre>
    <br/>
    <ul>
        <li><code>derive</code> enables traits like:
            <ul>
                <li><code>Debug</code></li>
                <li><code>Copy</code></li>
                <li><code>Clone</code></li>
                <li><code>Eq</code></li>
                <li><code>Hash</code></li>
            </ul>
        </li>
        <li>Useful when variants have no owned heap data.</li>
    </ul>
    <br/><br/>


    <li><b>Enum Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Enum Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Unit Variant</td>
                <td>No data</td>
                <td><code>Quit</code></td>
            </tr>
            <tr>
                <td>Tuple Variant</td>
                <td>Unnamed fields</td>
                <td><code>Write(String)</code></td>
            </tr>
            <tr>
                <td>Struct Variant</td>
                <td>Named fields</td>
                <td><code>Move { x: i32, y: i32 }</code></td>
            </tr>
            <tr>
                <td>Methods on Enums</td>
                <td>Via <code>impl</code> block</td>
                <td><code>fn area(&amp;self)</code></td>
            </tr>
            <tr>
                <td><code>Option&lt;T&gt;</code></td>
                <td>Nullable alternative</td>
                <td><code>Some(10), None</code></td>
            </tr>
            <tr>
                <td><code>Result&lt;T, E&gt;</code></td>
                <td>Error handling</td>
                <td><code>Ok(x), Err(e)</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Enums allow modeling of all possible states of a value in a type-safe way.</li>
        <li>They work seamlessly with <code>match</code> and pattern matching.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-constants">Constants in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust provides <code>const</code> and <code>static</code> for defining values that are known for the entire program runtime.</li>
        <br/>
        <li>They differ from <code>let</code> bindings:
            <ul>
                <li><code>let</code> creates variables on the stack (by default immutable, but can be <code>mut</code>).</li>
                <li><code>const</code> creates inlined compile-time constants.</li>
                <li><code>static</code> creates a single <u>global memory location</u> with a fixed address.</li>
            </ul>
        </li>
        <br/>
        <li>Both <code>const</code> and <code>static</code> must have an explicit type annotation and a value that can be evaluated at compile time.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Defining a <code>const</code> Value</b></li>
<pre><code class="language-rust line-numbers">const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.141_592_653_589;
</code></pre>
    <br/>
    <ul>
        <li><code>const</code> items:
            <ul>
                <li>Must have a type: <code>MAX_POINTS: u32</code>.</li>
                <li>Must be initialized with a compile-time expression.</li>
            </ul>
        </li>
        <br/>
        <li>By convention, constant names use <b>SCREAMING_SNAKE_CASE</b> (<code>MAX_POINTS</code>, <code>DEFAULT_TIMEOUT</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constants vs <code>let</code> Variables</b></li>
<pre><code class="language-rust line-numbers">const MAX_USERS: u32 = 1_000;

fn main() {
    let current_users = 10;    // runtime variable
    println!("Current: {}, max: {}", current_users, MAX_USERS);
}
</code></pre>
    <br/>
    <ul>
        <li><code>MAX_USERS</code> is usable <u>everywhere</u> in the crate where it is visible, including in other <code>const</code> expressions and array sizes.</li>
        <br/>
        <li><code>let current_users</code>:
            <ul>
                <li>Lives only in <code>main</code>.</li>
                <li>Is created at runtime.</li>
            </ul>
        </li>
        <br/>
        <li>Constants are often used for:
            <ul>
                <li>Configuration values</li>
                <li>Array lengths</li>
                <li>Compile-time flags and limits</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Scope of Constants</b></li>
<pre><code class="language-rust line-numbers">const GLOBAL_LIMIT: u32 = 10_000;

fn main() {
    const LOCAL_FACTOR: u32 = 2;
    println!("Global = {}, local = {}", GLOBAL_LIMIT, LOCAL_FACTOR);
}
</code></pre>
    <br/>
    <ul>
        <li><code>const</code> can be declared:
            <ul>
                <li>At the module/root level (like <code>GLOBAL_LIMIT</code>).</li>
                <li>Inside functions (like <code>LOCAL_FACTOR</code>).</li>
            </ul>
        </li>
        <br/>
        <li>Scope rules are similar to <code>let</code> bindings: a <code>const</code> defined in a function is visible only inside that function.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constants in Types and Array Sizes</b></li>
<pre><code class="language-rust line-numbers">const ROWS: usize = 3;
const COLS: usize = 4;

fn main() {
    let matrix: [[i32; COLS]; ROWS] = [[0; COLS]; ROWS];
    println!("Matrix has {} rows and {} cols", ROWS, COLS);
}
</code></pre>
    <br/>
    <ul>
        <li>Constants can be used in:
            <ul>
                <li>Array lengths</li>
                <li>Generic parameters</li>
                <li>Other <code>const</code> expressions</li>
            </ul>
        </li>
        <br/>
        <li>This is something <code>let</code> bindings cannot do, because they are not available at compile time.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>static</code> Variables (Global Storage)</b></li>
<pre><code class="language-rust line-numbers">static APP_NAME: &amp;str = "My Rust App";
static MAX_CONNECTIONS: u32 = 1024;
</code></pre>
    <br/>
    <ul>
        <li><code>static</code> defines a <u>single location in memory</u> with a fixed address.</li>
        <br/>
        <li>Properties of <code>static</code> items:
            <ul>
                <li>Have a <code>'static</code> lifetime (live for the entire duration of the program).</li>
                <li>May be accessed from anywhere in the program where they are visible.</li>
                <li>Must have a type annotation and a compile-time initializer, just like <code>const</code>.</li>
            </ul>
        </li>
        <br/>
        <li>A common pattern is to store a <code>&amp;'static str</code>:
<pre><code class="language-rust line-numbers">static WELCOME: &amp;str = "Welcome to Rust!";
</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b><code>static mut</code> and Safety</b></li>
<pre><code class="language-rust line-numbers">static mut COUNTER: u32 = 0;

fn main() {
    unsafe {
        COUNTER += 1;
        println!("COUNTER = {}", COUNTER);
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>static mut</code> allows mutable global state.</li>
        <br/>
        <li>However, reading or writing a <code>static mut</code> is <b>unsafe</b>:
            <ul>
                <li>Requires an <code>unsafe</code> block.</li>
                <li>Can easily introduce data races in concurrent code.</li>
            </ul>
        </li>
        <br/>
        <li>Recommended approach:
            <ul>
                <li>Avoid <code>static mut</code> when possible.</li>
                <li>Prefer safe wrappers like <code>Mutex&lt;T&gt;</code>, <code>RwLock&lt;T&gt;</code> or atomic types in <code>std::sync</code> and <code>std::sync::atomic</code> inside a <code>static</code>.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>static</code> with Interior Mutability</b></li>
<pre><code class="language-rust line-numbers">use std::sync::Mutex;

static COUNTER: Mutex&lt;u32&gt; = Mutex::new(0);

fn main() {
    let mut n = COUNTER.lock().unwrap();
    *n += 1;
    println!("COUNTER = {}", *n);
}
</code></pre>
    <br/>
    <ul>
        <li>Here <code>COUNTER</code> is <b>not</b> <code>mut</code>, but the data <u>inside</u> the <code>Mutex</code> can change.</li>
        <br/>
        <li>This pattern:
            <ul>
                <li>Stays thread-safe.</li>
                <li>Avoids <code>unsafe</code>.</li>
                <li>Is the idiomatic way to represent mutable global state.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b><code>const fn</code> and Computed Constants</b></li>
<pre><code class="language-rust line-numbers">const fn square(x: i32) -&gt; i32 {
    x * x
}

const FOUR: i32 = square(2);
const SIXTEEN: i32 = square(4);
</code></pre>
    <br/>
    <ul>
        <li><code>const fn</code> defines a function that can be evaluated at compile time (under certain rules).</li>
        <br/>
        <li>Such functions can be used in:
            <ul>
                <li><code>const</code> initializers</li>
                <li><code>static</code> initializers</li>
                <li>Array sizes and other compile-time contexts</li>
            </ul>
        </li>
        <br/>
        <li>Not all operations are allowed inside <code>const fn</code>, but the set of allowed operations grows with newer Rust versions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Summary: <code>const</code> vs <code>static</code> vs <code>let</code></b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Keyword</th>
                <th>When Evaluated</th>
                <th>Storage</th>
                <th>Mutability</th>
                <th>Typical Use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>let</code></td>
                <td>Runtime</td>
                <td>Stack (or moved to heap inside types)</td>
                <td>Immutable by default, can be <code>mut</code></td>
                <td>Normal variables, function-local state</td>
            </tr>
            <tr>
                <td><code>const</code></td>
                <td>Compile time</td>
                <td>Inlined, no single fixed address</td>
                <td>Always immutable</td>
                <td>Global configuration, array sizes, generic parameters</td>
            </tr>
            <tr>
                <td><code>static</code></td>
                <td>Compile-time initialization</td>
                <td>Single fixed memory location</td>
                <td>Immutable by default, <code>static mut</code> is unsafe</td>
                <td>Global data with <code>'static</code> lifetime</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Use <code>let</code> for ordinary values, <code>const</code> for compile-time constants, and <code>static</code> only when you truly need a global memory location.</li>
        <li>For mutable global state, prefer safe wrappers (like <code>Mutex</code> or atomics) inside <code>static</code> instead of <code>static mut</code>.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-variable-bindings">Variable Bindings</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Rust, variables are created using <code>let</code> and are called <u>bindings</u>.</li>
        <br/>
        <li>Bindings are immutable by default, meaning their value cannot be changed after assignment.</li>
        <br/>
        <li>Rust encourages immutability for safety and ease of reasoning, but allows mutation with <code>mut</code> when needed.</li>
        <br/>
        <li>Bindings can also use patterns, shadowing, type annotations, and destructuring.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Immutable Binding</b></li>
<pre><code class="language-rust line-numbers">let x = 10;
println!("x = {}", x);
</code></pre>
    <br/>
    <ul>
        <li><code>let x = 10;</code> binds <code>x</code> to the value <code>10</code>.</li>
        <li>The binding is immutable ‚Äî <code>x</code> cannot be changed after this point.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable Binding</b></li>
<pre><code class="language-rust line-numbers">let mut count = 0;
count += 1;
println!("count = {}", count);
</code></pre>
    <br/>
    <ul>
        <li><code>mut</code> allows changing the value of the binding.</li>
        <li>Mutation affects only the binding, not necessarily the value's ownership rules.</li>
        <li>Use mutation only when necessary.</li>
    </ul>
    <br/><br/>


    <li><b>Type Annotations</b></li>
<pre><code class="language-rust line-numbers">let x: i32 = 42;
let name: &amp;str = "Alice";
</code></pre>
    <br/>
    <ul>
        <li>Rust usually infers types automatically.</li>
        <li>Type annotations are needed when:
            <ul>
                <li>Type inference is ambiguous.</li>
                <li>You want to guide or constrain the type.</li>
                <li>Working with generics or traits.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Shadowing</b></li>
<pre><code class="language-rust line-numbers">let x = 5;
let x = x + 1;   // shadows the previous x
{
    let x = x * 2;
    println!("x inside block = {}", x); // 12
}
println!("x outside block = {}", x);     // 6
</code></pre>
    <br/>
    <ul>
        <li>Shadowing allows creating a <u>new binding</u> with the same name.</li>
        <li>The new binding <u>replaces</u> the previous one within that scope.</li>
        <li>Unlike <code>mut</code>, shadowing can change:
            <ul>
                <li>the type</li>
                <li>the mutability</li>
                <li>the structure of the value</li>
            </ul>
        </li>
        <br/>
        <li>Shadowing is useful for transformations:</li>
<pre><code class="language-rust line-numbers">let spaces = "    ";
let spaces = spaces.len();
</code></pre>
        <li>Here, a <code>&amp;str</code> becomes a <code>usize</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Destructuring Bindings</b></li>
<pre><code class="language-rust line-numbers">let (a, b, c) = (1, 2, 3);
println!("a = {}, b = {}, c = {}", a, b, c);
</code></pre>
    <br/>
    <ul>
        <li>Rust allows <u>pattern matching</u> in variable bindings.</li>
        <li>Patterns include:
            <ul>
                <li>Tuples</li>
                <li>Structs</li>
                <li>Enums</li>
                <li>Nested patterns</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-rust line-numbers">struct Point { x: i32, y: i32 }

let p = Point { x: 10, y: 20 };
let Point { x, y } = p;
println!("x = {}, y = {}", x, y);
</code></pre>

    <br/>
    <ul>
        <li>Use <code>_</code> to ignore values:</li>
    </ul>

<pre><code class="language-rust line-numbers">let (x, _) = (10, 99);
</code></pre>
    <br/><br/>


    <li><b>Binding by Reference</b></li>
<pre><code class="language-rust line-numbers">let x     = 10;
let ref_x = &amp;x;

println!("ref_x = {}", ref_x);
</code></pre>
    <br/>
    <ul>
        <li>Bindings can store references.</li>
        <li>You can also destructure references:</li>
<pre><code class="language-rust line-numbers">let value = 5;
let &amp;ref_to_value = &amp;value;
// let ref_to_value = value;  // same end result for Copy types

println!("{}", ref_to_value); // 5
</code></pre>
    </ul>
    <br/><br/>


    <li><b>Mutable References as Bindings</b></li>
<pre><code class="language-rust line-numbers">let mut x = 10;
let y     = &amp;mut x;
*y += 5;
println!("x = {}", x);
</code></pre>
    <br/>
    <ul>
        <li>Mutable references require the original binding to be <code>mut</code>.</li>
        <li>The borrowchecker enforces rules: only <u>one</u> mutable reference allowed at a time.</li>
    </ul>
    <br/><br/>


    <li><b>Binding with <code>match</code> Patterns</b></li>
<pre><code class="language-rust line-numbers">let numbers = vec![1, 2, 3];

match numbers.as_slice() {
    [first, .., last] =&gt; println!("first = {}, last = {}", first, last),
    _                 =&gt; println!("Too short"),
}
</code></pre>
    <br/><br/>


    <li><b>Using <code>let</code> in <code>if</code> and <code>while let</code></b></li>
<pre><code class="language-rust line-numbers">if let Some(n) = Some(5) {
    println!("n = {}", n);
}
</code></pre>

<pre><code class="language-rust line-numbers">let mut v = vec![1, 2, 3];

while let Some(n) = v.pop() {
    println!("popped {}", n);
}
</code></pre>
    <br/>
    <ul>
        <li><code>if let</code> is for matching a single pattern.</li>
        <li><code>while let</code> runs repeatedly as long as the pattern matches.</li>
        <li>Both rely on variable binding through patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Freezing via Immutable Binding</b></li>
<pre><code class="language-rust line-numbers">let mut x = 10;
let y     = &amp;x;

println!("y = {}", y);

// x += 1; // ERROR: x frozen while y exists
</code></pre>
    <br/>
    <ul>
        <li>An immutable reference "freezes" the original variable: it cannot be mutated while the reference exists.</li>
        <li>Rules enforced by the borrowchecker guarantee safe access.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Variable Binding Rules</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Binding Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Immutable by default</td>
                <td>Cannot change value</td>
                <td><code>let x = 5;</code></td>
            </tr>
            <tr>
                <td>Mutable binding</td>
                <td>Explicit <code>mut</code> required</td>
                <td><code>let mut x = 5;</code></td>
            </tr>
            <tr>
                <td>Shadowing</td>
                <td>Create new binding with same name</td>
                <td><code>let x = x + 1;</code></td>
            </tr>
            <tr>
                <td>Pattern binding</td>
                <td>Destructure tuples, structs, enums</td>
                <td><code>let (a, b) = pair;</code></td>
            </tr>
            <tr>
                <td>Move semantics</td>
                <td>Non-Copy values move on assignment</td>
                <td><code>let t = s;</code></td>
            </tr>
            <tr>
                <td>Binding references</td>
                <td>Store <code>&amp;</code> or <code>&amp;mut</code></td>
                <td><code>let r = &amp;x;</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-types">Types</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust is a <u>statically typed</u> language, meaning every value has a known type at compile time.</li>
        <br/>
        <li>Most types fall into these categories:
            <ul>
                <li>Primitive types</li>
                <li>Compound types</li>
                <li>User-defined types (structs, enums)</li>
                <li>Reference types</li>
                <li>Function and closure types</li>
                <li>Generic and trait object types</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Type Inference</b></li>
<pre><code class="language-rust line-numbers">let x    = 10;          // inferred as i32
let name = "Alice";     // inferred as &amp;str
</code></pre>
    <br/><br/>


    <li><b>Annotating Types Explicitly</b></li>
<pre><code class="language-rust line-numbers">let x: i64 = 100;
let flag: bool = true;
let scores: [i32; 3] = [10, 20, 30];
</code></pre>
    <br/>
    <ul>
        <li>Type annotations follow the pattern: <code>let name: Type</code>.</li>
        <li>Annotations improve clarity and integration in complex codebases.</li>
    </ul>
    <br/><br/>


    <li><b>Type Aliases</b></li>
<pre><code class="language-rust line-numbers">type Kilometers = i32;

let distance: Kilometers = 50;
</code></pre>
    <br/>
    <ul>
        <li>Aliases introduce new names for existing types.</li>
        <li>This does <u>not</u> create a new type ‚Äî only a new label.</li>
        <li>Useful for readability, domain-specific naming, or complex types.</li>
    </ul>

<pre><code class="language-rust line-numbers">type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;
</code></pre>
    <br/><br/>


    <li><b>Primitive Types (Built-in)</b></li>
    <br/>
    <ul>
        <li>Primitive types include:
            <ul>
                <li>Integers: <code>i8</code>.. <code>i128</code>, <code>u8</code>.. <code>u128</code>, <code>isize</code>, <code>usize</code></li>
                <li>Floating: <code>f32</code>, <code>f64</code></li>
                <li>Boolean: <code>bool</code></li>
                <li>Character: <code>char</code></li>
                <li>Tuples: <code>(T1, T2, ...)</code></li>
                <li>Arrays: <code>[T; N]</code></li>
                <li>Slices: <code>&amp;[T]</code></li>
                <li>String slice: <code>&amp;str</code></li>
                <li>String: <code>String</code></li>
                <li>Unit: <code>()</code></li>
                <li>Never: <code>!</code></li>
            </ul>
        </li>
        <br/>
        <li>Primitive types are covered in detail in the ‚ÄúPrimitives‚Äù chapter.</li>
    </ul>
    <br/><br/>


    <li><b>Compound Types</b></li>
<pre><code class="language-rust line-numbers">let tup: (i32, &amp;str) = (10, "Hi");
let arr: [u8; 4] = [1, 2, 3, 4];
</code></pre>
    <br/>
    <ul>
        <li>Compound types group multiple values together.</li>
        <li>Rust supports tuples and arrays as built-in compound types.</li>
        <li>More expressive types can be created with structs and enums.</li>
    </ul>
    <br/><br/>


    <li><b>User-Defined Types</b></li>
<pre><code class="language-rust line-numbers">struct User {
    id: u32,
    name: String,
}

enum Direction {
    Up,
    Down,
    Left,
    Right,
}

type Id = u64;
</code></pre>
    <br/><br/>


    <li><b>Reference Types</b></li>
<pre><code class="language-rust line-numbers">let x = 10;
let r1: &amp;i32 = &amp;x;

let mut y = 20;
let r2: &amp;mut i32 = &amp;mut y;
</code></pre>
    <br/>
    <ul>
        <li>References allow borrowing values without taking ownership.</li>
        <br/>
        <li>Two main reference types:
            <ul>
                <li><code>&amp;T</code> ‚Äî shared reference (immutable)</li>
                <li><code>&amp;mut T</code> ‚Äî mutable reference</li>
            </ul>
        </li>
        <br/>
        <li>Rules enforced by borrowchecker ensure memory safety:
            <ul>
                <li>Any number of immutable borrows</li>
                <li>Exactly one mutable borrow</li>
                <li>Mutable and immutable borrows cannot coexist</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Function Types</b></li>
<pre><code class="language-rust line-numbers">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
    <br/>
    <ul>
        <li>Function items have a unique type based on their signature.</li>
        <li>They can be referenced using <code>fn</code> pointer types:</li>
<pre><code class="language-rust line-numbers">let f: fn(i32, i32) -&gt; i32 = add;
println!("{}", f(3, 4));
</code></pre>
        <li>Function types:
            <ul>
                <li>Are zero-sized</li>
                <li>Can be passed around like values</li>
                <li>Useful for callbacks and functional programming patterns</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Closure Types</b></li>
<pre><code class="language-rust line-numbers">let add = |x: i32, y: i32| x + y;
println!("{}", add(2, 3));
</code></pre>
    <br/>
    <ul>
        <li>Closures capture their environment.</li>
        <li>Different closure traits:
            <ul>
                <li><code>Fn</code> ‚Äî captures immutably</li>
                <li><code>FnMut</code> ‚Äî captures mutably</li>
                <li><code>FnOnce</code> ‚Äî consumes captured values</li>
            </ul>
        </li>
        <br/>
        <li>Closures have unique anonymous types generated by the compiler.</li>
        <li>Used heavily in iterator pipelines and functional patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Generic Types</b></li>
<pre><code class="language-rust line-numbers">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let p = Point { x: 1.0, y: 2.0 };
</code></pre>
    <br/>
    <ul>
        <li>Generics allow writing code that works with many types.</li>
        <br/>
        <li>Rust performs monomorphization:
            <ul>
                <li>The compiler generates concrete specialized versions.</li>
                <li>No runtime overhead.</li>
            </ul>
        </li>
        <br/>
        <li>Generics appear in:
            <ul>
                <li>Structs</li>
                <li>Enums</li>
                <li>Functions</li>
                <li>Traits</li>
                <li>Implementations</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Trait Object Types (<code>dyn Trait</code>)</b></li>
<pre><code class="language-rust line-numbers">trait Speak {
    fn speak(&amp;self);
}

struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) { println!("Woof"); }
}

let animal: &amp;dyn Speak = &amp;Dog;
animal.speak();
</code></pre>
    <br/>
    <ul>
        <li>Trait objects enable dynamic dispatch through <code>dyn Trait</code>.</li>
        <br/>
        <li>Used when:
            <ul>
                <li>The exact type is not known at compile time.</li>
                <li>You need heterogeneous collections of different types.</li>
            </ul>
        </li>
        <br/>
        <li>Requires the trait to be <u>object-safe</u>.</li>
    </ul>
    <br/><br/>


    <li><b>Never Type (<code>!</code>)</b></li>
<pre><code class="language-rust line-numbers">fn crash() -&gt; ! {
    panic!("boom");
}
</code></pre>
    <br/>
    <ul>
        <li><code>!</code> means a function never returns.</li>
        <li>Used for:
            <ul>
                <li>panics</li>
                <li>infinite loops</li>
                <li>process termination</li>
            </ul>
        </li>
        <li>The never type can coerce into any other type.</li>
    </ul>
    <br/><br/>


    <li><b>Type Coercions</b></li>
<pre><code class="language-rust line-numbers">let s: &amp;str = "Hello";
let slice: &amp;[u8] = s.as_bytes();
</code></pre>
    <br/>
    <ul>
        <li>Rust performs very limited implicit coercions.</li>
        <br/>
        <li>Allowed coercions:
            <ul>
                <li><code>&amp;String</code> ‚Üí <code>&amp;str</code></li>
                <li><code>&amp;Vec&lt;T&gt;</code> ‚Üí <code>&amp;[T]</code></li>
                <li><code>T</code> ‚Üí <code>dyn Trait</code> (trait object)</li>
                <li><code>! </code> ‚Üí any type</li>
            </ul>
        </li>
        <br/>
        <li>Unlike languages like C/C++, Rust does not do:
            <ul>
                <li>integer promotions</li>
                <li>implicit float conversions</li>
                <li>pointer arithmetic</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Summary of Rust Type Categories</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Description</th>
                <th>Examples</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Primitive</td>
                <td>Built-in low-level types</td>
                <td><code>i32</code>, <code>bool</code>, <code>char</code>, <code>&amp;str</code></td>
            </tr>
            <tr>
                <td>User-defined</td>
                <td>Custom structs, enums, aliases</td>
                <td><code>struct User</code>, <code>enum Option</code></td>
            </tr>
            <tr>
                <td>Reference</td>
                <td>Borrows without ownership</td>
                <td><code>&amp;T</code>, <code>&amp;mut T</code></td>
            </tr>
            <tr>
                <td>Function / Closure</td>
                <td>Callable values</td>
                <td><code>fn(i32)-&gt;i32</code>, <code>Fn</code> closures</td>
            </tr>
            <tr>
                <td>Generic</td>
                <td>Parameterized types</td>
                <td><code>Vec&lt;T&gt;</code>, <code>Option&lt;T&gt;</code></td>
            </tr>
            <tr>
                <td>Trait objects</td>
                <td>Dynamic dispatch</td>
                <td><code>dyn Write</code>, <code>dyn Display</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-conversion">Conversion</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust enforces <u>explicit</u> and <u>type-safe</u> conversions to avoid unexpected behavior.</li>
        <br/>
        <li>Unlike languages such as C/C++, Rust does <u>not</u> perform implicit numeric conversions (e.g. <code>i32</code> ‚Üí <code>i64</code>).</li>
        <br/>
        <li>Rust provides several mechanisms for converting values:
            <ul>
                <li><code>as</code> keyword for primitive casts</li>
                <li><code>From</code> and <code>Into</code> traits for safe and idiomatic conversions</li>
                <li><code>TryFrom</code> and <code>TryInto</code> for fallible conversions</li>
                <li>String conversions (<code>to_string</code>, <code>parse</code>, <code>format!</code>)</li>
                <li>Reference conversions (<code>AsRef</code>, <code>AsMut</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Casting with <code>as</code></b></li>
<pre><code class="language-rust line-numbers">let a = 10_i32;
let b = a as i64;       // widen
let c = 300_u16 as u8;  // truncate
let d = 3.14_f32 as i32;
</code></pre>
    <br/>
    <ul>
        <li>The <code>as</code> keyword performs:
            <ul>
                <li>numeric casts</li>
                <li>pointer casts (*unsafe*)</li>
                <li>enum-to-integer casts</li>
            </ul>
        </li>
        <br/>
        <li><b>WARNING:</b> numeric casts may cause truncation:</li>
<pre><code class="language-rust line-numbers">let x = 1000_u16 as u8; // 1000 % 256 = 232
</code></pre>
        <li>Use <code>TryFrom</code> for safe checking (see below).</li>
    </ul>
    <br/><br/>


    <li><b>The <code>From</code> Trait (Preferred for Safe Conversions)</b></li>
<pre><code class="language-rust line-numbers">let s = String::from("hello");
let v = Vec::from([1, 2, 3]);
let n = i32::from(42_u8);
</code></pre>
    <br/>
    <ul>
        <li><code>From</code> guarantees <u>infallible</u> conversion ‚Äî it cannot fail.</li>
        <li>If a conversion is always possible, Rust implements <code>From</code> for it.</li>
        <li>Common examples:
            <ul>
                <li><code>String::from(&amp;str)</code></li>
                <li><code>Vec::from(array)</code></li>
                <li><code>i32::from(u8)</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>The <code>Into</code> Trait (Auto-Implemented from <code>From</code>)</b></li>
<pre><code class="language-rust line-numbers">fn greet(name: impl Into&lt;String&gt;) {
    let s: String = name.into();
    println!("Hello {}", s);
}

greet("Alice");              // &amp;str   ‚Üí String
greet(String::from("Bob"));  // String ‚Üí String
</code></pre>
    <br/>
    <ul>
        <li><code>Into</code> is the inverse of <code>From</code>:</li>
        <li>If <code>From&lt;A&gt; for B</code> is implemented, then <code>Into&lt;B&gt; for A</code> is automatically implemented.</li>
        <li>Use <code>Into</code> in function parameters to accept flexible input types.</li>
    </ul>
    <br/><br/>


    <li><b>Fallible Conversions: <code>TryFrom</code> and <code>TryInto</code></b></li>
<pre><code class="language-rust line-numbers">use std::convert::TryFrom;

let x: u8  = 200;
let result = i8::try_from(x);

match result {
    Ok(n)  =&gt; println!("n = {}", n),
    Err(e) =&gt; println!("Error: {}", e),
}
</code></pre>

<pre><code class="language-rust line-numbers">use std::convert::TryInto;

let val: i16 = (-5).try_into().unwrap(); // will panic!
</code></pre>
    <br/>
    <ul>
        <li>Use these traits when conversion <u>may fail</u>.</li>
        <li>Returns <code>Result&lt;T, E&gt;</code>.</li>
        <li>Never use <code>as</code> for fallible situations unless you want truncation.</li>
    </ul>
    <br/><br/><br/>


    <li><b>String Conversions</b></li><br/>

    <b>A. To</b> <code>String</code>
<pre><code class="language-rust line-numbers">let n  = 123;
let s1 = n.to_string();
let s2 = format!("Number: {}", n);
let s3: String = "hello".into();
</code></pre>
    <br/>
    <ul>
        <li>Any type implementing <code>Display</code> or <code>Debug</code> also implements <code>ToString</code>.</li>
        <li><code>format!</code> is the most flexible method.</li>
    </ul>

    <br/><br/>

    <b>B. From</b> <code>String</code> <b>(Parsing)</b>
<pre><code class="language-rust line-numbers">let s = "42";
let n: i32 = s.parse().unwrap();
</code></pre>
    <br/>
    <ul>
        <li><code>parse()</code> uses the <code>FromStr</code> trait.</li>
        <li>Returns <code>Result&lt;T, E&gt;</code>.</li>
        <li>Valid for:
            <ul>
                <li>numbers</li>
                <li>booleans</li>
                <li>IPs</li>
                <li>custom types implementing <code>FromStr</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>

    <b>C. String Slice &lt;-&gt; String</b>
<pre><code class="language-rust line-numbers">let s: &amp;str = "hello";
let owned: String = s.to_string();

let another: &amp;str = &amp;owned;    // &amp;String ‚Üí &amp;str
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;String</code> automatically coerces to <code>&amp;str</code> (one of Rust‚Äôs few implicit conversions).</li>
    </ul>
    <br/><br/><br/>


    <li><b>Reference Conversions: <code>AsRef</code> and <code>AsMut</code></b></li>
<pre><code class="language-rust line-numbers">fn print_bytes<T: AsRef&lt;[u8]&gt;>(input: T) {
    let bytes = input.as_ref();
    println!("{:?}", bytes);
}

print_bytes("hello");            // &amp;str ‚Üí &amp;[u8]
print_bytes(String::from("hi")); // String ‚Üí &amp;[u8]
</code></pre>
    <br/>
    <ul>
        <li><code>AsRef</code> is used for cheap reference conversions. Commonly used in APIs requiring flexible inputs.</li>
        <li><code>AsMut</code> is the mutable twin of <code>AsRef</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Pointer Conversions (Unsafe)</b></li>
<pre><code class="language-rust line-numbers">let x = 10;
let ptr = &amp;x as *const i32;
let addr = ptr as usize;
</code></pre>
    <br/>
    <ul>
        <li>Rust allows pointer conversion using <code>as</code>, but <u>dereferencing raw pointers is unsafe</u>.</li>
        <li>These conversions are required for:
            <ul>
                <li>FFI (C interop)</li>
                <li>Low-level memory manipulation</li>
                <li>Embedded and systems programming</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Enum Discriminant Conversions</b></li>
<pre><code class="language-rust line-numbers">#[repr(u8)]
enum Status {
    Ok    = 1,
    Error = 2,
}

let x = Status::Ok as u8;
</code></pre>
    <br/>
    <ul>
        <li>Enums can be cast to integers using <code>as</code>.</li>
        <li>Use <code>#[repr(...)]</code> to control the layout for FFI or embedded systems.</li>
    </ul>
    <br/><br/>


    <li><b>Custom Conversion Implementations</b></li>
<pre><code class="language-rust line-numbers">struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from(t: (i32, i32)) -&gt; Self {
        Point { x: t.0, y: t.1 }
    }
}

let p = Point::from((3, 4));
</code></pre>
    <br/>
    <ul>
        <li>Implement <code>From</code> for infallible conversions.</li>
        <li>Implement <code>TryFrom</code> for conversions that may fail.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Rust Conversion Mechanisms</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Mechanism</th>
                <th>Description</th>
                <th>Fallible?</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>as</code></td>
                <td>Primitive casts, sometimes unsafe</td>
                <td>No (may truncate)</td>
                <td><code>x as u8</code></td>
            </tr>
            <tr>
                <td><code>From</code></td>
                <td>Idiomatic, guaranteed success</td>
                <td>No</td>
                <td><code>String::from(&amp;str)</code></td>
            </tr>
            <tr>
                <td><code>Into</code></td>
                <td>Auto-implemented reciprocal of <code>From</code></td>
                <td>No</td>
                <td><code>let s: String = str.into()</code></td>
            </tr>
            <tr>
                <td><code>TryFrom</code></td>
                <td>Checked conversions</td>
                <td>Yes</td>
                <td><code>i8::try_from(200)</code></td>
            </tr>
            <tr>
                <td><code>TryInto</code></td>
                <td>Auto-implemented reciprocal of <code>TryFrom</code></td>
                <td>Yes</td>
                <td><code>(-5).try_into()</code></td>
            </tr>
            <tr>
                <td><code>parse()</code></td>
                <td>String parsing via <code>FromStr</code></td>
                <td>Yes</td>
                <td><code>"42".parse()</code></td>
            </tr>
            <tr>
                <td><code>AsRef</code></td>
                <td>Cheap reference conversion</td>
                <td>No</td>
                <td><code>path.as_ref()</code></td>
            </tr>
            <tr>
                <td><code>AsMut</code></td>
                <td>Mutable reference conversion</td>
                <td>No</td>
                <td><code>buf.as_mut()</code></td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>Use <code>as</code> for simple numeric casts, <code>From/Into</code> for idiomatic conversions, and <code>TryFrom/TryInto</code> wherever failure is possible.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-if-else">if / else</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Unlike many languages, <code>if</code> in Rust is an <u>expression</u>, not just a statement:
            <ul>
                <li>It produces a value.</li>
                <li>It can be used in <code>let</code> bindings.</li>
                <li>Its branches must return compatible types.</li>
            </ul>
        </li>
        <br/>
        <li>Rust does not allow non-boolean conditions (e.g., numbers or strings) ‚Äî the condition must be <code>bool</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Basic if</b></li>
<pre><code class="language-rust line-numbers">let x = 10;

if x &gt; 5 {
    println!("x is greater than 5");
}
</code></pre>
    <br/>
    <ul>
        <li>The condition must be a boolean expression: <code>x &gt; 5</code>.</li>
        <li>Curly braces are required, even for single-line blocks.</li>
    </ul>
    <br/><br/>



    <li><b>if / else</b></li>
<pre><code class="language-rust line-numbers">let x = 3;

if x % 2 == 0 {
    println!("even");
} else {
    println!("odd");
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>else</code> branch runs when the <code>if</code> condition is false.</li>
        <li>Indentation and braces help readability and are idiomatic in Rust.</li>
    </ul>
    <br/><br/>



    <li><b>else if (Chained Conditions)</b></li>

<pre><code class="language-rust line-numbers">let score = 85;

if score &gt;= 90 {
    println!("A");
} else if score &gt;= 80 {
    println!("B");
} else if score &gt;= 70 {
    println!("C");
} else {
    println!("D");
}
</code></pre>
    <br/>
    <ul>
        <li><code>else if</code> allows branching on multiple conditions.</li>
        <li>Evaluates from top to bottom until a condition matches.</li>
    </ul>
    <br/><br/>



    <li><b>if as an Expression</b></li>

<pre><code class="language-rust line-numbers">let x = 5;

let result = if x &gt; 3 {
    "big"
} else {
    "small"
};

println!("result = {}", result);
</code></pre>
    <br/>
    <ul>
        <li>Both branches must return the <u>same type</u>: both return <code>&amp;str</code> in this example.</li>
        <li>Semicolon after the entire <code>if</code> is optional but conventional when binding.</li>
    </ul>
    <br/><br/>



    <li><b>Mismatched Types in Branches (Error)</b></li>

<pre><code class="language-rust line-numbers">let x = 5;

let result = if x &gt; 3 {
    10        // i32
} else {
    "small"   // &amp;str
};
</code></pre>
    <br/>
    <ul>
        <li>This will not compile because the two branches return different types.</li>
        <li>Rust expects both branches to yield a single consistent type.</li>
    </ul>
    <br/><br/>



    <li><b>Using if in let bindings</b></li>

<pre><code class="language-rust line-numbers">let temperature = 30;

let advice = if temperature &gt; 25 {
    "Wear light clothes"
} else {
    "Wear a jacket"
};

println!("{}", advice);
</code></pre>
    <br/>
    <ul>
        <li>Common idiom when choosing between two values.</li>
    </ul>
    <br/><br/>



    <li><b>Nested if</b></li>

<pre><code class="language-rust line-numbers">let x = 15;

if x &gt; 10 {
    if x &lt; 20 {
        println!("x is between 10 and 20");
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Nesting is allowed but can reduce readability.</li>
        <li>Prefer <code>else if</code> or <code>match</code> for clearer branching when possible.</li>
    </ul>
    <br/><br/>



    <li><b>Returning Complex Values from if</b></li>

<pre><code class="language-rust line-numbers">struct User {
    name: String,
    admin: bool,
}

let user = User { name: "Alice".into(), admin: false };

let label = if user.admin {
    format!("Admin: {}", user.name)
} else {
    format!("User: {}", user.name)
};

println!("{}", label);
</code></pre>
    <br/>
    <ul>
        <li>Both branches return <code>String</code>, so types match.</li>
        <li>Using <code>format!</code> inside <code>if</code> expressions is common.</li>
    </ul>
    <br/><br/>



    <li><b>Using if with Option values</b></li>

<pre><code class="language-rust line-numbers">let value: Option&lt;i32&gt; = Some(10);

if let Some(v) = value {
    println!("We got {}", v);
} else {
    println!("No value");
}
</code></pre>
    <br/>
    <ul>
        <li><code>if let</code> simplifies matching against one pattern.</li>
        <li>Works like a shorthand for simple <code>match</code> expressions.</li>
    </ul>
    <br/><br/>



    <li><b>if let for Ignoring the Else Branch</b></li>

<pre><code class="language-rust line-numbers">let maybe_number = Some(5);

if let Some(x) = maybe_number {
    println!("Got {}", x);
}
// else is optional
</code></pre>
    <br/>
    <ul>
        <li>Useful when you only care about the success branch.</li>
    </ul>
    <br/><br/>



    <li><b>Short-Circuiting with Boolean Expressions</b></li>

<pre><code class="language-rust line-numbers">let logged_in = true;
let is_admin = false;

if logged_in &amp;&amp; is_admin {
    println!("Welcome, admin");
} else {
    println!("Access denied");
}
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;&amp;</code> and <code>||</code> short-circuit:</li>
        <ul>
            <li><code>&amp;&amp;</code> stops if left side is false</li>
            <li><code>||</code> stops if left side is true</li>
        </ul>
        <li>This is identical to most C-like languages.</li>
    </ul>
    <br/><br/>



    <li><b>if vs match</b></li>

<pre><code class="language-rust line-numbers">let x = 5;

match x {
    0 =&gt; println!("Zero"),
    1..=5 =&gt; println!("Small"),
    _ =&gt; println!("Large"),
}
</code></pre>
    <br/>
    <ul>
        <li>Use <code>if</code> for:
            <ul>
                <li>simple boolean checks</li>
                <li>two-branch decisions</li>
                <li>short conditions</li>
            </ul>
        </li>
        <br/>
        <li>Use <code>match</code> for:
            <ul>
                <li>pattern matching</li>
                <li>exhaustive branching</li>
                <li>multiple complex conditions</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Summary of if / else</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic if</td>
                <td>Executes block when condition is true</td>
                <td><code>if x &gt; 0 { ... }</code></td>
            </tr>
            <tr>
                <td>if / else</td>
                <td>Fallback branch when condition is false</td>
                <td><code>if a { ... } else { ... }</code></td>
            </tr>
            <tr>
                <td>else if</td>
                <td>Multiple branching conditions</td>
                <td><code>else if x &gt; 10</code></td>
            </tr>
            <tr>
                <td>Expression</td>
                <td>Returns a value</td>
                <td><code>let v = if cond { 1 } else { 2 };</code></td>
            </tr>
            <tr>
                <td>Type consistency</td>
                <td>Both branches must match</td>
                <td><code>i32 / i32</code>, not mixed</td>
            </tr>
            <tr>
                <td>if let</td>
                <td>Pattern matching convenience</td>
                <td><code>if let Some(v) = opt</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>The <code>if</code> expression is simple, powerful, and forms the foundation of branching logic in Rust.</li>
        <li>Mastering <code>if</code>, <code>else if</code>, and <code>if let</code> is essential before learning <code>match</code> and pattern matching.</li>
    </ul>
    <br/><br/>

</ol>
<br/>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-loop">loop</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>loop</code> runs forever unless explicitly stopped with:
            <ul>
                <li><code>break</code></li>
                <li><code>return</code></li>
                <li><code>panic!</code></li>
            </ul>
        </li>
        <br/>
        <li>Because <code>loop</code> can run indefinitely, it is useful for:
            <ul>
                <li>State machines</li>
                <li>Game loops</li>
                <li>Servers listening for requests</li>
                <li>Retry logic</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Basic loop</b></li>
<pre><code class="language-rust line-numbers">let mut count = 0;

loop {
    println!("count = {}", count);
    count += 1;

    if count == 3 {
        break;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The loop repeats until <code>break</code> is executed.</li>
        <li>Without <code>break</code>, this loop would be infinite.</li>
    </ul>
    <br/><br/>


    <li><b>Using break to exit the loop</b></li>
<pre><code class="language-rust line-numbers">let mut n = 1;

loop {
    if n &gt; 5 {
        break;
    }
    println!("{}", n);
    n += 1;
}
</code></pre>
    <br/>
    <ul>
        <li><code>break</code> stops the loop completely.</li>
        <li><code>continue</code> (shown later) skips to the next iteration.</li>
    </ul>
    <br/><br/>


    <li><b>loop is an expression (can return a value)</b></li>
<pre><code class="language-rust line-numbers">let mut x = 0;

let result = loop {
    x += 1;

    if x == 5 {
        break x * 2; // break with value
    }
};

println!("result = {}", result);
</code></pre>
    <br/>
    <ul>
        <li><code>break</code> can return a value, making <code>loop</code> behave like an expression.</li>
        <li>Here <code>result</code> gets the value <code>10</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Using continue</b></li>
<pre><code class="language-rust line-numbers">for i in 1..=5 {
    if i % 2 == 0 {
        continue;
    }
    println!("{}", i);
}
</code></pre>
    <br/>
    <ul>
        <li><code>continue</code> jumps to the next loop iteration.</li>
        <li>Works in <code>loop</code>, <code>while</code>, and <code>for</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Loop Labels (controlling nested loops)</b></li>
<pre><code class="language-rust line-numbers">'outer: loop {
    println!("In outer loop");

    loop {
        println!("In inner loop");
        break 'outer; // exit BOTH loops
    }
}



let result = 'outer: loop {
    println!("In outer loop");

    loop {
        println!("In inner loop");
        break 'outer 42; // exit BOTH loops with value 42
    }
};
println!("result = {result}");
</code></pre>
    <br/>
    <ul>
        <li>Labels allow breaking or continuing specific loops when nested.</li>
        <li>Labels start with <code>'</code> and can be any valid identifier.</li>
    </ul>
    <br/><br/>


    <li><b>Loop with return</b></li>
<pre><code class="language-rust line-numbers">fn find() -&gt; i32 {
    let mut n = 0;

    loop {
        if n == 7 {
            return n; // exit the function entirely
        }
        n += 1;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>return</code> bypasses the loop and exits the function completely.</li>
    </ul>
    <br/><br/>


    <li><b>Infinite loops intentionally</b></li>
<pre><code class="language-rust line-numbers">loop {
    println!("This runs forever");
}
</code></pre>
    <br/>
    <ul>
        <li>Infinite loops are valid for:
            <ul>
                <li>microcontroller firmware</li>
                <li>servers</li>
                <li>event loops</li>
            </ul>
        </li>
        <li>To prevent CPU burnout, these loops often include waiting or I/O.</li>
    </ul>
    <br/><br/>


    <li><b>Combining loop with state transitions</b></li>
<pre><code class="language-rust line-numbers">let mut state = 0;

loop {
    match state {
        0 =&gt; {
            println!("Start");
            state = 1;
        }
        1 =&gt; {
            println!("Processing");
            state = 2;
        }
        2 =&gt; {
            println!("Done");
            break;
        }
        _ =&gt; unreachable!(),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>loop</code> is excellent for state machines with deterministic transitions.</li>
    </ul>
    <br/><br/>


    <li><b>Using loop to retry operations</b></li>
<pre><code class="language-rust line-numbers">use std::fs::File;

loop {
    match File::open("config.txt") {
        Ok(f) =&gt; {
            println!("File opened");
            break;
        }
        Err(_) =&gt; {
            println!("Retrying...");
        }
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Ideal for ‚Äúretry-until-success‚Äù logic.</li>
        <li>Often used with network or file system operations.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of loop</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic loop</td>
                <td>Repeats forever</td>
                <td><code>loop { ... }</code></td>
            </tr>
            <tr>
                <td>Break</td>
                <td>Stops the loop</td>
                <td><code>break;</code></td>
            </tr>
            <tr>
                <td>Break with value</td>
                <td>Returns value from loop-expression</td>
                <td><code>break x;</code></td>
            </tr>
            <tr>
                <td>Continue</td>
                <td>Skip to next iteration</td>
                <td><code>continue;</code></td>
            </tr>
            <tr>
                <td>Loop labels</td>
                <td>Control nested loops</td>
                <td><code>'label: loop { ... }</code></td>
            </tr>
            <tr>
                <td>State machines</td>
                <td>Ideal for multi-step logic</td>
                <td><code>match state { ... }</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li><code>loop</code> is simple, powerful, and often the foundation of more complex looping constructs.</li>
        <li>Mastering <code>loop</code> helps build systems-level code, state machines, servers, and embedded applications in Rust.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-while">while</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>while</code> loop runs as long as its condition evaluates to <code>true</code>.</li>
        <br/>
        <li>Unlike <code>loop</code>, <code>while</code> ends automatically once its condition becomes false.</li>
        <br/>
        <li>The condition must be a boolean (<code>bool</code>).</li>
        <br/>
        <li><code>while</code> and <code>for</code> do <u>not</u> return values with <code>break</code> like what <code>loop</code> could do.</li>
    </ul>
    <br/><br/>


    <li><b>Basic while loop</b></li>
<pre><code class="language-rust line-numbers">let mut n = 1;

while n &lt;= 5 {
    println!("{}", n);
    n += 1;
}
</code></pre>
    <br/>
    <ul>
        <li>This prints numbers from <code>1</code> to <code>5</code>.</li>
        <li>Once <code>n</code> becomes <code>6</code>, the condition becomes false and iteration stops.</li>
    </ul>
    <br/><br/>


    <li><b>Using break in a while loop</b></li>
<pre><code class="language-rust line-numbers">let mut x = 0;

while x &lt; 10 {
    if x == 4 {
        break; // stop the loop early
    }
    println!("{}", x);
    x += 1;
}
</code></pre>
    <br/>
    <ul>
        <li><code>break</code> exits the loop immediately.</li>
    </ul>
    <br/><br/>


    <li><b>Using continue in while</b></li>
<pre><code class="language-rust line-numbers">let mut x = 0;

while x &lt; 5 {
    x += 1;

    if x % 2 == 0 {
        continue; // skip even numbers
    }

    println!("{}", x);
}
</code></pre>
    <br/>
    <ul>
        <li><code>continue</code> skips the current iteration and jumps to the next one.</li>
    </ul>
    <br/><br/>


    <li><b>Countdown example</b></li>
<pre><code class="language-rust line-numbers">let mut count = 3;

while count &gt; 0 {
    println!("{}", count);
    count -= 1;
}

println!("Lift off!");
</code></pre>
    <br/>
    <ul>
        <li>Classic countdown pattern.</li>
    </ul>
    <br/><br/>


    <li><b>while with conditions that change inside the loop</b></li>
<pre><code class="language-rust line-numbers">let mut temperature = 20;

while temperature &lt; 25 {
    println!("Heating... {}", temperature);
    temperature += 1;
}
</code></pre>
    <br/>
    <ul>
        <li>Conditions often depend on values updated inside the loop body.</li>
    </ul>
    <br/><br/>


    <li><b>while as an alternative to some for loops</b></li>
<pre><code class="language-rust line-numbers">let arr = [10, 20, 30, 40];
let mut i = 0;

while i &lt; arr.len() {
    println!("{}", arr[i]);
    i += 1;
}
</code></pre>
    <br/>
    <ul>
        <li>This mimics classical <code>for</code>-loops from languages like C or Java.</li>
        <li>But in Rust, <code>for</code> is usually preferred for iteration.</li>
    </ul>
    <br/><br/>


    <li><b>while let (pattern-based iteration)</b></li>
<pre><code class="language-rust line-numbers">let mut opt = Some(3);

while let Some(x) = opt {
    println!("{}", x);
    opt = if x &gt; 1 { Some(x - 1) } else { None };
}
</code></pre>
    <br/>
    <ul>
        <li><code>while let</code> continues looping as long as the pattern matches.</li>
        <li>Very useful for popping or consuming items gradually.</li>
    </ul>
    <br/><br/>


    <li><b>Using while let with collections</b></li>
<pre><code class="language-rust line-numbers">let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop() {
    println!("Popped: {}", top);
}
</code></pre>
    <br/>
    <ul>
        <li><code>Vec::pop()</code> returns <code>Some(value)</code> until the vector is empty.</li>
        <li>When it becomes <code>None</code>, the loop stops.</li>
        <li>This is idiomatic Rust.</li>
    </ul>
    <br/><br/>


    <li><b>Labelled while loops</b></li>
<pre><code class="language-rust line-numbers">'outer: while true {
    let mut x = 0;

    while x &lt; 5 {
        if x == 2 {
            break 'outer; // exit the outer loop
        }
        x += 1;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Labels allow you to control which loop you break from.</li>
        <li>Useful in nested loops with complex logic.</li>
    </ul>
    <br/><br/>


    <li><b>Infinite while loop (not recommended)</b></li>
<pre><code class="language-rust line-numbers">while true {
    println!("Running...");
}
</code></pre>
    <br/>
    <ul>
        <li>Works, but using <code>loop</code> is more idiomatic for deliberate infinite loops.</li>
    </ul>
    <br/><br/>


    <li><b>while for waiting on conditions</b></li>
<pre><code class="language-rust line-numbers">let mut ready = false;

while !ready {
    println!("Waiting...");
    // check some condition...
    ready = true; // simulate becoming ready
}

println!("Ready!");
</code></pre>
    <br/>
    <ul>
        <li>Often used with hardware events, threads, or async tasks (though async uses <code>await</code> instead).</li>
    </ul>
    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-for-range"><code>for</code> and Range</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>for</code> loop in Rust is used to iterate over items in a sequence.</li>
        <br/>
        <li>Unlike C/Java style loops, Rust <u>does not</u> use index-based counting automatically.</li>
        <br/>
        <li>Instead, <code>for</code> iterates over anything that implements the <code>IntoIterator</code> trait, including:
            <ul>
                <li>ranges</li>
                <li>arrays</li>
                <li>vectors</li>
                <li>strings</li>
                <li>custom iterator types</li>
            </ul>
        </li>
        <br/>
        <li>It is safe, avoids indexing errors, and is the idiomatic way to loop in Rust.</li>
    </ul>
    <br/><br/>


    <li><b>Basic for loop with a range</b></li>
<pre><code class="language-rust line-numbers">for i in 0..5 {
    println!("{}", i);
}
</code></pre>
    <br/>
    <ul>
        <li><code>0..5</code> is a range from <u>0 to 4</u> (end is exclusive).</li>
        <li>This prints: <code>0 1 2 3 4</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Inclusive range</b></li>
<pre><code class="language-rust line-numbers">for i in 0..=5 {
    println!("{}", i);
}
</code></pre>
    <br/>
    <ul>
        <li><code>0..=5</code> includes the end value.</li>
        <li>This prints: <code>0 1 2 3 4 5</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Reverse iteration using rev()</b></li>
<pre><code class="language-rust line-numbers">for i in (1..5).rev() {
    println!("{}", i);
}
</code></pre>
    <br/>
    <ul>
        <li>Prints: <code>4 3 2 1</code></li>
        <li>Ranges must be in parentheses when using methods like <code>rev()</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Iterating over an array</b></li>
<pre><code class="language-rust line-numbers">let arr = [10, 20, 30];

for value in arr {
    println!("{}", value);
}
</code></pre>
    <br/>
    <ul>
        <li>Rust copies each element for simple types (like <code>i32</code>).</li>
        <li>For non-<code>Copy</code> types, values are moved (ownership transferred).</li>
    </ul>
    <br/><br/>


    <li><b>Iterating over a vector by reference</b></li>
<pre><code class="language-rust line-numbers">let v = vec![10, 20, 30];

for value in &amp;v {
    println!("{}", value);
}
</code></pre>
    <br/>
    <ul>
        <li><code>&v</code> borrows the vector instead of moving it.</li>
        <li>Inside the loop, <code>value</code> is of type <code>&i32</code>.</li>
        <li>The vector remains usable after the loop.</li>
    </ul>
    <br/><br/>


    <li><b>Mutable iteration over a vector</b></li>
<pre><code class="language-rust line-numbers">let mut v = vec![1, 2, 3];

for value in &mut v {
    *value *= 2;
}

println!("{:?}", v);
</code></pre>
    <br/>
    <ul>
        <li><code>&mut v</code> gives mutable references to elements.</li>
        <li>You must dereference <code>*value</code> to modify.</li>
        <li>Result: <code>[2, 4, 6]</code></li>
    </ul>
    <br/><br/>


    <li><b>Enumerating index and value</b></li>
<pre><code class="language-rust line-numbers">let arr = ["a", "b", "c"];

for (index, value) in arr.iter().enumerate() {
    println!("{}: {}", index, value);
}
</code></pre>
    <br/>
    <ul>
        <li><code>.iter()</code> borrows elements.</li>
        <li><code>.enumerate()</code> gives (index, value) pairs.</li>
    </ul>
    <br/><br/>


    <li><b>Iterating over characters in a string</b></li>
<pre><code class="language-rust line-numbers">let s = "Hello";

for c in s.chars() {
    println!("{}", c);
}
</code></pre>
    <br/>
    <ul>
        <li><code>.chars()</code> iterates Unicode scalar values (<code>char</code>).</li>
        <li>Each <code>char</code> is 4 bytes.</li>
    </ul>
    <br/><br/>


    <li><b>Iterating over bytes in a string</b></li>
<pre><code class="language-rust line-numbers">let s = "Hello";

for b in s.bytes() {
    println!("{}", b);
}
</code></pre>
    <br/>
    <ul>
        <li><code>.bytes()</code> iterates raw UTF-8 bytes (<code>u8</code>).</li>
        <li>Useful for parsing low-level binary data.</li>
    </ul>
    <br/><br/>


    <li><b>Using for with patterns</b></li>
<pre><code class="language-rust line-numbers">let pairs = vec![(1, 2), (3, 4)];

for (a, b) in pairs {
    println!("{} + {} = {}", a, b, a + b);
}
</code></pre>
    <br/>
    <ul>
        <li>Rust destructures tuples directly in the loop head.</li>
    </ul>
    <br/><br/>


    <li><b>Looping multiple ranges (Cartesian product)</b></li>
<pre><code class="language-rust line-numbers">for x in 0..3 {
    for y in 0..3 {
        println!("({}, {})", x, y);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Nesting <code>for</code> loops is straightforward.</li>
    </ul>
    <br/><br/>


    <li><b>Breaking from a for loop</b></li>
<pre><code class="language-rust line-numbers">for i in 0..10 {
    if i == 4 {
        break;
    }
    println!("{}", i);
}
</code></pre>
    <br/>
    <ul>
        <li><code>break</code> stops the loop early.</li>
    </ul>
    <br/><br/>


    <li><b>Continuing to next iteration</b></li>
<pre><code class="language-rust line-numbers">for i in 0..10 {
    if i % 2 == 0 {
        continue; // skip even numbers
    }
    println!("{}", i);
}
</code></pre>
    <br/>
    <ul>
        <li><code>continue</code> skips the remain of the current iteration.</li>
    </ul>
    <br/><br/>


    <li><b>Labelled for loops</b></li>
<pre><code class="language-rust line-numbers">'outer: for x in 0..3 {
    for y in 0..3 {
        if x == 1 && y == 1 {
            break 'outer;
        }
        println!("({}, {})", x, y);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Labels allow breaking out of outer loops.</li>
    </ul>
    <br/><br/>


    <li><b>Range types: from and to</b></li>
<pre><code class="language-rust line-numbers">// exclusive end
let r1 = 1..5;   // 1,2,3,4

// inclusive end
let r2 = 1..=5;  // 1,2,3,4,5
</code></pre>
    <br/>
    <ul>
        <li>All range types implement <code>Iterator</code> or <code>IntoIterator</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Ranges used in slices</b></li>
<pre><code class="language-rust line-numbers">let arr = [10, 20, 30, 40, 50];

let slice = &arr[1..4];  // elements 1 through 3
println!("{:?}", slice);
</code></pre>
    <br/>
    <ul>
        <li>Ranges can index collections.</li>
        <li>In slices, the upper bound is always exclusive.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of for and range</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Exclusive range</td>
                <td>End value is excluded</td>
                <td><code>0..5</code></td>
            </tr>
            <tr>
                <td>Inclusive range</td>
                <td>End value included</td>
                <td><code>0..=5</code></td>
            </tr>
            <tr>
                <td>Reverse iteration</td>
                <td>Iterate backwards</td>
                <td><code>(1..5).rev()</code></td>
            </tr>
            <tr>
                <td>Vector iteration</td>
                <td>Borrow or move elements</td>
                <td><code>for v in &vec</code></td>
            </tr>
            <tr>
                <td>Enumerate</td>
                <td>Index + value</td>
                <td><code>.enumerate()</code></td>
            </tr>
            <tr>
                <td>Characters</td>
                <td>Iterate Unicode chars</td>
                <td><code>s.chars()</code></td>
            </tr>
            <tr>
                <td>Pattern matching</td>
                <td>Destructure in loop head</td>
                <td><code>for (a,b) in pairs</code></td>
            </tr>
            <tr>
                <td>Labels</td>
                <td>Control nested loops</td>
                <td><code>'outer: for...</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li><code>for</code> is the most idiomatic looping construct in Rust.</li>
        <li>Ranges are powerful tools for index-free iteration.</li>
        <li>Together, they provide safe, expressive, and concise looping patterns for everyday Rust programming.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-match">match</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>match</code> is Rust‚Äôs powerful pattern-matching expression.</li>
        <br/>
        <li>It compares a value against multiple patterns and executes the code of the first matching arm.</li>
        <br/>
        <li><u>match must be exhaustive</u> ‚Äî all possible cases must be handled.</li>
        <br/>
        <li><code>match</code> is an expression and can return a value.</li>
    </ul>
    <br/><br/>


    <li><b>Basic match</b></li>
<pre><code class="language-rust line-numbers">let n = 3;

match n {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("something else"),
}
</code></pre>
    <br/>
    <ul>
        <li><code>_</code> is the wildcard pattern: matches anything.</li>
        <li>The match is exhaustive because <code>_</code> handles all remaining cases.</li>
    </ul>
    <br/><br/>


    <li><b>match is an expression</b></li>
<pre><code class="language-rust line-numbers">let n = 5;

let description = match n {
    1 =&gt; "one",
    2 =&gt; "two",
    3 =&gt; "three",
    _ =&gt; "other",
};

println!("{}", description);
</code></pre>
    <br/>
    <ul>
        <li>Both arms must produce the same type (<code>&amp;str</code> here).</li>
        <li>No semicolon inside arms unless you want to return <code>()</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Matching ranges</b></li>
<pre><code class="language-rust line-numbers">let age = 20;

match age {
    0..=12  =&gt; println!("child"),
    13..=19 =&gt; println!("teenager"),
    _       =&gt; println!("adult"),
}
</code></pre>
    <br/>
    <ul>
        <li>Range patterns are inclusive: <code>0..=12</code>.</li>
        <li>Great for numerical classification.</li>
    </ul>
    <br/><br/>


    <li><b>Multiple patterns with |</b></li>
<pre><code class="language-rust line-numbers">let c = 'a';

match c {
    'a' | 'e' | 'i' | 'o' | 'u' =&gt; println!("vowel"),
    _ =&gt; println!("consonant or other"),
}
</code></pre>
    <br/>
    <ul>
        <li><code>|</code> acts like logical OR for matching.</li>
    </ul>
    <br/><br/>


    <li><b>Matching Option&lt;T&gt;</b></li>
<pre><code class="language-rust line-numbers">let x: Option&lt;i32&gt; = Some(10);

match x {
    Some(n) =&gt; println!("value = {}", n),
    None    =&gt; println!("no value"),
}
</code></pre>
    <br/>
    <ul>
        <li><code>Option</code> is the standard way Rust handles nullability.</li>
        <li>The match destructures the enum and extracts its data.</li>
    </ul>
    <br/><br/>


    <li><b>Matching Result&lt;T, E&gt;</b></li>
<pre><code class="language-rust line-numbers">let r: Result&lt;i32, &amp;str&gt; = Ok(42);

match r {
    Ok(v)  =&gt; println!("Success: {}", v),
    Err(e) =&gt; println!("Error: {}", e),
}
</code></pre>
    <br/>
    <ul>
        <li>Used extensively in Rust error handling.</li>
        <li>Patterns extract inner values.</li>
    </ul>
    <br/><br/>


    <li><b>Binding matched values</b></li>
<pre><code class="language-rust line-numbers">let n = 7;

match n {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    other =&gt; println!("something else: {}", other),
}
</code></pre>
    <br/>
    <ul>
        <li><code>other</code> binds whatever value is matched.</li>
        <li>Equivalent to <code>_</code> but binds the value for use.</li>
    </ul>
    <br/><br/>


    <li><b>Pattern guards</b></li>
<pre><code class="language-rust line-numbers">let n = 10;

match n {
    x if x % 2 == 0 =&gt; println!("even"),
    _ =&gt; println!("odd"),
}
</code></pre>
    <br/>
    <ul>
        <li><u>Pattern guards</u> add an extra boolean condition.</li>
        <li>Useful for additional filtering beyond pattern structure.</li>
    </ul>
    <br/><br/>


    <li><b>Destructuring tuples</b></li>
<pre><code class="language-rust line-numbers">let pair = (3, -3);

match pair {
    (0, y) =&gt; println!("x is zero, y = {}", y),
    (x, 0) =&gt; println!("y is zero, x = {}", x),
    (x, y) =&gt; println!("x = {}, y = {}", x, y),
}
</code></pre>
    <br/>
    <ul>
        <li>Matches structure and extracts values at the same time.</li>
    </ul>
    <br/><br/>


    <li><b>Destructuring structs</b></li>
<pre><code class="language-rust line-numbers">struct Point { x: i32, y: i32 }

let p = Point { x: 3, y: 7 };

match p {
    Point { x: 0, y } =&gt; println!("on y-axis at {}", y),
    Point { x, y: 0 } =&gt; println!("on x-axis at {}", x),
    Point { x, y }     =&gt; println!("({}, {})", x, y),
}
</code></pre>
    <br/>
    <ul>
        <li>Allows destructuring only some fields or matching specific ones.</li>
    </ul>
    <br/><br/>


    <li><b>Match an enum with data</b></li>
<pre><code class="language-rust line-numbers">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Move { x: 3, y: 5 };

match msg {
    Message::Quit =&gt; println!("Quit"),
    Message::Move { x, y } =&gt; println!("Move to ({}, {})", x, y),
    Message::Write(text) =&gt; println!("Message: {}", text),
}
</code></pre>
    <br/>
    <ul>
        <li>This is one of Rust‚Äôs strongest features ‚Äî enum pattern matching.</li>
    </ul>
    <br/><br/>


    <li><b>Matching references</b></li>
<pre><code class="language-rust line-numbers">let x = 5;

match &amp;x {
    &amp;1 =&gt; println!("one"),
    &amp;n =&gt; println!("something else: {}", n),
}
</code></pre>
    <br/>
    <ul>
        <li>Patterns must match the reference type.</li>
        <li>Use <code>&amp;</code> in patterns to dereference.</li>
    </ul>
    <br/><br/>


    <li><b>Ignoring parts of a pattern</b></li>
<pre><code class="language-rust line-numbers">let pair = (10, 20);

match pair {
    (x, _) =&gt; println!("first = {}", x),
}
</code></pre>
    <br/>
    <ul>
        <li><code>_</code> ignores the second value.</li>
    </ul>
    <br/><br/>


    <li><b>Deep destructuring</b></li>
<pre><code class="language-rust line-numbers">let data = (Some(3), 10);

match data {
    (Some(x), y) =&gt; println!("x = {}, y = {}", x, y),
    (None, y)    =&gt; println!("no x, y = {}", y),
}
</code></pre>
    <br/>
    <ul>
        <li>Patterns can match deeply nested structures.</li>
    </ul>
    <br/><br/>


    <li><b>Match with return values</b></li>
<pre><code class="language-rust line-numbers">let n = 10;

let result = match n {
    0 =&gt; "zero",
    1 =&gt; "one",
    _ =&gt; "many",
};

println!("{}", result);
</code></pre>
    <br/>
    <ul>
        <li>Because <code>match</code> is an expression, you can return results directly.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of match</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic matching</td>
                <td>Compare values to patterns</td>
                <td><code>match x { 1 =&gt; ... }</code></td>
            </tr>
            <tr>
                <td>Wildcard</td>
                <td>Catches all unmatched cases</td>
                <td><code>_ =&gt; ...</code></td>
            </tr>
            <tr>
                <td>Ranges</td>
                <td>Match inclusive ranges</td>
                <td><code>0..=10</code></td>
            </tr>
            <tr>
                <td>Multiple patterns</td>
                <td>OR conditions</td>
                <td><code>'a' | 'b'</code></td>
            </tr>
            <tr>
                <td>Enums</td>
                <td>Destructure and match variants</td>
                <td><code>Message::Move { x, y }</code></td>
            </tr>
            <tr>
                <td>Guards</td>
                <td>Apply extra conditions</td>
                <td><code>x if x % 2 == 0</code></td>
            </tr>
            <tr>
                <td>Bindings</td>
                <td>Store matched value</td>
                <td><code>n =&gt; ...</code></td>
            </tr>
            <tr>
                <td>Destructuring</td>
                <td>Break apart structs/tuples</td>
                <td><code>(x, y)</code></td>
            </tr>
            <tr>
                <td>Expressions</td>
                <td>Return values from match</td>
                <td><code>let t = match x { ... }</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-if-let">if let</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>It is a shortcut for:
            <ul>
                <li>Matching <u>only one pattern</u></li>
                <li>Ignoring the <u>remaining cases</u></li>
            </ul>
        </li>
        <br/>
        <li>It is especially common with <code>Option</code>, <code>Result</code>, and simple enum matches.</li>
        <br/>
        <li>Equivalent to a <code>match</code> with two arms, where one arm is <code>_ =&gt; {}</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Basic if let with Option&lt;T&gt;</b></li>
<pre><code class="language-rust line-numbers">let value: Option&lt;i32&gt; = Some(10);

if let Some(v) = value {
    println!("Value is {}", v);
}
</code></pre>
    <br/>
    <ul>
        <li>This checks if <code>value</code> is <code>Some(v)</code>.</li>
        <li>Inside the block, <code>v</code> is available.</li>
        <li>If <code>value</code> is <code>None</code>, nothing happens.</li>
    </ul>
    <br/><br/>


    <li><b>if let ... else</b></li>
<pre><code class="language-rust line-numbers">let value: Option&lt;i32&gt; = None;

if let Some(v) = value {
    println!("Value = {}", v);
} else {
    println!("No value found");
}
</code></pre>
    <br/>
    <ul>
        <li><code>else</code> runs only when the pattern does not match.</li>
        <li>Equivalent to a full <code>match</code> expression.</li>
    </ul>
    <br/><br/>


    <li><b>if let is a shortcut for match</b></li>
<pre><code class="language-rust line-numbers">let value = Some(5);

match value {
    Some(v) =&gt; println!("{}", v),
    _ =&gt; {},
}
</code></pre>

<pre><code class="language-rust line-numbers">if let Some(v) = value {
    println!("{}", v);
}
</code></pre>
    <br/>
    <ul>
        <li>Same behavior, cleaner syntax.</li>
        <li>Use <code>match</code> when more than one pattern is needed.</li>
    </ul>
    <br/><br/>


    <li><b>Matching Result&lt;T, E&gt;</b></li>
<pre><code class="language-rust line-numbers">let result: Result&lt;i32, &amp;str&gt; = Ok(42);

if let Ok(n) = result {
    println!("Number is {}", n);
}
</code></pre>
    <br/>
    <ul>
        <li>Equivalent to checking for <code>Ok</code> only.</li>
        <li>Error case is ignored silently unless you add <code>else</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Using if let with enums</b></li>
<pre><code class="language-rust line-numbers">enum Msg {
    Quit,
    Move { x: i32, y: i32 },
}

let m = Msg::Move { x: 3, y: 7 };

if let Msg::Move { x, y } = m {
    println!("Moving to ({}, {})", x, y);
}
</code></pre>
    <br/>
    <ul>
        <li>Allows extracting values from an enum variant easily.</li>
        <li>Other variants are ignored.</li>
    </ul>
    <br/><br/>


    <li><b>if let with pattern guards</b></li>
<pre><code class="language-rust line-numbers">let n = Some(12);

if let Some(v) = n if v &gt; 10 {
    println!("Large number: {}", v);
}
</code></pre>
    <br/>
    <ul>
        <li>Pattern guards refine conditions further.</li>
        <li>Equivalent to <code>Some(v) if v &gt; 10</code> in a match arm.</li>
    </ul>
    <br/><br/>


    <li><b>Mutably binding with if let</b></li>
<pre><code class="language-rust line-numbers">let mut opt = Some(5);

if let Some(ref mut v) = opt {
    *v += 1;
}

println!("{:?}", opt);
</code></pre>
    <br/>
    <ul>
        <li><code>ref mut</code> gives a mutable reference to the contained value.</li>
        <li>Very common for updating a value inside <code>Option</code>.</li>
    </ul>
    <br/><br/>


    <li><b>if let with references</b></li>
<pre><code class="language-rust line-numbers">let x = Some(10);

if let Some(&amp;v) = x.as_ref() {
    println!("v = {}", v);
}
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;</code> in patterns destructures the reference.</li>
        <li><code>as_ref()</code> converts <code>Option&lt;T&gt;</code> into <code>Option&lt;&amp;T&gt;</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Combining multiple patterns (nested)</b></li>
<pre><code class="language-rust line-numbers">let data = Some((1, 2));

if let Some((a, b)) = data {
    println!("a = {}, b = {}", a, b);
}
</code></pre>
    <br/>
    <ul>
        <li>Works with nested tuples, structs, enums, etc.</li>
    </ul>
    <br/><br/>


    <li><b>if let chains (Rust 1.65+)</b></li>
<pre><code class="language-rust line-numbers">let a = Some(10);
let b = Some(20);

if let Some(x) = a
    &amp;&amp; let Some(y) = b
{
    println!("Both present: {} and {}", x, y);
}
</code></pre>
    <br/>
    <ul>
        <li>Chained <code>if let</code> allows matching multiple patterns at once.</li>
        <li>Both patterns must match for the body to execute.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-let-else">let else</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>let else</code> is a control-flow construct introduced in Rust 1.65.</li>
        <br/>
        <li>It allows you to perform pattern matching <u>inside a let-binding</u>, and if the pattern fails, execution jumps into an <code>else</code> block.</li>
        <br/>
        <li>It is used for:
            <ul>
                <li>Early exits</li>
                <li>Input validation</li>
                <li>Pattern destructuring with failure handling</li>
            </ul>
        </li>
        <br/>
        <li>Syntax:</li>
    </ul>

<pre><code class="language-rust line-numbers">let PATTERN = EXPR else {
    HANDLING_CODE
};</code></pre>

    <br/>
    <ul>
        <li>If <code>EXPR</code> matches <code>PATTERN</code>, the destructured variables are available afterwards.</li>
        <li>If not, the <code>else</code> block runs, and the surrounding scope must be exited (e.g., <code>return</code>, <code>break</code>, <code>continue</code>, <code>panic!</code>).</li>
    </ul>
    <br/><br/>


    <li><b>Basic let else Example</b></li>
<pre><code class="language-rust line-numbers">let Some(value) = maybe_value else {
    println!("No value!");
    return;
};

println!("Got: {}", value);
</code></pre>
    <br/>
    <ul>
        <li>If <code>maybe_value</code> is <code>Some(v)</code>, then <code>value</code> is bound.</li>
        <li>If it's <code>None</code>, the function returns early.</li>
    </ul>
    <br/><br/>


    <li><b>Why let else? Cleaner than match</b></li>
<pre><code class="language-rust line-numbers">// Traditional match:
let value = match maybe_value {
    Some(v) =&gt; v,
    None =&gt; return,
};

// Cleaner with let else:
let Some(value) = maybe_value else {
    return;
};
</code></pre>
    <br/>
    <ul>
        <li>Avoids indentation and nested matches.</li>
        <li>Improves readability when only one pattern matters.</li>
    </ul>
    <br/><br/>


    <li><b>Using let else with multiple variables</b></li>
<pre><code class="language-rust line-numbers">let Ok((x, y)) = do_work() else {
    eprintln!("Work failed");
    return;
};

println!("x = {}, y = {}", x, y);
</code></pre>
    <br/>
    <ul>
        <li>Perfect for destructuring tuples, structs, or enum variants.</li>
    </ul>
    <br/><br/>


    <li><b>let else in loops</b></li>
<pre><code class="language-rust line-numbers">while let Some(line) = lines.next() {
    let Ok(num) = line.parse::&lt;i32&gt;() else {
        continue; // skip malformed input
    };

    println!("Parsed number: {}", num);
}
</code></pre>
    <br/>
    <ul>
        <li><code>continue</code> is a valid early exit inside loops.</li>
        <li>Useful for parsing streams or validating input.</li>
    </ul>
    <br/><br/>


    <li><b>let else with structs</b></li>
<pre><code class="language-rust line-numbers">struct Point { x: i32, y: i32 }

let Point { x, y } = p else {
    panic!("Not a point!");
};

println!("({}, {})", x, y);
</code></pre>
    <br/>
    <ul>
        <li>Struct destructuring works the same as in <code>match</code> patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Pattern guards are allowed</b></li>
<pre><code class="language-rust line-numbers">let Some(v) = input else {
    panic!("Not an Option");
};

let n = v;

let Some(x) = n.filter(|x| *x &gt; 10) else {
    println!("Too small!");
    return;
};
</code></pre>
    <br/>
    <ul>
        <li>You can combine <code>let else</code> with preconditions using methods like <code>filter</code>.</li>
    </ul>
    <br/><br/>


    <li><b>The else block must break or return</b></li>
<pre><code class="language-rust line-numbers">// ERROR: compiler does not allow falling through
let Some(x) = maybe else {
    println!("No value");
    // nothing here ‚Äî ERROR
};
</code></pre>
    <br/>
    <ul>
        <li>The compiler requires that the <code>else</code> block ends control flow:</li>
        <ul>
            <li><code>return</code></li>
            <li><code>break</code></li>
            <li><code>continue</code></li>
            <li><code>panic!</code></li>
        </ul>
        <li>Otherwise, the pattern failure would result in uninitialized variables.</li>
    </ul>
    <br/><br/>


    <li><b>Combining let else with references</b></li>
<pre><code class="language-rust line-numbers">let Some(&amp;num) = maybe_ref else {
    return;
};

println!("Number: {}", num);
</code></pre>
    <br/>
    <ul>
        <li>Supports destructuring of references via <code>&amp;</code> in the pattern.</li>
    </ul>
    <br/><br/>


    <li><b>Chaining multiple let elses</b></li>
<pre><code class="language-rust line-numbers">let Some(a) = opt_a else { return; };
let Some(b) = opt_b else { return; };
let Ok(sum) = add(a, b) else { return; };

println!("Sum = {}", sum);
</code></pre>
    <br/>
    <ul>
        <li>Useful for step-by-step validation pipelines.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-while-let">while let</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>while let</code> is a control-flow construct that repeatedly matches a pattern as long as it continues to succeed.</li>
        <br/>
        <li>It is especially useful for:
            <ul>
                <li>Iterators</li>
                <li>Processing <code>Option</code> values</li>
                <li>Handling <code>Result</code> types in loops</li>
                <li>State machines or stream parsing</li>
            </ul>
        </li>
        <br/>
        <li>It is syntactic sugar for a <code>loop</code> + <code>if let</code> + <code>break</code> combination.</li>
    </ul>
    <br/><br/>


    <li><b>Basic while let Example</b></li>
<pre><code class="language-rust line-numbers">let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop() {
    println!("Popped: {}", top);
}
</code></pre>
    <br/>
    <ul>
        <li><code>stack.pop()</code> returns <code>Some(value)</code> until the vector is empty.</li>
        <li>When it returns <code>None</code>, the loop stops automatically.</li>
        <li>No need for a manual <code>break</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Equivalent to loop + if let</b></li>
<pre><code class="language-rust line-numbers">let mut stack = vec![1, 2, 3];

loop {
    if let Some(top) = stack.pop() {
        println!("Popped: {}", top);
    } else {
        break;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>while let</code> is more concise and idiomatic for this pattern.</li>
    </ul>
    <br/><br/>


    <li><b>Matching tuples with while let</b></li>
<pre><code class="language-rust line-numbers">let mut iter = (0..5).enumerate();

while let Some((index, value)) = iter.next() {
    println!("#{} = {}", index, value);
}
</code></pre>
    <br/>
    <ul>
        <li>You can destructure complex values inside the loop header.</li>
    </ul>
    <br/><br/>


    <li><b>while let with Result&lt;T, E&gt;</b></li>
<pre><code class="language-rust line-numbers">let mut input = vec!["10", "x", "20"].into_iter();

while let Some(s) = input.next() {
    let Ok(n) = s.parse::&lt;i32&gt;() else {
        println!("Skipping invalid number: {}", s);
        continue;
    };

    println!("Parsed: {}", n);
}
</code></pre>
    <br/>
    <ul>
        <li>Here <code>while let</code> drives iteration, while <code>let else</code> handles parsing.</li>
        <li>You may combine both constructs effectively.</li>
    </ul>
    <br/><br/>


    <li><b>while let with state machines</b></li>
<pre><code class="language-rust line-numbers">enum State {
    Start,
    Number(i32),
    End,
}

let mut state = Some(State::Start);

while let Some(s) = state {
    match s {
        State::Start =&gt; {
            println!("Starting...");
            state = Some(State::Number(42));
        }
        State::Number(n) =&gt; {
            println!("Number: {}", n);
            state = Some(State::End);
        }
        State::End =&gt; {
            println!("Finished.");
            state = None;
        }
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>while let</code> loops until <code>state</code> becomes <code>None</code>.</li>
        <li>Extremely useful for designing simple state machines.</li>
    </ul>
    <br/><br/>


    <li><b>Processing I/O lines</b></li>
<pre><code class="language-rust line-numbers">use std::io::{self, BufRead};

let stdin = io::stdin();
let mut lines = stdin.lock().lines();

while let Some(Ok(line)) = lines.next() {
    println!("Input: {}", line);
}
</code></pre>
    <br/>
    <ul>
        <li>Real-world example: reading input until EOF.</li>
        <li>Combines pattern matching with loop control.</li>
    </ul>
    <br/><br/>


    <li><b>while let with references</b></li>
<pre><code class="language-rust line-numbers">let numbers = vec![10, 20, 30];
let mut iter = numbers.iter();

while let Some(&amp;n) = iter.next() {
    println!("n = {}", n);
}
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;n</code> destructures a <code>&amp;i32</code> reference into an <code>i32</code> value.</li>
    </ul>
    <br/><br/>


    <li><b>while let vs for loop</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use while let when...</th>
                <th>Use for when...</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>You must destructure <code>Option</code> or <code>Result</code>.</td>
                <td>You have a simple iterator.</td>
            </tr>
            <tr>
                <td>You want to stop upon <code>None</code>.</td>
                <td>You want to iterate exactly once over each element.</td>
            </tr>
            <tr>
                <td>You have stateful logic controlling <code>next()</code>.</td>
                <td>Your iterations are independent and clean.</td>
            </tr>
            <tr>
                <td>You need flexible custom loop breaking.</td>
                <td>Standard iteration is sufficient.</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Summary of while let</b></li>
    <br/>
    <ul>
        <li><code>while let</code> repeatedly matches a pattern until it fails.</li>
        <li>Perfect for iterators, stacks, parsing, and state machines.</li>
        <li>A more concise alternative to:
            <ul>
                <li><code>loop</code> + <code>if let</code> + <code>break</code></li>
                <li>or a <code>match</code> inside a loop</li>
            </ul>
        </li>
        <li>Supports full pattern matching, destructuring, references, and tuple patterns.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-methods">Methods</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>method</u> in Rust is a function defined inside an <code>impl</code> block and associated with a specific type (struct, enum, or trait).</li>
        <br/>
        <li>Unlike a normal function, a method always has:
            <ul>
                <li>a <u>receiver</u> parameter (<code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code>)</li>
                <li>access to the instance it is called on</li>
            </ul>
        </li>
        <br/>
        <li>Methods allow types to encapsulate behavior, similar to OOP languages, but without inheritance.</li>
    </ul>
    <br/><br/>


    <li><b>Defining a Method</b></li>
<pre><code class="language-rust line-numbers">struct Point {
    x: f64,
    y: f64,
}

impl Point {
    fn distance_from_origin(&amp;self) -&gt; f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Methods are placed inside an <code>impl</code> block.</li>
        <li><code>&amp;self</code> borrows the instance immutably.</li>
        <li>Call it like this:</li>
    </ul>

<pre><code class="language-rust line-numbers">let p = Point { x: 3.0, y: 4.0 };
println!("{}", p.distance_from_origin());
</code></pre>
    <br/><br/>


    <li><b>The Receiver: self, &amp;self, &amp;mut self</b></li>
    <br/>
    <ul>
        <li>Methods may take the following receivers:</li>
    </ul>

    <table>
        <thead>
            <tr>
                <th>Receiver</th>
                <th>Description</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>self</code></td>
                <td>takes ownership</td>
                <td>method consumes the instance</td>
            </tr>
            <tr>
                <td><code>&amp;self</code></td>
                <td>immutable borrow</td>
                <td>method reads but cannot modify</td>
            </tr>
            <tr>
                <td><code>&amp;mut self</code></td>
                <td>mutable borrow</td>
                <td>method can modify the instance</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Methods with &amp;mut self</b></li>
<pre><code class="language-rust line-numbers">impl Point {
    fn move_by(&amp;mut self, dx: f64, dy: f64) {
        self.x += dx;
        self.y += dy;
    }
}

let mut p = Point { x: 1.0, y: 2.0 };
p.move_by(5.0, -1.0);
</code></pre>
    <br/>
    <ul>
        <li>Only mutable instances can call methods with <code>&amp;mut self</code>.</li>
        <li>Rust enforces borrowing rules strictly.</li>
    </ul>
    <br/><br/>


    <li><b>Methods with self (consuming)</b></li>
<pre><code class="language-rust line-numbers">impl Point {
    fn into_tuple(self) -&gt; (f64, f64) {
        (self.x, self.y)
    }
}

let p = Point { x: 3.0, y: 4.0 };
let t = p.into_tuple(); // p is moved and cannot be used again
</code></pre>
    <br/>
    <ul>
        <li>Use <code>self</code> when a method should take ownership.</li>
        <li>Common for builder patterns and transformation methods.</li>
    </ul>
    <br/><br/>


    <li><b>Multiple impl Blocks</b></li>
<pre><code class="language-rust line-numbers">impl Point {
    fn x(&amp;self) -&gt; f64 { self.x }
}

impl Point {
    fn y(&amp;self) -&gt; f64 { self.y }
}
</code></pre>
    <br/>
    <ul>
        <li>A type can have many <code>impl</code> blocks.</li>
        <li>Useful for separating functionality into logical sections.</li>
    </ul>
    <br/><br/>


    <li><b>Associated Functions vs Methods</b></li>
<pre><code class="language-rust line-numbers">impl Point {
    fn new(x: f64, y: f64) -&gt; Self {
        Self { x, y }
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Associated functions have no <code>self</code> parameter.</li>
        <li>Called with <code>Point::new()</code>, not on an instance.</li>
        <li>Commonly used for constructors.</li>
    </ul>

<pre><code class="language-rust line-numbers">let p = Point::new(1.0, 2.0);
</code></pre>
    <br/><br/>


    <li><b>Chaining Methods</b></li>
<pre><code class="language-rust line-numbers">struct Counter { n: i32 }

impl Counter {
    fn new() -&gt; Self {
        Self { n: 0 }
    }

    fn inc(&amp;mut self) -&gt; &amp;mut Self {
        self.n += 1;
        self
    }
}

let mut c = Counter::new();
c.inc().inc().inc();
</code></pre>
    <br/>
    <ul>
        <li>Return <code>&amp;mut Self</code> to support fluent APIs.</li>
    </ul>
    <br/><br/>


    <li><b>Methods on Enums</b></li>
<pre><code class="language-rust line-numbers">enum Shape {
    Circle(f64),
    Rect { w: f64, h: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Circle(r) =&gt; std::f64::consts::PI * r * r,
            Shape::Rect { w, h } =&gt; w * h,
        }
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Enums can have methods just like structs.</li>
        <li>Supports full pattern matching inside methods.</li>
    </ul>
    <br/><br/>


    <li><b>Method Syntax Sugar: p.method() == Type::method(&amp;p)</b></li>
<pre><code class="language-rust line-numbers">p.distance_from_origin();

// Is equivalent to:
Point::distance_from_origin(&amp;p);
</code></pre>
    <br/>
    <ul>
        <li>Rust automatically inserts:
            <ul>
                <li><code>&amp;</code></li>
                <li><code>&amp;mut</code></li>
                <li>or ownership moves</li>
            </ul>
            depending on the method signature.</li>
        <br/>
        <li>This is called <b>automatic referencing and dereferencing</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Methods with Generic Parameters</b></li>
<pre><code class="language-rust line-numbers">struct Wrapper&lt;T&gt; {
    value: T,
}

impl&lt;T&gt; Wrapper&lt;T&gt; {
    fn get(&amp;self) -&gt; &amp;T {
        &amp;self.value
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Methods can be generic, just like functions.</li>
        <li>Generic types appear on the <code>impl</code> block.</li>
    </ul>
    <br/><br/>


    <li><b>Methods with where Clauses</b></li>
<pre><code class="language-rust line-numbers">impl&lt;T&gt; Wrapper&lt;T&gt;
where
    T: std::fmt::Display,
{
    fn show(&amp;self) {
        println!("{}", self.value);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Allows restricting methods to types that satisfy trait bounds.</li>
    </ul>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-closures">Closures</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>closure</u> in Rust is an anonymous function that can capture values from its surrounding environment.</li>
        <br/>
        <li>Closures are similar to:
            <ul>
                <li>lambda expressions (Python, Java, C++)</li>
                <li>blocks (Swift)</li>
                <li>arrow functions (JavaScript)</li>
            </ul>
        </li>
        <br/>
        <li>They are often used for:
            <ul>
                <li>inline logic</li>
                <li>callbacks</li>
                <li>short computations</li>
                <li>functional-style programming</li>
            </ul>
        </li>
        <br/>
        <li>Closures are defined using the <code>|args| expression</code> syntax.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Closure Syntax</b></li>
<pre><code class="language-rust line-numbers">let add = |a, b| a + b;

println!("{}", add(2, 3)); // 5
</code></pre>
    <br/>
    <ul>
        <li>No type annotations needed ‚Äî Rust infers the types.</li>
        <li>Closures can be stored in variables and called like functions.</li>
    </ul>
    <br/><br/>


    <li><b>Closures Capturing Environment</b></li>
<pre><code class="language-rust line-numbers">let x = 10;

let show = || println!("x = {}", x);

show();
</code></pre>
    <br/>
    <ul>
        <li>The closure automatically captures <code>x</code> by reference.</li>
        <li>Rust chooses the capture mode based on usage.</li>
    </ul>
    <br/><br/>


    <li><b>Capture by Mutable Reference</b></li>
<pre><code class="language-rust line-numbers">let mut counter = 0;

let mut increment = || {
    counter += 1;
};

increment();
increment();

println!("{}", counter); // 2
</code></pre>
    <br/>
    <ul>
        <li>Because the closure mutates <code>counter</code>, the closure itself must be mutable.</li>
    </ul>
    <br/><br/>


    <li><b>Capture by Move (Moving Ownership)</b> </li>
<pre><code class="language-rust line-numbers">let s = String::from("hello");

let closure = move || {
    println!("inside: {}", s);
};

closure();

// println!("{}", s); // ERROR: moved into closure
</code></pre>
    <br/>
    <ul>
        <li><code>move</code> forces the closure to take ownership of captured variables.</li>
        <li>Useful when closures are passed to new threads.</li>
    </ul>
    <br/><br/>


    <li><b>Type Annotations for Closures</b></li>
<pre><code class="language-rust line-numbers">let multiply = |a: i32, b: i32| -&gt; i32 {
    a * b
};
</code></pre>
    <br/>
    <ul>
        <li>Usually unnecessary, but required when Rust cannot infer types.</li>
    </ul>
    <br/><br/>


    <li><b>Closures as Function Parameters</b></li>
<pre><code class="language-rust line-numbers">fn apply&lt;F&gt;(f: F)
where
    F: Fn(),
{
    f();
}

apply(|| println!("Hello"));
</code></pre>
    <br/>
    <ul>
        <li>Closures implement one of the function traits:
            <ul>
                <li><code>Fn</code></li>
                <li><code>FnMut</code></li>
                <li><code>FnOnce</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>The Three Closure Traits</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Trait</th>
                <th>Capture Style</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>Fn</code></td>
                <td>&amp;T (immutable borrow)</td>
                <td>Used for closures that don't modify captured values</td>
            </tr>
            <tr>
                <td><code>FnMut</code></td>
                <td>&amp;mut T (mutable borrow)</td>
                <td>Used for closures that modify captured variables</td>
            </tr>
            <tr>
                <td><code>FnOnce</code></td>
                <td>T (move)</td>
                <td>Used for closures that consume captured variables</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Every closure implements exactly one of these traits.</li>
        <li><code>FnOnce</code> is the "lowest" trait ‚Äî all closures implement it.</li>
    </ul>
    <br/><br/>


    <li><b>Returning Closures</b></li>
    <br/>
    <ul>
        <li>Closures have unique types, so returning them requires <u>impl Trait</u>.</li>
    </ul>

<pre><code class="language-rust line-numbers">fn make_adder(x: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |y| x + y
}

let add10 = make_adder(10);
println!("{}", add10(5)); // 15
</code></pre>
    <br/><br/>


    <li><b>Closures in Iterator Adapters</b></li>
<pre><code class="language-rust line-numbers">let nums = vec![1, 2, 3];

let doubled: Vec&lt;i32&gt; = nums.iter()
    .map(|x| x * 2)
    .collect();

println!("{:?}", doubled); // [2, 4, 6]
</code></pre>
    <br/>
    <ul>
        <li>Closures are essential for functional-style iterator chains.</li>
        <li><code>map</code>, <code>filter</code>, <code>fold</code>, and many others rely heavily on closures.</li>
    </ul>
    <br/><br/>


    <li><b>Closures in Threads</b></li>
<pre><code class="language-rust line-numbers">use std::thread;

let s = String::from("hello");

thread::spawn(move || {
    println!("{}", s);
});
</code></pre>
    <br/>
    <ul>
        <li>Threads require <code>move</code> closures to ensure captured values are owned.</li>
    </ul>
    <br/><br/>


    <li><b>Closures vs Functions</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Closures</th>
                <th>Functions</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Can capture environment</td>
                <td>Cannot capture any outside variable</td>
            </tr>
            <tr>
                <td>Anonymous, inline</td>
                <td>Named, standalone</td>
            </tr>
            <tr>
                <td>Type inferred automatically</td>
                <td>Types must be explicit</td>
            </tr>
            <tr>
                <td>Implement Fn / FnMut / FnOnce</td>
                <td>Functions are <code>fn</code> pointers</td>
            </tr>
        </tbody>
    </table>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-higher-order-functions">Higher-Order Functions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>higher-order function</u> (HOF) is any function that does one or both of the following:</li>
        <ul>
            <li>Accepts another function or closure as an argument</li>
            <li>Returns a function or closure</li>
        </ul>
        <br/>
        <li>They power iterator adapters (<code>map</code>, <code>filter</code>, <code>fold</code>), callback-based APIs, and clean abstraction patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Accepting a Closure as an Argument</b></li>
<pre><code class="language-rust line-numbers">fn apply&lt;F&gt;(f: F)
where
    F: Fn(),
{
    f();
}

apply(|| println!("Hello from closure"));
</code></pre>
    <br/>
    <ul>
        <li>The function <code>apply</code> takes any <code>Fn()</code> closure and executes it.</li>
        <li>Traits <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> decide how closures capture variables.</li>
    </ul>
    <br/><br/>


    <li><b>Passing Closures with Parameters</b></li>
<pre><code class="language-rust line-numbers">fn compute&lt;F&gt;(op: F, a: i32, b: i32) -&gt; i32
where
    F: Fn(i32, i32) -&gt; i32,
{
    op(a, b)
}

let sum = compute(|x, y| x + y, 2, 3);
println!("{}", sum); // 5
</code></pre>
    <br/>
    <ul>
        <li>Higher-order functions enable behavior injection instead of hard-coded logic.</li>
    </ul>
    <br/><br/>


    <li><b>Returning a Closure</b></li>
    <br/>
    <ul>
        <li>Because closures have unique types, Rust returns them using <code>impl Fn</code>.</li>
    </ul>

<pre><code class="language-rust line-numbers">fn make_multiplier(x: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |y| x * y
}

let times3 = make_multiplier(3);

println!("{}", times3(10)); // 30
</code></pre>
    <br/>
    <ul>
        <li>Using <code>move</code> ensures the closure captures <code>x</code> by value.</li>
    </ul>
    <br/><br/>


    <li><b>Returning Different Closures Based on Conditions</b></li>
<pre><code class="language-rust line-numbers">fn choose(op: &amp;str) -&gt; impl Fn(i32, i32) -&gt; i32 {
    match op {
        "add" =&gt; |a, b| a + b,
        "mul" =&gt; |a, b| a * b,
        _ =&gt; |_, _| 0,
    }
}

let adder = choose("add");
println!("{}", adder(2, 3)); // 5
</code></pre>
    <br/>
    <ul>
        <li>HOFs can dynamically create and return behaviors.</li>
    </ul>
    <br/><br/>


    <li><b>Using Higher-Order Functions with Iterators</b></li>
<pre><code class="language-rust line-numbers">let nums = vec![1, 2, 3, 4];

let even_squares: Vec&lt;i32&gt; = nums
    .into_iter()
    .filter(|x| x % 2 == 0)
    .map(|x| x * x)
    .collect();

println!("{:?}", even_squares); // [4, 16]
</code></pre>
    <br/>
    <ul>
        <li><code>map</code>, <code>filter</code>, <code>fold</code>, and many others are higher-order functions.</li>
        <li>They take closures and return new iterators.</li>
        <li>This enables expressive, chainable pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>fold: The Most General HOF</b></li>
<pre><code class="language-rust line-numbers">let sum = (1..=5).fold(0, |acc, x| acc + x);

println!("{}", sum); // 15
</code></pre>
    <br/>
    <ul>
        <li><code>fold</code> accumulates values based on a closure.</li>
        <li>Expressive and extremely flexible.</li>
    </ul>
    <br/><br/>


    <li><b>Closures vs Function Pointers</b></li>
    <br/>
    <ul>
        <li>Higher-order functions may accept either closures or function pointers.</li>
    </ul>

<pre><code class="language-rust line-numbers">fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn operate&lt;F&gt;(f: F) -&gt; i32
where
    F: Fn(i32, i32) -&gt; i32,
{
    f(3, 4)
}

println!("{}", operate(add));        // works
println!("{}", operate(|x, y| x*y)); // works
</code></pre>
    <br/>
    <ul>
        <li>Function pointers automatically coerce to <code>Fn</code>-trait closures.</li>
    </ul>
    <br/><br/>


    <li><b>Higher-Order Functions with Generics</b></li>
<pre><code class="language-rust line-numbers">fn transform_all&lt;T, F&gt;(items: Vec&lt;T&gt;, f: F) -&gt; Vec&lt;T&gt;
where
    F: Fn(T) -&gt; T,
{
    items.into_iter().map(f).collect()
}

let nums = vec![1, 2, 3];
let doubled = transform_all(nums, |x| x * 2);

println!("{:?}", doubled); // [2, 4, 6]
</code></pre>
    <br/>
    <ul>
        <li>HOFs work with generics to provide powerful reusable patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Using HOFs as Callbacks</b></li>
<pre><code class="language-rust line-numbers">fn notify&lt;F&gt;(msg: &amp;str, f: F)
where
    F: Fn(&amp;str),
{
    f(msg);
}

notify("Warning!", |text| println!("[LOG]: {}", text));
</code></pre>
    <br/>
    <ul>
        <li>Great for logging layers, hooks, and event handlers.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Higher-Order Functions</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Accept functions</td>
                <td>HOFs can take closures or function pointers as arguments</td>
            </tr>
            <tr>
                <td>Return functions</td>
                <td>HOFs may return closures using <code>impl Fn</code></td>
            </tr>
            <tr>
                <td>Used in iterators</td>
                <td><code>map</code>, <code>filter</code>, <code>fold</code> are all HOFs</td>
            </tr>
            <tr>
                <td>Enable declarative style</td>
                <td>Clean, chainable, functional pipelines</td>
            </tr>
            <tr>
                <td>Flexible capture rules</td>
                <td>Closures can capture variables via <code>&amp;</code>, <code>&amp;mut</code>, or <code>move</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Higher-order functions make Rust expressive, modular, and functional when needed.</li>
        <li>They are central to iterator chains, callback-based APIs, and composable logic.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-diverging-functions">Diverging Functions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>diverging function</u> in Rust is a function that <u>never returns</u>.</li>
        <br/>
        <li>Such a function has the special return type <code>!</code>, called the <u>never type</u>.</li>
        <br/>
        <li>Diverging functions are used for:
            <ul>
                <li>fatal errors</li>
                <li>infinite event loops</li>
                <li>type-level reasoning</li>
                <li>unreachable logic</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Syntax of a Diverging Function</b></li>
<pre><code class="language-rust line-numbers">fn never_returns() -&gt; ! {
    panic!("This function never returns");
}
</code></pre>
    <br/>
    <ul>
        <li>The return type <code>!</code> signifies that control flow never reaches the end.</li>
    </ul>
    <br/><br/>


    <li><b>Infinite Loops as Diverging Functions</b></li>
<pre><code class="language-rust line-numbers">fn forever() -&gt; ! {
    loop {
        println!("Running forever...");
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The function never exits the <code>loop</code>, so the return type is <code>!</code>.</li>
        <li>This is often used in embedded systems or event-driven environments.</li>
    </ul>
    <br/><br/>


    <li><b>Diverging Functions in Error Handling</b></li>
<pre><code class="language-rust line-numbers">fn expect_value(v: Option&lt;i32&gt;) -&gt; i32 {
    match v {
        Some(n) =&gt; n,
        None =&gt; panic!("Expected a value"),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>panic!</code> is itself a diverging function.</li>
        <li>This allows <code>match</code> to return <code>i32</code> even though one branch never returns.</li>
    </ul>
    <br/><br/>


    <li><b>The Never Type as a "Bottom Type"</b></li>
    <br/>
    <ul>
        <li><code>!</code> can coerce into any other type.</li>
        <li>This is because <code>!</code> has no valid value ‚Äî it never actually exists.</li>
    </ul>

<pre><code class="language-rust line-numbers">let x: i32 = {
    panic!("crash"); // type is `!` but coerced to i32
};
</code></pre>
    <br/>
    <ul>
        <li>Expressions that never produce a value can still be used where a value is expected.</li>
    </ul>
    <br/><br/>


    <li><b>Using Diverging Functions for Exhaustive Matching</b></li>
<pre><code class="language-rust line-numbers">enum Never {}

fn impossible(n: Never) -&gt; ! {
    match n {} // no variants, so this match is exhaustive
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>Never</code> enum has no variants ‚Äî it is uninhabitable.</li>
        <li>This function can never be called, so its return type is <code>!</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Useful for Marking Unreachable Code</b></li>
<pre><code class="language-rust line-numbers">fn handle(value: Result&lt;i32, &amp;str&gt;) -&gt; i32 {
    match value {
        Ok(v) =&gt; v,
        Err(_) =&gt; unreachable!("Error should never occur"),
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>unreachable!()</code> is a diverging macro that returns <code>!</code>.</li>
        <li>It signals logic that should not be reachable, both for humans and the compiler.</li>
    </ul>
    <br/><br/>


    <li><b>Never Type in Control Flow</b></li>
<pre><code class="language-rust line-numbers">fn compute(flag: bool) -&gt; i32 {
    if flag {
        return 10;
    } else {
        panic!("bad flag"); // type = !
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>panic!</code> branch becomes type-compatible with <code>i32</code> because <code>!</code> can coerce into any type.</li>
    </ul>
    <br/><br/>


    <li><b>Never Type in Matches</b></li>
<pre><code class="language-rust line-numbers">let mut iter = vec![1].into_iter();

match iter.next() {
    Some(v) =&gt; println!("{}", v),
    None =&gt; { continue; } // continue is diverging
}
</code></pre>
    <br/>
    <ul>
        <li><code>continue</code>, <code>break</code>, and <code>return</code> all produce <code>!</code>.</li>
        <li>Therefore they are legal where other value types are expected.</li>
    </ul>
    <br/><br/>


    <li><b>Common Diverging Constructs</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Expression</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>panic!()</code></td>
                <td><code>!</code></td>
                <td>Terminates the program</td>
            </tr>
            <tr>
                <td><code>loop { ... }</code></td>
                <td><code>!</code></td>
                <td>Infinite loop</td>
            </tr>
            <tr>
                <td><code>continue</code></td>
                <td><code>!</code></td>
                <td>Exits current loop iteration</td>
            </tr>
            <tr>
                <td><code>break</code> (no value)</td>
                <td><code>!</code></td>
                <td>Exits the loop immediately</td>
            </tr>
            <tr>
                <td><code>return</code></td>
                <td><code>!</code></td>
                <td>Leaves the function</td>
            </tr>
            <tr>
                <td><code>unimplemented!()</code>, <code>todo!()</code></td>
                <td><code>!</code></td>
                <td>Marks incomplete code</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Summary of Diverging Functions</b></li>
    <br/>
    <ul>
        <li>Diverging functions return <code>!</code>, the never type.</li>
        <li>They never complete normally ‚Äî they loop forever or abort execution.</li>
        <li><code>!</code> can coerce into any other type, making it flexible in control-flow expressions.</li>
        <li>Used widely in:
            <ul>
                <li>error handling</li>
                <li>infinite loops</li>
                <li>exhaustive matching</li>
                <li>unreachable paths</li>
            </ul>
        </li>
        <li>The never type is a powerful tool for the type system and compiler optimizations.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-modules">Modules in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>module</u> in Rust is a way to organize code into logical units.</li>
        <br/>
        <li>Modules can be nested, private or public, inline or file-based.</li>
        <br/>
        <li>Rust‚Äôs module system works together with its file system structure.</li>
    </ul>
    <br/><br/>


    <li><b>Declaring a Module (Inline)</b></li>
<pre><code class="language-rust line-numbers">mod api {
    pub fn hello() {
        println!("Hello from API!");
    }
}

fn main() {
    api::hello();
}
</code></pre>
    <br/>
    <ul>
        <li>Inline modules are declared with the <code>mod</code> keyword.</li>
        <li>The code is placed directly inside braces <code>{ ... }</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Declaring a Module in a Separate File</b></li>
    <br/>
    <ul>
        <li>This is the standard way for larger projects.</li>
    </ul>

<pre><code class="language-bash line-numbers">src/
‚îú‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ api.rs
</code></pre>

<pre><code class="language-rust line-numbers">// main.rs
mod api;           // declares the module (loads src/api.rs)
fn main() {
    api::hello();
}
</code></pre>

<pre><code class="language-rust line-numbers">// api.rs
pub fn hello() {
    println!("Hello from file module!");
}
</code></pre>
    <br/>
    <ul>
        <li><code>mod api;</code> tells Rust to load <code>api.rs</code> as the module body.</li>
    </ul>
    <br/><br/>


    <li><b>Modules with Submodules</b></li>
    <br/>
    <ul>
        <li>Create a directory matching the module name:</li>
    </ul>

<pre><code class="language-bash line-numbers">src/
‚îú‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ network/
    ‚îú‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ client.rs
</code></pre>

<pre><code class="language-rust line-numbers">// main.rs
mod network;

fn main() {
    network::client::connect();
}
</code></pre>

<pre><code class="language-rust line-numbers">// network/mod.rs
pub mod client;
</code></pre>

<pre><code class="language-rust line-numbers">// network/client.rs
pub fn connect() {
    println!("Client connected!");
}
</code></pre>
    <br/>
    <ul>
        <li>For module <code>network</code>:
            <ul>
                <li><code>network/mod.rs</code> defines the module root.</li>
                <li><code>network/client.rs</code> defines the submodule.</li>
            </ul>
        </li>
        <br/>
        <li>This pattern is the same as Go, Java, or Python package directories.</li>
    </ul>
    <br/><br/>


    <li><b>The Modern Alternative: <code>network.rs</code> + <code>network/</code> Directory</b></li>
    <br/>
    <ul>
        <li>Rust now allows ‚Äúfs-based modules‚Äù without requiring <code>mod.rs</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">src/
‚îú‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ network.rs
‚îî‚îÄ‚îÄ network/
    ‚îî‚îÄ‚îÄ client.rs
</code></pre>

<pre><code class="language-rust line-numbers">// network.rs
pub mod client;
</code></pre>

    <br/>
    <ul>
        <li>This is the recommended layout in modern Rust.</li>
    </ul>
    <br/><br/>


    <li><b>Module Visibility</b></li>
    <br/>
    <ul>
        <li>Items are private by default.</li>
        <li>Use visibility modifiers:</li>
        <ul>
            <li><code>pub</code> ‚Äî visible everywhere</li>
            <li><code>pub(crate)</code> ‚Äî entire crate</li>
            <li><code>pub(super)</code> ‚Äî parent module</li>
            <li><code>pub(in path)</code> ‚Äî specific module path</li>
        </ul>
    </ul>

<pre><code class="language-rust line-numbers">mod a {
    pub mod b {
        pub(super) fn f() {}
    }
}
</code></pre>

    <br/><br/>


    <li><b>Using Other Modules</b></li>
    <br/>
    <ul>
        <li>Use the <code>use</code> keyword to bring names into scope:</li>
    </ul>

<pre><code class="language-rust line-numbers">mod math {
    pub fn add(a: i32, b: i32) -&gt; i32 { a + b }
}

use math::add;

fn main() {
    println!("{}", add(2, 3));
}
</code></pre>

    <br/><br/>


    <li><b>Absolute Paths vs Relative Paths</b></li>
    <br/>

<pre><code class="language-rust line-numbers">crate::a::b::f();  // absolute path
super::f();        // parent module
self::g();         // current module
</code></pre>

    <br/>
    <ul>
        <li>Absolute paths start from <code>crate::</code>.</li>
        <li>Relative paths use <code>self</code> and <code>super</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Re-exporting Modules</b></li>
<pre><code class="language-rust line-numbers">mod backend {
    pub fn init() {}
}

pub use backend::init; // re-export

fn main() {
    init(); // available in root namespace
}
</code></pre>
    <br/>
    <ul>
        <li>Re-exports make APIs cleaner and easier to use.</li>
    </ul>
    <br/><br/>


    <li><b>Common File Layout Patterns in Rust Projects</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Module Structure</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>lib.rs</code></td>
                <td>Entry point for library crates</td>
            </tr>
            <tr>
                <td><code>main.rs</code></td>
                <td>Entry point for binary crates</td>
            </tr>
            <tr>
                <td><code>mod.rs</code> (legacy)</td>
                <td>Module root inside directories</td>
            </tr>
            <tr>
                <td><code>module.rs</code> + <code>module/</code></td>
                <td>Modern module + its submodules</td>
            </tr>
            <tr>
                <td><code>pub use</code></td>
                <td>Re-exporting to create clean public APIs</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-module-visibility">Visibility in Modules</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust uses a module system to organize code into namespaces.</li>
        <br/>
        <li>By default, everything is <u>private</u> inside a module unless you explicitly make it visible.</li>
        <br/>
        <li>Visibility rules control:
            <ul>
                <li>which functions, structs, enums, traits, and modules are accessible</li>
                <li>how other modules interact with your code</li>
                <li>public APIs vs internal implementation details</li>
            </ul>
        </li>
        <br/>
        <li>You change visibility with the <code>pub</code> keyword and its variants.</li>
    </ul>
    <br/><br/>


    <li><b>Default: Everything is Private</b></li>
<pre><code class="language-rust line-numbers">mod a {
    fn secret() {
        println!("hidden");
    }
}

fn main() {
    // a::secret(); // ERROR: function is private
}
</code></pre>
    <br/>
    <ul>
        <li>Items inside a module are private to that module unless marked <code>pub</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Making Items Public with pub</b></li>
<pre><code class="language-rust line-numbers">mod a {
    pub fn hello() {
        println!("Hello!");
    }
}

fn main() {
    a::hello(); // OK
}
</code></pre>
    <br/>
    <ul>
        <li><code>pub</code> makes an item visible outside the module.</li>
    </ul>
    <br/><br/>


    <li><b>Public Structs with Private Fields</b></li>
<pre><code class="language-rust line-numbers">mod user {
    pub struct User {
        pub name: String,
        age: u32, // private
    }

    impl User {
        pub fn new(name: String, age: u32) -&gt; Self {
            Self { name, age }
        }
    }
}

fn main() {
    let u = user::User::new("Alice".into(), 20);

    println!("{}", u.name);
    // println!("{}", u.age); // ERROR: age is private
}
</code></pre>
    <br/>
    <ul>
        <li>A <code>pub</code> struct does not automatically make its fields public.</li>
        <li>You control field visibility individually.</li>
    </ul>
    <br/><br/>


    <li><b>Visibility of Enums</b></li>
<pre><code class="language-rust line-numbers">mod m {
    pub enum Color {
        Red,
        Green,
        Blue,
    }
}

fn main() {
    let c = m::Color::Red; // OK
}
</code></pre>
    <br/>
    <ul>
        <li>If an enum is public, all its variants are also public.</li>
    </ul>
    <br/><br/>


    <li><b>pub(crate): Visible Within the Entire Crate</b></li>
<pre><code class="language-rust line-numbers">mod internal {
    pub(crate) fn helper() {
        println!("crate-level visibility");
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Visible everywhere in the same crate.</li>
        <li>Invisible to external crates.</li>
        <li>Useful for library internal APIs.</li>
    </ul>
    <br/><br/>


    <li><b>pub(super): Visible Only to Parent Module</b></li>
<pre><code class="language-rust line-numbers">mod a {
    mod b {
        pub(super) fn f() {
            println!("visible to parent (mod a)");
        }
    }

    pub fn call() {
        b::f(); // OK
    }
}

fn main() {}
</code></pre>
    <br/>
    <ul>
        <li><code>pub(super)</code> exposes an item to the parent module only.</li>
        <li>Siblings and outside modules cannot access it.</li>
    </ul>
    <br/><br/>


    <li><b>pub(in path): Visible Only Within a Specific Module</b></li>
<pre><code class="language-rust line-numbers">mod a {
    pub mod b {
        pub(in crate::a) fn f() {
            println!("visible only inside mod a");
        }
    }

    fn call() {
        b::f(); // OK
    }
}

fn main() {
    // a::b::f(); // ERROR
}
</code></pre>
    <br/>
    <ul>
        <li><code>pub(in path)</code> gives fine-grained control.</li>
        <li>You can expose functions to a specific module subtree.</li>
    </ul>
    <br/><br/>


    <li><b>pub(self): Visible Only Inside the Current Module</b></li>
<pre><code class="language-rust line-numbers">mod a {
    pub(self) fn f() {
        println!("only inside a");
    }
}
</code></pre>
    <br/>
    <ul>
        <li>This is identical to the default private visibility.</li>
        <li>Useful for clarity in API design.</li>
    </ul>
    <br/><br/>


    <li><b>pub(restricted) Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Keyword</th>
                <th>Visibility</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>pub</code></td>
                <td>Visible everywhere</td>
            </tr>
            <tr>
                <td><code>pub(crate)</code></td>
                <td>Visible in the current crate</td>
            </tr>
            <tr>
                <td><code>pub(super)</code></td>
                <td>Visible to parent module</td>
            </tr>
            <tr>
                <td><code>pub(in path)</code></td>
                <td>Visible in a specific module</td>
            </tr>
            <tr>
                <td><code>pub(self)</code></td>
                <td>Visible only in the current module (default)</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Re-exporting with pub use</b></li>
<pre><code class="language-rust line-numbers">mod backend {
    pub fn init() {
        println!("backend init");
    }
}

pub use backend::init; // re-export

fn main() {
    init(); // OK
}
</code></pre>
    <br/>
    <ul>
        <li><code>pub use</code> re-exports items at a different location.</li>
        <li>Useful for creating clean public APIs.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-use">The <code>use</code> Keyword in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>use</code> keyword in Rust brings names into the current scope.</li>
        <br/>
        <li>It reduces long paths and makes code cleaner.</li>
        <br/>
        <li>You can use it for:
            <ul>
                <li>Your own modules</li>
                <li>Crates and external libraries</li>
                <li>Standard library items</li>
                <li>Structs, enums, traits, and functions</li>
                <li>Selective imports and renaming</li>
                <li>Re-exports (public API design)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Basic Usage</b></li>
<pre><code class="language-rust line-numbers">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
}
</code></pre>
    <br/>
    <ul>
        <li>Without <code>use</code>, you would need:</li>
    </ul>

<pre><code class="language-rust line-numbers">let mut map = std::collections::HashMap::new();
</code></pre>

    <br/><br/>


    <li><b>Using Standard Library Items</b></li>
<pre><code class="language-rust line-numbers">use std::fs::File;
use std::io::{self, Read};

fn main() -&gt; io::Result&lt;()&gt; {
    let mut file = File::open("data.txt")?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?;
    Ok(())
}
</code></pre>
    <br/>
    <ul>
        <li><code>use std::io::{self, Read};</code> imports:
            <ul>
                <li><code>io</code> module</li>
                <li><code>Read</code> trait</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Using 3rd-Party Crates</b></li>
    <br/>
    <ul>
        <li>Declare dependencies in <code>Cargo.toml</code>:</li>
    </ul>

<pre><code class="language-toml line-numbers">[dependencies]
rand = "0.8"
serde = "1.0"
</code></pre>

<pre><code class="language-rust line-numbers">use rand::Rng;

fn main() {
    let n = rand::thread_rng().gen_range(1..=10);
    println!("Random: {}", n);
}
</code></pre>

    <br/>
    <ul>
        <li>After adding a crate in <code>Cargo.toml</code>, you use <code>use</code> to bring items into scope.</li>
    </ul>
    <br/><br/>


    <li><b>Using Your Own Modules</b></li>
<pre><code class="language-rust line-numbers">// src/math.rs
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }
</code></pre>

<pre><code class="language-rust line-numbers">// src/main.rs
mod math;
use math::add;

fn main() {
    println!("{}", add(5, 3));
}
</code></pre>

    <br/>
    <ul>
        <li><code>mod math;</code> loads <code>math.rs</code>.</li>
        <li><code>use math::add;</code> imports the function.</li>
    </ul>
    <br/><br/>


    <li><b>Using Nested Submodules</b></li>

<pre><code class="language-bash line-numbers">src/
‚îú‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ network/
    ‚îú‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ client.rs
</code></pre>

<pre><code class="language-rust line-numbers">// network/mod.rs
pub mod client;
</code></pre>

<pre><code class="language-rust line-numbers">// network/client.rs
pub fn connect() {
    println!("Connected!");
}
</code></pre>

<pre><code class="language-rust line-numbers">// main.rs
mod network;
use network::client::connect;

fn main() {
    connect();
}
</code></pre>

    <br/><br/>


    <li><b>Using Multiple Imports from the Same Module</b></li>
<pre><code class="language-rust line-numbers">use std::cmp::{min, max};
</code></pre>

    <br/>
    <ul>
        <li>Brings several items into scope in one line.</li>
    </ul>
    <br/><br/>


    <li><b>Using Everything in a Module (Glob Import)</b></li>
<pre><code class="language-rust line-numbers">use std::collections::*;
</code></pre>
    <br/>
    <ul>
        <li>Imports all items in the module.</li>
        <li>Recommended mainly for:
            <ul>
                <li>tests</li>
                <li>prelude design</li>
                <li>example code</li>
            </ul>
        </li>
        <li>Avoid overuse in production for clarity.</li>
    </ul>
    <br/><br/>


    <li><b>Renaming Imports with <code>as</code></b></li>
<pre><code class="language-rust line-numbers">use std::io::Result as IoResult;

fn example() -&gt; IoResult&lt;()&gt; {
    Ok(())
}
</code></pre>
    <br/>
    <ul>
        <li>Renaming helps avoid name conflicts.</li>
        <li>Useful for common names like <code>Result</code> and <code>Error</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Importing Traits</b> (Required for Methods!)</b></li>
<pre><code class="language-rust line-numbers">use std::io::Read;

let mut buffer = String::new();
file.read_to_string(&amp;mut buffer); // method from Read trait
</code></pre>
    <br/>
    <ul>
        <li>If a method is defined by a trait, you must <code>use</code> the trait.</li>
        <li>Otherwise Rust cannot find the method.</li>
    </ul>
    <br/><br/>


    <li><b>Importing Enums and Variants</b></li>
<pre><code class="language-rust line-numbers">use std::cmp::Ordering;

match x.cmp(&amp;y) {
    Ordering::Less =&gt; {}
    Ordering::Equal =&gt; {}
    Ordering::Greater =&gt; {}
}
</code></pre>

<pre><code class="language-rust line-numbers">use std::cmp::Ordering::{Less, Equal, Greater};

match x.cmp(&amp;y) {
    Less =&gt; {}
    Equal =&gt; {}
    Greater =&gt; {}
}
</code></pre>
    <br/>
    <ul>
        <li>You can import:
            <ul>
                <li>the enum type</li>
                <li>specific variants</li>
                <li>all variants <code>use Enum::*;</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Re-exporting (`pub use`)</b></li>
<pre><code class="language-rust line-numbers">mod utils {
    pub fn greet() { println!("hi"); }
}

pub use utils::greet;  // re-export

fn main() {
    greet(); // available at crate root
}
</code></pre>

    <br/>
    <ul>
        <li>This is how libraries design clean APIs.</li>
        <li>External users don‚Äôt need to know your internal module layout.</li>
    </ul>
    <br/><br/>


    <li><b>Self and Super Imports</b></li>
<pre><code class="language-rust line-numbers">use self::math::add;
use super::config::load_config;
</code></pre>

    <br/>
    <ul>
        <li><code>self</code> refers to the current module.</li>
        <li><code>super</code> refers to its parent.</li>
        <li>Useful for organizing complex directory structures.</li>
    </ul>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li><code>use</code> brings names into scope to reduce long paths.</li>
        <li>Use it for:
            <ul>
                <li>Standard library modules</li>
                <li>3rd-party crates</li>
                <li>Your own modules</li>
                <li>Traits, structs, enums, functions</li>
            </ul>
        </li>
        <li>Glob imports (<code>*</code>) and variant imports are also supported.</li>
        <li>Renaming with <code>as</code> helps avoid conflicts.</li>
        <li><code>pub use</code> is important for API design and re-exporting.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-crates">Crates in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>crate</u> is the fundamental compilation unit in Rust.</li>
        <br/>
        <li>A crate can be:
            <ul>
                <li>a <u>binary crate</u> ‚Äî produces an executable (contains <code>fn main()</code>)</li>
                <li>a <u>library crate</u> ‚Äî produces reusable functionality without requiring <code>main</code></li>
            </ul>
        </li>
        <br/>
        <li>All Rust programs consist of one or more crates.</li>
        <li>A crate defines a <u>root module</u> (<code>main.rs</code> or <code>lib.rs</code>) from which the module tree grows.</li>
    </ul>
    <br/><br/>


    <li><b>Binary Crates</b></li>
    <br/>
    <ul>
        <li>Binary crates compile into executable files.</li>
        <li>They must contain a <code>main()</code> function as an entry point.</li>
    </ul>

<pre><code class="language-bash line-numbers">src/
‚îî‚îÄ‚îÄ main.rs
</code></pre>

<pre><code class="language-rust line-numbers">// main.rs
fn main() {
    println!("Hello from a binary crate!");
}
</code></pre>

    <br/>
    <ul>
        <li>Running <code>cargo build</code> produces <code>target/debug/&lt;crate-name&gt;</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Library Crates</b></li>
    <br/>
    <ul>
        <li>Library crates do not have <code>main()</code>.</li>
        <li>They expose public APIs using <code>pub</code> items.</li>
    </ul>

<pre><code class="language-bash line-numbers">src/
‚îî‚îÄ‚îÄ lib.rs
</code></pre>

<pre><code class="language-rust line-numbers">// lib.rs
pub fn greet(name: &amp;str) {
    println!("Hello, {}!", name);
}
</code></pre>

    <br/>
    <ul>
        <li>Other crates can depend on this library and call <code>lib::greet()</code>.</li>
        <li>Running <code>cargo test</code> also tests <code>lib.rs</code> contents.</li>
    </ul>
    <br/><br/>


    <li><b>Project Structure: One Package, Multiple Crates</b></li>
    <br/>
    <ul>
        <li>A Cargo package (a directory with <code>Cargo.toml</code>) can contain:
            <ul>
                <li>0 or 1 library crate</li>
                <li>0 or many binary crates</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">src/
‚îú‚îÄ‚îÄ lib.rs       # library crate
‚îú‚îÄ‚îÄ main.rs      # default binary crate
‚îî‚îÄ‚îÄ bin/
    ‚îú‚îÄ‚îÄ tool1.rs # binary crate 1
    ‚îî‚îÄ‚îÄ tool2.rs # binary crate 2
</code></pre>

    <br/>
    <ul>
        <li>A single package can therefore ship multiple executables and one optional library.</li>
    </ul>
    <br/><br/>


    <li><b>The Crate Root</b></li>
    <br/>
    <ul>
        <li>The crate root is the source file that <u>defines the root of the module tree</u>.</li>
    </ul>

<pre><code class="language-bash line-numbers">src/main.rs  # crate root for binary crate
src/lib.rs   # crate root for library crate
</code></pre>

    <br/>
    <ul>
        <li>The crate root:
            <ul>
                <li>contains top-level items</li>
                <li>includes submodules using <code>mod</code></li>
                <li>defines what is exposed publicly</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Cargo.toml Defines the Crate</b></li>
<pre><code class="language-toml line-numbers">[package]
name = "my_project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = "1.0"
rand = "0.8"
</code></pre>
    <br/>
    <ul>
        <li><code>Cargo.toml</code> describes crate metadata and dependencies.</li>
        <li>Crate name inside <code>package.name</code> is used when publishing.</li>
        <li>Dependencies listed become accessible inside code through <code>use</code>.</li>
    </ul>
    <br/><br/>


    <li><b>External Crates</b></li>
<pre><code class="language-rust line-numbers">use rand::Rng;

fn main() {
    let n: u32 = rand::thread_rng().gen_range(1..=10);
    println!("{}", n);
}
</code></pre>
    <br/>
    <ul>
        <li>An external crate becomes available after you list it in <code>Cargo.toml</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Preludes and the Name `crate`</b></li>
    <br/>
    <ul>
        <li><code>crate</code> refers to the current crate root.</li>
    </ul>

<pre><code class="language-rust line-numbers">crate::utils::math::add(2, 3);
</code></pre>

    <br/>
    <ul>
        <li>This is an absolute path inside the current crate.</li>
        <li>Useful when writing libraries.</li>
    </ul>
    <br/><br/>


    <li><b>Crates.io and Publishing</b></li>
    <br/>
    <ul>
        <li>Rust‚Äôs public package registry is <u>crates.io</u>.</li>
        <li>You can publish your library crates to share them with the world.</li>
        <li>Binary crates can also be published (for distribution via <code>cargo install</code>).</li>
    </ul>

<pre><code class="language-bash line-numbers">$ cargo publish
</code></pre>

    <br/>
    <ul>
        <li>Requires an account and API token.</li>
    </ul>
    <br/><br/>


    <li><b>Building and Running Crates</b></li>
<pre><code class="language-bash line-numbers">$ cargo build         # build the crate
$ cargo build --release
$ cargo run           # binary crates only
$ cargo test          # test library + binaries
$ cargo doc --open    # generate and open crate docs
</code></pre>
    <br/>
    <ul>
        <li>All actions operate at the crate level.</li>
        <li>Documentation includes both your crate and its dependencies.</li>
    </ul>
    <br/><br/>


    <li><b>Crates vs Modules</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Level</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Crate</td>
                <td>Compilation Unit</td>
                <td>Produces a binary or library</td>
            </tr>
            <tr>
                <td>Module</td>
                <td>Namespace Unit</td>
                <td>Organizes code inside a crate</td>
            </tr>
            <tr>
                <td>Package</td>
                <td>Project Unit</td>
                <td>Contains <code>Cargo.toml</code> and zero/many crates</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-attributes">Attributes in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust attributes are metadata applied to items such as:
            <ul>
                <li>functions</li>
                <li>modules</li>
                <li>structs and enums</li>
                <li>expressions</li>
                <li>crates</li>
            </ul>
        </li>
        <br/>
        <li>They change how Rust compiles, documents, warns, tests, and structures your code.</li>
        <br/>
        <li>Attributes appear in two syntaxes:
            <ul>
                <li><code>#[attribute]</code> &nbsp; ‚Äî outer attribute</li>
                <li><code>#![attribute]</code> ‚Äî inner attribute</li>
            </ul>
        </li>
        <br/>
        <li>Inner attributes apply to the <u>containing item</u> (crate or module). At the top of the file like that, it applies to the entire crate.</li>
        <li>Outer attributes apply to the <u>following item</u>.</li>
    </ul>
    <br/><br/>


    <li><b>Outer Attributes</b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug)]
struct User {
    id: u32,
    name: String,
}
</code></pre>
    <br/>
    <ul>
        <li>Placed directly before the item they modify.</li>
    </ul>
    <br/><br/>


    <li><b>Inner Attributes</b></li>
<pre><code class="language-rust line-numbers">#![allow(unused)]
mod utils {
    fn temp() {}
}
</code></pre>
    <br/>
    <ul>
        <li>Placed inside a crate or module using <code>#![ ... ]</code>.</li>
        <li>Apply to the entire enclosing item.</li>
    </ul>
    <br/><br/>


    <li><b>Derive Attributes</b></li>
    <br/>
    <ul>
        <li><code>#[derive(...)]</code> automatically implements common traits.</li>
    </ul>

<pre><code class="language-rust line-numbers">#[derive(Debug, Clone, Copy, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}
</code></pre>
    <br/>
    <ul>
        <li>Common derive traits include:
            <ul>
                <li><code>Debug</code></li>
                <li><code>Clone</code></li>
                <li><code>Copy</code></li>
                <li><code>Eq</code>, <code>PartialEq</code></li>
                <li><code>Hash</code></li>
                <li><code>Default</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Conditional Compilation Attributes</b></li>
<pre><code class="language-rust line-numbers">#[cfg(target_os = "linux")]
fn platform_only() {
    println!("Running on Linux");
}

#[cfg(feature = "fast_mode")]
fn fast() {}
</code></pre>
    <br/>
    <ul>
        <li><code>cfg</code> controls what gets compiled depending on OS, architecture, Cargo features, etc.</li>
    </ul>

<pre><code class="language-rust line-numbers">fn main() {
    #[cfg(debug_assertions)]
    println!("Running in debug mode");
}
</code></pre>
    <br/><br/>


    <li><b>Allow, Warn, and Deny Lints</b></li>
<pre><code class="language-rust line-numbers">#[allow(dead_code)]
fn unused() {}

#[warn(missing_docs)]
fn documented() {}

#[deny(warnings)]
fn strict() {}
</code></pre>
    <br/>
    <ul>
        <li>These attributes control compiler warnings and errors.</li>
    </ul>
    <br/><br/>


    <li><b>Documentation Attributes (rustdoc)</b></li>
<pre><code class="language-rust line-numbers">#![doc = "A crate-level description"]

/// Adds two numbers.
///
/// # Example
/// ```
/// assert_eq!(3, add(1, 2));
/// ```
#[doc(alias = "plus")]
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
    <br/>
    <ul>
        <li>Used by <code>rustdoc</code> to generate documentation.</li>
        <li><code>#[doc(alias = "...")]</code> improves searchability.</li>
    </ul>
    <br/><br/>


    <li><b>Test Attributes</b></li>
<pre><code class="language-rust line-numbers">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    #[should_panic]
    fn should_fail() {
        panic!("panics as expected");
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>#[test]</code> marks test functions.</li>
        <li><code>#[should_panic]</code> marks tests expecting a panic.</li>
    </ul>
    <br/><br/>


    <li><b>Inline and Macro Attributes</b></li>
<pre><code class="language-rust line-numbers">#[inline]
fn fast_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[inline(always)]
fn really_inline(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[macro_export]
macro_rules! hello {
    () =&gt; {
        println!("Hello from macro!");
    };
}
</code></pre>
    <br/>
    <ul>
        <li><code>#[inline]</code> suggests inlining to the compiler.</li>
        <li><code>#[macro_export]</code> makes macros public from a crate.</li>
    </ul>
    <br/><br/>


    <li><b>Serde Attributes (3rd-Party Example)</b></li>
<pre><code class="language-rust line-numbers">use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct User {
    #[serde(rename = "user_id")]
    id: u32,

    #[serde(skip_serializing)]
    password: String,
}
</code></pre>
    <br/>
    <ul>
        <li>3rd-party crates (like serde) provide powerful custom attributes.</li>
        <li>They can modify serialization, deserialization, renaming, skipping, etc.</li>
    </ul>
    <br/><br/>


    <li><b>Entry Point Attribute</b></li>
<pre><code class="language-rust line-numbers">#[no_mangle]
pub extern "C" fn my_entry() {}
</code></pre>
    <br/>
    <ul>
        <li><code>#[no_mangle]</code> keeps the symbol name unchanged for FFI.</li>
    </ul>
    <br/><br/>


    <li><b>Crate-Level Attributes</b></li>
<pre><code class="language-rust line-numbers">#![allow(unused)]
#![warn(missing_docs)]
#![cfg_attr(debug_assertions, feature(explicit_generic_args_with_impl_trait))]
</code></pre>
    <br/>
    <ul>
        <li>Applied at the top of <code>main.rs</code> or <code>lib.rs</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Attribute Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Attribute</th>
                <th>Purpose</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>#[derive]</code></td>
                <td>Auto-impl common traits</td>
                <td><code>#[derive(Debug, Clone)]</code></td>
            </tr>
            <tr>
                <td><code>#[cfg]</code></td>
                <td>Conditional compilation</td>
                <td><code>#[cfg(unix)]</code></td>
            </tr>
            <tr>
                <td><code>#[allow]</code>, <code>#[warn]</code>, <code>#[deny]</code></td>
                <td>Lint control</td>
                <td><code>#[allow(dead_code)]</code></td>
            </tr>
            <tr>
                <td><code>#[test]</code></td>
                <td>Unit test functions</td>
                <td><code>#[test]</code></td>
            </tr>
            <tr>
                <td><code>#[inline]</code></td>
                <td>Suggest inline expansion</td>
                <td><code>#[inline(always)]</code></td>
            </tr>
            <tr>
                <td><code>#[doc]</code></td>
                <td>Documentation metadata</td>
                <td><code>#[doc(alias = "x")]</code></td>
            </tr>
            <tr>
                <td><code>#[macro_export]</code></td>
                <td>Expose macros publicly</td>
                <td><code>#[macro_export]</code></td>
            </tr>
            <tr>
                <td><code>#![crate_attr]</code></td>
                <td>Crate-level behavior</td>
                <td><code>#![allow(unused)]</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li>Attributes modify how Rust compiles, tests, documents, or interprets code.</li>
        <li>Outer attributes (<code>#[...]</code>) apply to the next item.</li>
        <li>Inner attributes (<code>#![...]</code>) apply to the containing module or crate.</li>
        <li>Used for:
            <ul>
                <li>trait derivation</li>
                <li>conditional compilation</li>
                <li>enabling/disabling lints</li>
                <li>tests</li>
                <li>macros</li>
                <li>FFI</li>
                <li>documentation</li>
            </ul>
        </li>
        <li>They are one of Rust‚Äôs most flexible and powerful meta-programming mechanisms.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-custom-attributes-beginner">Defining Custom Attributes in Rust (Beginner Level)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust does not allow you to freely invent new attributes ‚Äúout of nowhere.‚Äù</li>
        <br/>
        <li>Custom attributes can only be created through:
            <ul>
                <li><u>procedural macros</u> (derive macros, attribute macros, function-like macros)</li>
                <li><u>external crates</u> that expose their own attributes</li>
            </ul>
        </li>
        <br/>
        <li>This means that when you write a new attribute, you are actually writing a <u>macro</u>.</li>
        <br/>
        <li>Beginner-level rule:
            You can only define new attributes inside a library crate using <u>procedural macros</u>.
        </li>
    </ul>
    <br/><br/>


    <li><b>Three Kinds of Procedural Macros that Create Attributes</b></li>
    <br/>
    <ul>
        <li><b>Derive macro</b> (creates attributes like <code>#[derive(MyTrait)]</code>)</li>
        <li><b>Attribute macro</b> (creates attributes like <code>#[my_attribute]</code>)</li>
        <li><b>Function-like macro</b> (not an attribute, but part of procedural macros)</li>
    </ul>
    <br/>
    <ul>
        <li>At beginner level, we focus mainly on <u>derive macros</u> and <u>attribute macros</u>.</li>
    </ul>
    <br/><br/>


    <li><b>Project Setup for Custom Attributes</b></li>
    <br/>
    <ul>
        <li>To define custom attributes, you must create a crate of type <code>proc-macro</code>.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ cargo new my_macros --lib
$ cd my_macros

# Edit Cargo.toml to enable procedural macros
</code></pre>

<pre><code class="language-toml line-numbers">[lib]
proc-macro = true
</code></pre>
    <br/>
    <ul>
        <li>This declares the crate as a ‚Äúmacro crate‚Äù, allowing it to define custom attributes.</li>
    </ul>
    <br/><br/>


    <li><b>Example 1: Creating a Simple Derive Macro</b> (easiest form)</li>
<pre><code class="language-rust line-numbers">// my_macros/src/lib.rs

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro(_input: TokenStream) -&gt; TokenStream {
    // At beginner level, return nothing or simple message
    // A real macro would inspect and modify the input code.
    TokenStream::new()
}
</code></pre>

    <br/>
    <ul>
        <li>This lets you write:</li>
    </ul>

<pre><code class="language-rust line-numbers">// in another crate:

use my_macros::HelloMacro;

#[derive(HelloMacro)]
struct User;
</code></pre>

    <br/>
    <ul>
        <li>This compiles but does nothing yet ‚Äî good for beginners to test setup.</li>
    </ul>
    <br/><br/>


    <li><b>Example 2: A Very Simple Attribute Macro</b></li>
<pre><code class="language-rust line-numbers">// inside my_macros/src/lib.rs

use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn debug_message(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!("debug_message attribute was used!");
    item  // return the original item unchanged
}
</code></pre>

    <br/>
    <ul>
        <li>Now you can write:</li>
    </ul>

<pre><code class="language-rust line-numbers">// in a binary or library crate

use my_macros::debug_message;

#[debug_message]
fn greet() {
    println!("Hello!");
}
</code></pre>

    <br/>
    <ul>
        <li>This macro prints a message at compile-time when used.</li>
        <li>It does nothing to the function itself (beginner-friendly example).</li>
    </ul>
    <br/><br/>


    <li><b>Example 3: Attribute Macro That Modifies Code (Still Beginner Level)</b></li>
<pre><code class="language-rust line-numbers">// my_macros/src/lib.rs

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_attribute]
pub fn make_public(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    let mut ast = syn::parse_macro_input!(item as syn::ItemFn);
    ast.vis = syn::Visibility::Public;

    let expanded = quote! { #ast };
    expanded.into()
}
</code></pre>

    <br/>
    <ul>
        <li>Usage:</li>
    </ul>

<pre><code class="language-rust line-numbers">use my_macros::make_public;

#[make_public]
fn secret() {
    println!("This is now public!");
}
</code></pre>

    <br/>
    <ul>
        <li>This macro turns <code>fn secret()</code> into <code>pub fn secret()</code>.</li>
        <li>This is a gentle example of modifying syntax trees.</li>
    </ul>
    <br/><br/>


    <li><b>How Custom Attributes Work Internally (Beginner Explanation)</b></li>
    <br/>
    <ul>
        <li>Rust passes the item (function, struct, etc.) to your macro as a <code>TokenStream</code>, which is a sequence of tokens: identifiers, keywords, literals, braces</li>
        <br/>
        <li>Your macro:
            <ul>
                <li><u>reads</u> the input tokens</li>
                <li><u>may modify</u> them (optional)</li>
                <li><u>returns</u> new code back to the compiler</li>
            </ul>
        </li>
        <br/>
        <li>Popular crates that help:
            <ul>
                <li><code>syn</code> ‚Äî parses Rust code into a syntax tree</li>
                <li><code>quote</code> ‚Äî converts syntax tree back to tokens</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Limitations of Custom Attributes</b></li>
    <br/>
    <ul>
        <li>You cannot arbitrarily attach attributes unless they correspond to actual procedural macros.</li>
        <li>You must put custom macros in a <code>proc-macro</code> crate.</li>
        <li>Beginner-level macros often:
            <ul>
                <li>modify visibility</li>
                <li>auto-generate trivial functions</li>
                <li>add print/debug statements</li>
                <li>derive simple traits</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li>Custom attributes in Rust are created using <u>procedural macros</u>.</li>
        <li>You must use a <code>proc-macro</code> crate.</li>
        <li>Two forms of attribute macros:
            <ul>
                <li><code>#[derive(MyTrait)]</code> ‚Äî derive macros</li>
                <li><code>#[my_attribute]</code> ‚Äî attribute macros</li>
            </ul>
        </li>
        <li>They operate on Rust code represented as token streams.</li>
        <li>Beginner-level macros can modify visibility or add simple behaviors.</li>
        <li>Popular crates <code>syn</code> and <code>quote</code> make macros easier to write.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-dead-code">The <code>dead_code</code> Attribute in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust warns you when you define a function, variable, struct, or module that is <u>never used</u>.</li>
        <br/>
        <li>The compiler issues this warning under the lint named <code>dead_code</code>.</li>
        <br/>
        <li>You can suppress this warning using the attribute:
            <ul>
                <li><code>#[allow(dead_code)]</code></li>
                <li><code>#![allow(dead_code)]</code> (crate-level)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Why Does Rust Warn About Dead Code?</b></li>
    <br/>
    <ul>
        <li>Unused code may indicate mistakes:
            <ul>
                <li>a function you forgot to call</li>
                <li>an outdated variable</li>
                <li>an abandoned struct or enum</li>
            </ul>
        </li>
        <br/>
        <li>The warning encourages:
            <ul>
                <li>clean codebases</li>
                <li>smaller binaries</li>
                <li>better maintainability</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Basic Usage of <code>#[allow(dead_code)]</code></b></li>
<pre><code class="language-rust line-numbers">#[allow(dead_code)]
fn unused_function() {
    println!("This function is never called");
}
</code></pre>
    <br/>
    <ul>
        <li>This suppresses the warning for <u>only this item</u>.</li>
        <li>The function still compiles normally.</li>
    </ul>
    <br/><br/>


    <li><b>Allowing Dead Code for Structs and Enums</b></li>
<pre><code class="language-rust line-numbers">#[allow(dead_code)]
struct Config {
    debug: bool,
    retries: u32,
}

#[allow(dead_code)]
enum Status {
    Ok,
    Error,
}
</code></pre>
    <br/>
    <ul>
        <li>Useful when structs or enums are temporarily unused during refactoring.</li>
    </ul>
    <br/><br/>


    <li><b>Silencing Dead Code for an Entire Module</b></li>
<pre><code class="language-rust line-numbers">#[allow(dead_code)]
mod utils {
    fn unused_a() {}
    fn unused_b() {}
}
</code></pre>
    <br/>
    <ul>
        <li>Applies to everything within the module.</li>
        <li>Helpful during early development stages.</li>
    </ul>
    <br/><br/>


    <li><b>Crate-Level Dead Code Attribute</b></li>
<pre><code class="language-rust line-numbers">#![allow(dead_code)]

fn a() {}
fn b() {}

mod helpers {
    fn c() {}
}
</code></pre>
    <br/>
    <ul>
        <li>Placed at the top of <code>main.rs</code> or <code>lib.rs</code>.</li>
        <li>Suppresses the warning for the <b>entire crate</b>.</li>
        <li>Useful for small experiments or prototypes.</li>
    </ul>
    <br/><br/>


    <li><b>When Should You Use <code>dead_code</code>?</b></li>
    <br/>
    <ul>
        <li>‚úî During prototyping or early development</li>
        <li>‚úî When writing helper functions not yet used</li>
        <li>‚úî When preparing an API but not exporting all items yet</li>
        <li>‚úî In large modules where some code is only conditionally used</li>
        <br/>
        <li>‚úò Avoid using it to hide mistakes:
            <ul>
                <li>Forgot to call the function?</li>
                <li>Unused struct that should be removed?</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Combining with <code>cfg</code> Attributes</b></li>
    <br/>
    <ul>
        <li>Sometimes code is unused on one platform but used on another.</li>
        <li>Combine <code>cfg</code> and <code>dead_code</code> to silence correct cases.</li>
    </ul>

<pre><code class="language-rust line-numbers">#[cfg(unix)]
fn unix_only() {}

#[cfg(windows)]
#[allow(dead_code)]
fn unix_only() {}  // unused on Windows
</code></pre>
    <br/><br/>


    <li><b>Dead Code on Private Items Only</b></li>
    <br/>
    <ul>
        <li>The compiler only warns about unused:
            <ul>
                <li>private functions</li>
                <li>private structs and enums</li>
                <li>private fields</li>
            </ul>
        </li>
        <br/>
        <li>Public items <b>never</b> trigger a dead code warning because they may be used by external crates.</li>
    </ul>

<pre><code class="language-rust line-numbers">pub fn api_entry() {} // never warns
</code></pre>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-cfg">The <code>cfg</code> Attribute in Rust</h3>
<ol>
    <li><b>Introduction: What is <code>cfg</code>?</b></li>
    <br/>
    <ul>
        <li>The <code>cfg</code> attribute (<b>c</b>on<b>f</b>i<b>g</b>uration) allows conditional compilation in Rust.</li>
        <br/>
        <li>It instructs the compiler to <u>include</u> or <u>exclude</u> code depending on:
            <ul>
                <li>target operating system</li>
                <li>CPU architecture</li>
                <li>compiler flags</li>
                <li>Cargo features</li>
                <li>debug vs release mode</li>
                <li>test mode</li>
            </ul>
        </li>
        <br/>
        <li>Useful for:
            <ul>
                <li>cross-platform code</li>
                <li>feature flags</li>
                <li>debug-only tools</li>
                <li>compile-time switches</li>
                <li>conditional modules</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Two Forms: Attribute</b> <code>#[cfg]</code> <b>and Conditional Block</b> <code>cfg!</code></li>
    <br/>
    <ul>
        <li><code>#[cfg(...)]</code> ‚Äî compile-time inclusion/exclusion of items.</li>
        <li><code>cfg!(...)</code> ‚Äî returns <code>true</code>/<code>false</code> at runtime (but decided at compile time).</li>
    </ul>

<pre><code class="language-rust line-numbers">#[cfg(unix)]
fn platform() { println!("running on unix"); }

#[cfg(windows)]
fn platform() { println!("running on windows"); }

fn main() {
    platform();
}
</code></pre>
    <br/><br/>


    <li><b>OS-Based Conditions</b></li>
<pre><code class="language-rust line-numbers">#[cfg(target_os = "linux")]
fn only_linux() {
    println!("This runs on Linux");
}

#[cfg(target_os = "windows")]
fn only_windows() {
    println!("This runs on Windows");
}
</code></pre>

    <br/>
    <ul>
        <li>Common OS targets:
            <ul>
                <li><code>linux</code></li>
                <li><code>windows</code></li>
                <li><code>macos</code></li>
                <li><code>ios</code></li>
                <li><code>android</code></li>
                <li><code>freebsd</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Architecture Conditions</b></li>
<pre><code class="language-rust line-numbers">#[cfg(target_arch = "x86_64")]
fn arch_fn() { println!("x86_64 CPU"); }

#[cfg(target_arch = "aarch64")]
fn arch_fn() { println!("ARM64 CPU"); }
</code></pre>
    <br/>
    <ul>
        <li>Common architectures:
            <ul>
                <li><code>x86</code>, <code>x86_64</code></li>
                <li><code>aarch64</code></li>
                <li><code>wasm32</code></li>
                <li><code>mips</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Debug vs Release Mode</b></li>
<pre><code class="language-rust line-numbers">#[cfg(debug_assertions)]
fn debug_mode() {
    println!("Compiled in debug mode");
}

#[cfg(not(debug_assertions))]
fn debug_mode() {
    println!("Compiled in release mode");
}
</code></pre>
    <br/>
    <ul>
        <li><code>debug_assertions</code> is <code>true</code> for <code>cargo build</code> but <code>false</code> for <code>cargo build --release</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Using Cargo Features</b></li>
    <br/>
    <ul>
        <li>Define features in <code>Cargo.toml</code>:</li>
    </ul>

<pre><code class="language-toml line-numbers">[features]
fast = []
gui = []
</code></pre>

<pre><code class="language-rust line-numbers">#[cfg(feature = "fast")]
fn run() {
    println!("Fast mode enabled");
}

#[cfg(not(feature = "fast"))]
fn run() {
    println!("Normal mode");
}
</code></pre>

    <br/>
    <ul>
        <li>Activate with:</li>
    </ul>

<pre><code class="language-bash line-numbers">$ cargo run --features fast
</code></pre>
    <br/><br/>


    <li><b>Combining Conditions</b></li>
    <br/>
    <ul>
        <li>You can use <code>any</code>, <code>all</code>, and <code>not</code>.</li>
    </ul>

<pre><code class="language-rust line-numbers">#[cfg(all(unix, target_arch = "x86_64"))]
fn example() { println!("Unix + x86_64"); }

#[cfg(any(windows, target_os = "macos"))]
fn example() { println!("Windows OR macOS"); }

#[cfg(not(debug_assertions))]
fn example() { println!("Not debug"); }
</code></pre>
    <br/><br/>


    <li><b>Conditional Modules</b></li>
<pre><code class="language-rust line-numbers">#[cfg(feature = "gui")]
mod gui;

#[cfg(feature = "cli")]
mod cli;
</code></pre>

    <br/>
    <ul>
        <li>Only the selected module is compiled.</li>
    </ul>
    <br/><br/>


    <li><b>Conditional Blocks Using <code>cfg!</code></b></li>
    <br/>
    <ul>
        <li><code>cfg!</code> does not remove code from compilation.</li>
        <li>It simply evaluates to <code>true</code> or <code>false</code>.</li>
    </ul>

<pre><code class="language-rust line-numbers">fn main() {
    if cfg!(windows) {
        println!("This binary was compiled for Windows");
    }

    if cfg!(target_arch = "aarch64") {
        println!("Compiled for ARM64");
    }
}
</code></pre>

    <br/><br/>


    <li><b>Conditional Use Statements</b></li>
<pre><code class="language-rust line-numbers">#[cfg(windows)]
use winapi::um::winuser::MessageBoxA;

#[cfg(unix)]
use libc::printf;
</code></pre>

    <br/>
    <ul>
        <li>Useful for selecting platform-specific libraries.</li>
    </ul>
    <br/><br/>


    <li><b>Conditional Struct Fields</b></li>
<pre><code class="language-rust line-numbers">struct Config {
    #[cfg(feature = "gui")]
    window_size: u32,

    #[cfg(feature = "cli")]
    terminal_colors: u8,
}
</code></pre>

    <br/>
    <ul>
        <li>Only included when the feature is active.</li>
    </ul>
    <br/><br/>


    <li><b>Conditional Functions Inside Modules</b></li>
<pre><code class="language-rust line-numbers">mod util {
    #[cfg(feature = "fast")]
    pub fn compute() { println!("fast compute"); }

    #[cfg(not(feature = "fast"))]
    pub fn compute() { println!("normal compute"); }
}
</code></pre>
    <br/><br/>


    <li><b>Common <code>cfg</code> Targets Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Condition</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>target_os</code></td>
                <td><code>#[cfg(target_os = "linux")]</code></td>
                <td>OS-specific code</td>
            </tr>
            <tr>
                <td><code>target_arch</code></td>
                <td><code>#[cfg(target_arch = "x86_64")]</code></td>
                <td>CPU architecture</td>
            </tr>
            <tr>
                <td><code>debug_assertions</code></td>
                <td><code>#[cfg(debug_assertions)]</code></td>
                <td>Debug mode</td>
            </tr>
            <tr>
                <td><code>feature</code></td>
                <td><code>#[cfg(feature = "fast")]</code></td>
                <td>Cargo feature flags</td>
            </tr>
            <tr>
                <td><code>unix</code>, <code>windows</code></td>
                <td><code>#[cfg(unix)]</code></td>
                <td>Platform families</td>
            </tr>
            <tr>
                <td><code>test</code></td>
                <td><code>#[cfg(test)]</code></td>
                <td>Unit test code only</td>
            </tr>
            <tr>
                <td><code>not</code>, <code>all</code>, <code>any</code></td>
                <td><code>#[cfg(not(windows))]</code></td>
                <td>Condition combinators</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li><code>cfg</code> enables compile-time conditional code.</li>
        <li>Main use cases:
            <ul>
                <li>OS-dependent behavior</li>
                <li>Architecture-dependent logic</li>
                <li>Feature flags</li>
                <li>Debug vs release differences</li>
                <li>Test-only modules</li>
            </ul>
        </li>
        <li><code>#[cfg(...)]</code> removes code entirely when condition is false.</li>
        <li><code>cfg!(...)</code> evaluates to <code>true</code>/<code>false</code> but still compiles both branches.</li>
        <li>Flexible combinations via <code>any</code>, <code>all</code>, <code>not</code>.</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
