<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Rust</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    body {
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Rust</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-cargo-create-project">Create Project with Cargo</h3>
<ol>
    <li><b>What Is Cargo?</b></li>
    <br/>
    <ul>
        <li><code>Cargo</code> is Rust's official build and package manager, similar to <code>npm</code> (JS), <code>pip</code> (Python), or <code>maven</code> (Java).</li>
        <br/>
        <li>It helps you:
            <ul>
                <li>create new projects</li>
                <li>build and run your code</li>
                <li>manage dependencies (crates)</li>
                <li>run tests, benchmarks, and more</li>
            </ul>
        </li>
        <br/>
        <li>You'll use Cargo for almost every non-trivial Rust project.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Check If Cargo Is Installed</b></li>
<pre><code class="language-bash line-numbers">$ cargo --version
cargo 1.80.0 (or similar)
</code></pre>
    <br/>
    <ul>
        <li>If Cargo is not found, install Rust using <code>rustup</code> from the official Rust website.</li>
        <br/>
        <li><code>rustup</code> will install:
            <ul>
                <li><code>rustc</code> ‚Äî the Rust compiler</li>
                <li><code>cargo</code> ‚Äî the package manager</li>
                <li><code>rustdoc</code> ‚Äî documentation tool</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Create a New Binary Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo new hello-rust
     Created binary (application) `hello-rust` package
</code></pre>
    <br/>
    <ul>
        <li>This creates a new directory <code>hello-rust/</code> containing a ready-to-build Rust project.</li>
        <br/>
        <li><code>cargo new &lt;name&gt;</code> by default creates a <u>binary crate</u> (an executable program).</li>
        <br/>
        <li>Move into the project directory:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ cd hello-rust
</code></pre>
    <br/>
    <br/>


    <li><b>Project Layout (Created by Cargo)</b></li>
<pre><code class="language-bash line-numbers">hello-rust/
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
    <br/>
    <ul>
        <li><code>Cargo.toml</code> ‚Äî project metadata and dependencies (TOML format).</li>
        <li><code>src/main.rs</code> ‚Äî entry point of the binary crate (contains <code>fn main()</code>).</li>
        <br/>
        <li>This is the minimal standard layout that Cargo expects.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inspecting <code>src/main.rs</code></b></li>
<pre><code class="language-rust line-numbers">fn main() {
    println!("Hello, world!");
}
</code></pre>
    <br/>
    <ul>
        <li>This is the default "Hello, world!" program generated by Cargo.</li>
        <br/>
        <li><code>fn main()</code> is the entry point; the program starts executing here.</li>
        <br/>
        <li>You can change the message or add more logic as needed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inspecting <code>Cargo.toml</code></b></li>
<pre><code class="language-toml line-numbers">[package]
name = "hello-rust"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
    <br/>
    <ul>
        <li><code>[package]</code> section:
            <ul>
                <li><code>name</code> ‚Äî crate name (used on crates.io if published).</li>
                <li><code>version</code> ‚Äî semantic version of your crate.</li>
                <li><code>edition</code> ‚Äî Rust edition (e.g. 2018, 2021).</li>
            </ul>
        </li>
        <br/>
        <li><code>[dependencies]</code> ‚Äî list of external crates your project uses (initially empty).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Build the Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo build
   Compiling hello-rust v0.1.0 (path/to/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
    <br/>
    <ul>
        <li>By default, Cargo builds in <u>debug mode</u> (fast compile, slower runtime).</li>
        <br/>
        <li>Build artifacts are placed under <code>target/debug/</code>:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ ls target/debug
hello-rust   # executable
</code></pre>
    <br/>
    <br/>


    <li><b>Run the Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo run
   Compiling hello-rust v0.1.0 (path/to/hello-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target/debug/hello-rust`
Hello, world!
</code></pre>
    <br/>
    <ul>
        <li><code>cargo run</code> = <code>cargo build</code> + run the resulting binary.</li>
        <br/>
        <li>If nothing changed since last build, Cargo skips recompiling and just runs the existing executable.</li>
        <br/>
        <li>You can pass arguments after <code>--</code>:</li>
    </ul>
<pre><code class="language-bash line-numbers">$ cargo run -- --help
</code></pre>
    <br/>
    <br/>


    <li><b>Create a Library Project</b></li>
<pre><code class="language-bash line-numbers">$ cargo new my-lib --lib
     Created library `my-lib` package
</code></pre>
    <br/>
    <ul>
        <li><code>--lib</code> creates a <u>library crate</u> instead of a binary.</li>
        <br/>
        <li>Layout is slightly different:</li>
    </ul>
<pre><code class="language-bash line-numbers">my-lib/
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
    <br/>
    <ul>
        <li><code>src/lib.rs</code> is the library entry file, defining public functions, types, etc., that other crates can use.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Use <code>cargo init</code> in an Existing Directory</b></li>
<pre><code class="language-bash line-numbers">$ mkdir existing-project
$ cd existing-project
$ cargo init
     Created binary (application) `existing-project` package
</code></pre>
    <br/>
    <ul>
        <li><code>cargo init</code> turns the <u>current directory</u> into a Cargo project.</li>
        <br/>
        <li>Useful when you already have files and want to add Cargo support later.</li>
        <br/>
        <li>Use <code>cargo init --lib</code> to create a library crate instead.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Debug vs Release Builds</b></li>
<pre><code class="language-bash line-numbers"># Debug build (default)
$ cargo build

# Release build (optimized, slower compile)
$ cargo build --release
</code></pre>
    <br/>
    <ul>
        <li>Debug artifacts: <code>target/debug/...</code></li>
        <li>Release artifacts: <code>target/release/...</code></li>
        <br/>
        <li>Use <code>--release</code> when you care about <u>performance</u> (benchmarks, production builds).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Add Dependencies to Your Project</b></li>
<pre><code class="language-toml line-numbers">[dependencies]
rand = "0.8"
</code></pre>
    <br/>
    <ul>
        <li>Add crates under <code>[dependencies]</code> in <code>Cargo.toml</code>.</li>
        <br/>
        <li>Then use them in your code:</li>
    </ul>
<pre><code class="language-rust line-numbers">use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    let n: u8 = rng.gen_range(0..=9);
    println!("Random number: {n}");
}
</code></pre>
    <br/>
    <ul>
        <li>On next <code>cargo build</code> or <code>cargo run</code>, Cargo will:
            <ul>
                <li>download <code>rand</code> and its dependencies</li>
                <li>compile them and your project</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Cargo Commands for a New Project</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>cargo new &lt;name&gt;</code></td>
                <td>Create a new project directory with Cargo files</td>
            </tr>
            <tr>
                <td><code>cargo init</code></td>
                <td>Initialize Cargo in the current directory</td>
            </tr>
            <tr>
                <td><code>cargo build</code></td>
                <td>Compile the project (debug mode)</td>
            </tr>
            <tr>
                <td><code>cargo run</code></td>
                <td>Build and run the binary</td>
            </tr>
            <tr>
                <td><code>cargo check</code></td>
                <td>Type-check without producing binaries (faster feedback)</td>
            </tr>
            <tr>
                <td><code>cargo test</code></td>
                <td>Run tests (if any exist in <code>tests/</code> or <code>src</code>)</td>
            </tr>
            <tr>
                <td><code>cargo clean</code></td>
                <td>Remove the <code>target/</code> directory</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>For everyday development, you'll mostly use: <code>cargo run</code>, <code>cargo check</code>, and <code>cargo test</code>.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-comments">Comments in Rust</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust supports several kinds of comments, each serving a different purpose:</li>
        <br/>
        <ul>
            <li><b>Line comments</b> ‚Äî for normal explanations</li>
            <li><b>Block comments</b> ‚Äî for multi-line notes or temporarily disabling code</li>
            <li><b>Documentation comments</b> ‚Äî generate HTML docs and appear in <code>rustdoc</code></li>
        </ul>
        <br/>
        <li>Comments are ignored by the compiler (except documentation comments, which are processed by <code>rustdoc</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Line Comments (<code>//</code>)</b></li>
<pre><code class="language-rust line-numbers">// This is a single-line comment
let x = 10; // you can also put comments at the end of a line
</code></pre>
    <br/>
    <ul>
        <li>Starts with <code>//</code> and continues until the end of the line.</li>
        <li>Most common form of comments in Rust.</li>
        <li>Great for explaining logic or adding short descriptions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Block Comments (<code>/* ... */</code>)</b></li>
<pre><code class="language-rust line-numbers">/*
   This is a block comment.
   It can span multiple lines.
*/
let x = 5;
</code></pre>
    <br/>
    <ul>
        <li>Useful for larger explanations or temporarily disabling code.</li>
        <li>Can contain nested block comments ‚Äî Rust supports nesting!</li>
    </ul>

<pre><code class="language-rust line-numbers">/*
    Outer comment
    /*
        Nested comment ‚Äî valid!
    */
*/
</code></pre>

    <br/>
    <ul>
        <li>This makes large-scale commenting-out safer compared to languages like C/C++.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Documentation Comments (<code>///</code> and <code>//! </code>)</b></li>
    <br/>
    <ul>
        <li>Rust has two styles of documentation comments:</li>
        <ul>
            <li><b><code>///</code></b> ‚Äî for documenting items <u>that follow</u>.</li>
            <li><b><code>//! </code></b> ‚Äî for documenting containers (crate/module) <u>from within</u>.</li>
        </ul>
        <br/>
        <li>They support Markdown formatting and are used by <code>rustdoc</code> to generate HTML documentation.</li>
    </ul>
    <br/>

    <li><b>Documentation for Functions (<code>///</code>)</b></li>
<pre><code class="language-rust line-numbers">/// Adds two numbers together.
///
/// # Examples
/// ```
/// let sum = add(2, 3);
/// assert_eq!(sum, 5);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
    <br/>
    <ul>
        <li>Supports Markdown sections like:</li>
        <ul>
            <li><code># Examples</code></li>
            <li><code># Panics</code></li>
            <li><code># Safety</code></li>
            <li><code># Errors</code></li>
        </ul>
        <br/>
        <li>The examples are actually <u>compiled and tested</u> when running <code>cargo test</code>!</li>
    </ul>
    <br/>
    <br/>

    <li><b>Documentation for Modules or Crates (<code>//! </code>)</b></li>
<pre><code class="language-rust line-numbers">//! This is documentation for the entire module or crate.
//! It describes the purpose and structure at a high level.

//! You typically put this at the top of `lib.rs` or inside a module.
</code></pre>
    <br/>
    <ul>
        <li><code>//! </code> comments apply to the <u>enclosing item</u> (crate or module).</li>
        <li>Ideal for explaining architecture or high-level concepts.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inner vs Outer Documentation Comments</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Kind</th>
                <th>Syntax</th>
                <th>Applies To</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Outer doc</td>
                <td><code>///</code></td>
                <td>Item that follows</td>
            </tr>
            <tr>
                <td>Inner doc</td>
                <td><code>//! </code></td>
                <td>Enclosing module or crate</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Doc Comments Support Markdown</b></li>
<pre><code class="language-rust line-numbers">/// # Title
/// - Bullet point
/// - Another
///
/// `inline code`
///
/// ```rust
/// let x = 5;
/// println!("{}", x);
/// ```
fn demo() {}
</code></pre>
    <br/>
    <ul>
        <li>This Markdown is rendered into HTML when running <code>cargo doc</code>.</li>
        <li>You can use bold, italic, links, headings, code blocks, and tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generate Docs and Open Them</b></li>
<pre><code class="language-bash line-numbers">$ cargo doc --open
</code></pre>
    <br/>
    <ul>
        <li>Builds documentation using <code>rustdoc</code> and opens it in your browser.</li>
        <li>Includes documentation for your dependencies too.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Temporary Disabling Code with Block Comments</b></li>
<pre><code class="language-rust line-numbers">/*
fn calculate() {
    // temporarily disabled
}
*/
</code></pre>
    <br/>
    <ul>
        <li>Because Rust supports nested block comments, disabling large sections is safe:</li>
    </ul>
<pre><code class="language-rust line-numbers">/*
fn a() {}

/*
fn b() {}
*/

fn c() {}
*/
</code></pre>
    <br/>
    <ul>
        <li>Unlike C/C++, nested comments won't break the code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing the Right Comment Style</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use Case</th>
                <th>Style</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Explain a line of code</td>
                <td><code>//</code></td>
                <td><code>// explanation</code></td>
            </tr>
            <tr>
                <td>Explain a block or disable code</td>
                <td><code>/* ... */</code></td>
                <td><code>/* long comment */</code></td>
            </tr>
            <tr>
                <td>Document a function/struct/enum</td>
                <td><code>///</code></td>
                <td><code>/// Adds two numbers</code></td>
            </tr>
            <tr>
                <td>Document a module/crate</td>
                <td><code>//! </code></td>
                <td><code>//! Top-level docs</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-formatted-print">Formatted Print</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Rust provides a powerful and type-safe formatting system through <code>println!</code>, <code>print!</code>, <code>format!</code>, and related macros.</li>
        <br/>
        <li>The formatting engine is part of the <code>std::fmt</code> module and uses <u>traits</u> like <code>Display</code> and <code>Debug</code> to render values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Printing</b></li>
<pre><code class="language-rust line-numbers">fn main() {
    println!("Hello, world!");
    print!("No newline here");
}
</code></pre>
    <br/>
    <ul>
        <li><code>println!</code> appends a newline, <code>print!</code> does not.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing with Placeholder <code>{}</code></b></li>
<pre><code class="language-rust line-numbers">fn main() {
    let name = "Alice";
    let age = 30;

    println!("Name: {}, Age: {}", name, age);
}
</code></pre>
    <br/>
    <ul>
        <li><code>{}</code> is a placeholder for values implementing the <code>Display</code> trait.</li>
        <li>Strings, numbers, chars, and many built-in types support <code>Display</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Debug Formatting (<code>{:?}</code>)</b></li>
<pre><code class="language-rust line-numbers">#[derive(Debug)]
struct User {
    id: u32,
    name: String,
}

fn main() {
    let u = User { id: 1, name: "Alice".into() };
    println!("{:?}", u);
}
</code></pre>
    <br/>
    <ul>
        <li><code>{:?}</code> requires the <code>Debug</code> trait.</li>
        <li>Use <code>{:#?}</code> for pretty-printed (multi-line) debug output.</li>
    </ul>
<pre><code class="language-rust line-numbers">println!("{:#?}", u);  // pretty debug
</code></pre>
    <br/>
    <br/>


    <li><b>Named Arguments</b></li>
<pre><code class="language-rust line-numbers">println!("x = {x}, y = {y}", x = 5, y = 10);
</code></pre>
    <br/>
    <ul>
        <li>Named arguments improve clarity in complex prints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Positional Arguments</b></li>
<pre><code class="language-rust line-numbers">println!("{0} + {0} = {1}", 5, 10);
</code></pre>
    <br/>
    <ul>
        <li>Use numeric indices to reuse arguments.</li>
        <li><code>{0}</code> refers to the first argument, <code>{1}</code> to the second.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting Numbers</b></li>
<pre><code class="language-rust line-numbers">println!("{:b}", 10);   // binary
println!("{:o}", 10);   // octal
println!("{:x}", 255);  // hex (lower)
println!("{:X}", 255);  // hex (upper)
println!("{:e}", 10.5); // scientific
</code></pre>
    <br/>
    <ul>
        <li>Format specifiers after a colon (<code>:</code>) control number formatting.</li>
        <li>Supported types depend on the <code>Display</code> or <code>Debug</code> implementation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Padding and Alignment</b></li>
<pre><code class="language-rust line-numbers">println!("{:&gt;10}", 42);   // right-align
println!("{:&lt;10}", 42);   // left-align
println!("{:^10}", 42);   // center-align
</code></pre>
    <br/>
    <ul>
        <li>Numbers specify the width of the formatted field.</li>
        <li>Alignment is controlled before the width:
            <ul>
                <li><code>&lt;</code> left-align</li>
                <li><code>&gt;</code> right-align</li>
                <li><code>^</code> center</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Custom Fill Characters</b></li>
<pre><code class="language-rust line-numbers">println!("{:*^10}", "hi");   // ****hi****
println!("{:-&lt;10}", "rust"); // rust------
</code></pre>
    <br/>
    <ul>
        <li>The first character before the alignment specifier becomes the fill.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Floating-Point Precision</b></li>
<pre><code class="language-rust line-numbers">println!("{:.2}", 3.14159);   // 3.14
println!("{:8.3}", 3.14159);  // '   3.142' (width + precision)
</code></pre>
    <br/>
    <ul>
        <li><code>.2</code> means 2 digits after the decimal.</li>
        <li>You can combine precision with width.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Format Strings with <code>format!</code></b></li>
<pre><code class="language-rust line-numbers">let msg = format!("Hello, {}", "world");
println!("{}", msg);
</code></pre>
    <br/>
    <ul>
        <li><code>format!</code> works like <code>println!</code> but returns a <code>String</code> instead of printing.</li>
        <li>Useful for building messages, logs, or UI output.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing to stderr (<code>eprintln!</code>)</b></li>
<pre><code class="language-rust line-numbers">eprintln!("This is an error message.");
</code></pre>
    <br/>
    <ul>
        <li><code>eprintln!</code> prints to standard error instead of stdout.</li>
        <li>Important for error reporting when stdout is used for program output.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Implementing <code>Display</code> for Custom Types</b></li>
<pre><code class="language-rust line-numbers">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 3, y: 4 };
    println!("{}", p);
}
</code></pre>
    <br/>
    <ul>
        <li>Implement <code>Display</code> when you want clean, user-friendly printing.</li>
        <li><code>Debug</code> (<code>{:?}</code>) is for debugging ‚Äî <code>Display</code> (<code>{}</code>) is for end-users.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Escape Sequences</b></li>
<pre><code class="language-rust line-numbers">println!("Line 1\nLine 2");
println!("Tab\tSeparated");
println!("Quote: \"text\"");
println!("Backslash: \\");
</code></pre>
    <br/>
    <ul>
        <li>Rust supports common escape sequences from C-like languages.</li>
        <li>Newlines, tabs, quotes, and backslashes must be escaped.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Raw Strings (No Escaping)</b></li>
<pre><code class="language-rust line-numbers">println!(r"Path: C:\Users\Alice\Documents");
println!(r#"He said, "Hello!""#);
println!(r##"Multiple # signs can be used"##);
</code></pre>
    <br/>
    <ul>
        <li>Raw strings start with <code>r"..."</code> or <code>r#"..."#</code>.</li>
        <li>Add more <code>#</code> signs when your string contains both quotes and <code>#</code> characters.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Format Specifier Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Specifier</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>{}</code></td>
                <td>Display</td>
                <td><code>"{}"</code></td>
            </tr>
            <tr>
                <td><code>{:?}</code></td>
                <td>Debug</td>
                <td><code>"{:?}"</code></td>
            </tr>
            <tr>
                <td><code>{:#?}</code></td>
                <td>Pretty Debug</td>
                <td><code>"{:#?}"</code></td>
            </tr>
            <tr>
                <td><code>{:b}</code></td>
                <td>Binary</td>
                <td><code>10 ‚Üí 1010</code></td>
            </tr>
            <tr>
                <td><code>{:x}</code></td>
                <td>Hex (lowercase)</td>
                <td><code>255 ‚Üí ff</code></td>
            </tr>
            <tr>
                <td><code>{:X}</code></td>
                <td>Hex (uppercase)</td>
                <td><code>255 ‚Üí FF</code></td>
            </tr>
            <tr>
                <td><code>{:o}</code></td>
                <td>Octal</td>
                <td><code>10 ‚Üí 12</code></td>
            </tr>
            <tr>
                <td><code>{:.N}</code></td>
                <td>Floating precision</td>
                <td><code>3.14</code></td>
            </tr>
            <tr>
                <td><code>{:width}</code></td>
                <td>Minimum field width</td>
                <td><code>"{:5}"</code></td>
            </tr>
            <tr>
                <td><code>{:&lt;}</code></td>
                <td>Left align</td>
                <td><code>"{:&lt;10}"</code></td>
            </tr>
            <tr>
                <td><code>{:&gt;}</code></td>
                <td>Right align</td>
                <td><code>"{:&gt;10}"</code></td>
            </tr>
            <tr>
                <td><code>{:^}</code></td>
                <td>Center align</td>
                <td><code>"{:^10}"</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Formatted output in Rust is powerful, flexible, and entirely type-checked at compile time.</li>
        <li>Understanding <code>{}</code>, <code>{:?}</code>, and format specifiers unlocks rich console logging and string formatting.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rust-primitives">Primitives in Rust</h3>
<ol>
    <li>Rust provides a set of <b>primitive types</b> (built-in types) that form the foundation of all Rust programs.</li>
    <br/>
    <li>Primitives are:
        <ul>
            <li><u>Copy</u> by default (except types containing heap allocations)</li>
            <li>Fast and efficient</li>
        </ul>
    </li>
    <br/>
    <li>Primitive categories include:
        <ul>
            <li>Scalar types</li>
            <li>Compound types</li>
            <li>Special types</li>
        </ul>
    </li>
    <br/>
    <br/>


    <li><b>Integer Types</b></li>
<pre><code class="language-rust line-numbers">let a: i32 = 10;    // signed 32-bit integer
let b: u64 = 20;    // unsigned 64-bit integer
let c = 100usize;   // machine pointer-sized unsigned integer
</code></pre>
    <br/>
    <ul>
        <li>Integer sizes:</li>
        <ul>
            <li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></li>
            <li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></li>
        </ul>
        <br/>
        <li><code>isize</code> and <code>usize</code> depend on platform pointer width (32-bit or 64-bit).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Number Literals</b></li>
<pre><code class="language-rust line-numbers">let dec = 98_222;
let hex = 0xff;
let oct = 0o77;
let bin = 0b1111_0000;
let byte = b'A'; // u8 only
</code></pre>
    <br/>
    <ul>
        <li>Underscores improve readability (<code>98_222</code>).</li>
        <li><code>b'A'</code> is a byte literal (<code>u8</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Floating-Point Types</b></li>
<pre><code class="language-rust line-numbers">let x = 3.14f32;    // 32-bit float
let y: f64 = 2.718; // 64-bit float (default)
</code></pre>
    <br/>
    <ul>
        <li>Floats use IEEE-754 format.</li>
        <li><code>f64</code> is the default because it is more precise.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean</b></li>
<pre><code class="language-rust line-numbers">let is_active: bool = true;
let is_valid = false;
</code></pre>
    <br/>
    <ul>
        <li>Boolean values: <code>true</code>, <code>false</code>.</li>
        <li>Used in conditions (<code>if</code>, <code>while</code>, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Character (Unicode Scalar Value)</b></li>
<pre><code class="language-rust line-numbers">let a = 'A';
let heart = '‚ù§';
let chinese = '‰∏≠';
let emoji = 'üöÄ';
</code></pre>
    <br/>
    <ul>
        <li><code>char</code> is <u>4 bytes</u> and stores a Unicode scalar value.</li>
        <li>Supports emoji and all languages.</li>
        <li>Not a byte ‚Äî that is <code>u8</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Tuples</b></li>
<pre><code class="language-rust line-numbers">let tup: (i32, f64, bool) = (10, 3.14, true);

let (x, y, z) = tup;  // destructuring

println!("y = {}", tup.1);
</code></pre>
    <br/>
    <ul>
        <li>Tuples group values of different types.</li>
        <li>Access with dot syntax (<code>tup.1</code>).</li>
        <li>Useful for returning multiple values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Arrays</b></li>
<pre><code class="language-rust line-numbers">let nums: [i32; 3] = [1, 2, 3];
let zeros = [0; 5]; // [0, 0, 0, 0, 0]
</code></pre>
    <br/>
    <ul>
        <li>Arrays have:
            <ul>
                <li>elements of the same type</li>
                <li>fixed length</li>
            </ul>
        </li>
        <br/>
        <li>Length is part of the type (<code>[i32; 3]</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Slices</b></li>
<pre><code class="language-rust line-numbers">let arr = [1, 2, 3, 4];
let slice: &amp;[i32] = &amp;arr[1..3];  // [2, 3]
</code></pre>
    <br/>
    <ul>
        <li>Slices are <u>references</u> to contiguous sequences.</li>
        <li><code>&amp;arr[..]</code> = slice of whole array.</li>
        <li>Slices do not own data, they borrow.</li>
    </ul>
    <br/>
    <br/>


    <li><b>String Slices</b></li>
<pre><code class="language-rust line-numbers">let s: &amp;str = "Hello";      // string slice
let part = &amp;s[0..2];        // slice bytes, careful with UTF-8
</code></pre>
    <br/>
    <ul>
        <li><code>&amp;str</code> is an immutable UTF-8 string slice.</li>
        <li>Remember Rust strings are UTF-8 ‚Äî slicing must align with char boundaries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Owned String (<code>String</code>)</b></li>
<pre><code class="language-rust line-numbers">let mut s = String::from("Hello");
s.push_str(" World");
</code></pre>
    <br/>
    <ul>
        <li><code>String</code> owns the heap-allocated text.</li>
        <li>Growable and mutable.</li>
        <li>Frequently used in application code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Special Primitive: Unit (<code>()</code>)</b></li>
<pre><code class="language-rust line-numbers">fn do_something() {
    // returns () implicitly
}
</code></pre>
    <br/>
    <ul>
        <li><code>()</code> is a type with exactly one value: <code>()</code>.</li>
        <li>Used as the default return type for functions that return nothing.</li>
        <li>Similar to <code>void</code> in other languages but still a real type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Special Primitive: Never (<code>!</code>)</b></li>
<pre><code class="language-rust line-numbers">fn fail() -&gt; ! {
    panic!("Something went wrong");
}
</code></pre>
    <br/>
    <ul>
        <li><code>!</code> represents computations that never return.</li>
        <li>Examples:
            <ul>
                <li><code>panic!</code></li>
                <li>infinite loops</li>
                <li>functions that always <code>return Err</code> or <code>exit</code></li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Primitive Type Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Integer</td>
                <td><code>i*, u*</code></td>
                <td>Signed/unsigned integers</td>
            </tr>
            <tr>
                <td>Float</td>
                <td><code>f32, f64</code></td>
                <td>Floating-point numbers</td>
            </tr>
            <tr>
                <td>Boolean</td>
                <td><code>bool</code></td>
                <td><code>true</code>, <code>false</code></td>
            </tr>
            <tr>
                <td>Character</td>
                <td><code>char</code></td>
                <td>Unicode scalar value</td>
            </tr>
            <tr>
                <td>Tuple</td>
                <td><code>(T1, T2, ...)</code></td>
                <td>Fixed-size heterogeneous values</td>
            </tr>
            <tr>
                <td>Array</td>
                <td><code>[T; N]</code></td>
                <td>Fixed-size homogeneous values</td>
            </tr>
            <tr>
                <td>Slice</td>
                <td><code>&amp;[T]</code></td>
                <td>View into contiguous memory</td>
            </tr>
            <tr>
                <td>String Slice</td>
                <td><code>&amp;str</code></td>
                <td>UTF-8 string reference</td>
            </tr>
            <tr>
                <td>Owned String</td>
                <td><code>String</code></td>
                <td>Growable heap string</td>
            </tr>
            <tr>
                <td>Unit</td>
                <td><code>()</code></td>
                <td>No meaningful value</td>
            </tr>
            <tr>
                <td>Never</td>
                <td><code>!</code></td>
                <td>Function never returns</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>These primitives form the basis of all memory, data, and control flow in Rust programs.</li>
        <li>Understanding them is essential for mastering ownership, lifetime rules, and type safety.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
