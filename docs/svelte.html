<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .325rem;
        padding: .05rem .25rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.725rem;
        line-height: 1.7;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.825rem;
        line-height: 1.4;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/svelte.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#svelte-introduction">Introduction</a></li>
        <li><a href="#svelte-reactivity">Reactivity</a></li>
        <li><a href="#svelte-props">Props</a></li>
        <li><a href="#svelte-logic">Logic</a></li>
        <li><a href="#svelte-events">Events</a></li>
        <li><a href="#svelte-bindings">Bindings</a></li>
        <li><a href="#svelte-classes">Classes</a></li>
        <li><a href="#svelte-actions">Actions</a></li>
        <li><a href="#svelte-transitions">Transitions</a></li>
        <li><a href="#svelte-advanced-reactivity">Advanced Reactivity</a></li>
        <li><a href="#svelte-reusing-content">Reusing Content</a></li>
        <li><a href="#svelte-advanced-bindings">Advanced Bindings</a></li>
        <li><a href="#svelte-context-api">Context API</a></li>
        <li><a href="#svelte-special-elements">Special Elements</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-introduction">Introduction to Svelte</h3>
<ol>
    <li>What Is Svelte?</li>
    <br/>
    <ul>
        <li><b>Svelte</b> is a modern, <u>compiler-based</u> JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Unlike Vue or React, Svelte shifts work from the <u>browser</u> to a <u>compile step</u> at build time, producing highly optimized vanilla JavaScript.</li>
        <br/>
        <li>Svelte's ecosystem includes:
            <ul>
                <li><code>SvelteKit</code> which is a full-stack application framework (routing, SSR, etc.)</li>
                <li><code>Svelte Stores</code> for built-in state management</li>
                <li><code>Vite</code> is the recommended build tool</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>How Svelte Works</li>
    <br/>
    <ul>
        <li>Svelte compiles your components into <u>efficient imperative code</u> that surgically updates the DOM.</li>
        <br/>
        <li>There is <u>no virtual DOM</u> — Svelte generates code that directly manipulates the DOM when state changes.</li>
        <br/>
        <li>A Svelte component contains:
            <ul>
                <li>a <code>&lt;script&gt;</code> block for JavaScript logic</li>
                <li>HTML markup (the template)</li>
                <li>an optional <code>&lt;style&gt;</code> block for scoped CSS</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let message = "Hello Svelte!";
&lt;/script&gt;

&lt;h1&gt;{message}&lt;/h1&gt;

&lt;style&gt;
    h1 {
        color: #ff3e00;
    }
&lt;/style&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{ }</code> automatically updates when <code>message</code> changes.</li>
    </ul>
    <br/><br/>



    <li>Getting Started (Project Setup)</li>
    <br/>
    <ul>
        <li>The recommended way to start a Svelte project is using <code>SvelteKit</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npx sv create my-app
cd my-app/
npm install
npm run dev
</code></pre>
    <ul>
        <li>For a simpler standalone Svelte project without it:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm create vite@latest my-app -- --template svelte
cd my-app/
npm install
npm run dev
</code></pre>
    <br/><br/>



    <li>Core Concepts of Svelte</li>

    <br/>
    <ol>
    <li>Reactivity</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is built into the language — just assign a new value to trigger updates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count += 1;  // This automatically updates the DOM
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>Use <code>$:</code> to create reactive statements that re-run when dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: console.log("Count is now", count);
&lt;/script&gt;

&lt;p&gt;{count} doubled is {doubled}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Handling</li>

<pre><code class="language-html line-numbers">&lt;button on:click={handleClick}&gt;Click me&lt;/button&gt;

&lt;!-- With inline handler --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increase&lt;/button&gt;

&lt;!-- With modifiers --&gt;
&lt;button on:click|once|preventDefault={handleClick}&gt;Submit&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>on:click</code> is Svelte's event directive syntax.</li>
        <li>Modifiers like <code>|once</code>, <code>|preventDefault</code>, <code>|stopPropagation</code> can be chained.</li>
    </ul>
    <br/><br/>



    <li>Two-Way Binding with <code>bind:</code></li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "";
&lt;/script&gt;

&lt;input bind:value={name} /&gt;
&lt;p&gt;Hello {name}!&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>
    <br/><br/>



    <li>Conditionals and Loops</li>
<pre><code class="language-html line-numbers">&lt;!-- Conditionals --&gt;
{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}

&lt;!-- Loops --&gt;
{#each items as item, index (item.id)}
    &lt;li&gt;{index}: {item.name}&lt;/li&gt;
{/each}
</code></pre>
    <ul>
        <li><code>{#if}</code>, <code>{:else}</code>, <code>{/if}</code> are Svelte's conditional blocks.</li>
        <li><code>{#each}</code> iterates over arrays; the <code>(item.id)</code> part is a keyed each block for efficient updates.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Component Structure</li>
    <br/>
    <ul>
        <li>Svelte components are stored in <code>.svelte</code> files.</li>
        <li>Each file is a single component with script, markup, and styles together.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name = "World";
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;

&lt;style&gt;
    h1 {
        font-family: Georgia, serif;
        color: #333;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>export let</code> declares a <u>prop</u> that can be passed from parent components.</li>
        <li>Styles are <u>scoped by default</u>, they only affect this component.</li>
    </ul>
    <br/><br/>



    <li>Using Components</li>
    <br/>
    <ul>
        <li>Import and use components like regular ES modules:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Svelte" /&gt;
&lt;Greeting /&gt;  &lt;!-- Uses default "World" --&gt;
</code></pre>
    <br/><br/>



    <li>Key Differences from Other Frameworks</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte</th>
            <th>Vue / React</th>
        </tr>
        <tr>
            <td>Compilation</td>
            <td>Compiles to vanilla JS at build time</td>
            <td>Ships a runtime library to the browser</td>
        </tr>
        <tr>
            <td>Virtual DOM</td>
            <td>No virtual DOM</td>
            <td>Uses virtual DOM for diffing</td>
        </tr>
        <tr>
            <td>Reactivity</td>
            <td>Built into the language (<code>$:</code>)</td>
            <td>Requires hooks or reactive APIs</td>
        </tr>
        <tr>
            <td>Bundle Size</td>
            <td>Typically smaller</td>
            <td>Includes framework runtime</td>
        </tr>
        <tr>
            <td>Learning Curve</td>
            <td>Closer to vanilla HTML/CSS/JS</td>
            <td>Framework-specific patterns</td>
        </tr>
    </table>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduced <u>Runes</u>, a new reactivity system using special functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);

    function increment() {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    {count} × 2 = {doubled}
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$state()</code> creates reactive state.</li>
        <li><code>$derived()</code> creates computed values.</li>
        <li><code>$effect()</code> runs side effects when dependencies change.</li>
        <li>Note: In Svelte 5, event handlers use <code>onclick</code> instead of <code>on:click</code>.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-reactivity">Svelte Reactivity</h3>
<ol>
    <li>What Is Reactivity in Svelte?</li>
    <br/>
    <ul>
        <li><b>Reactivity</b> means that when your data changes, the UI automatically updates to reflect those changes.</li>
        <br/>
        <li>In Svelte, reactivity is <u>built into the language</u> — you don't need special APIs or hooks.</li>
        <br/>
        <li>Svelte's compiler analyzes your code and generates efficient JavaScript that updates the DOM only where necessary.</li>
    </ul>
    <br/><br/>



    <li>Assignment-Based Reactivity</li>
    <br/>
    <ul>
        <li>In Svelte, <u>assignments</u> trigger reactivity. Simply reassigning a variable updates the DOM.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count = count + 1;  // Assignment triggers update
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This also works with shorthand operators:</li>
    </ul>

<pre><code class="language-js line-numbers">count += 1;   // Reactive
count++;      // Reactive
count--;      // Reactive
</code></pre>
    <br/><br/>



    <li>Reactivity with Arrays and Objects</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is triggered by <u>assignments</u>, not mutations.</li>
        <br/>
        <li>Methods like <code>push()</code>, <code>pop()</code>, <code>splice()</code> do <u>not</u> trigger reactivity by themselves:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");  // This does NOT trigger update!
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>To trigger reactivity, you must <u>reassign</u> the variable:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");
        items = items;  // Reassignment triggers update
    }

    // Or more idiomatically:
    function addItemBetter() {
        items = [...items, "Cherry"];  // Spread creates new array
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Same applies to objects:</li>
    </ul>

<pre><code class="language-js line-numbers">let user = { name: "Alice", age: 25 };

user.age = 26;      // Does NOT trigger update
user = user;        // Triggers update

// Or:
user = { ...user, age: 26 };  // Triggers update
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>The <code>$:</code> label creates <u>reactive declarations</u> — values that automatically recalculate when their dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: quadrupled = doubled * 2;
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Svelte automatically tracks which variables are used and re-runs the declaration when any dependency changes.</li>
        <br/>
        <li>Reactive declarations can depend on other reactive declarations (like <code>quadrupled</code> depends on <code>doubled</code>).</li>
    </ul>
    <br/><br/>



    <li>Reactive Statements</li>
    <br/>
    <ul>
        <li>You can also use <code>$:</code> to run <u>arbitrary statements</u> reactively:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    $: console.log("Count changed to:", count);

    $: if (count &gt;= 10) {
        alert("Count is getting high!");
        count = 0;
    }

    $: {
        console.log("Running reactive block");
        console.log("Current count:", count);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>These statements re-run whenever any referenced variable changes.</li>
    </ul>
    <br/><br/>



    <li>Reactive Stores</li>
    <br/>
    <ul>
        <li>For state that needs to be shared across components, Svelte provides <u>stores</u>.</li>
        <br/>
        <li>A store is an object with a <code>subscribe</code> method that allows reactive access to a value.</li>
        <br/>
        <li>Svelte provides three built-in store types.</li>
    </ul>

    <br/>
    <ol>
    <li><code>writable</code> — Read and write</li>

<pre><code class="language-js line-numbers">// stores.js
import { writable } from "svelte/store";

export const count = writable(0);
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { count } from "./stores.js";

    function increment() {
        count.update(n =&gt; n + 1);
    }

    function reset() {
        count.set(0);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>set(value)</code> — Sets the store to a new value.</li>
        <li><code>update(fn)</code> — Updates based on current value.</li>
    </ul>
    <br/><br/>



    <li><code>readable</code> — Read only</li>

<pre><code class="language-js line-numbers">import { readable } from "svelte/store";

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() =&gt; {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };
});
</code></pre>

    <ul>
        <li>The second argument is a function that receives <code>set</code> and returns a cleanup function.</li>
    </ul>
    <br/><br/>



    <li><code>derived</code> — Derived from other stores</li>

<pre><code class="language-js line-numbers">import { derived } from "svelte/store";
import { count } from "./stores.js";

export const doubled = derived(count, $count =&gt; $count * 2);

// Derived from multiple stores:
export const total = derived(
    [storeA, storeB],
    ([$a, $b]) =&gt; $a + $b
);
</code></pre>
    </ol>
    <br/><br/>



    <li>Auto-Subscription with <code>$</code> Prefix</li>
    <br/>
    <ul>
        <li>Inside Svelte components, you can access store values using the <code>$</code> prefix:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { count } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;The count is {$count}&lt;/p&gt;

&lt;button on:click={() =&gt; $count++}&gt;
    Increment
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$count</code> automatically subscribes to the store and unsubscribes when the component is destroyed.</li>
        <br/>
        <li>You can also assign directly to <code>$count</code> — it's equivalent to calling <code>count.set()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { name } from "./stores.js";
&lt;/script&gt;

&lt;input bind:value={$name}&gt;
</code></pre>
    <br/><br/>



    <li>Custom Stores</li>
    <br/>
    <ul>
        <li>You can create custom stores with domain-specific logic:</li>
    </ul>

<pre><code class="language-js line-numbers">import { writable } from "svelte/store";

function createCounter() {
    const { subscribe, set, update } = writable(0);

    return {
        subscribe,
        increment: () =&gt; update(n =&gt; n + 1),
        decrement: () =&gt; update(n =&gt; n - 1),
        reset: () =&gt; set(0)
    };
}

export const counter = createCounter();
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { counter } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;{$counter}&lt;/p&gt;
&lt;button on:click={counter.increment}&gt;+&lt;/button&gt;
&lt;button on:click={counter.decrement}&gt;-&lt;/button&gt;
&lt;button on:click={counter.reset}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity System)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduces <u>Runes</u>, a new reactivity system that replaces <code>$:</code> and provides more explicit control.</li>
    </ul>

    <br/>
    <ol>
    <li><code>$state</code> — Reactive State</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    function increment() {
        count++;  // Directly mutate, it's reactive!
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>With <code>$state</code>, even mutations on arrays and objects are reactive:</li>
    </ul>

<pre><code class="language-js line-numbers">let items = $state(["Apple", "Banana"]);
items.push("Cherry");  // This IS reactive in Svelte 5!

let user = $state({ name: "Alice", age: 25 });
user.age = 26;  // This IS reactive in Svelte 5!
</code></pre>
    <br/><br/>



    <li><code>$derived</code> — Computed Values</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);
    let quadrupled = $derived(doubled * 2);
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$derived</code> replaces the <code>$:</code> reactive declarations.</li>
    </ul>
    <br/><br/>



    <li><code>$effect</code> — Side Effects</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    $effect(() =&gt; {
        console.log("Count is now:", count);
    });

    $effect(() =&gt; {
        // Runs when component mounts
        console.log("Mounted!");

        return () =&gt; {
            // Cleanup when component unmounts
            console.log("Unmounted!");
        };
    });
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$effect</code> automatically tracks dependencies and re-runs when they change.</li>
        <li>Return a function for cleanup (like <code>useEffect</code> in React).</li>
    </ul>
    <br/><br/>



    <li><code>$props</code> — Component Props</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let { name, age = 18 } = $props();
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$props</code> replaces <code>export let</code> for declaring component props in Svelte 5.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Reactivity</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5 (Runes)</th>
        </tr>
        <tr>
            <td>Reactive variable</td>
            <td><code>let count = 0;</code></td>
            <td><code>let count = $state(0);</code></td>
        </tr>
        <tr>
            <td>Computed value</td>
            <td><code>$: doubled = count * 2;</code></td>
            <td><code>let doubled = $derived(count * 2);</code></td>
        </tr>
        <tr>
            <td>Side effect</td>
            <td><code>$: console.log(count);</code></td>
            <td><code>$effect(() =&gt; console.log(count));</code></td>
        </tr>
        <tr>
            <td>Props</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Array/Object mutation</td>
            <td>Requires reassignment</td>
            <td>Direct mutation works</td>
        </tr>
        <tr>
            <td>Event handlers</td>
            <td><code>on:click={fn}</code></td>
            <td><code>onclick={fn}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-props">Svelte Props</h3>
<ol>
    <li>What Are Props?</li>
    <br/>
    <ul>
        <li><b>Props</b> (short for properties) are how you pass data from a <u>parent component</u> to a <u>child component</u>.</li>
        <br/>
        <li>Props allow components to be reusable and configurable.</li>
        <br/>
        <li>In Svelte, props flow <u>one direction</u>: from parent to child (unidirectional data flow).</li>
    </ul>
    <br/><br/>



    <li>Declaring Props (Svelte 4)</li>
    <br/>
    <ul>
        <li>In Svelte 4, use <code>export let</code> to declare a prop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name;
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>The parent component passes the prop as an attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Alice" /&gt;
&lt;Greeting name="Bob" /&gt;
</code></pre>
    <br/><br/>



    <li>Default Values</li>
    <br/>
    <ul>
        <li>You can assign a default value to a prop:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name = "World";
    export let age = 18;
    export let active = false;
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Using defaults --&gt;
&lt;Greeting /&gt;                    &lt;!-- name="World", age=18 --&gt;
&lt;Greeting name="Alice" /&gt;       &lt;!-- name="Alice", age=18 --&gt;
&lt;Greeting name="Bob" age={25} /&gt;
</code></pre>
    <br/><br/>



    <li>Passing Different Data Types</li>
    <br/>
    <ul>
        <li>Strings can be passed directly, but other types require curly braces:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- String --&gt;
&lt;User name="Alice" /&gt;

&lt;!-- Number --&gt;
&lt;User age={25} /&gt;

&lt;!-- Boolean --&gt;
&lt;User active={true} /&gt;
&lt;User active /&gt;              &lt;!-- Shorthand for active={true} --&gt;

&lt;!-- Array --&gt;
&lt;List items={["Apple", "Banana", "Cherry"]} /&gt;

&lt;!-- Object --&gt;
&lt;Profile user={{ name: "Alice", age: 25 }} /&gt;

&lt;!-- Variable --&gt;
&lt;script&gt;
    let username = "Alice";
&lt;/script&gt;
&lt;User name={username} /&gt;
</code></pre>
    <br/><br/>



    <li>Shorthand Props</li>
    <br/>
    <ul>
        <li>When the prop name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "Alice";
    let age = 25;
&lt;/script&gt;

&lt;!-- Instead of this: --&gt;
&lt;User name={name} age={age} /&gt;

&lt;!-- Use shorthand: --&gt;
&lt;User {name} {age} /&gt;
</code></pre>
    <br/><br/>



    <li>Spread Props</li>
    <br/>
    <ul>
        <li>You can spread an object to pass multiple props at once:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import User from "./User.svelte";

    const userData = {
        name: "Alice",
        age: 25,
        email: "alice@example.com"
    };
&lt;/script&gt;

&lt;!-- Instead of: --&gt;
&lt;User name={userData.name} age={userData.age} email={userData.email} /&gt;

&lt;!-- Use spread: --&gt;
&lt;User {...userData} /&gt;
</code></pre>
    <br/><br/>



    <li>Receiving All Props with <code>$$props</code> and <code>$$restProps</code></li>
    <br/>
    <ul>
        <li><code>$$props</code> contains all props passed to a component:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name;
    export let age;

    // $$props = { name: "...", age: ..., ...anyOtherProps }
    console.log($$props);
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$$restProps</code> contains props that were <u>not</u> explicitly declared:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script&gt;
    export let variant = "primary";
    // Any other props (class, id, disabled, etc.) go to $$restProps
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...$$restProps}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Button variant="danger" disabled id="submit-btn"&gt;
    Submit
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>This is useful for wrapper components that forward attributes to native elements.</li>
    </ul>
    <br/><br/>



    <li>Reactive Props</li>
    <br/>
    <ul>
        <li>Props are reactive — when the parent updates a prop, the child re-renders:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script&gt;
    import Counter from "./Counter.svelte";
    let count = 0;
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;Increment in Parent&lt;/button&gt;
&lt;Counter value={count} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte --&gt;
&lt;script&gt;
    export let value;
    $: console.log("Value changed to:", value);
&lt;/script&gt;

&lt;p&gt;Count: {value}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Readonly Props (One-Way Binding)</li>
    <br/>
    <ul>
        <li>By default, props are <u>one-way</u>: parent → child.</li>
        <br/>
        <li>Modifying a prop inside the child does <u>not</u> affect the parent:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.svelte --&gt;
&lt;script&gt;
    export let count = 0;

    function increment() {
        count++;  // Only changes local copy, not parent's value
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;{count}&lt;/button&gt;
</code></pre>

    <ul>
        <li>To update the parent, use <u>events</u> or <u>two-way binding</u> (covered later).</li>
    </ul>
    <br/><br/>



    <li>Props with TypeScript (Svelte 4)</li>
    <br/>
    <ul>
        <li>Add types to props using TypeScript:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    export let name: string;
    export let age: number = 18;
    export let active: boolean = false;
    export let items: string[] = [];
    export let user: { name: string; email: string } | null = null;
&lt;/script&gt;
</code></pre>

    <ul>
        <li>For complex types, define interfaces:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    export let user: User;
    export let users: User[] = [];
&lt;/script&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with <code>$props</code></li>
    <br/>
    <ul>
        <li>In Svelte 5, use the <code>$props</code> rune instead of <code>export let</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte (Svelte 5) --&gt;
&lt;script&gt;
    let { name } = $props();
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>Multiple props with defaults:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name = "World", age = 18, active = false } = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Rest props (similar to <code>$$restProps</code>):</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name, age, ...rest } = $props();
&lt;/script&gt;

&lt;div {...rest}&gt;
    {name} is {age}
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with TypeScript</li>
    <br/>
    <ul>
        <li>Type your props using TypeScript with <code>$props</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Props {
        name: string;
        age?: number;
        active?: boolean;
    }

    let { name, age = 18, active = false }: Props = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>With rest props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: "primary" | "secondary" | "danger";
    }

    let { variant = "primary", ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Props</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>Basic prop</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Default value</td>
            <td><code>export let name = "World";</code></td>
            <td><code>let { name = "World" } = $props();</code></td>
        </tr>
        <tr>
            <td>Multiple props</td>
            <td>Multiple <code>export let</code> lines</td>
            <td>Destructure from <code>$props()</code></td>
        </tr>
        <tr>
            <td>Rest props</td>
            <td><code>$$restProps</code></td>
            <td><code>let { a, ...rest } = $props();</code></td>
        </tr>
        <tr>
            <td>All props</td>
            <td><code>$$props</code></td>
            <td><code>let props = $props();</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-logic">Svelte Logic</h3>
<ol>
    <li>What Is Svelte Logic?</li>
    <br/>
    <ul>
        <li>Svelte provides special <u>logic blocks</u> in templates to handle conditional rendering, loops, and asynchronous data.</li>
        <br/>
        <li>These blocks use a syntax with <code>{#...}</code> to open, <code>{:...}</code> for continuation, and <code>{/...}</code> to close.</li>
        <br/>
        <li>The main logic blocks are:
            <ul>
                <li><code>{#if}</code> — Conditional rendering</li>
                <li><code>{#each}</code> — Looping over arrays</li>
                <li><code>{#await}</code> — Handling promises</li>
                <li><code>{#key}</code> — Forcing re-render on value change</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Conditional Rendering with <code>{#if}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#if}</code> to conditionally render content:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{/if}

&lt;button onclick={() =&gt; loggedIn = !loggedIn}&gt;
    Toggle Login
&lt;/button&gt;
</code></pre>

    <ul>
        <li>The content inside <code>{#if}</code> only renders when the condition is <code>true</code>.</li>
    </ul>
    <br/><br/>



    <li><code>{:else}</code> Block</li>
    <br/>
    <ul>
        <li>Use <code>{:else}</code> to render alternative content when the condition is <code>false</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back, user!&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = false}&gt;Log Out&lt;/button&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = true}&gt;Log In&lt;/button&gt;
{/if}
</code></pre>
    <br/><br/>



    <li><code>{:else if}</code> Block</li>
    <br/>
    <ul>
        <li>Chain multiple conditions with <code>{:else if}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let score: number = 75;
&lt;/script&gt;

{#if score &gt;= 90}
    &lt;p&gt;Grade: A&lt;/p&gt;
{:else if score &gt;= 80}
    &lt;p&gt;Grade: B&lt;/p&gt;
{:else if score &gt;= 70}
    &lt;p&gt;Grade: C&lt;/p&gt;
{:else if score &gt;= 60}
    &lt;p&gt;Grade: D&lt;/p&gt;
{:else}
    &lt;p&gt;Grade: F&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Nested Conditionals</li>
    <br/>
    <ul>
        <li>You can nest <code>{#if}</code> blocks inside each other:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = true;
    let isAdmin: boolean = true;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome!&lt;/p&gt;
    {#if isAdmin}
        &lt;p&gt;You have admin privileges.&lt;/p&gt;
        &lt;button&gt;Access Admin Panel&lt;/button&gt;
    {:else}
        &lt;p&gt;You are a regular user.&lt;/p&gt;
    {/if}
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Looping with <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#each}</code> to iterate over arrays:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit}
        &lt;li&gt;{fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{#each}</code> with Index</li>
    <br/>
    <ul>
        <li>Access the current index as the second parameter:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit, index}
        &lt;li&gt;{index + 1}. {fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Keyed <code>{#each}</code> Blocks</li>
    <br/>
    <ul>
        <li>When items can be added, removed, or reordered, use a <u>key</u> to help Svelte track each item:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Todo {
        id: number;
        text: string;
        done: boolean;
    }

    let todos: Todo[] = [
        { id: 1, text: "Learn Svelte", done: false },
        { id: 2, text: "Build an app", done: false },
        { id: 3, text: "Deploy", done: false }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo (todo.id)}
        &lt;li&gt;{todo.text}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>

    <ul>
        <li>The <code>(todo.id)</code> part is the key — it should be a unique identifier.</li>
        <br/>
        <li>Keys ensure correct DOM updates when the list changes (especially important for animations and component state).</li>
    </ul>
    <br/><br/>



    <li><code>{#each}</code> with Destructuring</li>
    <br/>
    <ul>
        <li>Destructure objects directly in the each block:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    let users: User[] = [
        { id: 1, name: "Alice", email: "alice@example.com" },
        { id: 2, name: "Bob", email: "bob@example.com" }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each users as { id, name, email } (id)}
        &lt;li&gt;{name} - {email}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{:else}</code> in <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Render fallback content when the array is empty:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let todos: string[] = [];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo}
        &lt;li&gt;{todo}&lt;/li&gt;
    {:else}
        &lt;li&gt;No todos yet. Add one!&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Iterating Over Objects</li>
    <br/>
    <ul>
        <li>Use <code>Object.entries()</code> or <code>Object.keys()</code> to iterate over objects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const scores: Record&lt;string, number&gt; = {
        Alice: 95,
        Bob: 82,
        Charlie: 78
    };
&lt;/script&gt;

&lt;ul&gt;
    {#each Object.entries(scores) as [name, score]}
        &lt;li&gt;{name}: {score}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Handling Promises with <code>{#await}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#await}</code> to handle asynchronous data directly in templates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchUser(): Promise&lt;User&gt; {
        const response = await fetch("https://api.example.com/user/1");
        return response.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchUser();
&lt;/script&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;Hello, {user.name}!&lt;/p&gt;
{:catch error}
    &lt;p&gt;Error: {error.message}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li><code>{#await promise}</code> — Shows while pending</li>
        <li><code>{:then value}</code> — Shows when resolved</li>
        <li><code>{:catch error}</code> — Shows when rejected</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Loading State</li>
    <br/>
    <ul>
        <li>If you don't need a loading state, skip directly to <code>{:then}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let dataPromise: Promise&lt;string&gt; = Promise.resolve("Hello!");
&lt;/script&gt;

{#await dataPromise then data}
    &lt;p&gt;{data}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li>Nothing renders until the promise resolves.</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Catch</li>
    <br/>
    <ul>
        <li>You can omit <code>{:catch}</code> if you don't need error handling in the template:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        title: string;
        body: string;
    }

    async function fetchPost(): Promise&lt;Post&gt; {
        const res = await fetch("https://api.example.com/posts/1");
        return res.json();
    }

    let postPromise: Promise&lt;Post&gt; = fetchPost();
&lt;/script&gt;

{#await postPromise}
    &lt;p&gt;Loading post...&lt;/p&gt;
{:then post}
    &lt;h2&gt;{post.title}&lt;/h2&gt;
    &lt;p&gt;{post.body}&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Refreshing <code>{#await}</code> Data</li>
    <br/>
    <ul>
        <li>Reassign the promise to trigger a refresh:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchRandomUser(): Promise&lt;User&gt; {
        const id = Math.floor(Math.random() * 10) + 1;
        const res = await fetch(`https://api.example.com/users/${id}`);
        return res.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchRandomUser();

    function refresh(): void {
        userPromise = fetchRandomUser();  // Reassign to refetch
    }
&lt;/script&gt;

&lt;button onclick={refresh}&gt;Load Random User&lt;/button&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;{user.name}&lt;/p&gt;
{:catch error}
    &lt;p&gt;Failed to load user.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Forcing Re-render with <code>{#key}</code></li>
    <br/>
    <ul>
        <li>The <code>{#key}</code> block destroys and recreates its content when the key value changes:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let userId: number = 1;
&lt;/script&gt;

&lt;input type="number" bind:value={userId} min="1" /&gt;

{#key userId}
    &lt;UserProfile id={userId} /&gt;
{/key}
</code></pre>

    <ul>
        <li>When <code>userId</code> changes, the <code>UserProfile</code> component is destroyed and a new instance is created.</li>
        <br/>
        <li>This resets all component state and re-runs lifecycle functions.</li>
    </ul>
    <br/><br/>



    <li><code>{#key}</code> for Animations</li>
    <br/>
    <ul>
        <li><code>{#key}</code> is useful for triggering intro/outro transitions:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let count: number = 0;
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;

{#key count}
    &lt;p transition:fade&gt;{count}&lt;/p&gt;
{/key}
</code></pre>

    <ul>
        <li>Every time <code>count</code> changes, the paragraph fades out and a new one fades in.</li>
    </ul>
    <br/><br/>



    <li>Combining Logic Blocks</li>
    <br/>
    <ul>
        <li>Logic blocks can be combined for complex rendering:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        id: number;
        title: string;
        published: boolean;
    }

    async function fetchPosts(): Promise&lt;Post[]&gt; {
        const res = await fetch("https://api.example.com/posts");
        return res.json();
    }

    let postsPromise: Promise&lt;Post[]&gt; = fetchPosts();
    let showOnlyPublished: boolean = false;
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={showOnlyPublished} /&gt;
    Show only published
&lt;/label&gt;

{#await postsPromise}
    &lt;p&gt;Loading posts...&lt;/p&gt;
{:then posts}
    &lt;ul&gt;
        {#each posts as post (post.id)}
            {#if !showOnlyPublished || post.published}
                &lt;li&gt;
                    {post.title}
                    {#if !post.published}
                        &lt;span&gt;(Draft)&lt;/span&gt;
                    {/if}
                &lt;/li&gt;
            {/if}
        {/each}
    &lt;/ul&gt;
{:catch}
    &lt;p&gt;Failed to load posts.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Logic Blocks Summary</li>
    <br/>

    <table>
        <tr>
            <th>Block</th>
            <th>Purpose</th>
            <th>Syntax</th>
        </tr>
        <tr>
            <td><code>{#if}</code></td>
            <td>Conditional rendering</td>
            <td><code>{#if condition}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else}</code></td>
            <td>Else branch</td>
            <td><code>{#if}...{:else}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else if}</code></td>
            <td>Else-if branch</td>
            <td><code>{#if}...{:else if}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{#each}</code></td>
            <td>Loop over arrays</td>
            <td><code>{#each array as item}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#each} + key</code></td>
            <td>Keyed loop</td>
            <td><code>{#each array as item (key)}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#await}</code></td>
            <td>Handle promises</td>
            <td><code>{#await promise}...{:then}...{:catch}...{/await}</code></td>
        </tr>
        <tr>
            <td><code>{#key}</code></td>
            <td>Force re-render</td>
            <td><code>{#key value}...{/key}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-events">Svelte Events</h3>
<ol>
    <li>What Are Events in Svelte?</li>
    <br/>
    <ul>
        <li><b>Events</b> allow components to respond to user interactions and communicate with each other.</li>
        <br/>
        <li>Svelte supports:
            <ul>
                <li><b>DOM events</b> — Native browser events like click, input, submit</li>
                <li><b>Component events</b> — Custom events dispatched from child to parent</li>
            </ul>
        </li>
        <br/>
        <li>Svelte 4 uses <code>on:event</code> syntax, while Svelte 5 uses <code>onevent</code> syntax.</li>
    </ul>
    <br/><br/>



    <li>DOM Event Handling (Svelte 4)</li>
    <br/>
    <ul>
        <li>Use <code>on:</code> directive to listen to DOM events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = 0;

    function handleClick(): void {
        count++;
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>

    <ul>
        <li>Common DOM events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Mouse events --&gt;
&lt;button on:click={handleClick}&gt;Click&lt;/button&gt;
&lt;div on:dblclick={handleDoubleClick}&gt;Double click&lt;/div&gt;
&lt;div on:mouseenter={handleMouseEnter}&gt;Hover me&lt;/div&gt;
&lt;div on:mouseleave={handleMouseLeave}&gt;Leave me&lt;/div&gt;
&lt;div on:mousemove={handleMouseMove}&gt;Move inside&lt;/div&gt;

&lt;!-- Keyboard events --&gt;
&lt;input on:keydown={handleKeyDown} /&gt;
&lt;input on:keyup={handleKeyUp} /&gt;
&lt;input on:keypress={handleKeyPress} /&gt;

&lt;!-- Form events --&gt;
&lt;input on:input={handleInput} /&gt;
&lt;input on:change={handleChange} /&gt;
&lt;input on:focus={handleFocus} /&gt;
&lt;input on:blur={handleBlur} /&gt;
&lt;form on:submit={handleSubmit}&gt;...&lt;/form&gt;

&lt;!-- Other events --&gt;
&lt;div on:scroll={handleScroll}&gt;...&lt;/div&gt;
&lt;img on:load={handleLoad} on:error={handleError} /&gt;
</code></pre>
    <br/><br/>



    <li>DOM Event Handling (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use standard HTML attribute syntax:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);

    function handleClick(): void {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 5 event syntax --&gt;
&lt;button onclick={handleClick}&gt;Click&lt;/button&gt;
&lt;div ondblclick={handleDoubleClick}&gt;Double click&lt;/div&gt;
&lt;input onkeydown={handleKeyDown} /&gt;
&lt;input oninput={handleInput} /&gt;
&lt;form onsubmit={handleSubmit}&gt;...&lt;/form&gt;
</code></pre>
    <br/><br/>



    <li>Inline Event Handlers</li>
    <br/>
    <ul>
        <li>You can define handlers inline using arrow functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let message: string = $state("");
&lt;/script&gt;

&lt;!-- Svelte 5 syntax --&gt;
&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;
&lt;button onclick={() =&gt; count = 0}&gt;Reset&lt;/button&gt;
&lt;button onclick={() =&gt; alert("Hello!")}&gt;Alert&lt;/button&gt;

&lt;input oninput={(e) =&gt; message = e.currentTarget.value} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 4 syntax --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increment&lt;/button&gt;
&lt;button on:click={() =&gt; count = 0}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>The Event Object</li>
    <br/>
    <ul>
        <li>Event handlers receive the native DOM event object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function handleClick(event: MouseEvent): void {
        console.log("Clicked at:", event.clientX, event.clientY);
        console.log("Target:", event.target);
        console.log("Current target:", event.currentTarget);
    }

    function handleKeyDown(event: KeyboardEvent): void {
        console.log("Key pressed:", event.key);
        console.log("Key code:", event.code);
        if (event.key === "Enter") {
            console.log("Enter pressed!");
        }
    }

    function handleInput(event: Event): void {
        const target = event.currentTarget as HTMLInputElement;
        console.log("Input value:", target.value);
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;Click me&lt;/button&gt;
&lt;input onkeydown={handleKeyDown} /&gt;
&lt;input oninput={handleInput} /&gt;
</code></pre>
    <br/><br/>



    <li>Event Modifiers (Svelte 4)</li>
    <br/>
    <ul>
        <li>Svelte 4 provides modifiers to alter event behavior:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- preventDefault: Prevents default browser action --&gt;
&lt;form on:submit|preventDefault={handleSubmit}&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;!-- stopPropagation: Stops event from bubbling up --&gt;
&lt;div on:click={handleOuter}&gt;
    &lt;button on:click|stopPropagation={handleInner}&gt;Click&lt;/button&gt;
&lt;/div&gt;

&lt;!-- once: Handler runs only once --&gt;
&lt;button on:click|once={handleClick}&gt;Click once&lt;/button&gt;

&lt;!-- capture: Use capture phase instead of bubble --&gt;
&lt;div on:click|capture={handleClick}&gt;...&lt;/div&gt;

&lt;!-- self: Only trigger if event.target is the element itself --&gt;
&lt;div on:click|self={handleClick}&gt;
    &lt;button&gt;Clicking here won't trigger parent&lt;/button&gt;
&lt;/div&gt;

&lt;!-- passive: Improves scroll performance --&gt;
&lt;div on:scroll|passive={handleScroll}&gt;...&lt;/div&gt;

&lt;!-- nonpassive: Explicitly not passive --&gt;
&lt;div on:touchstart|nonpassive={handleTouch}&gt;...&lt;/div&gt;

&lt;!-- trusted: Only trigger for user-initiated events --&gt;
&lt;button on:click|trusted={handleClick}&gt;...&lt;/button&gt;
</code></pre>

    <ul>
        <li>Modifiers can be chained:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;form on:submit|preventDefault|stopPropagation={handleSubmit}&gt;
    ...
&lt;/form&gt;

&lt;button on:click|once|capture={handleClick}&gt;...&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Event Modifiers (Svelte 5)</li>
    <br/>
    <ul>
        <li>Svelte 5 doesn't have the modifier syntax. Use standard JavaScript instead:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function handleSubmit(event: SubmitEvent): void {
        event.preventDefault();
        // Handle form submission
    }

    function handleInnerClick(event: MouseEvent): void {
        event.stopPropagation();
        // Handle click
    }
&lt;/script&gt;

&lt;form onsubmit={handleSubmit}&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;div onclick={handleOuter}&gt;
    &lt;button onclick={handleInnerClick}&gt;Click&lt;/button&gt;
&lt;/div&gt;
</code></pre>

    <ul>
        <li>For <code>once</code>, use a wrapper or state:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let clicked: boolean = $state(false);

    function handleOnce(): void {
        if (clicked) return;
        clicked = true;
        console.log("This runs only once");
    }
&lt;/script&gt;

&lt;button onclick={handleOnce}&gt;Click once&lt;/button&gt;
</code></pre>

    <ul>
        <li>For <code>capture</code> and <code>passive</code>, use <code>onclickcapture</code> or handle in <code>$effect</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Capture phase --&gt;
&lt;div onclickcapture={handleClick}&gt;...&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Component Events (Svelte 4)</li>
    <br/>
    <ul>
        <li>Components can dispatch custom events to their parent using <code>createEventDispatcher</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import { createEventDispatcher } from "svelte";

    const dispatch = createEventDispatcher&lt;{
        click: void;
        customEvent: { message: string };
    }&gt;();

    function handleClick(): void {
        dispatch("click");
        dispatch("customEvent", { message: "Hello from child!" });
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";

    function handleCustomEvent(event: CustomEvent&lt;{ message: string }&gt;): void {
        console.log(event.detail.message);
    }
&lt;/script&gt;

&lt;Button on:click={() =&gt; console.log("Clicked!")} on:customEvent={handleCustomEvent}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Component Events (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <u>callback props</u> instead of <code>createEventDispatcher</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        onclick?: () =&gt; void;
        onCustomEvent?: (data: { message: string }) =&gt; void;
        children?: any;
    }

    let { onclick, onCustomEvent, children }: Props = $props();

    function handleClick(): void {
        onclick?.();
        onCustomEvent?.({ message: "Hello from child!" });
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;
    {@render children?.()}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";

    function handleCustomEvent(data: { message: string }): void {
        console.log(data.message);
    }
&lt;/script&gt;

&lt;Button onclick={() =&gt; console.log("Clicked!")} onCustomEvent={handleCustomEvent}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Event Forwarding (Svelte 4)</li>
    <br/>
    <ul>
        <li>Forward DOM events from a child element without handling them:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    export let variant: string = "primary";
&lt;/script&gt;

&lt;!-- Forward click event to parent --&gt;
&lt;button class="btn btn-{variant}" on:click&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button on:click={() =&gt; console.log("Button clicked!")}&gt;
    Click me
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>The <code>on:click</code> without a value forwards the event.</li>
        <br/>
        <li>Forward multiple events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input
    on:input
    on:change
    on:focus
    on:blur
    on:keydown
/&gt;
</code></pre>
    <br/><br/>



    <li>Event Forwarding (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use rest props to forward events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: string;
    }

    let { variant = "primary", children, ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    {@render children?.()}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button onclick={() =&gt; console.log("Clicked!")} onmouseenter={() =&gt; console.log("Hovered!")}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Typed Custom Events (Svelte 4)</li>
    <br/>
    <ul>
        <li>Strongly type custom events with generics:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchBox.svelte --&gt;
&lt;script lang="ts"&gt;
    import { createEventDispatcher } from "svelte";

    interface SearchEvents {
        search: string;
        clear: void;
        select: { id: number; label: string };
    }

    const dispatch = createEventDispatcher&lt;SearchEvents&gt;();

    let query: string = "";

    function handleSearch(): void {
        dispatch("search", query);
    }

    function handleClear(): void {
        query = "";
        dispatch("clear");
    }

    function handleSelect(id: number, label: string): void {
        dispatch("select", { id, label });
    }
&lt;/script&gt;

&lt;input bind:value={query} on:input={handleSearch} /&gt;
&lt;button on:click={handleClear}&gt;Clear&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import SearchBox from "./SearchBox.svelte";

    function onSearch(event: CustomEvent&lt;string&gt;): void {
        console.log("Searching for:", event.detail);
    }

    function onClear(): void {
        console.log("Search cleared");
    }

    function onSelect(event: CustomEvent&lt;{ id: number; label: string }&gt;): void {
        console.log("Selected:", event.detail.id, event.detail.label);
    }
&lt;/script&gt;

&lt;SearchBox on:search={onSearch} on:clear={onClear} on:select={onSelect} /&gt;
</code></pre>
    <br/><br/>



    <li>Typed Callback Props (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, callbacks are naturally typed:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchBox.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        onSearch?: (query: string) =&gt; void;
        onClear?: () =&gt; void;
        onSelect?: (item: { id: number; label: string }) =&gt; void;
    }

    let { onSearch, onClear, onSelect }: Props = $props();

    let query: string = $state("");

    function handleInput(): void {
        onSearch?.(query);
    }

    function handleClear(): void {
        query = "";
        onClear?.();
    }
&lt;/script&gt;

&lt;input bind:value={query} oninput={handleInput} /&gt;
&lt;button onclick={handleClear}&gt;Clear&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import SearchBox from "./SearchBox.svelte";

    function handleSearch(query: string): void {
        console.log("Searching for:", query);
    }

    function handleSelect(item: { id: number; label: string }): void {
        console.log("Selected:", item.id, item.label);
    }
&lt;/script&gt;

&lt;SearchBox onSearch={handleSearch} onClear={() =&gt; console.log("Cleared")} onSelect={handleSelect} /&gt;
</code></pre>
    <br/><br/>



    <li>Handling Window and Document Events</li>
    <br/>
    <ul>
        <li>Use <code>&lt;svelte:window&gt;</code> and <code>&lt;svelte:document&gt;</code> for global events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);

    function handleKeyDown(event: KeyboardEvent): void {
        if (event.key === "Escape") {
            console.log("Escape pressed!");
        }
    }

    function handleVisibilityChange(): void {
        console.log("Visibility:", document.visibilityState);
    }
&lt;/script&gt;

&lt;!-- Window events --&gt;
&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    onkeydown={handleKeyDown}
    onresize={() =&gt; console.log("Resized!")}
/&gt;

&lt;!-- Document events --&gt;
&lt;svelte:document onvisibilitychange={handleVisibilityChange} /&gt;

&lt;p&gt;Window size: {innerWidth} x {innerHeight}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Handling Body Events</li>
    <br/>
    <ul>
        <li>Use <code>&lt;svelte:body&gt;</code> for body-level events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let mouseX: number = $state(0);
    let mouseY: number = $state(0);

    function handleMouseMove(event: MouseEvent): void {
        mouseX = event.clientX;
        mouseY = event.clientY;
    }
&lt;/script&gt;

&lt;svelte:body onmousemove={handleMouseMove} /&gt;

&lt;p&gt;Mouse position: {mouseX}, {mouseY}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Syntax Comparison</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>DOM event</td>
            <td><code>on:click={handler}</code></td>
            <td><code>onclick={handler}</code></td>
        </tr>
        <tr>
            <td>Inline handler</td>
            <td><code>on:click={() => ...}</code></td>
            <td><code>onclick={() => ...}</code></td>
        </tr>
        <tr>
            <td>Modifiers</td>
            <td><code>on:click|preventDefault</code></td>
            <td><code>event.preventDefault()</code></td>
        </tr>
        <tr>
            <td>Event forwarding</td>
            <td><code>on:click</code> (no value)</td>
            <td><code>{...rest}</code> spread</td>
        </tr>
        <tr>
            <td>Component events</td>
            <td><code>createEventDispatcher</code></td>
            <td>Callback props</td>
        </tr>
        <tr>
            <td>Listen to component</td>
            <td><code>on:customEvent={handler}</code></td>
            <td><code>onCustomEvent={handler}</code></td>
        </tr>
        <tr>
            <td>Capture phase</td>
            <td><code>on:click|capture</code></td>
            <td><code>onclickcapture</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-bindings">Svelte Bindings</h3>
<ol>
    <li>What Are Bindings?</li>
    <br/>
    <ul>
        <li><b>Bindings</b> create a <u>two-way connection</u> between a variable and an element property or component prop.</li>
        <br/>
        <li>When the variable changes, the element updates. When the element changes (e.g., user input), the variable updates.</li>
        <br/>
        <li>Svelte uses the <code>bind:</code> directive for bindings.</li>
    </ul>
    <br/><br/>



    <li>Basic Input Binding</li>
    <br/>
    <ul>
        <li>Bind an input's value to a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let name: string = $state("");
&lt;/script&gt;

&lt;input type="text" bind:value={name} /&gt;
&lt;p&gt;Hello, {name || "stranger"}!&lt;/p&gt;
</code></pre>

    <ul>
        <li>Typing in the input automatically updates <code>name</code>.</li>
        <li>Changing <code>name</code> programmatically updates the input.</li>
    </ul>
    <br/><br/>



    <li>Text Input Types</li>
    <br/>
    <ul>
        <li>Works with various text input types:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let text: string = $state("");
    let email: string = $state("");
    let password: string = $state("");
    let search: string = $state("");
    let url: string = $state("");
    let tel: string = $state("");
&lt;/script&gt;

&lt;input type="text" bind:value={text} /&gt;
&lt;input type="email" bind:value={email} /&gt;
&lt;input type="password" bind:value={password} /&gt;
&lt;input type="search" bind:value={search} /&gt;
&lt;input type="url" bind:value={url} /&gt;
&lt;input type="tel" bind:value={tel} /&gt;
</code></pre>
    <br/><br/>



    <li>Numeric Input Binding</li>
    <br/>
    <ul>
        <li>For <code>type="number"</code> and <code>type="range"</code>, the value is automatically coerced to a number:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let quantity: number = $state(1);
    let volume: number = $state(50);
&lt;/script&gt;

&lt;input type="number" bind:value={quantity} min="0" max="100" /&gt;
&lt;p&gt;Quantity: {quantity} (type: {typeof quantity})&lt;/p&gt;

&lt;input type="range" bind:value={volume} min="0" max="100" /&gt;
&lt;p&gt;Volume: {volume}%&lt;/p&gt;
</code></pre>

    <ul>
        <li>The bound variable will be a <code>number</code>, not a string.</li>
    </ul>
    <br/><br/>



    <li>Checkbox Binding</li>
    <br/>
    <ul>
        <li>For checkboxes, bind to <code>checked</code> instead of <code>value</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let agreed: boolean = $state(false);
    let subscribed: boolean = $state(true);
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={agreed} /&gt;
    I agree to the terms
&lt;/label&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={subscribed} /&gt;
    Subscribe to newsletter
&lt;/label&gt;

&lt;p&gt;Agreed: {agreed}, Subscribed: {subscribed}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Checkbox Group Binding</li>
    <br/>
    <ul>
        <li>Bind multiple checkboxes to an array using <code>bind:group</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let selectedFruits: string[] = $state([]);

    const fruits: string[] = ["Apple", "Banana", "Cherry", "Mango"];
&lt;/script&gt;

{#each fruits as fruit}
    &lt;label&gt;
        &lt;input type="checkbox" value={fruit} bind:group={selectedFruits} /&gt;
        {fruit}
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected: {selectedFruits.join(", ") || "None"}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Checking a box adds its <code>value</code> to the array.</li>
        <li>Unchecking removes it from the array.</li>
    </ul>
    <br/><br/>



    <li>Radio Button Binding</li>
    <br/>
    <ul>
        <li>Bind radio buttons to a single value using <code>bind:group</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let selectedColor: string = $state("red");

    const colors: string[] = ["red", "green", "blue"];
&lt;/script&gt;

{#each colors as color}
    &lt;label&gt;
        &lt;input type="radio" value={color} bind:group={selectedColor} /&gt;
        {color}
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected color: {selectedColor}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Only one radio button in a group can be selected at a time.</li>
    </ul>
    <br/><br/>



    <li>Radio Button with Objects</li>
    <br/>
    <ul>
        <li>Radio buttons can bind to object references:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Plan {
        id: string;
        name: string;
        price: number;
    }

    const plans: Plan[] = [
        { id: "basic",      name: "Basic",      price: 9.99  },
        { id: "pro",        name: "Pro",        price: 19.99 },
        { id: "enterprise", name: "Enterprise", price: 49.99 }
    ];

    let selectedPlan: Plan = $state(plans[0]);
&lt;/script&gt;

{#each plans as plan}
    &lt;label&gt;
        &lt;input type="radio" value={plan} bind:group={selectedPlan} /&gt;
        {plan.name} - ${plan.price}/month
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected: {selectedPlan.name} at ${selectedPlan.price}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Select Dropdown Binding</li>
    <br/>
    <ul>
        <li>Bind a <code>&lt;select&gt;</code> element to a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const selectedCountry: string = $state("");

    const countries: string[] = ["USA", "Canada", "UK", "Germany", "Japan"];
&lt;/script&gt;

&lt;select bind:value={selectedCountry}&gt;
    &lt;option value=""&gt;Select a country&lt;/option&gt;
    {#each countries as country}
        &lt;option value={country}&gt;{country}&lt;/option&gt;
    {/each}
&lt;/select&gt;

&lt;p&gt;Selected: {selectedCountry || "None"}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Select with Objects</li>
    <br/>
    <ul>
        <li>Select elements can bind to object values:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Country {
        code: string;
        name: string;
        population: number;
    }

    const countries: Country[] = [
        { code: "US", name: "United States", population: 331000000 },
        { code: "JP", name: "Japan",         population: 125800000 },
        { code: "DE", name: "Germany",       population: 83200000 }
    ];

    const selectedCountry: Country | undefined = $state(undefined);
&lt;/script&gt;

&lt;select bind:value={selectedCountry}&gt;
    &lt;option value={undefined}&gt;Select a country&lt;/option&gt;
    {#each countries as country}
        &lt;option value={country}&gt;{country.name}&lt;/option&gt;
    {/each}
&lt;/select&gt;

{#if selectedCountry}
    &lt;p&gt;{selectedCountry.name}: {selectedCountry.population.toLocaleString()} people&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Multiple Select Binding</li>
    <br/>
    <ul>
        <li>Bind a multi-select to an array:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const selectedSkills: string[] = $state([]);

    const skills: string[] = ["JavaScript", "TypeScript", "Python", "Rust", "Go"];
&lt;/script&gt;

&lt;select multiple bind:value={selectedSkills}&gt;
    {#each skills as skill}
        &lt;option value={skill}&gt;{skill}&lt;/option&gt;
    {/each}
&lt;/select&gt;

&lt;p&gt;Selected: {selectedSkills.join(", ") || "None"}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Hold Ctrl/Cmd to select multiple options.</li>
    </ul>
    <br/><br/>



    <li>Textarea Binding</li>
    <br/>
    <ul>
        <li>Bind a textarea's content:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const bio: string = $state("");
&lt;/script&gt;

&lt;textarea bind:value={bio} rows="4" cols="50"&gt;&lt;/textarea&gt;

&lt;p&gt;Character count: {bio.length}&lt;/p&gt;
&lt;p&gt;Preview:&lt;/p&gt;
&lt;pre&gt;{bio}&lt;/pre&gt;
</code></pre>
    <br/><br/>



    <li>Contenteditable Binding</li>
    <br/>
    <ul>
        <li>Bind to <code>contenteditable</code> elements using <code>textContent</code> or <code>innerHTML</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let plainText: string = $state("Edit this text");
    let richText: string = $state("&lt;b&gt;Bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt;");
&lt;/script&gt;

&lt;!-- Plain text binding --&gt;
&lt;div contenteditable="true" bind:textContent={plainText}&gt;&lt;/div&gt;
&lt;p&gt;Plain: {plainText}&lt;/p&gt;

&lt;!-- HTML binding --&gt;
&lt;div contenteditable="true" bind:innerHTML={richText}&gt;&lt;/div&gt;
&lt;p&gt;HTML: {richText}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>bind:textContent</code> — Gets/sets plain text only.</li>
        <li><code>bind:innerHTML</code> — Gets/sets HTML content.</li>
    </ul>
    <br/><br/>



    <li>Element Reference Binding (<code>bind:this</code>)</li>
    <br/>
    <ul>
        <li>Get a reference to a DOM element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { onMount } from "svelte";

    let inputElement: HTMLInputElement;
    let canvasElement: HTMLCanvasElement;

    onMount(() =&gt; {
        // Focus the input on mount
        inputElement.focus();

        // Draw on canvas
        const ctx = canvasElement.getContext("2d");
        if (ctx) {
            ctx.fillStyle = "blue";
            ctx.fillRect(10, 10, 100, 100);
        }
    });
&lt;/script&gt;

&lt;input bind:this={inputElement} placeholder="Auto-focused" /&gt;
&lt;canvas bind:this={canvasElement} width="200" height="150"&gt;&lt;/canvas&gt;
</code></pre>

    <ul>
        <li>The element is <code>undefined</code> until the component mounts.</li>
        <li>Use <code>onMount</code> or <code>$effect</code> to safely access the element.</li>
    </ul>
    <br/><br/>



    <li>Element Reference with Svelte 5</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <code>$effect</code> to work with element references:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let inputElement: HTMLInputElement | undefined = $state(undefined);

    $effect(() =&gt; {
        if (inputElement) {
            inputElement.focus();
        }
    });
&lt;/script&gt;

&lt;input bind:this={inputElement} placeholder="Auto-focused" /&gt;
</code></pre>
    <br/><br/>



    <li>Dimension Bindings</li>
    <br/>
    <ul>
        <li>Bind to an element's dimensions (read-only):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let clientWidth: number = $state(0);
    let clientHeight: number = $state(0);
    let offsetWidth: number = $state(0);
    let offsetHeight: number = $state(0);
&lt;/script&gt;

&lt;div
    bind:clientWidth
    bind:clientHeight
    bind:offsetWidth
    bind:offsetHeight
    style="padding: 20px; border: 5px solid black;"
&gt;
    &lt;p&gt;Resize the window to see changes&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Client: {clientWidth} x {clientHeight}&lt;/p&gt;
&lt;p&gt;Offset: {offsetWidth} x {offsetHeight}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>clientWidth/Height</code> — Content + padding (excluding border and scrollbar).</li>
        <li><code>offsetWidth/Height</code> — Content + padding + border.</li>
    </ul>
    <br/><br/>



    <li>Media Element Bindings</li>
    <br/>
    <ul>
        <li>Bind to audio and video element properties:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let videoElement: HTMLVideoElement;

    // Readonly bindings
    let duration: number = $state(0);
    let buffered: TimeRanges;
    let seekable: TimeRanges;
    let played: TimeRanges;
    let seeking: boolean = $state(false);
    let ended: boolean = $state(false);
    let readyState: number = $state(0);
    let videoWidth: number = $state(0);
    let videoHeight: number = $state(0);

    // Two-way bindings
    let currentTime: number = $state(0);
    let playbackRate: number = $state(1);
    let paused: boolean = $state(true);
    let volume: number = $state(1);
    let muted: boolean = $state(false);

    function formatTime(seconds: number): string {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
    }
&lt;/script&gt;

&lt;video
    bind:this={videoElement}
    bind:duration
    bind:currentTime
    bind:paused
    bind:volume
    bind:muted
    bind:playbackRate
    bind:seeking
    bind:ended
    src="video.mp4"
    width="400"
&gt;
    &lt;track kind="captions" /&gt;
&lt;/video&gt;

&lt;div&gt;
    &lt;button onclick={() =&gt; paused = !paused}&gt;
        {paused ? "Play" : "Pause"}
    &lt;/button&gt;
    &lt;span&gt;{formatTime(currentTime)} / {formatTime(duration)}&lt;/span&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;label&gt;
        Volume:
        &lt;input type="range" bind:value={volume} min="0" max="1" step="0.1" /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        &lt;input type="checkbox" bind:checked={muted} /&gt;
        Muted
    &lt;/label&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;label&gt;
        Speed:
        &lt;select bind:value={playbackRate}&gt;
            &lt;option value={0.5}&gt;0.5x&lt;/option&gt;
            &lt;option value={1}&gt;1x&lt;/option&gt;
            &lt;option value={1.5}&gt;1.5x&lt;/option&gt;
            &lt;option value={2}&gt;2x&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Window Bindings</li>
    <br/>
    <ul>
        <li>Bind to window properties using <code>&lt;svelte:window&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Readonly
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);
    let outerWidth: number = $state(0);
    let outerHeight: number = $state(0);
    let online: boolean = $state(true);

    // Two-way
    let scrollX: number = $state(0);
    let scrollY: number = $state(0);
&lt;/script&gt;

&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    bind:outerWidth
    bind:outerHeight
    bind:scrollX
    bind:scrollY
    bind:online
/&gt;

&lt;div style="position: fixed; top: 10px; right: 10px; background: white; padding: 10px;"&gt;
    &lt;p&gt;Window: {innerWidth} x {innerHeight}&lt;/p&gt;
    &lt;p&gt;Scroll: {scrollX}, {scrollY}&lt;/p&gt;
    &lt;p&gt;Online: {online ? "Yes" : "No"}&lt;/p&gt;
&lt;/div&gt;

&lt;button onclick={() =&gt; scrollY = 0}&gt;Scroll to top&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Document Bindings</li>
    <br/>
    <ul>
        <li>Bind to document properties using <code>&lt;svelte:document&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let activeElement: Element | null = $state(null);
    let fullscreenElement: Element | null = $state(null);
    let pointerLockElement: Element | null = $state(null);
    let visibilityState: DocumentVisibilityState = $state("visible");
&lt;/script&gt;

&lt;svelte:document
    bind:activeElement
    bind:fullscreenElement
    bind:pointerLockElement
    bind:visibilityState
/&gt;

&lt;p&gt;Active element: {activeElement?.tagName || "None"}&lt;/p&gt;
&lt;p&gt;Visibility: {visibilityState}&lt;/p&gt;

&lt;input placeholder="Focus me" /&gt;
&lt;button&gt;Or focus me&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Component Bindings</li>
    <br/>
    <ul>
        <li>Bind to a child component's exported values (Svelte 4):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let count: number = 0;

    export function reset(): void {
        count = 0;
    }
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;{count}&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let counterValue: number;
    let counterComponent: Counter;
&lt;/script&gt;

&lt;Counter bind:count={counterValue} bind:this={counterComponent} /&gt;

&lt;p&gt;Counter value: {counterValue}&lt;/p&gt;
&lt;button on:click={() =&gt; counterComponent.reset()}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Component Bindings (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <code>$bindable</code> for props that can be bound:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        count?: number;
    }

    let { count = $bindable(0) }: Props = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;{count}&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let counterValue: number = $state(0);
&lt;/script&gt;

&lt;Counter bind:count={counterValue} /&gt;

&lt;p&gt;Counter value: {counterValue}&lt;/p&gt;
&lt;button onclick={() =&gt; counterValue = 0}&gt;Reset&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$bindable()</code> marks a prop as bindable with an optional default value.</li>
        <li>Changes in either parent or child sync both ways.</li>
    </ul>
    <br/><br/>



    <li>Binding Shorthand</li>
    <br/>
    <ul>
        <li>When the variable name matches the property name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let value: string = $state("");
    let checked: boolean = $state(false);
    let clientWidth: number = $state(0);
    let innerWidth: number = $state(0);
&lt;/script&gt;

&lt;!-- These are equivalent: --&gt;
&lt;input bind:value={value} /&gt;
&lt;input bind:value /&gt;

&lt;input type="checkbox" bind:checked={checked} /&gt;
&lt;input type="checkbox" bind:checked /&gt;

&lt;div bind:clientWidth={clientWidth}&gt;...&lt;/div&gt;
&lt;div bind:clientWidth&gt;...&lt;/div&gt;

&lt;svelte:window bind:innerWidth={innerWidth} /&gt;
&lt;svelte:window bind:innerWidth /&gt;
</code></pre>
    <br/><br/>



    <li>Binding Summary</li>
    <br/>

    <table>
        <tr>
            <th>Element</th>
            <th>Binding</th>
            <th>Type</th>
        </tr>
        <tr>
            <td>Text input</td>
            <td><code>bind:value</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Number/Range input</td>
            <td><code>bind:value</code></td>
            <td><code>number</code></td>
        </tr>
        <tr>
            <td>Checkbox</td>
            <td><code>bind:checked</code></td>
            <td><code>boolean</code></td>
        </tr>
        <tr>
            <td>Checkbox group</td>
            <td><code>bind:group</code></td>
            <td><code>Array</code></td>
        </tr>
        <tr>
            <td>Radio group</td>
            <td><code>bind:group</code></td>
            <td>Single value</td>
        </tr>
        <tr>
            <td>Select</td>
            <td><code>bind:value</code></td>
            <td>Any</td>
        </tr>
        <tr>
            <td>Multi-select</td>
            <td><code>bind:value</code></td>
            <td><code>Array</code></td>
        </tr>
        <tr>
            <td>Textarea</td>
            <td><code>bind:value</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Contenteditable</td>
            <td><code>bind:textContent</code>, <code>bind:innerHTML</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Any element</td>
            <td><code>bind:this</code></td>
            <td><code>HTMLElement</code></td>
        </tr>
        <tr>
            <td>Any element</td>
            <td><code>bind:clientWidth</code>, etc.</td>
            <td><code>number</code> (readonly)</td>
        </tr>
        <tr>
            <td>Audio/Video</td>
            <td><code>bind:currentTime</code>, <code>bind:paused</code>, etc.</td>
            <td>Various</td>
        </tr>
        <tr>
            <td><code>&lt;svelte:window&gt;</code></td>
            <td><code>bind:innerWidth</code>, <code>bind:scrollY</code>, etc.</td>
            <td><code>number</code></td>
        </tr>
        <tr>
            <td>Component (Svelte 5)</td>
            <td><code>bind:prop</code> with <code>$bindable</code></td>
            <td>Any</td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-classes">Svelte Classes</h3>
<ol>
    <li>What Are Class Directives?</li>
    <br/>
    <ul>
        <li>Svelte provides special syntax for dynamically adding and removing CSS classes.</li>
        <br/>
        <li>The <code>class:</code> directive conditionally applies a class based on a boolean expression.</li>
        <br/>
        <li>This is cleaner than manually building class strings.</li>
    </ul>
    <br/><br/>



    <li>Basic Class Attribute</li>
    <br/>
    <ul>
        <li>You can use the standard <code>class</code> attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let className: string = "button primary";
&lt;/script&gt;

&lt;button class="button"&gt;Static class&lt;/button&gt;
&lt;button class={className}&gt;Dynamic class&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Conditional Classes with Ternary</li>
    <br/>
    <ul>
        <li>Use template expressions to conditionally apply classes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(false);
    let isDisabled: boolean = $state(false);
&lt;/script&gt;

&lt;button class={isActive ? "active" : ""}&gt;
    Toggle
&lt;/button&gt;

&lt;button class={isActive ? "btn active" : "btn"}&gt;
    With base class
&lt;/button&gt;

&lt;button class="btn {isActive ? 'active' : ''} {isDisabled ? 'disabled' : ''}"&gt;
    Multiple conditions
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This works but can become verbose with multiple conditions.</li>
    </ul>
    <br/><br/>



    <li>The <code>class:</code> Directive</li>
    <br/>
    <ul>
        <li>The <code>class:</code> directive provides a cleaner syntax:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(false);
&lt;/script&gt;

&lt;button class:active={isActive}&gt;
    Toggle
&lt;/button&gt;

&lt;!-- The class "active" is added when isActive is true --&gt;

&lt;style&gt;
    .active {
        background-color: #4CAF50;
        color: white;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li>Syntax: <code>class:classname={condition}</code></li>
        <li>When <code>condition</code> is truthy, <code>classname</code> is added.</li>
    </ul>
    <br/><br/>



    <li>Shorthand <code>class:</code> Directive</li>
    <br/>
    <ul>
        <li>When the class name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let active: boolean = $state(false);
    let disabled: boolean = $state(false);
    let hidden: boolean = $state(false);
&lt;/script&gt;

&lt;!-- These are equivalent: --&gt;
&lt;button class:active={active}&gt;Long form&lt;/button&gt;
&lt;button class:active&gt;Shorthand&lt;/button&gt;

&lt;!-- Multiple shorthand classes --&gt;
&lt;button class:active class:disabled class:hidden&gt;
    Multiple
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Multiple Class Directives</li>
    <br/>
    <ul>
        <li>Apply multiple conditional classes to one element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(true);
    let isLarge: boolean = $state(false);
    let isPrimary: boolean = $state(true);
    let isDisabled: boolean = $state(false);
&lt;/script&gt;

&lt;button
    class="btn"
    class:active={isActive}
    class:large={isLarge}
    class:primary={isPrimary}
    class:disabled={isDisabled}
&gt;
    Styled Button
&lt;/button&gt;

&lt;style&gt;
    .btn {
        padding: 10px 20px;
        border: none;
        cursor: pointer;
    }
    .active { border: 2px solid blue; }
    .large { font-size: 1.5rem; padding: 15px 30px; }
    .primary { background-color: #007bff; color: white; }
    .disabled { opacity: 0.5; cursor: not-allowed; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Combining <code>class</code> and <code>class:</code></li>
    <br/>
    <ul>
        <li>Use both static classes and conditional class directives together:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let variant: string = $state("primary");
    let isLoading: boolean = $state(false);
    let isFullWidth: boolean = $state(false);
&lt;/script&gt;

&lt;button
    class="btn btn-{variant}"
    class:loading={isLoading}
    class:full-width={isFullWidth}
&gt;
    {isLoading ? "Loading..." : "Submit"}
&lt;/button&gt;

&lt;style&gt;
    .btn { padding: 10px 20px; }
    .btn-primary { background: blue; color: white; }
    .btn-secondary { background: gray; color: white; }
    .btn-danger { background: red; color: white; }
    .loading { opacity: 0.7; pointer-events: none; }
    .full-width { width: 100%; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Directive with Expressions</li>
    <br/>
    <ul>
        <li>The condition can be any JavaScript expression:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let status: string = $state("pending");
    let items: string[] = $state(["a", "b"]);
&lt;/script&gt;

&lt;!-- Comparison expressions --&gt;
&lt;div class:warning={count &gt; 5}&gt;Count warning&lt;/div&gt;
&lt;div class:danger={count &gt; 10}&gt;Count danger&lt;/div&gt;

&lt;!-- Equality checks --&gt;
&lt;div class:success={status === "completed"}&gt;Status&lt;/div&gt;
&lt;div class:pending={status === "pending"}&gt;Status&lt;/div&gt;

&lt;!-- Array/Object checks --&gt;
&lt;div class:empty={items.length === 0}&gt;Items&lt;/div&gt;
&lt;div class:has-items={items.length &gt; 0}&gt;Items&lt;/div&gt;

&lt;!-- Logical expressions --&gt;
&lt;div class:special={count &gt; 5 && status === "completed"}&gt;
    Special
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Dynamic Class Names</li>
    <br/>
    <ul>
        <li>Build class names dynamically using template literals:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let size: "sm" | "md" | "lg" = $state("md");
    let color: "red" | "green" | "blue" = $state("blue");
    let theme: "light" | "dark" = $state("light");
&lt;/script&gt;

&lt;button class="btn btn-{size} btn-{color}"&gt;
    Dynamic Size &amp; Color
&lt;/button&gt;

&lt;div class="container theme-{theme}"&gt;
    Themed Container
&lt;/div&gt;

&lt;!-- With conditional fallback --&gt;
&lt;div class="icon icon-{status || 'default'}"&gt;
    Icon
&lt;/div&gt;

&lt;style&gt;
    .btn-sm { padding: 5px 10px; font-size: 0.8rem; }
    .btn-md { padding: 10px 20px; font-size: 1rem; }
    .btn-lg { padding: 15px 30px; font-size: 1.2rem; }
    .btn-red { background: red; }
    .btn-green { background: green; }
    .btn-blue { background: blue; }
    .theme-light { background: white; color: black; }
    .theme-dark { background: #333; color: white; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Object Pattern</li>
    <br/>
    <ul>
        <li>Create a utility function for complex class logic:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Utility function to build class string from object
    function classNames(classes: Record&lt;string, boolean&gt;): string {
        return Object.entries(classes)
            .filter(([, value]) =&gt; value)
            .map(([key]) =&gt; key)
            .join(" ");
    }

    let isActive: boolean = $state(true);
    let isDisabled: boolean = $state(false);
    let size: string = $state("large");

    let buttonClasses = $derived(classNames({
        "btn": true,
        "btn-active": isActive,
        "btn-disabled": isDisabled,
        "btn-large": size === "large",
        "btn-small": size === "small"
    }));
&lt;/script&gt;

&lt;button class={buttonClasses}&gt;
    Dynamic Classes
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Using <code>clsx</code> or <code>classnames</code> Library</li>
    <br/>
    <ul>
        <li>For complex class logic, use a utility library like <code>clsx</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm install clsx
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import clsx from "clsx";

    let isActive: boolean = $state(false);
    let isDisabled: boolean = $state(false);
    let variant: "primary" | "secondary" = $state("primary");

    let classes = $derived(clsx(
        "btn",
        `btn-${variant}`,
        {
            "active": isActive,
            "disabled": isDisabled
        }
    ));
&lt;/script&gt;

&lt;button class={classes}&gt;
    Using clsx
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>clsx</code> handles strings, objects, arrays, and falsy values gracefully.</li>
    </ul>
    <br/><br/>



    <li>Classes in Loops</li>
    <br/>
    <ul>
        <li>Apply conditional classes to items in a loop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Item {
        id: number;
        name: string;
        completed: boolean;
        priority: "low" | "medium" | "high";
    }

    let items: Item[] = $state([
        { id: 1, name: "Task 1", completed: false, priority: "high" },
        { id: 2, name: "Task 2", completed: true, priority: "low" },
        { id: 3, name: "Task 3", completed: false, priority: "medium" }
    ]);

    let selectedId: number | null = $state(null);
&lt;/script&gt;

&lt;ul&gt;
    {#each items as item (item.id)}
        &lt;li
            class="item priority-{item.priority}"
            class:completed={item.completed}
            class:selected={selectedId === item.id}
            onclick={() =&gt; selectedId = item.id}
        &gt;
            {item.name}
        &lt;/li&gt;
    {/each}
&lt;/ul&gt;

&lt;style&gt;
    .item { padding: 10px; cursor: pointer; }
    .completed { text-decoration: line-through; opacity: 0.6; }
    .selected { background-color: #e0e0e0; }
    .priority-low { border-left: 3px solid green; }
    .priority-medium { border-left: 3px solid orange; }
    .priority-high { border-left: 3px solid red; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Global Classes vs Scoped Classes</li>
    <br/>
    <ul>
        <li>Svelte styles are <u>scoped by default</u> — they only apply to the current component.</li>
        <br/>
        <li>Use <code>:global()</code> to apply styles globally:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isDark: boolean = $state(false);
&lt;/script&gt;

&lt;div class="container" class:dark={isDark}&gt;
    &lt;p&gt;This is styled locally.&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    /* Scoped to this component */
    .container {
        padding: 20px;
        background: white;
    }

    .dark {
        background: #333;
        color: white;
    }

    /* Global style - affects all elements */
    :global(.global-class) {
        font-weight: bold;
    }

    /* Global modifier within scoped context */
    .container :global(.highlight) {
        background-color: yellow;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Passing Classes to Child Components</li>
    <br/>
    <ul>
        <li>Accept a <code>class</code> prop to allow parent customization:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        variant?: "primary" | "secondary";
        class?: string;
    }

    let { variant = "primary", class: className = "" }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant} {className}"&gt;
    &lt;slot /&gt;
&lt;/button&gt;

&lt;style&gt;
    .btn { padding: 10px 20px; border: none; cursor: pointer; }
    .btn-primary { background: blue; color: white; }
    .btn-secondary { background: gray; color: white; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button class="my-custom-class"&gt;Click me&lt;/Button&gt;
&lt;Button variant="secondary" class="full-width"&gt;Submit&lt;/Button&gt;

&lt;style&gt;
    :global(.my-custom-class) {
        margin: 10px;
    }
    :global(.full-width) {
        width: 100%;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Using <code>$$restProps</code> for Class Forwarding (Svelte 4)</li>
    <br/>
    <ul>
        <li>Forward all attributes including <code>class</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Input.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let label: string = "";
&lt;/script&gt;

&lt;label&gt;
    {label}
    &lt;input {...$$restProps} /&gt;
&lt;/label&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Input label="Email" class="form-input" type="email" placeholder="Enter email" /&gt;
</code></pre>
    <br/><br/>



    <li>Using Rest Props for Class Forwarding (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use rest props destructuring:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Input.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    import type { HTMLInputAttributes } from "svelte/elements";

    interface Props extends HTMLInputAttributes {
        label?: string;
    }

    let { label = "", ...rest }: Props = $props();
&lt;/script&gt;

&lt;label&gt;
    {label}
    &lt;input {...rest} /&gt;
&lt;/label&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Input label="Email" class="form-input" type="email" placeholder="Enter email" /&gt;
</code></pre>
    <br/><br/>



    <li>Animated Class Transitions</li>
    <br/>
    <ul>
        <li>Combine class toggling with CSS transitions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let expanded: boolean = $state(false);
    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; expanded = !expanded}&gt;
    Toggle Expand
&lt;/button&gt;

&lt;div class="box" class:expanded&gt;
    &lt;p&gt;Content here&lt;/p&gt;
&lt;/div&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle Visibility
&lt;/button&gt;

&lt;div class="fade-box" class:visible&gt;
    &lt;p&gt;Fading content&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    .box {
        height: 50px;
        overflow: hidden;
        background: #f0f0f0;
        transition: height 0.3s ease;
    }

    .box.expanded {
        height: 200px;
    }

    .fade-box {
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .fade-box.visible {
        opacity: 1;
        transform: translateY(0);
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Directive Summary</li>
    <br/>

    <table>
        <tr>
            <th>Syntax</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><code>class="name"</code></td>
            <td>Static class</td>
            <td><code>&lt;div class="container"&gt;</code></td>
        </tr>
        <tr>
            <td><code>class={expr}</code></td>
            <td>Dynamic class string</td>
            <td><code>&lt;div class={className}&gt;</code></td>
        </tr>
        <tr>
            <td><code>class="a {b}"</code></td>
            <td>Mixed static + dynamic</td>
            <td><code>&lt;div class="btn {variant}"&gt;</code></td>
        </tr>
        <tr>
            <td><code>class:name={cond}</code></td>
            <td>Conditional class</td>
            <td><code>&lt;div class:active={isActive}&gt;</code></td>
        </tr>
        <tr>
            <td><code>class:name</code></td>
            <td>Shorthand (name === var)</td>
            <td><code>&lt;div class:active&gt;</code></td>
        </tr>
        <tr>
            <td>Multiple <code>class:</code></td>
            <td>Multiple conditionals</td>
            <td><code>&lt;div class:a class:b class:c&gt;</code></td>
        </tr>
        <tr>
            <td><code>:global()</code></td>
            <td>Escape scoping</td>
            <td><code>:global(.class) { }</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-actions">Svelte Actions</h3>
<ol>
    <li>What Are Actions?</li>
    <br/>
    <ul>
        <li><b>Actions</b> are functions that run when an element is mounted to the DOM.</li>
        <br/>
        <li>They provide a way to add <u>reusable behavior</u> to elements without creating wrapper components.</li>
        <br/>
        <li>Actions are applied using the <code>use:</code> directive.</li>
    </ul>
    <br/><br/>



    <li>Basic Action Syntax</li>
    <br/>
    <ul>
        <li>An action is a function that receives the element as its first argument:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function greet(node: HTMLElement): void {
        console.log("Element mounted:", node);
    }
&lt;/script&gt;

&lt;div use:greet&gt;
    Hello, World!
&lt;/div&gt;
</code></pre>

    <ul>
        <li>The function runs once when the element is added to the DOM.</li>
    </ul>
    <br/><br/>



    <li>Action with Cleanup</li>
    <br/>
    <ul>
        <li>Return an object with a <code>destroy</code> method to clean up when the element is removed:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    function logger(node: HTMLElement): ActionReturn {
        console.log("Mounted:", node);

        return {
            destroy() {
                console.log("Destroyed:", node);
            }
        };
    }
&lt;/script&gt;

&lt;div use:logger&gt;
    Watch the console
&lt;/div&gt;
</code></pre>

    <ul>
        <li>The <code>destroy</code> function is called when the element is removed from the DOM.</li>
        <li>Use it to remove event listeners, clear timers, or clean up resources.</li>
    </ul>
    <br/><br/>



    <li>Action with Parameters</li>
    <br/>
    <ul>
        <li>Actions can accept parameters as the second argument:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface TooltipParams {
        text: string;
        position?: "top" | "bottom" | "left" | "right";
    }

    function tooltip(node: HTMLElement, params: TooltipParams): ActionReturn&lt;TooltipParams&gt; {
        const { text, position = "top" } = params;

        node.setAttribute("title", text);
        node.setAttribute("data-position", position);

        console.log(`Tooltip: "${text}" at ${position}`);

        return {
            destroy() {
                node.removeAttribute("title");
                node.removeAttribute("data-position");
            }
        };
    }
&lt;/script&gt;

&lt;button use:tooltip={{ text: "Click to submit", position: "bottom" }}&gt;
    Submit
&lt;/button&gt;

&lt;button use:tooltip={{ text: "Cancel operation" }}&gt;
    Cancel
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Action with Update</li>
    <br/>
    <ul>
        <li>Return an <code>update</code> method to react when parameters change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ColorParams {
        color: string;
    }

    function backgroundColor(node: HTMLElement, params: ColorParams): ActionReturn&lt;ColorParams&gt; {
        node.style.backgroundColor = params.color;

        return {
            update(newParams: ColorParams) {
                node.style.backgroundColor = newParams.color;
            },
            destroy() {
                node.style.backgroundColor = "";
            }
        };
    }

    const color: string = $state("#ff0000");
&lt;/script&gt;

&lt;input type="color" bind:value={color} /&gt;

&lt;div use:backgroundColor={{ color }} style="padding: 20px;"&gt;
    Dynamic background color
&lt;/div&gt;
</code></pre>

    <ul>
        <li>The <code>update</code> function is called whenever the parameters change.</li>
    </ul>
    <br/><br/>



    <li>Typing Actions with <code>ActionReturn</code></li>
    <br/>
    <ul>
        <li>Use the <code>ActionReturn</code> type for proper TypeScript support:</li>
    </ul>

<pre><code class="language-ts line-numbers">import type { ActionReturn } from "svelte/action";

// Action without parameters
function simpleAction(node: HTMLElement): ActionReturn {
    return {
        destroy() {}
    };
}

// Action with required parameters
function paramAction(node: HTMLElement, params: string): ActionReturn&lt;string&gt; {
    return {
        update(newParams: string) {},
        destroy() {}
    };
}

// Action with optional parameters
function optionalAction(node: HTMLElement, params?: number): ActionReturn&lt;number | undefined&gt; {
    return {
        update(newParams?: number) {},
        destroy() {}
    };
}
</code></pre>
    <br/><br/>



    <li>Using the <code>Action</code> Type</li>
    <br/>
    <ul>
        <li>You can also use the <code>Action</code> type to define action signatures:</li>
    </ul>

<pre><code class="language-ts line-numbers">import type { Action } from "svelte/action";

interface FocusTrapParams {
    enabled?: boolean;
}

const focusTrap: Action&lt;HTMLElement, FocusTrapParams&gt; = (node, params) =&gt; {
    // Implementation
    return {
        update(newParams) {
            // Handle updates
        },
        destroy() {
            // Cleanup
        }
    };
};
</code></pre>
    <br/><br/>



    <li>Click Outside Action</li>
    <br/>
    <ul>
        <li>A common action to detect clicks outside an element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ClickOutsideParams {
        onClickOutside: () =&gt; void;
    }

    function clickOutside(node: HTMLElement, params: ClickOutsideParams): ActionReturn&lt;ClickOutsideParams&gt; {
        let { onClickOutside } = params;

        function handleClick(event: MouseEvent): void {
            if (!node.contains(event.target as Node)) {
                onClickOutside();
            }
        }

        document.addEventListener("click", handleClick, true);

        return {
            update(newParams: ClickOutsideParams) {
                onClickOutside = newParams.onClickOutside;
            },
            destroy() {
                document.removeEventListener("click", handleClick, true);
            }
        };
    }

    let showDropdown: boolean = $state(false);
&lt;/script&gt;

&lt;div class="dropdown-container"&gt;
    &lt;button onclick={() =&gt; showDropdown = !showDropdown}&gt;
        Toggle Dropdown
    &lt;/button&gt;

    {#if showDropdown}
        &lt;div
            class="dropdown"
            use:clickOutside={{ onClickOutside: () =&gt; showDropdown = false }}
        &gt;
            &lt;p&gt;Dropdown content&lt;/p&gt;
            &lt;p&gt;Click outside to close&lt;/p&gt;
        &lt;/div&gt;
    {/if}
&lt;/div&gt;

&lt;style&gt;
    .dropdown-container { position: relative; }
    .dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        background: white;
        border: 1px solid #ccc;
        padding: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Auto Focus Action</li>
    <br/>
    <ul>
        <li>Automatically focus an element when mounted:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface FocusParams {
        delay?: number;
        select?: boolean;
    }

    function autoFocus(node: HTMLElement, params: FocusParams = {}): ActionReturn&lt;FocusParams&gt; {
        const { delay = 0, select = false } = params;

        const timeoutId = setTimeout(() =&gt; {
            node.focus();
            if (select && node instanceof HTMLInputElement) {
                node.select();
            }
        }, delay);

        return {
            destroy() {
                clearTimeout(timeoutId);
            }
        };
    }

    let showModal: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; showModal = true}&gt;Open Modal&lt;/button&gt;

{#if showModal}
    &lt;div class="modal"&gt;
        &lt;input
            use:autoFocus={{ select: true }}
            value="Selected text"
        /&gt;
        &lt;button onclick={() =&gt; showModal = false}&gt;Close&lt;/button&gt;
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Longpress Action</li>
    <br/>
    <ul>
        <li>Detect long press gestures:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface LongpressParams {
        duration?: number;
        onLongpress: () =&gt; void;
    }

    function longpress(node: HTMLElement, params: LongpressParams): ActionReturn&lt;LongpressParams&gt; {
        let { duration = 500, onLongpress } = params;
        let timeoutId: ReturnType&lt;typeof setTimeout&gt;;

        function handleMouseDown(): void {
            timeoutId = setTimeout(() =&gt; {
                onLongpress();
            }, duration);
        }

        function handleMouseUp(): void {
            clearTimeout(timeoutId);
        }

        node.addEventListener("mousedown", handleMouseDown);
        node.addEventListener("mouseup", handleMouseUp);
        node.addEventListener("mouseleave", handleMouseUp);

        return {
            update(newParams: LongpressParams) {
                duration = newParams.duration ?? 500;
                onLongpress = newParams.onLongpress;
            },
            destroy() {
                clearTimeout(timeoutId);
                node.removeEventListener("mousedown", handleMouseDown);
                node.removeEventListener("mouseup", handleMouseUp);
                node.removeEventListener("mouseleave", handleMouseUp);
            }
        };
    }

    let message: string = $state("Press and hold the button");
&lt;/script&gt;

&lt;button use:longpress={{ duration: 1000, onLongpress: () =&gt; message = "Longpress detected!" }}&gt;
    Hold me
&lt;/button&gt;

&lt;p&gt;{message}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Lazy Load Image Action</li>
    <br/>
    <ul>
        <li>Lazy load images using Intersection Observer:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface LazyLoadParams {
        src: string;
        placeholder?: string;
    }

    function lazyLoad(node: HTMLImageElement, params: LazyLoadParams): ActionReturn&lt;LazyLoadParams&gt; {
        let { src, placeholder = "" } = params;

        // Set placeholder initially
        if (placeholder) {
            node.src = placeholder;
        }

        const observer = new IntersectionObserver(
            (entries) =&gt; {
                entries.forEach((entry) =&gt; {
                    if (entry.isIntersecting) {
                        node.src = src;
                        observer.unobserve(node);
                    }
                });
            },
            { rootMargin: "50px" }
        );

        observer.observe(node);

        return {
            update(newParams: LazyLoadParams) {
                src = newParams.src;
                if (newParams.placeholder) {
                    placeholder = newParams.placeholder;
                }
            },
            destroy() {
                observer.disconnect();
            }
        };
    }

    const images: string[] = [
        "https://picsum.photos/400/300?1",
        "https://picsum.photos/400/300?2",
        "https://picsum.photos/400/300?3"
    ];
&lt;/script&gt;

{#each images as src, i}
    &lt;img
        use:lazyLoad={{ src, placeholder: "placeholder.jpg" }}
        alt="Lazy loaded image {i + 1}"
        width="400"
        height="300"
    /&gt;
{/each}
</code></pre>
    <br/><br/>



    <li>Portal Action</li>
    <br/>
    <ul>
        <li>Move an element to a different location in the DOM:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface PortalParams {
        target?: string | HTMLElement;
    }

    function portal(node: HTMLElement, params: PortalParams = {}): ActionReturn&lt;PortalParams&gt; {
        let targetEl: HTMLElement;

        function update(newParams: PortalParams): void {
            const { target = "body" } = newParams;

            if (typeof target === "string") {
                targetEl = document.querySelector(target) ?? document.body;
            } else {
                targetEl = target;
            }

            targetEl.appendChild(node);
        }

        update(params);

        return {
            update,
            destroy() {
                node.remove();
            }
        };
    }

    let showModal: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; showModal = true}&gt;Open Modal&lt;/button&gt;

{#if showModal}
    &lt;div class="modal-overlay" use:portal&gt;
        &lt;div class="modal-content"&gt;
            &lt;h2&gt;Modal Title&lt;/h2&gt;
            &lt;p&gt;This is rendered at the end of body.&lt;/p&gt;
            &lt;button onclick={() =&gt; showModal = false}&gt;Close&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
{/if}

&lt;style&gt;
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Resize Observer Action</li>
    <br/>
    <ul>
        <li>Track element size changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ResizeParams {
        onResize: (width: number, height: number) =&gt; void;
    }

    function resize(node: HTMLElement, params: ResizeParams): ActionReturn&lt;ResizeParams&gt; {
        let { onResize } = params;

        const observer = new ResizeObserver((entries) =&gt; {
            for (const entry of entries) {
                const { width, height } = entry.contentRect;
                onResize(width, height);
            }
        });

        observer.observe(node);

        return {
            update(newParams: ResizeParams) {
                onResize = newParams.onResize;
            },
            destroy() {
                observer.disconnect();
            }
        };
    }

    let width: number = $state(0);
    let height: number = $state(0);
&lt;/script&gt;

&lt;div
    class="resizable"
    use:resize={{ onResize: (w, h) =&gt; { width = w; height = h; } }}
&gt;
    &lt;p&gt;Resize me!&lt;/p&gt;
    &lt;p&gt;{width.toFixed(0)} x {height.toFixed(0)}&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    .resizable {
        resize: both;
        overflow: auto;
        border: 2px solid #333;
        padding: 20px;
        min-width: 100px;
        min-height: 100px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Intersection Observer Action</li>
    <br/>
    <ul>
        <li>Detect when an element enters or leaves the viewport:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface InViewParams {
        onEnter?: () =&gt; void;
        onLeave?: () =&gt; void;
        threshold?: number;
        once?: boolean;
    }

    function inView(node: HTMLElement, params: InViewParams = {}): ActionReturn&lt;InViewParams&gt; {
        let { onEnter, onLeave, threshold = 0, once = false } = params;

        const observer = new IntersectionObserver(
            (entries) =&gt; {
                entries.forEach((entry) =&gt; {
                    if (entry.isIntersecting) {
                        onEnter?.();
                        if (once) {
                            observer.unobserve(node);
                        }
                    } else {
                        onLeave?.();
                    }
                });
            },
            { threshold }
        );

        observer.observe(node);

        return {
            update(newParams: InViewParams) {
                onEnter = newParams.onEnter;
                onLeave = newParams.onLeave;
            },
            destroy() {
                observer.disconnect();
            }
        };
    }

    let isVisible: boolean = $state(false);
&lt;/script&gt;

&lt;div style="height: 150vh;"&gt;
    &lt;p&gt;Scroll down...&lt;/p&gt;
&lt;/div&gt;

&lt;div
    class="observed"
    class:visible={isVisible}
    use:inView={{
        onEnter: () =&gt; isVisible = true,
        onLeave: () =&gt; isVisible = false,
        threshold: 0.5
    }}
&gt;
    I'm being observed!
&lt;/div&gt;

&lt;style&gt;
    .observed {
        padding: 40px;
        background: #eee;
        transition: background 0.3s;
    }
    .observed.visible {
        background: #4CAF50;
        color: white;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Third-Party Library Integration</li>
    <br/>
    <ul>
        <li>Actions are ideal for integrating third-party libraries:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";
    // Assuming tippy.js is installed
    // import tippy, { type Instance, type Props } from "tippy.js";

    interface TippyParams {
        content: string;
        placement?: "top" | "bottom" | "left" | "right";
    }

    function tippyAction(node: HTMLElement, params: TippyParams): ActionReturn&lt;TippyParams&gt; {
        // const instance: Instance = tippy(node, {
        //     content: params.content,
        //     placement: params.placement ?? "top"
        // });

        // Simulated for demonstration
        node.title = params.content;

        return {
            update(newParams: TippyParams) {
                // instance.setContent(newParams.content);
                // instance.setProps({ placement: newParams.placement });
                node.title = newParams.content;
            },
            destroy() {
                // instance.destroy();
                node.removeAttribute("title");
            }
        };
    }
&lt;/script&gt;

&lt;button use:tippyAction={{ content: "Hello Tooltip!", placement: "bottom" }}&gt;
    Hover me
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Copy to Clipboard Action</li>
    <br/>
    <ul>
        <li>Copy text to clipboard on click:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface CopyParams {
        text: string;
        onCopy?: () =&gt; void;
        onError?: (error: Error) =&gt; void;
    }

    function copy(node: HTMLElement, params: CopyParams): ActionReturn&lt;CopyParams&gt; {
        let { text, onCopy, onError } = params;

        async function handleClick(): Promise&lt;void&gt; {
            try {
                await navigator.clipboard.writeText(text);
                onCopy?.();
            } catch (err) {
                onError?.(err as Error);
            }
        }

        node.addEventListener("click", handleClick);

        return {
            update(newParams: CopyParams) {
                text = newParams.text;
                onCopy = newParams.onCopy;
                onError = newParams.onError;
            },
            destroy() {
                node.removeEventListener("click", handleClick);
            }
        };
    }

    let copied: boolean = $state(false);
    const textToCopy: string = "Hello, World!";

    function handleCopy(): void {
        copied = true;
        setTimeout(() =&gt; copied = false, 2000);
    }
&lt;/script&gt;

&lt;code&gt;{textToCopy}&lt;/code&gt;

&lt;button use:copy={{ text: textToCopy, onCopy: handleCopy }}&gt;
    {copied ? "Copied!" : "Copy"}
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Shortcut / Hotkey Action</li>
    <br/>
    <ul>
        <li>Add keyboard shortcuts to elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ShortcutParams {
        key: string;
        ctrl?: boolean;
        shift?: boolean;
        alt?: boolean;
        onTrigger: () =&gt; void;
    }

    function shortcut(node: HTMLElement, params: ShortcutParams): ActionReturn&lt;ShortcutParams&gt; {
        let { key, ctrl = false, shift = false, alt = false, onTrigger } = params;

        function handleKeyDown(event: KeyboardEvent): void {
            if (
                event.key.toLowerCase() === key.toLowerCase() &&
                event.ctrlKey === ctrl &&
                event.shiftKey === shift &&
                event.altKey === alt
            ) {
                event.preventDefault();
                onTrigger();
            }
        }

        window.addEventListener("keydown", handleKeyDown);

        return {
            update(newParams: ShortcutParams) {
                key = newParams.key;
                ctrl = newParams.ctrl ?? false;
                shift = newParams.shift ?? false;
                alt = newParams.alt ?? false;
                onTrigger = newParams.onTrigger;
            },
            destroy() {
                window.removeEventListener("keydown", handleKeyDown);
            }
        };
    }

    let count: number = $state(0);
&lt;/script&gt;

&lt;div use:shortcut={{ key: "k", ctrl: true, onTrigger: () =&gt; count++ }}&gt;
    &lt;p&gt;Press Ctrl+K to increment: {count}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Multiple Actions on One Element</li>
    <br/>
    <ul>
        <li>Apply multiple actions to a single element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    function logMount(node: HTMLElement): ActionReturn {
        console.log("Mounted");
        return { destroy() { console.log("Destroyed"); } };
    }

    function addBorder(node: HTMLElement, color: string): ActionReturn&lt;string&gt; {
        node.style.border = `2px solid ${color}`;
        return {
            update(newColor: string) {
                node.style.border = `2px solid ${newColor}`;
            },
            destroy() {
                node.style.border = "";
            }
        };
    }

    function autoFocus(node: HTMLElement): ActionReturn {
        node.focus();
        return {};
    }
&lt;/script&gt;

&lt;input
    use:logMount
    use:addBorder={"blue"}
    use:autoFocus
    placeholder="Multiple actions"
/&gt;
</code></pre>
    <br/><br/>



    <li>Actions Summary</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Description</th>
            <th>Syntax</th>
        </tr>
        <tr>
            <td>Basic action</td>
            <td>Function runs on mount</td>
            <td><code>use:action</code></td>
        </tr>
        <tr>
            <td>With parameter</td>
            <td>Pass data to action</td>
            <td><code>use:action={params}</code></td>
        </tr>
        <tr>
            <td><code>destroy</code></td>
            <td>Cleanup on unmount</td>
            <td><code>return { destroy() {} }</code></td>
        </tr>
        <tr>
            <td><code>update</code></td>
            <td>React to param changes</td>
            <td><code>return { update(p) {} }</code></td>
        </tr>
        <tr>
            <td>Type (function)</td>
            <td>Action return type</td>
            <td><code>ActionReturn&lt;Params&gt;</code></td>
        </tr>
        <tr>
            <td>Type (signature)</td>
            <td>Full action type</td>
            <td><code>Action&lt;Element, Params&gt;</code></td>
        </tr>
        <tr>
            <td>Multiple actions</td>
            <td>Combine on one element</td>
            <td><code>use:a use:b use:c</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-transitions">Svelte Transitions</h3>
<ol>
    <li>What Are Transitions?</li>
    <br/>
    <ul>
        <li><b>Transitions</b> are animations that play when elements are added to or removed from the DOM.</li>
        <br/>
        <li>Svelte provides built-in transitions and the ability to create custom ones.</li>
        <br/>
        <li>Transitions make UI changes feel smooth and polished.</li>
        <br/>
        <li>Key concepts:
            <ul>
                <li><code>transition:</code> — Plays on both enter and exit</li>
                <li><code>in:</code> — Plays only on enter</li>
                <li><code>out:</code> — Plays only on exit</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Built-in Transitions</li>
    <br/>
    <ul>
        <li>Svelte provides several built-in transitions in <code>svelte/transition</code>:</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Transition</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>fade</code></td>
            <td>Fades opacity in/out</td>
        </tr>
        <tr>
            <td><code>blur</code></td>
            <td>Fades with blur effect</td>
        </tr>
        <tr>
            <td><code>fly</code></td>
            <td>Flies in from a direction</td>
        </tr>
        <tr>
            <td><code>slide</code></td>
            <td>Slides vertically</td>
        </tr>
        <tr>
            <td><code>scale</code></td>
            <td>Scales size in/out</td>
        </tr>
        <tr>
            <td><code>draw</code></td>
            <td>Draws SVG paths</td>
        </tr>
        <tr>
            <td><code>crossfade</code></td>
            <td>Morphs between elements</td>
        </tr>
    </table>
    <br/><br/>



    <li>Fade Transition</li>
    <br/>
    <ul>
        <li>The simplest transition — fades opacity:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;p transition:fade&gt;
        This fades in and out
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li>With parameters:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;p transition:fade={{ duration: 500, delay: 100 }}&gt;
        Slower fade with delay
    &lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Fly Transition</li>
    <br/>
    <ul>
        <li>Animates position and opacity:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;!-- Fly from top --&gt;
    &lt;p transition:fly={{ y: -50, duration: 300 }}&gt;
        Flies from top
    &lt;/p&gt;

    &lt;!-- Fly from left --&gt;
    &lt;p transition:fly={{ x: -200, duration: 300 }}&gt;
        Flies from left
    &lt;/p&gt;

    &lt;!-- Fly with opacity control --&gt;
    &lt;p transition:fly={{ y: 100, opacity: 0.5, duration: 400 }}&gt;
        Partial opacity fly
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>x</code>, <code>y</code>, <code>opacity</code>, <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Slide Transition</li>
    <br/>
    <ul>
        <li>Slides element vertically (collapses height):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { slide } from "svelte/transition";

    let expanded: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; expanded = !expanded}&gt;
    {expanded ? "Collapse" : "Expand"}
&lt;/button&gt;

{#if expanded}
    &lt;div transition:slide={{ duration: 300 }}&gt;
        &lt;p&gt;This content slides in and out.&lt;/p&gt;
        &lt;p&gt;It animates the height property.&lt;/p&gt;
        &lt;p&gt;Great for accordions and dropdowns.&lt;/p&gt;
    &lt;/div&gt;
{/if}
</code></pre>

    <ul>
        <li>With axis parameter (Svelte 4+):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { slide } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;!-- Horizontal slide --&gt;
    &lt;div transition:slide={{ axis: "x", duration: 300 }}&gt;
        Slides horizontally
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Scale Transition</li>
    <br/>
    <ul>
        <li>Scales element size:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { scale } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;div transition:scale={{ duration: 300 }}&gt;
        Scales in and out
    &lt;/div&gt;

    &lt;div transition:scale={{ start: 0.5, opacity: 0.5 }}&gt;
        Starts at 50% size
    &lt;/div&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>start</code> (initial scale), <code>opacity</code>, <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Blur Transition</li>
    <br/>
    <ul>
        <li>Fades with a blur effect:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { blur } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;p transition:blur={{ amount: 10, duration: 400 }}&gt;
        Blurs in and out
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>amount</code> (blur pixels), <code>opacity</code>, <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Draw Transition (SVG)</li>
    <br/>
    <ul>
        <li>Animates SVG path stroke:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { draw } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;svg viewBox="0 0 100 100" width="200" height="200"&gt;
        &lt;path
            transition:draw={{ duration: 1000 }}
            d="M10,50 Q50,10 90,50 Q50,90 10,50"
            fill="none"
            stroke="blue"
            stroke-width="2"
        /&gt;
    &lt;/svg&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>speed</code> (pixels per second) or <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Separate In and Out Transitions</li>
    <br/>
    <ul>
        <li>Use different transitions for entering and exiting:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly, fade, scale } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;!-- Different transitions for in/out --&gt;
    &lt;p in:fly={{ y: -50 }} out:fade&gt;
        Flies in, fades out
    &lt;/p&gt;

    &lt;p in:scale out:fly={{ x: 200 }}&gt;
        Scales in, flies out to the right
    &lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Transition Parameters</li>
    <br/>
    <ul>
        <li>Common parameters available to all transitions:</li>
    </ul>

    <table>
        <tr>
            <th>Parameter</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>delay</code></td>
            <td><code>number</code></td>
            <td>Milliseconds before starting</td>
        </tr>
        <tr>
            <td><code>duration</code></td>
            <td><code>number</code></td>
            <td>Length in milliseconds</td>
        </tr>
        <tr>
            <td><code>easing</code></td>
            <td><code>function</code></td>
            <td>Easing function</td>
        </tr>
    </table>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";
    import { cubicOut, elasticOut, bounceOut } from "svelte/easing";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;p transition:fade={{ duration: 300, delay: 100, easing: cubicOut }}&gt;
        Custom easing
    &lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Easing Functions</li>
    <br/>
    <ul>
        <li>Svelte provides many easing functions in <code>svelte/easing</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">import {
    // Linear
    linear,

    // Sine
    sineIn, sineOut, sineInOut,

    // Quad (power of 2)
    quadIn, quadOut, quadInOut,

    // Cubic (power of 3)
    cubicIn, cubicOut, cubicInOut,

    // Quart (power of 4)
    quartIn, quartOut, quartInOut,

    // Quint (power of 5)
    quintIn, quintOut, quintInOut,

    // Expo (exponential)
    expoIn, expoOut, expoInOut,

    // Circ (circular)
    circIn, circOut, circInOut,

    // Back (overshoots)
    backIn, backOut, backInOut,

    // Elastic (springy)
    elasticIn, elasticOut, elasticInOut,

    // Bounce
    bounceIn, bounceOut, bounceInOut
} from "svelte/easing";
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly } from "svelte/transition";
    import { elasticOut, bounceOut } from "svelte/easing";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;div transition:fly={{ y: -100, easing: elasticOut, duration: 800 }}&gt;
        Elastic entrance!
    &lt;/div&gt;

    &lt;div transition:fly={{ y: 100, easing: bounceOut, duration: 600 }}&gt;
        Bouncy entrance!
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Transition Events</li>
    <br/>
    <ul>
        <li>Listen to transition lifecycle events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
    let status: string = $state("");

    function handleIntroStart(): void {
        status = "Intro started";
    }

    function handleIntroEnd(): void {
        status = "Intro ended";
    }

    function handleOutroStart(): void {
        status = "Outro started";
    }

    function handleOutroEnd(): void {
        status = "Outro ended";
    }
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

&lt;p&gt;Status: {status}&lt;/p&gt;

{#if visible}
    &lt;div
        transition:fade={{ duration: 500 }}
        onintrostart={handleIntroStart}
        onintroend={handleIntroEnd}
        onoutrostart={handleOutroStart}
        onoutroend={handleOutroEnd}
    &gt;
        Watch the status!
    &lt;/div&gt;
{/if}
</code></pre>

    <ul>
        <li>Events: <code>introstart</code>, <code>introend</code>, <code>outrostart</code>, <code>outroend</code></li>
    </ul>
    <br/><br/>



    <li>Local Transitions</li>
    <br/>
    <ul>
        <li>By default, transitions play when any parent block is added/removed.</li>
        <br/>
        <li>Use <code>local</code> modifier to only play when the element's direct block changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { slide, fade } from "svelte/transition";

    let showList: boolean = $state(true);
    let items: string[] = $state(["Item 1", "Item 2", "Item 3"]);

    function addItem(): void {
        items = [...items, `Item ${items.length + 1}`];
    }

    function removeItem(index: number): void {
        items = items.filter((_, i) =&gt; i !== index);
    }
&lt;/script&gt;

&lt;button onclick={() =&gt; showList = !showList}&gt;
    Toggle List
&lt;/button&gt;
&lt;button onclick={addItem}&gt;Add Item&lt;/button&gt;

{#if showList}
    &lt;ul transition:fade&gt;
        {#each items as item, i (item)}
            &lt;!-- |local prevents animation when parent toggles --&gt;
            &lt;li transition:slide|local&gt;
                {item}
                &lt;button onclick={() =&gt; removeItem(i)}&gt;×&lt;/button&gt;
            &lt;/li&gt;
        {/each}
    &lt;/ul&gt;
{/if}
</code></pre>

    <ul>
        <li>Without <code>|local</code>, items would animate when toggling the entire list.</li>
        <li>With <code>|local</code>, items only animate when individually added/removed.</li>
    </ul>
    <br/><br/>



    <li>Global Modifier</li>
    <br/>
    <ul>
        <li>The <code>|global</code> modifier ensures transitions play even during initial page load:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";
&lt;/script&gt;

&lt;!-- Plays transition on initial render --&gt;
&lt;div transition:fade|global={{ duration: 1000 }}&gt;
    Fades in on page load
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Crossfade Transition</li>
    <br/>
    <ul>
        <li>Creates a morphing effect between two elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { crossfade } from "svelte/transition";
    import { quintOut } from "svelte/easing";

    const [send, receive] = crossfade({
        duration: 400,
        easing: quintOut,
        fallback(node) {
            // Fallback when no matching element exists
            return {
                duration: 300,
                css: (t: number) =&gt; `opacity: ${t}`
            };
        }
    });

    interface Todo {
        id: number;
        text: string;
        done: boolean;
    }

    let todos: Todo[] = $state([
        { id: 1, text: "Learn Svelte", done: false },
        { id: 2, text: "Build an app", done: false },
        { id: 3, text: "Deploy", done: true }
    ]);

    function toggle(id: number): void {
        todos = todos.map(t =&gt;
            t.id === id ? { ...t, done: !t.done } : t
        );
    }

    let pending = $derived(todos.filter(t =&gt; !t.done));
    let completed = $derived(todos.filter(t =&gt; t.done));
&lt;/script&gt;

&lt;div class="columns"&gt;
    &lt;div class="column"&gt;
        &lt;h3&gt;Pending&lt;/h3&gt;
        {#each pending as todo (todo.id)}
            &lt;div
                class="todo"
                in:receive={{ key: todo.id }}
                out:send={{ key: todo.id }}
                onclick={() =&gt; toggle(todo.id)}
            &gt;
                {todo.text}
            &lt;/div&gt;
        {/each}
    &lt;/div&gt;

    &lt;div class="column"&gt;
        &lt;h3&gt;Completed&lt;/h3&gt;
        {#each completed as todo (todo.id)}
            &lt;div
                class="todo done"
                in:receive={{ key: todo.id }}
                out:send={{ key: todo.id }}
                onclick={() =&gt; toggle(todo.id)}
            &gt;
                {todo.text}
            &lt;/div&gt;
        {/each}
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
    .columns { display: flex; gap: 20px; }
    .column { flex: 1; }
    .todo { padding: 10px; margin: 5px 0; background: #eee; cursor: pointer; }
    .todo.done { background: #c8e6c9; }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>crossfade</code> returns <code>[send, receive]</code> pair.</li>
        <li>Elements with matching <code>key</code> morph into each other.</li>
    </ul>
    <br/><br/>



    <li>Custom Transitions</li>
    <br/>
    <ul>
        <li>Create custom transitions by returning a configuration object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";

    interface SpinParams {
        duration?: number;
        rotations?: number;
    }

    function spin(node: HTMLElement, params: SpinParams = {}): TransitionConfig {
        const { duration = 500, rotations = 1 } = params;

        return {
            duration,
            css: (t: number) =&gt; {
                const rotation = t * rotations * 360;
                const scale = t;
                return `
                    transform: rotate(${rotation}deg) scale(${scale});
                    opacity: ${t};
                `;
            }
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;div transition:spin={{ duration: 800, rotations: 2 }}&gt;
        Spinning!
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Custom Transition with <code>tick</code></li>
    <br/>
    <ul>
        <li>Use <code>tick</code> for JavaScript-based animations (when CSS isn't enough):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";

    interface TypewriterParams {
        speed?: number;
    }

    function typewriter(node: HTMLElement, params: TypewriterParams = {}): TransitionConfig {
        const { speed = 50 } = params;
        const text = node.textContent ?? "";
        const duration = text.length * speed;

        return {
            duration,
            tick: (t: number) =&gt; {
                const length = Math.floor(text.length * t);
                node.textContent = text.slice(0, length);
            }
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;p transition:typewriter={{ speed: 30 }}&gt;
        This text appears character by character...
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li><code>css</code> is preferred for performance (runs on GPU).</li>
        <li><code>tick</code> is for animations that can't be done with CSS.</li>
    </ul>
    <br/><br/>



    <li>Transition Return Object</li>
    <br/>
    <ul>
        <li>Custom transitions return a <code>TransitionConfig</code> object:</li>
    </ul>

<pre><code class="language-ts line-numbers">interface TransitionConfig {
    delay?: number;           // Delay before starting
    duration?: number;        // Animation length in ms
    easing?: (t: number) =&gt; number;  // Easing function
    css?: (t: number, u: number) =&gt; string;  // CSS generator
    tick?: (t: number, u: number) =&gt; void;   // JS callback
}

// t: 0 to 1 (intro) or 1 to 0 (outro) - the progress
// u: 1 - t (the inverse)
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";
    import { cubicOut } from "svelte/easing";

    function customFade(node: HTMLElement): TransitionConfig {
        return {
            delay: 100,
            duration: 400,
            easing: cubicOut,
            css: (t: number, u: number) =&gt; `
                opacity: ${t};
                transform: translateY(${u * 20}px);
            `
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;div transition:customFade&gt;
        Custom fade transition
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Deferred Transitions</li>
    <br/>
    <ul>
        <li>Return a function to defer transition creation:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";

    function deferredSlide(node: HTMLElement): () =&gt; TransitionConfig {
        // Measure height when transition starts, not when component mounts
        return () =&gt; {
            const height = node.offsetHeight;
            return {
                duration: 300,
                css: (t: number) =&gt; `
                    height: ${t * height}px;
                    overflow: hidden;
                `
            };
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;div transition:deferredSlide&gt;
        Content with dynamic height
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Staggered List Transitions</li>
    <br/>
    <ul>
        <li>Create staggered animations using index-based delays:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly } from "svelte/transition";

    let visible: boolean = $state(true);

    const items: string[] = [
        "First item",
        "Second item",
        "Third item",
        "Fourth item",
        "Fifth item"
    ];
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle List
&lt;/button&gt;

{#if visible}
    &lt;ul&gt;
        {#each items as item, i}
            &lt;li
                in:fly={{ y: 20, delay: i * 100, duration: 300 }}
                out:fly={{ y: -20, delay: (items.length - i - 1) * 50, duration: 200 }}
            &gt;
                {item}
            &lt;/li&gt;
        {/each}
    &lt;/ul&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Combining Transitions with CSS</li>
    <br/>
    <ul>
        <li>Transitions work alongside CSS transitions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
    let hovered: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;div
        class="box"
        class:hovered
        transition:fade={{ duration: 300 }}
        onmouseenter={() =&gt; hovered = true}
        onmouseleave={() =&gt; hovered = false}
    &gt;
        Hover me!
    &lt;/div&gt;
{/if}

&lt;style&gt;
    .box {
        padding: 20px;
        background: #3498db;
        color: white;
        transition: transform 0.2s, background 0.2s;
    }
    .box.hovered {
        transform: scale(1.05);
        background: #2980b9;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Transition with <code>{#key}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#key}</code> to trigger transitions when a value changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade, fly } from "svelte/transition";

    let count: number = $state(0);
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;
    Increment
&lt;/button&gt;

{#key count}
    &lt;p transition:fade={{ duration: 200 }}&gt;
        Count: {count}
    &lt;/p&gt;
{/key}

{#key count}
    &lt;div in:fly={{ y: -20 }} out:fly={{ y: 20 }}&gt;
        Value changed!
    &lt;/div&gt;
{/key}
</code></pre>
    <br/><br/>



    <li>Transitions Summary</li>
    <br/>

    <table>
        <tr>
            <th>Directive</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><code>transition:</code></td>
            <td>In and out</td>
            <td><code>transition:fade</code></td>
        </tr>
        <tr>
            <td><code>in:</code></td>
            <td>Enter only</td>
            <td><code>in:fly={{ y: -50 }}</code></td>
        </tr>
        <tr>
            <td><code>out:</code></td>
            <td>Exit only</td>
            <td><code>out:fade</code></td>
        </tr>
        <tr>
            <td><code>|local</code></td>
            <td>Only direct block changes</td>
            <td><code>transition:slide|local</code></td>
        </tr>
        <tr>
            <td><code>|global</code></td>
            <td>Play on initial render</td>
            <td><code>transition:fade|global</code></td>
        </tr>
        <tr>
            <td>Events</td>
            <td>Lifecycle hooks</td>
            <td><code>onintroend={handler}</code></td>
        </tr>
        <tr>
            <td>Custom</td>
            <td>Return <code>TransitionConfig</code></td>
            <td><code>css: (t) =&gt; ...</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-advanced-reactivity">Svelte Advanced Reactivity</h3>
<ol>
    <br/>
    <li>Deep Reactivity with <code>$state</code></li>
    <br/>
    <ul>
        <li><code>$state</code> creates <u>deeply reactive</u> state — nested objects and arrays are automatically reactive:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        name: string;
        address: {
            city: string;
            country: string;
        };
        hobbies: string[];
    }

    let user: User = $state({
        name: "Alice",
        address: {
            city: "New York",
            country: "USA"
        },
        hobbies: ["reading", "coding"]
    });

    function updateCity(): void {
        // Deep mutation is reactive!
        user.address.city = "Los Angeles";
    }

    function addHobby(): void {
        // Array mutations are reactive!
        user.hobbies.push("gaming");
    }
&lt;/script&gt;

&lt;p&gt;{user.name} lives in {user.address.city}&lt;/p&gt;
&lt;p&gt;Hobbies: {user.hobbies.join(", ")}&lt;/p&gt;

&lt;button onclick={updateCity}&gt;Move to LA&lt;/button&gt;
&lt;button onclick={addHobby}&gt;Add Hobby&lt;/button&gt;
</code></pre>

    <ul>
        <li>Unlike Svelte 4, you don't need to reassign to trigger updates.</li>
    </ul>
    <br/><br/>



    <li>Shallow Reactivity with <code>$state.raw</code></li>
    <br/>
    <ul>
        <li>Use <code>$state.raw</code> when you don't need deep reactivity:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface LargeDataset {
        id: number;
        values: number[];
    }

    // Only the reference is reactive, not nested properties
    let data: LargeDataset = $state.raw({
        id: 1,
        values: [1, 2, 3, 4, 5]
    });

    function updateData(): void {
        // This does NOT trigger reactivity
        data.values.push(6);

        // This DOES trigger reactivity (replacing the whole object)
        data = { ...data, values: [...data.values, 7] };
    }

    function replaceData(): void {
        // Reassignment triggers update
        data = {
            id: 2,
            values: [10, 20, 30]
        };
    }
&lt;/script&gt;

&lt;p&gt;ID: {data.id}&lt;/p&gt;
&lt;p&gt;Values: {data.values.join(", ")}&lt;/p&gt;

&lt;button onclick={updateData}&gt;Update&lt;/button&gt;
&lt;button onclick={replaceData}&gt;Replace&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>$state.raw</code> for:
            <ul>
                <li>Large datasets where deep reactivity is expensive</li>
                <li>Immutable data patterns</li>
                <li>Data that rarely changes</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Getting Plain Values with <code>$state.snapshot</code></li>
    <br/>
    <ul>
        <li><code>$state.snapshot</code> returns a non-reactive copy of reactive state:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface FormData {
        name: string;
        email: string;
    }

    let form: FormData = $state({
        name: "",
        email: ""
    });

    function handleSubmit(): void {
        // Get a plain object snapshot for API calls
        const snapshot = $state.snapshot(form);

        console.log("Submitting:", snapshot);
        console.log("Is proxy:", form !== snapshot); // true

        // Send to API
        fetch("/api/submit", {
            method: "POST",
            body: JSON.stringify(snapshot)
        });
    }

    function logState(): void {
        // Reactive proxy - may show Proxy in console
        console.log("Reactive:", form);

        // Plain object - cleaner for debugging
        console.log("Snapshot:", $state.snapshot(form));
    }
&lt;/script&gt;

&lt;input bind:value={form.name} placeholder="Name" /&gt;
&lt;input bind:value={form.email} placeholder="Email" /&gt;

&lt;button onclick={handleSubmit}&gt;Submit&lt;/button&gt;
&lt;button onclick={logState}&gt;Log State&lt;/button&gt;
</code></pre>

    <ul>
        <li>Useful when passing state to external libraries or APIs.</li>
    </ul>
    <br/><br/>



    <li>Computed Values with <code>$derived</code></li>
    <br/>
    <ul>
        <li><code>$derived</code> creates values that automatically update when dependencies change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let firstName: string = $state("John");
    let lastName: string = $state("Doe");
    let age: number = $state(25);

    // Simple derived value
    let fullName: string = $derived(firstName + " " + lastName);

    // Derived with transformation
    let upperName: string = $derived(fullName.toUpperCase());

    // Derived boolean
    let isAdult: boolean = $derived(age &gt;= 18);

    // Chained derivations
    let greeting: string = $derived(
        `Hello, ${fullName}! You are ${isAdult ? "an adult" : "a minor"}.`
    );
&lt;/script&gt;

&lt;input bind:value={firstName} placeholder="First name" /&gt;
&lt;input bind:value={lastName} placeholder="Last name" /&gt;
&lt;input type="number" bind:value={age} /&gt;

&lt;p&gt;Full name: {fullName}&lt;/p&gt;
&lt;p&gt;Upper: {upperName}&lt;/p&gt;
&lt;p&gt;{greeting}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Complex Derivations with <code>$derived.by</code></li>
    <br/>
    <ul>
        <li>Use <code>$derived.by</code> for derivations that need multiple statements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Product {
        name: string;
        price: number;
        quantity: number;
    }

    let products: Product[] = $state([
        { name: "Apple", price: 1.5, quantity: 3 },
        { name: "Banana", price: 0.75, quantity: 5 },
        { name: "Orange", price: 2.0, quantity: 2 }
    ]);

    let taxRate: number = $state(0.08);

    // Complex derivation with multiple statements
    let orderSummary = $derived.by(() =&gt; {
        const subtotal = products.reduce(
            (sum, p) =&gt; sum + p.price * p.quantity,
            0
        );
        const tax = subtotal * taxRate;
        const total = subtotal + tax;
        const itemCount = products.reduce((sum, p) =&gt; sum + p.quantity, 0);

        return {
            subtotal: subtotal.toFixed(2),
            tax: tax.toFixed(2),
            total: total.toFixed(2),
            itemCount
        };
    });

    // Derived with conditional logic
    let recommendation = $derived.by(() =&gt; {
        const total = parseFloat(orderSummary.total);

        if (total &gt; 50) {
            return "You qualify for free shipping!";
        } else if (total &gt; 25) {
            return `Add $${(50 - total).toFixed(2)} more for free shipping.`;
        } else {
            return "Keep shopping for great deals!";
        }
    });
&lt;/script&gt;

&lt;ul&gt;
    {#each products as product}
        &lt;li&gt;{product.name}: ${product.price} × {product.quantity}&lt;/li&gt;
    {/each}
&lt;/ul&gt;

&lt;p&gt;Items: {orderSummary.itemCount}&lt;/p&gt;
&lt;p&gt;Subtotal: ${orderSummary.subtotal}&lt;/p&gt;
&lt;p&gt;Tax: ${orderSummary.tax}&lt;/p&gt;
&lt;p&gt;Total: ${orderSummary.total}&lt;/p&gt;
&lt;p&gt;{recommendation}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Side Effects with <code>$effect</code></li>
    <br/>
    <ul>
        <li><code>$effect</code> runs code when reactive dependencies change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let name: string = $state("World");

    // Runs when count changes
    $effect(() =&gt; {
        console.log("Count is now:", count);
    });

    // Runs when name changes
    $effect(() =&gt; {
        document.title = `Hello, ${name}!`;
    });

    // Runs when either changes
    $effect(() =&gt; {
        console.log(`${name} has count ${count}`);
    });
&lt;/script&gt;

&lt;input bind:value={name} /&gt;
&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;
</code></pre>

    <ul>
        <li>Effects automatically track which reactive values are read.</li>
        <li>They re-run whenever those values change.</li>
    </ul>
    <br/><br/>



    <li>Effect Cleanup</li>
    <br/>
    <ul>
        <li>Return a function from <code>$effect</code> to clean up before re-running:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let interval: number = $state(1000);
    let count: number = $state(0);

    $effect(() =&gt; {
        // Set up interval with current value
        const id = setInterval(() =&gt; {
            count++;
        }, interval);

        console.log(`Started interval: ${interval}ms`);

        // Cleanup: clear interval before re-running or on unmount
        return () =&gt; {
            clearInterval(id);
            console.log("Cleared interval");
        };
    });

    // Event listener example
    let mouseX: number = $state(0);
    let mouseY: number = $state(0);

    $effect(() =&gt; {
        function handleMouseMove(e: MouseEvent): void {
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        window.addEventListener("mousemove", handleMouseMove);

        return () =&gt; {
            window.removeEventListener("mousemove", handleMouseMove);
        };
    });
&lt;/script&gt;

&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;p&gt;Mouse: {mouseX}, {mouseY}&lt;/p&gt;

&lt;label&gt;
    Interval (ms):
    &lt;input type="number" bind:value={interval} min="100" step="100" /&gt;
&lt;/label&gt;
</code></pre>
    <br/><br/>



    <li>Pre-Effects with <code>$effect.pre</code></li>
    <br/>
    <ul>
        <li><code>$effect.pre</code> runs <u>before</u> the DOM updates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let messages: string[] = $state(["Hello", "World"]);
    let container: HTMLDivElement;

    // Runs BEFORE DOM updates - useful for measuring
    $effect.pre(() =&gt; {
        if (container) {
            // Capture scroll position before DOM changes
            const isAtBottom =
                container.scrollHeight - container.scrollTop === container.clientHeight;

            console.log("Before update, at bottom:", isAtBottom);
        }
    });

    // Runs AFTER DOM updates
    $effect(() =&gt; {
        if (container) {
            // Auto-scroll to bottom after new messages
            container.scrollTop = container.scrollHeight;
        }
    });

    function addMessage(): void {
        messages.push(`Message ${messages.length + 1}`);
    }
&lt;/script&gt;

&lt;div bind:this={container} class="chat" style="height: 200px; overflow-y: auto;"&gt;
    {#each messages as message}
        &lt;p&gt;{message}&lt;/p&gt;
    {/each}
&lt;/div&gt;

&lt;button onclick={addMessage}&gt;Add Message&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>$effect.pre</code> when you need to measure or capture state before the DOM changes.</li>
    </ul>
    <br/><br/>



    <li>Effect Tracking with <code>$effect.tracking</code></li>
    <br/>
    <ul>
        <li>Check if code is running inside a tracking context:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);

    function logWithContext(message: string): void {
        if ($effect.tracking()) {
            console.log("[Tracked]", message);
        } else {
            console.log("[Untracked]", message);
        }
    }

    // Inside $effect - tracked
    $effect(() =&gt; {
        logWithContext(`Count is ${count}`);
    });

    // Inside $derived - tracked
    let doubled = $derived.by(() =&gt; {
        logWithContext("Computing doubled");
        return count * 2;
    });

    function handleClick(): void {
        // Event handler - not tracked
        logWithContext("Button clicked");
        count++;
    }
&lt;/script&gt;

&lt;p&gt;Count: {count}, Doubled: {doubled}&lt;/p&gt;
&lt;button onclick={handleClick}&gt;Increment&lt;/button&gt;
</code></pre>

    <ul>
        <li>Useful for libraries that need to behave differently in reactive vs non-reactive contexts.</li>
    </ul>
    <br/><br/>



    <li>Root Effects with <code>$effect.root</code></li>
    <br/>
    <ul>
        <li><code>$effect.root</code> creates effects outside the component lifecycle:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let cleanupRoot: (() =&gt; void) | null = null;

    function startRootEffect(): void {
        // Create an effect that persists outside component lifecycle
        cleanupRoot = $effect.root(() =&gt; {
            $effect(() =&gt; {
                console.log("[Root Effect] Count:", count);
            });

            // Return cleanup for the root
            return () =&gt; {
                console.log("[Root Effect] Cleaned up");
            };
        });
    }

    function stopRootEffect(): void {
        if (cleanupRoot) {
            cleanupRoot();
            cleanupRoot = null;
        }
    }
&lt;/script&gt;

&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;

&lt;button onclick={startRootEffect}&gt;Start Root Effect&lt;/button&gt;
&lt;button onclick={stopRootEffect}&gt;Stop Root Effect&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>$effect.root</code> for:
            <ul>
                <li>Effects in shared modules</li>
                <li>Effects with manual lifecycle control</li>
                <li>Testing scenarios</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Untracking Dependencies with <code>untrack</code></li>
    <br/>
    <ul>
        <li>Use <code>untrack</code> to read reactive values without creating a dependency:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { untrack } from "svelte";

    let count: number = $state(0);
    let name: string = $state("Alice");
    let effectRuns: number = $state(0);

    $effect(() =&gt; {
        // This creates a dependency on 'count'
        console.log("Count:", count);

        // This does NOT create a dependency on 'name'
        const currentName = untrack(() =&gt; name);
        console.log("Name (untracked):", currentName);

        effectRuns++;
    });

    // The effect only re-runs when 'count' changes, not 'name'
&lt;/script&gt;

&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;p&gt;Name: {name}&lt;/p&gt;
&lt;p&gt;Effect runs: {effectRuns}&lt;/p&gt;

&lt;button onclick={() =&gt; count++}&gt;Increment Count (triggers effect)&lt;/button&gt;
&lt;button onclick={() =&gt; name = name + "!"}&gt;Change Name (no effect)&lt;/button&gt;
</code></pre>

    <ul>
        <li>Useful when you need to read a value without reacting to its changes.</li>
    </ul>
    <br/><br/>



    <li>Debugging with <code>$inspect</code></li>
    <br/>
    <ul>
        <li><code>$inspect</code> logs reactive values whenever they change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        name: string;
        age: number;
    }

    let count: number = $state(0);
    let user: User = $state({ name: "Alice", age: 25 });

    // Basic inspection - logs on every change
    $inspect(count);

    // Inspect multiple values
    $inspect(count, user);

    // Custom logging with .with()
    $inspect(user).with((type, value) =&gt; {
        console.log(`[${type}]`, JSON.stringify(value, null, 2));
    });

    // Useful for debugging: pause on change
    $inspect(count).with((type, value) =&gt; {
        if (value &gt; 5) {
            debugger; // Opens browser debugger
        }
    });
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;
&lt;button onclick={() =&gt; user.age++}&gt;Age: {user.age}&lt;/button&gt;
&lt;input bind:value={user.name} /&gt;
</code></pre>

    <ul>
        <li><code>$inspect</code> only works in development mode.</li>
        <li>The <code>type</code> parameter is either <code>"init"</code> or <code>"update"</code>.</li>
    </ul>
    <br/><br/>



    <li>Fine-Grained Reactivity</li>
    <br/>
    <ul>
        <li>Svelte 5 tracks reactivity at the <u>property level</u>, not just the object level:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Coordinates {
        x: number;
        y: number;
    }

    let coords: Coordinates = $state({ x: 0, y: 0 });

    // This effect only re-runs when coords.x changes
    $effect(() =&gt; {
        console.log("X changed:", coords.x);
    });

    // This effect only re-runs when coords.y changes
    $effect(() =&gt; {
        console.log("Y changed:", coords.y);
    });

    function updateX(): void {
        coords.x++; // Only triggers first effect
    }

    function updateY(): void {
        coords.y++; // Only triggers second effect
    }
&lt;/script&gt;

&lt;p&gt;X: {coords.x}, Y: {coords.y}&lt;/p&gt;
&lt;button onclick={updateX}&gt;Update X&lt;/button&gt;
&lt;button onclick={updateY}&gt;Update Y&lt;/button&gt;
</code></pre>

    <ul>
        <li>This fine-grained tracking improves performance for complex objects.</li>
    </ul>
    <br/><br/>



    <li>Reactive Classes</li>
    <br/>
    <ul>
        <li>Use <code>$state</code> in class fields for reactive class instances:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    class Counter {
        count: number = $state(0);

        increment(): void {
            this.count++;
        }

        decrement(): void {
            this.count--;
        }

        get doubled(): number {
            return this.count * 2;
        }
    }

    class TodoList {
        items: string[] = $state([]);

        add(item: string): void {
            this.items.push(item);
        }

        remove(index: number): void {
            this.items.splice(index, 1);
        }

        get count(): number {
            return this.items.length;
        }
    }

    const counter = new Counter();
    const todos = new TodoList();
    let newTodo: string = $state("");
&lt;/script&gt;

&lt;div&gt;
    &lt;h3&gt;Counter&lt;/h3&gt;
    &lt;p&gt;Count: {counter.count} (doubled: {counter.doubled})&lt;/p&gt;
    &lt;button onclick={() =&gt; counter.decrement()}&gt;-&lt;/button&gt;
    &lt;button onclick={() =&gt; counter.increment()}&gt;+&lt;/button&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h3&gt;Todos ({todos.count})&lt;/h3&gt;
    &lt;input bind:value={newTodo} /&gt;
    &lt;button onclick={() =&gt; { todos.add(newTodo); newTodo = ""; }}&gt;Add&lt;/button&gt;

    &lt;ul&gt;
        {#each todos.items as item, i}
            &lt;li&gt;{item} &lt;button onclick={() =&gt; todos.remove(i)}&gt;×&lt;/button&gt;&lt;/li&gt;
        {/each}
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Reactive State in Modules</li>
    <br/>
    <ul>
        <li>Create shared reactive state in separate modules:</li>
    </ul>

<pre><code class="language-ts line-numbers">// stores/counter.svelte.ts
export function createCounter(initial: number = 0) {
    let count = $state(initial);

    return {
        get count() {
            return count;
        },
        increment() {
            count++;
        },
        decrement() {
            count--;
        },
        reset() {
            count = initial;
        }
    };
}

// Singleton instance
export const counter = createCounter(0);
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Component.svelte --&gt;
&lt;script lang="ts"&gt;
    import { counter } from "./stores/counter.svelte";
&lt;/script&gt;

&lt;p&gt;Count: {counter.count}&lt;/p&gt;
&lt;button onclick={counter.increment}&gt;+&lt;/button&gt;
&lt;button onclick={counter.decrement}&gt;-&lt;/button&gt;
&lt;button onclick={counter.reset}&gt;Reset&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use the <code>.svelte.ts</code> or <code>.svelte.js</code> extension for files containing runes.</li>
    </ul>
    <br/><br/>



    <li>Store Interoperability</li>
    <br/>
    <ul>
        <li>Svelte 5 stores work with both old stores and new runes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { writable, type Writable } from "svelte/store";
    import { fromStore, toStore } from "svelte/store";

    // Traditional store
    const countStore: Writable&lt;number&gt; = writable(0);

    // Convert store to rune-based state
    const countState = fromStore(countStore);

    // Access value (automatically subscribes)
    $effect(() =&gt; {
        console.log("Store value:", countState.current);
    });

    // Or create a store from rune state
    let runeCount: number = $state(0);
    const runeStore = toStore(() =&gt; runeCount, (v) =&gt; runeCount = v);
&lt;/script&gt;

&lt;p&gt;Store: {$countStore}&lt;/p&gt;
&lt;p&gt;State: {countState.current}&lt;/p&gt;

&lt;button onclick={() =&gt; countStore.update(n =&gt; n + 1)}&gt;
    Update Store
&lt;/button&gt;

&lt;button onclick={() =&gt; runeCount++}&gt;
    Update Rune
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Avoiding Infinite Loops</li>
    <br/>
    <ul>
        <li>Be careful not to create infinite loops in effects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { untrack } from "svelte";

    let count: number = $state(0);
    let history: number[] = $state([]);

    // BAD: Infinite loop!
    // $effect(() =&gt; {
    //     history.push(count); // Reading 'count' AND modifying 'history'
    //     history = history;   // This creates a loop
    // });

    // GOOD: Use untrack to prevent loop
    $effect(() =&gt; {
        const current = count; // Track count
        untrack(() =&gt; {
            history.push(current); // Don't track history modification
        });
    });

    // ALTERNATIVE: Use $effect.pre or separate the concerns
    let lastCount: number | null = null;

    $effect(() =&gt; {
        if (count !== lastCount) {
            lastCount = count;
            // Safe to modify other state here
        }
    });
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;
&lt;p&gt;History: {history.join(", ")}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Conditional Effects</li>
    <br/>
    <ul>
        <li>Effects can have conditional logic, but dependencies are still tracked:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let enabled: boolean = $state(true);
    let count: number = $state(0);
    let logs: string[] = $state([]);

    $effect(() =&gt; {
        // 'enabled' is always tracked
        if (enabled) {
            // 'count' is only tracked when this branch runs
            logs.push(`Count is ${count}`);
        }
    });

    // Better pattern: guard the entire effect
    $effect(() =&gt; {
        if (!enabled) return;

        logs.push(`Enabled count: ${count}`);

        return () =&gt; {
            logs.push("Effect cleaned up");
        };
    });
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={enabled} /&gt;
    Enabled
&lt;/label&gt;

&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;

&lt;ul&gt;
    {#each logs as log}
        &lt;li&gt;{log}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Batching Updates</li>
    <br/>
    <ul>
        <li>Svelte batches synchronous updates automatically:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { flushSync } from "svelte";

    let a: number = $state(0);
    let b: number = $state(0);
    let effectRuns: number = $state(0);

    $effect(() =&gt; {
        console.log(`a: ${a}, b: ${b}`);
        effectRuns++;
    });

    function batchedUpdate(): void {
        // These are batched - effect runs once
        a++;
        b++;
    }

    function forcedUpdate(): void {
        a++;
        // Force synchronous flush
        flushSync();
        // This triggers a separate effect run
        b++;
    }
&lt;/script&gt;

&lt;p&gt;a: {a}, b: {b}&lt;/p&gt;
&lt;p&gt;Effect runs: {effectRuns}&lt;/p&gt;

&lt;button onclick={batchedUpdate}&gt;Batched (1 effect run)&lt;/button&gt;
&lt;button onclick={forcedUpdate}&gt;Forced (2 effect runs)&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>flushSync</code> sparingly — only when you need immediate DOM updates.</li>
    </ul>
    <br/><br/>



    <li>Advanced Reactivity Summary</li>
    <br/>

    <table>
        <tr>
            <th>API</th>
            <th>Purpose</th>
            <th>Usage</th>
        </tr>
        <tr>
            <td><code>$state</code></td>
            <td>Deep reactive state</td>
            <td><code>let x = $state(value)</code></td>
        </tr>
        <tr>
            <td><code>$state.raw</code></td>
            <td>Shallow reactive state</td>
            <td><code>let x = $state.raw(value)</code></td>
        </tr>
        <tr>
            <td><code>$state.snapshot</code></td>
            <td>Get plain object copy</td>
            <td><code>$state.snapshot(state)</code></td>
        </tr>
        <tr>
            <td><code>$derived</code></td>
            <td>Computed value (expression)</td>
            <td><code>let x = $derived(expr)</code></td>
        </tr>
        <tr>
            <td><code>$derived.by</code></td>
            <td>Computed value (function)</td>
            <td><code>let x = $derived.by(() =&gt; ...)</code></td>
        </tr>
        <tr>
            <td><code>$effect</code></td>
            <td>Side effect (after DOM)</td>
            <td><code>$effect(() =&gt; { ... })</code></td>
        </tr>
        <tr>
            <td><code>$effect.pre</code></td>
            <td>Side effect (before DOM)</td>
            <td><code>$effect.pre(() =&gt; { ... })</code></td>
        </tr>
        <tr>
            <td><code>$effect.tracking</code></td>
            <td>Check if tracking</td>
            <td><code>if ($effect.tracking()) ...</code></td>
        </tr>
        <tr>
            <td><code>$effect.root</code></td>
            <td>Manual effect lifecycle</td>
            <td><code>$effect.root(() =&gt; ...)</code></td>
        </tr>
        <tr>
            <td><code>untrack</code></td>
            <td>Read without tracking</td>
            <td><code>untrack(() =&gt; value)</code></td>
        </tr>
        <tr>
            <td><code>$inspect</code></td>
            <td>Debug reactive values</td>
            <td><code>$inspect(value)</code></td>
        </tr>
        <tr>
            <td><code>flushSync</code></td>
            <td>Force synchronous update</td>
            <td><code>flushSync()</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-reusing-content">Svelte Reusing Content</h3>
<ol>
    <li>Overview</li>
    <br/>
    <ul>
        <li>Svelte provides several ways to create <u>reusable content</u> within and across components.</li>
        <br/>
        <li>Key concepts:
            <ul>
                <li><b>Slots</b> — Allow parent to inject content into child components (Svelte 4)</li>
                <li><b>Snippets</b> — Reusable template chunks with parameters (Svelte 5)</li>
                <li><b>@render</b> — Render snippets and children (Svelte 5)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Basic Slots (Svelte 4)</li>
    <br/>
    <ul>
        <li>Slots allow a parent component to pass content into a child:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Card.svelte --&gt;
&lt;script lang="ts"&gt;
    export let title: string;
&lt;/script&gt;

&lt;div class="card"&gt;
    &lt;h2&gt;{title}&lt;/h2&gt;
    &lt;div class="content"&gt;
        &lt;slot /&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
    .card { border: 1px solid #ccc; padding: 16px; border-radius: 8px; }
    .content { margin-top: 12px; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Card from "./Card.svelte";
&lt;/script&gt;

&lt;Card title="Welcome"&gt;
    &lt;p&gt;This content goes into the slot.&lt;/p&gt;
    &lt;p&gt;Multiple elements are allowed.&lt;/p&gt;
&lt;/Card&gt;
</code></pre>
    <br/><br/>



    <li>Default Slot Content (Svelte 4)</li>
    <br/>
    <ul>
        <li>Provide fallback content when no slot content is provided:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    export let variant: "primary" | "secondary" = "primary";
&lt;/script&gt;

&lt;button class="btn btn-{variant}"&gt;
    &lt;slot&gt;
        &lt;!-- Default content if nothing is passed --&gt;
        Click me
    &lt;/slot&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button /&gt;                    &lt;!-- Shows "Click me" --&gt;
&lt;Button&gt;Submit&lt;/Button&gt;       &lt;!-- Shows "Submit" --&gt;
&lt;Button&gt;Cancel&lt;/Button&gt;       &lt;!-- Shows "Cancel" --&gt;
</code></pre>
    <br/><br/>



    <li>Named Slots (Svelte 4)</li>
    <br/>
    <ul>
        <li>Use named slots for multiple content areas:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Modal.svelte --&gt;
&lt;script lang="ts"&gt;
    export let open: boolean = false;
&lt;/script&gt;

{#if open}
    &lt;div class="modal-overlay"&gt;
        &lt;div class="modal"&gt;
            &lt;header&gt;
                &lt;slot name="header"&gt;
                    &lt;h2&gt;Modal Title&lt;/h2&gt;
                &lt;/slot&gt;
            &lt;/header&gt;

            &lt;main&gt;
                &lt;slot&gt;
                    &lt;p&gt;Modal content goes here.&lt;/p&gt;
                &lt;/slot&gt;
            &lt;/main&gt;

            &lt;footer&gt;
                &lt;slot name="footer"&gt;
                    &lt;button on:click={() =&gt; open = false}&gt;Close&lt;/button&gt;
                &lt;/slot&gt;
            &lt;/footer&gt;
        &lt;/div&gt;
    &lt;/div&gt;
{/if}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Modal from "./Modal.svelte";

    let showModal: boolean = false;
&lt;/script&gt;

&lt;button on:click={() =&gt; showModal = true}&gt;Open Modal&lt;/button&gt;

&lt;Modal bind:open={showModal}&gt;
    &lt;h2 slot="header"&gt;Confirm Action&lt;/h2&gt;

    &lt;p&gt;Are you sure you want to proceed?&lt;/p&gt;

    &lt;div slot="footer"&gt;
        &lt;button on:click={() =&gt; showModal = false}&gt;Cancel&lt;/button&gt;
        &lt;button on:click={() =&gt; { /* confirm */ showModal = false }}&gt;Confirm&lt;/button&gt;
    &lt;/div&gt;
&lt;/Modal&gt;
</code></pre>
    <br/><br/>



    <li>Slot Props (Svelte 4)</li>
    <br/>
    <ul>
        <li>Pass data from child to parent through slot props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- List.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Item {
        id: number;
        name: string;
    }

    export let items: Item[];
&lt;/script&gt;

&lt;ul&gt;
    {#each items as item, index}
        &lt;li&gt;
            &lt;slot {item} {index} isFirst={index === 0} isLast={index === items.length - 1}&gt;
                {item.name}
            &lt;/slot&gt;
        &lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import List from "./List.svelte";

    const users = [
        { id: 1, name: "Alice" },
        { id: 2, name: "Bob" },
        { id: 3, name: "Charlie" }
    ];
&lt;/script&gt;

&lt;List items={users} let:item let:index let:isFirst let:isLast&gt;
    &lt;span class:highlight={isFirst || isLast}&gt;
        {index + 1}. {item.name}
        {#if isFirst}(First){/if}
        {#if isLast}(Last){/if}
    &lt;/span&gt;
&lt;/List&gt;
</code></pre>
    <br/><br/>



    <li>Checking for Slot Content with <code>$$slots</code> (Svelte 4)</li>
    <br/>
    <ul>
        <li>Check if slot content was provided:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Card.svelte --&gt;
&lt;script lang="ts"&gt;
    export let title: string;
&lt;/script&gt;

&lt;div class="card"&gt;
    &lt;h2&gt;{title}&lt;/h2&gt;

    &lt;slot /&gt;

    {#if $$slots.footer}
        &lt;hr /&gt;
        &lt;footer&gt;
            &lt;slot name="footer" /&gt;
        &lt;/footer&gt;
    {/if}

    {#if $$slots.actions}
        &lt;div class="actions"&gt;
            &lt;slot name="actions" /&gt;
        &lt;/div&gt;
    {/if}
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Card from "./Card.svelte";
&lt;/script&gt;

&lt;!-- No footer - footer section won't render --&gt;
&lt;Card title="Simple Card"&gt;
    &lt;p&gt;Just some content.&lt;/p&gt;
&lt;/Card&gt;

&lt;!-- With footer --&gt;
&lt;Card title="Card with Footer"&gt;
    &lt;p&gt;Content here.&lt;/p&gt;
    &lt;span slot="footer"&gt;Footer text&lt;/span&gt;
&lt;/Card&gt;
</code></pre>
    <br/><br/>



    <li>Introduction to Snippets (Svelte 5)</li>
    <br/>
    <ul>
        <li>Snippets are Svelte 5's way to create reusable template chunks:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let items: string[] = $state(["Apple", "Banana", "Cherry"]);
&lt;/script&gt;

{#snippet listItem(item: string, index: number)}
    &lt;li class="item"&gt;
        &lt;span class="index"&gt;{index + 1}.&lt;/span&gt;
        &lt;span class="name"&gt;{item}&lt;/span&gt;
    &lt;/li&gt;
{/snippet}

&lt;ul&gt;
    {#each items as item, i}
        {@render listItem(item, i)}
    {/each}
&lt;/ul&gt;

&lt;style&gt;
    .item { display: flex; gap: 8px; }
    .index { color: #666; }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>{#snippet name(params)}</code> defines a snippet.</li>
        <li><code>{@render name(args)}</code> renders the snippet.</li>
    </ul>
    <br/><br/>



    <li>Snippets with Complex Parameters</li>
    <br/>
    <ul>
        <li>Snippets can accept any TypeScript types as parameters:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
        avatar: string;
        isOnline: boolean;
    }

    let users: User[] = $state([
        { id: 1, name: "Alice",   email: "alice@example.com",   avatar: "👩", isOnline: true },
        { id: 2, name: "Bob",     email: "bob@example.com",     avatar: "👨", isOnline: false },
        { id: 3, name: "Charlie", email: "charlie@example.com", avatar: "🧑", isOnline: true }
    ]);
&lt;/script&gt;

{#snippet userCard(user: User, showEmail: boolean = false)}
    &lt;div class="user-card"&gt;
        &lt;span class="avatar"&gt;{user.avatar}&lt;/span&gt;
        &lt;div class="info"&gt;
            &lt;strong&gt;{user.name}&lt;/strong&gt;
            {#if showEmail}
                &lt;small&gt;{user.email}&lt;/small&gt;
            {/if}
        &lt;/div&gt;
        &lt;span class="status" class:online={user.isOnline}&gt;
            {user.isOnline ? "●" : "○"}
        &lt;/span&gt;
    &lt;/div&gt;
{/snippet}

&lt;h3&gt;Users (compact)&lt;/h3&gt;
{#each users as user}
    {@render userCard(user)}
{/each}

&lt;h3&gt;Users (with email)&lt;/h3&gt;
{#each users as user}
    {@render userCard(user, true)}
{/each}
</code></pre>
    <br/><br/>



    <li>Snippets for Conditional Rendering</li>
    <br/>
    <ul>
        <li>Use snippets to avoid repeating conditional templates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    type Status = "loading" | "success" | "error";

    let status: Status = $state("loading");
    let data: string | null = $state(null);
    let error: string | null = $state(null);

    function fetchData(): void {
        status = "loading";
        setTimeout(() =&gt; {
            if (Math.random() &gt; 0.3) {
                data = "Here is your data!";
                status = "success";
            } else {
                error = "Failed to fetch data";
                status = "error";
            }
        }, 1000);
    }
&lt;/script&gt;

{#snippet loadingState()}
    &lt;div class="loading"&gt;
        &lt;span class="spinner"&gt;⏳&lt;/span&gt;
        &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/div&gt;
{/snippet}

{#snippet errorState(message: string)}
    &lt;div class="error"&gt;
        &lt;span class="icon"&gt;❌&lt;/span&gt;
        &lt;p&gt;{message}&lt;/p&gt;
        &lt;button onclick={fetchData}&gt;Retry&lt;/button&gt;
    &lt;/div&gt;
{/snippet}

{#snippet successState(content: string)}
    &lt;div class="success"&gt;
        &lt;span class="icon"&gt;✅&lt;/span&gt;
        &lt;p&gt;{content}&lt;/p&gt;
    &lt;/div&gt;
{/snippet}

&lt;button onclick={fetchData}&gt;Fetch Data&lt;/button&gt;

{#if status === "loading"}
    {@render loadingState()}
{:else if status === "error" && error}
    {@render errorState(error)}
{:else if status === "success" && data}
    {@render successState(data)}
{/if}
</code></pre>
    <br/><br/>



    <li>Passing Snippets to Components (Svelte 5)</li>
    <br/>
    <ul>
        <li>Snippets can be passed as props to child components:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- List.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface Props&lt;T&gt; {
        items: T[];
        renderItem: Snippet&lt;[T, number]&gt;;
        emptyState?: Snippet;
    }

    let { items, renderItem, emptyState }: Props&lt;unknown&gt; = $props();
&lt;/script&gt;

{#if items.length === 0}
    {#if emptyState}
        {@render emptyState()}
    {:else}
        &lt;p&gt;No items to display.&lt;/p&gt;
    {/if}
{:else}
    &lt;ul&gt;
        {#each items as item, index}
            &lt;li&gt;
                {@render renderItem(item, index)}
            &lt;/li&gt;
        {/each}
    &lt;/ul&gt;
{/if}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import List from "./List.svelte";

    interface Product {
        id: number;
        name: string;
        price: number;
    }

    let products: Product[] = $state([
        { id: 1, name: "Widget", price: 9.99 },
        { id: 2, name: "Gadget", price: 19.99 }
    ]);
&lt;/script&gt;

{#snippet productItem(product: Product, index: number)}
    &lt;div class="product"&gt;
        &lt;strong&gt;{product.name}&lt;/strong&gt;
        &lt;span&gt;${product.price.toFixed(2)}&lt;/span&gt;
    &lt;/div&gt;
{/snippet}

{#snippet emptyProducts()}
    &lt;div class="empty"&gt;
        &lt;p&gt;No products available.&lt;/p&gt;
        &lt;button&gt;Add Product&lt;/button&gt;
    &lt;/div&gt;
{/snippet}

&lt;List items={products} renderItem={productItem} emptyState={emptyProducts} /&gt;
</code></pre>
    <br/><br/>



    <li>The <code>children</code> Snippet (Svelte 5)</li>
    <br/>
    <ul>
        <li>Content passed between component tags becomes the <code>children</code> snippet:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Card.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface Props {
        title: string;
        children: Snippet;
        footer?: Snippet;
    }

    let { title, children, footer }: Props = $props();
&lt;/script&gt;

&lt;div class="card"&gt;
    &lt;h2&gt;{title}&lt;/h2&gt;

    &lt;div class="content"&gt;
        {@render children()}
    &lt;/div&gt;

    {#if footer}
        &lt;div class="footer"&gt;
            {@render footer()}
        &lt;/div&gt;
    {/if}
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Card from "./Card.svelte";
&lt;/script&gt;

{#snippet cardFooter()}
    &lt;button&gt;Learn More&lt;/button&gt;
{/snippet}

&lt;Card title="Welcome" footer={cardFooter}&gt;
    &lt;p&gt;This becomes the children snippet.&lt;/p&gt;
    &lt;p&gt;All content here is passed automatically.&lt;/p&gt;
&lt;/Card&gt;
</code></pre>
    <br/><br/>



    <li>Optional Children</li>
    <br/>
    <ul>
        <li>Make children optional with a default fallback:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface Props {
        onclick?: () =&gt; void;
        children?: Snippet;
    }

    let { onclick, children }: Props = $props();
&lt;/script&gt;

&lt;button onclick={onclick}&gt;
    {#if children}
        {@render children()}
    {:else}
        Click me
    {/if}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button /&gt;                     &lt;!-- Shows "Click me" --&gt;
&lt;Button&gt;Submit&lt;/Button&gt;        &lt;!-- Shows "Submit" --&gt;
&lt;Button&gt;🚀 Launch&lt;/Button&gt;     &lt;!-- Shows "🚀 Launch" --&gt;
</code></pre>
    <br/><br/>



    <li>Snippets with Data from Parent (Render Props Pattern)</li>
    <br/>
    <ul>
        <li>Pass data back to the snippet when rendering:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- DataFetcher.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface FetchState&lt;T&gt; {
        data: T | null;
        loading: boolean;
        error: string | null;
    }

    interface Props&lt;T&gt; {
        url: string;
        children: Snippet&lt;[FetchState&lt;T&gt;]&gt;;
    }

    let { url, children }: Props&lt;unknown&gt; = $props();

    let state: FetchState&lt;unknown&gt; = $state({
        data: null,
        loading: true,
        error: null
    });

    $effect(() =&gt; {
        state.loading = true;
        state.error = null;

        fetch(url)
            .then(res =&gt; res.json())
            .then(data =&gt; {
                state.data = data;
                state.loading = false;
            })
            .catch(err =&gt; {
                state.error = err.message;
                state.loading = false;
            });
    });
&lt;/script&gt;

{@render children(state)}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import DataFetcher from "./DataFetcher.svelte";

    interface User {
        id: number;
        name: string;
    }
&lt;/script&gt;

&lt;DataFetcher url="/api/users"&gt;
    {#snippet children(state: { data: User[] | null; loading: boolean; error: string | null })}
        {#if state.loading}
            &lt;p&gt;Loading...&lt;/p&gt;
        {:else if state.error}
            &lt;p class="error"&gt;Error: {state.error}&lt;/p&gt;
        {:else if state.data}
            &lt;ul&gt;
                {#each state.data as user}
                    &lt;li&gt;{user.name}&lt;/li&gt;
                {/each}
            &lt;/ul&gt;
        {/if}
    {/snippet}
&lt;/DataFetcher&gt;
</code></pre>
    <br/><br/>



    <li>Typing Snippets</li>
    <br/>
    <ul>
        <li>Use the <code>Snippet</code> type from Svelte for proper typing:</li>
    </ul>

<pre><code class="language-ts line-numbers">import type { Snippet } from "svelte";

// Snippet with no parameters
type NoParams = Snippet;

// Snippet with one parameter
type SingleParam = Snippet&lt;[string]&gt;;

// Snippet with multiple parameters
type MultiParams = Snippet&lt;[string, number, boolean]&gt;;

// Snippet with object parameter
interface ItemData {
    id: number;
    name: string;
}
type ObjectParam = Snippet&lt;[ItemData]&gt;;

// Optional snippet
interface Props {
    required: Snippet;
    optional?: Snippet;
}
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface TableColumn&lt;T&gt; {
        key: keyof T;
        header: string;
        render?: Snippet&lt;[T[keyof T], T]&gt;;
    }

    interface Props&lt;T&gt; {
        data: T[];
        columns: TableColumn&lt;T&gt;[];
    }

    let { data, columns }: Props&lt;Record&lt;string, unknown&gt;&gt; = $props();
&lt;/script&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            {#each columns as column}
                &lt;th&gt;{column.header}&lt;/th&gt;
            {/each}
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {#each data as row}
            &lt;tr&gt;
                {#each columns as column}
                    &lt;td&gt;
                        {#if column.render}
                            {@render column.render(row[column.key], row)}
                        {:else}
                            {row[column.key]}
                        {/if}
                    &lt;/td&gt;
                {/each}
            &lt;/tr&gt;
        {/each}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
    <br/><br/>



    <li>Recursive Snippets</li>
    <br/>
    <ul>
        <li>Snippets can call themselves for recursive structures:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface TreeNode {
        id: number;
        name: string;
        children?: TreeNode[];
    }

    let tree: TreeNode = $state({
        id: 1,
        name: "Root",
        children: [
            {
                id: 2,
                name: "Folder A",
                children: [
                    { id: 4, name: "File 1" },
                    { id: 5, name: "File 2" }
                ]
            },
            {
                id: 3,
                name: "Folder B",
                children: [
                    { id: 6, name: "File 3" }
                ]
            }
        ]
    });
&lt;/script&gt;

{#snippet treeNode(node: TreeNode, depth: number = 0)}
    &lt;div class="node" style="padding-left: {depth * 20}px"&gt;
        &lt;span&gt;{node.children ? "📁" : "📄"} {node.name}&lt;/span&gt;
    &lt;/div&gt;

    {#if node.children}
        {#each node.children as child}
            {@render treeNode(child, depth + 1)}
        {/each}
    {/if}
{/snippet}

&lt;div class="tree"&gt;
    {@render treeNode(tree)}
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Snippets vs Components</li>
    <br/>
    <table>
        <tr>
            <th>Use Snippets When</th>
            <th>Use Components When</th>
        </tr>
        <tr>
            <td>Template is only used in one component</td>
            <td>Template is reused across multiple files</td>
        </tr>
        <tr>
            <td>No need for separate state/lifecycle</td>
            <td>Needs its own state management</td>
        </tr>
        <tr>
            <td>Simple, presentational markup</td>
            <td>Complex logic or side effects</td>
        </tr>
        <tr>
            <td>Avoiding component overhead</td>
            <td>Need component features (actions, bindings)</td>
        </tr>
        <tr>
            <td>Render props / slot replacement</td>
            <td>Standalone, testable unit</td>
        </tr>
    </table>
    <br/><br/>



    <li>Migrating from Slots to Snippets</li>
    <br/>
    <ul>
        <li>Comparison of Svelte 4 slots vs Svelte 5 snippets:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 4: Default slot --&gt;
&lt;div&gt;
    &lt;slot /&gt;
&lt;/div&gt;

&lt;!-- Svelte 5: children snippet --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";
    let { children }: { children: Snippet } = $props();
&lt;/script&gt;
&lt;div&gt;
    {@render children()}
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 4: Named slot --&gt;
&lt;header&gt;
    &lt;slot name="header" /&gt;
&lt;/header&gt;

&lt;!-- Svelte 5: Named snippet prop --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";
    let { header }: { header?: Snippet } = $props();
&lt;/script&gt;
&lt;header&gt;
    {#if header}
        {@render header()}
    {/if}
&lt;/header&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 4: Slot props --&gt;
&lt;slot item={item} index={i} /&gt;

&lt;!-- Parent usage --&gt;
&lt;Component let:item let:index&gt;
    {item.name} at {index}
&lt;/Component&gt;

&lt;!-- Svelte 5: Snippet with parameters --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";
    let { renderItem }: { renderItem: Snippet&lt;[Item, number]&gt; } = $props();
&lt;/script&gt;
{@render renderItem(item, i)}

&lt;!-- Parent usage --&gt;
{#snippet itemRenderer(item: Item, index: number)}
    {item.name} at {index}
{/snippet}
&lt;Component renderItem={itemRenderer} /&gt;
</code></pre>
    <br/><br/>



    <li>Advanced: Snippet Composition</li>
    <br/>
    <ul>
        <li>Compose snippets for flexible layouts:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface Props {
        layout?: "horizontal" | "vertical" | "grid";
        items: unknown[];
        renderItem: Snippet&lt;[unknown, number]&gt;;
        header?: Snippet;
        footer?: Snippet;
        empty?: Snippet;
    }

    let {
        layout = "vertical",
        items,
        renderItem,
        header,
        footer,
        empty
    }: Props = $props();
&lt;/script&gt;

{#snippet wrapper(content: Snippet)}
    &lt;div class="container layout-{layout}"&gt;
        {#if header}
            &lt;div class="header"&gt;
                {@render header()}
            &lt;/div&gt;
        {/if}

        &lt;div class="content"&gt;
            {@render content()}
        &lt;/div&gt;

        {#if footer}
            &lt;div class="footer"&gt;
                {@render footer()}
            &lt;/div&gt;
        {/if}
    &lt;/div&gt;
{/snippet}

{#snippet itemList()}
    {#if items.length === 0}
        {#if empty}
            {@render empty()}
        {:else}
            &lt;p&gt;No items&lt;/p&gt;
        {/if}
    {:else}
        {#each items as item, i}
            &lt;div class="item"&gt;
                {@render renderItem(item, i)}
            &lt;/div&gt;
        {/each}
    {/if}
{/snippet}

{@render wrapper(itemList)}

&lt;style&gt;
    .layout-horizontal .content { display: flex; flex-direction: row; gap: 8px; }
    .layout-vertical .content { display: flex; flex-direction: column; gap: 8px; }
    .layout-grid .content { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Reusing Content Summary</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>Default content</td>
            <td><code>&lt;slot /&gt;</code></td>
            <td><code>{@render children()}</code></td>
        </tr>
        <tr>
            <td>Named content</td>
            <td><code>&lt;slot name="x" /&gt;</code></td>
            <td><code>{@render x()}</code> prop</td>
        </tr>
        <tr>
            <td>Pass to named</td>
            <td><code>slot="x"</code></td>
            <td><code>x={snippet}</code></td>
        </tr>
        <tr>
            <td>Data to parent</td>
            <td><code>&lt;slot {data} /&gt;</code> + <code>let:data</code></td>
            <td><code>Snippet&lt;[Data]&gt;</code></td>
        </tr>
        <tr>
            <td>Check existence</td>
            <td><code>$$slots.name</code></td>
            <td><code>{#if snippetProp}</code></td>
        </tr>
        <tr>
            <td>Default fallback</td>
            <td>Content inside <code>&lt;slot&gt;</code></td>
            <td><code>{:else}</code> block</td>
        </tr>
        <tr>
            <td>Local reuse</td>
            <td>N/A</td>
            <td><code>{#snippet}</code></td>
        </tr>
        <tr>
            <td>Type safety</td>
            <td>Limited</td>
            <td>Full with <code>Snippet&lt;T&gt;</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-advanced-bindings">Svelte Advanced Bindings</h3>
<ol>
    <br/>
    <li>Bindable Props with <code>$bindable</code> (Svelte 5)</li>
    <br/>
    <ul>
        <li>Use <code>$bindable</code> to make component props support two-way binding:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        count?: number;
    }

    let { count = $bindable(0) }: Props = $props();

    function increment(): void {
        count++;
    }

    function decrement(): void {
        count--;
    }
&lt;/script&gt;

&lt;div class="counter"&gt;
    &lt;button onclick={decrement}&gt;-&lt;/button&gt;
    &lt;span&gt;{count}&lt;/span&gt;
    &lt;button onclick={increment}&gt;+&lt;/button&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let value: number = $state(10);
&lt;/script&gt;

&lt;Counter bind:count={value} /&gt;

&lt;p&gt;Parent value: {value}&lt;/p&gt;
&lt;button onclick={() =&gt; value = 0}&gt;Reset from parent&lt;/button&gt;
</code></pre>

    <ul>
        <li>Changes in either parent or child sync both ways.</li>
        <li>The default value in <code>$bindable(0)</code> is used when no binding is provided.</li>
    </ul>
    <br/><br/>



    <li>Multiple Bindable Props</li>
    <br/>
    <ul>
        <li>Components can have multiple bindable props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- DateTimePicker.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        date?: string;
        time?: string;
        timezone?: string;
    }

    let {
        date = $bindable(""),
        time = $bindable(""),
        timezone = $bindable("UTC")
    }: Props = $props();

    const timezones: string[] = ["UTC", "EST", "PST", "CET", "JST"];
&lt;/script&gt;

&lt;div class="datetime-picker"&gt;
    &lt;input type="date" bind:value={date} /&gt;
    &lt;input type="time" bind:value={time} /&gt;
    &lt;select bind:value={timezone}&gt;
        {#each timezones as tz}
            &lt;option value={tz}&gt;{tz}&lt;/option&gt;
        {/each}
    &lt;/select&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import DateTimePicker from "./DateTimePicker.svelte";

    let selectedDate: string = $state("2024-01-15");
    let selectedTime: string = $state("14:30");
    let selectedTimezone: string = $state("EST");

    let combined = $derived(
        `${selectedDate} ${selectedTime} ${selectedTimezone}`
    );
&lt;/script&gt;

&lt;DateTimePicker
    bind:date={selectedDate}
    bind:time={selectedTime}
    bind:timezone={selectedTimezone}
/&gt;

&lt;p&gt;Selected: {combined}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Bindable with Validation</li>
    <br/>
    <ul>
        <li>Add validation logic while maintaining two-way binding:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ValidatedInput.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        value?: string;
        min?: number;
        max?: number;
        pattern?: RegExp;
    }

    let {
        value = $bindable(""),
        min = 0,
        max = Infinity,
        pattern
    }: Props = $props();

    let error: string = $state("");

    function validate(newValue: string): void {
        error = "";

        if (newValue.length &lt; min) {
            error = `Minimum ${min} characters required`;
        } else if (newValue.length &gt; max) {
            error = `Maximum ${max} characters allowed`;
        } else if (pattern && !pattern.test(newValue)) {
            error = "Invalid format";
        }
    }

    // Validate on change
    $effect(() =&gt; {
        validate(value);
    });

    let isValid = $derived(error === "");
&lt;/script&gt;

&lt;div class="validated-input"&gt;
    &lt;input
        type="text"
        bind:value
        class:invalid={!isValid}
    /&gt;
    {#if error}
        &lt;span class="error"&gt;{error}&lt;/span&gt;
    {/if}
&lt;/div&gt;

&lt;style&gt;
    .invalid { border-color: red; }
    .error { color: red; font-size: 0.8em; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import ValidatedInput from "./ValidatedInput.svelte";

    let email: string = $state("");
    let username: string = $state("");
&lt;/script&gt;

&lt;ValidatedInput
    bind:value={email}
    pattern={/^[^\s@]+@[^\s@]+\.[^\s@]+$/}
/&gt;

&lt;ValidatedInput
    bind:value={username}
    min={3}
    max={20}
/&gt;
</code></pre>
    <br/><br/>



    <li>File Input Binding</li>
    <br/>
    <ul>
        <li>Bind to file inputs to access selected files:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let files: FileList | null = $state(null);
    let previews: string[] = $state([]);

    $effect(() =&gt; {
        if (!files) {
            previews = [];
            return;
        }

        const newPreviews: string[] = [];

        for (const file of files) {
            if (file.type.startsWith("image/")) {
                const url = URL.createObjectURL(file);
                newPreviews.push(url);
            }
        }

        previews = newPreviews;

        // Cleanup URLs on change
        return () =&gt; {
            previews.forEach(url =&gt; URL.revokeObjectURL(url));
        };
    });

    function formatSize(bytes: number): string {
        if (bytes &lt; 1024) return bytes + " B";
        if (bytes &lt; 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
        return (bytes / (1024 * 1024)).toFixed(1) + " MB";
    }
&lt;/script&gt;

&lt;input type="file" bind:files multiple accept="image/*" /&gt;

{#if files && files.length &gt; 0}
    &lt;h4&gt;Selected Files:&lt;/h4&gt;
    &lt;ul&gt;
        {#each Array.from(files) as file, i}
            &lt;li&gt;
                {file.name} ({formatSize(file.size)})
            &lt;/li&gt;
        {/each}
    &lt;/ul&gt;

    &lt;div class="previews"&gt;
        {#each previews as src}
            &lt;img {src} alt="Preview" width="100" /&gt;
        {/each}
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>File Input Component with Bindable</li>
    <br/>
    <ul>
        <li>Create a reusable file input component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- FileUploader.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        files?: FileList | null;
        accept?: string;
        multiple?: boolean;
        maxSize?: number; // bytes
    }

    let {
        files = $bindable(null),
        accept = "*/*",
        multiple = false,
        maxSize = 10 * 1024 * 1024 // 10MB default
    }: Props = $props();

    let inputElement: HTMLInputElement;
    let dragOver: boolean = $state(false);
    let error: string = $state("");

    function validateFiles(fileList: FileList): boolean {
        error = "";

        for (const file of fileList) {
            if (file.size &gt; maxSize) {
                error = `File "${file.name}" exceeds maximum size`;
                return false;
            }
        }

        return true;
    }

    function handleDrop(event: DragEvent): void {
        event.preventDefault();
        dragOver = false;

        const droppedFiles = event.dataTransfer?.files;
        if (droppedFiles && validateFiles(droppedFiles)) {
            files = droppedFiles;
        }
    }

    function handleChange(event: Event): void {
        const target = event.target as HTMLInputElement;
        if (target.files && validateFiles(target.files)) {
            files = target.files;
        }
    }
&lt;/script&gt;

&lt;div
    class="dropzone"
    class:drag-over={dragOver}
    ondragover={(e) =&gt; { e.preventDefault(); dragOver = true; }}
    ondragleave={() =&gt; dragOver = false}
    ondrop={handleDrop}
    onclick={() =&gt; inputElement.click()}
&gt;
    &lt;input
        bind:this={inputElement}
        type="file"
        {accept}
        {multiple}
        onchange={handleChange}
        hidden
    /&gt;

    &lt;p&gt;Drop files here or click to browse&lt;/p&gt;

    {#if error}
        &lt;p class="error"&gt;{error}&lt;/p&gt;
    {/if}
&lt;/div&gt;

&lt;style&gt;
    .dropzone {
        border: 2px dashed #ccc;
        padding: 40px;
        text-align: center;
        cursor: pointer;
        transition: border-color 0.2s;
    }
    .drag-over { border-color: #007bff; background: #f0f8ff; }
    .error { color: red; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import FileUploader from "./FileUploader.svelte";

    let uploadedFiles: FileList | null = $state(null);
&lt;/script&gt;

&lt;FileUploader
    bind:files={uploadedFiles}
    accept="image/*,application/pdf"
    multiple
    maxSize={5 * 1024 * 1024}
/&gt;

{#if uploadedFiles}
    &lt;p&gt;{uploadedFiles.length} file(s) selected&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Details Element Binding</li>
    <br/>
    <ul>
        <li>Bind to the <code>open</code> state of <code>&lt;details&gt;</code> elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let detailsOpen: boolean = $state(false);

    interface FAQ {
        question: string;
        answer: string;
        open: boolean;
    }

    let faqs: FAQ[] = $state([
        { question: "What is Svelte?", answer: "A compiler-based framework.", open: false },
        { question: "Is it fast?", answer: "Yes, very fast!", open: false },
        { question: "Should I learn it?", answer: "Absolutely!", open: false }
    ]);

    function closeAll(): void {
        faqs = faqs.map(faq =&gt; ({ ...faq, open: false }));
    }

    function openAll(): void {
        faqs = faqs.map(faq =&gt; ({ ...faq, open: true }));
    }
&lt;/script&gt;

&lt;h3&gt;Single Details&lt;/h3&gt;
&lt;details bind:open={detailsOpen}&gt;
    &lt;summary&gt;Click to {detailsOpen ? "close" : "open"}&lt;/summary&gt;
    &lt;p&gt;Hidden content revealed!&lt;/p&gt;
&lt;/details&gt;

&lt;p&gt;Details is {detailsOpen ? "open" : "closed"}&lt;/p&gt;
&lt;button onclick={() =&gt; detailsOpen = !detailsOpen}&gt;
    Toggle programmatically
&lt;/button&gt;

&lt;h3&gt;FAQ Accordion&lt;/h3&gt;
&lt;button onclick={openAll}&gt;Open All&lt;/button&gt;
&lt;button onclick={closeAll}&gt;Close All&lt;/button&gt;

{#each faqs as faq, i}
    &lt;details bind:open={faq.open}&gt;
        &lt;summary&gt;{faq.question}&lt;/summary&gt;
        &lt;p&gt;{faq.answer}&lt;/p&gt;
    &lt;/details&gt;
{/each}
</code></pre>
    <br/><br/>



    <li>Dialog Element Binding</li>
    <br/>
    <ul>
        <li>Bind to the <code>open</code> attribute of <code>&lt;dialog&gt;</code> elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let dialogElement: HTMLDialogElement;
    let isOpen: boolean = $state(false);
    let returnValue: string = $state("");

    function openModal(): void {
        dialogElement.showModal();
        isOpen = true;
    }

    function closeModal(value: string): void {
        dialogElement.close(value);
        isOpen = false;
        returnValue = value;
    }

    function handleClose(): void {
        isOpen = false;
        returnValue = dialogElement.returnValue;
    }
&lt;/script&gt;

&lt;button onclick={openModal}&gt;Open Dialog&lt;/button&gt;
&lt;p&gt;Last result: {returnValue || "None"}&lt;/p&gt;

&lt;dialog bind:this={dialogElement} onclose={handleClose}&gt;
    &lt;h2&gt;Confirm Action&lt;/h2&gt;
    &lt;p&gt;Are you sure you want to proceed?&lt;/p&gt;

    &lt;div class="actions"&gt;
        &lt;button onclick={() =&gt; closeModal("cancel")}&gt;Cancel&lt;/button&gt;
        &lt;button onclick={() =&gt; closeModal("confirm")}&gt;Confirm&lt;/button&gt;
    &lt;/div&gt;
&lt;/dialog&gt;

&lt;style&gt;
    dialog::backdrop {
        background: rgba(0, 0, 0, 0.5);
    }
    .actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 16px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Binding to Component Instances</li>
    <br/>
    <ul>
        <li>Get a reference to a component instance to call its methods:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- VideoPlayer.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        src: string;
    }

    let { src }: Props = $props();

    let videoElement: HTMLVideoElement;
    let currentTime: number = $state(0);
    let duration: number = $state(0);
    let paused: boolean = $state(true);

    // Expose methods for parent to call
    export function play(): void {
        videoElement.play();
    }

    export function pause(): void {
        videoElement.pause();
    }

    export function seek(time: number): void {
        videoElement.currentTime = time;
    }

    export function togglePlay(): void {
        if (paused) {
            play();
        } else {
            pause();
        }
    }
&lt;/script&gt;

&lt;div class="video-player"&gt;
    &lt;video
        bind:this={videoElement}
        bind:currentTime
        bind:duration
        bind:paused
        {src}
    &gt;
        &lt;track kind="captions" /&gt;
    &lt;/video&gt;

    &lt;div class="controls"&gt;
        &lt;button onclick={togglePlay}&gt;
            {paused ? "▶️" : "⏸️"}
        &lt;/button&gt;
        &lt;span&gt;{currentTime.toFixed(1)} / {duration.toFixed(1)}&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import VideoPlayer from "./VideoPlayer.svelte";

    let player: VideoPlayer;
&lt;/script&gt;

&lt;VideoPlayer bind:this={player} src="video.mp4" /&gt;

&lt;div class="external-controls"&gt;
    &lt;button onclick={() =&gt; player.play()}&gt;Play&lt;/button&gt;
    &lt;button onclick={() =&gt; player.pause()}&gt;Pause&lt;/button&gt;
    &lt;button onclick={() =&gt; player.seek(0)}&gt;Restart&lt;/button&gt;
    &lt;button onclick={() =&gt; player.seek(30)}&gt;Skip to 30s&lt;/button&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Binding to Inline Styles</li>
    <br/>
    <ul>
        <li>Bind CSS custom properties (CSS variables) directly:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let color: string = $state("#007bff");
    let size: number = $state(16);
    let opacity: number = $state(1);
    let rotation: number = $state(0);
&lt;/script&gt;

&lt;div class="controls"&gt;
    &lt;label&gt;
        Color: &lt;input type="color" bind:value={color} /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        Size: &lt;input type="range" bind:value={size} min="8" max="48" /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        Opacity: &lt;input type="range" bind:value={opacity} min="0" max="1" step="0.1" /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        Rotation: &lt;input type="range" bind:value={rotation} min="0" max="360" /&gt;
    &lt;/label&gt;
&lt;/div&gt;

&lt;div
    class="styled-box"
    style:--color={color}
    style:--size="{size}px"
    style:--opacity={opacity}
    style:--rotation="{rotation}deg"
&gt;
    Styled Box
&lt;/div&gt;

&lt;style&gt;
    .styled-box {
        color: var(--color);
        font-size: var(--size);
        opacity: var(--opacity);
        transform: rotate(var(--rotation));
        padding: 20px;
        border: 2px solid var(--color);
        display: inline-block;
        transition: all 0.2s;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Indeterminate Checkbox Binding</li>
    <br/>
    <ul>
        <li>Bind to the <code>indeterminate</code> state of checkboxes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Task {
        id: number;
        name: string;
        completed: boolean;
    }

    let tasks: Task[] = $state([
        { id: 1, name: "Task 1", completed: true },
        { id: 2, name: "Task 2", completed: false },
        { id: 3, name: "Task 3", completed: true }
    ]);

    let allChecked = $derived(tasks.every(t =&gt; t.completed));
    let noneChecked = $derived(tasks.every(t =&gt; !t.completed));
    let indeterminate = $derived(!allChecked && !noneChecked);

    function toggleAll(): void {
        const newState = !allChecked;
        tasks = tasks.map(t =&gt; ({ ...t, completed: newState }));
    }
&lt;/script&gt;

&lt;label&gt;
    &lt;input
        type="checkbox"
        checked={allChecked}
        {indeterminate}
        onchange={toggleAll}
    /&gt;
    Select All
&lt;/label&gt;

&lt;ul&gt;
    {#each tasks as task}
        &lt;li&gt;
            &lt;label&gt;
                &lt;input type="checkbox" bind:checked={task.completed} /&gt;
                {task.name}
            &lt;/label&gt;
        &lt;/li&gt;
    {/each}
&lt;/ul&gt;

&lt;p&gt;
    Status:
    {#if allChecked}
        All selected
    {:else if noneChecked}
        None selected
    {:else}
        Partial selection
    {/if}
&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Binding to Canvas</li>
    <br/>
    <ul>
        <li>Bind to canvas and create interactive drawings:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let canvas: HTMLCanvasElement;
    let ctx: CanvasRenderingContext2D | null = null;
    let isDrawing: boolean = $state(false);
    let color: string = $state("#000000");
    let lineWidth: number = $state(2);

    $effect(() =&gt; {
        if (canvas) {
            ctx = canvas.getContext("2d");
            if (ctx) {
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
            }
        }
    });

    function startDrawing(e: MouseEvent): void {
        if (!ctx) return;
        isDrawing = true;
        ctx.beginPath();
        ctx.moveTo(e.offsetX, e.offsetY);
    }

    function draw(e: MouseEvent): void {
        if (!isDrawing || !ctx) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.lineTo(e.offsetX, e.offsetY);
        ctx.stroke();
    }

    function stopDrawing(): void {
        isDrawing = false;
    }

    function clearCanvas(): void {
        if (ctx && canvas) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }
&lt;/script&gt;

&lt;div class="controls"&gt;
    &lt;input type="color" bind:value={color} /&gt;
    &lt;input type="range" bind:value={lineWidth} min="1" max="20" /&gt;
    &lt;button onclick={clearCanvas}&gt;Clear&lt;/button&gt;
&lt;/div&gt;

&lt;canvas
    bind:this={canvas}
    width="400"
    height="300"
    onmousedown={startDrawing}
    onmousemove={draw}
    onmouseup={stopDrawing}
    onmouseleave={stopDrawing}
    style="border: 1px solid #ccc; cursor: crosshair;"
&gt;&lt;/canvas&gt;
</code></pre>
    <br/><br/>



    <li>Binding to Audio Element</li>
    <br/>
    <ul>
        <li>Create a full audio player with comprehensive bindings:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Track {
        title: string;
        artist: string;
        src: string;
    }

    let tracks: Track[] = [
        { title: "Song 1", artist: "Artist A", src: "song1.mp3" },
        { title: "Song 2", artist: "Artist B", src: "song2.mp3" }
    ];

    let currentTrackIndex: number = $state(0);
    let audioElement: HTMLAudioElement;

    // Bindable audio properties
    let currentTime: number = $state(0);
    let duration: number = $state(0);
    let paused: boolean = $state(true);
    let volume: number = $state(1);
    let muted: boolean = $state(false);
    let playbackRate: number = $state(1);
    let ended: boolean = $state(false);
    let seeking: boolean = $state(false);

    let currentTrack = $derived(tracks[currentTrackIndex]);
    let progress = $derived(duration ? (currentTime / duration) * 100 : 0);

    function formatTime(seconds: number): string {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
    }

    function nextTrack(): void {
        currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
    }

    function prevTrack(): void {
        currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
    }

    $effect(() =&gt; {
        if (ended) {
            nextTrack();
        }
    });
&lt;/script&gt;

&lt;audio
    bind:this={audioElement}
    bind:currentTime
    bind:duration
    bind:paused
    bind:volume
    bind:muted
    bind:playbackRate
    bind:ended
    bind:seeking
    src={currentTrack.src}
&gt;&lt;/audio&gt;

&lt;div class="audio-player"&gt;
    &lt;div class="track-info"&gt;
        &lt;strong&gt;{currentTrack.title}&lt;/strong&gt;
        &lt;span&gt;{currentTrack.artist}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="progress-bar"&gt;
        &lt;input
            type="range"
            min="0"
            max={duration || 0}
            bind:value={currentTime}
        /&gt;
        &lt;span&gt;{formatTime(currentTime)} / {formatTime(duration)}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="controls"&gt;
        &lt;button onclick={prevTrack}&gt;⏮️&lt;/button&gt;
        &lt;button onclick={() =&gt; paused = !paused}&gt;
            {paused ? "▶️" : "⏸️"}
        &lt;/button&gt;
        &lt;button onclick={nextTrack}&gt;⏭️&lt;/button&gt;
    &lt;/div&gt;

    &lt;div class="volume"&gt;
        &lt;button onclick={() =&gt; muted = !muted}&gt;
            {muted ? "🔇" : "🔊"}
        &lt;/button&gt;
        &lt;input type="range" min="0" max="1" step="0.1" bind:value={volume} /&gt;
    &lt;/div&gt;

    &lt;div class="speed"&gt;
        &lt;label&gt;
            Speed:
            &lt;select bind:value={playbackRate}&gt;
                &lt;option value={0.5}&gt;0.5x&lt;/option&gt;
                &lt;option value={1}&gt;1x&lt;/option&gt;
                &lt;option value={1.5}&gt;1.5x&lt;/option&gt;
                &lt;option value={2}&gt;2x&lt;/option&gt;
            &lt;/select&gt;
        &lt;/label&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Binding with Getter/Setter Pattern</li>
    <br/>
    <ul>
        <li>Create computed bindings using getters and setters:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Store value in cents, display in dollars
    let cents: number = $state(1000);

    // Create a "virtual" binding with getter/setter
    let dollars = {
        get value(): number {
            return cents / 100;
        },
        set value(v: number) {
            cents = Math.round(v * 100);
        }
    };

    // Temperature conversion
    let celsius: number = $state(0);

    let fahrenheit = {
        get value(): number {
            return (celsius * 9/5) + 32;
        },
        set value(f: number) {
            celsius = (f - 32) * 5/9;
        }
    };
&lt;/script&gt;

&lt;div&gt;
    &lt;h4&gt;Currency (stored as cents: {cents})&lt;/h4&gt;
    &lt;label&gt;
        Dollars: $
        &lt;input
            type="number"
            step="0.01"
            value={dollars.value}
            oninput={(e) =&gt; dollars.value = parseFloat(e.currentTarget.value) || 0}
        /&gt;
    &lt;/label&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h4&gt;Temperature&lt;/h4&gt;
    &lt;label&gt;
        Celsius:
        &lt;input type="number" bind:value={celsius} /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        Fahrenheit:
        &lt;input
            type="number"
            value={fahrenheit.value}
            oninput={(e) =&gt; fahrenheit.value = parseFloat(e.currentTarget.value) || 0}
        /&gt;
    &lt;/label&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Binding to Custom Form Components</li>
    <br/>
    <ul>
        <li>Create fully custom form components with binding support:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- StarRating.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        rating?: number;
        max?: number;
        readonly?: boolean;
    }

    let {
        rating = $bindable(0),
        max = 5,
        readonly = false
    }: Props = $props();

    let hoverRating: number | null = $state(null);

    function setRating(value: number): void {
        if (!readonly) {
            rating = value;
        }
    }

    function handleHover(value: number | null): void {
        if (!readonly) {
            hoverRating = value;
        }
    }

    let displayRating = $derived(hoverRating ?? rating);
&lt;/script&gt;

&lt;div class="star-rating" class:readonly&gt;
    {#each Array(max) as _, i}
        {@const value = i + 1}
        &lt;button
            type="button"
            class="star"
            class:filled={value &lt;= displayRating}
            onclick={() =&gt; setRating(value)}
            onmouseenter={() =&gt; handleHover(value)}
            onmouseleave={() =&gt; handleHover(null)}
            disabled={readonly}
        &gt;
            {value &lt;= displayRating ? "★" : "☆"}
        &lt;/button&gt;
    {/each}
&lt;/div&gt;

&lt;style&gt;
    .star-rating { display: flex; gap: 4px; }
    .star {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #ffc107;
    }
    .readonly .star { cursor: default; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- RangeSlider.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        min?: number;
        max?: number;
        step?: number;
        value?: [number, number];
    }

    let {
        min = 0,
        max = 100,
        step = 1,
        value = $bindable([25, 75] as [number, number])
    }: Props = $props();

    function handleMinChange(e: Event): void {
        const target = e.target as HTMLInputElement;
        const newMin = parseFloat(target.value);
        if (newMin &lt;= value[1]) {
            value = [newMin, value[1]];
        }
    }

    function handleMaxChange(e: Event): void {
        const target = e.target as HTMLInputElement;
        const newMax = parseFloat(target.value);
        if (newMax &gt;= value[0]) {
            value = [value[0], newMax];
        }
    }
&lt;/script&gt;

&lt;div class="range-slider"&gt;
    &lt;input
        type="range"
        {min}
        {max}
        {step}
        value={value[0]}
        oninput={handleMinChange}
    /&gt;
    &lt;input
        type="range"
        {min}
        {max}
        {step}
        value={value[1]}
        oninput={handleMaxChange}
    /&gt;
    &lt;div class="values"&gt;
        {value[0]} - {value[1]}
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import StarRating from "./StarRating.svelte";
    import RangeSlider from "./RangeSlider.svelte";

    let movieRating: number = $state(3);
    let priceRange: [number, number] = $state([20, 80]);
&lt;/script&gt;

&lt;h4&gt;Rate this movie:&lt;/h4&gt;
&lt;StarRating bind:rating={movieRating} /&gt;
&lt;p&gt;You rated: {movieRating} stars&lt;/p&gt;

&lt;h4&gt;Price range:&lt;/h4&gt;
&lt;RangeSlider bind:value={priceRange} min={0} max={100} /&gt;
&lt;p&gt;Selected: ${priceRange[0]} - ${priceRange[1]}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Debounced Binding</li>
    <br/>
    <ul>
        <li>Create bindings with debouncing for performance:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- DebouncedInput.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        value?: string;
        delay?: number;
        placeholder?: string;
    }

    let {
        value = $bindable(""),
        delay = 300,
        placeholder = ""
    }: Props = $props();

    let internalValue: string = $state(value);
    let timeoutId: ReturnType&lt;typeof setTimeout&gt;;

    // Sync internal value when external value changes
    $effect(() =&gt; {
        internalValue = value;
    });

    function handleInput(e: Event): void {
        const target = e.target as HTMLInputElement;
        internalValue = target.value;

        clearTimeout(timeoutId);
        timeoutId = setTimeout(() =&gt; {
            value = internalValue;
        }, delay);
    }

    // Cleanup on unmount
    $effect(() =&gt; {
        return () =&gt; clearTimeout(timeoutId);
    });
&lt;/script&gt;

&lt;input
    type="text"
    value={internalValue}
    oninput={handleInput}
    {placeholder}
/&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import DebouncedInput from "./DebouncedInput.svelte";

    let searchQuery: string = $state("");
    let searchCount: number = $state(0);

    $effect(() =&gt; {
        if (searchQuery) {
            searchCount++;
            console.log(`Searching for: ${searchQuery}`);
        }
    });
&lt;/script&gt;

&lt;DebouncedInput
    bind:value={searchQuery}
    delay={500}
    placeholder="Search..."
/&gt;

&lt;p&gt;Query: {searchQuery}&lt;/p&gt;
&lt;p&gt;Search triggered: {searchCount} times&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Binding to Scroll Position</li>
    <br/>
    <ul>
        <li>Create scroll-bound animations and effects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let scrollY: number = $state(0);
    let innerHeight: number = $state(0);
    let scrollContainer: HTMLDivElement;
    let containerScrollTop: number = $state(0);

    let scrollProgress = $derived(
        scrollY / (document.body.scrollHeight - innerHeight) * 100 || 0
    );

    let headerOpacity = $derived(
        Math.max(0, 1 - scrollY / 200)
    );

    let showBackToTop = $derived(scrollY &gt; 300);

    function scrollToTop(): void {
        window.scrollTo({ top: 0, behavior: "smooth" });
    }
&lt;/script&gt;

&lt;svelte:window bind:scrollY bind:innerHeight /&gt;

&lt;!-- Progress bar --&gt;
&lt;div class="scroll-progress" style="width: {scrollProgress}%"&gt;&lt;/div&gt;

&lt;!-- Header with fade effect --&gt;
&lt;header style="opacity: {headerOpacity}"&gt;
    &lt;h1&gt;Scroll Demo&lt;/h1&gt;
&lt;/header&gt;

&lt;!-- Content --&gt;
&lt;main&gt;
    &lt;p&gt;Scroll Y: {scrollY.toFixed(0)}px&lt;/p&gt;
    &lt;p&gt;Progress: {scrollProgress.toFixed(1)}%&lt;/p&gt;

    &lt;!-- Lots of content to enable scrolling --&gt;
    {#each Array(50) as _, i}
        &lt;p&gt;Paragraph {i + 1}&lt;/p&gt;
    {/each}
&lt;/main&gt;

&lt;!-- Back to top button --&gt;
{#if showBackToTop}
    &lt;button class="back-to-top" onclick={scrollToTop}&gt;
        ↑ Top
    &lt;/button&gt;
{/if}

&lt;style&gt;
    .scroll-progress {
        position: fixed;
        top: 0;
        left: 0;
        height: 3px;
        background: #007bff;
        z-index: 100;
        transition: width 0.1s;
    }
    header {
        position: fixed;
        top: 3px;
        width: 100%;
        background: white;
        padding: 10px;
        z-index: 99;
    }
    main { margin-top: 80px; }
    .back-to-top {
        position: fixed;
        bottom: 20px;
        right: 20px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Advanced Bindings Summary</li>
    <br/>

    <table>
        <tr>
            <th>Binding Type</th>
            <th>Syntax</th>
            <th>Use Case</th>
        </tr>
        <tr>
            <td>Bindable prop</td>
            <td><code>$bindable(default)</code></td>
            <td>Two-way component props</td>
        </tr>
        <tr>
            <td>File input</td>
            <td><code>bind:files</code></td>
            <td>File uploads</td>
        </tr>
        <tr>
            <td>Details open</td>
            <td><code>bind:open</code></td>
            <td>Accordions, dropdowns</td>
        </tr>
        <tr>
            <td>Component instance</td>
            <td><code>bind:this</code></td>
            <td>Call component methods</td>
        </tr>
        <tr>
            <td>CSS custom property</td>
            <td><code>style:--prop</code></td>
            <td>Dynamic theming</td>
        </tr>
        <tr>
            <td>Indeterminate</td>
            <td><code>indeterminate</code></td>
            <td>Partial checkbox state</td>
        </tr>
        <tr>
            <td>Canvas reference</td>
            <td><code>bind:this</code></td>
            <td>Drawing, graphics</td>
        </tr>
        <tr>
            <td>Audio/Video</td>
            <td><code>bind:currentTime</code>, etc.</td>
            <td>Media players</td>
        </tr>
        <tr>
            <td>Window scroll</td>
            <td><code>bind:scrollY</code></td>
            <td>Scroll effects</td>
        </tr>
        <tr>
            <td>Debounced</td>
            <td>Custom component</td>
            <td>Search, performance</td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-context-api">Svelte Context API</h3>
<ol>
    <li>What Is Context?</li>
    <br/>
    <ul>
        <li><b>Context</b> allows you to pass data between components without prop drilling.</li>
        <br/>
        <li>Data flows from a parent component to <u>any descendant</u>, regardless of depth.</li>
        <br/>
        <li>Key characteristics:
            <ul>
                <li>Context is <u>not reactive</u> by default (but can hold reactive values)</li>
                <li>Context is available only during component initialization</li>
                <li>Each component tree can have its own context values</li>
            </ul>
        </li>
        <br/>
        <li>Common use cases:
            <ul>
                <li>Theme/styling configuration</li>
                <li>Authentication state</li>
                <li>Internationalization (i18n)</li>
                <li>Feature flags</li>
                <li>Shared services</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Basic Context: <code>setContext</code> and <code>getContext</code></li>
    <br/>
    <ul>
        <li>Use <code>setContext</code> to provide a value and <code>getContext</code> to consume it:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import { setContext } from "svelte";
    import Child from "./Child.svelte";

    // Set a context value with a key
    setContext("username", "Alice");
    setContext("theme", "dark");
&lt;/script&gt;

&lt;div&gt;
    &lt;h2&gt;Parent Component&lt;/h2&gt;
    &lt;Child /&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Child.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getContext } from "svelte";
    import GrandChild from "./GrandChild.svelte";

    // Get context values
    const username = getContext&lt;string&gt;("username");
    const theme    = getContext&lt;string&gt;("theme");
&lt;/script&gt;

&lt;div&gt;
    &lt;p&gt;Child: User is {username}, theme is {theme}&lt;/p&gt;
    &lt;GrandChild /&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- GrandChild.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getContext } from "svelte";

    // Context is available at any depth
    const username = getContext&lt;string&gt;("username");
&lt;/script&gt;

&lt;p&gt;GrandChild: Hello, {username}!&lt;/p&gt;
</code></pre>

    <ul>
        <li>Context must be set during component initialization (not in event handlers or effects).</li>
    </ul>
    <br/><br/>



    <li>Type-Safe Context Keys</li>
    <br/>
    <ul>
        <li>Use symbols or typed keys for better type safety:</li>
    </ul>

<pre><code class="language-ts line-numbers">// context-keys.ts
import type { Writable } from "svelte/store";

// Define context keys as symbols for uniqueness
export const THEME_KEY  = Symbol("theme");
export const USER_KEY   = Symbol("user");
export const CONFIG_KEY = Symbol("config");

// Define types for context values
export interface User {
    id: number;
    name: string;
    email: string;
    role: "admin" | "user" | "guest";
}

export interface ThemeConfig {
    mode: "light" | "dark";
    primaryColor: string;
    fontSize: number;
}

export interface AppConfig {
    apiUrl: string;
    features: {
        darkMode: boolean;
        notifications: boolean;
    };
}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script lang="ts"&gt;
    import { setContext } from "svelte";
    import { THEME_KEY, USER_KEY, CONFIG_KEY } from "./context-keys";
    import type { User, ThemeConfig, AppConfig } from "./context-keys";
    import Dashboard from "./Dashboard.svelte";

    const user: User = {
        id: 1,
        name: "Alice",
        email: "alice@example.com",
        role: "admin"
    };

    const theme: ThemeConfig = {
        mode: "dark",
        primaryColor: "#007bff",
        fontSize: 16
    };

    const config: AppConfig = {
        apiUrl: "https://api.example.com",
        features: {
            darkMode: true,
            notifications: true
        }
    };

    setContext(THEME_KEY, theme);
    setContext(USER_KEY, user);
    setContext(CONFIG_KEY, config);
&lt;/script&gt;

&lt;Dashboard /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Dashboard.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getContext } from "svelte";
    import { THEME_KEY, USER_KEY } from "./context-keys";
    import type { User, ThemeConfig } from "./context-keys";

    // Type-safe context retrieval
    const user = getContext&lt;User&gt;(USER_KEY);
    const theme = getContext&lt;ThemeConfig&gt;(THEME_KEY);
&lt;/script&gt;

&lt;div style="background: {theme.mode === 'dark' ? '#333' : '#fff'}"&gt;
    &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
    &lt;p&gt;Role: {user.role}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Checking for Context with <code>hasContext</code></li>
    <br/>
    <ul>
        <li>Use <code>hasContext</code> to check if a context exists before accessing it:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { getContext, hasContext } from "svelte";

    interface Theme {
        mode: "light" | "dark";
    }

    const THEME_KEY = Symbol("theme");

    // Check if context exists
    const hasTheme = hasContext(THEME_KEY);

    // Provide fallback if context doesn't exist
    const theme: Theme = hasContext(THEME_KEY)
        ? getContext&lt;Theme&gt;(THEME_KEY)
        : { mode: "light" }; // default fallback

    // Or use a helper function
    function getContextWithDefault&lt;T&gt;(key: symbol, defaultValue: T): T {
        return hasContext(key) ? getContext&lt;T&gt;(key) : defaultValue;
    }

    const safeTheme = getContextWithDefault&lt;Theme&gt;(THEME_KEY, { mode: "light" });
&lt;/script&gt;

&lt;p&gt;Theme context exists: {hasTheme}&lt;/p&gt;
&lt;p&gt;Current mode: {theme.mode}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Getting All Contexts with <code>getAllContexts</code></li>
    <br/>
    <ul>
        <li>Retrieve all available contexts as a Map:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import { setContext } from "svelte";
    import Child from "./Child.svelte";

    setContext("theme", "dark");
    setContext("language", "en");
    setContext("userId", 123);
&lt;/script&gt;

&lt;Child /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Child.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getAllContexts, setContext } from "svelte";
    import GrandChild from "./GrandChild.svelte";

    // Add more context at this level
    setContext("role", "admin");

    // Get all contexts (including from ancestors)
    const allContexts = getAllContexts();

    // Convert to array for display
    const contextEntries = Array.from(allContexts.entries());
&lt;/script&gt;

&lt;div&gt;
    &lt;h3&gt;Available Contexts:&lt;/h3&gt;
    &lt;ul&gt;
        {#each contextEntries as [key, value]}
            &lt;li&gt;{String(key)}: {JSON.stringify(value)}&lt;/li&gt;
        {/each}
    &lt;/ul&gt;

    &lt;GrandChild /&gt;
&lt;/div&gt;
</code></pre>

    <ul>
        <li><code>getAllContexts</code> is useful for:
            <ul>
                <li>Debugging context availability</li>
                <li>Forwarding all contexts to dynamically created components</li>
                <li>Building context-aware wrapper components</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Reactive Context with Svelte 5</li>
    <br/>
    <ul>
        <li>Context values are not reactive by default, but you can pass reactive state:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ThemeProvider.svelte --&gt;
&lt;script lang="ts"&gt;
    import { setContext } from "svelte";
    import type { Snippet } from "svelte";

    interface Props {
        children: Snippet;
    }

    let { children }: Props = $props();

    // Create reactive state
    let mode: "light" | "dark" = $state("light");
    let primaryColor: string = $state("#007bff");

    // Create a context object with getters and methods
    const themeContext = {
        get mode() { return mode; },
        get primaryColor() { return primaryColor; },
        toggle() {
            mode = mode === "light" ? "dark" : "light";
        },
        setColor(color: string) {
            primaryColor = color;
        }
    };

    setContext("theme", themeContext);
&lt;/script&gt;

{@render children()}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script lang="ts"&gt;
    import ThemeProvider from "./ThemeProvider.svelte";
    import ThemedContent from "./ThemedContent.svelte";
&lt;/script&gt;

&lt;ThemeProvider&gt;
    &lt;ThemedContent /&gt;
&lt;/ThemeProvider&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- ThemedContent.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getContext } from "svelte";

    interface ThemeContext {
        readonly mode: "light" | "dark";
        readonly primaryColor: string;
        toggle: () =&gt; void;
        setColor: (color: string) =&gt; void;
    }

    const theme = getContext&lt;ThemeContext&gt;("theme");
&lt;/script&gt;

&lt;div
    class="content"
    style="
        background: {theme.mode === 'dark' ? '#1a1a1a' : '#ffffff'};
        color: {theme.mode === 'dark' ? '#ffffff' : '#1a1a1a'};
    "
&gt;
    &lt;p&gt;Current theme: {theme.mode}&lt;/p&gt;
    &lt;p&gt;Primary color: {theme.primaryColor}&lt;/p&gt;

    &lt;button onclick={theme.toggle}&gt;
        Toggle Theme
    &lt;/button&gt;

    &lt;input
        type="color"
        value={theme.primaryColor}
        oninput={(e) =&gt; theme.setColor(e.currentTarget.value)}
    /&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Context Factory Pattern</li>
    <br/>
    <ul>
        <li>Create reusable context with factory functions:</li>
    </ul>

<pre><code class="language-ts line-numbers">// auth-context.svelte.ts
import { setContext, getContext, hasContext } from "svelte";

const AUTH_KEY = Symbol("auth");

export interface User {
    id: number;
    name: string;
    email: string;
}

export interface AuthContext {
    readonly user: User | null;
    readonly isAuthenticated: boolean;
    readonly isLoading: boolean;
    login: (email: string, password: string) =&gt; Promise&lt;void&gt;;
    logout: () =&gt; void;
}

export function createAuthContext(): AuthContext {
    let user: User | null = $state(null);
    let isLoading: boolean = $state(false);

    const context: AuthContext = {
        get user() { return user; },
        get isAuthenticated() { return user !== null; },
        get isLoading() { return isLoading; },

        async login(email: string, password: string) {
            isLoading = true;
            try {
                // Simulate API call
                await new Promise(r =&gt; setTimeout(r, 1000));
                user = { id: 1, name: "Alice", email };
            } finally {
                isLoading = false;
            }
        },

        logout() {
            user = null;
        }
    };

    setContext(AUTH_KEY, context);
    return context;
}

export function getAuthContext(): AuthContext {
    if (!hasContext(AUTH_KEY)) {
        throw new Error("Auth context not found. Did you forget to wrap with AuthProvider?");
    }
    return getContext&lt;AuthContext&gt;(AUTH_KEY);
}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- AuthProvider.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";
    import { createAuthContext } from "./auth-context.svelte";

    interface Props {
        children: Snippet;
    }

    let { children }: Props = $props();

    // Initialize auth context
    createAuthContext();
&lt;/script&gt;

{@render children()}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- LoginForm.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getAuthContext } from "./auth-context.svelte";

    const auth = getAuthContext();

    let email: string = $state("");
    let password: string = $state("");

    async function handleSubmit(): Promise&lt;void&gt; {
        await auth.login(email, password);
    }
&lt;/script&gt;

{#if auth.isAuthenticated}
    &lt;div&gt;
        &lt;p&gt;Welcome, {auth.user?.name}!&lt;/p&gt;
        &lt;button onclick={auth.logout}&gt;Logout&lt;/button&gt;
    &lt;/div&gt;
{:else}
    &lt;form onsubmit={(e) =&gt; { e.preventDefault(); handleSubmit(); }}&gt;
        &lt;input bind:value={email} placeholder="Email" disabled={auth.isLoading} /&gt;
        &lt;input bind:value={password} type="password" placeholder="Password" disabled={auth.isLoading} /&gt;
        &lt;button type="submit" disabled={auth.isLoading}&gt;
            {auth.isLoading ? "Loading..." : "Login"}
        &lt;/button&gt;
    &lt;/form&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Internationalization (i18n) Context</li>
    <br/>
    <ul>
        <li>Build a complete i18n solution with context:</li>
    </ul>

<pre><code class="language-ts line-numbers">// i18n-context.svelte.ts
import { setContext, getContext } from "svelte";

const I18N_KEY = Symbol("i18n");

type Locale = "en" | "es" | "fr" | "de";

interface Translations {
    [key: string]: string;
}

const translations: Record&lt;Locale, Translations&gt; = {
    en: {
        greeting: "Hello",
        farewell: "Goodbye",
        welcome: "Welcome, {name}!",
        items: "{count} item(s)"
    },
    es: {
        greeting: "Hola",
        farewell: "Adiós",
        welcome: "¡Bienvenido, {name}!",
        items: "{count} artículo(s)"
    },
    fr: {
        greeting: "Bonjour",
        farewell: "Au revoir",
        welcome: "Bienvenue, {name}!",
        items: "{count} article(s)"
    },
    de: {
        greeting: "Hallo",
        farewell: "Auf Wiedersehen",
        welcome: "Willkommen, {name}!",
        items: "{count} Artikel"
    }
};

export interface I18nContext {
    readonly locale: Locale;
    readonly availableLocales: Locale[];
    setLocale: (locale: Locale) =&gt; void;
    t: (key: string, params?: Record&lt;string, string | number&gt;) =&gt; string;
}

export function createI18nContext(initialLocale: Locale = "en"): I18nContext {
    let locale: Locale = $state(initialLocale);

    function t(key: string, params?: Record&lt;string, string | number&gt;): string {
        let text = translations[locale][key] || key;

        if (params) {
            Object.entries(params).forEach(([k, v]) =&gt; {
                text = text.replace(`{${k}}`, String(v));
            });
        }

        return text;
    }

    const context: I18nContext = {
        get locale() { return locale; },
        get availableLocales() { return ["en", "es", "fr", "de"] as Locale[]; },
        setLocale(newLocale: Locale) {
            locale = newLocale;
        },
        t
    };

    setContext(I18N_KEY, context);
    return context;
}

export function getI18n(): I18nContext {
    return getContext&lt;I18nContext&gt;(I18N_KEY);
}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- I18nProvider.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";
    import { createI18nContext, type I18nContext } from "./i18n-context.svelte";

    interface Props {
        locale?: "en" | "es" | "fr" | "de";
        children: Snippet;
    }

    let { locale = "en", children }: Props = $props();

    createI18nContext(locale);
&lt;/script&gt;

{@render children()}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- TranslatedContent.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getI18n } from "./i18n-context.svelte";

    const i18n = getI18n();

    let itemCount: number = $state(5);
&lt;/script&gt;

&lt;div&gt;
    &lt;select
        value={i18n.locale}
        onchange={(e) =&gt; i18n.setLocale(e.currentTarget.value as "en" | "es" | "fr" | "de")}
    &gt;
        {#each i18n.availableLocales as loc}
            &lt;option value={loc}&gt;{loc.toUpperCase()}&lt;/option&gt;
        {/each}
    &lt;/select&gt;

    &lt;h1&gt;{i18n.t("greeting")}&lt;/h1&gt;
    &lt;p&gt;{i18n.t("welcome", { name: "Alice" })}&lt;/p&gt;

    &lt;input type="number" bind:value={itemCount} min="0" /&gt;
    &lt;p&gt;{i18n.t("items", { count: itemCount })}&lt;/p&gt;

    &lt;p&gt;{i18n.t("farewell")}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Toast/Notification Context</li>
    <br/>
    <ul>
        <li>Create a global toast notification system:</li>
    </ul>

<pre><code class="language-ts line-numbers">// toast-context.svelte.ts
import { setContext, getContext } from "svelte";

const TOAST_KEY = Symbol("toast");

export interface Toast {
    id: number;
    message: string;
    type: "info" | "success" | "warning" | "error";
    duration: number;
}

export interface ToastContext {
    readonly toasts: Toast[];
    show: (message: string, type?: Toast["type"], duration?: number) =&gt; void;
    success: (message: string) =&gt; void;
    error: (message: string) =&gt; void;
    warning: (message: string) =&gt; void;
    info: (message: string) =&gt; void;
    dismiss: (id: number) =&gt; void;
    clear: () =&gt; void;
}

export function createToastContext(): ToastContext {
    let toasts: Toast[] = $state([]);
    let nextId = 0;

    function show(message: string, type: Toast["type"] = "info", duration = 3000): void {
        const id = nextId++;
        const toast: Toast = { id, message, type, duration };

        toasts = [...toasts, toast];

        if (duration &gt; 0) {
            setTimeout(() =&gt; dismiss(id), duration);
        }
    }

    function dismiss(id: number): void {
        toasts = toasts.filter(t =&gt; t.id !== id);
    }

    function clear(): void {
        toasts = [];
    }

    const context: ToastContext = {
        get toasts() { return toasts; },
        show,
        success: (msg) =&gt; show(msg, "success"),
        error: (msg) =&gt; show(msg, "error", 5000),
        warning: (msg) =&gt; show(msg, "warning"),
        info: (msg) =&gt; show(msg, "info"),
        dismiss,
        clear
    };

    setContext(TOAST_KEY, context);
    return context;
}

export function useToast(): ToastContext {
    return getContext&lt;ToastContext&gt;(TOAST_KEY);
}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- ToastProvider.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";
    import { createToastContext, type Toast } from "./toast-context.svelte";
    import { fly, fade } from "svelte/transition";

    interface Props {
        children: Snippet;
    }

    let { children }: Props = $props();

    const toast = createToastContext();

    const typeStyles: Record&lt;Toast["type"], string&gt; = {
        info: "background: #3498db; color: white;",
        success: "background: #27ae60; color: white;",
        warning: "background: #f39c12; color: white;",
        error: "background: #e74c3c; color: white;"
    };
&lt;/script&gt;

{@render children()}

&lt;div class="toast-container"&gt;
    {#each toast.toasts as t (t.id)}
        &lt;div
            class="toast"
            style={typeStyles[t.type]}
            in:fly={{ y: 50, duration: 200 }}
            out:fade={{ duration: 150 }}
        &gt;
            &lt;span&gt;{t.message}&lt;/span&gt;
            &lt;button onclick={() =&gt; toast.dismiss(t.id)}&gt;×&lt;/button&gt;
        &lt;/div&gt;
    {/each}
&lt;/div&gt;

&lt;style&gt;
    .toast-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 1000;
    }
    .toast {
        padding: 12px 16px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 200px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .toast button {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        margin-left: auto;
    }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- SomeComponent.svelte --&gt;
&lt;script lang="ts"&gt;
    import { useToast } from "./toast-context.svelte";

    const toast = useToast();

    function handleSave(): void {
        toast.success("Saved successfully!");
    }

    function handleError(): void {
        toast.error("Something went wrong!");
    }
&lt;/script&gt;

&lt;button onclick={handleSave}&gt;Save&lt;/button&gt;
&lt;button onclick={handleError}&gt;Trigger Error&lt;/button&gt;
&lt;button onclick={() =&gt; toast.info("Just FYI...")}&gt;Info&lt;/button&gt;
&lt;button onclick={() =&gt; toast.warning("Be careful!")}&gt;Warning&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Modal/Dialog Context</li>
    <br/>
    <ul>
        <li>Manage modals globally through context:</li>
    </ul>

<pre><code class="language-ts line-numbers">// modal-context.svelte.ts
import { setContext, getContext } from "svelte";
import type { Snippet } from "svelte";

const MODAL_KEY = Symbol("modal");

export interface ModalConfig {
    title?: string;
    content: Snippet;
    onClose?: () =&gt; void;
    closeOnBackdrop?: boolean;
}

export interface ModalContext {
    readonly isOpen: boolean;
    readonly config: ModalConfig | null;
    open: (config: ModalConfig) =&gt; void;
    close: () =&gt; void;
    confirm: (title: string, message: string) =&gt; Promise&lt;boolean&gt;;
}

export function createModalContext(): ModalContext {
    let isOpen: boolean = $state(false);
    let config: ModalConfig | null = $state(null);
    let confirmResolver: ((value: boolean) =&gt; void) | null = null;

    const context: ModalContext = {
        get isOpen() { return isOpen; },
        get config() { return config; },

        open(newConfig: ModalConfig) {
            config = newConfig;
            isOpen = true;
        },

        close() {
            config?.onClose?.();
            isOpen = false;
            config = null;

            if (confirmResolver) {
                confirmResolver(false);
                confirmResolver = null;
            }
        },

        confirm(title: string, message: string): Promise&lt;boolean&gt; {
            return new Promise((resolve) =&gt; {
                confirmResolver = resolve;
                // Note: content would be set by the ModalProvider
                isOpen = true;
            });
        }
    };

    setContext(MODAL_KEY, context);
    return context;
}

export function useModal(): ModalContext {
    return getContext&lt;ModalContext&gt;(MODAL_KEY);
}
</code></pre>
    <br/><br/>



    <li>Feature Flags Context</li>
    <br/>
    <ul>
        <li>Control feature visibility across your app:</li>
    </ul>

<pre><code class="language-ts line-numbers">// feature-flags-context.svelte.ts
import { setContext, getContext } from "svelte";

const FEATURE_FLAGS_KEY = Symbol("featureFlags");

export interface FeatureFlags {
    darkMode: boolean;
    newDashboard: boolean;
    betaFeatures: boolean;
    experimentalApi: boolean;
}

export interface FeatureFlagsContext {
    readonly flags: FeatureFlags;
    isEnabled: (flag: keyof FeatureFlags) =&gt; boolean;
    enable: (flag: keyof FeatureFlags) =&gt; void;
    disable: (flag: keyof FeatureFlags) =&gt; void;
    toggle: (flag: keyof FeatureFlags) =&gt; void;
}

export function createFeatureFlagsContext(initial: Partial&lt;FeatureFlags&gt; = {}): FeatureFlagsContext {
    let flags: FeatureFlags = $state({
        darkMode: false,
        newDashboard: false,
        betaFeatures: false,
        experimentalApi: false,
        ...initial
    });

    const context: FeatureFlagsContext = {
        get flags() { return flags; },

        isEnabled(flag: keyof FeatureFlags): boolean {
            return flags[flag];
        },

        enable(flag: keyof FeatureFlags): void {
            flags[flag] = true;
        },

        disable(flag: keyof FeatureFlags): void {
            flags[flag] = false;
        },

        toggle(flag: keyof FeatureFlags): void {
            flags[flag] = !flags[flag];
        }
    };

    setContext(FEATURE_FLAGS_KEY, context);
    return context;
}

export function useFeatureFlags(): FeatureFlagsContext {
    return getContext&lt;FeatureFlagsContext&gt;(FEATURE_FLAGS_KEY);
}
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- FeatureFlaggedComponent.svelte --&gt;
&lt;script lang="ts"&gt;
    import { useFeatureFlags } from "./feature-flags-context.svelte";

    const features = useFeatureFlags();
&lt;/script&gt;

{#if features.isEnabled("newDashboard")}
    &lt;div class="new-dashboard"&gt;
        &lt;h2&gt;New Dashboard (Beta)&lt;/h2&gt;
        &lt;!-- New dashboard content --&gt;
    &lt;/div&gt;
{:else}
    &lt;div class="old-dashboard"&gt;
        &lt;h2&gt;Dashboard&lt;/h2&gt;
        &lt;!-- Old dashboard content --&gt;
    &lt;/div&gt;
{/if}

{#if features.isEnabled("betaFeatures")}
    &lt;aside class="beta-panel"&gt;
        &lt;h3&gt;Beta Features&lt;/h3&gt;
        &lt;!-- Beta content --&gt;
    &lt;/aside&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Nested Context Override</li>
    <br/>
    <ul>
        <li>Child components can override parent context:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ThemeProvider.svelte --&gt;
&lt;script lang="ts"&gt;
    import { setContext } from "svelte";
    import type { Snippet } from "svelte";

    interface Props {
        theme: "light" | "dark";
        children: Snippet;
    }

    let { theme, children }: Props = $props();

    // This will override any parent theme context
    setContext("theme", theme);
&lt;/script&gt;

&lt;div class="theme-{theme}"&gt;
    {@render children()}
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script lang="ts"&gt;
    import ThemeProvider from "./ThemeProvider.svelte";
    import ThemedBox from "./ThemedBox.svelte";
&lt;/script&gt;

&lt;ThemeProvider theme="light"&gt;
    &lt;!-- This section uses light theme --&gt;
    &lt;ThemedBox&gt;Light themed content&lt;/ThemedBox&gt;

    &lt;ThemeProvider theme="dark"&gt;
        &lt;!-- This nested section overrides to dark theme --&gt;
        &lt;ThemedBox&gt;Dark themed content (nested override)&lt;/ThemedBox&gt;
    &lt;/ThemeProvider&gt;

    &lt;!-- Back to light theme --&gt;
    &lt;ThemedBox&gt;Light themed again&lt;/ThemedBox&gt;
&lt;/ThemeProvider&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- ThemedBox.svelte --&gt;
&lt;script lang="ts"&gt;
    import { getContext } from "svelte";
    import type { Snippet } from "svelte";

    interface Props {
        children: Snippet;
    }

    let { children }: Props = $props();

    const theme = getContext&lt;"light" | "dark"&gt;("theme");
&lt;/script&gt;

&lt;div
    class="box"
    style="
        background: {theme === 'dark' ? '#333' : '#fff'};
        color: {theme === 'dark' ? '#fff' : '#333'};
    "
&gt;
    &lt;p&gt;Theme: {theme}&lt;/p&gt;
    {@render children()}
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Context vs Props vs Stores</li>
    <br/>
    <ul>
        <li>Choosing the right state sharing mechanism:</li>
    </ul>

    <table>
        <tr>
            <th>Feature</th>
            <th>Props</th>
            <th>Context</th>
            <th>Stores / Runes in Modules</th>
        </tr>
        <tr>
            <td>Direction</td>
            <td>Parent → Child (direct)</td>
            <td>Parent → Any Descendant</td>
            <td>Any → Any</td>
        </tr>
        <tr>
            <td>Reactivity</td>
            <td>Automatic</td>
            <td>Manual (via runes)</td>
            <td>Automatic</td>
        </tr>
        <tr>
            <td>Scope</td>
            <td>Single component</td>
            <td>Component subtree</td>
            <td>Global / Module</td>
        </tr>
        <tr>
            <td>Multiple instances</td>
            <td>Yes</td>
            <td>Yes (per tree)</td>
            <td>No (singleton)</td>
        </tr>
        <tr>
            <td>Best for</td>
            <td>Direct parent-child data</td>
            <td>Avoiding prop drilling</td>
            <td>Global app state</td>
        </tr>
        <tr>
            <td>Debugging</td>
            <td>Easy</td>
            <td>Moderate</td>
            <td>Easy</td>
        </tr>
    </table>
    <br/><br/>



    <li>Common Pitfalls</li>
    <br/>
    <ul>
        <li><b>Setting context outside initialization:</b></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { setContext, getContext } from "svelte";

    // ✅ CORRECT: During initialization
    setContext("key", "value");

    // ❌ WRONG: In event handler
    function handleClick(): void {
        // This will throw an error!
        // setContext("key", "newValue");
    }

    // ❌ WRONG: In $effect
    // $effect(() =&gt; {
    //     setContext("key", someValue);
    // });
&lt;/script&gt;
</code></pre>

    <ul>
        <li><b>Expecting automatic reactivity:</b></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { setContext } from "svelte";

    let count = $state(0);

    // ❌ WRONG: Primitive won't be reactive in consumers
    // setContext("count", count);

    // ✅ CORRECT: Pass an object with getter
    setContext("counter", {
        get count() { return count; },
        increment() { count++; }
    });
&lt;/script&gt;
</code></pre>

    <ul>
        <li><b>Using string keys (collision risk):</b></li>
    </ul>

<pre><code class="language-ts line-numbers">// ❌ WRONG: String keys can collide
setContext("theme", myTheme);

// ✅ CORRECT: Use symbols for uniqueness
const THEME_KEY = Symbol("theme");
setContext(THEME_KEY, myTheme);
</code></pre>
    <br/><br/>



    <li>Context API Summary</li>
    <br/>

    <table>
        <tr>
            <th>Function</th>
            <th>Purpose</th>
            <th>Usage</th>
        </tr>
        <tr>
            <td><code>setContext</code></td>
            <td>Provide a value</td>
            <td><code>setContext(key, value)</code></td>
        </tr>
        <tr>
            <td><code>getContext</code></td>
            <td>Consume a value</td>
            <td><code>getContext&lt;T&gt;(key)</code></td>
        </tr>
        <tr>
            <td><code>hasContext</code></td>
            <td>Check if exists</td>
            <td><code>hasContext(key)</code></td>
        </tr>
        <tr>
            <td><code>getAllContexts</code></td>
            <td>Get all as Map</td>
            <td><code>getAllContexts()</code></td>
        </tr>
        <tr>
            <td>Symbol keys</td>
            <td>Prevent collisions</td>
            <td><code>Symbol("name")</code></td>
        </tr>
        <tr>
            <td>Factory pattern</td>
            <td>Reusable contexts</td>
            <td><code>createXContext()</code></td>
        </tr>
        <tr>
            <td>Reactive context</td>
            <td>Use getters + runes</td>
            <td><code>get value() { return state }</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-special-elements">Svelte Special Elements</h3>
<ol>
    <li>Overview</li>
    <br/>
    <ul>
        <li>Svelte provides <u>special elements</u> that offer functionality beyond regular HTML.</li>
        <br/>
        <li>These elements are prefixed with <code>svelte:</code> and handle specific use cases:
            <ul>
                <li><code>&lt;svelte:self&gt;</code> — Recursive component rendering</li>
                <li><code>&lt;svelte:component&gt;</code> — Dynamic component rendering</li>
                <li><code>&lt;svelte:element&gt;</code> — Dynamic HTML element rendering</li>
                <li><code>&lt;svelte:window&gt;</code> — Window event listeners and bindings</li>
                <li><code>&lt;svelte:document&gt;</code> — Document event listeners and bindings</li>
                <li><code>&lt;svelte:body&gt;</code> — Body event listeners</li>
                <li><code>&lt;svelte:head&gt;</code> — Insert content into <code>&lt;head&gt;</code></li>
                <li><code>&lt;svelte:options&gt;</code> — Compiler options</li>
                <li><code>&lt;svelte:fragment&gt;</code> — Group elements without wrapper (Svelte 4)</li>
                <li><code>&lt;svelte:boundary&gt;</code> — Error boundaries (Svelte 5)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><code>&lt;svelte:self&gt;</code> — Recursive Components</li>
    <br/>
    <ul>
        <li>Allows a component to include itself recursively:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- TreeView.svelte --&gt;
&lt;script lang="ts"&gt;
    interface TreeNode {
        name: string;
        children?: TreeNode[];
        expanded?: boolean;
    }

    interface Props {
        node: TreeNode;
        depth?: number;
    }

    let { node, depth = 0 }: Props = $props();

    let expanded: boolean = $state(node.expanded ?? false);

    function toggle(): void {
        expanded = !expanded;
    }
&lt;/script&gt;

&lt;div class="tree-node" style="padding-left: {depth * 20}px"&gt;
    {#if node.children && node.children.length &gt; 0}
        &lt;button class="toggle" onclick={toggle}&gt;
            {expanded ? "▼" : "▶"}
        &lt;/button&gt;
    {:else}
        &lt;span class="leaf"&gt;•&lt;/span&gt;
    {/if}

    &lt;span class="name"&gt;{node.name}&lt;/span&gt;

    {#if expanded && node.children}
        {#each node.children as child}
            &lt;!-- Recursive call to self --&gt;
            &lt;svelte:self node={child} depth={depth + 1} /&gt;
        {/each}
    {/if}
&lt;/div&gt;

&lt;style&gt;
    .tree-node { font-family: monospace; }
    .toggle {
        background: none;
        border: none;
        cursor: pointer;
        width: 20px;
    }
    .leaf { width: 20px; display: inline-block; text-align: center; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script lang="ts"&gt;
    import TreeView from "./TreeView.svelte";

    const fileSystem = {
        name: "root",
        expanded: true,
        children: [
            {
                name: "src",
                children: [
                    { name: "App.svelte" },
                    { name: "main.ts" },
                    {
                        name: "components",
                        children: [
                            { name: "Header.svelte" },
                            { name: "Footer.svelte" }
                        ]
                    }
                ]
            },
            {
                name: "public",
                children: [
                    { name: "index.html" },
                    { name: "favicon.ico" }
                ]
            },
            { name: "package.json" }
        ]
    };
&lt;/script&gt;

&lt;TreeView node={fileSystem} /&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:self&gt;</code> — Comment Thread Example</li>
    <br/>
    <ul>
        <li>Nested comment threads are a perfect use case:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Comment.svelte --&gt;
&lt;script lang="ts"&gt;
    interface CommentData {
        id: number;
        author: string;
        text: string;
        timestamp: string;
        replies?: CommentData[];
    }

    interface Props {
        comment: CommentData;
        depth?: number;
    }

    let { comment, depth = 0 }: Props = $props();

    let showReplies: boolean = $state(true);
    let maxDepth = 5;
&lt;/script&gt;

&lt;div class="comment" style="margin-left: {depth * 24}px"&gt;
    &lt;div class="comment-header"&gt;
        &lt;strong&gt;{comment.author}&lt;/strong&gt;
        &lt;span class="timestamp"&gt;{comment.timestamp}&lt;/span&gt;
    &lt;/div&gt;

    &lt;p class="comment-text"&gt;{comment.text}&lt;/p&gt;

    {#if comment.replies && comment.replies.length &gt; 0}
        &lt;button onclick={() =&gt; showReplies = !showReplies}&gt;
            {showReplies ? "Hide" : "Show"} {comment.replies.length} replies
        &lt;/button&gt;

        {#if showReplies && depth &lt; maxDepth}
            {#each comment.replies as reply}
                &lt;svelte:self comment={reply} depth={depth + 1} /&gt;
            {/each}
        {:else if depth &gt;= maxDepth}
            &lt;p class="max-depth"&gt;Continue thread →&lt;/p&gt;
        {/if}
    {/if}
&lt;/div&gt;

&lt;style&gt;
    .comment {
        border-left: 2px solid #ddd;
        padding: 8px 12px;
        margin: 8px 0;
    }
    .timestamp { color: #666; font-size: 0.8em; margin-left: 8px; }
    .max-depth { color: #007bff; cursor: pointer; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:component&gt;</code> — Dynamic Components</li>
    <br/>
    <ul>
        <li>Render different components dynamically based on a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Alert.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        message: string;
    }
    let { message }: Props = $props();
&lt;/script&gt;

&lt;div class="alert"&gt;⚠️ {message}&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Success.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        message: string;
    }
    let { message }: Props = $props();
&lt;/script&gt;

&lt;div class="success"&gt;✅ {message}&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Error.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        message: string;
    }
    let { message }: Props = $props();
&lt;/script&gt;

&lt;div class="error"&gt;❌ {message}&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script lang="ts"&gt;
    import Alert from "./Alert.svelte";
    import Success from "./Success.svelte";
    import Error from "./Error.svelte";
    import type { Component } from "svelte";

    type NotificationType = "alert" | "success" | "error";

    const components: Record&lt;NotificationType, Component&lt;{ message: string }&gt;&gt; = {
        alert: Alert,
        success: Success,
        error: Error
    };

    let currentType: NotificationType = $state("alert");
    let message: string = $state("This is a notification");

    let CurrentComponent = $derived(components[currentType]);
&lt;/script&gt;

&lt;select bind:value={currentType}&gt;
    &lt;option value="alert"&gt;Alert&lt;/option&gt;
    &lt;option value="success"&gt;Success&lt;/option&gt;
    &lt;option value="error"&gt;Error&lt;/option&gt;
&lt;/select&gt;

&lt;input bind:value={message} /&gt;

&lt;!-- Dynamic component rendering --&gt;
&lt;svelte:component this={CurrentComponent} {message} /&gt;
</code></pre>

    <ul>
        <li>If <code>this</code> is falsy, nothing is rendered.</li>
    </ul>
    <br/><br/>



    <li><code>&lt;svelte:component&gt;</code> — Tab System</li>
    <br/>
    <ul>
        <li>Build a dynamic tab system:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { Component } from "svelte";
    import HomeTab from "./tabs/HomeTab.svelte";
    import ProfileTab from "./tabs/ProfileTab.svelte";
    import SettingsTab from "./tabs/SettingsTab.svelte";

    interface Tab {
        id: string;
        label: string;
        component: Component;
        icon: string;
    }

    const tabs: Tab[] = [
        { id: "home", label: "Home", component: HomeTab, icon: "🏠" },
        { id: "profile", label: "Profile", component: ProfileTab, icon: "👤" },
        { id: "settings", label: "Settings", component: SettingsTab, icon: "⚙️" }
    ];

    let activeTabId: string = $state("home");

    let activeTab = $derived(tabs.find(t =&gt; t.id === activeTabId));
&lt;/script&gt;

&lt;div class="tabs"&gt;
    &lt;nav class="tab-list"&gt;
        {#each tabs as tab}
            &lt;button
                class="tab-button"
                class:active={activeTabId === tab.id}
                onclick={() =&gt; activeTabId = tab.id}
            &gt;
                {tab.icon} {tab.label}
            &lt;/button&gt;
        {/each}
    &lt;/nav&gt;

    &lt;div class="tab-content"&gt;
        {#if activeTab}
            &lt;svelte:component this={activeTab.component} /&gt;
        {/if}
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
    .tab-list { display: flex; gap: 4px; border-bottom: 1px solid #ddd; }
    .tab-button {
        padding: 8px 16px;
        border: none;
        background: none;
        cursor: pointer;
    }
    .tab-button.active {
        border-bottom: 2px solid #007bff;
        color: #007bff;
    }
    .tab-content { padding: 16px; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:element&gt;</code> — Dynamic HTML Elements</li>
    <br/>
    <ul>
        <li>Render different HTML elements based on a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Props {
        level?: 1 | 2 | 3 | 4 | 5 | 6;
        children: import("svelte").Snippet;
    }

    let { level = 1, children }: Props = $props();

    // Dynamically determine the heading tag
    let tag = $derived(`h${level}` as "h1" | "h2" | "h3" | "h4" | "h5" | "h6");
&lt;/script&gt;

&lt;svelte:element this={tag}&gt;
    {@render children()}
&lt;/svelte:element&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;script lang="ts"&gt;
    import Heading from "./Heading.svelte";
&lt;/script&gt;

&lt;Heading level={1}&gt;Main Title&lt;/Heading&gt;
&lt;Heading level={2}&gt;Subtitle&lt;/Heading&gt;
&lt;Heading level={3}&gt;Section&lt;/Heading&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:element&gt;</code> — Polymorphic Components</li>
    <br/>
    <ul>
        <li>Create components that can render as different elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { Snippet } from "svelte";

    interface Props {
        as?: "button" | "a" | "div";
        href?: string;
        disabled?: boolean;
        variant?: "primary" | "secondary" | "ghost";
        onclick?: () =&gt; void;
        children: Snippet;
    }

    let {
        as = "button",
        href,
        disabled = false,
        variant = "primary",
        onclick,
        children
    }: Props = $props();

    // If href is provided, render as anchor
    let tag = $derived(href ? "a" : as);
&lt;/script&gt;

&lt;svelte:element
    this={tag}
    class="btn btn-{variant}"
    class:disabled
    {href}
    {disabled}
    {onclick}
&gt;
    {@render children()}
&lt;/svelte:element&gt;

&lt;style&gt;
    .btn {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        text-decoration: none;
        display: inline-block;
    }
    .btn-primary { background: #007bff; color: white; border: none; }
    .btn-secondary { background: #6c757d; color: white; border: none; }
    .btn-ghost { background: transparent; border: 1px solid #007bff; color: #007bff; }
    .disabled { opacity: 0.5; pointer-events: none; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;!-- Renders as &lt;button&gt; --&gt;
&lt;Button onclick={() =&gt; console.log("clicked")}&gt;Click Me&lt;/Button&gt;

&lt;!-- Renders as &lt;a&gt; --&gt;
&lt;Button href="/about"&gt;Go to About&lt;/Button&gt;

&lt;!-- Renders as &lt;div&gt; --&gt;
&lt;Button as="div" variant="ghost"&gt;Div Button&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:window&gt;</code> — Window Events</li>
    <br/>
    <ul>
        <li>Add event listeners to the window object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);
    let scrollY: number = $state(0);
    let online: boolean = $state(true);

    function handleKeydown(event: KeyboardEvent): void {
        if (event.key === "Escape") {
            console.log("Escape pressed!");
        }
        if (event.ctrlKey && event.key === "s") {
            event.preventDefault();
            console.log("Save shortcut!");
        }
    }

    function handleResize(): void {
        console.log(`Window resized: ${innerWidth}x${innerHeight}`);
    }

    function handleOnline(): void {
        online = true;
        console.log("Back online!");
    }

    function handleOffline(): void {
        online = false;
        console.log("Gone offline!");
    }
&lt;/script&gt;

&lt;!-- Window event listeners and bindings --&gt;
&lt;svelte:window
    onkeydown={handleKeydown}
    onresize={handleResize}
    ononline={handleOnline}
    onoffline={handleOffline}
    bind:innerWidth
    bind:innerHeight
    bind:scrollY
/&gt;

&lt;div class="status-bar" class:offline={!online}&gt;
    &lt;p&gt;Window: {innerWidth} × {innerHeight}&lt;/p&gt;
    &lt;p&gt;Scroll Y: {scrollY}px&lt;/p&gt;
    &lt;p&gt;Status: {online ? "🟢 Online" : "🔴 Offline"}&lt;/p&gt;
&lt;/div&gt;

&lt;div style="height: 200vh; padding: 20px;"&gt;
    &lt;p&gt;Scroll down to see scrollY update&lt;/p&gt;
    &lt;p&gt;Press Escape or Ctrl+S to test keyboard events&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    .status-bar {
        position: fixed;
        top: 0;
        right: 0;
        background: white;
        padding: 10px;
        border: 1px solid #ddd;
        font-size: 12px;
    }
    .offline { background: #ffebee; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:window&gt;</code> — Available Bindings</li>
    <br/>
    <ul>
        <li>All bindable window properties:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Readonly bindings
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);
    let outerWidth: number = $state(0);
    let outerHeight: number = $state(0);
    let online: boolean = $state(true);
    let devicePixelRatio: number = $state(1);

    // Two-way bindings (can be set)
    let scrollX: number = $state(0);
    let scrollY: number = $state(0);

    function scrollToTop(): void {
        scrollY = 0; // This will scroll the window
    }

    function scrollToPosition(x: number, y: number): void {
        scrollX = x;
        scrollY = y;
    }
&lt;/script&gt;

&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    bind:outerWidth
    bind:outerHeight
    bind:scrollX
    bind:scrollY
    bind:online
    bind:devicePixelRatio
/&gt;

&lt;div class="info"&gt;
    &lt;h3&gt;Window Properties&lt;/h3&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;Inner Size&lt;/td&gt;&lt;td&gt;{innerWidth} × {innerHeight}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Outer Size&lt;/td&gt;&lt;td&gt;{outerWidth} × {outerHeight}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Scroll Position&lt;/td&gt;&lt;td&gt;{scrollX}, {scrollY}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Online&lt;/td&gt;&lt;td&gt;{online}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Pixel Ratio&lt;/td&gt;&lt;td&gt;{devicePixelRatio}&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;

    &lt;button onclick={scrollToTop}&gt;Scroll to Top&lt;/button&gt;
&lt;/div&gt;
</code></pre>

    <table>
        <tr>
            <th>Binding</th>
            <th>Type</th>
            <th>Writable</th>
        </tr>
        <tr>
            <td><code>innerWidth</code></td>
            <td><code>number</code></td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>innerHeight</code></td>
            <td><code>number</code></td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>outerWidth</code></td>
            <td><code>number</code></td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>outerHeight</code></td>
            <td><code>number</code></td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>scrollX</code></td>
            <td><code>number</code></td>
            <td>Yes</td>
        </tr>
        <tr>
            <td><code>scrollY</code></td>
            <td><code>number</code></td>
            <td>Yes</td>
        </tr>
        <tr>
            <td><code>online</code></td>
            <td><code>boolean</code></td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>devicePixelRatio</code></td>
            <td><code>number</code></td>
            <td>No</td>
        </tr>
    </table>
    <br/><br/>



    <li><code>&lt;svelte:document&gt;</code> — Document Events</li>
    <br/>
    <ul>
        <li>Add event listeners to the document object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let activeElement: Element | null = $state(null);
    let visibilityState: DocumentVisibilityState = $state("visible");
    let fullscreenElement: Element | null = $state(null);

    function handleVisibilityChange(): void {
        visibilityState = document.visibilityState;
        console.log("Visibility:", visibilityState);
    }

    function handleSelectionChange(): void {
        const selection = document.getSelection();
        if (selection && selection.toString()) {
            console.log("Selected:", selection.toString());
        }
    }

    function handleFullscreenChange(): void {
        fullscreenElement = document.fullscreenElement;
    }
&lt;/script&gt;

&lt;svelte:document
    onvisibilitychange={handleVisibilityChange}
    onselectionchange={handleSelectionChange}
    onfullscreenchange={handleFullscreenChange}
    bind:activeElement
    bind:fullscreenElement
/&gt;

&lt;div&gt;
    &lt;p&gt;Active Element: {activeElement?.tagName ?? "None"}&lt;/p&gt;
    &lt;p&gt;Visibility: {visibilityState}&lt;/p&gt;
    &lt;p&gt;Fullscreen: {fullscreenElement ? "Yes" : "No"}&lt;/p&gt;

    &lt;input placeholder="Focus me to see activeElement change" /&gt;
    &lt;textarea&gt;Select this text to trigger selectionchange&lt;/textarea&gt;
&lt;/div&gt;
</code></pre>

    <ul>
        <li>Available document bindings:
            <ul>
                <li><code>activeElement</code> — Currently focused element</li>
                <li><code>fullscreenElement</code> — Element in fullscreen mode</li>
                <li><code>pointerLockElement</code> — Element with pointer lock</li>
                <li><code>visibilityState</code> — Document visibility state</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><code>&lt;svelte:body&gt;</code> — Body Events</li>
    <br/>
    <ul>
        <li>Add event listeners to the document body:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let mouseX: number = $state(0);
    let mouseY: number = $state(0);
    let isDragging: boolean = $state(false);

    function handleMouseMove(event: MouseEvent): void {
        mouseX = event.clientX;
        mouseY = event.clientY;
    }

    function handleDragStart(): void {
        isDragging = true;
    }

    function handleDragEnd(): void {
        isDragging = false;
    }

    // Useful for modals - prevent body scroll
    let preventScroll: boolean = $state(false);

    $effect(() =&gt; {
        if (preventScroll) {
            document.body.style.overflow = "hidden";
        } else {
            document.body.style.overflow = "";
        }
    });
&lt;/script&gt;

&lt;svelte:body
    onmousemove={handleMouseMove}
    ondragstart={handleDragStart}
    ondragend={handleDragEnd}
/&gt;

&lt;div&gt;
    &lt;p&gt;Mouse Position: {mouseX}, {mouseY}&lt;/p&gt;
    &lt;p&gt;Dragging: {isDragging}&lt;/p&gt;

    &lt;label&gt;
        &lt;input type="checkbox" bind:checked={preventScroll} /&gt;
        Prevent body scroll (for modals)
    &lt;/label&gt;
&lt;/div&gt;

&lt;!-- Custom cursor that follows mouse --&gt;
&lt;div
    class="cursor-follower"
    style="left: {mouseX}px; top: {mouseY}px"
&gt;&lt;/div&gt;

&lt;style&gt;
    .cursor-follower {
        position: fixed;
        width: 20px;
        height: 20px;
        background: rgba(0, 123, 255, 0.3);
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:head&gt;</code> — Document Head</li>
    <br/>
    <ul>
        <li>Insert elements into the document's <code>&lt;head&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Props {
        title?: string;
        description?: string;
    }

    let {
        title = "My App",
        description = "A Svelte application"
    }: Props = $props();
&lt;/script&gt;

&lt;svelte:head&gt;
    &lt;title&gt;{title}&lt;/title&gt;
    &lt;meta name="description" content={description} /&gt;
&lt;/svelte:head&gt;

&lt;h1&gt;{title}&lt;/h1&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:head&gt;</code> — SEO Component</li>
    <br/>
    <ul>
        <li>Create a reusable SEO component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SEO.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        title: string;
        description?: string;
        keywords?: string[];
        image?: string;
        url?: string;
        type?: "website" | "article" | "profile";
        author?: string;
        publishedTime?: string;
        noindex?: boolean;
    }

    let {
        title,
        description = "",
        keywords = [],
        image = "",
        url = "",
        type = "website",
        author = "",
        publishedTime = "",
        noindex = false
    }: Props = $props();

    let fullTitle = $derived(`${title} | My Site`);
&lt;/script&gt;

&lt;svelte:head&gt;
    &lt;!-- Basic Meta --&gt;
    &lt;title&gt;{fullTitle}&lt;/title&gt;
    &lt;meta name="description" content={description} /&gt;

    {#if keywords.length &gt; 0}
        &lt;meta name="keywords" content={keywords.join(", ")} /&gt;
    {/if}

    {#if noindex}
        &lt;meta name="robots" content="noindex, nofollow" /&gt;
    {/if}

    &lt;!-- Open Graph --&gt;
    &lt;meta property="og:title" content={title} /&gt;
    &lt;meta property="og:description" content={description} /&gt;
    &lt;meta property="og:type" content={type} /&gt;

    {#if url}
        &lt;meta property="og:url" content={url} /&gt;
    {/if}

    {#if image}
        &lt;meta property="og:image" content={image} /&gt;
    {/if}

    &lt;!-- Twitter Card --&gt;
    &lt;meta name="twitter:card" content="summary_large_image" /&gt;
    &lt;meta name="twitter:title" content={title} /&gt;
    &lt;meta name="twitter:description" content={description} /&gt;

    {#if image}
        &lt;meta name="twitter:image" content={image} /&gt;
    {/if}

    &lt;!-- Article specific --&gt;
    {#if type === "article"}
        {#if author}
            &lt;meta property="article:author" content={author} /&gt;
        {/if}
        {#if publishedTime}
            &lt;meta property="article:published_time" content={publishedTime} /&gt;
        {/if}
    {/if}

    &lt;!-- Canonical URL --&gt;
    {#if url}
        &lt;link rel="canonical" href={url} /&gt;
    {/if}
&lt;/svelte:head&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- BlogPost.svelte --&gt;
&lt;script lang="ts"&gt;
    import SEO from "./SEO.svelte";

    interface Props {
        post: {
            title: string;
            excerpt: string;
            image: string;
            author: string;
            date: string;
            content: string;
        };
    }

    let { post }: Props = $props();
&lt;/script&gt;

&lt;SEO
    title={post.title}
    description={post.excerpt}
    image={post.image}
    type="article"
    author={post.author}
    publishedTime={post.date}
/&gt;

&lt;article&gt;
    &lt;h1&gt;{post.title}&lt;/h1&gt;
    &lt;p&gt;{post.content}&lt;/p&gt;
&lt;/article&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:head&gt;</code> — Dynamic Styles and Scripts</li>
    <br/>
    <ul>
        <li>Load external resources dynamically:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let theme: "light" | "dark" = $state("light");
    let loadHighlighting: boolean = $state(false);
&lt;/script&gt;

&lt;svelte:head&gt;
    &lt;!-- Dynamic theme stylesheet --&gt;
    &lt;link
        rel="stylesheet"
        href="/themes/{theme}.css"
    /&gt;

    &lt;!-- Conditionally load external library --&gt;
    {#if loadHighlighting}
        &lt;link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
        /&gt;
        &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"&gt;&lt;/script&gt;
    {/if}

    &lt;!-- Custom fonts --&gt;
    &lt;link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
        rel="stylesheet"
    /&gt;
&lt;/svelte:head&gt;

&lt;select bind:value={theme}&gt;
    &lt;option value="light"&gt;Light Theme&lt;/option&gt;
    &lt;option value="dark"&gt;Dark Theme&lt;/option&gt;
&lt;/select&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={loadHighlighting} /&gt;
    Load syntax highlighting
&lt;/label&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:options&gt;</code> — Compiler Options</li>
    <br/>
    <ul>
        <li>Configure compiler behavior for a component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Must be at the top of the component --&gt;
&lt;svelte:options
    immutable={true}
    accessors={true}
    namespace="svg"
    customElement="my-component"
/&gt;

&lt;script lang="ts"&gt;
    // Component code...
&lt;/script&gt;
</code></pre>

    <table>
        <tr>
            <th>Option</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>immutable</code></td>
            <td><code>boolean</code></td>
            <td>Assume data never mutates (optimize comparisons)</td>
        </tr>
        <tr>
            <td><code>accessors</code></td>
            <td><code>boolean</code></td>
            <td>Generate getters/setters for props</td>
        </tr>
        <tr>
            <td><code>namespace</code></td>
            <td><code>string</code></td>
            <td>Namespace for the component (e.g., "svg", "mathml")</td>
        </tr>
        <tr>
            <td><code>customElement</code></td>
            <td><code>string</code></td>
            <td>Compile as custom element with given tag name</td>
        </tr>
        <tr>
            <td><code>runes</code></td>
            <td><code>boolean</code></td>
            <td>Force runes mode (Svelte 5)</td>
        </tr>
    </table>
    <br/><br/>



    <li><code>&lt;svelte:options&gt;</code> — Custom Elements</li>
    <br/>
    <ul>
        <li>Compile a Svelte component as a Web Component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;svelte:options customElement="my-counter" /&gt;

&lt;script lang="ts"&gt;
    interface Props {
        count?: number;
        step?: number;
    }

    let { count = $bindable(0), step = 1 }: Props = $props();

    function increment(): void {
        count += step;
    }

    function decrement(): void {
        count -= step;
    }
&lt;/script&gt;

&lt;div class="counter"&gt;
    &lt;button onclick={decrement}&gt;-&lt;/button&gt;
    &lt;span&gt;{count}&lt;/span&gt;
    &lt;button onclick={increment}&gt;+&lt;/button&gt;
&lt;/div&gt;

&lt;style&gt;
    /* Styles are encapsulated in Shadow DOM */
    .counter {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    button {
        width: 32px;
        height: 32px;
    }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Use in any HTML page --&gt;
&lt;my-counter count="10" step="5"&gt;&lt;/my-counter&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:fragment&gt;</code> — Slot Grouping (Svelte 4)</li>
    <br/>
    <ul>
        <li>Group content for named slots without a wrapper element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Layout.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let title: string;
&lt;/script&gt;

&lt;div class="layout"&gt;
    &lt;header&gt;
        &lt;slot name="header"&gt;
            &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;/slot&gt;
    &lt;/header&gt;

    &lt;main&gt;
        &lt;slot /&gt;
    &lt;/main&gt;

    &lt;footer&gt;
        &lt;slot name="footer" /&gt;
    &lt;/footer&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    import Layout from "./Layout.svelte";
&lt;/script&gt;

&lt;Layout title="My Page"&gt;
    &lt;!-- Use svelte:fragment to pass multiple elements to a named slot --&gt;
    &lt;svelte:fragment slot="header"&gt;
        &lt;h1&gt;Custom Header&lt;/h1&gt;
        &lt;nav&gt;
            &lt;a href="/"&gt;Home&lt;/a&gt;
            &lt;a href="/about"&gt;About&lt;/a&gt;
        &lt;/nav&gt;
    &lt;/svelte:fragment&gt;

    &lt;!-- Default slot content --&gt;
    &lt;p&gt;Main content goes here.&lt;/p&gt;

    &lt;svelte:fragment slot="footer"&gt;
        &lt;p&gt;Copyright 2024&lt;/p&gt;
        &lt;p&gt;All rights reserved&lt;/p&gt;
    &lt;/svelte:fragment&gt;
&lt;/Layout&gt;
</code></pre>

    <ul>
        <li>In Svelte 5 with snippets, <code>&lt;svelte:fragment&gt;</code> is less commonly needed.</li>
    </ul>
    <br/><br/>



    <li><code>&lt;svelte:boundary&gt;</code> — Error Boundaries (Svelte 5)</li>
    <br/>
    <ul>
        <li>Catch and handle errors in child components:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import BuggyComponent from "./BuggyComponent.svelte";

    let errorMessage: string = $state("");
    let hasError: boolean = $state(false);

    function handleError(error: Error): void {
        hasError = true;
        errorMessage = error.message;
        console.error("Caught error:", error);
    }

    function reset(): void {
        hasError = false;
        errorMessage = "";
    }
&lt;/script&gt;

&lt;svelte:boundary onerror={handleError}&gt;
    {#if hasError}
        &lt;div class="error-fallback"&gt;
            &lt;h2&gt;Something went wrong&lt;/h2&gt;
            &lt;p&gt;{errorMessage}&lt;/p&gt;
            &lt;button onclick={reset}&gt;Try Again&lt;/button&gt;
        &lt;/div&gt;
    {:else}
        &lt;BuggyComponent /&gt;
    {/if}
&lt;/svelte:boundary&gt;

&lt;style&gt;
    .error-fallback {
        padding: 20px;
        background: #ffebee;
        border: 1px solid #f44336;
        border-radius: 4px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:boundary&gt;</code> — With Failed Snippet</li>
    <br/>
    <ul>
        <li>Use the <code>failed</code> snippet for error UI:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import DataDisplay from "./DataDisplay.svelte";
&lt;/script&gt;

&lt;svelte:boundary&gt;
    &lt;DataDisplay /&gt;

    {#snippet failed(error, reset)}
        &lt;div class="error-boundary"&gt;
            &lt;h3&gt;⚠️ Error Loading Data&lt;/h3&gt;
            &lt;p&gt;{error.message}&lt;/p&gt;
            &lt;details&gt;
                &lt;summary&gt;Stack trace&lt;/summary&gt;
                &lt;pre&gt;{error.stack}&lt;/pre&gt;
            &lt;/details&gt;
            &lt;button onclick={reset}&gt;Retry&lt;/button&gt;
        &lt;/div&gt;
    {/snippet}
&lt;/svelte:boundary&gt;

&lt;style&gt;
    .error-boundary {
        padding: 16px;
        background: #fff3cd;
        border: 1px solid #ffc107;
        border-radius: 8px;
    }
    details { margin: 10px 0; }
    pre {
        background: #f5f5f5;
        padding: 10px;
        overflow-x: auto;
        font-size: 12px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li><code>&lt;svelte:boundary&gt;</code> — Nested Boundaries</li>
    <br/>
    <ul>
        <li>Create granular error handling with nested boundaries:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import Header from "./Header.svelte";
    import Sidebar from "./Sidebar.svelte";
    import MainContent from "./MainContent.svelte";
&lt;/script&gt;

&lt;div class="app"&gt;
    &lt;!-- Header errors won't crash the whole app --&gt;
    &lt;svelte:boundary&gt;
        &lt;Header /&gt;
        {#snippet failed(error, reset)}
            &lt;header class="fallback"&gt;
                &lt;span&gt;Header unavailable&lt;/span&gt;
                &lt;button onclick={reset}&gt;↻&lt;/button&gt;
            &lt;/header&gt;
        {/snippet}
    &lt;/svelte:boundary&gt;

    &lt;div class="content"&gt;
        &lt;!-- Sidebar errors are isolated --&gt;
        &lt;svelte:boundary&gt;
            &lt;Sidebar /&gt;
            {#snippet failed()}
                &lt;aside class="fallback"&gt;Menu unavailable&lt;/aside&gt;
            {/snippet}
        &lt;/svelte:boundary&gt;

        &lt;!-- Main content has its own boundary --&gt;
        &lt;svelte:boundary&gt;
            &lt;MainContent /&gt;
            {#snippet failed(error, reset)}
                &lt;main class="fallback"&gt;
                    &lt;p&gt;Content failed to load&lt;/p&gt;
                    &lt;button onclick={reset}&gt;Reload&lt;/button&gt;
                &lt;/main&gt;
            {/snippet}
        &lt;/svelte:boundary&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
    .app { display: flex; flex-direction: column; min-height: 100vh; }
    .content { display: flex; flex: 1; }
    .fallback {
        background: #f5f5f5;
        padding: 10px;
        color: #666;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Special Elements Summary</li>
    <br/>

    <table>
        <tr>
            <th>Element</th>
            <th>Purpose</th>
            <th>Key Usage</th>
        </tr>
        <tr>
            <td><code>&lt;svelte:self&gt;</code></td>
            <td>Recursive rendering</td>
            <td>Trees, nested comments</td>
        </tr>
        <tr>
            <td><code>&lt;svelte:component&gt;</code></td>
            <td>Dynamic components</td>
            <td><code>this={Component}</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:element&gt;</code></td>
            <td>Dynamic HTML elements</td>
            <td><code>this={"div"}</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:window&gt;</code></td>
            <td>Window events/bindings</td>
            <td><code>bind:scrollY</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:document&gt;</code></td>
            <td>Document events/bindings</td>
            <td><code>bind:activeElement</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:body&gt;</code></td>
            <td>Body events</td>
            <td><code>onmousemove</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:head&gt;</code></td>
            <td>Document head content</td>
            <td><code>&lt;title&gt;</code>, <code>&lt;meta&gt;</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:options&gt;</code></td>
            <td>Compiler options</td>
            <td><code>customElement</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:fragment&gt;</code></td>
            <td>Slot grouping (Svelte 4)</td>
            <td><code>slot="name"</code></td>
        </tr>
        <tr>
            <td><code>&lt;svelte:boundary&gt;</code></td>
            <td>Error boundaries (Svelte 5)</td>
            <td><code>onerror</code>, <code>failed</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
