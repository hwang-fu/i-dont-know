<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .325rem;
        padding: .05rem .25rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.725rem;
        line-height: 1.7;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.825rem;
        line-height: 1.4;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/svelte.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#svelte-introduction">Introduction</a></li>
        <li><a href="#svelte-reactivity">Reactivity</a></li>
        <li><a href="#svelte-props">Props</a></li>
        <li><a href="#svelte-logic">Logic</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-introduction">Introduction to Svelte</h3>
<ol>
    <li>What Is Svelte?</li>
    <br/>
    <ul>
        <li><b>Svelte</b> is a modern, <u>compiler-based</u> JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Unlike Vue or React, Svelte shifts work from the <u>browser</u> to a <u>compile step</u> at build time, producing highly optimized vanilla JavaScript.</li>
        <br/>
        <li>Svelte's ecosystem includes:
            <ul>
                <li><code>SvelteKit</code> which is a full-stack application framework (routing, SSR, etc.)</li>
                <li><code>Svelte Stores</code> for built-in state management</li>
                <li><code>Vite</code> is the recommended build tool</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>How Svelte Works</li>
    <br/>
    <ul>
        <li>Svelte compiles your components into <u>efficient imperative code</u> that surgically updates the DOM.</li>
        <br/>
        <li>There is <u>no virtual DOM</u> — Svelte generates code that directly manipulates the DOM when state changes.</li>
        <br/>
        <li>A Svelte component contains:
            <ul>
                <li>a <code>&lt;script&gt;</code> block for JavaScript logic</li>
                <li>HTML markup (the template)</li>
                <li>an optional <code>&lt;style&gt;</code> block for scoped CSS</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let message = "Hello Svelte!";
&lt;/script&gt;

&lt;h1&gt;{message}&lt;/h1&gt;

&lt;style&gt;
    h1 {
        color: #ff3e00;
    }
&lt;/style&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{ }</code> automatically updates when <code>message</code> changes.</li>
    </ul>
    <br/><br/>



    <li>Getting Started (Project Setup)</li>
    <br/>
    <ul>
        <li>The recommended way to start a Svelte project is using <code>SvelteKit</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npx sv create my-app
cd my-app/
npm install
npm run dev
</code></pre>
    <ul>
        <li>For a simpler standalone Svelte project without it:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm create vite@latest my-app -- --template svelte
cd my-app/
npm install
npm run dev
</code></pre>
    <br/><br/>



    <li>Core Concepts of Svelte</li>

    <br/>
    <ol>
    <li>Reactivity</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is built into the language — just assign a new value to trigger updates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count += 1;  // This automatically updates the DOM
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>Use <code>$:</code> to create reactive statements that re-run when dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: console.log("Count is now", count);
&lt;/script&gt;

&lt;p&gt;{count} doubled is {doubled}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Handling</li>

<pre><code class="language-html line-numbers">&lt;button on:click={handleClick}&gt;Click me&lt;/button&gt;

&lt;!-- With inline handler --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increase&lt;/button&gt;

&lt;!-- With modifiers --&gt;
&lt;button on:click|once|preventDefault={handleClick}&gt;Submit&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>on:click</code> is Svelte's event directive syntax.</li>
        <li>Modifiers like <code>|once</code>, <code>|preventDefault</code>, <code>|stopPropagation</code> can be chained.</li>
    </ul>
    <br/><br/>



    <li>Two-Way Binding with <code>bind:</code></li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "";
&lt;/script&gt;

&lt;input bind:value={name} /&gt;
&lt;p&gt;Hello {name}!&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>
    <br/><br/>



    <li>Conditionals and Loops</li>
<pre><code class="language-html line-numbers">&lt;!-- Conditionals --&gt;
{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}

&lt;!-- Loops --&gt;
{#each items as item, index (item.id)}
    &lt;li&gt;{index}: {item.name}&lt;/li&gt;
{/each}
</code></pre>
    <ul>
        <li><code>{#if}</code>, <code>{:else}</code>, <code>{/if}</code> are Svelte's conditional blocks.</li>
        <li><code>{#each}</code> iterates over arrays; the <code>(item.id)</code> part is a keyed each block for efficient updates.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Component Structure</li>
    <br/>
    <ul>
        <li>Svelte components are stored in <code>.svelte</code> files.</li>
        <li>Each file is a single component with script, markup, and styles together.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name = "World";
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;

&lt;style&gt;
    h1 {
        font-family: Georgia, serif;
        color: #333;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>export let</code> declares a <u>prop</u> that can be passed from parent components.</li>
        <li>Styles are <u>scoped by default</u>, they only affect this component.</li>
    </ul>
    <br/><br/>



    <li>Using Components</li>
    <br/>
    <ul>
        <li>Import and use components like regular ES modules:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Svelte" /&gt;
&lt;Greeting /&gt;  &lt;!-- Uses default "World" --&gt;
</code></pre>
    <br/><br/>



    <li>Key Differences from Other Frameworks</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte</th>
            <th>Vue / React</th>
        </tr>
        <tr>
            <td>Compilation</td>
            <td>Compiles to vanilla JS at build time</td>
            <td>Ships a runtime library to the browser</td>
        </tr>
        <tr>
            <td>Virtual DOM</td>
            <td>No virtual DOM</td>
            <td>Uses virtual DOM for diffing</td>
        </tr>
        <tr>
            <td>Reactivity</td>
            <td>Built into the language (<code>$:</code>)</td>
            <td>Requires hooks or reactive APIs</td>
        </tr>
        <tr>
            <td>Bundle Size</td>
            <td>Typically smaller</td>
            <td>Includes framework runtime</td>
        </tr>
        <tr>
            <td>Learning Curve</td>
            <td>Closer to vanilla HTML/CSS/JS</td>
            <td>Framework-specific patterns</td>
        </tr>
    </table>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduced <u>Runes</u>, a new reactivity system using special functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);

    function increment() {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    {count} × 2 = {doubled}
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$state()</code> creates reactive state.</li>
        <li><code>$derived()</code> creates computed values.</li>
        <li><code>$effect()</code> runs side effects when dependencies change.</li>
        <li>Note: In Svelte 5, event handlers use <code>onclick</code> instead of <code>on:click</code>.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-reactivity">Svelte Reactivity</h3>
<ol>
    <li>What Is Reactivity in Svelte?</li>
    <br/>
    <ul>
        <li><b>Reactivity</b> means that when your data changes, the UI automatically updates to reflect those changes.</li>
        <br/>
        <li>In Svelte, reactivity is <u>built into the language</u> — you don't need special APIs or hooks.</li>
        <br/>
        <li>Svelte's compiler analyzes your code and generates efficient JavaScript that updates the DOM only where necessary.</li>
    </ul>
    <br/><br/>



    <li>Assignment-Based Reactivity</li>
    <br/>
    <ul>
        <li>In Svelte, <u>assignments</u> trigger reactivity. Simply reassigning a variable updates the DOM.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count = count + 1;  // Assignment triggers update
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This also works with shorthand operators:</li>
    </ul>

<pre><code class="language-js line-numbers">count += 1;   // Reactive
count++;      // Reactive
count--;      // Reactive
</code></pre>
    <br/><br/>



    <li>Reactivity with Arrays and Objects</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is triggered by <u>assignments</u>, not mutations.</li>
        <br/>
        <li>Methods like <code>push()</code>, <code>pop()</code>, <code>splice()</code> do <u>not</u> trigger reactivity by themselves:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");  // This does NOT trigger update!
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>To trigger reactivity, you must <u>reassign</u> the variable:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");
        items = items;  // Reassignment triggers update
    }

    // Or more idiomatically:
    function addItemBetter() {
        items = [...items, "Cherry"];  // Spread creates new array
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Same applies to objects:</li>
    </ul>

<pre><code class="language-js line-numbers">let user = { name: "Alice", age: 25 };

user.age = 26;      // Does NOT trigger update
user = user;        // Triggers update

// Or:
user = { ...user, age: 26 };  // Triggers update
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>The <code>$:</code> label creates <u>reactive declarations</u> — values that automatically recalculate when their dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: quadrupled = doubled * 2;
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Svelte automatically tracks which variables are used and re-runs the declaration when any dependency changes.</li>
        <br/>
        <li>Reactive declarations can depend on other reactive declarations (like <code>quadrupled</code> depends on <code>doubled</code>).</li>
    </ul>
    <br/><br/>



    <li>Reactive Statements</li>
    <br/>
    <ul>
        <li>You can also use <code>$:</code> to run <u>arbitrary statements</u> reactively:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    $: console.log("Count changed to:", count);

    $: if (count &gt;= 10) {
        alert("Count is getting high!");
        count = 0;
    }

    $: {
        console.log("Running reactive block");
        console.log("Current count:", count);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>These statements re-run whenever any referenced variable changes.</li>
    </ul>
    <br/><br/>



    <li>Reactive Stores</li>
    <br/>
    <ul>
        <li>For state that needs to be shared across components, Svelte provides <u>stores</u>.</li>
        <br/>
        <li>A store is an object with a <code>subscribe</code> method that allows reactive access to a value.</li>
        <br/>
        <li>Svelte provides three built-in store types.</li>
    </ul>

    <br/>
    <ol>
    <li><code>writable</code> — Read and write</li>

<pre><code class="language-js line-numbers">// stores.js
import { writable } from "svelte/store";

export const count = writable(0);
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { count } from "./stores.js";

    function increment() {
        count.update(n =&gt; n + 1);
    }

    function reset() {
        count.set(0);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>set(value)</code> — Sets the store to a new value.</li>
        <li><code>update(fn)</code> — Updates based on current value.</li>
    </ul>
    <br/><br/>



    <li><code>readable</code> — Read only</li>

<pre><code class="language-js line-numbers">import { readable } from "svelte/store";

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() =&gt; {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };
});
</code></pre>

    <ul>
        <li>The second argument is a function that receives <code>set</code> and returns a cleanup function.</li>
    </ul>
    <br/><br/>



    <li><code>derived</code> — Derived from other stores</li>

<pre><code class="language-js line-numbers">import { derived } from "svelte/store";
import { count } from "./stores.js";

export const doubled = derived(count, $count =&gt; $count * 2);

// Derived from multiple stores:
export const total = derived(
    [storeA, storeB],
    ([$a, $b]) =&gt; $a + $b
);
</code></pre>
    </ol>
    <br/><br/>



    <li>Auto-Subscription with <code>$</code> Prefix</li>
    <br/>
    <ul>
        <li>Inside Svelte components, you can access store values using the <code>$</code> prefix:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { count } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;The count is {$count}&lt;/p&gt;

&lt;button on:click={() =&gt; $count++}&gt;
    Increment
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$count</code> automatically subscribes to the store and unsubscribes when the component is destroyed.</li>
        <br/>
        <li>You can also assign directly to <code>$count</code> — it's equivalent to calling <code>count.set()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { name } from "./stores.js";
&lt;/script&gt;

&lt;input bind:value={$name}&gt;
</code></pre>
    <br/><br/>



    <li>Custom Stores</li>
    <br/>
    <ul>
        <li>You can create custom stores with domain-specific logic:</li>
    </ul>

<pre><code class="language-js line-numbers">import { writable } from "svelte/store";

function createCounter() {
    const { subscribe, set, update } = writable(0);

    return {
        subscribe,
        increment: () =&gt; update(n =&gt; n + 1),
        decrement: () =&gt; update(n =&gt; n - 1),
        reset: () =&gt; set(0)
    };
}

export const counter = createCounter();
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { counter } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;{$counter}&lt;/p&gt;
&lt;button on:click={counter.increment}&gt;+&lt;/button&gt;
&lt;button on:click={counter.decrement}&gt;-&lt;/button&gt;
&lt;button on:click={counter.reset}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity System)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduces <u>Runes</u>, a new reactivity system that replaces <code>$:</code> and provides more explicit control.</li>
    </ul>

    <br/>
    <ol>
    <li><code>$state</code> — Reactive State</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    function increment() {
        count++;  // Directly mutate, it's reactive!
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>With <code>$state</code>, even mutations on arrays and objects are reactive:</li>
    </ul>

<pre><code class="language-js line-numbers">let items = $state(["Apple", "Banana"]);
items.push("Cherry");  // This IS reactive in Svelte 5!

let user = $state({ name: "Alice", age: 25 });
user.age = 26;  // This IS reactive in Svelte 5!
</code></pre>
    <br/><br/>



    <li><code>$derived</code> — Computed Values</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);
    let quadrupled = $derived(doubled * 2);
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$derived</code> replaces the <code>$:</code> reactive declarations.</li>
    </ul>
    <br/><br/>



    <li><code>$effect</code> — Side Effects</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    $effect(() =&gt; {
        console.log("Count is now:", count);
    });

    $effect(() =&gt; {
        // Runs when component mounts
        console.log("Mounted!");

        return () =&gt; {
            // Cleanup when component unmounts
            console.log("Unmounted!");
        };
    });
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$effect</code> automatically tracks dependencies and re-runs when they change.</li>
        <li>Return a function for cleanup (like <code>useEffect</code> in React).</li>
    </ul>
    <br/><br/>



    <li><code>$props</code> — Component Props</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let { name, age = 18 } = $props();
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$props</code> replaces <code>export let</code> for declaring component props in Svelte 5.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Reactivity</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5 (Runes)</th>
        </tr>
        <tr>
            <td>Reactive variable</td>
            <td><code>let count = 0;</code></td>
            <td><code>let count = $state(0);</code></td>
        </tr>
        <tr>
            <td>Computed value</td>
            <td><code>$: doubled = count * 2;</code></td>
            <td><code>let doubled = $derived(count * 2);</code></td>
        </tr>
        <tr>
            <td>Side effect</td>
            <td><code>$: console.log(count);</code></td>
            <td><code>$effect(() =&gt; console.log(count));</code></td>
        </tr>
        <tr>
            <td>Props</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Array/Object mutation</td>
            <td>Requires reassignment</td>
            <td>Direct mutation works</td>
        </tr>
        <tr>
            <td>Event handlers</td>
            <td><code>on:click={fn}</code></td>
            <td><code>onclick={fn}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-props">Svelte Props</h3>
<ol>
    <li>What Are Props?</li>
    <br/>
    <ul>
        <li><b>Props</b> (short for properties) are how you pass data from a <u>parent component</u> to a <u>child component</u>.</li>
        <br/>
        <li>Props allow components to be reusable and configurable.</li>
        <br/>
        <li>In Svelte, props flow <u>one direction</u>: from parent to child (unidirectional data flow).</li>
    </ul>
    <br/><br/>



    <li>Declaring Props (Svelte 4)</li>
    <br/>
    <ul>
        <li>In Svelte 4, use <code>export let</code> to declare a prop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name;
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>The parent component passes the prop as an attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Alice" /&gt;
&lt;Greeting name="Bob" /&gt;
</code></pre>
    <br/><br/>



    <li>Default Values</li>
    <br/>
    <ul>
        <li>You can assign a default value to a prop:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name = "World";
    export let age = 18;
    export let active = false;
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Using defaults --&gt;
&lt;Greeting /&gt;                    &lt;!-- name="World", age=18 --&gt;
&lt;Greeting name="Alice" /&gt;       &lt;!-- name="Alice", age=18 --&gt;
&lt;Greeting name="Bob" age={25} /&gt;
</code></pre>
    <br/><br/>



    <li>Passing Different Data Types</li>
    <br/>
    <ul>
        <li>Strings can be passed directly, but other types require curly braces:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- String --&gt;
&lt;User name="Alice" /&gt;

&lt;!-- Number --&gt;
&lt;User age={25} /&gt;

&lt;!-- Boolean --&gt;
&lt;User active={true} /&gt;
&lt;User active /&gt;              &lt;!-- Shorthand for active={true} --&gt;

&lt;!-- Array --&gt;
&lt;List items={["Apple", "Banana", "Cherry"]} /&gt;

&lt;!-- Object --&gt;
&lt;Profile user={{ name: "Alice", age: 25 }} /&gt;

&lt;!-- Variable --&gt;
&lt;script&gt;
    let username = "Alice";
&lt;/script&gt;
&lt;User name={username} /&gt;
</code></pre>
    <br/><br/>



    <li>Shorthand Props</li>
    <br/>
    <ul>
        <li>When the prop name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "Alice";
    let age = 25;
&lt;/script&gt;

&lt;!-- Instead of this: --&gt;
&lt;User name={name} age={age} /&gt;

&lt;!-- Use shorthand: --&gt;
&lt;User {name} {age} /&gt;
</code></pre>
    <br/><br/>



    <li>Spread Props</li>
    <br/>
    <ul>
        <li>You can spread an object to pass multiple props at once:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import User from "./User.svelte";

    const userData = {
        name: "Alice",
        age: 25,
        email: "alice@example.com"
    };
&lt;/script&gt;

&lt;!-- Instead of: --&gt;
&lt;User name={userData.name} age={userData.age} email={userData.email} /&gt;

&lt;!-- Use spread: --&gt;
&lt;User {...userData} /&gt;
</code></pre>
    <br/><br/>



    <li>Receiving All Props with <code>$$props</code> and <code>$$restProps</code></li>
    <br/>
    <ul>
        <li><code>$$props</code> contains all props passed to a component:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name;
    export let age;

    // $$props = { name: "...", age: ..., ...anyOtherProps }
    console.log($$props);
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$$restProps</code> contains props that were <u>not</u> explicitly declared:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script&gt;
    export let variant = "primary";
    // Any other props (class, id, disabled, etc.) go to $$restProps
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...$$restProps}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Button variant="danger" disabled id="submit-btn"&gt;
    Submit
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>This is useful for wrapper components that forward attributes to native elements.</li>
    </ul>
    <br/><br/>



    <li>Reactive Props</li>
    <br/>
    <ul>
        <li>Props are reactive — when the parent updates a prop, the child re-renders:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script&gt;
    import Counter from "./Counter.svelte";
    let count = 0;
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;Increment in Parent&lt;/button&gt;
&lt;Counter value={count} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte --&gt;
&lt;script&gt;
    export let value;
    $: console.log("Value changed to:", value);
&lt;/script&gt;

&lt;p&gt;Count: {value}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Readonly Props (One-Way Binding)</li>
    <br/>
    <ul>
        <li>By default, props are <u>one-way</u>: parent → child.</li>
        <br/>
        <li>Modifying a prop inside the child does <u>not</u> affect the parent:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.svelte --&gt;
&lt;script&gt;
    export let count = 0;

    function increment() {
        count++;  // Only changes local copy, not parent's value
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;{count}&lt;/button&gt;
</code></pre>

    <ul>
        <li>To update the parent, use <u>events</u> or <u>two-way binding</u> (covered later).</li>
    </ul>
    <br/><br/>



    <li>Props with TypeScript (Svelte 4)</li>
    <br/>
    <ul>
        <li>Add types to props using TypeScript:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    export let name: string;
    export let age: number = 18;
    export let active: boolean = false;
    export let items: string[] = [];
    export let user: { name: string; email: string } | null = null;
&lt;/script&gt;
</code></pre>

    <ul>
        <li>For complex types, define interfaces:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    export let user: User;
    export let users: User[] = [];
&lt;/script&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with <code>$props</code></li>
    <br/>
    <ul>
        <li>In Svelte 5, use the <code>$props</code> rune instead of <code>export let</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte (Svelte 5) --&gt;
&lt;script&gt;
    let { name } = $props();
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>Multiple props with defaults:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name = "World", age = 18, active = false } = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Rest props (similar to <code>$$restProps</code>):</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name, age, ...rest } = $props();
&lt;/script&gt;

&lt;div {...rest}&gt;
    {name} is {age}
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with TypeScript</li>
    <br/>
    <ul>
        <li>Type your props using TypeScript with <code>$props</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Props {
        name: string;
        age?: number;
        active?: boolean;
    }

    let { name, age = 18, active = false }: Props = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>With rest props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: "primary" | "secondary" | "danger";
    }

    let { variant = "primary", ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Props</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>Basic prop</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Default value</td>
            <td><code>export let name = "World";</code></td>
            <td><code>let { name = "World" } = $props();</code></td>
        </tr>
        <tr>
            <td>Multiple props</td>
            <td>Multiple <code>export let</code> lines</td>
            <td>Destructure from <code>$props()</code></td>
        </tr>
        <tr>
            <td>Rest props</td>
            <td><code>$$restProps</code></td>
            <td><code>let { a, ...rest } = $props();</code></td>
        </tr>
        <tr>
            <td>All props</td>
            <td><code>$$props</code></td>
            <td><code>let props = $props();</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-logic">Svelte Logic</h3>
<ol>
    <li>What Is Svelte Logic?</li>
    <br/>
    <ul>
        <li>Svelte provides special <u>logic blocks</u> in templates to handle conditional rendering, loops, and asynchronous data.</li>
        <br/>
        <li>These blocks use a syntax with <code>{#...}</code> to open, <code>{:...}</code> for continuation, and <code>{/...}</code> to close.</li>
        <br/>
        <li>The main logic blocks are:
            <ul>
                <li><code>{#if}</code> — Conditional rendering</li>
                <li><code>{#each}</code> — Looping over arrays</li>
                <li><code>{#await}</code> — Handling promises</li>
                <li><code>{#key}</code> — Forcing re-render on value change</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Conditional Rendering with <code>{#if}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#if}</code> to conditionally render content:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{/if}

&lt;button onclick={() =&gt; loggedIn = !loggedIn}&gt;
    Toggle Login
&lt;/button&gt;
</code></pre>

    <ul>
        <li>The content inside <code>{#if}</code> only renders when the condition is <code>true</code>.</li>
    </ul>
    <br/><br/>



    <li><code>{:else}</code> Block</li>
    <br/>
    <ul>
        <li>Use <code>{:else}</code> to render alternative content when the condition is <code>false</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back, user!&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = false}&gt;Log Out&lt;/button&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = true}&gt;Log In&lt;/button&gt;
{/if}
</code></pre>
    <br/><br/>



    <li><code>{:else if}</code> Block</li>
    <br/>
    <ul>
        <li>Chain multiple conditions with <code>{:else if}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let score: number = 75;
&lt;/script&gt;

{#if score &gt;= 90}
    &lt;p&gt;Grade: A&lt;/p&gt;
{:else if score &gt;= 80}
    &lt;p&gt;Grade: B&lt;/p&gt;
{:else if score &gt;= 70}
    &lt;p&gt;Grade: C&lt;/p&gt;
{:else if score &gt;= 60}
    &lt;p&gt;Grade: D&lt;/p&gt;
{:else}
    &lt;p&gt;Grade: F&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Nested Conditionals</li>
    <br/>
    <ul>
        <li>You can nest <code>{#if}</code> blocks inside each other:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = true;
    let isAdmin: boolean = true;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome!&lt;/p&gt;
    {#if isAdmin}
        &lt;p&gt;You have admin privileges.&lt;/p&gt;
        &lt;button&gt;Access Admin Panel&lt;/button&gt;
    {:else}
        &lt;p&gt;You are a regular user.&lt;/p&gt;
    {/if}
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Looping with <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#each}</code> to iterate over arrays:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit}
        &lt;li&gt;{fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{#each}</code> with Index</li>
    <br/>
    <ul>
        <li>Access the current index as the second parameter:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit, index}
        &lt;li&gt;{index + 1}. {fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Keyed <code>{#each}</code> Blocks</li>
    <br/>
    <ul>
        <li>When items can be added, removed, or reordered, use a <u>key</u> to help Svelte track each item:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Todo {
        id: number;
        text: string;
        done: boolean;
    }

    let todos: Todo[] = [
        { id: 1, text: "Learn Svelte", done: false },
        { id: 2, text: "Build an app", done: false },
        { id: 3, text: "Deploy", done: false }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo (todo.id)}
        &lt;li&gt;{todo.text}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>

    <ul>
        <li>The <code>(todo.id)</code> part is the key — it should be a unique identifier.</li>
        <br/>
        <li>Keys ensure correct DOM updates when the list changes (especially important for animations and component state).</li>
    </ul>
    <br/><br/>



    <li><code>{#each}</code> with Destructuring</li>
    <br/>
    <ul>
        <li>Destructure objects directly in the each block:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    let users: User[] = [
        { id: 1, name: "Alice", email: "alice@example.com" },
        { id: 2, name: "Bob", email: "bob@example.com" }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each users as { id, name, email } (id)}
        &lt;li&gt;{name} - {email}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{:else}</code> in <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Render fallback content when the array is empty:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let todos: string[] = [];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo}
        &lt;li&gt;{todo}&lt;/li&gt;
    {:else}
        &lt;li&gt;No todos yet. Add one!&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Iterating Over Objects</li>
    <br/>
    <ul>
        <li>Use <code>Object.entries()</code> or <code>Object.keys()</code> to iterate over objects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const scores: Record&lt;string, number&gt; = {
        Alice: 95,
        Bob: 82,
        Charlie: 78
    };
&lt;/script&gt;

&lt;ul&gt;
    {#each Object.entries(scores) as [name, score]}
        &lt;li&gt;{name}: {score}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Handling Promises with <code>{#await}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#await}</code> to handle asynchronous data directly in templates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchUser(): Promise&lt;User&gt; {
        const response = await fetch("https://api.example.com/user/1");
        return response.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchUser();
&lt;/script&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;Hello, {user.name}!&lt;/p&gt;
{:catch error}
    &lt;p&gt;Error: {error.message}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li><code>{#await promise}</code> — Shows while pending</li>
        <li><code>{:then value}</code> — Shows when resolved</li>
        <li><code>{:catch error}</code> — Shows when rejected</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Loading State</li>
    <br/>
    <ul>
        <li>If you don't need a loading state, skip directly to <code>{:then}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let dataPromise: Promise&lt;string&gt; = Promise.resolve("Hello!");
&lt;/script&gt;

{#await dataPromise then data}
    &lt;p&gt;{data}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li>Nothing renders until the promise resolves.</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Catch</li>
    <br/>
    <ul>
        <li>You can omit <code>{:catch}</code> if you don't need error handling in the template:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        title: string;
        body: string;
    }

    async function fetchPost(): Promise&lt;Post&gt; {
        const res = await fetch("https://api.example.com/posts/1");
        return res.json();
    }

    let postPromise: Promise&lt;Post&gt; = fetchPost();
&lt;/script&gt;

{#await postPromise}
    &lt;p&gt;Loading post...&lt;/p&gt;
{:then post}
    &lt;h2&gt;{post.title}&lt;/h2&gt;
    &lt;p&gt;{post.body}&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Refreshing <code>{#await}</code> Data</li>
    <br/>
    <ul>
        <li>Reassign the promise to trigger a refresh:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchRandomUser(): Promise&lt;User&gt; {
        const id = Math.floor(Math.random() * 10) + 1;
        const res = await fetch(`https://api.example.com/users/${id}`);
        return res.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchRandomUser();

    function refresh(): void {
        userPromise = fetchRandomUser();  // Reassign to refetch
    }
&lt;/script&gt;

&lt;button onclick={refresh}&gt;Load Random User&lt;/button&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;{user.name}&lt;/p&gt;
{:catch error}
    &lt;p&gt;Failed to load user.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Forcing Re-render with <code>{#key}</code></li>
    <br/>
    <ul>
        <li>The <code>{#key}</code> block destroys and recreates its content when the key value changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let userId: number = 1;
&lt;/script&gt;

&lt;input type="number" bind:value={userId} min="1" /&gt;

{#key userId}
    &lt;UserProfile id={userId} /&gt;
{/key}
</code></pre>

    <ul>
        <li>When <code>userId</code> changes, the <code>UserProfile</code> component is destroyed and a new instance is created.</li>
        <br/>
        <li>This resets all component state and re-runs lifecycle functions.</li>
    </ul>
    <br/><br/>



    <li><code>{#key}</code> for Animations</li>
    <br/>
    <ul>
        <li><code>{#key}</code> is useful for triggering intro/outro transitions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let count: number = 0;
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;

{#key count}
    &lt;p transition:fade&gt;{count}&lt;/p&gt;
{/key}
</code></pre>

    <ul>
        <li>Every time <code>count</code> changes, the paragraph fades out and a new one fades in.</li>
    </ul>
    <br/><br/>



    <li>Combining Logic Blocks</li>
    <br/>
    <ul>
        <li>Logic blocks can be combined for complex rendering:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        id: number;
        title: string;
        published: boolean;
    }

    async function fetchPosts(): Promise&lt;Post[]&gt; {
        const res = await fetch("https://api.example.com/posts");
        return res.json();
    }

    let postsPromise: Promise&lt;Post[]&gt; = fetchPosts();
    let showOnlyPublished: boolean = false;
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={showOnlyPublished} /&gt;
    Show only published
&lt;/label&gt;

{#await postsPromise}
    &lt;p&gt;Loading posts...&lt;/p&gt;
{:then posts}
    &lt;ul&gt;
        {#each posts as post (post.id)}
            {#if !showOnlyPublished || post.published}
                &lt;li&gt;
                    {post.title}
                    {#if !post.published}
                        &lt;span&gt;(Draft)&lt;/span&gt;
                    {/if}
                &lt;/li&gt;
            {/if}
        {/each}
    &lt;/ul&gt;
{:catch}
    &lt;p&gt;Failed to load posts.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Logic Blocks Summary</li>
    <br/>

    <table>
        <tr>
            <th>Block</th>
            <th>Purpose</th>
            <th>Syntax</th>
        </tr>
        <tr>
            <td><code>{#if}</code></td>
            <td>Conditional rendering</td>
            <td><code>{#if condition}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else}</code></td>
            <td>Else branch</td>
            <td><code>{#if}...{:else}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else if}</code></td>
            <td>Else-if branch</td>
            <td><code>{#if}...{:else if}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{#each}</code></td>
            <td>Loop over arrays</td>
            <td><code>{#each array as item}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#each} + key</code></td>
            <td>Keyed loop</td>
            <td><code>{#each array as item (key)}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#await}</code></td>
            <td>Handle promises</td>
            <td><code>{#await promise}...{:then}...{:catch}...{/await}</code></td>
        </tr>
        <tr>
            <td><code>{#key}</code></td>
            <td>Force re-render</td>
            <td><code>{#key value}...{/key}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
