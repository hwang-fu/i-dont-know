<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .325rem;
        padding: .05rem .25rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.725rem;
        line-height: 1.7;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.825rem;
        line-height: 1.4;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/svelte.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#svelte-introduction">Introduction</a></li>
        <li><a href="#svelte-reactivity">Reactivity</a></li>
        <li><a href="#svelte-props">Props</a></li>
        <li><a href="#svelte-logic">Logic</a></li>
        <li><a href="#svelte-events">Events</a></li>
        <li><a href="#svelte-bindings">Bindings</a></li>
        <li><a href="#svelte-classes">Classes</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-introduction">Introduction to Svelte</h3>
<ol>
    <li>What Is Svelte?</li>
    <br/>
    <ul>
        <li><b>Svelte</b> is a modern, <u>compiler-based</u> JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Unlike Vue or React, Svelte shifts work from the <u>browser</u> to a <u>compile step</u> at build time, producing highly optimized vanilla JavaScript.</li>
        <br/>
        <li>Svelte's ecosystem includes:
            <ul>
                <li><code>SvelteKit</code> which is a full-stack application framework (routing, SSR, etc.)</li>
                <li><code>Svelte Stores</code> for built-in state management</li>
                <li><code>Vite</code> is the recommended build tool</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>How Svelte Works</li>
    <br/>
    <ul>
        <li>Svelte compiles your components into <u>efficient imperative code</u> that surgically updates the DOM.</li>
        <br/>
        <li>There is <u>no virtual DOM</u> — Svelte generates code that directly manipulates the DOM when state changes.</li>
        <br/>
        <li>A Svelte component contains:
            <ul>
                <li>a <code>&lt;script&gt;</code> block for JavaScript logic</li>
                <li>HTML markup (the template)</li>
                <li>an optional <code>&lt;style&gt;</code> block for scoped CSS</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let message = "Hello Svelte!";
&lt;/script&gt;

&lt;h1&gt;{message}&lt;/h1&gt;

&lt;style&gt;
    h1 {
        color: #ff3e00;
    }
&lt;/style&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{ }</code> automatically updates when <code>message</code> changes.</li>
    </ul>
    <br/><br/>



    <li>Getting Started (Project Setup)</li>
    <br/>
    <ul>
        <li>The recommended way to start a Svelte project is using <code>SvelteKit</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npx sv create my-app
cd my-app/
npm install
npm run dev
</code></pre>
    <ul>
        <li>For a simpler standalone Svelte project without it:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm create vite@latest my-app -- --template svelte
cd my-app/
npm install
npm run dev
</code></pre>
    <br/><br/>



    <li>Core Concepts of Svelte</li>

    <br/>
    <ol>
    <li>Reactivity</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is built into the language — just assign a new value to trigger updates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count += 1;  // This automatically updates the DOM
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>Use <code>$:</code> to create reactive statements that re-run when dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: console.log("Count is now", count);
&lt;/script&gt;

&lt;p&gt;{count} doubled is {doubled}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Handling</li>

<pre><code class="language-html line-numbers">&lt;button on:click={handleClick}&gt;Click me&lt;/button&gt;

&lt;!-- With inline handler --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increase&lt;/button&gt;

&lt;!-- With modifiers --&gt;
&lt;button on:click|once|preventDefault={handleClick}&gt;Submit&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>on:click</code> is Svelte's event directive syntax.</li>
        <li>Modifiers like <code>|once</code>, <code>|preventDefault</code>, <code>|stopPropagation</code> can be chained.</li>
    </ul>
    <br/><br/>



    <li>Two-Way Binding with <code>bind:</code></li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "";
&lt;/script&gt;

&lt;input bind:value={name} /&gt;
&lt;p&gt;Hello {name}!&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>
    <br/><br/>



    <li>Conditionals and Loops</li>
<pre><code class="language-html line-numbers">&lt;!-- Conditionals --&gt;
{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}

&lt;!-- Loops --&gt;
{#each items as item, index (item.id)}
    &lt;li&gt;{index}: {item.name}&lt;/li&gt;
{/each}
</code></pre>
    <ul>
        <li><code>{#if}</code>, <code>{:else}</code>, <code>{/if}</code> are Svelte's conditional blocks.</li>
        <li><code>{#each}</code> iterates over arrays; the <code>(item.id)</code> part is a keyed each block for efficient updates.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Component Structure</li>
    <br/>
    <ul>
        <li>Svelte components are stored in <code>.svelte</code> files.</li>
        <li>Each file is a single component with script, markup, and styles together.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name = "World";
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;

&lt;style&gt;
    h1 {
        font-family: Georgia, serif;
        color: #333;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>export let</code> declares a <u>prop</u> that can be passed from parent components.</li>
        <li>Styles are <u>scoped by default</u>, they only affect this component.</li>
    </ul>
    <br/><br/>



    <li>Using Components</li>
    <br/>
    <ul>
        <li>Import and use components like regular ES modules:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Svelte" /&gt;
&lt;Greeting /&gt;  &lt;!-- Uses default "World" --&gt;
</code></pre>
    <br/><br/>



    <li>Key Differences from Other Frameworks</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte</th>
            <th>Vue / React</th>
        </tr>
        <tr>
            <td>Compilation</td>
            <td>Compiles to vanilla JS at build time</td>
            <td>Ships a runtime library to the browser</td>
        </tr>
        <tr>
            <td>Virtual DOM</td>
            <td>No virtual DOM</td>
            <td>Uses virtual DOM for diffing</td>
        </tr>
        <tr>
            <td>Reactivity</td>
            <td>Built into the language (<code>$:</code>)</td>
            <td>Requires hooks or reactive APIs</td>
        </tr>
        <tr>
            <td>Bundle Size</td>
            <td>Typically smaller</td>
            <td>Includes framework runtime</td>
        </tr>
        <tr>
            <td>Learning Curve</td>
            <td>Closer to vanilla HTML/CSS/JS</td>
            <td>Framework-specific patterns</td>
        </tr>
    </table>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduced <u>Runes</u>, a new reactivity system using special functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);

    function increment() {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    {count} × 2 = {doubled}
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$state()</code> creates reactive state.</li>
        <li><code>$derived()</code> creates computed values.</li>
        <li><code>$effect()</code> runs side effects when dependencies change.</li>
        <li>Note: In Svelte 5, event handlers use <code>onclick</code> instead of <code>on:click</code>.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-reactivity">Svelte Reactivity</h3>
<ol>
    <li>What Is Reactivity in Svelte?</li>
    <br/>
    <ul>
        <li><b>Reactivity</b> means that when your data changes, the UI automatically updates to reflect those changes.</li>
        <br/>
        <li>In Svelte, reactivity is <u>built into the language</u> — you don't need special APIs or hooks.</li>
        <br/>
        <li>Svelte's compiler analyzes your code and generates efficient JavaScript that updates the DOM only where necessary.</li>
    </ul>
    <br/><br/>



    <li>Assignment-Based Reactivity</li>
    <br/>
    <ul>
        <li>In Svelte, <u>assignments</u> trigger reactivity. Simply reassigning a variable updates the DOM.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count = count + 1;  // Assignment triggers update
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This also works with shorthand operators:</li>
    </ul>

<pre><code class="language-js line-numbers">count += 1;   // Reactive
count++;      // Reactive
count--;      // Reactive
</code></pre>
    <br/><br/>



    <li>Reactivity with Arrays and Objects</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is triggered by <u>assignments</u>, not mutations.</li>
        <br/>
        <li>Methods like <code>push()</code>, <code>pop()</code>, <code>splice()</code> do <u>not</u> trigger reactivity by themselves:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");  // This does NOT trigger update!
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>To trigger reactivity, you must <u>reassign</u> the variable:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");
        items = items;  // Reassignment triggers update
    }

    // Or more idiomatically:
    function addItemBetter() {
        items = [...items, "Cherry"];  // Spread creates new array
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Same applies to objects:</li>
    </ul>

<pre><code class="language-js line-numbers">let user = { name: "Alice", age: 25 };

user.age = 26;      // Does NOT trigger update
user = user;        // Triggers update

// Or:
user = { ...user, age: 26 };  // Triggers update
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>The <code>$:</code> label creates <u>reactive declarations</u> — values that automatically recalculate when their dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: quadrupled = doubled * 2;
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Svelte automatically tracks which variables are used and re-runs the declaration when any dependency changes.</li>
        <br/>
        <li>Reactive declarations can depend on other reactive declarations (like <code>quadrupled</code> depends on <code>doubled</code>).</li>
    </ul>
    <br/><br/>



    <li>Reactive Statements</li>
    <br/>
    <ul>
        <li>You can also use <code>$:</code> to run <u>arbitrary statements</u> reactively:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    $: console.log("Count changed to:", count);

    $: if (count &gt;= 10) {
        alert("Count is getting high!");
        count = 0;
    }

    $: {
        console.log("Running reactive block");
        console.log("Current count:", count);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>These statements re-run whenever any referenced variable changes.</li>
    </ul>
    <br/><br/>



    <li>Reactive Stores</li>
    <br/>
    <ul>
        <li>For state that needs to be shared across components, Svelte provides <u>stores</u>.</li>
        <br/>
        <li>A store is an object with a <code>subscribe</code> method that allows reactive access to a value.</li>
        <br/>
        <li>Svelte provides three built-in store types.</li>
    </ul>

    <br/>
    <ol>
    <li><code>writable</code> — Read and write</li>

<pre><code class="language-js line-numbers">// stores.js
import { writable } from "svelte/store";

export const count = writable(0);
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { count } from "./stores.js";

    function increment() {
        count.update(n =&gt; n + 1);
    }

    function reset() {
        count.set(0);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>set(value)</code> — Sets the store to a new value.</li>
        <li><code>update(fn)</code> — Updates based on current value.</li>
    </ul>
    <br/><br/>



    <li><code>readable</code> — Read only</li>

<pre><code class="language-js line-numbers">import { readable } from "svelte/store";

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() =&gt; {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };
});
</code></pre>

    <ul>
        <li>The second argument is a function that receives <code>set</code> and returns a cleanup function.</li>
    </ul>
    <br/><br/>



    <li><code>derived</code> — Derived from other stores</li>

<pre><code class="language-js line-numbers">import { derived } from "svelte/store";
import { count } from "./stores.js";

export const doubled = derived(count, $count =&gt; $count * 2);

// Derived from multiple stores:
export const total = derived(
    [storeA, storeB],
    ([$a, $b]) =&gt; $a + $b
);
</code></pre>
    </ol>
    <br/><br/>



    <li>Auto-Subscription with <code>$</code> Prefix</li>
    <br/>
    <ul>
        <li>Inside Svelte components, you can access store values using the <code>$</code> prefix:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { count } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;The count is {$count}&lt;/p&gt;

&lt;button on:click={() =&gt; $count++}&gt;
    Increment
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$count</code> automatically subscribes to the store and unsubscribes when the component is destroyed.</li>
        <br/>
        <li>You can also assign directly to <code>$count</code> — it's equivalent to calling <code>count.set()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { name } from "./stores.js";
&lt;/script&gt;

&lt;input bind:value={$name}&gt;
</code></pre>
    <br/><br/>



    <li>Custom Stores</li>
    <br/>
    <ul>
        <li>You can create custom stores with domain-specific logic:</li>
    </ul>

<pre><code class="language-js line-numbers">import { writable } from "svelte/store";

function createCounter() {
    const { subscribe, set, update } = writable(0);

    return {
        subscribe,
        increment: () =&gt; update(n =&gt; n + 1),
        decrement: () =&gt; update(n =&gt; n - 1),
        reset: () =&gt; set(0)
    };
}

export const counter = createCounter();
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { counter } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;{$counter}&lt;/p&gt;
&lt;button on:click={counter.increment}&gt;+&lt;/button&gt;
&lt;button on:click={counter.decrement}&gt;-&lt;/button&gt;
&lt;button on:click={counter.reset}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity System)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduces <u>Runes</u>, a new reactivity system that replaces <code>$:</code> and provides more explicit control.</li>
    </ul>

    <br/>
    <ol>
    <li><code>$state</code> — Reactive State</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    function increment() {
        count++;  // Directly mutate, it's reactive!
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>With <code>$state</code>, even mutations on arrays and objects are reactive:</li>
    </ul>

<pre><code class="language-js line-numbers">let items = $state(["Apple", "Banana"]);
items.push("Cherry");  // This IS reactive in Svelte 5!

let user = $state({ name: "Alice", age: 25 });
user.age = 26;  // This IS reactive in Svelte 5!
</code></pre>
    <br/><br/>



    <li><code>$derived</code> — Computed Values</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);
    let quadrupled = $derived(doubled * 2);
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$derived</code> replaces the <code>$:</code> reactive declarations.</li>
    </ul>
    <br/><br/>



    <li><code>$effect</code> — Side Effects</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    $effect(() =&gt; {
        console.log("Count is now:", count);
    });

    $effect(() =&gt; {
        // Runs when component mounts
        console.log("Mounted!");

        return () =&gt; {
            // Cleanup when component unmounts
            console.log("Unmounted!");
        };
    });
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$effect</code> automatically tracks dependencies and re-runs when they change.</li>
        <li>Return a function for cleanup (like <code>useEffect</code> in React).</li>
    </ul>
    <br/><br/>



    <li><code>$props</code> — Component Props</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let { name, age = 18 } = $props();
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$props</code> replaces <code>export let</code> for declaring component props in Svelte 5.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Reactivity</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5 (Runes)</th>
        </tr>
        <tr>
            <td>Reactive variable</td>
            <td><code>let count = 0;</code></td>
            <td><code>let count = $state(0);</code></td>
        </tr>
        <tr>
            <td>Computed value</td>
            <td><code>$: doubled = count * 2;</code></td>
            <td><code>let doubled = $derived(count * 2);</code></td>
        </tr>
        <tr>
            <td>Side effect</td>
            <td><code>$: console.log(count);</code></td>
            <td><code>$effect(() =&gt; console.log(count));</code></td>
        </tr>
        <tr>
            <td>Props</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Array/Object mutation</td>
            <td>Requires reassignment</td>
            <td>Direct mutation works</td>
        </tr>
        <tr>
            <td>Event handlers</td>
            <td><code>on:click={fn}</code></td>
            <td><code>onclick={fn}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-props">Svelte Props</h3>
<ol>
    <li>What Are Props?</li>
    <br/>
    <ul>
        <li><b>Props</b> (short for properties) are how you pass data from a <u>parent component</u> to a <u>child component</u>.</li>
        <br/>
        <li>Props allow components to be reusable and configurable.</li>
        <br/>
        <li>In Svelte, props flow <u>one direction</u>: from parent to child (unidirectional data flow).</li>
    </ul>
    <br/><br/>



    <li>Declaring Props (Svelte 4)</li>
    <br/>
    <ul>
        <li>In Svelte 4, use <code>export let</code> to declare a prop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name;
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>The parent component passes the prop as an attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Alice" /&gt;
&lt;Greeting name="Bob" /&gt;
</code></pre>
    <br/><br/>



    <li>Default Values</li>
    <br/>
    <ul>
        <li>You can assign a default value to a prop:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name = "World";
    export let age = 18;
    export let active = false;
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Using defaults --&gt;
&lt;Greeting /&gt;                    &lt;!-- name="World", age=18 --&gt;
&lt;Greeting name="Alice" /&gt;       &lt;!-- name="Alice", age=18 --&gt;
&lt;Greeting name="Bob" age={25} /&gt;
</code></pre>
    <br/><br/>



    <li>Passing Different Data Types</li>
    <br/>
    <ul>
        <li>Strings can be passed directly, but other types require curly braces:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- String --&gt;
&lt;User name="Alice" /&gt;

&lt;!-- Number --&gt;
&lt;User age={25} /&gt;

&lt;!-- Boolean --&gt;
&lt;User active={true} /&gt;
&lt;User active /&gt;              &lt;!-- Shorthand for active={true} --&gt;

&lt;!-- Array --&gt;
&lt;List items={["Apple", "Banana", "Cherry"]} /&gt;

&lt;!-- Object --&gt;
&lt;Profile user={{ name: "Alice", age: 25 }} /&gt;

&lt;!-- Variable --&gt;
&lt;script&gt;
    let username = "Alice";
&lt;/script&gt;
&lt;User name={username} /&gt;
</code></pre>
    <br/><br/>



    <li>Shorthand Props</li>
    <br/>
    <ul>
        <li>When the prop name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "Alice";
    let age = 25;
&lt;/script&gt;

&lt;!-- Instead of this: --&gt;
&lt;User name={name} age={age} /&gt;

&lt;!-- Use shorthand: --&gt;
&lt;User {name} {age} /&gt;
</code></pre>
    <br/><br/>



    <li>Spread Props</li>
    <br/>
    <ul>
        <li>You can spread an object to pass multiple props at once:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import User from "./User.svelte";

    const userData = {
        name: "Alice",
        age: 25,
        email: "alice@example.com"
    };
&lt;/script&gt;

&lt;!-- Instead of: --&gt;
&lt;User name={userData.name} age={userData.age} email={userData.email} /&gt;

&lt;!-- Use spread: --&gt;
&lt;User {...userData} /&gt;
</code></pre>
    <br/><br/>



    <li>Receiving All Props with <code>$$props</code> and <code>$$restProps</code></li>
    <br/>
    <ul>
        <li><code>$$props</code> contains all props passed to a component:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name;
    export let age;

    // $$props = { name: "...", age: ..., ...anyOtherProps }
    console.log($$props);
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$$restProps</code> contains props that were <u>not</u> explicitly declared:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script&gt;
    export let variant = "primary";
    // Any other props (class, id, disabled, etc.) go to $$restProps
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...$$restProps}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Button variant="danger" disabled id="submit-btn"&gt;
    Submit
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>This is useful for wrapper components that forward attributes to native elements.</li>
    </ul>
    <br/><br/>



    <li>Reactive Props</li>
    <br/>
    <ul>
        <li>Props are reactive — when the parent updates a prop, the child re-renders:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script&gt;
    import Counter from "./Counter.svelte";
    let count = 0;
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;Increment in Parent&lt;/button&gt;
&lt;Counter value={count} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte --&gt;
&lt;script&gt;
    export let value;
    $: console.log("Value changed to:", value);
&lt;/script&gt;

&lt;p&gt;Count: {value}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Readonly Props (One-Way Binding)</li>
    <br/>
    <ul>
        <li>By default, props are <u>one-way</u>: parent → child.</li>
        <br/>
        <li>Modifying a prop inside the child does <u>not</u> affect the parent:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.svelte --&gt;
&lt;script&gt;
    export let count = 0;

    function increment() {
        count++;  // Only changes local copy, not parent's value
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;{count}&lt;/button&gt;
</code></pre>

    <ul>
        <li>To update the parent, use <u>events</u> or <u>two-way binding</u> (covered later).</li>
    </ul>
    <br/><br/>



    <li>Props with TypeScript (Svelte 4)</li>
    <br/>
    <ul>
        <li>Add types to props using TypeScript:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    export let name: string;
    export let age: number = 18;
    export let active: boolean = false;
    export let items: string[] = [];
    export let user: { name: string; email: string } | null = null;
&lt;/script&gt;
</code></pre>

    <ul>
        <li>For complex types, define interfaces:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    export let user: User;
    export let users: User[] = [];
&lt;/script&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with <code>$props</code></li>
    <br/>
    <ul>
        <li>In Svelte 5, use the <code>$props</code> rune instead of <code>export let</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte (Svelte 5) --&gt;
&lt;script&gt;
    let { name } = $props();
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>Multiple props with defaults:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name = "World", age = 18, active = false } = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Rest props (similar to <code>$$restProps</code>):</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name, age, ...rest } = $props();
&lt;/script&gt;

&lt;div {...rest}&gt;
    {name} is {age}
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with TypeScript</li>
    <br/>
    <ul>
        <li>Type your props using TypeScript with <code>$props</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Props {
        name: string;
        age?: number;
        active?: boolean;
    }

    let { name, age = 18, active = false }: Props = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>With rest props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: "primary" | "secondary" | "danger";
    }

    let { variant = "primary", ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Props</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>Basic prop</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Default value</td>
            <td><code>export let name = "World";</code></td>
            <td><code>let { name = "World" } = $props();</code></td>
        </tr>
        <tr>
            <td>Multiple props</td>
            <td>Multiple <code>export let</code> lines</td>
            <td>Destructure from <code>$props()</code></td>
        </tr>
        <tr>
            <td>Rest props</td>
            <td><code>$$restProps</code></td>
            <td><code>let { a, ...rest } = $props();</code></td>
        </tr>
        <tr>
            <td>All props</td>
            <td><code>$$props</code></td>
            <td><code>let props = $props();</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-logic">Svelte Logic</h3>
<ol>
    <li>What Is Svelte Logic?</li>
    <br/>
    <ul>
        <li>Svelte provides special <u>logic blocks</u> in templates to handle conditional rendering, loops, and asynchronous data.</li>
        <br/>
        <li>These blocks use a syntax with <code>{#...}</code> to open, <code>{:...}</code> for continuation, and <code>{/...}</code> to close.</li>
        <br/>
        <li>The main logic blocks are:
            <ul>
                <li><code>{#if}</code> — Conditional rendering</li>
                <li><code>{#each}</code> — Looping over arrays</li>
                <li><code>{#await}</code> — Handling promises</li>
                <li><code>{#key}</code> — Forcing re-render on value change</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Conditional Rendering with <code>{#if}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#if}</code> to conditionally render content:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{/if}

&lt;button onclick={() =&gt; loggedIn = !loggedIn}&gt;
    Toggle Login
&lt;/button&gt;
</code></pre>

    <ul>
        <li>The content inside <code>{#if}</code> only renders when the condition is <code>true</code>.</li>
    </ul>
    <br/><br/>



    <li><code>{:else}</code> Block</li>
    <br/>
    <ul>
        <li>Use <code>{:else}</code> to render alternative content when the condition is <code>false</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back, user!&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = false}&gt;Log Out&lt;/button&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = true}&gt;Log In&lt;/button&gt;
{/if}
</code></pre>
    <br/><br/>



    <li><code>{:else if}</code> Block</li>
    <br/>
    <ul>
        <li>Chain multiple conditions with <code>{:else if}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let score: number = 75;
&lt;/script&gt;

{#if score &gt;= 90}
    &lt;p&gt;Grade: A&lt;/p&gt;
{:else if score &gt;= 80}
    &lt;p&gt;Grade: B&lt;/p&gt;
{:else if score &gt;= 70}
    &lt;p&gt;Grade: C&lt;/p&gt;
{:else if score &gt;= 60}
    &lt;p&gt;Grade: D&lt;/p&gt;
{:else}
    &lt;p&gt;Grade: F&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Nested Conditionals</li>
    <br/>
    <ul>
        <li>You can nest <code>{#if}</code> blocks inside each other:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = true;
    let isAdmin: boolean = true;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome!&lt;/p&gt;
    {#if isAdmin}
        &lt;p&gt;You have admin privileges.&lt;/p&gt;
        &lt;button&gt;Access Admin Panel&lt;/button&gt;
    {:else}
        &lt;p&gt;You are a regular user.&lt;/p&gt;
    {/if}
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Looping with <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#each}</code> to iterate over arrays:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit}
        &lt;li&gt;{fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{#each}</code> with Index</li>
    <br/>
    <ul>
        <li>Access the current index as the second parameter:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit, index}
        &lt;li&gt;{index + 1}. {fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Keyed <code>{#each}</code> Blocks</li>
    <br/>
    <ul>
        <li>When items can be added, removed, or reordered, use a <u>key</u> to help Svelte track each item:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Todo {
        id: number;
        text: string;
        done: boolean;
    }

    let todos: Todo[] = [
        { id: 1, text: "Learn Svelte", done: false },
        { id: 2, text: "Build an app", done: false },
        { id: 3, text: "Deploy", done: false }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo (todo.id)}
        &lt;li&gt;{todo.text}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>

    <ul>
        <li>The <code>(todo.id)</code> part is the key — it should be a unique identifier.</li>
        <br/>
        <li>Keys ensure correct DOM updates when the list changes (especially important for animations and component state).</li>
    </ul>
    <br/><br/>



    <li><code>{#each}</code> with Destructuring</li>
    <br/>
    <ul>
        <li>Destructure objects directly in the each block:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    let users: User[] = [
        { id: 1, name: "Alice", email: "alice@example.com" },
        { id: 2, name: "Bob", email: "bob@example.com" }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each users as { id, name, email } (id)}
        &lt;li&gt;{name} - {email}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{:else}</code> in <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Render fallback content when the array is empty:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let todos: string[] = [];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo}
        &lt;li&gt;{todo}&lt;/li&gt;
    {:else}
        &lt;li&gt;No todos yet. Add one!&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Iterating Over Objects</li>
    <br/>
    <ul>
        <li>Use <code>Object.entries()</code> or <code>Object.keys()</code> to iterate over objects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const scores: Record&lt;string, number&gt; = {
        Alice: 95,
        Bob: 82,
        Charlie: 78
    };
&lt;/script&gt;

&lt;ul&gt;
    {#each Object.entries(scores) as [name, score]}
        &lt;li&gt;{name}: {score}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Handling Promises with <code>{#await}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#await}</code> to handle asynchronous data directly in templates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchUser(): Promise&lt;User&gt; {
        const response = await fetch("https://api.example.com/user/1");
        return response.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchUser();
&lt;/script&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;Hello, {user.name}!&lt;/p&gt;
{:catch error}
    &lt;p&gt;Error: {error.message}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li><code>{#await promise}</code> — Shows while pending</li>
        <li><code>{:then value}</code> — Shows when resolved</li>
        <li><code>{:catch error}</code> — Shows when rejected</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Loading State</li>
    <br/>
    <ul>
        <li>If you don't need a loading state, skip directly to <code>{:then}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let dataPromise: Promise&lt;string&gt; = Promise.resolve("Hello!");
&lt;/script&gt;

{#await dataPromise then data}
    &lt;p&gt;{data}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li>Nothing renders until the promise resolves.</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Catch</li>
    <br/>
    <ul>
        <li>You can omit <code>{:catch}</code> if you don't need error handling in the template:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        title: string;
        body: string;
    }

    async function fetchPost(): Promise&lt;Post&gt; {
        const res = await fetch("https://api.example.com/posts/1");
        return res.json();
    }

    let postPromise: Promise&lt;Post&gt; = fetchPost();
&lt;/script&gt;

{#await postPromise}
    &lt;p&gt;Loading post...&lt;/p&gt;
{:then post}
    &lt;h2&gt;{post.title}&lt;/h2&gt;
    &lt;p&gt;{post.body}&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Refreshing <code>{#await}</code> Data</li>
    <br/>
    <ul>
        <li>Reassign the promise to trigger a refresh:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchRandomUser(): Promise&lt;User&gt; {
        const id = Math.floor(Math.random() * 10) + 1;
        const res = await fetch(`https://api.example.com/users/${id}`);
        return res.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchRandomUser();

    function refresh(): void {
        userPromise = fetchRandomUser();  // Reassign to refetch
    }
&lt;/script&gt;

&lt;button onclick={refresh}&gt;Load Random User&lt;/button&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;{user.name}&lt;/p&gt;
{:catch error}
    &lt;p&gt;Failed to load user.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Forcing Re-render with <code>{#key}</code></li>
    <br/>
    <ul>
        <li>The <code>{#key}</code> block destroys and recreates its content when the key value changes:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let userId: number = 1;
&lt;/script&gt;

&lt;input type="number" bind:value={userId} min="1" /&gt;

{#key userId}
    &lt;UserProfile id={userId} /&gt;
{/key}
</code></pre>

    <ul>
        <li>When <code>userId</code> changes, the <code>UserProfile</code> component is destroyed and a new instance is created.</li>
        <br/>
        <li>This resets all component state and re-runs lifecycle functions.</li>
    </ul>
    <br/><br/>



    <li><code>{#key}</code> for Animations</li>
    <br/>
    <ul>
        <li><code>{#key}</code> is useful for triggering intro/outro transitions:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let count: number = 0;
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;

{#key count}
    &lt;p transition:fade&gt;{count}&lt;/p&gt;
{/key}
</code></pre>

    <ul>
        <li>Every time <code>count</code> changes, the paragraph fades out and a new one fades in.</li>
    </ul>
    <br/><br/>



    <li>Combining Logic Blocks</li>
    <br/>
    <ul>
        <li>Logic blocks can be combined for complex rendering:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        id: number;
        title: string;
        published: boolean;
    }

    async function fetchPosts(): Promise&lt;Post[]&gt; {
        const res = await fetch("https://api.example.com/posts");
        return res.json();
    }

    let postsPromise: Promise&lt;Post[]&gt; = fetchPosts();
    let showOnlyPublished: boolean = false;
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={showOnlyPublished} /&gt;
    Show only published
&lt;/label&gt;

{#await postsPromise}
    &lt;p&gt;Loading posts...&lt;/p&gt;
{:then posts}
    &lt;ul&gt;
        {#each posts as post (post.id)}
            {#if !showOnlyPublished || post.published}
                &lt;li&gt;
                    {post.title}
                    {#if !post.published}
                        &lt;span&gt;(Draft)&lt;/span&gt;
                    {/if}
                &lt;/li&gt;
            {/if}
        {/each}
    &lt;/ul&gt;
{:catch}
    &lt;p&gt;Failed to load posts.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Logic Blocks Summary</li>
    <br/>

    <table>
        <tr>
            <th>Block</th>
            <th>Purpose</th>
            <th>Syntax</th>
        </tr>
        <tr>
            <td><code>{#if}</code></td>
            <td>Conditional rendering</td>
            <td><code>{#if condition}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else}</code></td>
            <td>Else branch</td>
            <td><code>{#if}...{:else}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else if}</code></td>
            <td>Else-if branch</td>
            <td><code>{#if}...{:else if}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{#each}</code></td>
            <td>Loop over arrays</td>
            <td><code>{#each array as item}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#each} + key</code></td>
            <td>Keyed loop</td>
            <td><code>{#each array as item (key)}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#await}</code></td>
            <td>Handle promises</td>
            <td><code>{#await promise}...{:then}...{:catch}...{/await}</code></td>
        </tr>
        <tr>
            <td><code>{#key}</code></td>
            <td>Force re-render</td>
            <td><code>{#key value}...{/key}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-events">Svelte Events</h3>
<ol>
    <li>What Are Events in Svelte?</li>
    <br/>
    <ul>
        <li><b>Events</b> allow components to respond to user interactions and communicate with each other.</li>
        <br/>
        <li>Svelte supports:
            <ul>
                <li><b>DOM events</b> — Native browser events like click, input, submit</li>
                <li><b>Component events</b> — Custom events dispatched from child to parent</li>
            </ul>
        </li>
        <br/>
        <li>Svelte 4 uses <code>on:event</code> syntax, while Svelte 5 uses <code>onevent</code> syntax.</li>
    </ul>
    <br/><br/>



    <li>DOM Event Handling (Svelte 4)</li>
    <br/>
    <ul>
        <li>Use <code>on:</code> directive to listen to DOM events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = 0;

    function handleClick(): void {
        count++;
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>

    <ul>
        <li>Common DOM events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Mouse events --&gt;
&lt;button on:click={handleClick}&gt;Click&lt;/button&gt;
&lt;div on:dblclick={handleDoubleClick}&gt;Double click&lt;/div&gt;
&lt;div on:mouseenter={handleMouseEnter}&gt;Hover me&lt;/div&gt;
&lt;div on:mouseleave={handleMouseLeave}&gt;Leave me&lt;/div&gt;
&lt;div on:mousemove={handleMouseMove}&gt;Move inside&lt;/div&gt;

&lt;!-- Keyboard events --&gt;
&lt;input on:keydown={handleKeyDown} /&gt;
&lt;input on:keyup={handleKeyUp} /&gt;
&lt;input on:keypress={handleKeyPress} /&gt;

&lt;!-- Form events --&gt;
&lt;input on:input={handleInput} /&gt;
&lt;input on:change={handleChange} /&gt;
&lt;input on:focus={handleFocus} /&gt;
&lt;input on:blur={handleBlur} /&gt;
&lt;form on:submit={handleSubmit}&gt;...&lt;/form&gt;

&lt;!-- Other events --&gt;
&lt;div on:scroll={handleScroll}&gt;...&lt;/div&gt;
&lt;img on:load={handleLoad} on:error={handleError} /&gt;
</code></pre>
    <br/><br/>



    <li>DOM Event Handling (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use standard HTML attribute syntax:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);

    function handleClick(): void {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 5 event syntax --&gt;
&lt;button onclick={handleClick}&gt;Click&lt;/button&gt;
&lt;div ondblclick={handleDoubleClick}&gt;Double click&lt;/div&gt;
&lt;input onkeydown={handleKeyDown} /&gt;
&lt;input oninput={handleInput} /&gt;
&lt;form onsubmit={handleSubmit}&gt;...&lt;/form&gt;
</code></pre>
    <br/><br/>



    <li>Inline Event Handlers</li>
    <br/>
    <ul>
        <li>You can define handlers inline using arrow functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let message: string = $state("");
&lt;/script&gt;

&lt;!-- Svelte 5 syntax --&gt;
&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;
&lt;button onclick={() =&gt; count = 0}&gt;Reset&lt;/button&gt;
&lt;button onclick={() =&gt; alert("Hello!")}&gt;Alert&lt;/button&gt;

&lt;input oninput={(e) =&gt; message = e.currentTarget.value} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 4 syntax --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increment&lt;/button&gt;
&lt;button on:click={() =&gt; count = 0}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>The Event Object</li>
    <br/>
    <ul>
        <li>Event handlers receive the native DOM event object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function handleClick(event: MouseEvent): void {
        console.log("Clicked at:", event.clientX, event.clientY);
        console.log("Target:", event.target);
        console.log("Current target:", event.currentTarget);
    }

    function handleKeyDown(event: KeyboardEvent): void {
        console.log("Key pressed:", event.key);
        console.log("Key code:", event.code);
        if (event.key === "Enter") {
            console.log("Enter pressed!");
        }
    }

    function handleInput(event: Event): void {
        const target = event.currentTarget as HTMLInputElement;
        console.log("Input value:", target.value);
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;Click me&lt;/button&gt;
&lt;input onkeydown={handleKeyDown} /&gt;
&lt;input oninput={handleInput} /&gt;
</code></pre>
    <br/><br/>



    <li>Event Modifiers (Svelte 4)</li>
    <br/>
    <ul>
        <li>Svelte 4 provides modifiers to alter event behavior:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- preventDefault: Prevents default browser action --&gt;
&lt;form on:submit|preventDefault={handleSubmit}&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;!-- stopPropagation: Stops event from bubbling up --&gt;
&lt;div on:click={handleOuter}&gt;
    &lt;button on:click|stopPropagation={handleInner}&gt;Click&lt;/button&gt;
&lt;/div&gt;

&lt;!-- once: Handler runs only once --&gt;
&lt;button on:click|once={handleClick}&gt;Click once&lt;/button&gt;

&lt;!-- capture: Use capture phase instead of bubble --&gt;
&lt;div on:click|capture={handleClick}&gt;...&lt;/div&gt;

&lt;!-- self: Only trigger if event.target is the element itself --&gt;
&lt;div on:click|self={handleClick}&gt;
    &lt;button&gt;Clicking here won't trigger parent&lt;/button&gt;
&lt;/div&gt;

&lt;!-- passive: Improves scroll performance --&gt;
&lt;div on:scroll|passive={handleScroll}&gt;...&lt;/div&gt;

&lt;!-- nonpassive: Explicitly not passive --&gt;
&lt;div on:touchstart|nonpassive={handleTouch}&gt;...&lt;/div&gt;

&lt;!-- trusted: Only trigger for user-initiated events --&gt;
&lt;button on:click|trusted={handleClick}&gt;...&lt;/button&gt;
</code></pre>

    <ul>
        <li>Modifiers can be chained:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;form on:submit|preventDefault|stopPropagation={handleSubmit}&gt;
    ...
&lt;/form&gt;

&lt;button on:click|once|capture={handleClick}&gt;...&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Event Modifiers (Svelte 5)</li>
    <br/>
    <ul>
        <li>Svelte 5 doesn't have the modifier syntax. Use standard JavaScript instead:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function handleSubmit(event: SubmitEvent): void {
        event.preventDefault();
        // Handle form submission
    }

    function handleInnerClick(event: MouseEvent): void {
        event.stopPropagation();
        // Handle click
    }
&lt;/script&gt;

&lt;form onsubmit={handleSubmit}&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;div onclick={handleOuter}&gt;
    &lt;button onclick={handleInnerClick}&gt;Click&lt;/button&gt;
&lt;/div&gt;
</code></pre>

    <ul>
        <li>For <code>once</code>, use a wrapper or state:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let clicked: boolean = $state(false);

    function handleOnce(): void {
        if (clicked) return;
        clicked = true;
        console.log("This runs only once");
    }
&lt;/script&gt;

&lt;button onclick={handleOnce}&gt;Click once&lt;/button&gt;
</code></pre>

    <ul>
        <li>For <code>capture</code> and <code>passive</code>, use <code>onclickcapture</code> or handle in <code>$effect</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Capture phase --&gt;
&lt;div onclickcapture={handleClick}&gt;...&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Component Events (Svelte 4)</li>
    <br/>
    <ul>
        <li>Components can dispatch custom events to their parent using <code>createEventDispatcher</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import { createEventDispatcher } from "svelte";

    const dispatch = createEventDispatcher&lt;{
        click: void;
        customEvent: { message: string };
    }&gt;();

    function handleClick(): void {
        dispatch("click");
        dispatch("customEvent", { message: "Hello from child!" });
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";

    function handleCustomEvent(event: CustomEvent&lt;{ message: string }&gt;): void {
        console.log(event.detail.message);
    }
&lt;/script&gt;

&lt;Button on:click={() =&gt; console.log("Clicked!")} on:customEvent={handleCustomEvent}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Component Events (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <u>callback props</u> instead of <code>createEventDispatcher</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        onclick?: () =&gt; void;
        onCustomEvent?: (data: { message: string }) =&gt; void;
        children?: any;
    }

    let { onclick, onCustomEvent, children }: Props = $props();

    function handleClick(): void {
        onclick?.();
        onCustomEvent?.({ message: "Hello from child!" });
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;
    {@render children?.()}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";

    function handleCustomEvent(data: { message: string }): void {
        console.log(data.message);
    }
&lt;/script&gt;

&lt;Button onclick={() =&gt; console.log("Clicked!")} onCustomEvent={handleCustomEvent}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Event Forwarding (Svelte 4)</li>
    <br/>
    <ul>
        <li>Forward DOM events from a child element without handling them:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    export let variant: string = "primary";
&lt;/script&gt;

&lt;!-- Forward click event to parent --&gt;
&lt;button class="btn btn-{variant}" on:click&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button on:click={() =&gt; console.log("Button clicked!")}&gt;
    Click me
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>The <code>on:click</code> without a value forwards the event.</li>
        <br/>
        <li>Forward multiple events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input
    on:input
    on:change
    on:focus
    on:blur
    on:keydown
/&gt;
</code></pre>
    <br/><br/>



    <li>Event Forwarding (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use rest props to forward events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: string;
    }

    let { variant = "primary", children, ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    {@render children?.()}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button onclick={() =&gt; console.log("Clicked!")} onmouseenter={() =&gt; console.log("Hovered!")}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Typed Custom Events (Svelte 4)</li>
    <br/>
    <ul>
        <li>Strongly type custom events with generics:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchBox.svelte --&gt;
&lt;script lang="ts"&gt;
    import { createEventDispatcher } from "svelte";

    interface SearchEvents {
        search: string;
        clear: void;
        select: { id: number; label: string };
    }

    const dispatch = createEventDispatcher&lt;SearchEvents&gt;();

    let query: string = "";

    function handleSearch(): void {
        dispatch("search", query);
    }

    function handleClear(): void {
        query = "";
        dispatch("clear");
    }

    function handleSelect(id: number, label: string): void {
        dispatch("select", { id, label });
    }
&lt;/script&gt;

&lt;input bind:value={query} on:input={handleSearch} /&gt;
&lt;button on:click={handleClear}&gt;Clear&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import SearchBox from "./SearchBox.svelte";

    function onSearch(event: CustomEvent&lt;string&gt;): void {
        console.log("Searching for:", event.detail);
    }

    function onClear(): void {
        console.log("Search cleared");
    }

    function onSelect(event: CustomEvent&lt;{ id: number; label: string }&gt;): void {
        console.log("Selected:", event.detail.id, event.detail.label);
    }
&lt;/script&gt;

&lt;SearchBox on:search={onSearch} on:clear={onClear} on:select={onSelect} /&gt;
</code></pre>
    <br/><br/>



    <li>Typed Callback Props (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, callbacks are naturally typed:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchBox.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        onSearch?: (query: string) =&gt; void;
        onClear?: () =&gt; void;
        onSelect?: (item: { id: number; label: string }) =&gt; void;
    }

    let { onSearch, onClear, onSelect }: Props = $props();

    let query: string = $state("");

    function handleInput(): void {
        onSearch?.(query);
    }

    function handleClear(): void {
        query = "";
        onClear?.();
    }
&lt;/script&gt;

&lt;input bind:value={query} oninput={handleInput} /&gt;
&lt;button onclick={handleClear}&gt;Clear&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import SearchBox from "./SearchBox.svelte";

    function handleSearch(query: string): void {
        console.log("Searching for:", query);
    }

    function handleSelect(item: { id: number; label: string }): void {
        console.log("Selected:", item.id, item.label);
    }
&lt;/script&gt;

&lt;SearchBox onSearch={handleSearch} onClear={() =&gt; console.log("Cleared")} onSelect={handleSelect} /&gt;
</code></pre>
    <br/><br/>



    <li>Handling Window and Document Events</li>
    <br/>
    <ul>
        <li>Use <code>&lt;svelte:window&gt;</code> and <code>&lt;svelte:document&gt;</code> for global events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);

    function handleKeyDown(event: KeyboardEvent): void {
        if (event.key === "Escape") {
            console.log("Escape pressed!");
        }
    }

    function handleVisibilityChange(): void {
        console.log("Visibility:", document.visibilityState);
    }
&lt;/script&gt;

&lt;!-- Window events --&gt;
&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    onkeydown={handleKeyDown}
    onresize={() =&gt; console.log("Resized!")}
/&gt;

&lt;!-- Document events --&gt;
&lt;svelte:document onvisibilitychange={handleVisibilityChange} /&gt;

&lt;p&gt;Window size: {innerWidth} x {innerHeight}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Handling Body Events</li>
    <br/>
    <ul>
        <li>Use <code>&lt;svelte:body&gt;</code> for body-level events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let mouseX: number = $state(0);
    let mouseY: number = $state(0);

    function handleMouseMove(event: MouseEvent): void {
        mouseX = event.clientX;
        mouseY = event.clientY;
    }
&lt;/script&gt;

&lt;svelte:body onmousemove={handleMouseMove} /&gt;

&lt;p&gt;Mouse position: {mouseX}, {mouseY}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Syntax Comparison</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>DOM event</td>
            <td><code>on:click={handler}</code></td>
            <td><code>onclick={handler}</code></td>
        </tr>
        <tr>
            <td>Inline handler</td>
            <td><code>on:click={() => ...}</code></td>
            <td><code>onclick={() => ...}</code></td>
        </tr>
        <tr>
            <td>Modifiers</td>
            <td><code>on:click|preventDefault</code></td>
            <td><code>event.preventDefault()</code></td>
        </tr>
        <tr>
            <td>Event forwarding</td>
            <td><code>on:click</code> (no value)</td>
            <td><code>{...rest}</code> spread</td>
        </tr>
        <tr>
            <td>Component events</td>
            <td><code>createEventDispatcher</code></td>
            <td>Callback props</td>
        </tr>
        <tr>
            <td>Listen to component</td>
            <td><code>on:customEvent={handler}</code></td>
            <td><code>onCustomEvent={handler}</code></td>
        </tr>
        <tr>
            <td>Capture phase</td>
            <td><code>on:click|capture</code></td>
            <td><code>onclickcapture</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-bindings">Svelte Bindings</h3>
<ol>
    <li>What Are Bindings?</li>
    <br/>
    <ul>
        <li><b>Bindings</b> create a <u>two-way connection</u> between a variable and an element property or component prop.</li>
        <br/>
        <li>When the variable changes, the element updates. When the element changes (e.g., user input), the variable updates.</li>
        <br/>
        <li>Svelte uses the <code>bind:</code> directive for bindings.</li>
    </ul>
    <br/><br/>



    <li>Basic Input Binding</li>
    <br/>
    <ul>
        <li>Bind an input's value to a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let name: string = $state("");
&lt;/script&gt;

&lt;input type="text" bind:value={name} /&gt;
&lt;p&gt;Hello, {name || "stranger"}!&lt;/p&gt;
</code></pre>

    <ul>
        <li>Typing in the input automatically updates <code>name</code>.</li>
        <li>Changing <code>name</code> programmatically updates the input.</li>
    </ul>
    <br/><br/>



    <li>Text Input Types</li>
    <br/>
    <ul>
        <li>Works with various text input types:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let text: string = $state("");
    let email: string = $state("");
    let password: string = $state("");
    let search: string = $state("");
    let url: string = $state("");
    let tel: string = $state("");
&lt;/script&gt;

&lt;input type="text" bind:value={text} /&gt;
&lt;input type="email" bind:value={email} /&gt;
&lt;input type="password" bind:value={password} /&gt;
&lt;input type="search" bind:value={search} /&gt;
&lt;input type="url" bind:value={url} /&gt;
&lt;input type="tel" bind:value={tel} /&gt;
</code></pre>
    <br/><br/>



    <li>Numeric Input Binding</li>
    <br/>
    <ul>
        <li>For <code>type="number"</code> and <code>type="range"</code>, the value is automatically coerced to a number:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let quantity: number = $state(1);
    let volume: number = $state(50);
&lt;/script&gt;

&lt;input type="number" bind:value={quantity} min="0" max="100" /&gt;
&lt;p&gt;Quantity: {quantity} (type: {typeof quantity})&lt;/p&gt;

&lt;input type="range" bind:value={volume} min="0" max="100" /&gt;
&lt;p&gt;Volume: {volume}%&lt;/p&gt;
</code></pre>

    <ul>
        <li>The bound variable will be a <code>number</code>, not a string.</li>
    </ul>
    <br/><br/>



    <li>Checkbox Binding</li>
    <br/>
    <ul>
        <li>For checkboxes, bind to <code>checked</code> instead of <code>value</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let agreed: boolean = $state(false);
    let subscribed: boolean = $state(true);
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={agreed} /&gt;
    I agree to the terms
&lt;/label&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={subscribed} /&gt;
    Subscribe to newsletter
&lt;/label&gt;

&lt;p&gt;Agreed: {agreed}, Subscribed: {subscribed}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Checkbox Group Binding</li>
    <br/>
    <ul>
        <li>Bind multiple checkboxes to an array using <code>bind:group</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let selectedFruits: string[] = $state([]);

    const fruits: string[] = ["Apple", "Banana", "Cherry", "Mango"];
&lt;/script&gt;

{#each fruits as fruit}
    &lt;label&gt;
        &lt;input type="checkbox" value={fruit} bind:group={selectedFruits} /&gt;
        {fruit}
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected: {selectedFruits.join(", ") || "None"}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Checking a box adds its <code>value</code> to the array.</li>
        <li>Unchecking removes it from the array.</li>
    </ul>
    <br/><br/>



    <li>Radio Button Binding</li>
    <br/>
    <ul>
        <li>Bind radio buttons to a single value using <code>bind:group</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let selectedColor: string = $state("red");

    const colors: string[] = ["red", "green", "blue"];
&lt;/script&gt;

{#each colors as color}
    &lt;label&gt;
        &lt;input type="radio" value={color} bind:group={selectedColor} /&gt;
        {color}
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected color: {selectedColor}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Only one radio button in a group can be selected at a time.</li>
    </ul>
    <br/><br/>



    <li>Radio Button with Objects</li>
    <br/>
    <ul>
        <li>Radio buttons can bind to object references:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Plan {
        id: string;
        name: string;
        price: number;
    }

    const plans: Plan[] = [
        { id: "basic",      name: "Basic",      price: 9.99  },
        { id: "pro",        name: "Pro",        price: 19.99 },
        { id: "enterprise", name: "Enterprise", price: 49.99 }
    ];

    let selectedPlan: Plan = $state(plans[0]);
&lt;/script&gt;

{#each plans as plan}
    &lt;label&gt;
        &lt;input type="radio" value={plan} bind:group={selectedPlan} /&gt;
        {plan.name} - ${plan.price}/month
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected: {selectedPlan.name} at ${selectedPlan.price}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Select Dropdown Binding</li>
    <br/>
    <ul>
        <li>Bind a <code>&lt;select&gt;</code> element to a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const selectedCountry: string = $state("");

    const countries: string[] = ["USA", "Canada", "UK", "Germany", "Japan"];
&lt;/script&gt;

&lt;select bind:value={selectedCountry}&gt;
    &lt;option value=""&gt;Select a country&lt;/option&gt;
    {#each countries as country}
        &lt;option value={country}&gt;{country}&lt;/option&gt;
    {/each}
&lt;/select&gt;

&lt;p&gt;Selected: {selectedCountry || "None"}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Select with Objects</li>
    <br/>
    <ul>
        <li>Select elements can bind to object values:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Country {
        code: string;
        name: string;
        population: number;
    }

    const countries: Country[] = [
        { code: "US", name: "United States", population: 331000000 },
        { code: "JP", name: "Japan",         population: 125800000 },
        { code: "DE", name: "Germany",       population: 83200000 }
    ];

    const selectedCountry: Country | undefined = $state(undefined);
&lt;/script&gt;

&lt;select bind:value={selectedCountry}&gt;
    &lt;option value={undefined}&gt;Select a country&lt;/option&gt;
    {#each countries as country}
        &lt;option value={country}&gt;{country.name}&lt;/option&gt;
    {/each}
&lt;/select&gt;

{#if selectedCountry}
    &lt;p&gt;{selectedCountry.name}: {selectedCountry.population.toLocaleString()} people&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Multiple Select Binding</li>
    <br/>
    <ul>
        <li>Bind a multi-select to an array:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const selectedSkills: string[] = $state([]);

    const skills: string[] = ["JavaScript", "TypeScript", "Python", "Rust", "Go"];
&lt;/script&gt;

&lt;select multiple bind:value={selectedSkills}&gt;
    {#each skills as skill}
        &lt;option value={skill}&gt;{skill}&lt;/option&gt;
    {/each}
&lt;/select&gt;

&lt;p&gt;Selected: {selectedSkills.join(", ") || "None"}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Hold Ctrl/Cmd to select multiple options.</li>
    </ul>
    <br/><br/>



    <li>Textarea Binding</li>
    <br/>
    <ul>
        <li>Bind a textarea's content:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const bio: string = $state("");
&lt;/script&gt;

&lt;textarea bind:value={bio} rows="4" cols="50"&gt;&lt;/textarea&gt;

&lt;p&gt;Character count: {bio.length}&lt;/p&gt;
&lt;p&gt;Preview:&lt;/p&gt;
&lt;pre&gt;{bio}&lt;/pre&gt;
</code></pre>
    <br/><br/>



    <li>Contenteditable Binding</li>
    <br/>
    <ul>
        <li>Bind to <code>contenteditable</code> elements using <code>textContent</code> or <code>innerHTML</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let plainText: string = $state("Edit this text");
    let richText: string = $state("&lt;b&gt;Bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt;");
&lt;/script&gt;

&lt;!-- Plain text binding --&gt;
&lt;div contenteditable="true" bind:textContent={plainText}&gt;&lt;/div&gt;
&lt;p&gt;Plain: {plainText}&lt;/p&gt;

&lt;!-- HTML binding --&gt;
&lt;div contenteditable="true" bind:innerHTML={richText}&gt;&lt;/div&gt;
&lt;p&gt;HTML: {richText}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>bind:textContent</code> — Gets/sets plain text only.</li>
        <li><code>bind:innerHTML</code> — Gets/sets HTML content.</li>
    </ul>
    <br/><br/>



    <li>Element Reference Binding (<code>bind:this</code>)</li>
    <br/>
    <ul>
        <li>Get a reference to a DOM element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { onMount } from "svelte";

    let inputElement: HTMLInputElement;
    let canvasElement: HTMLCanvasElement;

    onMount(() =&gt; {
        // Focus the input on mount
        inputElement.focus();

        // Draw on canvas
        const ctx = canvasElement.getContext("2d");
        if (ctx) {
            ctx.fillStyle = "blue";
            ctx.fillRect(10, 10, 100, 100);
        }
    });
&lt;/script&gt;

&lt;input bind:this={inputElement} placeholder="Auto-focused" /&gt;
&lt;canvas bind:this={canvasElement} width="200" height="150"&gt;&lt;/canvas&gt;
</code></pre>

    <ul>
        <li>The element is <code>undefined</code> until the component mounts.</li>
        <li>Use <code>onMount</code> or <code>$effect</code> to safely access the element.</li>
    </ul>
    <br/><br/>



    <li>Element Reference with Svelte 5</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <code>$effect</code> to work with element references:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let inputElement: HTMLInputElement | undefined = $state(undefined);

    $effect(() =&gt; {
        if (inputElement) {
            inputElement.focus();
        }
    });
&lt;/script&gt;

&lt;input bind:this={inputElement} placeholder="Auto-focused" /&gt;
</code></pre>
    <br/><br/>



    <li>Dimension Bindings</li>
    <br/>
    <ul>
        <li>Bind to an element's dimensions (read-only):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let clientWidth: number = $state(0);
    let clientHeight: number = $state(0);
    let offsetWidth: number = $state(0);
    let offsetHeight: number = $state(0);
&lt;/script&gt;

&lt;div
    bind:clientWidth
    bind:clientHeight
    bind:offsetWidth
    bind:offsetHeight
    style="padding: 20px; border: 5px solid black;"
&gt;
    &lt;p&gt;Resize the window to see changes&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Client: {clientWidth} x {clientHeight}&lt;/p&gt;
&lt;p&gt;Offset: {offsetWidth} x {offsetHeight}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>clientWidth/Height</code> — Content + padding (excluding border and scrollbar).</li>
        <li><code>offsetWidth/Height</code> — Content + padding + border.</li>
    </ul>
    <br/><br/>



    <li>Media Element Bindings</li>
    <br/>
    <ul>
        <li>Bind to audio and video element properties:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let videoElement: HTMLVideoElement;

    // Readonly bindings
    let duration: number = $state(0);
    let buffered: TimeRanges;
    let seekable: TimeRanges;
    let played: TimeRanges;
    let seeking: boolean = $state(false);
    let ended: boolean = $state(false);
    let readyState: number = $state(0);
    let videoWidth: number = $state(0);
    let videoHeight: number = $state(0);

    // Two-way bindings
    let currentTime: number = $state(0);
    let playbackRate: number = $state(1);
    let paused: boolean = $state(true);
    let volume: number = $state(1);
    let muted: boolean = $state(false);

    function formatTime(seconds: number): string {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
    }
&lt;/script&gt;

&lt;video
    bind:this={videoElement}
    bind:duration
    bind:currentTime
    bind:paused
    bind:volume
    bind:muted
    bind:playbackRate
    bind:seeking
    bind:ended
    src="video.mp4"
    width="400"
&gt;
    &lt;track kind="captions" /&gt;
&lt;/video&gt;

&lt;div&gt;
    &lt;button onclick={() =&gt; paused = !paused}&gt;
        {paused ? "Play" : "Pause"}
    &lt;/button&gt;
    &lt;span&gt;{formatTime(currentTime)} / {formatTime(duration)}&lt;/span&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;label&gt;
        Volume:
        &lt;input type="range" bind:value={volume} min="0" max="1" step="0.1" /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        &lt;input type="checkbox" bind:checked={muted} /&gt;
        Muted
    &lt;/label&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;label&gt;
        Speed:
        &lt;select bind:value={playbackRate}&gt;
            &lt;option value={0.5}&gt;0.5x&lt;/option&gt;
            &lt;option value={1}&gt;1x&lt;/option&gt;
            &lt;option value={1.5}&gt;1.5x&lt;/option&gt;
            &lt;option value={2}&gt;2x&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Window Bindings</li>
    <br/>
    <ul>
        <li>Bind to window properties using <code>&lt;svelte:window&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Readonly
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);
    let outerWidth: number = $state(0);
    let outerHeight: number = $state(0);
    let online: boolean = $state(true);

    // Two-way
    let scrollX: number = $state(0);
    let scrollY: number = $state(0);
&lt;/script&gt;

&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    bind:outerWidth
    bind:outerHeight
    bind:scrollX
    bind:scrollY
    bind:online
/&gt;

&lt;div style="position: fixed; top: 10px; right: 10px; background: white; padding: 10px;"&gt;
    &lt;p&gt;Window: {innerWidth} x {innerHeight}&lt;/p&gt;
    &lt;p&gt;Scroll: {scrollX}, {scrollY}&lt;/p&gt;
    &lt;p&gt;Online: {online ? "Yes" : "No"}&lt;/p&gt;
&lt;/div&gt;

&lt;button onclick={() =&gt; scrollY = 0}&gt;Scroll to top&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Document Bindings</li>
    <br/>
    <ul>
        <li>Bind to document properties using <code>&lt;svelte:document&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let activeElement: Element | null = $state(null);
    let fullscreenElement: Element | null = $state(null);
    let pointerLockElement: Element | null = $state(null);
    let visibilityState: DocumentVisibilityState = $state("visible");
&lt;/script&gt;

&lt;svelte:document
    bind:activeElement
    bind:fullscreenElement
    bind:pointerLockElement
    bind:visibilityState
/&gt;

&lt;p&gt;Active element: {activeElement?.tagName || "None"}&lt;/p&gt;
&lt;p&gt;Visibility: {visibilityState}&lt;/p&gt;

&lt;input placeholder="Focus me" /&gt;
&lt;button&gt;Or focus me&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Component Bindings</li>
    <br/>
    <ul>
        <li>Bind to a child component's exported values (Svelte 4):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let count: number = 0;

    export function reset(): void {
        count = 0;
    }
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;{count}&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let counterValue: number;
    let counterComponent: Counter;
&lt;/script&gt;

&lt;Counter bind:count={counterValue} bind:this={counterComponent} /&gt;

&lt;p&gt;Counter value: {counterValue}&lt;/p&gt;
&lt;button on:click={() =&gt; counterComponent.reset()}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Component Bindings (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <code>$bindable</code> for props that can be bound:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        count?: number;
    }

    let { count = $bindable(0) }: Props = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;{count}&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let counterValue: number = $state(0);
&lt;/script&gt;

&lt;Counter bind:count={counterValue} /&gt;

&lt;p&gt;Counter value: {counterValue}&lt;/p&gt;
&lt;button onclick={() =&gt; counterValue = 0}&gt;Reset&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$bindable()</code> marks a prop as bindable with an optional default value.</li>
        <li>Changes in either parent or child sync both ways.</li>
    </ul>
    <br/><br/>



    <li>Binding Shorthand</li>
    <br/>
    <ul>
        <li>When the variable name matches the property name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let value: string = $state("");
    let checked: boolean = $state(false);
    let clientWidth: number = $state(0);
    let innerWidth: number = $state(0);
&lt;/script&gt;

&lt;!-- These are equivalent: --&gt;
&lt;input bind:value={value} /&gt;
&lt;input bind:value /&gt;

&lt;input type="checkbox" bind:checked={checked} /&gt;
&lt;input type="checkbox" bind:checked /&gt;

&lt;div bind:clientWidth={clientWidth}&gt;...&lt;/div&gt;
&lt;div bind:clientWidth&gt;...&lt;/div&gt;

&lt;svelte:window bind:innerWidth={innerWidth} /&gt;
&lt;svelte:window bind:innerWidth /&gt;
</code></pre>
    <br/><br/>



    <li>Binding Summary</li>
    <br/>

    <table>
        <tr>
            <th>Element</th>
            <th>Binding</th>
            <th>Type</th>
        </tr>
        <tr>
            <td>Text input</td>
            <td><code>bind:value</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Number/Range input</td>
            <td><code>bind:value</code></td>
            <td><code>number</code></td>
        </tr>
        <tr>
            <td>Checkbox</td>
            <td><code>bind:checked</code></td>
            <td><code>boolean</code></td>
        </tr>
        <tr>
            <td>Checkbox group</td>
            <td><code>bind:group</code></td>
            <td><code>Array</code></td>
        </tr>
        <tr>
            <td>Radio group</td>
            <td><code>bind:group</code></td>
            <td>Single value</td>
        </tr>
        <tr>
            <td>Select</td>
            <td><code>bind:value</code></td>
            <td>Any</td>
        </tr>
        <tr>
            <td>Multi-select</td>
            <td><code>bind:value</code></td>
            <td><code>Array</code></td>
        </tr>
        <tr>
            <td>Textarea</td>
            <td><code>bind:value</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Contenteditable</td>
            <td><code>bind:textContent</code>, <code>bind:innerHTML</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Any element</td>
            <td><code>bind:this</code></td>
            <td><code>HTMLElement</code></td>
        </tr>
        <tr>
            <td>Any element</td>
            <td><code>bind:clientWidth</code>, etc.</td>
            <td><code>number</code> (readonly)</td>
        </tr>
        <tr>
            <td>Audio/Video</td>
            <td><code>bind:currentTime</code>, <code>bind:paused</code>, etc.</td>
            <td>Various</td>
        </tr>
        <tr>
            <td><code>&lt;svelte:window&gt;</code></td>
            <td><code>bind:innerWidth</code>, <code>bind:scrollY</code>, etc.</td>
            <td><code>number</code></td>
        </tr>
        <tr>
            <td>Component (Svelte 5)</td>
            <td><code>bind:prop</code> with <code>$bindable</code></td>
            <td>Any</td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-classes">Svelte Classes</h3>
<ol>
    <li>What Are Class Directives?</li>
    <br/>
    <ul>
        <li>Svelte provides special syntax for dynamically adding and removing CSS classes.</li>
        <br/>
        <li>The <code>class:</code> directive conditionally applies a class based on a boolean expression.</li>
        <br/>
        <li>This is cleaner than manually building class strings.</li>
    </ul>
    <br/><br/>



    <li>Basic Class Attribute</li>
    <br/>
    <ul>
        <li>You can use the standard <code>class</code> attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let className: string = "button primary";
&lt;/script&gt;

&lt;button class="button"&gt;Static class&lt;/button&gt;
&lt;button class={className}&gt;Dynamic class&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Conditional Classes with Ternary</li>
    <br/>
    <ul>
        <li>Use template expressions to conditionally apply classes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(false);
    let isDisabled: boolean = $state(false);
&lt;/script&gt;

&lt;button class={isActive ? "active" : ""}&gt;
    Toggle
&lt;/button&gt;

&lt;button class={isActive ? "btn active" : "btn"}&gt;
    With base class
&lt;/button&gt;

&lt;button class="btn {isActive ? 'active' : ''} {isDisabled ? 'disabled' : ''}"&gt;
    Multiple conditions
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This works but can become verbose with multiple conditions.</li>
    </ul>
    <br/><br/>



    <li>The <code>class:</code> Directive</li>
    <br/>
    <ul>
        <li>The <code>class:</code> directive provides a cleaner syntax:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(false);
&lt;/script&gt;

&lt;button class:active={isActive}&gt;
    Toggle
&lt;/button&gt;

&lt;!-- The class "active" is added when isActive is true --&gt;

&lt;style&gt;
    .active {
        background-color: #4CAF50;
        color: white;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li>Syntax: <code>class:classname={condition}</code></li>
        <li>When <code>condition</code> is truthy, <code>classname</code> is added.</li>
    </ul>
    <br/><br/>



    <li>Shorthand <code>class:</code> Directive</li>
    <br/>
    <ul>
        <li>When the class name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let active: boolean = $state(false);
    let disabled: boolean = $state(false);
    let hidden: boolean = $state(false);
&lt;/script&gt;

&lt;!-- These are equivalent: --&gt;
&lt;button class:active={active}&gt;Long form&lt;/button&gt;
&lt;button class:active&gt;Shorthand&lt;/button&gt;

&lt;!-- Multiple shorthand classes --&gt;
&lt;button class:active class:disabled class:hidden&gt;
    Multiple
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Multiple Class Directives</li>
    <br/>
    <ul>
        <li>Apply multiple conditional classes to one element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(true);
    let isLarge: boolean = $state(false);
    let isPrimary: boolean = $state(true);
    let isDisabled: boolean = $state(false);
&lt;/script&gt;

&lt;button
    class="btn"
    class:active={isActive}
    class:large={isLarge}
    class:primary={isPrimary}
    class:disabled={isDisabled}
&gt;
    Styled Button
&lt;/button&gt;

&lt;style&gt;
    .btn {
        padding: 10px 20px;
        border: none;
        cursor: pointer;
    }
    .active { border: 2px solid blue; }
    .large { font-size: 1.5rem; padding: 15px 30px; }
    .primary { background-color: #007bff; color: white; }
    .disabled { opacity: 0.5; cursor: not-allowed; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Combining <code>class</code> and <code>class:</code></li>
    <br/>
    <ul>
        <li>Use both static classes and conditional class directives together:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let variant: string = $state("primary");
    let isLoading: boolean = $state(false);
    let isFullWidth: boolean = $state(false);
&lt;/script&gt;

&lt;button
    class="btn btn-{variant}"
    class:loading={isLoading}
    class:full-width={isFullWidth}
&gt;
    {isLoading ? "Loading..." : "Submit"}
&lt;/button&gt;

&lt;style&gt;
    .btn { padding: 10px 20px; }
    .btn-primary { background: blue; color: white; }
    .btn-secondary { background: gray; color: white; }
    .btn-danger { background: red; color: white; }
    .loading { opacity: 0.7; pointer-events: none; }
    .full-width { width: 100%; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Directive with Expressions</li>
    <br/>
    <ul>
        <li>The condition can be any JavaScript expression:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let status: string = $state("pending");
    let items: string[] = $state(["a", "b"]);
&lt;/script&gt;

&lt;!-- Comparison expressions --&gt;
&lt;div class:warning={count &gt; 5}&gt;Count warning&lt;/div&gt;
&lt;div class:danger={count &gt; 10}&gt;Count danger&lt;/div&gt;

&lt;!-- Equality checks --&gt;
&lt;div class:success={status === "completed"}&gt;Status&lt;/div&gt;
&lt;div class:pending={status === "pending"}&gt;Status&lt;/div&gt;

&lt;!-- Array/Object checks --&gt;
&lt;div class:empty={items.length === 0}&gt;Items&lt;/div&gt;
&lt;div class:has-items={items.length &gt; 0}&gt;Items&lt;/div&gt;

&lt;!-- Logical expressions --&gt;
&lt;div class:special={count &gt; 5 && status === "completed"}&gt;
    Special
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Dynamic Class Names</li>
    <br/>
    <ul>
        <li>Build class names dynamically using template literals:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let size: "sm" | "md" | "lg" = $state("md");
    let color: "red" | "green" | "blue" = $state("blue");
    let theme: "light" | "dark" = $state("light");
&lt;/script&gt;

&lt;button class="btn btn-{size} btn-{color}"&gt;
    Dynamic Size &amp; Color
&lt;/button&gt;

&lt;div class="container theme-{theme}"&gt;
    Themed Container
&lt;/div&gt;

&lt;!-- With conditional fallback --&gt;
&lt;div class="icon icon-{status || 'default'}"&gt;
    Icon
&lt;/div&gt;

&lt;style&gt;
    .btn-sm { padding: 5px 10px; font-size: 0.8rem; }
    .btn-md { padding: 10px 20px; font-size: 1rem; }
    .btn-lg { padding: 15px 30px; font-size: 1.2rem; }
    .btn-red { background: red; }
    .btn-green { background: green; }
    .btn-blue { background: blue; }
    .theme-light { background: white; color: black; }
    .theme-dark { background: #333; color: white; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Object Pattern</li>
    <br/>
    <ul>
        <li>Create a utility function for complex class logic:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Utility function to build class string from object
    function classNames(classes: Record&lt;string, boolean&gt;): string {
        return Object.entries(classes)
            .filter(([, value]) =&gt; value)
            .map(([key]) =&gt; key)
            .join(" ");
    }

    let isActive: boolean = $state(true);
    let isDisabled: boolean = $state(false);
    let size: string = $state("large");

    let buttonClasses = $derived(classNames({
        "btn": true,
        "btn-active": isActive,
        "btn-disabled": isDisabled,
        "btn-large": size === "large",
        "btn-small": size === "small"
    }));
&lt;/script&gt;

&lt;button class={buttonClasses}&gt;
    Dynamic Classes
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Using <code>clsx</code> or <code>classnames</code> Library</li>
    <br/>
    <ul>
        <li>For complex class logic, use a utility library like <code>clsx</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm install clsx
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import clsx from "clsx";

    let isActive: boolean = $state(false);
    let isDisabled: boolean = $state(false);
    let variant: "primary" | "secondary" = $state("primary");

    let classes = $derived(clsx(
        "btn",
        `btn-${variant}`,
        {
            "active": isActive,
            "disabled": isDisabled
        }
    ));
&lt;/script&gt;

&lt;button class={classes}&gt;
    Using clsx
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>clsx</code> handles strings, objects, arrays, and falsy values gracefully.</li>
    </ul>
    <br/><br/>



    <li>Classes in Loops</li>
    <br/>
    <ul>
        <li>Apply conditional classes to items in a loop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Item {
        id: number;
        name: string;
        completed: boolean;
        priority: "low" | "medium" | "high";
    }

    let items: Item[] = $state([
        { id: 1, name: "Task 1", completed: false, priority: "high" },
        { id: 2, name: "Task 2", completed: true, priority: "low" },
        { id: 3, name: "Task 3", completed: false, priority: "medium" }
    ]);

    let selectedId: number | null = $state(null);
&lt;/script&gt;

&lt;ul&gt;
    {#each items as item (item.id)}
        &lt;li
            class="item priority-{item.priority}"
            class:completed={item.completed}
            class:selected={selectedId === item.id}
            onclick={() =&gt; selectedId = item.id}
        &gt;
            {item.name}
        &lt;/li&gt;
    {/each}
&lt;/ul&gt;

&lt;style&gt;
    .item { padding: 10px; cursor: pointer; }
    .completed { text-decoration: line-through; opacity: 0.6; }
    .selected { background-color: #e0e0e0; }
    .priority-low { border-left: 3px solid green; }
    .priority-medium { border-left: 3px solid orange; }
    .priority-high { border-left: 3px solid red; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Global Classes vs Scoped Classes</li>
    <br/>
    <ul>
        <li>Svelte styles are <u>scoped by default</u> — they only apply to the current component.</li>
        <br/>
        <li>Use <code>:global()</code> to apply styles globally:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isDark: boolean = $state(false);
&lt;/script&gt;

&lt;div class="container" class:dark={isDark}&gt;
    &lt;p&gt;This is styled locally.&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    /* Scoped to this component */
    .container {
        padding: 20px;
        background: white;
    }

    .dark {
        background: #333;
        color: white;
    }

    /* Global style - affects all elements */
    :global(.global-class) {
        font-weight: bold;
    }

    /* Global modifier within scoped context */
    .container :global(.highlight) {
        background-color: yellow;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Passing Classes to Child Components</li>
    <br/>
    <ul>
        <li>Accept a <code>class</code> prop to allow parent customization:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        variant?: "primary" | "secondary";
        class?: string;
    }

    let { variant = "primary", class: className = "" }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant} {className}"&gt;
    &lt;slot /&gt;
&lt;/button&gt;

&lt;style&gt;
    .btn { padding: 10px 20px; border: none; cursor: pointer; }
    .btn-primary { background: blue; color: white; }
    .btn-secondary { background: gray; color: white; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button class="my-custom-class"&gt;Click me&lt;/Button&gt;
&lt;Button variant="secondary" class="full-width"&gt;Submit&lt;/Button&gt;

&lt;style&gt;
    :global(.my-custom-class) {
        margin: 10px;
    }
    :global(.full-width) {
        width: 100%;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Using <code>$$restProps</code> for Class Forwarding (Svelte 4)</li>
    <br/>
    <ul>
        <li>Forward all attributes including <code>class</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Input.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let label: string = "";
&lt;/script&gt;

&lt;label&gt;
    {label}
    &lt;input {...$$restProps} /&gt;
&lt;/label&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Input label="Email" class="form-input" type="email" placeholder="Enter email" /&gt;
</code></pre>
    <br/><br/>



    <li>Using Rest Props for Class Forwarding (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use rest props destructuring:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Input.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    import type { HTMLInputAttributes } from "svelte/elements";

    interface Props extends HTMLInputAttributes {
        label?: string;
    }

    let { label = "", ...rest }: Props = $props();
&lt;/script&gt;

&lt;label&gt;
    {label}
    &lt;input {...rest} /&gt;
&lt;/label&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Input label="Email" class="form-input" type="email" placeholder="Enter email" /&gt;
</code></pre>
    <br/><br/>



    <li>Animated Class Transitions</li>
    <br/>
    <ul>
        <li>Combine class toggling with CSS transitions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let expanded: boolean = $state(false);
    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; expanded = !expanded}&gt;
    Toggle Expand
&lt;/button&gt;

&lt;div class="box" class:expanded&gt;
    &lt;p&gt;Content here&lt;/p&gt;
&lt;/div&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle Visibility
&lt;/button&gt;

&lt;div class="fade-box" class:visible&gt;
    &lt;p&gt;Fading content&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    .box {
        height: 50px;
        overflow: hidden;
        background: #f0f0f0;
        transition: height 0.3s ease;
    }

    .box.expanded {
        height: 200px;
    }

    .fade-box {
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .fade-box.visible {
        opacity: 1;
        transform: translateY(0);
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Directive Summary</li>
    <br/>

    <table>
        <tr>
            <th>Syntax</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><code>class="name"</code></td>
            <td>Static class</td>
            <td><code>&lt;div class="container"&gt;</code></td>
        </tr>
        <tr>
            <td><code>class={expr}</code></td>
            <td>Dynamic class string</td>
            <td><code>&lt;div class={className}&gt;</code></td>
        </tr>
        <tr>
            <td><code>class="a {b}"</code></td>
            <td>Mixed static + dynamic</td>
            <td><code>&lt;div class="btn {variant}"&gt;</code></td>
        </tr>
        <tr>
            <td><code>class:name={cond}</code></td>
            <td>Conditional class</td>
            <td><code>&lt;div class:active={isActive}&gt;</code></td>
        </tr>
        <tr>
            <td><code>class:name</code></td>
            <td>Shorthand (name === var)</td>
            <td><code>&lt;div class:active&gt;</code></td>
        </tr>
        <tr>
            <td>Multiple <code>class:</code></td>
            <td>Multiple conditionals</td>
            <td><code>&lt;div class:a class:b class:c&gt;</code></td>
        </tr>
        <tr>
            <td><code>:global()</code></td>
            <td>Escape scoping</td>
            <td><code>:global(.class) { }</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
