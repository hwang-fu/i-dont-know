<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .325rem;
        padding: .05rem .25rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.725rem;
        line-height: 1.7;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.825rem;
        line-height: 1.4;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/svelte.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#svelte-introduction">Introduction</a></li>
        <li><a href="#svelte-reactivity">Reactivity</a></li>
        <li><a href="#svelte-props">Props</a></li>
        <li><a href="#svelte-logic">Logic</a></li>
        <li><a href="#svelte-events">Events</a></li>
        <li><a href="#svelte-bindings">Bindings</a></li>
        <li><a href="#svelte-classes">Classes</a></li>
        <li><a href="#svelte-actions">Actions</a></li>
        <li><a href="#svelte-transitions">Transitions</a></li>
        <li><a href="#svelte-advanced-reactivity">Advanced Reactivity</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-introduction">Introduction to Svelte</h3>
<ol>
    <li>What Is Svelte?</li>
    <br/>
    <ul>
        <li><b>Svelte</b> is a modern, <u>compiler-based</u> JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Unlike Vue or React, Svelte shifts work from the <u>browser</u> to a <u>compile step</u> at build time, producing highly optimized vanilla JavaScript.</li>
        <br/>
        <li>Svelte's ecosystem includes:
            <ul>
                <li><code>SvelteKit</code> which is a full-stack application framework (routing, SSR, etc.)</li>
                <li><code>Svelte Stores</code> for built-in state management</li>
                <li><code>Vite</code> is the recommended build tool</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>How Svelte Works</li>
    <br/>
    <ul>
        <li>Svelte compiles your components into <u>efficient imperative code</u> that surgically updates the DOM.</li>
        <br/>
        <li>There is <u>no virtual DOM</u> — Svelte generates code that directly manipulates the DOM when state changes.</li>
        <br/>
        <li>A Svelte component contains:
            <ul>
                <li>a <code>&lt;script&gt;</code> block for JavaScript logic</li>
                <li>HTML markup (the template)</li>
                <li>an optional <code>&lt;style&gt;</code> block for scoped CSS</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let message = "Hello Svelte!";
&lt;/script&gt;

&lt;h1&gt;{message}&lt;/h1&gt;

&lt;style&gt;
    h1 {
        color: #ff3e00;
    }
&lt;/style&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{ }</code> automatically updates when <code>message</code> changes.</li>
    </ul>
    <br/><br/>



    <li>Getting Started (Project Setup)</li>
    <br/>
    <ul>
        <li>The recommended way to start a Svelte project is using <code>SvelteKit</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npx sv create my-app
cd my-app/
npm install
npm run dev
</code></pre>
    <ul>
        <li>For a simpler standalone Svelte project without it:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm create vite@latest my-app -- --template svelte
cd my-app/
npm install
npm run dev
</code></pre>
    <br/><br/>



    <li>Core Concepts of Svelte</li>

    <br/>
    <ol>
    <li>Reactivity</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is built into the language — just assign a new value to trigger updates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count += 1;  // This automatically updates the DOM
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>Use <code>$:</code> to create reactive statements that re-run when dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: console.log("Count is now", count);
&lt;/script&gt;

&lt;p&gt;{count} doubled is {doubled}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Handling</li>

<pre><code class="language-html line-numbers">&lt;button on:click={handleClick}&gt;Click me&lt;/button&gt;

&lt;!-- With inline handler --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increase&lt;/button&gt;

&lt;!-- With modifiers --&gt;
&lt;button on:click|once|preventDefault={handleClick}&gt;Submit&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>on:click</code> is Svelte's event directive syntax.</li>
        <li>Modifiers like <code>|once</code>, <code>|preventDefault</code>, <code>|stopPropagation</code> can be chained.</li>
    </ul>
    <br/><br/>



    <li>Two-Way Binding with <code>bind:</code></li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "";
&lt;/script&gt;

&lt;input bind:value={name} /&gt;
&lt;p&gt;Hello {name}!&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>
    <br/><br/>



    <li>Conditionals and Loops</li>
<pre><code class="language-html line-numbers">&lt;!-- Conditionals --&gt;
{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}

&lt;!-- Loops --&gt;
{#each items as item, index (item.id)}
    &lt;li&gt;{index}: {item.name}&lt;/li&gt;
{/each}
</code></pre>
    <ul>
        <li><code>{#if}</code>, <code>{:else}</code>, <code>{/if}</code> are Svelte's conditional blocks.</li>
        <li><code>{#each}</code> iterates over arrays; the <code>(item.id)</code> part is a keyed each block for efficient updates.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Component Structure</li>
    <br/>
    <ul>
        <li>Svelte components are stored in <code>.svelte</code> files.</li>
        <li>Each file is a single component with script, markup, and styles together.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name = "World";
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;

&lt;style&gt;
    h1 {
        font-family: Georgia, serif;
        color: #333;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>export let</code> declares a <u>prop</u> that can be passed from parent components.</li>
        <li>Styles are <u>scoped by default</u>, they only affect this component.</li>
    </ul>
    <br/><br/>



    <li>Using Components</li>
    <br/>
    <ul>
        <li>Import and use components like regular ES modules:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Svelte" /&gt;
&lt;Greeting /&gt;  &lt;!-- Uses default "World" --&gt;
</code></pre>
    <br/><br/>



    <li>Key Differences from Other Frameworks</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte</th>
            <th>Vue / React</th>
        </tr>
        <tr>
            <td>Compilation</td>
            <td>Compiles to vanilla JS at build time</td>
            <td>Ships a runtime library to the browser</td>
        </tr>
        <tr>
            <td>Virtual DOM</td>
            <td>No virtual DOM</td>
            <td>Uses virtual DOM for diffing</td>
        </tr>
        <tr>
            <td>Reactivity</td>
            <td>Built into the language (<code>$:</code>)</td>
            <td>Requires hooks or reactive APIs</td>
        </tr>
        <tr>
            <td>Bundle Size</td>
            <td>Typically smaller</td>
            <td>Includes framework runtime</td>
        </tr>
        <tr>
            <td>Learning Curve</td>
            <td>Closer to vanilla HTML/CSS/JS</td>
            <td>Framework-specific patterns</td>
        </tr>
    </table>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduced <u>Runes</u>, a new reactivity system using special functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);

    function increment() {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    {count} × 2 = {doubled}
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$state()</code> creates reactive state.</li>
        <li><code>$derived()</code> creates computed values.</li>
        <li><code>$effect()</code> runs side effects when dependencies change.</li>
        <li>Note: In Svelte 5, event handlers use <code>onclick</code> instead of <code>on:click</code>.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-reactivity">Svelte Reactivity</h3>
<ol>
    <li>What Is Reactivity in Svelte?</li>
    <br/>
    <ul>
        <li><b>Reactivity</b> means that when your data changes, the UI automatically updates to reflect those changes.</li>
        <br/>
        <li>In Svelte, reactivity is <u>built into the language</u> — you don't need special APIs or hooks.</li>
        <br/>
        <li>Svelte's compiler analyzes your code and generates efficient JavaScript that updates the DOM only where necessary.</li>
    </ul>
    <br/><br/>



    <li>Assignment-Based Reactivity</li>
    <br/>
    <ul>
        <li>In Svelte, <u>assignments</u> trigger reactivity. Simply reassigning a variable updates the DOM.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    function increment() {
        count = count + 1;  // Assignment triggers update
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This also works with shorthand operators:</li>
    </ul>

<pre><code class="language-js line-numbers">count += 1;   // Reactive
count++;      // Reactive
count--;      // Reactive
</code></pre>
    <br/><br/>



    <li>Reactivity with Arrays and Objects</li>
    <br/>
    <ul>
        <li>Svelte's reactivity is triggered by <u>assignments</u>, not mutations.</li>
        <br/>
        <li>Methods like <code>push()</code>, <code>pop()</code>, <code>splice()</code> do <u>not</u> trigger reactivity by themselves:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");  // This does NOT trigger update!
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>To trigger reactivity, you must <u>reassign</u> the variable:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    let items = ["Apple", "Banana"];

    function addItem() {
        items.push("Cherry");
        items = items;  // Reassignment triggers update
    }

    // Or more idiomatically:
    function addItemBetter() {
        items = [...items, "Cherry"];  // Spread creates new array
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Same applies to objects:</li>
    </ul>

<pre><code class="language-js line-numbers">let user = { name: "Alice", age: 25 };

user.age = 26;      // Does NOT trigger update
user = user;        // Triggers update

// Or:
user = { ...user, age: 26 };  // Triggers update
</code></pre>
    <br/><br/>



    <li>Reactive Declarations (<code>$:</code>)</li>
    <br/>
    <ul>
        <li>The <code>$:</code> label creates <u>reactive declarations</u> — values that automatically recalculate when their dependencies change.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;
    $: doubled = count * 2;
    $: quadrupled = doubled * 2;
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Svelte automatically tracks which variables are used and re-runs the declaration when any dependency changes.</li>
        <br/>
        <li>Reactive declarations can depend on other reactive declarations (like <code>quadrupled</code> depends on <code>doubled</code>).</li>
    </ul>
    <br/><br/>



    <li>Reactive Statements</li>
    <br/>
    <ul>
        <li>You can also use <code>$:</code> to run <u>arbitrary statements</u> reactively:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = 0;

    $: console.log("Count changed to:", count);

    $: if (count &gt;= 10) {
        alert("Count is getting high!");
        count = 0;
    }

    $: {
        console.log("Running reactive block");
        console.log("Current count:", count);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li>These statements re-run whenever any referenced variable changes.</li>
    </ul>
    <br/><br/>



    <li>Reactive Stores</li>
    <br/>
    <ul>
        <li>For state that needs to be shared across components, Svelte provides <u>stores</u>.</li>
        <br/>
        <li>A store is an object with a <code>subscribe</code> method that allows reactive access to a value.</li>
        <br/>
        <li>Svelte provides three built-in store types.</li>
    </ul>

    <br/>
    <ol>
    <li><code>writable</code> — Read and write</li>

<pre><code class="language-js line-numbers">// stores.js
import { writable } from "svelte/store";

export const count = writable(0);
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { count } from "./stores.js";

    function increment() {
        count.update(n =&gt; n + 1);
    }

    function reset() {
        count.set(0);
    }
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>set(value)</code> — Sets the store to a new value.</li>
        <li><code>update(fn)</code> — Updates based on current value.</li>
    </ul>
    <br/><br/>



    <li><code>readable</code> — Read only</li>

<pre><code class="language-js line-numbers">import { readable } from "svelte/store";

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() =&gt; {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };
});
</code></pre>

    <ul>
        <li>The second argument is a function that receives <code>set</code> and returns a cleanup function.</li>
    </ul>
    <br/><br/>



    <li><code>derived</code> — Derived from other stores</li>

<pre><code class="language-js line-numbers">import { derived } from "svelte/store";
import { count } from "./stores.js";

export const doubled = derived(count, $count =&gt; $count * 2);

// Derived from multiple stores:
export const total = derived(
    [storeA, storeB],
    ([$a, $b]) =&gt; $a + $b
);
</code></pre>
    </ol>
    <br/><br/>



    <li>Auto-Subscription with <code>$</code> Prefix</li>
    <br/>
    <ul>
        <li>Inside Svelte components, you can access store values using the <code>$</code> prefix:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { count } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;The count is {$count}&lt;/p&gt;

&lt;button on:click={() =&gt; $count++}&gt;
    Increment
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$count</code> automatically subscribes to the store and unsubscribes when the component is destroyed.</li>
        <br/>
        <li>You can also assign directly to <code>$count</code> — it's equivalent to calling <code>count.set()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    import { name } from "./stores.js";
&lt;/script&gt;

&lt;input bind:value={$name}&gt;
</code></pre>
    <br/><br/>



    <li>Custom Stores</li>
    <br/>
    <ul>
        <li>You can create custom stores with domain-specific logic:</li>
    </ul>

<pre><code class="language-js line-numbers">import { writable } from "svelte/store";

function createCounter() {
    const { subscribe, set, update } = writable(0);

    return {
        subscribe,
        increment: () =&gt; update(n =&gt; n + 1),
        decrement: () =&gt; update(n =&gt; n - 1),
        reset: () =&gt; set(0)
    };
}

export const counter = createCounter();
</code></pre>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import { counter } from "./stores.js";
&lt;/script&gt;

&lt;p&gt;{$counter}&lt;/p&gt;
&lt;button on:click={counter.increment}&gt;+&lt;/button&gt;
&lt;button on:click={counter.decrement}&gt;-&lt;/button&gt;
&lt;button on:click={counter.reset}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5 Runes (New Reactivity System)</li>
    <br/>
    <ul>
        <li>Svelte 5 introduces <u>Runes</u>, a new reactivity system that replaces <code>$:</code> and provides more explicit control.</li>
    </ul>

    <br/>
    <ol>
    <li><code>$state</code> — Reactive State</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    function increment() {
        count++;  // Directly mutate, it's reactive!
    }
&lt;/script&gt;

&lt;button onclick={increment}&gt;
    Count: {count}
&lt;/button&gt;
</code></pre>

    <ul>
        <li>With <code>$state</code>, even mutations on arrays and objects are reactive:</li>
    </ul>

<pre><code class="language-js line-numbers">let items = $state(["Apple", "Banana"]);
items.push("Cherry");  // This IS reactive in Svelte 5!

let user = $state({ name: "Alice", age: 25 });
user.age = 26;  // This IS reactive in Svelte 5!
</code></pre>
    <br/><br/>



    <li><code>$derived</code> — Computed Values</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);
    let doubled = $derived(count * 2);
    let quadrupled = $derived(doubled * 2);
&lt;/script&gt;

&lt;p&gt;{count} × 2 = {doubled}&lt;/p&gt;
&lt;p&gt;{count} × 4 = {quadrupled}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$derived</code> replaces the <code>$:</code> reactive declarations.</li>
    </ul>
    <br/><br/>



    <li><code>$effect</code> — Side Effects</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let count = $state(0);

    $effect(() =&gt; {
        console.log("Count is now:", count);
    });

    $effect(() =&gt; {
        // Runs when component mounts
        console.log("Mounted!");

        return () =&gt; {
            // Cleanup when component unmounts
            console.log("Unmounted!");
        };
    });
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$effect</code> automatically tracks dependencies and re-runs when they change.</li>
        <li>Return a function for cleanup (like <code>useEffect</code> in React).</li>
    </ul>
    <br/><br/>



    <li><code>$props</code> — Component Props</li>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let { name, age = 18 } = $props();
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>$props</code> replaces <code>export let</code> for declaring component props in Svelte 5.</li>
    </ul>
    </ol>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Reactivity</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5 (Runes)</th>
        </tr>
        <tr>
            <td>Reactive variable</td>
            <td><code>let count = 0;</code></td>
            <td><code>let count = $state(0);</code></td>
        </tr>
        <tr>
            <td>Computed value</td>
            <td><code>$: doubled = count * 2;</code></td>
            <td><code>let doubled = $derived(count * 2);</code></td>
        </tr>
        <tr>
            <td>Side effect</td>
            <td><code>$: console.log(count);</code></td>
            <td><code>$effect(() =&gt; console.log(count));</code></td>
        </tr>
        <tr>
            <td>Props</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Array/Object mutation</td>
            <td>Requires reassignment</td>
            <td>Direct mutation works</td>
        </tr>
        <tr>
            <td>Event handlers</td>
            <td><code>on:click={fn}</code></td>
            <td><code>onclick={fn}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-props">Svelte Props</h3>
<ol>
    <li>What Are Props?</li>
    <br/>
    <ul>
        <li><b>Props</b> (short for properties) are how you pass data from a <u>parent component</u> to a <u>child component</u>.</li>
        <br/>
        <li>Props allow components to be reusable and configurable.</li>
        <br/>
        <li>In Svelte, props flow <u>one direction</u>: from parent to child (unidirectional data flow).</li>
    </ul>
    <br/><br/>



    <li>Declaring Props (Svelte 4)</li>
    <br/>
    <ul>
        <li>In Svelte 4, use <code>export let</code> to declare a prop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte --&gt;
&lt;script&gt;
    export let name;
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>The parent component passes the prop as an attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.svelte --&gt;
&lt;script&gt;
    import Greeting from "./Greeting.svelte";
&lt;/script&gt;

&lt;Greeting name="Alice" /&gt;
&lt;Greeting name="Bob" /&gt;
</code></pre>
    <br/><br/>



    <li>Default Values</li>
    <br/>
    <ul>
        <li>You can assign a default value to a prop:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name = "World";
    export let age = 18;
    export let active = false;
&lt;/script&gt;

&lt;p&gt;{name} is {age} years old.&lt;/p&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Using defaults --&gt;
&lt;Greeting /&gt;                    &lt;!-- name="World", age=18 --&gt;
&lt;Greeting name="Alice" /&gt;       &lt;!-- name="Alice", age=18 --&gt;
&lt;Greeting name="Bob" age={25} /&gt;
</code></pre>
    <br/><br/>



    <li>Passing Different Data Types</li>
    <br/>
    <ul>
        <li>Strings can be passed directly, but other types require curly braces:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- String --&gt;
&lt;User name="Alice" /&gt;

&lt;!-- Number --&gt;
&lt;User age={25} /&gt;

&lt;!-- Boolean --&gt;
&lt;User active={true} /&gt;
&lt;User active /&gt;              &lt;!-- Shorthand for active={true} --&gt;

&lt;!-- Array --&gt;
&lt;List items={["Apple", "Banana", "Cherry"]} /&gt;

&lt;!-- Object --&gt;
&lt;Profile user={{ name: "Alice", age: 25 }} /&gt;

&lt;!-- Variable --&gt;
&lt;script&gt;
    let username = "Alice";
&lt;/script&gt;
&lt;User name={username} /&gt;
</code></pre>
    <br/><br/>



    <li>Shorthand Props</li>
    <br/>
    <ul>
        <li>When the prop name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    let name = "Alice";
    let age = 25;
&lt;/script&gt;

&lt;!-- Instead of this: --&gt;
&lt;User name={name} age={age} /&gt;

&lt;!-- Use shorthand: --&gt;
&lt;User {name} {age} /&gt;
</code></pre>
    <br/><br/>



    <li>Spread Props</li>
    <br/>
    <ul>
        <li>You can spread an object to pass multiple props at once:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script&gt;
    import User from "./User.svelte";

    const userData = {
        name: "Alice",
        age: 25,
        email: "alice@example.com"
    };
&lt;/script&gt;

&lt;!-- Instead of: --&gt;
&lt;User name={userData.name} age={userData.age} email={userData.email} /&gt;

&lt;!-- Use spread: --&gt;
&lt;User {...userData} /&gt;
</code></pre>
    <br/><br/>



    <li>Receiving All Props with <code>$$props</code> and <code>$$restProps</code></li>
    <br/>
    <ul>
        <li><code>$$props</code> contains all props passed to a component:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script&gt;
    export let name;
    export let age;

    // $$props = { name: "...", age: ..., ...anyOtherProps }
    console.log($$props);
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>$$restProps</code> contains props that were <u>not</u> explicitly declared:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script&gt;
    export let variant = "primary";
    // Any other props (class, id, disabled, etc.) go to $$restProps
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...$$restProps}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Button variant="danger" disabled id="submit-btn"&gt;
    Submit
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>This is useful for wrapper components that forward attributes to native elements.</li>
    </ul>
    <br/><br/>



    <li>Reactive Props</li>
    <br/>
    <ul>
        <li>Props are reactive — when the parent updates a prop, the child re-renders:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script&gt;
    import Counter from "./Counter.svelte";
    let count = 0;
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;Increment in Parent&lt;/button&gt;
&lt;Counter value={count} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte --&gt;
&lt;script&gt;
    export let value;
    $: console.log("Value changed to:", value);
&lt;/script&gt;

&lt;p&gt;Count: {value}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Readonly Props (One-Way Binding)</li>
    <br/>
    <ul>
        <li>By default, props are <u>one-way</u>: parent → child.</li>
        <br/>
        <li>Modifying a prop inside the child does <u>not</u> affect the parent:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.svelte --&gt;
&lt;script&gt;
    export let count = 0;

    function increment() {
        count++;  // Only changes local copy, not parent's value
    }
&lt;/script&gt;

&lt;button on:click={increment}&gt;{count}&lt;/button&gt;
</code></pre>

    <ul>
        <li>To update the parent, use <u>events</u> or <u>two-way binding</u> (covered later).</li>
    </ul>
    <br/><br/>



    <li>Props with TypeScript (Svelte 4)</li>
    <br/>
    <ul>
        <li>Add types to props using TypeScript:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    export let name: string;
    export let age: number = 18;
    export let active: boolean = false;
    export let items: string[] = [];
    export let user: { name: string; email: string } | null = null;
&lt;/script&gt;
</code></pre>

    <ul>
        <li>For complex types, define interfaces:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    export let user: User;
    export let users: User[] = [];
&lt;/script&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with <code>$props</code></li>
    <br/>
    <ul>
        <li>In Svelte 5, use the <code>$props</code> rune instead of <code>export let</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Greeting.svelte (Svelte 5) --&gt;
&lt;script&gt;
    let { name } = $props();
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>

    <ul>
        <li>Multiple props with defaults:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name = "World", age = 18, active = false } = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Rest props (similar to <code>$$restProps</code>):</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script&gt;
    let { name, age, ...rest } = $props();
&lt;/script&gt;

&lt;div {...rest}&gt;
    {name} is {age}
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Svelte 5: Props with TypeScript</li>
    <br/>
    <ul>
        <li>Type your props using TypeScript with <code>$props</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Props {
        name: string;
        age?: number;
        active?: boolean;
    }

    let { name, age = 18, active = false }: Props = $props();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>With rest props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: "primary" | "secondary" | "danger";
    }

    let { variant = "primary", ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Comparison: Svelte 4 vs Svelte 5 Props</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>Basic prop</td>
            <td><code>export let name;</code></td>
            <td><code>let { name } = $props();</code></td>
        </tr>
        <tr>
            <td>Default value</td>
            <td><code>export let name = "World";</code></td>
            <td><code>let { name = "World" } = $props();</code></td>
        </tr>
        <tr>
            <td>Multiple props</td>
            <td>Multiple <code>export let</code> lines</td>
            <td>Destructure from <code>$props()</code></td>
        </tr>
        <tr>
            <td>Rest props</td>
            <td><code>$$restProps</code></td>
            <td><code>let { a, ...rest } = $props();</code></td>
        </tr>
        <tr>
            <td>All props</td>
            <td><code>$$props</code></td>
            <td><code>let props = $props();</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-logic">Svelte Logic</h3>
<ol>
    <li>What Is Svelte Logic?</li>
    <br/>
    <ul>
        <li>Svelte provides special <u>logic blocks</u> in templates to handle conditional rendering, loops, and asynchronous data.</li>
        <br/>
        <li>These blocks use a syntax with <code>{#...}</code> to open, <code>{:...}</code> for continuation, and <code>{/...}</code> to close.</li>
        <br/>
        <li>The main logic blocks are:
            <ul>
                <li><code>{#if}</code> — Conditional rendering</li>
                <li><code>{#each}</code> — Looping over arrays</li>
                <li><code>{#await}</code> — Handling promises</li>
                <li><code>{#key}</code> — Forcing re-render on value change</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Conditional Rendering with <code>{#if}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#if}</code> to conditionally render content:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back!&lt;/p&gt;
{/if}

&lt;button onclick={() =&gt; loggedIn = !loggedIn}&gt;
    Toggle Login
&lt;/button&gt;
</code></pre>

    <ul>
        <li>The content inside <code>{#if}</code> only renders when the condition is <code>true</code>.</li>
    </ul>
    <br/><br/>



    <li><code>{:else}</code> Block</li>
    <br/>
    <ul>
        <li>Use <code>{:else}</code> to render alternative content when the condition is <code>false</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = false;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome back, user!&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = false}&gt;Log Out&lt;/button&gt;
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
    &lt;button onclick={() =&gt; loggedIn = true}&gt;Log In&lt;/button&gt;
{/if}
</code></pre>
    <br/><br/>



    <li><code>{:else if}</code> Block</li>
    <br/>
    <ul>
        <li>Chain multiple conditions with <code>{:else if}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let score: number = 75;
&lt;/script&gt;

{#if score &gt;= 90}
    &lt;p&gt;Grade: A&lt;/p&gt;
{:else if score &gt;= 80}
    &lt;p&gt;Grade: B&lt;/p&gt;
{:else if score &gt;= 70}
    &lt;p&gt;Grade: C&lt;/p&gt;
{:else if score &gt;= 60}
    &lt;p&gt;Grade: D&lt;/p&gt;
{:else}
    &lt;p&gt;Grade: F&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Nested Conditionals</li>
    <br/>
    <ul>
        <li>You can nest <code>{#if}</code> blocks inside each other:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let loggedIn: boolean = true;
    let isAdmin: boolean = true;
&lt;/script&gt;

{#if loggedIn}
    &lt;p&gt;Welcome!&lt;/p&gt;
    {#if isAdmin}
        &lt;p&gt;You have admin privileges.&lt;/p&gt;
        &lt;button&gt;Access Admin Panel&lt;/button&gt;
    {:else}
        &lt;p&gt;You are a regular user.&lt;/p&gt;
    {/if}
{:else}
    &lt;p&gt;Please log in.&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Looping with <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#each}</code> to iterate over arrays:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit}
        &lt;li&gt;{fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{#each}</code> with Index</li>
    <br/>
    <ul>
        <li>Access the current index as the second parameter:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let fruits: string[] = ["Apple", "Banana", "Cherry"];
&lt;/script&gt;

&lt;ul&gt;
    {#each fruits as fruit, index}
        &lt;li&gt;{index + 1}. {fruit}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Keyed <code>{#each}</code> Blocks</li>
    <br/>
    <ul>
        <li>When items can be added, removed, or reordered, use a <u>key</u> to help Svelte track each item:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Todo {
        id: number;
        text: string;
        done: boolean;
    }

    let todos: Todo[] = [
        { id: 1, text: "Learn Svelte", done: false },
        { id: 2, text: "Build an app", done: false },
        { id: 3, text: "Deploy", done: false }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo (todo.id)}
        &lt;li&gt;{todo.text}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>

    <ul>
        <li>The <code>(todo.id)</code> part is the key — it should be a unique identifier.</li>
        <br/>
        <li>Keys ensure correct DOM updates when the list changes (especially important for animations and component state).</li>
    </ul>
    <br/><br/>



    <li><code>{#each}</code> with Destructuring</li>
    <br/>
    <ul>
        <li>Destructure objects directly in the each block:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
        email: string;
    }

    let users: User[] = [
        { id: 1, name: "Alice", email: "alice@example.com" },
        { id: 2, name: "Bob", email: "bob@example.com" }
    ];
&lt;/script&gt;

&lt;ul&gt;
    {#each users as { id, name, email } (id)}
        &lt;li&gt;{name} - {email}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li><code>{:else}</code> in <code>{#each}</code></li>
    <br/>
    <ul>
        <li>Render fallback content when the array is empty:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let todos: string[] = [];
&lt;/script&gt;

&lt;ul&gt;
    {#each todos as todo}
        &lt;li&gt;{todo}&lt;/li&gt;
    {:else}
        &lt;li&gt;No todos yet. Add one!&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Iterating Over Objects</li>
    <br/>
    <ul>
        <li>Use <code>Object.entries()</code> or <code>Object.keys()</code> to iterate over objects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const scores: Record&lt;string, number&gt; = {
        Alice: 95,
        Bob: 82,
        Charlie: 78
    };
&lt;/script&gt;

&lt;ul&gt;
    {#each Object.entries(scores) as [name, score]}
        &lt;li&gt;{name}: {score}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Handling Promises with <code>{#await}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#await}</code> to handle asynchronous data directly in templates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchUser(): Promise&lt;User&gt; {
        const response = await fetch("https://api.example.com/user/1");
        return response.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchUser();
&lt;/script&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;Hello, {user.name}!&lt;/p&gt;
{:catch error}
    &lt;p&gt;Error: {error.message}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li><code>{#await promise}</code> — Shows while pending</li>
        <li><code>{:then value}</code> — Shows when resolved</li>
        <li><code>{:catch error}</code> — Shows when rejected</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Loading State</li>
    <br/>
    <ul>
        <li>If you don't need a loading state, skip directly to <code>{:then}</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let dataPromise: Promise&lt;string&gt; = Promise.resolve("Hello!");
&lt;/script&gt;

{#await dataPromise then data}
    &lt;p&gt;{data}&lt;/p&gt;
{/await}
</code></pre>

    <ul>
        <li>Nothing renders until the promise resolves.</li>
    </ul>
    <br/><br/>



    <li><code>{#await}</code> Without Catch</li>
    <br/>
    <ul>
        <li>You can omit <code>{:catch}</code> if you don't need error handling in the template:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        title: string;
        body: string;
    }

    async function fetchPost(): Promise&lt;Post&gt; {
        const res = await fetch("https://api.example.com/posts/1");
        return res.json();
    }

    let postPromise: Promise&lt;Post&gt; = fetchPost();
&lt;/script&gt;

{#await postPromise}
    &lt;p&gt;Loading post...&lt;/p&gt;
{:then post}
    &lt;h2&gt;{post.title}&lt;/h2&gt;
    &lt;p&gt;{post.body}&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Refreshing <code>{#await}</code> Data</li>
    <br/>
    <ul>
        <li>Reassign the promise to trigger a refresh:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        id: number;
        name: string;
    }

    async function fetchRandomUser(): Promise&lt;User&gt; {
        const id = Math.floor(Math.random() * 10) + 1;
        const res = await fetch(`https://api.example.com/users/${id}`);
        return res.json();
    }

    let userPromise: Promise&lt;User&gt; = fetchRandomUser();

    function refresh(): void {
        userPromise = fetchRandomUser();  // Reassign to refetch
    }
&lt;/script&gt;

&lt;button onclick={refresh}&gt;Load Random User&lt;/button&gt;

{#await userPromise}
    &lt;p&gt;Loading...&lt;/p&gt;
{:then user}
    &lt;p&gt;{user.name}&lt;/p&gt;
{:catch error}
    &lt;p&gt;Failed to load user.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Forcing Re-render with <code>{#key}</code></li>
    <br/>
    <ul>
        <li>The <code>{#key}</code> block destroys and recreates its content when the key value changes:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    let userId: number = 1;
&lt;/script&gt;

&lt;input type="number" bind:value={userId} min="1" /&gt;

{#key userId}
    &lt;UserProfile id={userId} /&gt;
{/key}
</code></pre>

    <ul>
        <li>When <code>userId</code> changes, the <code>UserProfile</code> component is destroyed and a new instance is created.</li>
        <br/>
        <li>This resets all component state and re-runs lifecycle functions.</li>
    </ul>
    <br/><br/>



    <li><code>{#key}</code> for Animations</li>
    <br/>
    <ul>
        <li><code>{#key}</code> is useful for triggering intro/outro transitions:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let count: number = 0;
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;

{#key count}
    &lt;p transition:fade&gt;{count}&lt;/p&gt;
{/key}
</code></pre>

    <ul>
        <li>Every time <code>count</code> changes, the paragraph fades out and a new one fades in.</li>
    </ul>
    <br/><br/>



    <li>Combining Logic Blocks</li>
    <br/>
    <ul>
        <li>Logic blocks can be combined for complex rendering:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script lang="ts"&gt;
    interface Post {
        id: number;
        title: string;
        published: boolean;
    }

    async function fetchPosts(): Promise&lt;Post[]&gt; {
        const res = await fetch("https://api.example.com/posts");
        return res.json();
    }

    let postsPromise: Promise&lt;Post[]&gt; = fetchPosts();
    let showOnlyPublished: boolean = false;
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={showOnlyPublished} /&gt;
    Show only published
&lt;/label&gt;

{#await postsPromise}
    &lt;p&gt;Loading posts...&lt;/p&gt;
{:then posts}
    &lt;ul&gt;
        {#each posts as post (post.id)}
            {#if !showOnlyPublished || post.published}
                &lt;li&gt;
                    {post.title}
                    {#if !post.published}
                        &lt;span&gt;(Draft)&lt;/span&gt;
                    {/if}
                &lt;/li&gt;
            {/if}
        {/each}
    &lt;/ul&gt;
{:catch}
    &lt;p&gt;Failed to load posts.&lt;/p&gt;
{/await}
</code></pre>
    <br/><br/>



    <li>Logic Blocks Summary</li>
    <br/>

    <table>
        <tr>
            <th>Block</th>
            <th>Purpose</th>
            <th>Syntax</th>
        </tr>
        <tr>
            <td><code>{#if}</code></td>
            <td>Conditional rendering</td>
            <td><code>{#if condition}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else}</code></td>
            <td>Else branch</td>
            <td><code>{#if}...{:else}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{:else if}</code></td>
            <td>Else-if branch</td>
            <td><code>{#if}...{:else if}...{/if}</code></td>
        </tr>
        <tr>
            <td><code>{#each}</code></td>
            <td>Loop over arrays</td>
            <td><code>{#each array as item}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#each} + key</code></td>
            <td>Keyed loop</td>
            <td><code>{#each array as item (key)}...{/each}</code></td>
        </tr>
        <tr>
            <td><code>{#await}</code></td>
            <td>Handle promises</td>
            <td><code>{#await promise}...{:then}...{:catch}...{/await}</code></td>
        </tr>
        <tr>
            <td><code>{#key}</code></td>
            <td>Force re-render</td>
            <td><code>{#key value}...{/key}</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-events">Svelte Events</h3>
<ol>
    <li>What Are Events in Svelte?</li>
    <br/>
    <ul>
        <li><b>Events</b> allow components to respond to user interactions and communicate with each other.</li>
        <br/>
        <li>Svelte supports:
            <ul>
                <li><b>DOM events</b> — Native browser events like click, input, submit</li>
                <li><b>Component events</b> — Custom events dispatched from child to parent</li>
            </ul>
        </li>
        <br/>
        <li>Svelte 4 uses <code>on:event</code> syntax, while Svelte 5 uses <code>onevent</code> syntax.</li>
    </ul>
    <br/><br/>



    <li>DOM Event Handling (Svelte 4)</li>
    <br/>
    <ul>
        <li>Use <code>on:</code> directive to listen to DOM events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = 0;

    function handleClick(): void {
        count++;
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>

    <ul>
        <li>Common DOM events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Mouse events --&gt;
&lt;button on:click={handleClick}&gt;Click&lt;/button&gt;
&lt;div on:dblclick={handleDoubleClick}&gt;Double click&lt;/div&gt;
&lt;div on:mouseenter={handleMouseEnter}&gt;Hover me&lt;/div&gt;
&lt;div on:mouseleave={handleMouseLeave}&gt;Leave me&lt;/div&gt;
&lt;div on:mousemove={handleMouseMove}&gt;Move inside&lt;/div&gt;

&lt;!-- Keyboard events --&gt;
&lt;input on:keydown={handleKeyDown} /&gt;
&lt;input on:keyup={handleKeyUp} /&gt;
&lt;input on:keypress={handleKeyPress} /&gt;

&lt;!-- Form events --&gt;
&lt;input on:input={handleInput} /&gt;
&lt;input on:change={handleChange} /&gt;
&lt;input on:focus={handleFocus} /&gt;
&lt;input on:blur={handleBlur} /&gt;
&lt;form on:submit={handleSubmit}&gt;...&lt;/form&gt;

&lt;!-- Other events --&gt;
&lt;div on:scroll={handleScroll}&gt;...&lt;/div&gt;
&lt;img on:load={handleLoad} on:error={handleError} /&gt;
</code></pre>
    <br/><br/>



    <li>DOM Event Handling (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use standard HTML attribute syntax:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);

    function handleClick(): void {
        count++;
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;
    Clicked {count} times
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 5 event syntax --&gt;
&lt;button onclick={handleClick}&gt;Click&lt;/button&gt;
&lt;div ondblclick={handleDoubleClick}&gt;Double click&lt;/div&gt;
&lt;input onkeydown={handleKeyDown} /&gt;
&lt;input oninput={handleInput} /&gt;
&lt;form onsubmit={handleSubmit}&gt;...&lt;/form&gt;
</code></pre>
    <br/><br/>



    <li>Inline Event Handlers</li>
    <br/>
    <ul>
        <li>You can define handlers inline using arrow functions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let message: string = $state("");
&lt;/script&gt;

&lt;!-- Svelte 5 syntax --&gt;
&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;
&lt;button onclick={() =&gt; count = 0}&gt;Reset&lt;/button&gt;
&lt;button onclick={() =&gt; alert("Hello!")}&gt;Alert&lt;/button&gt;

&lt;input oninput={(e) =&gt; message = e.currentTarget.value} /&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Svelte 4 syntax --&gt;
&lt;button on:click={() =&gt; count++}&gt;Increment&lt;/button&gt;
&lt;button on:click={() =&gt; count = 0}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>The Event Object</li>
    <br/>
    <ul>
        <li>Event handlers receive the native DOM event object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function handleClick(event: MouseEvent): void {
        console.log("Clicked at:", event.clientX, event.clientY);
        console.log("Target:", event.target);
        console.log("Current target:", event.currentTarget);
    }

    function handleKeyDown(event: KeyboardEvent): void {
        console.log("Key pressed:", event.key);
        console.log("Key code:", event.code);
        if (event.key === "Enter") {
            console.log("Enter pressed!");
        }
    }

    function handleInput(event: Event): void {
        const target = event.currentTarget as HTMLInputElement;
        console.log("Input value:", target.value);
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;Click me&lt;/button&gt;
&lt;input onkeydown={handleKeyDown} /&gt;
&lt;input oninput={handleInput} /&gt;
</code></pre>
    <br/><br/>



    <li>Event Modifiers (Svelte 4)</li>
    <br/>
    <ul>
        <li>Svelte 4 provides modifiers to alter event behavior:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- preventDefault: Prevents default browser action --&gt;
&lt;form on:submit|preventDefault={handleSubmit}&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;!-- stopPropagation: Stops event from bubbling up --&gt;
&lt;div on:click={handleOuter}&gt;
    &lt;button on:click|stopPropagation={handleInner}&gt;Click&lt;/button&gt;
&lt;/div&gt;

&lt;!-- once: Handler runs only once --&gt;
&lt;button on:click|once={handleClick}&gt;Click once&lt;/button&gt;

&lt;!-- capture: Use capture phase instead of bubble --&gt;
&lt;div on:click|capture={handleClick}&gt;...&lt;/div&gt;

&lt;!-- self: Only trigger if event.target is the element itself --&gt;
&lt;div on:click|self={handleClick}&gt;
    &lt;button&gt;Clicking here won't trigger parent&lt;/button&gt;
&lt;/div&gt;

&lt;!-- passive: Improves scroll performance --&gt;
&lt;div on:scroll|passive={handleScroll}&gt;...&lt;/div&gt;

&lt;!-- nonpassive: Explicitly not passive --&gt;
&lt;div on:touchstart|nonpassive={handleTouch}&gt;...&lt;/div&gt;

&lt;!-- trusted: Only trigger for user-initiated events --&gt;
&lt;button on:click|trusted={handleClick}&gt;...&lt;/button&gt;
</code></pre>

    <ul>
        <li>Modifiers can be chained:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;form on:submit|preventDefault|stopPropagation={handleSubmit}&gt;
    ...
&lt;/form&gt;

&lt;button on:click|once|capture={handleClick}&gt;...&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Event Modifiers (Svelte 5)</li>
    <br/>
    <ul>
        <li>Svelte 5 doesn't have the modifier syntax. Use standard JavaScript instead:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function handleSubmit(event: SubmitEvent): void {
        event.preventDefault();
        // Handle form submission
    }

    function handleInnerClick(event: MouseEvent): void {
        event.stopPropagation();
        // Handle click
    }
&lt;/script&gt;

&lt;form onsubmit={handleSubmit}&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;div onclick={handleOuter}&gt;
    &lt;button onclick={handleInnerClick}&gt;Click&lt;/button&gt;
&lt;/div&gt;
</code></pre>

    <ul>
        <li>For <code>once</code>, use a wrapper or state:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let clicked: boolean = $state(false);

    function handleOnce(): void {
        if (clicked) return;
        clicked = true;
        console.log("This runs only once");
    }
&lt;/script&gt;

&lt;button onclick={handleOnce}&gt;Click once&lt;/button&gt;
</code></pre>

    <ul>
        <li>For <code>capture</code> and <code>passive</code>, use <code>onclickcapture</code> or handle in <code>$effect</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Capture phase --&gt;
&lt;div onclickcapture={handleClick}&gt;...&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Component Events (Svelte 4)</li>
    <br/>
    <ul>
        <li>Components can dispatch custom events to their parent using <code>createEventDispatcher</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import { createEventDispatcher } from "svelte";

    const dispatch = createEventDispatcher&lt;{
        click: void;
        customEvent: { message: string };
    }&gt;();

    function handleClick(): void {
        dispatch("click");
        dispatch("customEvent", { message: "Hello from child!" });
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";

    function handleCustomEvent(event: CustomEvent&lt;{ message: string }&gt;): void {
        console.log(event.detail.message);
    }
&lt;/script&gt;

&lt;Button on:click={() =&gt; console.log("Clicked!")} on:customEvent={handleCustomEvent}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Component Events (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <u>callback props</u> instead of <code>createEventDispatcher</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        onclick?: () =&gt; void;
        onCustomEvent?: (data: { message: string }) =&gt; void;
        children?: any;
    }

    let { onclick, onCustomEvent, children }: Props = $props();

    function handleClick(): void {
        onclick?.();
        onCustomEvent?.({ message: "Hello from child!" });
    }
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;
    {@render children?.()}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";

    function handleCustomEvent(data: { message: string }): void {
        console.log(data.message);
    }
&lt;/script&gt;

&lt;Button onclick={() =&gt; console.log("Clicked!")} onCustomEvent={handleCustomEvent}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Event Forwarding (Svelte 4)</li>
    <br/>
    <ul>
        <li>Forward DOM events from a child element without handling them:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    export let variant: string = "primary";
&lt;/script&gt;

&lt;!-- Forward click event to parent --&gt;
&lt;button class="btn btn-{variant}" on:click&gt;
    &lt;slot /&gt;
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button on:click={() =&gt; console.log("Button clicked!")}&gt;
    Click me
&lt;/Button&gt;
</code></pre>

    <ul>
        <li>The <code>on:click</code> without a value forwards the event.</li>
        <br/>
        <li>Forward multiple events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input
    on:input
    on:change
    on:focus
    on:blur
    on:keydown
/&gt;
</code></pre>
    <br/><br/>



    <li>Event Forwarding (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use rest props to forward events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    import type { HTMLButtonAttributes } from "svelte/elements";

    interface Props extends HTMLButtonAttributes {
        variant?: string;
    }

    let { variant = "primary", children, ...rest }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant}" {...rest}&gt;
    {@render children?.()}
&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button onclick={() =&gt; console.log("Clicked!")} onmouseenter={() =&gt; console.log("Hovered!")}&gt;
    Click me
&lt;/Button&gt;
</code></pre>
    <br/><br/>



    <li>Typed Custom Events (Svelte 4)</li>
    <br/>
    <ul>
        <li>Strongly type custom events with generics:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchBox.svelte --&gt;
&lt;script lang="ts"&gt;
    import { createEventDispatcher } from "svelte";

    interface SearchEvents {
        search: string;
        clear: void;
        select: { id: number; label: string };
    }

    const dispatch = createEventDispatcher&lt;SearchEvents&gt;();

    let query: string = "";

    function handleSearch(): void {
        dispatch("search", query);
    }

    function handleClear(): void {
        query = "";
        dispatch("clear");
    }

    function handleSelect(id: number, label: string): void {
        dispatch("select", { id, label });
    }
&lt;/script&gt;

&lt;input bind:value={query} on:input={handleSearch} /&gt;
&lt;button on:click={handleClear}&gt;Clear&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import SearchBox from "./SearchBox.svelte";

    function onSearch(event: CustomEvent&lt;string&gt;): void {
        console.log("Searching for:", event.detail);
    }

    function onClear(): void {
        console.log("Search cleared");
    }

    function onSelect(event: CustomEvent&lt;{ id: number; label: string }&gt;): void {
        console.log("Selected:", event.detail.id, event.detail.label);
    }
&lt;/script&gt;

&lt;SearchBox on:search={onSearch} on:clear={onClear} on:select={onSelect} /&gt;
</code></pre>
    <br/><br/>



    <li>Typed Callback Props (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, callbacks are naturally typed:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchBox.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        onSearch?: (query: string) =&gt; void;
        onClear?: () =&gt; void;
        onSelect?: (item: { id: number; label: string }) =&gt; void;
    }

    let { onSearch, onClear, onSelect }: Props = $props();

    let query: string = $state("");

    function handleInput(): void {
        onSearch?.(query);
    }

    function handleClear(): void {
        query = "";
        onClear?.();
    }
&lt;/script&gt;

&lt;input bind:value={query} oninput={handleInput} /&gt;
&lt;button onclick={handleClear}&gt;Clear&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import SearchBox from "./SearchBox.svelte";

    function handleSearch(query: string): void {
        console.log("Searching for:", query);
    }

    function handleSelect(item: { id: number; label: string }): void {
        console.log("Selected:", item.id, item.label);
    }
&lt;/script&gt;

&lt;SearchBox onSearch={handleSearch} onClear={() =&gt; console.log("Cleared")} onSelect={handleSelect} /&gt;
</code></pre>
    <br/><br/>



    <li>Handling Window and Document Events</li>
    <br/>
    <ul>
        <li>Use <code>&lt;svelte:window&gt;</code> and <code>&lt;svelte:document&gt;</code> for global events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);

    function handleKeyDown(event: KeyboardEvent): void {
        if (event.key === "Escape") {
            console.log("Escape pressed!");
        }
    }

    function handleVisibilityChange(): void {
        console.log("Visibility:", document.visibilityState);
    }
&lt;/script&gt;

&lt;!-- Window events --&gt;
&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    onkeydown={handleKeyDown}
    onresize={() =&gt; console.log("Resized!")}
/&gt;

&lt;!-- Document events --&gt;
&lt;svelte:document onvisibilitychange={handleVisibilityChange} /&gt;

&lt;p&gt;Window size: {innerWidth} x {innerHeight}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Handling Body Events</li>
    <br/>
    <ul>
        <li>Use <code>&lt;svelte:body&gt;</code> for body-level events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let mouseX: number = $state(0);
    let mouseY: number = $state(0);

    function handleMouseMove(event: MouseEvent): void {
        mouseX = event.clientX;
        mouseY = event.clientY;
    }
&lt;/script&gt;

&lt;svelte:body onmousemove={handleMouseMove} /&gt;

&lt;p&gt;Mouse position: {mouseX}, {mouseY}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Event Syntax Comparison</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Svelte 4</th>
            <th>Svelte 5</th>
        </tr>
        <tr>
            <td>DOM event</td>
            <td><code>on:click={handler}</code></td>
            <td><code>onclick={handler}</code></td>
        </tr>
        <tr>
            <td>Inline handler</td>
            <td><code>on:click={() => ...}</code></td>
            <td><code>onclick={() => ...}</code></td>
        </tr>
        <tr>
            <td>Modifiers</td>
            <td><code>on:click|preventDefault</code></td>
            <td><code>event.preventDefault()</code></td>
        </tr>
        <tr>
            <td>Event forwarding</td>
            <td><code>on:click</code> (no value)</td>
            <td><code>{...rest}</code> spread</td>
        </tr>
        <tr>
            <td>Component events</td>
            <td><code>createEventDispatcher</code></td>
            <td>Callback props</td>
        </tr>
        <tr>
            <td>Listen to component</td>
            <td><code>on:customEvent={handler}</code></td>
            <td><code>onCustomEvent={handler}</code></td>
        </tr>
        <tr>
            <td>Capture phase</td>
            <td><code>on:click|capture</code></td>
            <td><code>onclickcapture</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-bindings">Svelte Bindings</h3>
<ol>
    <li>What Are Bindings?</li>
    <br/>
    <ul>
        <li><b>Bindings</b> create a <u>two-way connection</u> between a variable and an element property or component prop.</li>
        <br/>
        <li>When the variable changes, the element updates. When the element changes (e.g., user input), the variable updates.</li>
        <br/>
        <li>Svelte uses the <code>bind:</code> directive for bindings.</li>
    </ul>
    <br/><br/>



    <li>Basic Input Binding</li>
    <br/>
    <ul>
        <li>Bind an input's value to a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let name: string = $state("");
&lt;/script&gt;

&lt;input type="text" bind:value={name} /&gt;
&lt;p&gt;Hello, {name || "stranger"}!&lt;/p&gt;
</code></pre>

    <ul>
        <li>Typing in the input automatically updates <code>name</code>.</li>
        <li>Changing <code>name</code> programmatically updates the input.</li>
    </ul>
    <br/><br/>



    <li>Text Input Types</li>
    <br/>
    <ul>
        <li>Works with various text input types:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let text: string = $state("");
    let email: string = $state("");
    let password: string = $state("");
    let search: string = $state("");
    let url: string = $state("");
    let tel: string = $state("");
&lt;/script&gt;

&lt;input type="text" bind:value={text} /&gt;
&lt;input type="email" bind:value={email} /&gt;
&lt;input type="password" bind:value={password} /&gt;
&lt;input type="search" bind:value={search} /&gt;
&lt;input type="url" bind:value={url} /&gt;
&lt;input type="tel" bind:value={tel} /&gt;
</code></pre>
    <br/><br/>



    <li>Numeric Input Binding</li>
    <br/>
    <ul>
        <li>For <code>type="number"</code> and <code>type="range"</code>, the value is automatically coerced to a number:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let quantity: number = $state(1);
    let volume: number = $state(50);
&lt;/script&gt;

&lt;input type="number" bind:value={quantity} min="0" max="100" /&gt;
&lt;p&gt;Quantity: {quantity} (type: {typeof quantity})&lt;/p&gt;

&lt;input type="range" bind:value={volume} min="0" max="100" /&gt;
&lt;p&gt;Volume: {volume}%&lt;/p&gt;
</code></pre>

    <ul>
        <li>The bound variable will be a <code>number</code>, not a string.</li>
    </ul>
    <br/><br/>



    <li>Checkbox Binding</li>
    <br/>
    <ul>
        <li>For checkboxes, bind to <code>checked</code> instead of <code>value</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let agreed: boolean = $state(false);
    let subscribed: boolean = $state(true);
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={agreed} /&gt;
    I agree to the terms
&lt;/label&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={subscribed} /&gt;
    Subscribe to newsletter
&lt;/label&gt;

&lt;p&gt;Agreed: {agreed}, Subscribed: {subscribed}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Checkbox Group Binding</li>
    <br/>
    <ul>
        <li>Bind multiple checkboxes to an array using <code>bind:group</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let selectedFruits: string[] = $state([]);

    const fruits: string[] = ["Apple", "Banana", "Cherry", "Mango"];
&lt;/script&gt;

{#each fruits as fruit}
    &lt;label&gt;
        &lt;input type="checkbox" value={fruit} bind:group={selectedFruits} /&gt;
        {fruit}
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected: {selectedFruits.join(", ") || "None"}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Checking a box adds its <code>value</code> to the array.</li>
        <li>Unchecking removes it from the array.</li>
    </ul>
    <br/><br/>



    <li>Radio Button Binding</li>
    <br/>
    <ul>
        <li>Bind radio buttons to a single value using <code>bind:group</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let selectedColor: string = $state("red");

    const colors: string[] = ["red", "green", "blue"];
&lt;/script&gt;

{#each colors as color}
    &lt;label&gt;
        &lt;input type="radio" value={color} bind:group={selectedColor} /&gt;
        {color}
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected color: {selectedColor}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Only one radio button in a group can be selected at a time.</li>
    </ul>
    <br/><br/>



    <li>Radio Button with Objects</li>
    <br/>
    <ul>
        <li>Radio buttons can bind to object references:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Plan {
        id: string;
        name: string;
        price: number;
    }

    const plans: Plan[] = [
        { id: "basic",      name: "Basic",      price: 9.99  },
        { id: "pro",        name: "Pro",        price: 19.99 },
        { id: "enterprise", name: "Enterprise", price: 49.99 }
    ];

    let selectedPlan: Plan = $state(plans[0]);
&lt;/script&gt;

{#each plans as plan}
    &lt;label&gt;
        &lt;input type="radio" value={plan} bind:group={selectedPlan} /&gt;
        {plan.name} - ${plan.price}/month
    &lt;/label&gt;
{/each}

&lt;p&gt;Selected: {selectedPlan.name} at ${selectedPlan.price}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Select Dropdown Binding</li>
    <br/>
    <ul>
        <li>Bind a <code>&lt;select&gt;</code> element to a variable:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const selectedCountry: string = $state("");

    const countries: string[] = ["USA", "Canada", "UK", "Germany", "Japan"];
&lt;/script&gt;

&lt;select bind:value={selectedCountry}&gt;
    &lt;option value=""&gt;Select a country&lt;/option&gt;
    {#each countries as country}
        &lt;option value={country}&gt;{country}&lt;/option&gt;
    {/each}
&lt;/select&gt;

&lt;p&gt;Selected: {selectedCountry || "None"}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Select with Objects</li>
    <br/>
    <ul>
        <li>Select elements can bind to object values:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Country {
        code: string;
        name: string;
        population: number;
    }

    const countries: Country[] = [
        { code: "US", name: "United States", population: 331000000 },
        { code: "JP", name: "Japan",         population: 125800000 },
        { code: "DE", name: "Germany",       population: 83200000 }
    ];

    const selectedCountry: Country | undefined = $state(undefined);
&lt;/script&gt;

&lt;select bind:value={selectedCountry}&gt;
    &lt;option value={undefined}&gt;Select a country&lt;/option&gt;
    {#each countries as country}
        &lt;option value={country}&gt;{country.name}&lt;/option&gt;
    {/each}
&lt;/select&gt;

{#if selectedCountry}
    &lt;p&gt;{selectedCountry.name}: {selectedCountry.population.toLocaleString()} people&lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Multiple Select Binding</li>
    <br/>
    <ul>
        <li>Bind a multi-select to an array:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const selectedSkills: string[] = $state([]);

    const skills: string[] = ["JavaScript", "TypeScript", "Python", "Rust", "Go"];
&lt;/script&gt;

&lt;select multiple bind:value={selectedSkills}&gt;
    {#each skills as skill}
        &lt;option value={skill}&gt;{skill}&lt;/option&gt;
    {/each}
&lt;/select&gt;

&lt;p&gt;Selected: {selectedSkills.join(", ") || "None"}&lt;/p&gt;
</code></pre>

    <ul>
        <li>Hold Ctrl/Cmd to select multiple options.</li>
    </ul>
    <br/><br/>



    <li>Textarea Binding</li>
    <br/>
    <ul>
        <li>Bind a textarea's content:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    const bio: string = $state("");
&lt;/script&gt;

&lt;textarea bind:value={bio} rows="4" cols="50"&gt;&lt;/textarea&gt;

&lt;p&gt;Character count: {bio.length}&lt;/p&gt;
&lt;p&gt;Preview:&lt;/p&gt;
&lt;pre&gt;{bio}&lt;/pre&gt;
</code></pre>
    <br/><br/>



    <li>Contenteditable Binding</li>
    <br/>
    <ul>
        <li>Bind to <code>contenteditable</code> elements using <code>textContent</code> or <code>innerHTML</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let plainText: string = $state("Edit this text");
    let richText: string = $state("&lt;b&gt;Bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt;");
&lt;/script&gt;

&lt;!-- Plain text binding --&gt;
&lt;div contenteditable="true" bind:textContent={plainText}&gt;&lt;/div&gt;
&lt;p&gt;Plain: {plainText}&lt;/p&gt;

&lt;!-- HTML binding --&gt;
&lt;div contenteditable="true" bind:innerHTML={richText}&gt;&lt;/div&gt;
&lt;p&gt;HTML: {richText}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>bind:textContent</code> — Gets/sets plain text only.</li>
        <li><code>bind:innerHTML</code> — Gets/sets HTML content.</li>
    </ul>
    <br/><br/>



    <li>Element Reference Binding (<code>bind:this</code>)</li>
    <br/>
    <ul>
        <li>Get a reference to a DOM element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { onMount } from "svelte";

    let inputElement: HTMLInputElement;
    let canvasElement: HTMLCanvasElement;

    onMount(() =&gt; {
        // Focus the input on mount
        inputElement.focus();

        // Draw on canvas
        const ctx = canvasElement.getContext("2d");
        if (ctx) {
            ctx.fillStyle = "blue";
            ctx.fillRect(10, 10, 100, 100);
        }
    });
&lt;/script&gt;

&lt;input bind:this={inputElement} placeholder="Auto-focused" /&gt;
&lt;canvas bind:this={canvasElement} width="200" height="150"&gt;&lt;/canvas&gt;
</code></pre>

    <ul>
        <li>The element is <code>undefined</code> until the component mounts.</li>
        <li>Use <code>onMount</code> or <code>$effect</code> to safely access the element.</li>
    </ul>
    <br/><br/>



    <li>Element Reference with Svelte 5</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <code>$effect</code> to work with element references:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let inputElement: HTMLInputElement | undefined = $state(undefined);

    $effect(() =&gt; {
        if (inputElement) {
            inputElement.focus();
        }
    });
&lt;/script&gt;

&lt;input bind:this={inputElement} placeholder="Auto-focused" /&gt;
</code></pre>
    <br/><br/>



    <li>Dimension Bindings</li>
    <br/>
    <ul>
        <li>Bind to an element's dimensions (read-only):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let clientWidth: number = $state(0);
    let clientHeight: number = $state(0);
    let offsetWidth: number = $state(0);
    let offsetHeight: number = $state(0);
&lt;/script&gt;

&lt;div
    bind:clientWidth
    bind:clientHeight
    bind:offsetWidth
    bind:offsetHeight
    style="padding: 20px; border: 5px solid black;"
&gt;
    &lt;p&gt;Resize the window to see changes&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Client: {clientWidth} x {clientHeight}&lt;/p&gt;
&lt;p&gt;Offset: {offsetWidth} x {offsetHeight}&lt;/p&gt;
</code></pre>

    <ul>
        <li><code>clientWidth/Height</code> — Content + padding (excluding border and scrollbar).</li>
        <li><code>offsetWidth/Height</code> — Content + padding + border.</li>
    </ul>
    <br/><br/>



    <li>Media Element Bindings</li>
    <br/>
    <ul>
        <li>Bind to audio and video element properties:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let videoElement: HTMLVideoElement;

    // Readonly bindings
    let duration: number = $state(0);
    let buffered: TimeRanges;
    let seekable: TimeRanges;
    let played: TimeRanges;
    let seeking: boolean = $state(false);
    let ended: boolean = $state(false);
    let readyState: number = $state(0);
    let videoWidth: number = $state(0);
    let videoHeight: number = $state(0);

    // Two-way bindings
    let currentTime: number = $state(0);
    let playbackRate: number = $state(1);
    let paused: boolean = $state(true);
    let volume: number = $state(1);
    let muted: boolean = $state(false);

    function formatTime(seconds: number): string {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
    }
&lt;/script&gt;

&lt;video
    bind:this={videoElement}
    bind:duration
    bind:currentTime
    bind:paused
    bind:volume
    bind:muted
    bind:playbackRate
    bind:seeking
    bind:ended
    src="video.mp4"
    width="400"
&gt;
    &lt;track kind="captions" /&gt;
&lt;/video&gt;

&lt;div&gt;
    &lt;button onclick={() =&gt; paused = !paused}&gt;
        {paused ? "Play" : "Pause"}
    &lt;/button&gt;
    &lt;span&gt;{formatTime(currentTime)} / {formatTime(duration)}&lt;/span&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;label&gt;
        Volume:
        &lt;input type="range" bind:value={volume} min="0" max="1" step="0.1" /&gt;
    &lt;/label&gt;
    &lt;label&gt;
        &lt;input type="checkbox" bind:checked={muted} /&gt;
        Muted
    &lt;/label&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;label&gt;
        Speed:
        &lt;select bind:value={playbackRate}&gt;
            &lt;option value={0.5}&gt;0.5x&lt;/option&gt;
            &lt;option value={1}&gt;1x&lt;/option&gt;
            &lt;option value={1.5}&gt;1.5x&lt;/option&gt;
            &lt;option value={2}&gt;2x&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Window Bindings</li>
    <br/>
    <ul>
        <li>Bind to window properties using <code>&lt;svelte:window&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Readonly
    let innerWidth: number = $state(0);
    let innerHeight: number = $state(0);
    let outerWidth: number = $state(0);
    let outerHeight: number = $state(0);
    let online: boolean = $state(true);

    // Two-way
    let scrollX: number = $state(0);
    let scrollY: number = $state(0);
&lt;/script&gt;

&lt;svelte:window
    bind:innerWidth
    bind:innerHeight
    bind:outerWidth
    bind:outerHeight
    bind:scrollX
    bind:scrollY
    bind:online
/&gt;

&lt;div style="position: fixed; top: 10px; right: 10px; background: white; padding: 10px;"&gt;
    &lt;p&gt;Window: {innerWidth} x {innerHeight}&lt;/p&gt;
    &lt;p&gt;Scroll: {scrollX}, {scrollY}&lt;/p&gt;
    &lt;p&gt;Online: {online ? "Yes" : "No"}&lt;/p&gt;
&lt;/div&gt;

&lt;button onclick={() =&gt; scrollY = 0}&gt;Scroll to top&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Document Bindings</li>
    <br/>
    <ul>
        <li>Bind to document properties using <code>&lt;svelte:document&gt;</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let activeElement: Element | null = $state(null);
    let fullscreenElement: Element | null = $state(null);
    let pointerLockElement: Element | null = $state(null);
    let visibilityState: DocumentVisibilityState = $state("visible");
&lt;/script&gt;

&lt;svelte:document
    bind:activeElement
    bind:fullscreenElement
    bind:pointerLockElement
    bind:visibilityState
/&gt;

&lt;p&gt;Active element: {activeElement?.tagName || "None"}&lt;/p&gt;
&lt;p&gt;Visibility: {visibilityState}&lt;/p&gt;

&lt;input placeholder="Focus me" /&gt;
&lt;button&gt;Or focus me&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Component Bindings</li>
    <br/>
    <ul>
        <li>Bind to a child component's exported values (Svelte 4):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let count: number = 0;

    export function reset(): void {
        count = 0;
    }
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;{count}&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let counterValue: number;
    let counterComponent: Counter;
&lt;/script&gt;

&lt;Counter bind:count={counterValue} bind:this={counterComponent} /&gt;

&lt;p&gt;Counter value: {counterValue}&lt;/p&gt;
&lt;button on:click={() =&gt; counterComponent.reset()}&gt;Reset&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Component Bindings (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use <code>$bindable</code> for props that can be bound:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        count?: number;
    }

    let { count = $bindable(0) }: Props = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;{count}&lt;/button&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    import Counter from "./Counter.svelte";

    let counterValue: number = $state(0);
&lt;/script&gt;

&lt;Counter bind:count={counterValue} /&gt;

&lt;p&gt;Counter value: {counterValue}&lt;/p&gt;
&lt;button onclick={() =&gt; counterValue = 0}&gt;Reset&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>$bindable()</code> marks a prop as bindable with an optional default value.</li>
        <li>Changes in either parent or child sync both ways.</li>
    </ul>
    <br/><br/>



    <li>Binding Shorthand</li>
    <br/>
    <ul>
        <li>When the variable name matches the property name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let value: string = $state("");
    let checked: boolean = $state(false);
    let clientWidth: number = $state(0);
    let innerWidth: number = $state(0);
&lt;/script&gt;

&lt;!-- These are equivalent: --&gt;
&lt;input bind:value={value} /&gt;
&lt;input bind:value /&gt;

&lt;input type="checkbox" bind:checked={checked} /&gt;
&lt;input type="checkbox" bind:checked /&gt;

&lt;div bind:clientWidth={clientWidth}&gt;...&lt;/div&gt;
&lt;div bind:clientWidth&gt;...&lt;/div&gt;

&lt;svelte:window bind:innerWidth={innerWidth} /&gt;
&lt;svelte:window bind:innerWidth /&gt;
</code></pre>
    <br/><br/>



    <li>Binding Summary</li>
    <br/>

    <table>
        <tr>
            <th>Element</th>
            <th>Binding</th>
            <th>Type</th>
        </tr>
        <tr>
            <td>Text input</td>
            <td><code>bind:value</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Number/Range input</td>
            <td><code>bind:value</code></td>
            <td><code>number</code></td>
        </tr>
        <tr>
            <td>Checkbox</td>
            <td><code>bind:checked</code></td>
            <td><code>boolean</code></td>
        </tr>
        <tr>
            <td>Checkbox group</td>
            <td><code>bind:group</code></td>
            <td><code>Array</code></td>
        </tr>
        <tr>
            <td>Radio group</td>
            <td><code>bind:group</code></td>
            <td>Single value</td>
        </tr>
        <tr>
            <td>Select</td>
            <td><code>bind:value</code></td>
            <td>Any</td>
        </tr>
        <tr>
            <td>Multi-select</td>
            <td><code>bind:value</code></td>
            <td><code>Array</code></td>
        </tr>
        <tr>
            <td>Textarea</td>
            <td><code>bind:value</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Contenteditable</td>
            <td><code>bind:textContent</code>, <code>bind:innerHTML</code></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td>Any element</td>
            <td><code>bind:this</code></td>
            <td><code>HTMLElement</code></td>
        </tr>
        <tr>
            <td>Any element</td>
            <td><code>bind:clientWidth</code>, etc.</td>
            <td><code>number</code> (readonly)</td>
        </tr>
        <tr>
            <td>Audio/Video</td>
            <td><code>bind:currentTime</code>, <code>bind:paused</code>, etc.</td>
            <td>Various</td>
        </tr>
        <tr>
            <td><code>&lt;svelte:window&gt;</code></td>
            <td><code>bind:innerWidth</code>, <code>bind:scrollY</code>, etc.</td>
            <td><code>number</code></td>
        </tr>
        <tr>
            <td>Component (Svelte 5)</td>
            <td><code>bind:prop</code> with <code>$bindable</code></td>
            <td>Any</td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-classes">Svelte Classes</h3>
<ol>
    <li>What Are Class Directives?</li>
    <br/>
    <ul>
        <li>Svelte provides special syntax for dynamically adding and removing CSS classes.</li>
        <br/>
        <li>The <code>class:</code> directive conditionally applies a class based on a boolean expression.</li>
        <br/>
        <li>This is cleaner than manually building class strings.</li>
    </ul>
    <br/><br/>



    <li>Basic Class Attribute</li>
    <br/>
    <ul>
        <li>You can use the standard <code>class</code> attribute:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let className: string = "button primary";
&lt;/script&gt;

&lt;button class="button"&gt;Static class&lt;/button&gt;
&lt;button class={className}&gt;Dynamic class&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Conditional Classes with Ternary</li>
    <br/>
    <ul>
        <li>Use template expressions to conditionally apply classes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(false);
    let isDisabled: boolean = $state(false);
&lt;/script&gt;

&lt;button class={isActive ? "active" : ""}&gt;
    Toggle
&lt;/button&gt;

&lt;button class={isActive ? "btn active" : "btn"}&gt;
    With base class
&lt;/button&gt;

&lt;button class="btn {isActive ? 'active' : ''} {isDisabled ? 'disabled' : ''}"&gt;
    Multiple conditions
&lt;/button&gt;
</code></pre>

    <ul>
        <li>This works but can become verbose with multiple conditions.</li>
    </ul>
    <br/><br/>



    <li>The <code>class:</code> Directive</li>
    <br/>
    <ul>
        <li>The <code>class:</code> directive provides a cleaner syntax:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(false);
&lt;/script&gt;

&lt;button class:active={isActive}&gt;
    Toggle
&lt;/button&gt;

&lt;!-- The class "active" is added when isActive is true --&gt;

&lt;style&gt;
    .active {
        background-color: #4CAF50;
        color: white;
    }
&lt;/style&gt;
</code></pre>

    <ul>
        <li>Syntax: <code>class:classname={condition}</code></li>
        <li>When <code>condition</code> is truthy, <code>classname</code> is added.</li>
    </ul>
    <br/><br/>



    <li>Shorthand <code>class:</code> Directive</li>
    <br/>
    <ul>
        <li>When the class name matches the variable name, use the shorthand:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let active: boolean = $state(false);
    let disabled: boolean = $state(false);
    let hidden: boolean = $state(false);
&lt;/script&gt;

&lt;!-- These are equivalent: --&gt;
&lt;button class:active={active}&gt;Long form&lt;/button&gt;
&lt;button class:active&gt;Shorthand&lt;/button&gt;

&lt;!-- Multiple shorthand classes --&gt;
&lt;button class:active class:disabled class:hidden&gt;
    Multiple
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Multiple Class Directives</li>
    <br/>
    <ul>
        <li>Apply multiple conditional classes to one element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isActive: boolean = $state(true);
    let isLarge: boolean = $state(false);
    let isPrimary: boolean = $state(true);
    let isDisabled: boolean = $state(false);
&lt;/script&gt;

&lt;button
    class="btn"
    class:active={isActive}
    class:large={isLarge}
    class:primary={isPrimary}
    class:disabled={isDisabled}
&gt;
    Styled Button
&lt;/button&gt;

&lt;style&gt;
    .btn {
        padding: 10px 20px;
        border: none;
        cursor: pointer;
    }
    .active { border: 2px solid blue; }
    .large { font-size: 1.5rem; padding: 15px 30px; }
    .primary { background-color: #007bff; color: white; }
    .disabled { opacity: 0.5; cursor: not-allowed; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Combining <code>class</code> and <code>class:</code></li>
    <br/>
    <ul>
        <li>Use both static classes and conditional class directives together:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let variant: string = $state("primary");
    let isLoading: boolean = $state(false);
    let isFullWidth: boolean = $state(false);
&lt;/script&gt;

&lt;button
    class="btn btn-{variant}"
    class:loading={isLoading}
    class:full-width={isFullWidth}
&gt;
    {isLoading ? "Loading..." : "Submit"}
&lt;/button&gt;

&lt;style&gt;
    .btn { padding: 10px 20px; }
    .btn-primary { background: blue; color: white; }
    .btn-secondary { background: gray; color: white; }
    .btn-danger { background: red; color: white; }
    .loading { opacity: 0.7; pointer-events: none; }
    .full-width { width: 100%; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Directive with Expressions</li>
    <br/>
    <ul>
        <li>The condition can be any JavaScript expression:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let status: string = $state("pending");
    let items: string[] = $state(["a", "b"]);
&lt;/script&gt;

&lt;!-- Comparison expressions --&gt;
&lt;div class:warning={count &gt; 5}&gt;Count warning&lt;/div&gt;
&lt;div class:danger={count &gt; 10}&gt;Count danger&lt;/div&gt;

&lt;!-- Equality checks --&gt;
&lt;div class:success={status === "completed"}&gt;Status&lt;/div&gt;
&lt;div class:pending={status === "pending"}&gt;Status&lt;/div&gt;

&lt;!-- Array/Object checks --&gt;
&lt;div class:empty={items.length === 0}&gt;Items&lt;/div&gt;
&lt;div class:has-items={items.length &gt; 0}&gt;Items&lt;/div&gt;

&lt;!-- Logical expressions --&gt;
&lt;div class:special={count &gt; 5 && status === "completed"}&gt;
    Special
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Dynamic Class Names</li>
    <br/>
    <ul>
        <li>Build class names dynamically using template literals:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let size: "sm" | "md" | "lg" = $state("md");
    let color: "red" | "green" | "blue" = $state("blue");
    let theme: "light" | "dark" = $state("light");
&lt;/script&gt;

&lt;button class="btn btn-{size} btn-{color}"&gt;
    Dynamic Size &amp; Color
&lt;/button&gt;

&lt;div class="container theme-{theme}"&gt;
    Themed Container
&lt;/div&gt;

&lt;!-- With conditional fallback --&gt;
&lt;div class="icon icon-{status || 'default'}"&gt;
    Icon
&lt;/div&gt;

&lt;style&gt;
    .btn-sm { padding: 5px 10px; font-size: 0.8rem; }
    .btn-md { padding: 10px 20px; font-size: 1rem; }
    .btn-lg { padding: 15px 30px; font-size: 1.2rem; }
    .btn-red { background: red; }
    .btn-green { background: green; }
    .btn-blue { background: blue; }
    .theme-light { background: white; color: black; }
    .theme-dark { background: #333; color: white; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Object Pattern</li>
    <br/>
    <ul>
        <li>Create a utility function for complex class logic:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    // Utility function to build class string from object
    function classNames(classes: Record&lt;string, boolean&gt;): string {
        return Object.entries(classes)
            .filter(([, value]) =&gt; value)
            .map(([key]) =&gt; key)
            .join(" ");
    }

    let isActive: boolean = $state(true);
    let isDisabled: boolean = $state(false);
    let size: string = $state("large");

    let buttonClasses = $derived(classNames({
        "btn": true,
        "btn-active": isActive,
        "btn-disabled": isDisabled,
        "btn-large": size === "large",
        "btn-small": size === "small"
    }));
&lt;/script&gt;

&lt;button class={buttonClasses}&gt;
    Dynamic Classes
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Using <code>clsx</code> or <code>classnames</code> Library</li>
    <br/>
    <ul>
        <li>For complex class logic, use a utility library like <code>clsx</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm install clsx
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import clsx from "clsx";

    let isActive: boolean = $state(false);
    let isDisabled: boolean = $state(false);
    let variant: "primary" | "secondary" = $state("primary");

    let classes = $derived(clsx(
        "btn",
        `btn-${variant}`,
        {
            "active": isActive,
            "disabled": isDisabled
        }
    ));
&lt;/script&gt;

&lt;button class={classes}&gt;
    Using clsx
&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>clsx</code> handles strings, objects, arrays, and falsy values gracefully.</li>
    </ul>
    <br/><br/>



    <li>Classes in Loops</li>
    <br/>
    <ul>
        <li>Apply conditional classes to items in a loop:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Item {
        id: number;
        name: string;
        completed: boolean;
        priority: "low" | "medium" | "high";
    }

    let items: Item[] = $state([
        { id: 1, name: "Task 1", completed: false, priority: "high" },
        { id: 2, name: "Task 2", completed: true, priority: "low" },
        { id: 3, name: "Task 3", completed: false, priority: "medium" }
    ]);

    let selectedId: number | null = $state(null);
&lt;/script&gt;

&lt;ul&gt;
    {#each items as item (item.id)}
        &lt;li
            class="item priority-{item.priority}"
            class:completed={item.completed}
            class:selected={selectedId === item.id}
            onclick={() =&gt; selectedId = item.id}
        &gt;
            {item.name}
        &lt;/li&gt;
    {/each}
&lt;/ul&gt;

&lt;style&gt;
    .item { padding: 10px; cursor: pointer; }
    .completed { text-decoration: line-through; opacity: 0.6; }
    .selected { background-color: #e0e0e0; }
    .priority-low { border-left: 3px solid green; }
    .priority-medium { border-left: 3px solid orange; }
    .priority-high { border-left: 3px solid red; }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Global Classes vs Scoped Classes</li>
    <br/>
    <ul>
        <li>Svelte styles are <u>scoped by default</u> — they only apply to the current component.</li>
        <br/>
        <li>Use <code>:global()</code> to apply styles globally:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let isDark: boolean = $state(false);
&lt;/script&gt;

&lt;div class="container" class:dark={isDark}&gt;
    &lt;p&gt;This is styled locally.&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    /* Scoped to this component */
    .container {
        padding: 20px;
        background: white;
    }

    .dark {
        background: #333;
        color: white;
    }

    /* Global style - affects all elements */
    :global(.global-class) {
        font-weight: bold;
    }

    /* Global modifier within scoped context */
    .container :global(.highlight) {
        background-color: yellow;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Passing Classes to Child Components</li>
    <br/>
    <ul>
        <li>Accept a <code>class</code> prop to allow parent customization:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Button.svelte --&gt;
&lt;script lang="ts"&gt;
    interface Props {
        variant?: "primary" | "secondary";
        class?: string;
    }

    let { variant = "primary", class: className = "" }: Props = $props();
&lt;/script&gt;

&lt;button class="btn btn-{variant} {className}"&gt;
    &lt;slot /&gt;
&lt;/button&gt;

&lt;style&gt;
    .btn { padding: 10px 20px; border: none; cursor: pointer; }
    .btn-primary { background: blue; color: white; }
    .btn-secondary { background: gray; color: white; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.svelte --&gt;
&lt;script lang="ts"&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;Button class="my-custom-class"&gt;Click me&lt;/Button&gt;
&lt;Button variant="secondary" class="full-width"&gt;Submit&lt;/Button&gt;

&lt;style&gt;
    :global(.my-custom-class) {
        margin: 10px;
    }
    :global(.full-width) {
        width: 100%;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Using <code>$$restProps</code> for Class Forwarding (Svelte 4)</li>
    <br/>
    <ul>
        <li>Forward all attributes including <code>class</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Input.svelte (Svelte 4) --&gt;
&lt;script lang="ts"&gt;
    export let label: string = "";
&lt;/script&gt;

&lt;label&gt;
    {label}
    &lt;input {...$$restProps} /&gt;
&lt;/label&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Input label="Email" class="form-input" type="email" placeholder="Enter email" /&gt;
</code></pre>
    <br/><br/>



    <li>Using Rest Props for Class Forwarding (Svelte 5)</li>
    <br/>
    <ul>
        <li>In Svelte 5, use rest props destructuring:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Input.svelte (Svelte 5) --&gt;
&lt;script lang="ts"&gt;
    import type { HTMLInputAttributes } from "svelte/elements";

    interface Props extends HTMLInputAttributes {
        label?: string;
    }

    let { label = "", ...rest }: Props = $props();
&lt;/script&gt;

&lt;label&gt;
    {label}
    &lt;input {...rest} /&gt;
&lt;/label&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Usage --&gt;
&lt;Input label="Email" class="form-input" type="email" placeholder="Enter email" /&gt;
</code></pre>
    <br/><br/>



    <li>Animated Class Transitions</li>
    <br/>
    <ul>
        <li>Combine class toggling with CSS transitions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let expanded: boolean = $state(false);
    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; expanded = !expanded}&gt;
    Toggle Expand
&lt;/button&gt;

&lt;div class="box" class:expanded&gt;
    &lt;p&gt;Content here&lt;/p&gt;
&lt;/div&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle Visibility
&lt;/button&gt;

&lt;div class="fade-box" class:visible&gt;
    &lt;p&gt;Fading content&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    .box {
        height: 50px;
        overflow: hidden;
        background: #f0f0f0;
        transition: height 0.3s ease;
    }

    .box.expanded {
        height: 200px;
    }

    .fade-box {
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .fade-box.visible {
        opacity: 1;
        transform: translateY(0);
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Class Directive Summary</li>
    <br/>

    <table>
        <tr>
            <th>Syntax</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><code>class="name"</code></td>
            <td>Static class</td>
            <td><code>&lt;div class="container"&gt;</code></td>
        </tr>
        <tr>
            <td><code>class={expr}</code></td>
            <td>Dynamic class string</td>
            <td><code>&lt;div class={className}&gt;</code></td>
        </tr>
        <tr>
            <td><code>class="a {b}"</code></td>
            <td>Mixed static + dynamic</td>
            <td><code>&lt;div class="btn {variant}"&gt;</code></td>
        </tr>
        <tr>
            <td><code>class:name={cond}</code></td>
            <td>Conditional class</td>
            <td><code>&lt;div class:active={isActive}&gt;</code></td>
        </tr>
        <tr>
            <td><code>class:name</code></td>
            <td>Shorthand (name === var)</td>
            <td><code>&lt;div class:active&gt;</code></td>
        </tr>
        <tr>
            <td>Multiple <code>class:</code></td>
            <td>Multiple conditionals</td>
            <td><code>&lt;div class:a class:b class:c&gt;</code></td>
        </tr>
        <tr>
            <td><code>:global()</code></td>
            <td>Escape scoping</td>
            <td><code>:global(.class) { }</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-actions">Svelte Actions</h3>
<ol>
    <li>What Are Actions?</li>
    <br/>
    <ul>
        <li><b>Actions</b> are functions that run when an element is mounted to the DOM.</li>
        <br/>
        <li>They provide a way to add <u>reusable behavior</u> to elements without creating wrapper components.</li>
        <br/>
        <li>Actions are applied using the <code>use:</code> directive.</li>
    </ul>
    <br/><br/>



    <li>Basic Action Syntax</li>
    <br/>
    <ul>
        <li>An action is a function that receives the element as its first argument:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    function greet(node: HTMLElement): void {
        console.log("Element mounted:", node);
    }
&lt;/script&gt;

&lt;div use:greet&gt;
    Hello, World!
&lt;/div&gt;
</code></pre>

    <ul>
        <li>The function runs once when the element is added to the DOM.</li>
    </ul>
    <br/><br/>



    <li>Action with Cleanup</li>
    <br/>
    <ul>
        <li>Return an object with a <code>destroy</code> method to clean up when the element is removed:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    function logger(node: HTMLElement): ActionReturn {
        console.log("Mounted:", node);

        return {
            destroy() {
                console.log("Destroyed:", node);
            }
        };
    }
&lt;/script&gt;

&lt;div use:logger&gt;
    Watch the console
&lt;/div&gt;
</code></pre>

    <ul>
        <li>The <code>destroy</code> function is called when the element is removed from the DOM.</li>
        <li>Use it to remove event listeners, clear timers, or clean up resources.</li>
    </ul>
    <br/><br/>



    <li>Action with Parameters</li>
    <br/>
    <ul>
        <li>Actions can accept parameters as the second argument:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface TooltipParams {
        text: string;
        position?: "top" | "bottom" | "left" | "right";
    }

    function tooltip(node: HTMLElement, params: TooltipParams): ActionReturn&lt;TooltipParams&gt; {
        const { text, position = "top" } = params;

        node.setAttribute("title", text);
        node.setAttribute("data-position", position);

        console.log(`Tooltip: "${text}" at ${position}`);

        return {
            destroy() {
                node.removeAttribute("title");
                node.removeAttribute("data-position");
            }
        };
    }
&lt;/script&gt;

&lt;button use:tooltip={{ text: "Click to submit", position: "bottom" }}&gt;
    Submit
&lt;/button&gt;

&lt;button use:tooltip={{ text: "Cancel operation" }}&gt;
    Cancel
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Action with Update</li>
    <br/>
    <ul>
        <li>Return an <code>update</code> method to react when parameters change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ColorParams {
        color: string;
    }

    function backgroundColor(node: HTMLElement, params: ColorParams): ActionReturn&lt;ColorParams&gt; {
        node.style.backgroundColor = params.color;

        return {
            update(newParams: ColorParams) {
                node.style.backgroundColor = newParams.color;
            },
            destroy() {
                node.style.backgroundColor = "";
            }
        };
    }

    const color: string = $state("#ff0000");
&lt;/script&gt;

&lt;input type="color" bind:value={color} /&gt;

&lt;div use:backgroundColor={{ color }} style="padding: 20px;"&gt;
    Dynamic background color
&lt;/div&gt;
</code></pre>

    <ul>
        <li>The <code>update</code> function is called whenever the parameters change.</li>
    </ul>
    <br/><br/>



    <li>Typing Actions with <code>ActionReturn</code></li>
    <br/>
    <ul>
        <li>Use the <code>ActionReturn</code> type for proper TypeScript support:</li>
    </ul>

<pre><code class="language-ts line-numbers">import type { ActionReturn } from "svelte/action";

// Action without parameters
function simpleAction(node: HTMLElement): ActionReturn {
    return {
        destroy() {}
    };
}

// Action with required parameters
function paramAction(node: HTMLElement, params: string): ActionReturn&lt;string&gt; {
    return {
        update(newParams: string) {},
        destroy() {}
    };
}

// Action with optional parameters
function optionalAction(node: HTMLElement, params?: number): ActionReturn&lt;number | undefined&gt; {
    return {
        update(newParams?: number) {},
        destroy() {}
    };
}
</code></pre>
    <br/><br/>



    <li>Using the <code>Action</code> Type</li>
    <br/>
    <ul>
        <li>You can also use the <code>Action</code> type to define action signatures:</li>
    </ul>

<pre><code class="language-ts line-numbers">import type { Action } from "svelte/action";

interface FocusTrapParams {
    enabled?: boolean;
}

const focusTrap: Action&lt;HTMLElement, FocusTrapParams&gt; = (node, params) =&gt; {
    // Implementation
    return {
        update(newParams) {
            // Handle updates
        },
        destroy() {
            // Cleanup
        }
    };
};
</code></pre>
    <br/><br/>



    <li>Click Outside Action</li>
    <br/>
    <ul>
        <li>A common action to detect clicks outside an element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ClickOutsideParams {
        onClickOutside: () =&gt; void;
    }

    function clickOutside(node: HTMLElement, params: ClickOutsideParams): ActionReturn&lt;ClickOutsideParams&gt; {
        let { onClickOutside } = params;

        function handleClick(event: MouseEvent): void {
            if (!node.contains(event.target as Node)) {
                onClickOutside();
            }
        }

        document.addEventListener("click", handleClick, true);

        return {
            update(newParams: ClickOutsideParams) {
                onClickOutside = newParams.onClickOutside;
            },
            destroy() {
                document.removeEventListener("click", handleClick, true);
            }
        };
    }

    let showDropdown: boolean = $state(false);
&lt;/script&gt;

&lt;div class="dropdown-container"&gt;
    &lt;button onclick={() =&gt; showDropdown = !showDropdown}&gt;
        Toggle Dropdown
    &lt;/button&gt;

    {#if showDropdown}
        &lt;div
            class="dropdown"
            use:clickOutside={{ onClickOutside: () =&gt; showDropdown = false }}
        &gt;
            &lt;p&gt;Dropdown content&lt;/p&gt;
            &lt;p&gt;Click outside to close&lt;/p&gt;
        &lt;/div&gt;
    {/if}
&lt;/div&gt;

&lt;style&gt;
    .dropdown-container { position: relative; }
    .dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        background: white;
        border: 1px solid #ccc;
        padding: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Auto Focus Action</li>
    <br/>
    <ul>
        <li>Automatically focus an element when mounted:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface FocusParams {
        delay?: number;
        select?: boolean;
    }

    function autoFocus(node: HTMLElement, params: FocusParams = {}): ActionReturn&lt;FocusParams&gt; {
        const { delay = 0, select = false } = params;

        const timeoutId = setTimeout(() =&gt; {
            node.focus();
            if (select && node instanceof HTMLInputElement) {
                node.select();
            }
        }, delay);

        return {
            destroy() {
                clearTimeout(timeoutId);
            }
        };
    }

    let showModal: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; showModal = true}&gt;Open Modal&lt;/button&gt;

{#if showModal}
    &lt;div class="modal"&gt;
        &lt;input
            use:autoFocus={{ select: true }}
            value="Selected text"
        /&gt;
        &lt;button onclick={() =&gt; showModal = false}&gt;Close&lt;/button&gt;
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Longpress Action</li>
    <br/>
    <ul>
        <li>Detect long press gestures:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface LongpressParams {
        duration?: number;
        onLongpress: () =&gt; void;
    }

    function longpress(node: HTMLElement, params: LongpressParams): ActionReturn&lt;LongpressParams&gt; {
        let { duration = 500, onLongpress } = params;
        let timeoutId: ReturnType&lt;typeof setTimeout&gt;;

        function handleMouseDown(): void {
            timeoutId = setTimeout(() =&gt; {
                onLongpress();
            }, duration);
        }

        function handleMouseUp(): void {
            clearTimeout(timeoutId);
        }

        node.addEventListener("mousedown", handleMouseDown);
        node.addEventListener("mouseup", handleMouseUp);
        node.addEventListener("mouseleave", handleMouseUp);

        return {
            update(newParams: LongpressParams) {
                duration = newParams.duration ?? 500;
                onLongpress = newParams.onLongpress;
            },
            destroy() {
                clearTimeout(timeoutId);
                node.removeEventListener("mousedown", handleMouseDown);
                node.removeEventListener("mouseup", handleMouseUp);
                node.removeEventListener("mouseleave", handleMouseUp);
            }
        };
    }

    let message: string = $state("Press and hold the button");
&lt;/script&gt;

&lt;button use:longpress={{ duration: 1000, onLongpress: () =&gt; message = "Longpress detected!" }}&gt;
    Hold me
&lt;/button&gt;

&lt;p&gt;{message}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Lazy Load Image Action</li>
    <br/>
    <ul>
        <li>Lazy load images using Intersection Observer:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface LazyLoadParams {
        src: string;
        placeholder?: string;
    }

    function lazyLoad(node: HTMLImageElement, params: LazyLoadParams): ActionReturn&lt;LazyLoadParams&gt; {
        let { src, placeholder = "" } = params;

        // Set placeholder initially
        if (placeholder) {
            node.src = placeholder;
        }

        const observer = new IntersectionObserver(
            (entries) =&gt; {
                entries.forEach((entry) =&gt; {
                    if (entry.isIntersecting) {
                        node.src = src;
                        observer.unobserve(node);
                    }
                });
            },
            { rootMargin: "50px" }
        );

        observer.observe(node);

        return {
            update(newParams: LazyLoadParams) {
                src = newParams.src;
                if (newParams.placeholder) {
                    placeholder = newParams.placeholder;
                }
            },
            destroy() {
                observer.disconnect();
            }
        };
    }

    const images: string[] = [
        "https://picsum.photos/400/300?1",
        "https://picsum.photos/400/300?2",
        "https://picsum.photos/400/300?3"
    ];
&lt;/script&gt;

{#each images as src, i}
    &lt;img
        use:lazyLoad={{ src, placeholder: "placeholder.jpg" }}
        alt="Lazy loaded image {i + 1}"
        width="400"
        height="300"
    /&gt;
{/each}
</code></pre>
    <br/><br/>



    <li>Portal Action</li>
    <br/>
    <ul>
        <li>Move an element to a different location in the DOM:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface PortalParams {
        target?: string | HTMLElement;
    }

    function portal(node: HTMLElement, params: PortalParams = {}): ActionReturn&lt;PortalParams&gt; {
        let targetEl: HTMLElement;

        function update(newParams: PortalParams): void {
            const { target = "body" } = newParams;

            if (typeof target === "string") {
                targetEl = document.querySelector(target) ?? document.body;
            } else {
                targetEl = target;
            }

            targetEl.appendChild(node);
        }

        update(params);

        return {
            update,
            destroy() {
                node.remove();
            }
        };
    }

    let showModal: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; showModal = true}&gt;Open Modal&lt;/button&gt;

{#if showModal}
    &lt;div class="modal-overlay" use:portal&gt;
        &lt;div class="modal-content"&gt;
            &lt;h2&gt;Modal Title&lt;/h2&gt;
            &lt;p&gt;This is rendered at the end of body.&lt;/p&gt;
            &lt;button onclick={() =&gt; showModal = false}&gt;Close&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
{/if}

&lt;style&gt;
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Resize Observer Action</li>
    <br/>
    <ul>
        <li>Track element size changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ResizeParams {
        onResize: (width: number, height: number) =&gt; void;
    }

    function resize(node: HTMLElement, params: ResizeParams): ActionReturn&lt;ResizeParams&gt; {
        let { onResize } = params;

        const observer = new ResizeObserver((entries) =&gt; {
            for (const entry of entries) {
                const { width, height } = entry.contentRect;
                onResize(width, height);
            }
        });

        observer.observe(node);

        return {
            update(newParams: ResizeParams) {
                onResize = newParams.onResize;
            },
            destroy() {
                observer.disconnect();
            }
        };
    }

    let width: number = $state(0);
    let height: number = $state(0);
&lt;/script&gt;

&lt;div
    class="resizable"
    use:resize={{ onResize: (w, h) =&gt; { width = w; height = h; } }}
&gt;
    &lt;p&gt;Resize me!&lt;/p&gt;
    &lt;p&gt;{width.toFixed(0)} x {height.toFixed(0)}&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
    .resizable {
        resize: both;
        overflow: auto;
        border: 2px solid #333;
        padding: 20px;
        min-width: 100px;
        min-height: 100px;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Intersection Observer Action</li>
    <br/>
    <ul>
        <li>Detect when an element enters or leaves the viewport:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface InViewParams {
        onEnter?: () =&gt; void;
        onLeave?: () =&gt; void;
        threshold?: number;
        once?: boolean;
    }

    function inView(node: HTMLElement, params: InViewParams = {}): ActionReturn&lt;InViewParams&gt; {
        let { onEnter, onLeave, threshold = 0, once = false } = params;

        const observer = new IntersectionObserver(
            (entries) =&gt; {
                entries.forEach((entry) =&gt; {
                    if (entry.isIntersecting) {
                        onEnter?.();
                        if (once) {
                            observer.unobserve(node);
                        }
                    } else {
                        onLeave?.();
                    }
                });
            },
            { threshold }
        );

        observer.observe(node);

        return {
            update(newParams: InViewParams) {
                onEnter = newParams.onEnter;
                onLeave = newParams.onLeave;
            },
            destroy() {
                observer.disconnect();
            }
        };
    }

    let isVisible: boolean = $state(false);
&lt;/script&gt;

&lt;div style="height: 150vh;"&gt;
    &lt;p&gt;Scroll down...&lt;/p&gt;
&lt;/div&gt;

&lt;div
    class="observed"
    class:visible={isVisible}
    use:inView={{
        onEnter: () =&gt; isVisible = true,
        onLeave: () =&gt; isVisible = false,
        threshold: 0.5
    }}
&gt;
    I'm being observed!
&lt;/div&gt;

&lt;style&gt;
    .observed {
        padding: 40px;
        background: #eee;
        transition: background 0.3s;
    }
    .observed.visible {
        background: #4CAF50;
        color: white;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Third-Party Library Integration</li>
    <br/>
    <ul>
        <li>Actions are ideal for integrating third-party libraries:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";
    // Assuming tippy.js is installed
    // import tippy, { type Instance, type Props } from "tippy.js";

    interface TippyParams {
        content: string;
        placement?: "top" | "bottom" | "left" | "right";
    }

    function tippyAction(node: HTMLElement, params: TippyParams): ActionReturn&lt;TippyParams&gt; {
        // const instance: Instance = tippy(node, {
        //     content: params.content,
        //     placement: params.placement ?? "top"
        // });

        // Simulated for demonstration
        node.title = params.content;

        return {
            update(newParams: TippyParams) {
                // instance.setContent(newParams.content);
                // instance.setProps({ placement: newParams.placement });
                node.title = newParams.content;
            },
            destroy() {
                // instance.destroy();
                node.removeAttribute("title");
            }
        };
    }
&lt;/script&gt;

&lt;button use:tippyAction={{ content: "Hello Tooltip!", placement: "bottom" }}&gt;
    Hover me
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Copy to Clipboard Action</li>
    <br/>
    <ul>
        <li>Copy text to clipboard on click:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface CopyParams {
        text: string;
        onCopy?: () =&gt; void;
        onError?: (error: Error) =&gt; void;
    }

    function copy(node: HTMLElement, params: CopyParams): ActionReturn&lt;CopyParams&gt; {
        let { text, onCopy, onError } = params;

        async function handleClick(): Promise&lt;void&gt; {
            try {
                await navigator.clipboard.writeText(text);
                onCopy?.();
            } catch (err) {
                onError?.(err as Error);
            }
        }

        node.addEventListener("click", handleClick);

        return {
            update(newParams: CopyParams) {
                text = newParams.text;
                onCopy = newParams.onCopy;
                onError = newParams.onError;
            },
            destroy() {
                node.removeEventListener("click", handleClick);
            }
        };
    }

    let copied: boolean = $state(false);
    const textToCopy: string = "Hello, World!";

    function handleCopy(): void {
        copied = true;
        setTimeout(() =&gt; copied = false, 2000);
    }
&lt;/script&gt;

&lt;code&gt;{textToCopy}&lt;/code&gt;

&lt;button use:copy={{ text: textToCopy, onCopy: handleCopy }}&gt;
    {copied ? "Copied!" : "Copy"}
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Shortcut / Hotkey Action</li>
    <br/>
    <ul>
        <li>Add keyboard shortcuts to elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    interface ShortcutParams {
        key: string;
        ctrl?: boolean;
        shift?: boolean;
        alt?: boolean;
        onTrigger: () =&gt; void;
    }

    function shortcut(node: HTMLElement, params: ShortcutParams): ActionReturn&lt;ShortcutParams&gt; {
        let { key, ctrl = false, shift = false, alt = false, onTrigger } = params;

        function handleKeyDown(event: KeyboardEvent): void {
            if (
                event.key.toLowerCase() === key.toLowerCase() &&
                event.ctrlKey === ctrl &&
                event.shiftKey === shift &&
                event.altKey === alt
            ) {
                event.preventDefault();
                onTrigger();
            }
        }

        window.addEventListener("keydown", handleKeyDown);

        return {
            update(newParams: ShortcutParams) {
                key = newParams.key;
                ctrl = newParams.ctrl ?? false;
                shift = newParams.shift ?? false;
                alt = newParams.alt ?? false;
                onTrigger = newParams.onTrigger;
            },
            destroy() {
                window.removeEventListener("keydown", handleKeyDown);
            }
        };
    }

    let count: number = $state(0);
&lt;/script&gt;

&lt;div use:shortcut={{ key: "k", ctrl: true, onTrigger: () =&gt; count++ }}&gt;
    &lt;p&gt;Press Ctrl+K to increment: {count}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Multiple Actions on One Element</li>
    <br/>
    <ul>
        <li>Apply multiple actions to a single element:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { ActionReturn } from "svelte/action";

    function logMount(node: HTMLElement): ActionReturn {
        console.log("Mounted");
        return { destroy() { console.log("Destroyed"); } };
    }

    function addBorder(node: HTMLElement, color: string): ActionReturn&lt;string&gt; {
        node.style.border = `2px solid ${color}`;
        return {
            update(newColor: string) {
                node.style.border = `2px solid ${newColor}`;
            },
            destroy() {
                node.style.border = "";
            }
        };
    }

    function autoFocus(node: HTMLElement): ActionReturn {
        node.focus();
        return {};
    }
&lt;/script&gt;

&lt;input
    use:logMount
    use:addBorder={"blue"}
    use:autoFocus
    placeholder="Multiple actions"
/&gt;
</code></pre>
    <br/><br/>



    <li>Actions Summary</li>
    <br/>

    <table>
        <tr>
            <th>Feature</th>
            <th>Description</th>
            <th>Syntax</th>
        </tr>
        <tr>
            <td>Basic action</td>
            <td>Function runs on mount</td>
            <td><code>use:action</code></td>
        </tr>
        <tr>
            <td>With parameter</td>
            <td>Pass data to action</td>
            <td><code>use:action={params}</code></td>
        </tr>
        <tr>
            <td><code>destroy</code></td>
            <td>Cleanup on unmount</td>
            <td><code>return { destroy() {} }</code></td>
        </tr>
        <tr>
            <td><code>update</code></td>
            <td>React to param changes</td>
            <td><code>return { update(p) {} }</code></td>
        </tr>
        <tr>
            <td>Type (function)</td>
            <td>Action return type</td>
            <td><code>ActionReturn&lt;Params&gt;</code></td>
        </tr>
        <tr>
            <td>Type (signature)</td>
            <td>Full action type</td>
            <td><code>Action&lt;Element, Params&gt;</code></td>
        </tr>
        <tr>
            <td>Multiple actions</td>
            <td>Combine on one element</td>
            <td><code>use:a use:b use:c</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-transitions">Svelte Transitions</h3>
<ol>
    <li>What Are Transitions?</li>
    <br/>
    <ul>
        <li><b>Transitions</b> are animations that play when elements are added to or removed from the DOM.</li>
        <br/>
        <li>Svelte provides built-in transitions and the ability to create custom ones.</li>
        <br/>
        <li>Transitions make UI changes feel smooth and polished.</li>
        <br/>
        <li>Key concepts:
            <ul>
                <li><code>transition:</code> — Plays on both enter and exit</li>
                <li><code>in:</code> — Plays only on enter</li>
                <li><code>out:</code> — Plays only on exit</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Built-in Transitions</li>
    <br/>
    <ul>
        <li>Svelte provides several built-in transitions in <code>svelte/transition</code>:</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Transition</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>fade</code></td>
            <td>Fades opacity in/out</td>
        </tr>
        <tr>
            <td><code>blur</code></td>
            <td>Fades with blur effect</td>
        </tr>
        <tr>
            <td><code>fly</code></td>
            <td>Flies in from a direction</td>
        </tr>
        <tr>
            <td><code>slide</code></td>
            <td>Slides vertically</td>
        </tr>
        <tr>
            <td><code>scale</code></td>
            <td>Scales size in/out</td>
        </tr>
        <tr>
            <td><code>draw</code></td>
            <td>Draws SVG paths</td>
        </tr>
        <tr>
            <td><code>crossfade</code></td>
            <td>Morphs between elements</td>
        </tr>
    </table>
    <br/><br/>



    <li>Fade Transition</li>
    <br/>
    <ul>
        <li>The simplest transition — fades opacity:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;p transition:fade&gt;
        This fades in and out
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li>With parameters:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;p transition:fade={{ duration: 500, delay: 100 }}&gt;
        Slower fade with delay
    &lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Fly Transition</li>
    <br/>
    <ul>
        <li>Animates position and opacity:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;!-- Fly from top --&gt;
    &lt;p transition:fly={{ y: -50, duration: 300 }}&gt;
        Flies from top
    &lt;/p&gt;

    &lt;!-- Fly from left --&gt;
    &lt;p transition:fly={{ x: -200, duration: 300 }}&gt;
        Flies from left
    &lt;/p&gt;

    &lt;!-- Fly with opacity control --&gt;
    &lt;p transition:fly={{ y: 100, opacity: 0.5, duration: 400 }}&gt;
        Partial opacity fly
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>x</code>, <code>y</code>, <code>opacity</code>, <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Slide Transition</li>
    <br/>
    <ul>
        <li>Slides element vertically (collapses height):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { slide } from "svelte/transition";

    let expanded: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; expanded = !expanded}&gt;
    {expanded ? "Collapse" : "Expand"}
&lt;/button&gt;

{#if expanded}
    &lt;div transition:slide={{ duration: 300 }}&gt;
        &lt;p&gt;This content slides in and out.&lt;/p&gt;
        &lt;p&gt;It animates the height property.&lt;/p&gt;
        &lt;p&gt;Great for accordions and dropdowns.&lt;/p&gt;
    &lt;/div&gt;
{/if}
</code></pre>

    <ul>
        <li>With axis parameter (Svelte 4+):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { slide } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;!-- Horizontal slide --&gt;
    &lt;div transition:slide={{ axis: "x", duration: 300 }}&gt;
        Slides horizontally
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Scale Transition</li>
    <br/>
    <ul>
        <li>Scales element size:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { scale } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;div transition:scale={{ duration: 300 }}&gt;
        Scales in and out
    &lt;/div&gt;

    &lt;div transition:scale={{ start: 0.5, opacity: 0.5 }}&gt;
        Starts at 50% size
    &lt;/div&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>start</code> (initial scale), <code>opacity</code>, <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Blur Transition</li>
    <br/>
    <ul>
        <li>Fades with a blur effect:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { blur } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;p transition:blur={{ amount: 10, duration: 400 }}&gt;
        Blurs in and out
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>amount</code> (blur pixels), <code>opacity</code>, <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Draw Transition (SVG)</li>
    <br/>
    <ul>
        <li>Animates SVG path stroke:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { draw } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;svg viewBox="0 0 100 100" width="200" height="200"&gt;
        &lt;path
            transition:draw={{ duration: 1000 }}
            d="M10,50 Q50,10 90,50 Q50,90 10,50"
            fill="none"
            stroke="blue"
            stroke-width="2"
        /&gt;
    &lt;/svg&gt;
{/if}
</code></pre>

    <ul>
        <li>Parameters: <code>speed</code> (pixels per second) or <code>duration</code>, <code>delay</code>, <code>easing</code></li>
    </ul>
    <br/><br/>



    <li>Separate In and Out Transitions</li>
    <br/>
    <ul>
        <li>Use different transitions for entering and exiting:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly, fade, scale } from "svelte/transition";

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;!-- Different transitions for in/out --&gt;
    &lt;p in:fly={{ y: -50 }} out:fade&gt;
        Flies in, fades out
    &lt;/p&gt;

    &lt;p in:scale out:fly={{ x: 200 }}&gt;
        Scales in, flies out to the right
    &lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Transition Parameters</li>
    <br/>
    <ul>
        <li>Common parameters available to all transitions:</li>
    </ul>

    <table>
        <tr>
            <th>Parameter</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>delay</code></td>
            <td><code>number</code></td>
            <td>Milliseconds before starting</td>
        </tr>
        <tr>
            <td><code>duration</code></td>
            <td><code>number</code></td>
            <td>Length in milliseconds</td>
        </tr>
        <tr>
            <td><code>easing</code></td>
            <td><code>function</code></td>
            <td>Easing function</td>
        </tr>
    </table>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";
    import { cubicOut, elasticOut, bounceOut } from "svelte/easing";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;p transition:fade={{ duration: 300, delay: 100, easing: cubicOut }}&gt;
        Custom easing
    &lt;/p&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Easing Functions</li>
    <br/>
    <ul>
        <li>Svelte provides many easing functions in <code>svelte/easing</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">import {
    // Linear
    linear,

    // Sine
    sineIn, sineOut, sineInOut,

    // Quad (power of 2)
    quadIn, quadOut, quadInOut,

    // Cubic (power of 3)
    cubicIn, cubicOut, cubicInOut,

    // Quart (power of 4)
    quartIn, quartOut, quartInOut,

    // Quint (power of 5)
    quintIn, quintOut, quintInOut,

    // Expo (exponential)
    expoIn, expoOut, expoInOut,

    // Circ (circular)
    circIn, circOut, circInOut,

    // Back (overshoots)
    backIn, backOut, backInOut,

    // Elastic (springy)
    elasticIn, elasticOut, elasticInOut,

    // Bounce
    bounceIn, bounceOut, bounceInOut
} from "svelte/easing";
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly } from "svelte/transition";
    import { elasticOut, bounceOut } from "svelte/easing";

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;div transition:fly={{ y: -100, easing: elasticOut, duration: 800 }}&gt;
        Elastic entrance!
    &lt;/div&gt;

    &lt;div transition:fly={{ y: 100, easing: bounceOut, duration: 600 }}&gt;
        Bouncy entrance!
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Transition Events</li>
    <br/>
    <ul>
        <li>Listen to transition lifecycle events:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
    let status: string = $state("");

    function handleIntroStart(): void {
        status = "Intro started";
    }

    function handleIntroEnd(): void {
        status = "Intro ended";
    }

    function handleOutroStart(): void {
        status = "Outro started";
    }

    function handleOutroEnd(): void {
        status = "Outro ended";
    }
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

&lt;p&gt;Status: {status}&lt;/p&gt;

{#if visible}
    &lt;div
        transition:fade={{ duration: 500 }}
        onintrostart={handleIntroStart}
        onintroend={handleIntroEnd}
        onoutrostart={handleOutroStart}
        onoutroend={handleOutroEnd}
    &gt;
        Watch the status!
    &lt;/div&gt;
{/if}
</code></pre>

    <ul>
        <li>Events: <code>introstart</code>, <code>introend</code>, <code>outrostart</code>, <code>outroend</code></li>
    </ul>
    <br/><br/>



    <li>Local Transitions</li>
    <br/>
    <ul>
        <li>By default, transitions play when any parent block is added/removed.</li>
        <br/>
        <li>Use <code>local</code> modifier to only play when the element's direct block changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { slide, fade } from "svelte/transition";

    let showList: boolean = $state(true);
    let items: string[] = $state(["Item 1", "Item 2", "Item 3"]);

    function addItem(): void {
        items = [...items, `Item ${items.length + 1}`];
    }

    function removeItem(index: number): void {
        items = items.filter((_, i) =&gt; i !== index);
    }
&lt;/script&gt;

&lt;button onclick={() =&gt; showList = !showList}&gt;
    Toggle List
&lt;/button&gt;
&lt;button onclick={addItem}&gt;Add Item&lt;/button&gt;

{#if showList}
    &lt;ul transition:fade&gt;
        {#each items as item, i (item)}
            &lt;!-- |local prevents animation when parent toggles --&gt;
            &lt;li transition:slide|local&gt;
                {item}
                &lt;button onclick={() =&gt; removeItem(i)}&gt;×&lt;/button&gt;
            &lt;/li&gt;
        {/each}
    &lt;/ul&gt;
{/if}
</code></pre>

    <ul>
        <li>Without <code>|local</code>, items would animate when toggling the entire list.</li>
        <li>With <code>|local</code>, items only animate when individually added/removed.</li>
    </ul>
    <br/><br/>



    <li>Global Modifier</li>
    <br/>
    <ul>
        <li>The <code>|global</code> modifier ensures transitions play even during initial page load:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";
&lt;/script&gt;

&lt;!-- Plays transition on initial render --&gt;
&lt;div transition:fade|global={{ duration: 1000 }}&gt;
    Fades in on page load
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Crossfade Transition</li>
    <br/>
    <ul>
        <li>Creates a morphing effect between two elements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { crossfade } from "svelte/transition";
    import { quintOut } from "svelte/easing";

    const [send, receive] = crossfade({
        duration: 400,
        easing: quintOut,
        fallback(node) {
            // Fallback when no matching element exists
            return {
                duration: 300,
                css: (t: number) =&gt; `opacity: ${t}`
            };
        }
    });

    interface Todo {
        id: number;
        text: string;
        done: boolean;
    }

    let todos: Todo[] = $state([
        { id: 1, text: "Learn Svelte", done: false },
        { id: 2, text: "Build an app", done: false },
        { id: 3, text: "Deploy", done: true }
    ]);

    function toggle(id: number): void {
        todos = todos.map(t =&gt;
            t.id === id ? { ...t, done: !t.done } : t
        );
    }

    let pending = $derived(todos.filter(t =&gt; !t.done));
    let completed = $derived(todos.filter(t =&gt; t.done));
&lt;/script&gt;

&lt;div class="columns"&gt;
    &lt;div class="column"&gt;
        &lt;h3&gt;Pending&lt;/h3&gt;
        {#each pending as todo (todo.id)}
            &lt;div
                class="todo"
                in:receive={{ key: todo.id }}
                out:send={{ key: todo.id }}
                onclick={() =&gt; toggle(todo.id)}
            &gt;
                {todo.text}
            &lt;/div&gt;
        {/each}
    &lt;/div&gt;

    &lt;div class="column"&gt;
        &lt;h3&gt;Completed&lt;/h3&gt;
        {#each completed as todo (todo.id)}
            &lt;div
                class="todo done"
                in:receive={{ key: todo.id }}
                out:send={{ key: todo.id }}
                onclick={() =&gt; toggle(todo.id)}
            &gt;
                {todo.text}
            &lt;/div&gt;
        {/each}
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
    .columns { display: flex; gap: 20px; }
    .column { flex: 1; }
    .todo { padding: 10px; margin: 5px 0; background: #eee; cursor: pointer; }
    .todo.done { background: #c8e6c9; }
&lt;/style&gt;
</code></pre>

    <ul>
        <li><code>crossfade</code> returns <code>[send, receive]</code> pair.</li>
        <li>Elements with matching <code>key</code> morph into each other.</li>
    </ul>
    <br/><br/>



    <li>Custom Transitions</li>
    <br/>
    <ul>
        <li>Create custom transitions by returning a configuration object:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";

    interface SpinParams {
        duration?: number;
        rotations?: number;
    }

    function spin(node: HTMLElement, params: SpinParams = {}): TransitionConfig {
        const { duration = 500, rotations = 1 } = params;

        return {
            duration,
            css: (t: number) =&gt; {
                const rotation = t * rotations * 360;
                const scale = t;
                return `
                    transform: rotate(${rotation}deg) scale(${scale});
                    opacity: ${t};
                `;
            }
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;div transition:spin={{ duration: 800, rotations: 2 }}&gt;
        Spinning!
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Custom Transition with <code>tick</code></li>
    <br/>
    <ul>
        <li>Use <code>tick</code> for JavaScript-based animations (when CSS isn't enough):</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";

    interface TypewriterParams {
        speed?: number;
    }

    function typewriter(node: HTMLElement, params: TypewriterParams = {}): TransitionConfig {
        const { speed = 50 } = params;
        const text = node.textContent ?? "";
        const duration = text.length * speed;

        return {
            duration,
            tick: (t: number) =&gt; {
                const length = Math.floor(text.length * t);
                node.textContent = text.slice(0, length);
            }
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;p transition:typewriter={{ speed: 30 }}&gt;
        This text appears character by character...
    &lt;/p&gt;
{/if}
</code></pre>

    <ul>
        <li><code>css</code> is preferred for performance (runs on GPU).</li>
        <li><code>tick</code> is for animations that can't be done with CSS.</li>
    </ul>
    <br/><br/>



    <li>Transition Return Object</li>
    <br/>
    <ul>
        <li>Custom transitions return a <code>TransitionConfig</code> object:</li>
    </ul>

<pre><code class="language-ts line-numbers">interface TransitionConfig {
    delay?: number;           // Delay before starting
    duration?: number;        // Animation length in ms
    easing?: (t: number) =&gt; number;  // Easing function
    css?: (t: number, u: number) =&gt; string;  // CSS generator
    tick?: (t: number, u: number) =&gt; void;   // JS callback
}

// t: 0 to 1 (intro) or 1 to 0 (outro) - the progress
// u: 1 - t (the inverse)
</code></pre>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";
    import { cubicOut } from "svelte/easing";

    function customFade(node: HTMLElement): TransitionConfig {
        return {
            delay: 100,
            duration: 400,
            easing: cubicOut,
            css: (t: number, u: number) =&gt; `
                opacity: ${t};
                transform: translateY(${u * 20}px);
            `
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;div transition:customFade&gt;
        Custom fade transition
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Deferred Transitions</li>
    <br/>
    <ul>
        <li>Return a function to defer transition creation:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import type { TransitionConfig } from "svelte/transition";

    function deferredSlide(node: HTMLElement): () =&gt; TransitionConfig {
        // Measure height when transition starts, not when component mounts
        return () =&gt; {
            const height = node.offsetHeight;
            return {
                duration: 300,
                css: (t: number) =&gt; `
                    height: ${t * height}px;
                    overflow: hidden;
                `
            };
        };
    }

    let visible: boolean = $state(true);
&lt;/script&gt;

{#if visible}
    &lt;div transition:deferredSlide&gt;
        Content with dynamic height
    &lt;/div&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Staggered List Transitions</li>
    <br/>
    <ul>
        <li>Create staggered animations using index-based delays:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fly } from "svelte/transition";

    let visible: boolean = $state(true);

    const items: string[] = [
        "First item",
        "Second item",
        "Third item",
        "Fourth item",
        "Fifth item"
    ];
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle List
&lt;/button&gt;

{#if visible}
    &lt;ul&gt;
        {#each items as item, i}
            &lt;li
                in:fly={{ y: 20, delay: i * 100, duration: 300 }}
                out:fly={{ y: -20, delay: (items.length - i - 1) * 50, duration: 200 }}
            &gt;
                {item}
            &lt;/li&gt;
        {/each}
    &lt;/ul&gt;
{/if}
</code></pre>
    <br/><br/>



    <li>Combining Transitions with CSS</li>
    <br/>
    <ul>
        <li>Transitions work alongside CSS transitions:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade } from "svelte/transition";

    let visible: boolean = $state(true);
    let hovered: boolean = $state(false);
&lt;/script&gt;

&lt;button onclick={() =&gt; visible = !visible}&gt;
    Toggle
&lt;/button&gt;

{#if visible}
    &lt;div
        class="box"
        class:hovered
        transition:fade={{ duration: 300 }}
        onmouseenter={() =&gt; hovered = true}
        onmouseleave={() =&gt; hovered = false}
    &gt;
        Hover me!
    &lt;/div&gt;
{/if}

&lt;style&gt;
    .box {
        padding: 20px;
        background: #3498db;
        color: white;
        transition: transform 0.2s, background 0.2s;
    }
    .box.hovered {
        transform: scale(1.05);
        background: #2980b9;
    }
&lt;/style&gt;
</code></pre>
    <br/><br/>



    <li>Transition with <code>{#key}</code></li>
    <br/>
    <ul>
        <li>Use <code>{#key}</code> to trigger transitions when a value changes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { fade, fly } from "svelte/transition";

    let count: number = $state(0);
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;
    Increment
&lt;/button&gt;

{#key count}
    &lt;p transition:fade={{ duration: 200 }}&gt;
        Count: {count}
    &lt;/p&gt;
{/key}

{#key count}
    &lt;div in:fly={{ y: -20 }} out:fly={{ y: 20 }}&gt;
        Value changed!
    &lt;/div&gt;
{/key}
</code></pre>
    <br/><br/>



    <li>Transitions Summary</li>
    <br/>

    <table>
        <tr>
            <th>Directive</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><code>transition:</code></td>
            <td>In and out</td>
            <td><code>transition:fade</code></td>
        </tr>
        <tr>
            <td><code>in:</code></td>
            <td>Enter only</td>
            <td><code>in:fly={{ y: -50 }}</code></td>
        </tr>
        <tr>
            <td><code>out:</code></td>
            <td>Exit only</td>
            <td><code>out:fade</code></td>
        </tr>
        <tr>
            <td><code>|local</code></td>
            <td>Only direct block changes</td>
            <td><code>transition:slide|local</code></td>
        </tr>
        <tr>
            <td><code>|global</code></td>
            <td>Play on initial render</td>
            <td><code>transition:fade|global</code></td>
        </tr>
        <tr>
            <td>Events</td>
            <td>Lifecycle hooks</td>
            <td><code>onintroend={handler}</code></td>
        </tr>
        <tr>
            <td>Custom</td>
            <td>Return <code>TransitionConfig</code></td>
            <td><code>css: (t) =&gt; ...</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="svelte-advanced-reactivity">Svelte Advanced Reactivity</h3>
<ol>
    <br/>
    <li>Deep Reactivity with <code>$state</code></li>
    <br/>
    <ul>
        <li><code>$state</code> creates <u>deeply reactive</u> state — nested objects and arrays are automatically reactive:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        name: string;
        address: {
            city: string;
            country: string;
        };
        hobbies: string[];
    }

    let user: User = $state({
        name: "Alice",
        address: {
            city: "New York",
            country: "USA"
        },
        hobbies: ["reading", "coding"]
    });

    function updateCity(): void {
        // Deep mutation is reactive!
        user.address.city = "Los Angeles";
    }

    function addHobby(): void {
        // Array mutations are reactive!
        user.hobbies.push("gaming");
    }
&lt;/script&gt;

&lt;p&gt;{user.name} lives in {user.address.city}&lt;/p&gt;
&lt;p&gt;Hobbies: {user.hobbies.join(", ")}&lt;/p&gt;

&lt;button onclick={updateCity}&gt;Move to LA&lt;/button&gt;
&lt;button onclick={addHobby}&gt;Add Hobby&lt;/button&gt;
</code></pre>

    <ul>
        <li>Unlike Svelte 4, you don't need to reassign to trigger updates.</li>
    </ul>
    <br/><br/>



    <li>Shallow Reactivity with <code>$state.raw</code></li>
    <br/>
    <ul>
        <li>Use <code>$state.raw</code> when you don't need deep reactivity:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface LargeDataset {
        id: number;
        values: number[];
    }

    // Only the reference is reactive, not nested properties
    let data: LargeDataset = $state.raw({
        id: 1,
        values: [1, 2, 3, 4, 5]
    });

    function updateData(): void {
        // This does NOT trigger reactivity
        data.values.push(6);

        // This DOES trigger reactivity (replacing the whole object)
        data = { ...data, values: [...data.values, 7] };
    }

    function replaceData(): void {
        // Reassignment triggers update
        data = {
            id: 2,
            values: [10, 20, 30]
        };
    }
&lt;/script&gt;

&lt;p&gt;ID: {data.id}&lt;/p&gt;
&lt;p&gt;Values: {data.values.join(", ")}&lt;/p&gt;

&lt;button onclick={updateData}&gt;Update&lt;/button&gt;
&lt;button onclick={replaceData}&gt;Replace&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>$state.raw</code> for:
            <ul>
                <li>Large datasets where deep reactivity is expensive</li>
                <li>Immutable data patterns</li>
                <li>Data that rarely changes</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Getting Plain Values with <code>$state.snapshot</code></li>
    <br/>
    <ul>
        <li><code>$state.snapshot</code> returns a non-reactive copy of reactive state:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface FormData {
        name: string;
        email: string;
    }

    let form: FormData = $state({
        name: "",
        email: ""
    });

    function handleSubmit(): void {
        // Get a plain object snapshot for API calls
        const snapshot = $state.snapshot(form);

        console.log("Submitting:", snapshot);
        console.log("Is proxy:", form !== snapshot); // true

        // Send to API
        fetch("/api/submit", {
            method: "POST",
            body: JSON.stringify(snapshot)
        });
    }

    function logState(): void {
        // Reactive proxy - may show Proxy in console
        console.log("Reactive:", form);

        // Plain object - cleaner for debugging
        console.log("Snapshot:", $state.snapshot(form));
    }
&lt;/script&gt;

&lt;input bind:value={form.name} placeholder="Name" /&gt;
&lt;input bind:value={form.email} placeholder="Email" /&gt;

&lt;button onclick={handleSubmit}&gt;Submit&lt;/button&gt;
&lt;button onclick={logState}&gt;Log State&lt;/button&gt;
</code></pre>

    <ul>
        <li>Useful when passing state to external libraries or APIs.</li>
    </ul>
    <br/><br/>



    <li>Computed Values with <code>$derived</code></li>
    <br/>
    <ul>
        <li><code>$derived</code> creates values that automatically update when dependencies change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let firstName: string = $state("John");
    let lastName: string = $state("Doe");
    let age: number = $state(25);

    // Simple derived value
    let fullName: string = $derived(firstName + " " + lastName);

    // Derived with transformation
    let upperName: string = $derived(fullName.toUpperCase());

    // Derived boolean
    let isAdult: boolean = $derived(age &gt;= 18);

    // Chained derivations
    let greeting: string = $derived(
        `Hello, ${fullName}! You are ${isAdult ? "an adult" : "a minor"}.`
    );
&lt;/script&gt;

&lt;input bind:value={firstName} placeholder="First name" /&gt;
&lt;input bind:value={lastName} placeholder="Last name" /&gt;
&lt;input type="number" bind:value={age} /&gt;

&lt;p&gt;Full name: {fullName}&lt;/p&gt;
&lt;p&gt;Upper: {upperName}&lt;/p&gt;
&lt;p&gt;{greeting}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Complex Derivations with <code>$derived.by</code></li>
    <br/>
    <ul>
        <li>Use <code>$derived.by</code> for derivations that need multiple statements:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Product {
        name: string;
        price: number;
        quantity: number;
    }

    let products: Product[] = $state([
        { name: "Apple", price: 1.5, quantity: 3 },
        { name: "Banana", price: 0.75, quantity: 5 },
        { name: "Orange", price: 2.0, quantity: 2 }
    ]);

    let taxRate: number = $state(0.08);

    // Complex derivation with multiple statements
    let orderSummary = $derived.by(() =&gt; {
        const subtotal = products.reduce(
            (sum, p) =&gt; sum + p.price * p.quantity,
            0
        );
        const tax = subtotal * taxRate;
        const total = subtotal + tax;
        const itemCount = products.reduce((sum, p) =&gt; sum + p.quantity, 0);

        return {
            subtotal: subtotal.toFixed(2),
            tax: tax.toFixed(2),
            total: total.toFixed(2),
            itemCount
        };
    });

    // Derived with conditional logic
    let recommendation = $derived.by(() =&gt; {
        const total = parseFloat(orderSummary.total);

        if (total &gt; 50) {
            return "You qualify for free shipping!";
        } else if (total &gt; 25) {
            return `Add $${(50 - total).toFixed(2)} more for free shipping.`;
        } else {
            return "Keep shopping for great deals!";
        }
    });
&lt;/script&gt;

&lt;ul&gt;
    {#each products as product}
        &lt;li&gt;{product.name}: ${product.price} × {product.quantity}&lt;/li&gt;
    {/each}
&lt;/ul&gt;

&lt;p&gt;Items: {orderSummary.itemCount}&lt;/p&gt;
&lt;p&gt;Subtotal: ${orderSummary.subtotal}&lt;/p&gt;
&lt;p&gt;Tax: ${orderSummary.tax}&lt;/p&gt;
&lt;p&gt;Total: ${orderSummary.total}&lt;/p&gt;
&lt;p&gt;{recommendation}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Side Effects with <code>$effect</code></li>
    <br/>
    <ul>
        <li><code>$effect</code> runs code when reactive dependencies change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let name: string = $state("World");

    // Runs when count changes
    $effect(() =&gt; {
        console.log("Count is now:", count);
    });

    // Runs when name changes
    $effect(() =&gt; {
        document.title = `Hello, ${name}!`;
    });

    // Runs when either changes
    $effect(() =&gt; {
        console.log(`${name} has count ${count}`);
    });
&lt;/script&gt;

&lt;input bind:value={name} /&gt;
&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;
</code></pre>

    <ul>
        <li>Effects automatically track which reactive values are read.</li>
        <li>They re-run whenever those values change.</li>
    </ul>
    <br/><br/>



    <li>Effect Cleanup</li>
    <br/>
    <ul>
        <li>Return a function from <code>$effect</code> to clean up before re-running:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let interval: number = $state(1000);
    let count: number = $state(0);

    $effect(() =&gt; {
        // Set up interval with current value
        const id = setInterval(() =&gt; {
            count++;
        }, interval);

        console.log(`Started interval: ${interval}ms`);

        // Cleanup: clear interval before re-running or on unmount
        return () =&gt; {
            clearInterval(id);
            console.log("Cleared interval");
        };
    });

    // Event listener example
    let mouseX: number = $state(0);
    let mouseY: number = $state(0);

    $effect(() =&gt; {
        function handleMouseMove(e: MouseEvent): void {
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        window.addEventListener("mousemove", handleMouseMove);

        return () =&gt; {
            window.removeEventListener("mousemove", handleMouseMove);
        };
    });
&lt;/script&gt;

&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;p&gt;Mouse: {mouseX}, {mouseY}&lt;/p&gt;

&lt;label&gt;
    Interval (ms):
    &lt;input type="number" bind:value={interval} min="100" step="100" /&gt;
&lt;/label&gt;
</code></pre>
    <br/><br/>



    <li>Pre-Effects with <code>$effect.pre</code></li>
    <br/>
    <ul>
        <li><code>$effect.pre</code> runs <u>before</u> the DOM updates:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let messages: string[] = $state(["Hello", "World"]);
    let container: HTMLDivElement;

    // Runs BEFORE DOM updates - useful for measuring
    $effect.pre(() =&gt; {
        if (container) {
            // Capture scroll position before DOM changes
            const isAtBottom =
                container.scrollHeight - container.scrollTop === container.clientHeight;

            console.log("Before update, at bottom:", isAtBottom);
        }
    });

    // Runs AFTER DOM updates
    $effect(() =&gt; {
        if (container) {
            // Auto-scroll to bottom after new messages
            container.scrollTop = container.scrollHeight;
        }
    });

    function addMessage(): void {
        messages.push(`Message ${messages.length + 1}`);
    }
&lt;/script&gt;

&lt;div bind:this={container} class="chat" style="height: 200px; overflow-y: auto;"&gt;
    {#each messages as message}
        &lt;p&gt;{message}&lt;/p&gt;
    {/each}
&lt;/div&gt;

&lt;button onclick={addMessage}&gt;Add Message&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>$effect.pre</code> when you need to measure or capture state before the DOM changes.</li>
    </ul>
    <br/><br/>



    <li>Effect Tracking with <code>$effect.tracking</code></li>
    <br/>
    <ul>
        <li>Check if code is running inside a tracking context:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);

    function logWithContext(message: string): void {
        if ($effect.tracking()) {
            console.log("[Tracked]", message);
        } else {
            console.log("[Untracked]", message);
        }
    }

    // Inside $effect - tracked
    $effect(() =&gt; {
        logWithContext(`Count is ${count}`);
    });

    // Inside $derived - tracked
    let doubled = $derived.by(() =&gt; {
        logWithContext("Computing doubled");
        return count * 2;
    });

    function handleClick(): void {
        // Event handler - not tracked
        logWithContext("Button clicked");
        count++;
    }
&lt;/script&gt;

&lt;p&gt;Count: {count}, Doubled: {doubled}&lt;/p&gt;
&lt;button onclick={handleClick}&gt;Increment&lt;/button&gt;
</code></pre>

    <ul>
        <li>Useful for libraries that need to behave differently in reactive vs non-reactive contexts.</li>
    </ul>
    <br/><br/>



    <li>Root Effects with <code>$effect.root</code></li>
    <br/>
    <ul>
        <li><code>$effect.root</code> creates effects outside the component lifecycle:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let count: number = $state(0);
    let cleanupRoot: (() =&gt; void) | null = null;

    function startRootEffect(): void {
        // Create an effect that persists outside component lifecycle
        cleanupRoot = $effect.root(() =&gt; {
            $effect(() =&gt; {
                console.log("[Root Effect] Count:", count);
            });

            // Return cleanup for the root
            return () =&gt; {
                console.log("[Root Effect] Cleaned up");
            };
        });
    }

    function stopRootEffect(): void {
        if (cleanupRoot) {
            cleanupRoot();
            cleanupRoot = null;
        }
    }
&lt;/script&gt;

&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;button onclick={() =&gt; count++}&gt;Increment&lt;/button&gt;

&lt;button onclick={startRootEffect}&gt;Start Root Effect&lt;/button&gt;
&lt;button onclick={stopRootEffect}&gt;Stop Root Effect&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>$effect.root</code> for:
            <ul>
                <li>Effects in shared modules</li>
                <li>Effects with manual lifecycle control</li>
                <li>Testing scenarios</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li>Untracking Dependencies with <code>untrack</code></li>
    <br/>
    <ul>
        <li>Use <code>untrack</code> to read reactive values without creating a dependency:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { untrack } from "svelte";

    let count: number = $state(0);
    let name: string = $state("Alice");
    let effectRuns: number = $state(0);

    $effect(() =&gt; {
        // This creates a dependency on 'count'
        console.log("Count:", count);

        // This does NOT create a dependency on 'name'
        const currentName = untrack(() =&gt; name);
        console.log("Name (untracked):", currentName);

        effectRuns++;
    });

    // The effect only re-runs when 'count' changes, not 'name'
&lt;/script&gt;

&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;p&gt;Name: {name}&lt;/p&gt;
&lt;p&gt;Effect runs: {effectRuns}&lt;/p&gt;

&lt;button onclick={() =&gt; count++}&gt;Increment Count (triggers effect)&lt;/button&gt;
&lt;button onclick={() =&gt; name = name + "!"}&gt;Change Name (no effect)&lt;/button&gt;
</code></pre>

    <ul>
        <li>Useful when you need to read a value without reacting to its changes.</li>
    </ul>
    <br/><br/>



    <li>Debugging with <code>$inspect</code></li>
    <br/>
    <ul>
        <li><code>$inspect</code> logs reactive values whenever they change:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface User {
        name: string;
        age: number;
    }

    let count: number = $state(0);
    let user: User = $state({ name: "Alice", age: 25 });

    // Basic inspection - logs on every change
    $inspect(count);

    // Inspect multiple values
    $inspect(count, user);

    // Custom logging with .with()
    $inspect(user).with((type, value) =&gt; {
        console.log(`[${type}]`, JSON.stringify(value, null, 2));
    });

    // Useful for debugging: pause on change
    $inspect(count).with((type, value) =&gt; {
        if (value &gt; 5) {
            debugger; // Opens browser debugger
        }
    });
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;
&lt;button onclick={() =&gt; user.age++}&gt;Age: {user.age}&lt;/button&gt;
&lt;input bind:value={user.name} /&gt;
</code></pre>

    <ul>
        <li><code>$inspect</code> only works in development mode.</li>
        <li>The <code>type</code> parameter is either <code>"init"</code> or <code>"update"</code>.</li>
    </ul>
    <br/><br/>



    <li>Fine-Grained Reactivity</li>
    <br/>
    <ul>
        <li>Svelte 5 tracks reactivity at the <u>property level</u>, not just the object level:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    interface Coordinates {
        x: number;
        y: number;
    }

    let coords: Coordinates = $state({ x: 0, y: 0 });

    // This effect only re-runs when coords.x changes
    $effect(() =&gt; {
        console.log("X changed:", coords.x);
    });

    // This effect only re-runs when coords.y changes
    $effect(() =&gt; {
        console.log("Y changed:", coords.y);
    });

    function updateX(): void {
        coords.x++; // Only triggers first effect
    }

    function updateY(): void {
        coords.y++; // Only triggers second effect
    }
&lt;/script&gt;

&lt;p&gt;X: {coords.x}, Y: {coords.y}&lt;/p&gt;
&lt;button onclick={updateX}&gt;Update X&lt;/button&gt;
&lt;button onclick={updateY}&gt;Update Y&lt;/button&gt;
</code></pre>

    <ul>
        <li>This fine-grained tracking improves performance for complex objects.</li>
    </ul>
    <br/><br/>



    <li>Reactive Classes</li>
    <br/>
    <ul>
        <li>Use <code>$state</code> in class fields for reactive class instances:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    class Counter {
        count: number = $state(0);

        increment(): void {
            this.count++;
        }

        decrement(): void {
            this.count--;
        }

        get doubled(): number {
            return this.count * 2;
        }
    }

    class TodoList {
        items: string[] = $state([]);

        add(item: string): void {
            this.items.push(item);
        }

        remove(index: number): void {
            this.items.splice(index, 1);
        }

        get count(): number {
            return this.items.length;
        }
    }

    const counter = new Counter();
    const todos = new TodoList();
    let newTodo: string = $state("");
&lt;/script&gt;

&lt;div&gt;
    &lt;h3&gt;Counter&lt;/h3&gt;
    &lt;p&gt;Count: {counter.count} (doubled: {counter.doubled})&lt;/p&gt;
    &lt;button onclick={() =&gt; counter.decrement()}&gt;-&lt;/button&gt;
    &lt;button onclick={() =&gt; counter.increment()}&gt;+&lt;/button&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h3&gt;Todos ({todos.count})&lt;/h3&gt;
    &lt;input bind:value={newTodo} /&gt;
    &lt;button onclick={() =&gt; { todos.add(newTodo); newTodo = ""; }}&gt;Add&lt;/button&gt;

    &lt;ul&gt;
        {#each todos.items as item, i}
            &lt;li&gt;{item} &lt;button onclick={() =&gt; todos.remove(i)}&gt;×&lt;/button&gt;&lt;/li&gt;
        {/each}
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
    <br/><br/>



    <li>Reactive State in Modules</li>
    <br/>
    <ul>
        <li>Create shared reactive state in separate modules:</li>
    </ul>

<pre><code class="language-ts line-numbers">// stores/counter.svelte.ts
export function createCounter(initial: number = 0) {
    let count = $state(initial);

    return {
        get count() {
            return count;
        },
        increment() {
            count++;
        },
        decrement() {
            count--;
        },
        reset() {
            count = initial;
        }
    };
}

// Singleton instance
export const counter = createCounter(0);
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Component.svelte --&gt;
&lt;script lang="ts"&gt;
    import { counter } from "./stores/counter.svelte";
&lt;/script&gt;

&lt;p&gt;Count: {counter.count}&lt;/p&gt;
&lt;button onclick={counter.increment}&gt;+&lt;/button&gt;
&lt;button onclick={counter.decrement}&gt;-&lt;/button&gt;
&lt;button onclick={counter.reset}&gt;Reset&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use the <code>.svelte.ts</code> or <code>.svelte.js</code> extension for files containing runes.</li>
    </ul>
    <br/><br/>



    <li>Store Interoperability</li>
    <br/>
    <ul>
        <li>Svelte 5 stores work with both old stores and new runes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { writable, type Writable } from "svelte/store";
    import { fromStore, toStore } from "svelte/store";

    // Traditional store
    const countStore: Writable&lt;number&gt; = writable(0);

    // Convert store to rune-based state
    const countState = fromStore(countStore);

    // Access value (automatically subscribes)
    $effect(() =&gt; {
        console.log("Store value:", countState.current);
    });

    // Or create a store from rune state
    let runeCount: number = $state(0);
    const runeStore = toStore(() =&gt; runeCount, (v) =&gt; runeCount = v);
&lt;/script&gt;

&lt;p&gt;Store: {$countStore}&lt;/p&gt;
&lt;p&gt;State: {countState.current}&lt;/p&gt;

&lt;button onclick={() =&gt; countStore.update(n =&gt; n + 1)}&gt;
    Update Store
&lt;/button&gt;

&lt;button onclick={() =&gt; runeCount++}&gt;
    Update Rune
&lt;/button&gt;
</code></pre>
    <br/><br/>



    <li>Avoiding Infinite Loops</li>
    <br/>
    <ul>
        <li>Be careful not to create infinite loops in effects:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { untrack } from "svelte";

    let count: number = $state(0);
    let history: number[] = $state([]);

    // BAD: Infinite loop!
    // $effect(() =&gt; {
    //     history.push(count); // Reading 'count' AND modifying 'history'
    //     history = history;   // This creates a loop
    // });

    // GOOD: Use untrack to prevent loop
    $effect(() =&gt; {
        const current = count; // Track count
        untrack(() =&gt; {
            history.push(current); // Don't track history modification
        });
    });

    // ALTERNATIVE: Use $effect.pre or separate the concerns
    let lastCount: number | null = null;

    $effect(() =&gt; {
        if (count !== lastCount) {
            lastCount = count;
            // Safe to modify other state here
        }
    });
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;
&lt;p&gt;History: {history.join(", ")}&lt;/p&gt;
</code></pre>
    <br/><br/>



    <li>Conditional Effects</li>
    <br/>
    <ul>
        <li>Effects can have conditional logic, but dependencies are still tracked:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    let enabled: boolean = $state(true);
    let count: number = $state(0);
    let logs: string[] = $state([]);

    $effect(() =&gt; {
        // 'enabled' is always tracked
        if (enabled) {
            // 'count' is only tracked when this branch runs
            logs.push(`Count is ${count}`);
        }
    });

    // Better pattern: guard the entire effect
    $effect(() =&gt; {
        if (!enabled) return;

        logs.push(`Enabled count: ${count}`);

        return () =&gt; {
            logs.push("Effect cleaned up");
        };
    });
&lt;/script&gt;

&lt;label&gt;
    &lt;input type="checkbox" bind:checked={enabled} /&gt;
    Enabled
&lt;/label&gt;

&lt;button onclick={() =&gt; count++}&gt;Count: {count}&lt;/button&gt;

&lt;ul&gt;
    {#each logs as log}
        &lt;li&gt;{log}&lt;/li&gt;
    {/each}
&lt;/ul&gt;
</code></pre>
    <br/><br/>



    <li>Batching Updates</li>
    <br/>
    <ul>
        <li>Svelte batches synchronous updates automatically:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script lang="ts"&gt;
    import { flushSync } from "svelte";

    let a: number = $state(0);
    let b: number = $state(0);
    let effectRuns: number = $state(0);

    $effect(() =&gt; {
        console.log(`a: ${a}, b: ${b}`);
        effectRuns++;
    });

    function batchedUpdate(): void {
        // These are batched - effect runs once
        a++;
        b++;
    }

    function forcedUpdate(): void {
        a++;
        // Force synchronous flush
        flushSync();
        // This triggers a separate effect run
        b++;
    }
&lt;/script&gt;

&lt;p&gt;a: {a}, b: {b}&lt;/p&gt;
&lt;p&gt;Effect runs: {effectRuns}&lt;/p&gt;

&lt;button onclick={batchedUpdate}&gt;Batched (1 effect run)&lt;/button&gt;
&lt;button onclick={forcedUpdate}&gt;Forced (2 effect runs)&lt;/button&gt;
</code></pre>

    <ul>
        <li>Use <code>flushSync</code> sparingly — only when you need immediate DOM updates.</li>
    </ul>
    <br/><br/>



    <li>Advanced Reactivity Summary</li>
    <br/>

    <table>
        <tr>
            <th>API</th>
            <th>Purpose</th>
            <th>Usage</th>
        </tr>
        <tr>
            <td><code>$state</code></td>
            <td>Deep reactive state</td>
            <td><code>let x = $state(value)</code></td>
        </tr>
        <tr>
            <td><code>$state.raw</code></td>
            <td>Shallow reactive state</td>
            <td><code>let x = $state.raw(value)</code></td>
        </tr>
        <tr>
            <td><code>$state.snapshot</code></td>
            <td>Get plain object copy</td>
            <td><code>$state.snapshot(state)</code></td>
        </tr>
        <tr>
            <td><code>$derived</code></td>
            <td>Computed value (expression)</td>
            <td><code>let x = $derived(expr)</code></td>
        </tr>
        <tr>
            <td><code>$derived.by</code></td>
            <td>Computed value (function)</td>
            <td><code>let x = $derived.by(() =&gt; ...)</code></td>
        </tr>
        <tr>
            <td><code>$effect</code></td>
            <td>Side effect (after DOM)</td>
            <td><code>$effect(() =&gt; { ... })</code></td>
        </tr>
        <tr>
            <td><code>$effect.pre</code></td>
            <td>Side effect (before DOM)</td>
            <td><code>$effect.pre(() =&gt; { ... })</code></td>
        </tr>
        <tr>
            <td><code>$effect.tracking</code></td>
            <td>Check if tracking</td>
            <td><code>if ($effect.tracking()) ...</code></td>
        </tr>
        <tr>
            <td><code>$effect.root</code></td>
            <td>Manual effect lifecycle</td>
            <td><code>$effect.root(() =&gt; ...)</code></td>
        </tr>
        <tr>
            <td><code>untrack</code></td>
            <td>Read without tracking</td>
            <td><code>untrack(() =&gt; value)</code></td>
        </tr>
        <tr>
            <td><code>$inspect</code></td>
            <td>Debug reactive values</td>
            <td><code>$inspect(value)</code></td>
        </tr>
        <tr>
            <td><code>flushSync</code></td>
            <td>Force synchronous update</td>
            <td><code>flushSync()</code></td>
        </tr>
    </table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
