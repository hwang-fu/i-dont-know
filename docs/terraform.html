<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Terraform</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/terraform.jpeg" alt="Terraform Logo"/> </h2>
    <ul style="line-height: 1.8;">
        <li><a href="#tf-what-is-terraform">What Is Terraform?</a></li>
        <li><a href="#terraform-lifecycle">Life Cycle</a></li>
        <li><a href="#terraform-cli">CLI</a></li>
        <li><a href="#terraform-write-config">Writing Terraform Configuration</a></li>
    </ul>
</nav>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="tf-what-is-terraform">What Is Terraform?</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>Terraform</code> is an open-source <u>Infrastructure as Code (IaC)</u> tool created by HashiCorp.</li>
        <br/>
        <li>It allows you to <u>define, provision, and manage infrastructure</u>
            across multiple cloud providers using a declarative configuration language (HCL — HashiCorp Configuration Language).</li>
        <br/>
        <li>Instead of clicking in cloud dashboards, you write code describing your infrastructure — Terraform takes care of creating, updating, and deleting resources safely.</li>
    </ul>
    <br/><br/>


    <li><b>Key Characteristics</b></li>
    <br/>
    <ul>
        <li>You describe <u>what</u> you want, not <u>how</u> to do it.</li>
        <li>Supports many providers:
            <ul>
                <li>AWS, Azure, Google Cloud</li>
                <li>Alibaba Cloud, Oracle Cloud</li>
                <li>Kubernetes</li>
                <li>GitHub, Cloudflare, Datadog, etc.</li>
            </ul>
        </li>
        <li>Safe <u>execution plan</u> via <code>terraform plan</code>.</li>
        <li>Manages <u>dependencies</u> between resources automatically.</li>
        <li>Uses a <u>state file</u> to track real-world infrastructure.</li>
        <li>Works well in CI/CD pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Workflow</b></li>
    <br/>
    <ul>
        <li>Terraform follows a simple but powerful 4-step workflow:</li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Step</th>
                <th>Description</th>
                <th>Command</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>1. Write</b></td>
                <td>Write <code>.tf</code> files describing infrastructure.</td>
                <td>—</td>
            </tr>
            <tr>
                <td><b>2. Init</b></td>
                <td>Download providers and initialize the project.</td>
                <td><code>terraform init</code></td>
            </tr>
            <tr>
                <td><b>3. Plan</b></td>
                <td>Show what Terraform will create, modify, or destroy.</td>
                <td><code>terraform plan</code></td>
            </tr>
            <tr>
                <td><b>4. Apply</td>
                <td>Perform the actual infrastructure change.</td>
                <td><code>terraform apply</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>A Simple Terraform Example</b></li>
    <br/>
    <p>This example creates an AWS EC2 instance.</p>

<pre><code class="language-hcl line-numbers">provider "aws" {
  region = "eu-central-1"
}

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
</code></pre>

    <br/>
    <ul>
        <li><code>provider</code> block tells Terraform which cloud provider to use.</li>
        <li><code>resource</code> block describes an actual cloud object.</li>
        <li><code>aws_instance.example</code> becomes a managed resource in the Terraform state.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform State</b></li>
    <br/>
    <ul>
        <li>Terraform stores infrastructure details in a file called <code>terraform.tfstate</code>.</li>
        <br/>
        <li>This file tracks:
            <ul>
                <li>resource IDs</li>
                <li>connections between resources</li>
                <li>current configuration applied</li>
            </ul>
        </li>
        <br/>
        <li>This allows Terraform to detect changes and update resources safely.</li>
        <br/>
        <li>In teams, the state is usually stored remotely (S3, Azure Blob, Terraform Cloud).</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Language (HCL)</b></li>
    <br/>
    <ul>
        <li>Terraform uses <u>HCL (HashiCorp Configuration Language)</u>, which is:</li>
        <ul>
            <li>easy to read</li>
            <li>block-based</li>
            <li>supports variables, loops, functions, expressions</li>
        </ul>
        <br/>
        <li>Examples of HCL blocks:</li>
    </ul>

<pre><code class="language-hcl line-numbers">variable "project_name" {
  type = string
}

output "instance_id" {
  value = aws_instance.example.id
}
</code></pre>
    <br/><br/>


    <li><b>Common Terraform Terminology</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Term</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>provider</code></td>
                <td>Plugin to manage a service (e.g., AWS, Azure).</td>
            </tr>
            <tr>
                <td><code>resource</code></td>
                <td>A cloud object (VM, network, DB, etc.).</td>
            </tr>
            <tr>
                <td><code>data source</code></td>
                <td>Read existing infrastructure.</td>
            </tr>
            <tr>
                <td><code>module</code></td>
                <td>Reusable grouping of Terraform files.</td>
            </tr>
            <tr>
                <td><code>state</code></td>
                <td>The file storing real-world infrastructure details.</td>
            </tr>
            <tr>
                <td><code>plan</code></td>
                <td>Preview of actions before applying changes.</td>
            </tr>
            <tr>
                <td><code>apply</code></td>
                <td>Run the actual changes.</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-lifecycle">Terraform Resource Lifecycle</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Every Terraform <code>resource</code> has a <u>lifecycle</u> — a set of rules controlling how Terraform creates, updates, and destroys it.</li>
        <br/>
        <li>You can use the <code>lifecycle</code> block inside a resource to modify Terraform's default behavior.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>lifecycle</code> Block Structure</b></li>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"

  lifecycle {
    create_before_destroy = false
    prevent_destroy       = false
    ignore_changes        = []
  }
}
</code></pre>

    <br/>
    <ul>
        <li>The <code>lifecycle</code> block works inside <code>resource</code> definitions only.</li>
        <li>It modifies how Terraform handles changes, updates, and destruction.</li>
    </ul>
    <br/><br/>


    <li><code>create_before_destroy</code></li>
    <br/>
    <ul>
        <li>Normally Terraform does:
            <ul>
                <li>destroy the old resource</li>
                <li>then create a new one</li>
            </ul>
        </li>
        <br/>
        <li><code>create_before_destroy = true</code> reverses this order:
            <ul>
                <li>create new resource <u>first</u></li>
                <li>destroy the old one <u>after</u></li>
            </ul>
        </li>
        <br/>
        <li>Useful when:
            <ul>
                <li>you want zero downtime</li>
                <li>your resource cannot be deleted before a replacement exists</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  create_before_destroy = true
}
</code></pre>

    <br/><br/>


    <li><code>prevent_destroy</code></li>
    <br/>
    <ul>
        <li>Protects a resource from <u>accidental deletion</u>.</li>
        <li>If Terraform needs to destroy it, the <code>apply</code> will abort with an error.</li>
        <br/>
        <li>Commonly used for:
            <ul>
                <li>production databases</li>
                <li>S3 buckets containing critical data</li>
                <li>shared networks</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  prevent_destroy = true
}
</code></pre>

    <br/>
    <ul>
        <li>To override, you must temporarily remove <code>prevent_destroy</code> or force destruction with <code>-target</code> flags.</li>
    </ul>
    <br/><br/>


    <li><code>ignore_changes</code></li>
    <br/>
    <ul>
        <li>Tells Terraform to <u>ignore drift</u> on certain fields.</li>
        <li>Useful when some fields are updated by:
            <ul>
                <li>cloud providers</li>
                <li>external scripts</li>
                <li>manually modified settings</li>
            </ul>
        </li>
        <br/>
        <li>Prevents Terraform from trying to "fix" changes you don’t want overwritten.</li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  ignore_changes = [
    tags,
    metadata,
  ]
}
</code></pre>

    <br/>
    <ul>
        <li>Supports:
            <ul>
                <li>single attribute</li>
                <li>multiple attributes</li>
                <li><code>ignore_changes = all</code> (dangerous!)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Full Lifecycle Example</b></li>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "server" {
  ami           = "ami-123456"
  instance_type = "t3.micro"

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = false
    ignore_changes        = [
      tags["last_updated"],
      user_data,
    ]
  }
}
</code></pre>

    <br/>
    <ul>
        <li>This resource:
            <ul>
                <li>gets replaced without downtime</li>
                <li>can be destroyed normally</li>
                <li>does not react to changes in <code>user_data</code> or <code>tags.last_updated</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Lifecycle vs Depends On</b></li>
    <br/>
    <ul>
        <li>Lifecycle provides <u>behavior customization</u>.</li>
        <li><code>depends_on</code> enforces <u>ordering</u> between resources.</li>
        <br/>
        <li>They work together but serve different purposes.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_eip" "ip" {
  depends_on = [aws_instance.server]
}
</code></pre>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Setting</th>
                <th>Description</th>
                <th>Common Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>create_before_destroy</code></td>
                <td>Create replacement before destroying old resource</td>
                <td>Zero downtime deployments</td>
            </tr>
            <tr>
                <td><code>prevent_destroy</code></td>
                <td>Protect resource from deletion</td>
                <td>Critical databases, S3 buckets</td>
            </tr>
            <tr>
                <td><code>ignore_changes</code></td>
                <td>Ignore drift on specific attributes</td>
                <td>Provider-controlled fields, timestamps</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-cli">Terraform CLI (Command Line Interface)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The Terraform CLI is the primary way developers interact with Terraform.</li>
        <br/>
        <li>All Terraform workflows rely on the CLI, especially when working locally or inside CI/CD pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Command Structure</b></li>
    <br/>

<pre><code class="language-bash line-numbers">$ terraform &lt;command&gt; [options]
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform apply -auto-approve
</code></pre>

    <br/><br/>


    <li><b>Essential Terraform CLI Commands</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
                <th>Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>terraform init</code></td>
                <td>Initializes a working directory</td>
                <td>Download providers and set up backend</td>
            </tr>
            <tr>
                <td><code>terraform plan</code></td>
                <td>Show proposed changes</td>
                <td>Preview before apply</td>
            </tr>
            <tr>
                <td><code>terraform apply</code></td>
                <td>Apply the plan (create/update/destroy)</td>
                <td>Deploy infrastructure</td>
            </tr>
            <tr>
                <td><code>terraform destroy</code></td>
                <td>Destroy managed resources</td>
                <td>Cleanup infrastructure</td>
            </tr>
            <tr>
                <td><code>terraform validate</code></td>
                <td>Check module syntax</td>
                <td>Catches errors before running plan</td>
            </tr>
            <tr>
                <td><code>terraform fmt</code></td>
                <td>Format <code>.tf</code> files</td>
                <td>Enforce consistent style</td>
            </tr>
            <tr>
                <td><code>terraform providers</code></td>
                <td>Show used providers</td>
                <td>Dependency inspection</td>
            </tr>
            <tr>
                <td><code>terraform version</code></td>
                <td>Show Terraform version</td>
                <td>Debug/build info</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><code>terraform init</code></li>
    <br/>
    <ul>
        <li>Must be run once per project (or when providers/backends change).</li>
        <li>Downloads provider plugins.</li>
        <li>Initializes backend for state storage.</li>
        <li>Sets up module dependencies.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform init
Initializing the backend...
Initializing provider plugins...
Terraform has been successfully initialized!
</code></pre>
    <br/><br/>


    <li><code>terraform plan</code></li>
    <br/>
    <ul>
        <li>Shows what Terraform <u>would</u> do.</li>
        <li>No resources are changed.</li>
        <li>Output includes:
            <ul>
                <li>additions</li>
                <li>changes</li>
                <li>destructions</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform plan
Plan: 1 to add, 0 to change, 0 to destroy.
</code></pre>
    <br/><br/>


    <li><code>terraform apply</code></li>
    <br/>
    <ul>
        <li>Executes the plan and modifies infrastructure.</li>
        <li>Default behavior requires user confirmation.</li>
        <li>Use <code>-auto-approve</code> in automation.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform apply
Do you want to perform these actions?
  Enter a value: yes
</code></pre>
    <br/><br/>


    <li><code>terraform destroy</code></li>
    <br/>
    <ul>
        <li>Destroys all resources managed by Terraform.</li>
        <li>Useful for cleaning up dev environments.</li>
        <li>Confirmation required unless <code>-auto-approve</code> is used.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform destroy -auto-approve
</code></pre>
    <br/><br/>


    <li><code>terraform validate</code></li>
    <br/>
    <ul>
        <li>Checks configuration syntax.</li>
        <li>Verifies that the files are internally consistent.</li>
        <li>Does not check cloud provider availability.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform validate
Success! The configuration is valid.
</code></pre>
    <br/><br/>


    <li><code>terraform fmt</code></li>
    <br/>
    <ul>
        <li>Formats all Terraform files (<code>.tf</code> / <code>.tfvars</code>) to standard style.</li>
        <li>Keeps code clean in team environments.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform fmt
</code></pre>
    <br/><br/>


    <li><code>terraform show</code></li>
    <br/>
    <ul>
        <li>Displays the current state or a saved plan.</li>
        <li>Useful for debugging and documentation.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform show

# aws_instance.example:
resource "aws_instance" "example" {
    ami           = "ami-123456"
    instance_type = "t2.micro"
}
</code></pre>
    <br/><br/>


    <li><code>terraform graph</code></li>
    <br/>
    <ul>
        <li>Outputs a dependency graph in DOT format (Graphviz).</li>
        <li>Useful for visualizing relationships between resources.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform graph | dot -Tpng &gt; graph.png
</code></pre>
    <br/><br/>


    <li><code>terraform state</code> Commands</b></li>
    <br/>
    <ul>
        <li>The <code>terraform state</code> family manages state files.</li>
    </ul>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>state list</code></td>
                <td>List resources in state</td>
            </tr>
            <tr>
                <td><code>state show</code></td>
                <td>Show details for a resource</td>
            </tr>
            <tr>
                <td><code>state pull</code></td>
                <td>Download remote state</td>
            </tr>
            <tr>
                <td><code>state push</code></td>
                <td>Upload state manually</td>
            </tr>
            <tr>
                <td><code>state rm</code></td>
                <td>Remove resource from state</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><code>terraform import</code></li>
    <br/>
    <ul>
        <li>Add existing real-world resources to Terraform state.</li>
        <li>Useful when migrating to Terraform-managed infrastructure.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform import aws_instance.example i-1234567890abcdef0
</code></pre>
    <br/><br/>


    <li><b>Useful CLI Options</b></li>
    <br/>

<pre><code class="language-bash line-numbers">-auto-approve        # Skip yes/no prompt
-refresh=false       # Skip refreshing state
-target=&lt;address&gt;    # Apply a specific resource
-var name=value      # Pass variable
-var-file=file.tfvars
</code></pre>

    <br/><br/>


    <li><b>Summary of Terraform CLI</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Main Commands</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Setup</td>
                <td><code>init</code>, <code>fmt</code>, <code>validate</code></td>
            </tr>
            <tr>
                <td>Execution</td>
                <td><code>plan</code>, <code>apply</code>, <code>destroy</code></td>
            </tr>
            <tr>
                <td>State Management</td>
                <td><code>state</code>, <code>show</code>, <code>list</code>, <code>pull</code>, <code>push</code></td>
            </tr>
            <tr>
                <td>Migration</td>
                <td><code>import</code></td>
            </tr>
            <tr>
                <td>Debugging</td>
                <td><code>graph</code>, <code>providers</code>, <code>version</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-write-config">Writing Terraform Configuration</h3>
<ol>

    <li><b>What Does Terraform Configuration Mean?</b></li>
    <br/>
    <ul>
        <li>A Terraform <b>configuration</b> is a collection of <code>.tf</code> files that describe your desired infrastructure.</li>
        <br/>
        <li>Terraform uses a <b>declarative syntax</b> called HCL (HashiCorp Configuration Language).</li>
        <br/>
        <li>Configurations describe:
            <ul>
                <li>providers (AWS, Azure, GCP, Kubernetes, …),</li>
                <li>resources (servers, networks, buckets, etc.),</li>
                <li>variables and outputs,</li>
                <li>modules,</li>
                <li>data sources,</li>
                <li>state backend settings.</li>
            </ul>
        </li>
        <br/>
        <li>Terraform reads your <code>.tf</code> files, builds a desired-state graph, and then applies it to real cloud infrastructure.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Files and Directory Structure</b></li>
    <br/>
    <ul>
        <li>A typical Terraform directory might look like:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">.
├── main.tf
├── variables.tf
├── outputs.tf
└── terraform.tfvars
</code></pre>

    <ul>
        <li>Terraform automatically loads <b>every</b> <code>*.tf</code> files in the working directory.</li>
        <li>You don’t need to import them manually, Terraform merges them internally.</li>
    </ul>
    <br/><br/>


    <li><b>The</b> <code>terraform</code> <b>Block</b></li>
    <br/>
    <ul>
        <li>This block configures Terraform itself, especially:
            <ul>
                <li>required providers,</li>
                <li>backend (where state is stored),</li>
                <li>required terraform version.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_version = "&gt;= 1.5"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }

    backend "s3" {
        bucket = "my-tf-state"
        key    = "prod/terraform.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

    <ul>
        <li>The <code>backend</code> configuration (S3 example) is optional unless you're working in teams.</li>
    </ul>
    <br/><br/>


    <li><b>Provider Configuration</b></li>
    <br/>
    <ul>
        <li>A provider tells Terraform which cloud platform or service to interact with.</li>
        <li>Example for AWS:</li>
    </ul>

<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"
}
</code></pre>

    <ul>
        <li>Credentials can be set via:
            <ul>
                <li>environment variables (<code>AWS_ACCESS_KEY_ID</code>)</li>
                <li>AWS CLI config</li>
                <li>shared credentials files</li>
                <li>instance roles</li>
            </ul>
        </li>
        <li><b>Do not hardcode secrets</b> inside <code>.tf</code> files.</li>
    </ul>
    <br/><br/>


    <li><b>Resources: The Core of Terraform</b></li>
    <br/>
    <ul>
        <li>A <b>resource</b> is an infrastructure object Terraform manages.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "my_server" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = "t2.micro"

    tags = {
        Name = "DemoServer"
    }
}
</code></pre>

    <ul>
        <li>The identifier <code>aws_instance.my_server</code> becomes a referenceable object inside your configuration.</li>
        <br/>
        <li>You can reference attributes using interpolation:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_eip" "my_ip" {
    instance = aws_instance.my_server.id
}
</code></pre>

    <ul>
        <li>Terraform automatically builds dependency graphs based on references.</li>
    </ul>
    <br/><br/>


    <li><b>Variables</b></li>
    <br/>
    <ul>
        <li>Variables make your configuration reusable and configurable.</li>
        <li>Defined using:</li>
    </ul>

<pre><code class="language-hcl line-numbers">variable "instance_type" {
    description = "EC2 instance type"
    type        = string
    default     = "t2.micro"
}
</code></pre>

    <ul>
        <li>Used like:</li>
    </ul>

<pre><code class="language-hcl line-numbers">instance_type = var.instance_type
</code></pre>

    <ul>
        <li>Values can be passed via:
            <ul>
                <li><code>terraform.tfvars</code></li>
                <li><code>-var</code> command flag</li>
                <li>environment variables (<code>TF_VAR_...</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Variable Files</b> (<code>.tfvars</code>)</li>
    <br/>
    <ul>
        <li>Used to provide external input values:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">instance_type = "t3.small"
bucket_name   = "prod-assets-2025"
</code></pre>

    <ul>
        <li>Terraform automatically loads:</li>
        <ul>
            <li><code>terraform.tfvars</code></li>
            <li><code>*.auto.tfvars</code></li>
        </ul>
        <br/>
        <li>Other files require manual loading:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform apply -var-file=prod.tfvars
</code></pre>

    <br/><br/>


    <li><b>Outputs</b></li>
    <br/>
    <ul>
        <li>Outputs allow Terraform to display useful information after apply:</li>
    </ul>

<pre><code class="language-hcl line-numbers">output "public_ip" {
    description = "Public IP of the instance"
    value       = aws_instance.my_server.public_ip
}
</code></pre>

    <ul>
        <li>View outputs:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform output
terraform output public_ip
</code></pre>

    <br/><br/>


    <li><b>Locals</b></li>
    <br/>
    <ul>
        <li>Local values are internal configuration shortcuts.</li>
    </ul>

<pre><code class="language-hcl line-numbers">locals {
    tags = {
        Environment = "production"
        Owner       = "Junzhe"
    }
}

resource "aws_s3_bucket" "bucket" {
    bucket = "my-demo-bucket-2025"
    tags   = local.tags
}
</code></pre>

    <br/><br/>


    <li><b>Data Sources</b></li>
    <br/>
    <ul>
        <li>Data sources let Terraform <b>query existing resources</b>.</li>
        <li>Example: fetch the latest AMI ID:</li>
    </ul>

<pre><code class="language-hcl line-numbers">data "aws_ami" "latest_amazon_linux" {
    owners      = ["amazon"]
    most_recent = true

    filter {
        name   = "name"
        values = ["amzn2-ami-hvm-*-x86_64-gp2"]
    }
}

resource "aws_instance" "server" {
    ami           = data.aws_ami.latest_amazon_linux.id
    instance_type = "t2.micro"
}
</code></pre>

    <ul>
        <li>Data sources are <b>read-only</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Modules</b></li>
    <br/>
    <ul>
        <li>Modules allow you to group and reuse resources.</li>
        <li>Example using a public module:</li>
    </ul>

<pre><code class="language-hcl line-numbers">module "vpc" {
    source = "terraform-aws-modules/vpc/aws"
    version = "~&gt; 5.1"

    name = "prod-vpc"
    cidr = "10.0.0.0/16"
}
</code></pre>

    <ul>
        <li>You can also write your own module:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">
modules/
└── ec2/
    ├── main.tf
    ├── variables.tf
    └── outputs.tf
</code></pre>

    <br/><br/>


    <li><b>Expressions and Interpolation Syntax</b></li>
    <br/>
    <ul>
        <li>Terraform uses <code>${ ... }</code> for interpolation, but modern style allows direct reference:</li>
    </ul>

<pre><code class="language-hcl line-numbers">ami           = data.aws_ami.latest.id
instance_type = var.instance_type
tags          = local.tags
</code></pre>

    <ul>
        <li>Useful functions exist:</li>
    </ul>

<pre><code class="language-hcl line-numbers">timestamp()
upper("hello")
join("-", ["prod", "eu", "vpc"])
</code></pre>

    <br/><br/>


    <li><b>Lifecycle Rules</b></li>
    <br/>
    <ul>
        <li>Used for fine control over create/update/destroy behavior.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "server" {
    ami           = var.ami
    instance_type = "t2.micro"

    lifecycle {
        prevent_destroy = true
    }
}
</code></pre>

    <ul>
        <li>Other lifecycle options:
            <ul>
                <li><code>create_before_destroy</code></li>
                <li><code>ignore_changes</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Putting Everything Together: A Complete Example</b></li>
    <br/>
    <ul>
        <li>This small configuration provisions:
            <ul>
                <li>An EC2 instance</li>
                <li>An elastic IP</li>
                <li>Outputs its public IP</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"
}

variable "instance_type" {
    default = "t2.micro"
}

resource "aws_instance" "vm" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = var.instance_type

    tags = {
        Name = "ExampleVM"
    }
}

resource "aws_eip" "ip" {
    instance = aws_instance.vm.id
}

output "public_ip" {
    value = aws_eip.ip.public_ip
}
</code></pre>

    <ul>
        <li>Run it:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform init
terraform plan
terraform apply
</code></pre>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
