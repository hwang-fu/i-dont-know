<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Terraform</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/terraform.jpeg" alt="Terraform Logo"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#tf-what-is-terraform">What Is Terraform?</a></li>
        <li><a href="#terraform-lifecycle">Life Cycle</a></li>
        <li><a href="#terraform-cli">CLI</a></li>
        <li><a href="#terraform-write-config">Writing Terraform Configuration</a></li>
        <li><a href="#terraform-aws-intro">Introduction Using Terraform with AWS</a></li>
        <li><a href="#terraform-init-command">Understanding the <code>terraform init</code> Command</a></li>
        <li><a href="#terraform-block-reference">Understanding the <code>terraform</code> Block</a></li>
        <li><a href="#terraform-provider-reference">Understanding the <code>provider</code> Block</a></li>
        <li><a href="#terraform-resource-reference">Understanding the <code>resource</code> Block</a></li>
    </ol>
</nav>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="tf-what-is-terraform">What Is Terraform?</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>Terraform</code> is an open-source <u>Infrastructure as Code (IaC)</u> tool created by HashiCorp.</li>
        <br/>
        <li>It allows you to <u>define, provision, and manage infrastructure</u>
            across multiple cloud providers using a declarative configuration language (HCL — HashiCorp Configuration Language).</li>
        <br/>
        <li>Instead of clicking in cloud dashboards, you write code describing your infrastructure — Terraform takes care of creating, updating, and deleting resources safely.</li>
    </ul>
    <br/><br/>


    <li><b>Key Characteristics</b></li>
    <br/>
    <ul>
        <li>You describe <u>what</u> you want, not <u>how</u> to do it.</li>
        <li>Supports many providers:
            <ul>
                <li>AWS, Azure, Google Cloud</li>
                <li>Alibaba Cloud, Oracle Cloud</li>
                <li>Kubernetes</li>
                <li>GitHub, Cloudflare, Datadog, etc.</li>
            </ul>
        </li>
        <li>Safe <u>execution plan</u> via <code>terraform plan</code>.</li>
        <li>Manages <u>dependencies</u> between resources automatically.</li>
        <li>Uses a <u>state file</u> to track real-world infrastructure.</li>
        <li>Works well in CI/CD pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Workflow</b></li>
    <br/>
    <ul>
        <li>Terraform follows a simple but powerful 4-step workflow:</li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Step</th>
                <th>Description</th>
                <th>Command</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>1. Write</b></td>
                <td>Write <code>.tf</code> files describing infrastructure.</td>
                <td>—</td>
            </tr>
            <tr>
                <td><b>2. Init</b></td>
                <td>Download providers and initialize the project.</td>
                <td><code>terraform init</code></td>
            </tr>
            <tr>
                <td><b>3. Plan</b></td>
                <td>Show what Terraform will create, modify, or destroy.</td>
                <td><code>terraform plan</code></td>
            </tr>
            <tr>
                <td><b>4. Apply</td>
                <td>Perform the actual infrastructure change.</td>
                <td><code>terraform apply</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>A Simple Terraform Example</b></li>
    <br/>
    <p>This example creates an AWS EC2 instance.</p>

<pre><code class="language-hcl line-numbers">provider "aws" {
  region = "eu-central-1"
}

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
</code></pre>

    <br/>
    <ul>
        <li><code>provider</code> block tells Terraform which cloud provider to use.</li>
        <li><code>resource</code> block describes an actual cloud object.</li>
        <li><code>aws_instance.example</code> becomes a managed resource in the Terraform state.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform State</b></li>
    <br/>
    <ul>
        <li>Terraform stores infrastructure details in a file called <code>terraform.tfstate</code>.</li>
        <br/>
        <li>This file tracks:
            <ul>
                <li>resource IDs</li>
                <li>connections between resources</li>
                <li>current configuration applied</li>
            </ul>
        </li>
        <br/>
        <li>This allows Terraform to detect changes and update resources safely.</li>
        <br/>
        <li>In teams, the state is usually stored remotely (S3, Azure Blob, Terraform Cloud).</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Language (HCL)</b></li>
    <br/>
    <ul>
        <li>Terraform uses <u>HCL (HashiCorp Configuration Language)</u>, which is:</li>
        <ul>
            <li>easy to read</li>
            <li>block-based</li>
            <li>supports variables, loops, functions, expressions</li>
        </ul>
        <br/>
        <li>Examples of HCL blocks:</li>
    </ul>

<pre><code class="language-hcl line-numbers">variable "project_name" {
  type = string
}

output "instance_id" {
  value = aws_instance.example.id
}
</code></pre>
    <br/><br/>


    <li><b>Common Terraform Terminology</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Term</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>provider</code></td>
                <td>Plugin to manage a service (e.g., AWS, Azure).</td>
            </tr>
            <tr>
                <td><code>resource</code></td>
                <td>A cloud object (VM, network, DB, etc.).</td>
            </tr>
            <tr>
                <td><code>data source</code></td>
                <td>Read existing infrastructure.</td>
            </tr>
            <tr>
                <td><code>module</code></td>
                <td>Reusable grouping of Terraform files.</td>
            </tr>
            <tr>
                <td><code>state</code></td>
                <td>The file storing real-world infrastructure details.</td>
            </tr>
            <tr>
                <td><code>plan</code></td>
                <td>Preview of actions before applying changes.</td>
            </tr>
            <tr>
                <td><code>apply</code></td>
                <td>Run the actual changes.</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-lifecycle">Terraform Resource Lifecycle</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Every Terraform <code>resource</code> has a <u>lifecycle</u> — a set of rules controlling how Terraform creates, updates, and destroys it.</li>
        <br/>
        <li>You can use the <code>lifecycle</code> block inside a resource to modify Terraform's default behavior.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>lifecycle</code> Block Structure</b></li>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"

  lifecycle {
    create_before_destroy = false
    prevent_destroy       = false
    ignore_changes        = []
  }
}
</code></pre>

    <br/>
    <ul>
        <li>The <code>lifecycle</code> block works inside <code>resource</code> definitions only.</li>
        <li>It modifies how Terraform handles changes, updates, and destruction.</li>
    </ul>
    <br/><br/>


    <li><code>create_before_destroy</code></li>
    <br/>
    <ul>
        <li>Normally Terraform does:
            <ul>
                <li>destroy the old resource</li>
                <li>then create a new one</li>
            </ul>
        </li>
        <br/>
        <li><code>create_before_destroy = true</code> reverses this order:
            <ul>
                <li>create new resource <u>first</u></li>
                <li>destroy the old one <u>after</u></li>
            </ul>
        </li>
        <br/>
        <li>Useful when:
            <ul>
                <li>you want zero downtime</li>
                <li>your resource cannot be deleted before a replacement exists</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  create_before_destroy = true
}
</code></pre>

    <br/><br/>


    <li><code>prevent_destroy</code></li>
    <br/>
    <ul>
        <li>Protects a resource from <u>accidental deletion</u>.</li>
        <li>If Terraform needs to destroy it, the <code>apply</code> will abort with an error.</li>
        <br/>
        <li>Commonly used for:
            <ul>
                <li>production databases</li>
                <li>S3 buckets containing critical data</li>
                <li>shared networks</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  prevent_destroy = true
}
</code></pre>

    <br/>
    <ul>
        <li>To override, you must temporarily remove <code>prevent_destroy</code> or force destruction with <code>-target</code> flags.</li>
    </ul>
    <br/><br/>


    <li><code>ignore_changes</code></li>
    <br/>
    <ul>
        <li>Tells Terraform to <u>ignore drift</u> on certain fields.</li>
        <li>Useful when some fields are updated by:
            <ul>
                <li>cloud providers</li>
                <li>external scripts</li>
                <li>manually modified settings</li>
            </ul>
        </li>
        <br/>
        <li>Prevents Terraform from trying to "fix" changes you don’t want overwritten.</li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  ignore_changes = [
    tags,
    metadata,
  ]
}
</code></pre>

    <br/>
    <ul>
        <li>Supports:
            <ul>
                <li>single attribute</li>
                <li>multiple attributes</li>
                <li><code>ignore_changes = all</code> (dangerous!)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Full Lifecycle Example</b></li>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "server" {
  ami           = "ami-123456"
  instance_type = "t3.micro"

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = false
    ignore_changes        = [
      tags["last_updated"],
      user_data,
    ]
  }
}
</code></pre>

    <br/>
    <ul>
        <li>This resource:
            <ul>
                <li>gets replaced without downtime</li>
                <li>can be destroyed normally</li>
                <li>does not react to changes in <code>user_data</code> or <code>tags.last_updated</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Lifecycle vs Depends On</b></li>
    <br/>
    <ul>
        <li>Lifecycle provides <u>behavior customization</u>.</li>
        <li><code>depends_on</code> enforces <u>ordering</u> between resources.</li>
        <br/>
        <li>They work together but serve different purposes.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_eip" "ip" {
  depends_on = [aws_instance.server]
}
</code></pre>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Setting</th>
                <th>Description</th>
                <th>Common Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>create_before_destroy</code></td>
                <td>Create replacement before destroying old resource</td>
                <td>Zero downtime deployments</td>
            </tr>
            <tr>
                <td><code>prevent_destroy</code></td>
                <td>Protect resource from deletion</td>
                <td>Critical databases, S3 buckets</td>
            </tr>
            <tr>
                <td><code>ignore_changes</code></td>
                <td>Ignore drift on specific attributes</td>
                <td>Provider-controlled fields, timestamps</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-cli">Terraform CLI (Command Line Interface)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The Terraform CLI is the primary way developers interact with Terraform.</li>
        <br/>
        <li>All Terraform workflows rely on the CLI, especially when working locally or inside CI/CD pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Command Structure</b></li>
    <br/>

<pre><code class="language-bash line-numbers">$ terraform &lt;command&gt; [options]
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform apply -auto-approve
</code></pre>

    <br/><br/>


    <li><b>Essential Terraform CLI Commands</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
                <th>Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>terraform init</code></td>
                <td>Initializes a working directory</td>
                <td>Download providers and set up backend</td>
            </tr>
            <tr>
                <td><code>terraform plan</code></td>
                <td>Show proposed changes</td>
                <td>Preview before apply</td>
            </tr>
            <tr>
                <td><code>terraform apply</code></td>
                <td>Apply the plan (create/update/destroy)</td>
                <td>Deploy infrastructure</td>
            </tr>
            <tr>
                <td><code>terraform destroy</code></td>
                <td>Destroy managed resources</td>
                <td>Cleanup infrastructure</td>
            </tr>
            <tr>
                <td><code>terraform validate</code></td>
                <td>Check module syntax</td>
                <td>Catches errors before running plan</td>
            </tr>
            <tr>
                <td><code>terraform fmt</code></td>
                <td>Format <code>.tf</code> files</td>
                <td>Enforce consistent style</td>
            </tr>
            <tr>
                <td><code>terraform providers</code></td>
                <td>Show used providers</td>
                <td>Dependency inspection</td>
            </tr>
            <tr>
                <td><code>terraform version</code></td>
                <td>Show Terraform version</td>
                <td>Debug/build info</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><code>terraform init</code></li>
    <br/>
    <ul>
        <li>Must be run once per project (or when providers/backends change).</li>
        <li>Downloads provider plugins.</li>
        <li>Initializes backend for state storage.</li>
        <li>Sets up module dependencies.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform init
Initializing the backend...
Initializing provider plugins...
Terraform has been successfully initialized!
</code></pre>
    <br/><br/>


    <li><code>terraform plan</code></li>
    <br/>
    <ul>
        <li>Shows what Terraform <u>would</u> do.</li>
        <li>No resources are changed.</li>
        <li>Output includes:
            <ul>
                <li>additions</li>
                <li>changes</li>
                <li>destructions</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform plan
Plan: 1 to add, 0 to change, 0 to destroy.
</code></pre>
    <br/><br/>


    <li><code>terraform apply</code></li>
    <br/>
    <ul>
        <li>Executes the plan and modifies infrastructure.</li>
        <li>Default behavior requires user confirmation.</li>
        <li>Use <code>-auto-approve</code> in automation.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform apply
Do you want to perform these actions?
  Enter a value: yes
</code></pre>
    <br/><br/>


    <li><code>terraform destroy</code></li>
    <br/>
    <ul>
        <li>Destroys all resources managed by Terraform.</li>
        <li>Useful for cleaning up dev environments.</li>
        <li>Confirmation required unless <code>-auto-approve</code> is used.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform destroy -auto-approve
</code></pre>
    <br/><br/>


    <li><code>terraform validate</code></li>
    <br/>
    <ul>
        <li>Checks configuration syntax.</li>
        <li>Verifies that the files are internally consistent.</li>
        <li>Does not check cloud provider availability.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform validate
Success! The configuration is valid.
</code></pre>
    <br/><br/>


    <li><code>terraform fmt</code></li>
    <br/>
    <ul>
        <li>Formats all Terraform files (<code>.tf</code> / <code>.tfvars</code>) to standard style.</li>
        <li>Keeps code clean in team environments.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform fmt
</code></pre>
    <br/><br/>


    <li><code>terraform show</code></li>
    <br/>
    <ul>
        <li>Displays the current state or a saved plan.</li>
        <li>Useful for debugging and documentation.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform show

# aws_instance.example:
resource "aws_instance" "example" {
    ami           = "ami-123456"
    instance_type = "t2.micro"
}
</code></pre>
    <br/><br/>


    <li><code>terraform graph</code></li>
    <br/>
    <ul>
        <li>Outputs a dependency graph in DOT format (Graphviz).</li>
        <li>Useful for visualizing relationships between resources.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform graph | dot -Tpng &gt; graph.png
</code></pre>
    <br/><br/>


    <li><code>terraform state</code> Commands</b></li>
    <br/>
    <ul>
        <li>The <code>terraform state</code> family manages state files.</li>
    </ul>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>state list</code></td>
                <td>List resources in state</td>
            </tr>
            <tr>
                <td><code>state show</code></td>
                <td>Show details for a resource</td>
            </tr>
            <tr>
                <td><code>state pull</code></td>
                <td>Download remote state</td>
            </tr>
            <tr>
                <td><code>state push</code></td>
                <td>Upload state manually</td>
            </tr>
            <tr>
                <td><code>state rm</code></td>
                <td>Remove resource from state</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><code>terraform import</code></li>
    <br/>
    <ul>
        <li>Add existing real-world resources to Terraform state.</li>
        <li>Useful when migrating to Terraform-managed infrastructure.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform import aws_instance.example i-1234567890abcdef0
</code></pre>
    <br/><br/>


    <li><b>Useful CLI Options</b></li>
    <br/>

<pre><code class="language-bash line-numbers">-auto-approve        # Skip yes/no prompt
-refresh=false       # Skip refreshing state
-target=&lt;address&gt;    # Apply a specific resource
-var name=value      # Pass variable
-var-file=file.tfvars
</code></pre>

    <br/><br/>


    <li><b>Summary of Terraform CLI</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Main Commands</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Setup</td>
                <td><code>init</code>, <code>fmt</code>, <code>validate</code></td>
            </tr>
            <tr>
                <td>Execution</td>
                <td><code>plan</code>, <code>apply</code>, <code>destroy</code></td>
            </tr>
            <tr>
                <td>State Management</td>
                <td><code>state</code>, <code>show</code>, <code>list</code>, <code>pull</code>, <code>push</code></td>
            </tr>
            <tr>
                <td>Migration</td>
                <td><code>import</code></td>
            </tr>
            <tr>
                <td>Debugging</td>
                <td><code>graph</code>, <code>providers</code>, <code>version</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-write-config">Writing Terraform Configuration</h3>
<ol>

    <li><b>What Does Terraform Configuration Mean?</b></li>
    <br/>
    <ul>
        <li>A Terraform <b>configuration</b> is a collection of <code>.tf</code> files that describe your desired infrastructure.</li>
        <br/>
        <li>Terraform uses a <b>declarative syntax</b> called HCL (HashiCorp Configuration Language).</li>
        <br/>
        <li>Configurations describe:
            <ul>
                <li>providers (AWS, Azure, GCP, Kubernetes, …),</li>
                <li>resources (servers, networks, buckets, etc.),</li>
                <li>variables and outputs,</li>
                <li>modules,</li>
                <li>data sources,</li>
                <li>state backend settings.</li>
            </ul>
        </li>
        <br/>
        <li>Terraform reads your <code>.tf</code> files, builds a desired-state graph, and then applies it to real cloud infrastructure.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Files and Directory Structure</b></li>
    <br/>
    <ul>
        <li>A typical Terraform directory might look like:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">.
├── main.tf
├── variables.tf
├── outputs.tf
└── terraform.tfvars
</code></pre>

    <ul>
        <li>Terraform automatically loads <b>every</b> <code>*.tf</code> files in the working directory.</li>
        <li>You don’t need to import them manually, Terraform merges them internally.</li>
    </ul>
    <br/><br/>


    <li><b>The</b> <code>terraform</code> <b>Block</b></li>
    <br/>
    <ul>
        <li>This block configures Terraform itself, especially:
            <ul>
                <li>required providers,</li>
                <li>backend (where state is stored),</li>
                <li>required terraform version.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_version = "&gt;= 1.5"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }

    backend "s3" {
        bucket = "my-tf-state"
        key    = "prod/terraform.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

    <ul>
        <li>The <code>backend</code> configuration (S3 example) is optional unless you're working in teams.</li>
    </ul>
    <br/><br/>


    <li><b>Provider Configuration</b></li>
    <br/>
    <ul>
        <li>A provider tells Terraform which cloud platform or service to interact with.</li>
        <li>Example for AWS:</li>
    </ul>

<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"
}
</code></pre>

    <ul>
        <li>Credentials can be set via:
            <ul>
                <li>environment variables (<code>AWS_ACCESS_KEY_ID</code>)</li>
                <li>AWS CLI config</li>
                <li>shared credentials files</li>
                <li>instance roles</li>
            </ul>
        </li>
        <li><b>Do not hardcode secrets</b> inside <code>.tf</code> files.</li>
    </ul>
    <br/><br/>


    <li><b>Resources: The Core of Terraform</b></li>
    <br/>
    <ul>
        <li>A <b>resource</b> is an infrastructure object Terraform manages.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "my_server" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = "t2.micro"

    tags = {
        Name = "DemoServer"
    }
}
</code></pre>

    <ul>
        <li>The identifier <code>aws_instance.my_server</code> becomes a referenceable object inside your configuration.</li>
        <br/>
        <li>You can reference attributes using interpolation:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_eip" "my_ip" {
    instance = aws_instance.my_server.id
}
</code></pre>

    <ul>
        <li>Terraform automatically builds dependency graphs based on references.</li>
    </ul>
    <br/><br/>


    <li><b>Variables</b></li>
    <br/>
    <ul>
        <li>Variables make your configuration reusable and configurable.</li>
        <li>Defined using:</li>
    </ul>

<pre><code class="language-hcl line-numbers">variable "instance_type" {
    description = "EC2 instance type"
    type        = string
    default     = "t2.micro"
}
</code></pre>

    <ul>
        <li>Used like:</li>
    </ul>

<pre><code class="language-hcl line-numbers">instance_type = var.instance_type
</code></pre>

    <ul>
        <li>Values can be passed via:
            <ul>
                <li><code>terraform.tfvars</code></li>
                <li><code>-var</code> command flag</li>
                <li>environment variables (<code>TF_VAR_...</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Variable Files</b> (<code>.tfvars</code>)</li>
    <br/>
    <ul>
        <li>Used to provide external input values:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">instance_type = "t3.small"
bucket_name   = "prod-assets-2025"
</code></pre>

    <ul>
        <li>Terraform automatically loads:</li>
        <ul>
            <li><code>terraform.tfvars</code></li>
            <li><code>*.auto.tfvars</code></li>
        </ul>
        <br/>
        <li>Other files require manual loading:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform apply -var-file=prod.tfvars
</code></pre>

    <br/><br/>


    <li><b>Outputs</b></li>
    <br/>
    <ul>
        <li>Outputs allow Terraform to display useful information after apply:</li>
    </ul>

<pre><code class="language-hcl line-numbers">output "public_ip" {
    description = "Public IP of the instance"
    value       = aws_instance.my_server.public_ip
}
</code></pre>

    <ul>
        <li>View outputs:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform output
terraform output public_ip
</code></pre>

    <br/><br/>


    <li><b>Locals</b></li>
    <br/>
    <ul>
        <li>Local values are internal configuration shortcuts.</li>
    </ul>

<pre><code class="language-hcl line-numbers">locals {
    tags = {
        Environment = "production"
        Owner       = "Junzhe"
    }
}

resource "aws_s3_bucket" "bucket" {
    bucket = "my-demo-bucket-2025"
    tags   = local.tags
}
</code></pre>

    <br/><br/>


    <li><b>Data Sources</b></li>
    <br/>
    <ul>
        <li>Data sources let Terraform <b>query existing resources</b>.</li>
        <li>Example: fetch the latest AMI ID:</li>
    </ul>

<pre><code class="language-hcl line-numbers">data "aws_ami" "latest_amazon_linux" {
    owners      = ["amazon"]
    most_recent = true

    filter {
        name   = "name"
        values = ["amzn2-ami-hvm-*-x86_64-gp2"]
    }
}

resource "aws_instance" "server" {
    ami           = data.aws_ami.latest_amazon_linux.id
    instance_type = "t2.micro"
}
</code></pre>

    <ul>
        <li>Data sources are <b>read-only</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Modules</b></li>
    <br/>
    <ul>
        <li>Modules allow you to group and reuse resources.</li>
        <li>Example using a public module:</li>
    </ul>

<pre><code class="language-hcl line-numbers">module "vpc" {
    source = "terraform-aws-modules/vpc/aws"
    version = "~&gt; 5.1"

    name = "prod-vpc"
    cidr = "10.0.0.0/16"
}
</code></pre>

    <ul>
        <li>You can also write your own module:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">
modules/
└── ec2/
    ├── main.tf
    ├── variables.tf
    └── outputs.tf
</code></pre>

    <br/><br/>


    <li><b>Expressions and Interpolation Syntax</b></li>
    <br/>
    <ul>
        <li>Terraform uses <code>${ ... }</code> for interpolation, but modern style allows direct reference:</li>
    </ul>

<pre><code class="language-hcl line-numbers">ami           = data.aws_ami.latest.id
instance_type = var.instance_type
tags          = local.tags
</code></pre>

    <ul>
        <li>Useful functions exist:</li>
    </ul>

<pre><code class="language-hcl line-numbers">timestamp()
upper("hello")
join("-", ["prod", "eu", "vpc"])
</code></pre>

    <br/><br/>


    <li><b>Lifecycle Rules</b></li>
    <br/>
    <ul>
        <li>Used for fine control over create/update/destroy behavior.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "server" {
    ami           = var.ami
    instance_type = "t2.micro"

    lifecycle {
        prevent_destroy = true
    }
}
</code></pre>

    <ul>
        <li>Other lifecycle options:
            <ul>
                <li><code>create_before_destroy</code></li>
                <li><code>ignore_changes</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Putting Everything Together: A Complete Example</b></li>
    <br/>
    <ul>
        <li>This small configuration provisions:
            <ul>
                <li>An EC2 instance</li>
                <li>An elastic IP</li>
                <li>Outputs its public IP</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"
}

variable "instance_type" {
    default = "t2.micro"
}

resource "aws_instance" "vm" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = var.instance_type

    tags = {
        Name = "ExampleVM"
    }
}

resource "aws_eip" "ip" {
    instance = aws_instance.vm.id
}

output "public_ip" {
    value = aws_eip.ip.public_ip
}
</code></pre>

    <ul>
        <li>Run it:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform init
terraform plan
terraform apply
</code></pre>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-aws-intro">Using Terraform with AWS: An Introduction</h3>
<ol>

    <li><b>What Is AWS Terraform?</b></li>
    <br/>
    <ul>
        <li>Terraform can manage nearly all AWS resources using the <b>AWS Provider</b>.</li>
        <br/>
        <li>You write <code>.tf</code> files that describe what AWS infrastructure you want:
            <ul>
                <li>EC2 instances</li>
                <li>VPCs and subnets</li>
                <li>IAM users and roles</li>
                <li>S3 buckets</li>
                <li>RDS databases</li>
                <li>Lambda functions</li>
                <li>CloudWatch alarms</li>
                <li>Load balancers</li>
            </ul>
        </li>
        <br/>
        <li>Terraform then:
            <ul>
                <li>calls AWS APIs via the provider,</li>
                <li>creates/updates/destroys resources,</li>
                <li>tracks them in its state file.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Prerequisites for AWS Terraform</b></li>
    <br/>
    <ul>
        <li>Before using Terraform with AWS, you must have:</li>
        <ul>
            <li>an AWS account,</li>
            <li>an IAM user with enough permissions,</li>
            <li>AWS credentials saved locally.</li>
        </ul>
        <br/>
        <li><b>Store credentials safely</b> using the AWS CLI:</li>
    </ul>

<pre><code class="language-bash line-numbers">aws configure
</code></pre>

    <ul>
        <li>Typical files where credentials go:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">~/.aws/credentials
~/.aws/config
</code></pre>

    <ul>
        <li><b>Never store AWS secret keys directly in Terraform files.</b></li>
    </ul>
    <br/><br/>


    <li><b>AWS Provider Block</b></li>
    <br/>
    <ul>
        <li>The AWS provider connects Terraform to AWS.</li>
        <li>Basic configuration:</li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"
}
</code></pre>

    <ul>
        <li>Terraform loads credentials automatically from environment variables, the AWS config file, or IAM roles (if on EC2).</li>
    </ul>
    <br/><br/>


    <li><b>Deploying Your First AWS Resource: S3 Bucket</b></li>
    <br/>
    <ul>
        <li>S3 buckets are one of the simplest AWS resources to create:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "example" {
    bucket = "junzhe-demo-bucket-12345"

    tags = {
        Purpose = "TerraformIntro"
    }
}
</code></pre>

    <ul>
        <li>Apply it:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform init
terraform apply
</code></pre>

    <ul>
        <li>You now created your first AWS resource using Terraform.</li>
    </ul>
    <br/><br/>


    <li><b>Creating an EC2 Instance with Terraform</b></li>
    <br/>
    <ul>
        <li>EC2 deployment includes:
            <ul>
                <li>an AMI (machine image)</li>
                <li>instance type</li>
                <li>optional key pair</li>
                <li>security group</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "web" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = "t2.micro"

    tags = {
        Name = "TerraformWebServer"
    }
}
</code></pre>

    <ul>
        <li>Show the server’s public IP:</li>
    </ul>

<pre><code class="language-hcl line-numbers">output "public_ip" {
    value = aws_instance.web.public_ip
}
</code></pre>

    <br/><br/>


    <li><b>Using Data Sources (AWS Example)</b></li>
    <br/>
    <ul>
        <li>AWS has many dynamic values (latest AMIs, VPC IDs, etc.).</li>
        <li>Data sources allow Terraform to <b>look up existing AWS infrastructure</b>.</li>
    </ul>

<pre><code class="language-hcl line-numbers">data "aws_ami" "amazon_linux" {
    owners      = ["amazon"]
    most_recent = true

    filter {
        name   = "name"
        values = ["amzn2-ami-hvm-*-x86_64-gp2"]
    }
}

resource "aws_instance" "server" {
    ami           = data.aws_ami.amazon_linux.id
    instance_type = "t2.micro"
}
</code></pre>

    <ul>
        <li>Using a data source ensures your AMI is always up to date.</li>
    </ul>
    <br/><br/>


    <li><b>Managing AWS Networking (VPC, Subnets, SG)</b></li>
    <br/>
    <ul>
        <li>A typical AWS Terraform setup includes:
            <ul>
                <li>VPC</li>
                <li>subnets</li>
                <li>route tables</li>
                <li>security groups</li>
            </ul>
        </li>
        <br/>
        <li>A minimal example:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_vpc" "main" {
    cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
    vpc_id                  = aws_vpc.main.id
    cidr_block              = "10.0.1.0/24"
    map_public_ip_on_launch = true
}

resource "aws_security_group" "web_sg" {
    name        = "web-sg"
    description = "Allow HTTP"
    vpc_id      = aws_vpc.main.id

    ingress {
        from_port   = 80
        to_port     = 80
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
    }
}
</code></pre>

    <ul>
        <li>This is the foundation for most AWS architectures.</li>
    </ul>
    <br/><br/>


    <li><b>IAM with Terraform (Users, Roles, Policies)</b></li>
    <br/>
    <ul>
        <li>IAM is fully manageable through Terraform.</li>
        <li>Create a new user:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_iam_user" "developer" {
    name = "junzhe-dev"
}

resource "aws_iam_access_key" "developer_key" {
    user = aws_iam_user.developer.name
}

output "dev_access_key" {
    value = aws_iam_access_key.developer_key.id
}
</code></pre>

    <ul>
        <li><b>Never output IAM secrets in production environments.</b></li>
    </ul>
    <br/><br/>


    <li><b>S3 + IAM Example (Realistic Use Case)</b></li>
    <br/>
    <ul>
        <li>This example creates a bucket and a policy that grants read/write access.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "app_bucket" {
    bucket = "terraform-app-bucket-2025"
}

data "aws_iam_policy_document" "rw_access" {
    statement {
        actions   = ["s3:*"]
        resources = [
            aws_s3_bucket.app_bucket.arn,
            "${aws_s3_bucket.app_bucket.arn}/*"
        ]
    }
}

resource "aws_iam_policy" "app_bucket_policy" {
    name   = "AppBucketRW"
    policy = data.aws_iam_policy_document.rw_access.json
}
</code></pre>

    <br/><br/>


    <li><b>Using AWS Modules</b></li>
    <br/>
    <ul>
        <li>The easiest way to build AWS infrastructure is by using well-maintained Terraform Registry modules.</li>
        <li>Example: AWS VPC module</li>
    </ul>

<pre><code class="language-hcl line-numbers">module "vpc" {
    source  = "terraform-aws-modules/vpc/aws"
    version = "5.1.0"

    name = "production-vpc"
    cidr = "10.1.0.0/16"

    azs             = ["eu-central-1a", "eu-central-1b"]
    public_subnets  = ["10.1.1.0/24", "10.1.2.0/24"]
    private_subnets = ["10.1.3.0/24", "10.1.4.0/24"]
}
</code></pre>

    <ul>
        <li>Modules drastically reduce effort and errors.</li>
    </ul>
    <br/><br/>


    <li><b>Remote State Backend for AWS Projects (Recommended)</b></li>
    <br/>
    <ul>
        <li>For team projects, store Terraform state in S3 and lock with DynamoDB:</li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    backend "s3" {
        bucket         = "my-terraform-state-prod"
        key            = "global/state.tfstate"
        region         = "eu-central-1"
        dynamodb_table = "terraform-locks"
        encrypt        = true
    }
}
</code></pre>

    <ul>
        <li>This prevents:
            <ul>
                <li>conflicting changes,</li>
                <li>lost state files,</li>
                <li>corrupted environments.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Common AWS Terraform Patterns</b></li>
    <br/>
    <ul>
        <li>Almost every AWS Terraform project involves:</li>
        <ul>
            <li>using data sources to fetch AMIs</li>
            <li>creating VPC + subnets</li>
            <li>security groups for inbound/outbound rules</li>
            <li>EC2 instances or ECS/Lambda</li>
            <li>IAM roles for services</li>
            <li>S3 buckets for artifacts</li>
            <li>CloudWatch for monitoring</li>
            <li>Route53 for DNS</li>
        </ul>
        <br/>
        <li>These patterns can scale from tiny personal projects to large enterprise deployments.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-init-command">Understanding the <code>terraform init</code> Command</h3>
<ol>

    <li>What Does <code>terraform init</code> Do?</li>
    <br/>
    <ul>
        <li><code>terraform init</code> is the <b>first command</b> you run in any new or cloned Terraform project directory.</li>
        <br/>
        <li>Its main responsibilities:</li>
        <ul>
            <li>Initialize the working directory as a Terraform project</li>
            <li>Download and install required <b>providers</b> (e.g. AWS, Azure, Google)</li>
            <li>Download <b>modules</b> defined in your configuration</li>
            <li>Initialize and configure the <b>backend</b> (where the state is stored)</li>
            <li>Create internal metadata like <code>.terraform/</code> and <code>.terraform.lock.hcl</code></li>
        </ul>
        <br/>
        <li>Typical workflow:</li>
<pre><code class="language-bash line-numbers">terraform init
terraform plan
terraform apply</code></pre>
        <br/>
        <li>If you skip <code>terraform init</code>, <code>plan</code> and <code>apply</code> will fail because providers/backends are not set up.</li>
    </ul>
    <br/><br/>


    <li>What Happens in the Working Directory?</li>
    <br/>
    <ul>
        <li>After running <code>terraform init</code>, Terraform creates/updates:</li>
        <br/>
        <ul>
            <li><code>.terraform/</code> — internal directory for:
                <ul>
                    <li>downloaded provider plugins</li>
                    <li>downloaded modules</li>
                    <li>backend metadata</li>
                </ul>
            </li>
            <li><code>.terraform.lock.hcl</code> — dependency lockfile (provider versions, etc.)</li>
        </ul>
        <br/>
        <li>This makes your project:
            <ul>
                <li>reproducible (same provider versions)</li>
                <li>ready to run plans/applies</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Basic Usage: <code>terraform init</code></li>
    <br/>
    <ul>
        <li>Inside a folder containing <code>*.tf</code> files:</li>
<pre><code class="language-bash line-numbers">cd my-terraform-project
terraform init</code></pre>
        <br/>
        <li>Terraform then:</li>
        <ul>
            <li>Scans your <code>.tf</code> files for:
                <ul>
                    <li><code>required_providers</code></li>
                    <li><code>terraform</code> block</li>
                    <li><code>backend</code> configuration</li>
                    <li><code>module</code> blocks</li>
                </ul>
            </li>
            <li>Downloads missing providers</li>
            <li>Fetches modules from:
                <ul>
                    <li>Terraform Registry</li>
                    <li>Git repositories</li>
                    <li>local paths</li>
                </ul>
            </li>
            <li>Configures backend (local or remote state)</li>
        </ul>
        <br/>
        <li>You usually run this:
            <ul>
                <li>once when starting a new project</li>
                <li>again when:
                    <ul>
                        <li>changing providers/backends</li>
                        <li>upgrading provider versions</li>
                        <li>adding new modules</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>How <code>terraform init</code> Handles Providers</li>
    <br/>
    <ul>
        <li>Example configuration (<code>main.tf</code>):</li>
<pre><code class="language-hcl line-numbers">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 5.0"
    }
  }
}</code></pre>
        <br/>
        <li>When you run:</li>
<pre><code class="language-bash line-numbers">terraform init</code></pre>
        <br/>
        <li>Terraform will:</li>
        <ul>
            <li>Look up provider <code>"hashicorp/aws"</code> in the Terraform Registry</li>
            <li>Download a version compatible with <code>~&gt; 5.0</code></li>
            <li>Store it under <code>.terraform/providers/...</code></li>
            <li>Record the exact version in <code>.terraform.lock.hcl</code></li>
        </ul>
        <br/>
        <li>This ensures every developer on the project uses exactly the same provider versions.</li>
    </ul>
    <br/><br/>


    <li>How <code>terraform init</code> Handles Modules</li>
    <br/>
    <ul>
        <li>Example module usage:</li>
<pre><code class="language-hcl line-numbers">module "network" {
  source = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"

  name = "example-vpc"
  cidr = "10.0.0.0/16"
}</code></pre>
        <br/>
        <li>On <code>terraform init</code>, Terraform will:</li>
        <ul>
            <li>Locate module <code>terraform-aws-modules/vpc/aws</code> in the Registry</li>
            <li>Download it into <code>.terraform/modules/</code></li>
            <li>Use that local copy when running <code>plan</code>/<code>apply</code></li>
        </ul>
        <br/>
        <li>If you update <code>version</code> or <code>source</code>, re-run <code>terraform init</code> to fetch the new module version.</li>
    </ul>
    <br/><br/>


    <li>Backends and <code>terraform init</code></li>
    <br/>
    <ul>
        <li>The <b>backend</b> defines where your Terraform state (<code>terraform.tfstate</code>) is stored.</li>
        <br/>
        <li>Example local backend (default):</li>
<pre><code class="language-hcl line-numbers">terraform {
  backend "local" {
    path = "terraform.tfstate"
  }
}</code></pre>
        <br/>
        <li>Example remote backend (Amazon S3):</li>
<pre><code class="language-hcl line-numbers">terraform {
  backend "s3" {
    bucket = "my-terraform-state-bucket"
    key    = "envs/prod/terraform.tfstate"
    region = "eu-central-1"
  }
}</code></pre>
        <br/>
        <li>When you run <code>terraform init</code> with a backend block:</li>
        <ul>
            <li>Terraform configures the backend</li>
            <li>It may prompt you to migrate existing local state into the remote backend</li>
            <li>It writes backend metadata into <code>.terraform/</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li>Useful Options for <code>terraform init</code></li>
    <br/>
    <ul>
        <li>1. <code>-upgrade</code> &mdash; Upgrade providers and modules</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -upgrade</code></pre>
        <li>What it does:</li>
        <ul>
            <li>Checks for newer versions of required providers (within your version constraints)</li>
            <li>Redownloads modules to the latest acceptable versions</li>
            <li>Updates <code>.terraform.lock.hcl</code></li>
        </ul>
        <br/>
        <br/>

        <li>2. <code>-backend-config</code> &mdash; Override backend settings</li>
        <br/>
        <li>Instead of putting secrets in <code>.tf</code> files, you can pass them via CLI:</li>
<pre><code class="language-bash line-numbers">terraform init \
  -backend-config="bucket=my-tf-state" \
  -backend-config="region=eu-central-1"</code></pre>
        <br/>
        <li>Each <code>-backend-config</code> argument sets/overrides a backend argument.</li>
        <br/>
        <br/>

        <li>3. <code>-reconfigure</code> &mdash; Force backend reconfiguration</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -reconfigure</code></pre>
        <br/>
        <li>Use when:</li>
        <ul>
            <li>you changed backend type or remote config</li>
            <li>you want Terraform to forget previous backend settings and ask again</li>
        </ul>
        <br/>
        <br/>

        <li>4. <code>-migrate-state</code> &mdash; Move state between backends</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -migrate-state</code></pre>
        <br/>
        <li>Use when you:</li>
        <ul>
            <li>switch from local → remote backend (e.g., local → S3)</li>
            <li>move between two different remote backends</li>
        </ul>
        <br/>
        <li>Terraform will ask for confirmation before physically moving the state file.</li>
        <br/>
        <br/>

        <li>5. <code>-from-module</code> &mdash; Initialize a new project from a module</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -from-module=git::https://github.com/example/infra-module.git</code></pre>
        <br/>
        <li>What it does:</li>
        <ul>
            <li>Clones/copies the specified module into the current directory</li>
            <li>Then initializes providers and submodules as usual</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Idempotency: Re-running <code>terraform init</code></li>
    <br/>
    <ul>
        <li>It is <b>safe</b> to run <code>terraform init</code> multiple times.</li>
        <br/>
        <li>On repeated runs, Terraform will:</li>
        <ul>
            <li>Reuse already-downloaded providers (unless <code>-upgrade</code> is set)</li>
            <li>Reuse modules (again, unless <code>-upgrade</code>)</li>
            <li>Verify backend configuration</li>
        </ul>
        <br/>
        <li>You should re-run <code>init</code> when:</li>
        <ul>
            <li>cloning a repo for the first time</li>
            <li>changing provider versions</li>
            <li>changing backend configs</li>
            <li>adding/removing modules</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Putting It All Together: Example Session</li>
    <br/>
    <ul>
        <li>Imagine you have this setup in <code>main.tf</code>:</li>
<pre><code class="language-hcl line-numbers">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 5.0"
    }
  }
  backend "s3" {
    bucket = "my-tf-state-bucket"
    key    = "dev/terraform.tfstate"
    region = "eu-central-1"
  }
}</code></pre>
        <br/>
        <li>Typical usage:</li>
<pre><code class="language-bash line-numbers"># 1. Initialize project, providers, modules, backend
terraform init

# 2. (Later) change versions or modules, then upgrade
terraform init -upgrade

# 3. (Later) migrate from local backend to S3
terraform init -migrate-state -reconfigure</code></pre>
        <br/>
        <li>This sequence is extremely common in real-world Terraform projects.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-block-reference">Understanding the <code>terraform</code> Block in Terraform</h3>
<ol>

    <li>What Is the <code>terraform</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>terraform</code> block is a special <b>top-level</b> configuration block in Terraform that controls:
            <ul>
                <li>required provider versions</li>
                <li>required Terraform CLI version</li>
                <li>backend configuration (state storage)</li>
                <li>module behavior</li>
                <li>dependency lockfile rules</li>
            </ul>
        </li>
        <br/>
        <li>It does <u>not</u> provision infrastructure itself. It only configures Terraform’s behavior.</li>
        <br/>
        <li>This block is normally placed at the top of <code>main.tf</code>.</li>
    </ul>
    <br/><br/>


    <li>The General Structure of the <code>terraform</code> Block</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_version = "~&gt; 1.5.0"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }

    backend "s3" {
        bucket = "my-terraform-state"
        key    = "prod/terraform.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

        <br/>
        <li>This block lets Terraform know:
            <ul>
                <li>What version of Terraform is allowed</li>
                <li>Which providers are required</li>
                <li>Where to store the state</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><code>required_version</code> — Terraform CLI Version Constraint</li>
    <br/>
    <ul>
        <li>Ensures compatibility across team members and CI pipelines.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_version = "&gt;= 1.4.0, < 1.6.0"
}
</code></pre>

        <li>What it means:</li>
        <ul>
            <li>Terraform must be at least version <code>1.4.0</code></li>
            <li>Terraform must be &lt; <code>1.6.0</code></li>
        </ul>
        <br/>
        <li>If you run an incompatible version, Terraform will refuse to continue.</li>
    </ul>
    <br/><br/>


    <li><code>required_providers</code> — Provider Requirements</li>
    <ul>
        <br/>
        <li>This section tells Terraform which providers your configuration needs.</li>
        <br/>
        <li>This also defines:
            <ul>
                <li>provider source (where to download it from)</li>
                <li>provider version constraints</li>
            </ul>
        </li>
        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
        random = {
            source  = "hashicorp/random"
            version = "&gt;= 3.5.0"
        }
    }
}
</code></pre>

        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>aws</code> provider must be downloaded from the Hashicorp registry.</li>
            <li>Version must match <code>~&gt; 5.0</code> means <code>&gt;= 5.0.0, &lt; 6.0.0</code>
            </li>
            <li><code>random</code> provider must be at least <code>3.5.0</code></li>
        </ul>
        <br/>
        <li>These rules will be saved in <code>.terraform.lock.hcl</code> after <code>terraform init</code>.</li>
    </ul>
    <br/><br/>


    <li><code>backend</code> — Terraform State Storage</li>
    <br/>
    <ul>
        <li>Terraform stores its state (<code>terraform.tfstate</code>) externally using backends.</li>
        <br/>
        <li>Backends DO NOT support interpolation. Everything must be hard-coded or supplied via <code>-backend-config</code>.</li>
        <br/>

        <li>Example (S3 backend):</li>
<pre><code class="language-hcl line-numbers">terraform {
    backend "s3" {
        bucket = "my-tf-state"
        key    = "dev/state.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

        <li>What it does:</li>
        <ul>
            <li>Stores state in S3 bucket</li>
            <li>Key identifies the file path inside the bucket</li>
            <li>Supports locking when combined with DynamoDB</li>
        </ul>
        <br/>

        <li>You can override backend values:</li>
<pre><code class="language-bash line-numbers">terraform init                                  \
    -backend-config="bucket=my-other-bucket"    \
    -backend-config="key=new-key.tfstate"
</code></pre>
    </ul>
    <br/><br/>


    <li>Less Common but Useful Settings</li>
    <br/>
    <ol>
        <li><code>provider_meta</code> (rare)</li>
<pre><code class="language-hcl line-numbers">terraform {
    provider_meta "aws" {
        module_name = "custom-aws-module"
    }
}
</code></pre>

        <br/>

        <li><code>experiments</code> (very rare)</li>
<pre><code class="language-hcl line-numbers">terraform {
    experiments = [module_variable_optional_attrs]
}
</code></pre>

        <br/>

        <li><code>cloud</code> block (Terraform Cloud/Enterprise)</li>
<pre><code class="language-hcl line-numbers">terraform {
    cloud {
        organization = "mycompany"

        workspaces {
            name = "production"
        }
    }
}
</code></pre>
        <ul>
            <li>This integrates Terraform Cloud as the state backend + runs.</li>
        </ul>
        <br/>
    </ol>
    <br/><br/>


    <li>Putting It All Together — Complete Example</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_version = "~&gt; 1.5"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
        kubernetes = {
            source  = "hashicorp/kubernetes"
            version = "~&gt; 2.20"
        }
    }

    backend "s3" {
        bucket = "my-terraform-state-bucket"
        key    = "envs/prod/state.tfstate"
        region = "eu-central-1"
        encrypt = true
    }
}
</code></pre>

    <ul>
        <li>This prepares Terraform to:</li>
        <ul>
            <li>Use Terraform CLI 1.5.x</li>
            <li>Download AWS and Kubernetes providers</li>
            <li>Store state remotely in S3</li>
            <li>Use encryption for the state file</li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-provider-block">Understanding the <code>provider</code> Block in Terraform</h3>
<ol>

    <li>What Is the <code>provider</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>provider</code> block configures a specific cloud/vendor provider used by Terraform.</li>
        <br/>
        <li>A provider is responsible for:</li>
        <ul>
            <li>connecting Terraform to an external system (AWS, Azure, GCP, Kubernetes, etc.)</li>
            <li>authenticating</li>
            <li>defining regions/endpoints</li>
            <li>making API requests</li>
            <li>creating/updating/deleting resources</li>
        </ul>
        <br/>
        <li>Every resource (like <code>aws_instance</code>, <code>google_compute_network</code>, <code>kubernetes_deployment</code>) requires a provider.</li>
        <br/>
        <li>The provider block tells Terraform <b>how to configure</b> that provider (not which version—that belongs in the <code>terraform</code> block).</li>
    </ul>
    <br/><br/>


    <li>The Structure of a <code>provider</code> Block</li>
    <br/>
    <ul>
        <li>General form:</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region     = "eu-central-1"
    access_key = "AKIA..."
    secret_key = "SECRET..."
}
</code></pre>

        <li>Important points:</li>
        <ul>
            <li><code>provider "aws"</code> → refers to the AWS provider</li>
            <li>arguments inside → configure authentication, regions, settings</li>
            <li>DO NOT include provider version here</li>
        </ul>

        <br/>
        <li>Basic guideline:
            <ul>
                <li><code>terraform.required_providers</code> → WHICH provider + version</li>
                <li><code>provider</code> → HOW the provider connects to the cloud</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Example: AWS Provider Configuration</li>
    <br/>
    <ul>
        <li>A realistic AWS provider block:</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"

    default_tags {
        tags = {
            project = "terraform-demo"
            owner   = "junzhe"
        }
    }
}
</code></pre>

        <li>Explanation:</li>
        <ul>
            <li><code>region</code> is where Terraform creates AWS resources</li>
            <li><code>default_tags</code> are automatically attached tags to every AWS resource</li>
        </ul>

        <br/>
        <li>Authentication is normally handled externally:
            <ul>
                <li>environment variables</li>
                <li>AWS CLI profile</li>
                <li>EC2 instance role</li>
            </ul>
        </li>

        <br/>
        <li>AWS provider supports many options such as:</li>
        <ul>
            <li><code>profile</code> (use AWS CLI profile)</li>
            <li><code>assume_role</code> blocks</li>
            <li><code>endpoints</code> (custom AWS endpoints)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Example: Google Cloud Provider</li>
<pre><code class="language-hcl line-numbers">provider "google" {
    project = "my-gcp-project"
    region  = "us-central1"
    zone    = "us-central1-a"
}
</code></pre>

    <ul>
        <li>Explanation:</li>
        <ul>
            <li><code>project</code> is your GCP project ID</li>
            <li><code>region</code> are regional GCP resources</li>
            <li><code>zone</code> are zonal resources</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Multiple Provider Configurations</li>
    <br/>
    <ul>
        <li>You can configure multiple provider blocks for:</li>
        <ul>
            <li>multi-region deployments</li>
            <li>multi-account deployments</li>
            <li>multiple Kubernetes clusters</li>
        </ul>
        <br/>

        <li>Example: Two AWS regions</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    alias  = "eu"
    region = "eu-central-1"
}

provider "aws" {
    alias  = "us"
    region = "us-east-1"
}
</code></pre>

        <br/>
        <li>Use them in resources:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "bucket_eu" {
    provider = aws.eu
    bucket   = "bucket-europe"
}

resource "aws_s3_bucket" "bucket_us" {
    provider = aws.us
    bucket   = "bucket-america"
}
</code></pre>

        <br/>
        <li>Aliases allow multiple configurations for the same provider.</li>
    </ul>
    <br/><br/>


    <li>Provider Inheritance Rule</li>
    <br/>
    <ul>
        <li>Resources automatically use the default (non-aliased) provider.</li>
        <br/>
        <li>Only use <code>provider = aws.aliasname</code> when:</li>
        <ul>
            <li>you have multiple provider configs</li>
            <li>a resource belongs to a non-default provider</li>
        </ul>
        <br/>
        <li>Modules inherit provider configs from the root module unless overridden.</li>
    </ul>
    <br/><br/>


    <li><code>provider</code> Blocks vs. <code>required_providers</code></li>
    <br/>
    <ul>
        <li><b>required_providers</b> (inside <code>terraform</code> block):</li>
        <ul>
            <li>States which providers you want</li>
            <li>Specifies versions</li>
            <li>Dictates where to download the provider from</li>
        </ul>

        <br/>

        <li><b>provider</b> block:</li>
        <ul>
            <li>Configures the provider connection</li>
            <li>Sets up authentication</li>
            <li>Specifies region/endpoints</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Passing Variables into Provider Configurations</li>
    <br/>
    <ul>
        <li>You can parameterize provider configuration:</li>
<pre><code class="language-hcl line-numbers">variable "aws_region" {
    default = "eu-central-1"
}

provider "aws" {
    region = var.aws_region
}
</code></pre>

        <li>Don’t hardcode credentials in provider blocks.</li>
    </ul>
    <br/><br/>


    <li>Debugging Provider Issues</li>
    <br/>
    <ul>
        <li>Common mistakes include:</li>
        <ul>
            <li>Missing authentication environment variables</li>
            <li>Using wrong regions</li>
            <li>Incorrect aliases</li>
            <li>Mismatched provider versions (but Terraform catches this)</li>
        </ul>

        <br/>
        <li>Useful debug command:</li>
<pre><code class="language-bash line-numbers">TF_LOG=DEBUG terraform apply</code></pre>
        <li>This prints all API calls and provider loading behavior.</li>
    </ul>
    <br/><br/>


    <li>Complete Example</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"

    default_tags {
        tags = {
            env = "production"
        }
    }
}

resource "aws_s3_bucket" "example" {
    bucket = "my-s3-bucket-demo-12345"
}
</code></pre>
    <ul>
        <li>Terraform downloads AWS provider version 5.x</li>
        <li>Provider connects to AWS Frankfurt region</li>
        <li>An S3 bucket is created using that provider configuration</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-resource-block">Understanding the <code>resource</code> Block in Terraform</h3>
<ol>

    <li>What Is a <code>resource</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>resource</code> block is the core building block of Terraform.</li>
        <br/>
        <li>It describes:
            <ul>
                <li>WHAT infrastructure should be created</li>
                <li>HOW it should look</li>
                <li>WHICH provider should manage it</li>
                <li>WHAT arguments customize the resource</li>
            </ul>
        </li>
        <br/>
        <li>Example resources include:
            <ul>
                <li><code>aws_instance</code> → EC2 VM</li>
                <li><code>google_compute_network</code> → GCP VPC</li>
                <li><code>kubernetes_deployment</code> → K8S Deployment</li>
                <li><code>azurerm_storage_account</code> → Azure storage</li>
            </ul>
        </li>
        <br/>
        <li>Terraform reads the <code>resource</code> blocks, calculates the desired state, and makes provider API calls to achieve it.</li>
    </ul>
    <br/><br/>


    <li>The Structure of a <code>resource</code> Block</li>
    <br/>
    <ul>
        <li>Basic syntax:</li>
<pre><code class="language-hcl line-numbers">resource "PROVIDER_RESOURCE_TYPE" "LOCAL_NAME" {
    # arguments (config)
}
</code></pre>

        <li>Breakdown:</li>
        <ul>
            <li><code>PROVIDER_RESOURCE_TYPE</code> → e.g. <code>aws_s3_bucket</code></li>
            <li><code>LOCAL_NAME</code> → your own identifier (internal to Terraform)</li>
            <li>arguments inside block → specify configuration</li>
        </ul>

        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "my_bucket" {
    bucket = "junzhe-terraform-demo"
    acl    = "private"
}
</code></pre>

        <li>Here:
            <ul>
                <li><code>aws_s3_bucket</code> is the resource type</li>
                <li><code>my_bucket</code> is the name used within Terraform</li>
                <li>It creates a real AWS S3 bucket</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Understanding Resource Types</li>
    <br/>
    <ul>
        <li>Resource types follow this naming pattern:</li>
<pre><code class="language-plaintext line-numbers">&lt;PROVIDER_NAME&gt;_&lt;RESOURCE_TYPE&gt;
</code></pre>

        <li>Examples:</li>
        <ul>
            <li><code>aws_instance</code></li>
            <li><code>aws_security_group</code></li>
            <li><code>google_storage_bucket</code></li>
            <li><code>kubernetes_service</code></li>
        </ul>

        <br/>
        <li>The provider determines which resource types exist.
            Check your provider documentation for the full list.</li>
    </ul>
    <br/><br/>


    <li>Example 1: AWS EC2 Instance</li>
<pre><code class="language-hcl line-numbers">resource "aws_instance" "web" {
    ami           = "ami-0ff8a91507f77f867"
    instance_type = "t3.micro"

    tags = {
        Name = "WebServer"
    }
}
</code></pre>
    <ul>
        <li>Arguments:</li>
        <ul>
            <li><code>ami</code> → machine image</li>
            <li><code>instance_type</code> → VM size</li>
            <li><code>tags</code> → metadata</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Resource Arguments vs. Attributes</li>
    <br/>
    <ul>
        <li><b>Arguments</b> are input from your configuration</li>
        <br/>
        <li><b>Attributes</b> are output from the infrastructure provider</li>
        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "example" {
    bucket = "my-bucket"
}

output "bucket_arn" {
    value = aws_s3_bucket.example.arn
}
</code></pre>

        <ul>
            <li><code>bucket</code> → argument</li>
            <li><code>arn</code> → computed attribute</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Lifecycles for Resources (<code>lifecycle</code> Block)</li>
    <br/>
    <ul>
        <li>You can customize how Terraform manages updates:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "demo" {
    bucket = "demo-bucket"

    lifecycle {
        prevent_destroy = true
        ignore_changes  = [tags]
        create_before_destroy = true
    }
}
</code></pre>
        <li>Key lifecycle options:</li>
        <ul>
            <li><code>prevent_destroy</code> protects critical resources</li>
            <li><code>ignore_changes</code> makes Terraform ignore drift on selected attributes</li>
            <li><code>create_before_destroy</code> avoids downtime during resource replacement</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Meta-Arguments in Resource Blocks</li>
    <br/>
    <ul>
        <li>1. <code>count</code></li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "buckets" {
    count  = 3
    bucket = "bucket-${count.index}"
}
</code></pre>

        <li>2. <code>for_each</code></li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "buckets" {
    for_each = toset(["a", "b", "c"])
    bucket   = "bucket-${each.key}"
}
</code></pre>

        <li>3. <code>depends_on</code> — force explicit ordering</li>
<pre><code class="language-hcl line-numbers">resource "aws_iam_role" "role" {
    # ...
}

resource "aws_instance" "server" {
    depends_on = [aws_iam_role.role]
    # ...
}
</code></pre>

        <li>4. <code>provider</code> — choose a provider configuration</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    alias  = "us"
    region = "us-east-1"
}

resource "aws_s3_bucket" "us_bucket" {
    provider = aws.us
    bucket   = "bucket-us"
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Resource Dependencies</li>
    <br/>
    <ul>
        <li>Terraform automatically infers ordering via variables and references:</li>
<pre><code class="language-hcl line-numbers">resource "aws_vpc" "main" {
    cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "subnet" {
    vpc_id = aws_vpc.main.id   # implicit dependency
}
</code></pre>
        <li>If implicit dependencies fail, use <code>depends_on</code>.</li>
    </ul>
    <br/><br/>


    <li>Importing Existing Resources</li>
    <br/>
    <ul>
        <li>You can import existing real cloud resources into Terraform state:</li>
<pre><code class="language-bash line-numbers">terraform import aws_s3_bucket.my_bucket my-real-bucket</code></pre>
        <li>After import:
            <ul>
                <li>The resource exists in state</li>
                <li>You must write the matching <code>resource</code> block manually</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Destroying Resources</li>
    <br/>
    <ul>
        <li>Delete a resource from config → <code>terraform apply</code> will destroy it.</li>
        <br/>
        <li>Or destroy explicitly:</li>
<pre><code class="language-bash line-numbers">terraform destroy -target=aws_s3_bucket.my_bucket</code></pre>
    </ul>
    <br/><br/>


    <li>Complete Example Project</li>
    <ul>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"
}

resource "aws_vpc" "main" {
    cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "subnet" {
    vpc_id            = aws_vpc.main.id
    cidr_block        = "10.0.1.0/24"
    availability_zone = "eu-central-1a"
}

resource "aws_instance" "web" {
    ami           = "ami-0ff8a91507f77f867"
    instance_type = "t3.micro"
    subnet_id     = aws_subnet.subnet.id
}
</code></pre>

        <li>Terraform will automatically create:
            <ul>
                <li>VPC</li>
                <li>Subnet inside that VPC</li>
                <li>EC2 inside that subnet</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
