<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Terraform</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/terraform.jpeg" alt="Terraform Logo"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#tf-what-is-terraform">What Is Terraform?</a></li>
        <li><a href="#terraform-lifecycle">Life Cycle</a></li>
        <li><a href="#terraform-cli">CLI</a></li>
        <li><a href="#terraform-write-config">Writing Terraform Configuration</a></li>
        <li><a href="#terraform-aws-intro">Introduction Using Terraform with AWS</a></li>
        <li><a href="#terraform-init-command">Understanding the <code>terraform init</code> Command</a></li>
        <li><a href="#terraform-block-reference">Understanding the <code>terraform</code> Block</a></li>
        <li><a href="#terraform-provider-block">Understanding the <code>provider</code> Block</a></li>
        <li><a href="#terraform-resource-block">Understanding the <code>resource</code> Block</a></li>
        <li><a href="#terraform-variable-block">Understanding the <code>variable</code> Block</a></li>
        <li><a href="#terraform-output-block">Understanding the <code>output</code> Block</a></li>
        <li><a href="#terraform-locals-block">Understanding the <code>locals</code> Block</a></li>
        <li><a href="#terraform-import-block">Understanding the <code>import</code> Block</a></li>
        <li><a href="#terraform-module-block">Understanding the <code>module</code> Block</a></li>
    </ol>
</nav>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="tf-what-is-terraform">What Is Terraform?</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>Terraform</code> is an open-source <u>Infrastructure as Code (IaC)</u> tool created by HashiCorp.</li>
        <br/>
        <li>It allows you to <u>define, provision, and manage infrastructure</u>
            across multiple cloud providers using a declarative configuration language (HCL — HashiCorp Configuration Language).</li>
        <br/>
        <li>Instead of clicking in cloud dashboards, you write code describing your infrastructure — Terraform takes care of creating, updating, and deleting resources safely.</li>
    </ul>
    <br/><br/>


    <li><b>Key Characteristics</b></li>
    <br/>
    <ul>
        <li>You describe <u>what</u> you want, not <u>how</u> to do it.</li>
        <li>Supports many providers:
            <ul>
                <li>AWS, Azure, Google Cloud</li>
                <li>Alibaba Cloud, Oracle Cloud</li>
                <li>Kubernetes</li>
                <li>GitHub, Cloudflare, Datadog, etc.</li>
            </ul>
        </li>
        <li>Safe <u>execution plan</u> via <code>terraform plan</code>.</li>
        <li>Manages <u>dependencies</u> between resources automatically.</li>
        <li>Uses a <u>state file</u> to track real-world infrastructure.</li>
        <li>Works well in CI/CD pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Workflow</b></li>
    <br/>
    <ul>
        <li>Terraform follows a simple but powerful 4-step workflow:</li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Step</th>
                <th>Description</th>
                <th>Command</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>1. Write</b></td>
                <td>Write <code>.tf</code> files describing infrastructure.</td>
                <td>—</td>
            </tr>
            <tr>
                <td><b>2. Init</b></td>
                <td>Download providers and initialize the project.</td>
                <td><code>terraform init</code></td>
            </tr>
            <tr>
                <td><b>3. Plan</b></td>
                <td>Show what Terraform will create, modify, or destroy.</td>
                <td><code>terraform plan</code></td>
            </tr>
            <tr>
                <td><b>4. Apply</td>
                <td>Perform the actual infrastructure change.</td>
                <td><code>terraform apply</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>A Simple Terraform Example</b></li>
    <br/>
    <p>This example creates an AWS EC2 instance.</p>

<pre><code class="language-hcl line-numbers">provider "aws" {
  region = "eu-central-1"
}

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
</code></pre>

    <br/>
    <ul>
        <li><code>provider</code> block tells Terraform which cloud provider to use.</li>
        <li><code>resource</code> block describes an actual cloud object.</li>
        <li><code>aws_instance.example</code> becomes a managed resource in the Terraform state.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform State</b></li>
    <br/>
    <ul>
        <li>Terraform stores infrastructure details in a file called <code>terraform.tfstate</code>.</li>
        <br/>
        <li>This file tracks:
            <ul>
                <li>resource IDs</li>
                <li>connections between resources</li>
                <li>current configuration applied</li>
            </ul>
        </li>
        <br/>
        <li>This allows Terraform to detect changes and update resources safely.</li>
        <br/>
        <li>In teams, the state is usually stored remotely (S3, Azure Blob, Terraform Cloud).</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Language (HCL)</b></li>
    <br/>
    <ul>
        <li>Terraform uses <u>HCL (HashiCorp Configuration Language)</u>, which is:</li>
        <ul>
            <li>easy to read</li>
            <li>block-based</li>
            <li>supports variables, loops, functions, expressions</li>
        </ul>
        <br/>
        <li>Examples of HCL blocks:</li>
    </ul>

<pre><code class="language-hcl line-numbers">variable "project_name" {
  type = string
}

output "instance_id" {
  value = aws_instance.example.id
}
</code></pre>
    <br/><br/>


    <li><b>Common Terraform Terminology</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Term</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>provider</code></td>
                <td>Plugin to manage a service (e.g., AWS, Azure).</td>
            </tr>
            <tr>
                <td><code>resource</code></td>
                <td>A cloud object (VM, network, DB, etc.).</td>
            </tr>
            <tr>
                <td><code>data source</code></td>
                <td>Read existing infrastructure.</td>
            </tr>
            <tr>
                <td><code>module</code></td>
                <td>Reusable grouping of Terraform files.</td>
            </tr>
            <tr>
                <td><code>state</code></td>
                <td>The file storing real-world infrastructure details.</td>
            </tr>
            <tr>
                <td><code>plan</code></td>
                <td>Preview of actions before applying changes.</td>
            </tr>
            <tr>
                <td><code>apply</code></td>
                <td>Run the actual changes.</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-lifecycle">Terraform Resource Lifecycle</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Every Terraform <code>resource</code> has a <u>lifecycle</u> — a set of rules controlling how Terraform creates, updates, and destroys it.</li>
        <br/>
        <li>You can use the <code>lifecycle</code> block inside a resource to modify Terraform's default behavior.</li>
    </ul>
    <br/><br/>


    <li><b>The <code>lifecycle</code> Block Structure</b></li>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"

  lifecycle {
    create_before_destroy = false
    prevent_destroy       = false
    ignore_changes        = []
  }
}
</code></pre>

    <br/>
    <ul>
        <li>The <code>lifecycle</code> block works inside <code>resource</code> definitions only.</li>
        <li>It modifies how Terraform handles changes, updates, and destruction.</li>
    </ul>
    <br/><br/>


    <li><code>create_before_destroy</code></li>
    <br/>
    <ul>
        <li>Normally Terraform does:
            <ul>
                <li>destroy the old resource</li>
                <li>then create a new one</li>
            </ul>
        </li>
        <br/>
        <li><code>create_before_destroy = true</code> reverses this order:
            <ul>
                <li>create new resource <u>first</u></li>
                <li>destroy the old one <u>after</u></li>
            </ul>
        </li>
        <br/>
        <li>Useful when:
            <ul>
                <li>you want zero downtime</li>
                <li>your resource cannot be deleted before a replacement exists</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  create_before_destroy = true
}
</code></pre>

    <br/><br/>


    <li><code>prevent_destroy</code></li>
    <br/>
    <ul>
        <li>Protects a resource from <u>accidental deletion</u>.</li>
        <li>If Terraform needs to destroy it, the <code>apply</code> will abort with an error.</li>
        <br/>
        <li>Commonly used for:
            <ul>
                <li>production databases</li>
                <li>S3 buckets containing critical data</li>
                <li>shared networks</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  prevent_destroy = true
}
</code></pre>

    <br/>
    <ul>
        <li>To override, you must temporarily remove <code>prevent_destroy</code> or force destruction with <code>-target</code> flags.</li>
    </ul>
    <br/><br/>


    <li><code>ignore_changes</code></li>
    <br/>
    <ul>
        <li>Tells Terraform to <u>ignore drift</u> on certain fields.</li>
        <li>Useful when some fields are updated by:
            <ul>
                <li>cloud providers</li>
                <li>external scripts</li>
                <li>manually modified settings</li>
            </ul>
        </li>
        <br/>
        <li>Prevents Terraform from trying to "fix" changes you don’t want overwritten.</li>
    </ul>

<pre><code class="language-hcl line-numbers">lifecycle {
  ignore_changes = [
    tags,
    metadata,
  ]
}
</code></pre>

    <br/>
    <ul>
        <li>Supports:
            <ul>
                <li>single attribute</li>
                <li>multiple attributes</li>
                <li><code>ignore_changes = all</code> (dangerous!)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Full Lifecycle Example</b></li>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "server" {
  ami           = "ami-123456"
  instance_type = "t3.micro"

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = false
    ignore_changes        = [
      tags["last_updated"],
      user_data,
    ]
  }
}
</code></pre>

    <br/>
    <ul>
        <li>This resource:
            <ul>
                <li>gets replaced without downtime</li>
                <li>can be destroyed normally</li>
                <li>does not react to changes in <code>user_data</code> or <code>tags.last_updated</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Lifecycle vs Depends On</b></li>
    <br/>
    <ul>
        <li>Lifecycle provides <u>behavior customization</u>.</li>
        <li><code>depends_on</code> enforces <u>ordering</u> between resources.</li>
        <br/>
        <li>They work together but serve different purposes.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_eip" "ip" {
  depends_on = [aws_instance.server]
}
</code></pre>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Setting</th>
                <th>Description</th>
                <th>Common Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>create_before_destroy</code></td>
                <td>Create replacement before destroying old resource</td>
                <td>Zero downtime deployments</td>
            </tr>
            <tr>
                <td><code>prevent_destroy</code></td>
                <td>Protect resource from deletion</td>
                <td>Critical databases, S3 buckets</td>
            </tr>
            <tr>
                <td><code>ignore_changes</code></td>
                <td>Ignore drift on specific attributes</td>
                <td>Provider-controlled fields, timestamps</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-cli">Terraform CLI (Command Line Interface)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The Terraform CLI is the primary way developers interact with Terraform.</li>
        <br/>
        <li>All Terraform workflows rely on the CLI, especially when working locally or inside CI/CD pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Command Structure</b></li>
    <br/>

<pre><code class="language-bash line-numbers">$ terraform &lt;command&gt; [options]
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform apply -auto-approve
</code></pre>

    <br/><br/>


    <li><b>Essential Terraform CLI Commands</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
                <th>Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>terraform init</code></td>
                <td>Initializes a working directory</td>
                <td>Download providers and set up backend</td>
            </tr>
            <tr>
                <td><code>terraform plan</code></td>
                <td>Show proposed changes</td>
                <td>Preview before apply</td>
            </tr>
            <tr>
                <td><code>terraform apply</code></td>
                <td>Apply the plan (create/update/destroy)</td>
                <td>Deploy infrastructure</td>
            </tr>
            <tr>
                <td><code>terraform destroy</code></td>
                <td>Destroy managed resources</td>
                <td>Cleanup infrastructure</td>
            </tr>
            <tr>
                <td><code>terraform validate</code></td>
                <td>Check module syntax</td>
                <td>Catches errors before running plan</td>
            </tr>
            <tr>
                <td><code>terraform fmt</code></td>
                <td>Format <code>.tf</code> files</td>
                <td>Enforce consistent style</td>
            </tr>
            <tr>
                <td><code>terraform providers</code></td>
                <td>Show used providers</td>
                <td>Dependency inspection</td>
            </tr>
            <tr>
                <td><code>terraform version</code></td>
                <td>Show Terraform version</td>
                <td>Debug/build info</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><code>terraform init</code></li>
    <br/>
    <ul>
        <li>Must be run once per project (or when providers/backends change).</li>
        <li>Downloads provider plugins.</li>
        <li>Initializes backend for state storage.</li>
        <li>Sets up module dependencies.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform init
Initializing the backend...
Initializing provider plugins...
Terraform has been successfully initialized!
</code></pre>
    <br/><br/>


    <li><code>terraform plan</code></li>
    <br/>
    <ul>
        <li>Shows what Terraform <u>would</u> do.</li>
        <li>No resources are changed.</li>
        <li>Output includes:
            <ul>
                <li>additions</li>
                <li>changes</li>
                <li>destructions</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform plan
Plan: 1 to add, 0 to change, 0 to destroy.
</code></pre>
    <br/><br/>


    <li><code>terraform apply</code></li>
    <br/>
    <ul>
        <li>Executes the plan and modifies infrastructure.</li>
        <li>Default behavior requires user confirmation.</li>
        <li>Use <code>-auto-approve</code> in automation.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform apply
Do you want to perform these actions?
  Enter a value: yes
</code></pre>
    <br/><br/>


    <li><code>terraform destroy</code></li>
    <br/>
    <ul>
        <li>Destroys all resources managed by Terraform.</li>
        <li>Useful for cleaning up dev environments.</li>
        <li>Confirmation required unless <code>-auto-approve</code> is used.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform destroy -auto-approve
</code></pre>
    <br/><br/>


    <li><code>terraform validate</code></li>
    <br/>
    <ul>
        <li>Checks configuration syntax.</li>
        <li>Verifies that the files are internally consistent.</li>
        <li>Does not check cloud provider availability.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform validate
Success! The configuration is valid.
</code></pre>
    <br/><br/>


    <li><code>terraform fmt</code></li>
    <br/>
    <ul>
        <li>Formats all Terraform files (<code>.tf</code> / <code>.tfvars</code>) to standard style.</li>
        <li>Keeps code clean in team environments.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform fmt
</code></pre>
    <br/><br/>


    <li><code>terraform show</code></li>
    <br/>
    <ul>
        <li>Displays the current state or a saved plan.</li>
        <li>Useful for debugging and documentation.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform show

# aws_instance.example:
resource "aws_instance" "example" {
    ami           = "ami-123456"
    instance_type = "t2.micro"
}
</code></pre>
    <br/><br/>


    <li><code>terraform graph</code></li>
    <br/>
    <ul>
        <li>Outputs a dependency graph in DOT format (Graphviz).</li>
        <li>Useful for visualizing relationships between resources.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform graph | dot -Tpng &gt; graph.png
</code></pre>
    <br/><br/>


    <li><code>terraform state</code> Commands</b></li>
    <br/>
    <ul>
        <li>The <code>terraform state</code> family manages state files.</li>
    </ul>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>state list</code></td>
                <td>List resources in state</td>
            </tr>
            <tr>
                <td><code>state show</code></td>
                <td>Show details for a resource</td>
            </tr>
            <tr>
                <td><code>state pull</code></td>
                <td>Download remote state</td>
            </tr>
            <tr>
                <td><code>state push</code></td>
                <td>Upload state manually</td>
            </tr>
            <tr>
                <td><code>state rm</code></td>
                <td>Remove resource from state</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><code>terraform import</code></li>
    <br/>
    <ul>
        <li>Add existing real-world resources to Terraform state.</li>
        <li>Useful when migrating to Terraform-managed infrastructure.</li>
    </ul>

<pre><code class="language-bash line-numbers">$ terraform import aws_instance.example i-1234567890abcdef0
</code></pre>
    <br/><br/>


    <li><b>Useful CLI Options</b></li>
    <br/>

<pre><code class="language-bash line-numbers">-auto-approve        # Skip yes/no prompt
-refresh=false       # Skip refreshing state
-target=&lt;address&gt;    # Apply a specific resource
-var name=value      # Pass variable
-var-file=file.tfvars
</code></pre>

    <br/><br/>


    <li><b>Summary of Terraform CLI</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Main Commands</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Setup</td>
                <td><code>init</code>, <code>fmt</code>, <code>validate</code></td>
            </tr>
            <tr>
                <td>Execution</td>
                <td><code>plan</code>, <code>apply</code>, <code>destroy</code></td>
            </tr>
            <tr>
                <td>State Management</td>
                <td><code>state</code>, <code>show</code>, <code>list</code>, <code>pull</code>, <code>push</code></td>
            </tr>
            <tr>
                <td>Migration</td>
                <td><code>import</code></td>
            </tr>
            <tr>
                <td>Debugging</td>
                <td><code>graph</code>, <code>providers</code>, <code>version</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-write-config">Writing Terraform Configuration</h3>
<ol>

    <li><b>What Does Terraform Configuration Mean?</b></li>
    <br/>
    <ul>
        <li>A Terraform <b>configuration</b> is a collection of <code>.tf</code> files that describe your desired infrastructure.</li>
        <br/>
        <li>Terraform uses a <b>declarative syntax</b> called HCL (HashiCorp Configuration Language).</li>
        <br/>
        <li>Configurations describe:
            <ul>
                <li>providers (AWS, Azure, GCP, Kubernetes, …),</li>
                <li>resources (servers, networks, buckets, etc.),</li>
                <li>variables and outputs,</li>
                <li>modules,</li>
                <li>data sources,</li>
                <li>state backend settings.</li>
            </ul>
        </li>
        <br/>
        <li>Terraform reads your <code>.tf</code> files, builds a desired-state graph, and then applies it to real cloud infrastructure.</li>
    </ul>
    <br/><br/>


    <li><b>Terraform Files and Directory Structure</b></li>
    <br/>
    <ul>
        <li>A typical Terraform directory might look like:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">.
├── main.tf
├── variables.tf
├── outputs.tf
└── terraform.tfvars
</code></pre>

    <ul>
        <li>Terraform automatically loads <b>every</b> <code>*.tf</code> files in the working directory.</li>
        <li>You don’t need to import them manually, Terraform merges them internally.</li>
    </ul>
    <br/><br/>


    <li><b>The</b> <code>terraform</code> <b>Block</b></li>
    <br/>
    <ul>
        <li>This block configures Terraform itself, especially:
            <ul>
                <li>required providers,</li>
                <li>backend (where state is stored),</li>
                <li>required terraform version.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_version = "&gt;= 1.5"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }

    backend "s3" {
        bucket = "my-tf-state"
        key    = "prod/terraform.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

    <ul>
        <li>The <code>backend</code> configuration (S3 example) is optional unless you're working in teams.</li>
    </ul>
    <br/><br/>


    <li><b>Provider Configuration</b></li>
    <br/>
    <ul>
        <li>A provider tells Terraform which cloud platform or service to interact with.</li>
        <li>Example for AWS:</li>
    </ul>

<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"
}
</code></pre>

    <ul>
        <li>Credentials can be set via:
            <ul>
                <li>environment variables (<code>AWS_ACCESS_KEY_ID</code>)</li>
                <li>AWS CLI config</li>
                <li>shared credentials files</li>
                <li>instance roles</li>
            </ul>
        </li>
        <li><b>Do not hardcode secrets</b> inside <code>.tf</code> files.</li>
    </ul>
    <br/><br/>


    <li><b>Resources: The Core of Terraform</b></li>
    <br/>
    <ul>
        <li>A <b>resource</b> is an infrastructure object Terraform manages.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "my_server" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = "t2.micro"

    tags = {
        Name = "DemoServer"
    }
}
</code></pre>

    <ul>
        <li>The identifier <code>aws_instance.my_server</code> becomes a referenceable object inside your configuration.</li>
        <br/>
        <li>You can reference attributes using interpolation:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_eip" "my_ip" {
    instance = aws_instance.my_server.id
}
</code></pre>

    <ul>
        <li>Terraform automatically builds dependency graphs based on references.</li>
    </ul>
    <br/><br/>


    <li><b>Variables</b></li>
    <br/>
    <ul>
        <li>Variables make your configuration reusable and configurable.</li>
        <li>Defined using:</li>
    </ul>

<pre><code class="language-hcl line-numbers">variable "instance_type" {
    description = "EC2 instance type"
    type        = string
    default     = "t2.micro"
}
</code></pre>

    <ul>
        <li>Used like:</li>
    </ul>

<pre><code class="language-hcl line-numbers">instance_type = var.instance_type
</code></pre>

    <ul>
        <li>Values can be passed via:
            <ul>
                <li><code>terraform.tfvars</code></li>
                <li><code>-var</code> command flag</li>
                <li>environment variables (<code>TF_VAR_...</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Variable Files</b> (<code>.tfvars</code>)</li>
    <br/>
    <ul>
        <li>Used to provide external input values:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">instance_type = "t3.small"
bucket_name   = "prod-assets-2025"
</code></pre>

    <ul>
        <li>Terraform automatically loads:</li>
        <ul>
            <li><code>terraform.tfvars</code></li>
            <li><code>*.auto.tfvars</code></li>
        </ul>
        <br/>
        <li>Other files require manual loading:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform apply -var-file=prod.tfvars
</code></pre>

    <br/><br/>


    <li><b>Outputs</b></li>
    <br/>
    <ul>
        <li>Outputs allow Terraform to display useful information after apply:</li>
    </ul>

<pre><code class="language-hcl line-numbers">output "public_ip" {
    description = "Public IP of the instance"
    value       = aws_instance.my_server.public_ip
}
</code></pre>

    <ul>
        <li>View outputs:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform output
terraform output public_ip
</code></pre>

    <br/><br/>


    <li><b>Locals</b></li>
    <br/>
    <ul>
        <li>Local values are internal configuration shortcuts.</li>
    </ul>

<pre><code class="language-hcl line-numbers">locals {
    tags = {
        Environment = "production"
        Owner       = "Junzhe"
    }
}

resource "aws_s3_bucket" "bucket" {
    bucket = "my-demo-bucket-2025"
    tags   = local.tags
}
</code></pre>

    <br/><br/>


    <li><b>Data Sources</b></li>
    <br/>
    <ul>
        <li>Data sources let Terraform <b>query existing resources</b>.</li>
        <li>Example: fetch the latest AMI ID:</li>
    </ul>

<pre><code class="language-hcl line-numbers">data "aws_ami" "latest_amazon_linux" {
    owners      = ["amazon"]
    most_recent = true

    filter {
        name   = "name"
        values = ["amzn2-ami-hvm-*-x86_64-gp2"]
    }
}

resource "aws_instance" "server" {
    ami           = data.aws_ami.latest_amazon_linux.id
    instance_type = "t2.micro"
}
</code></pre>

    <ul>
        <li>Data sources are <b>read-only</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Modules</b></li>
    <br/>
    <ul>
        <li>Modules allow you to group and reuse resources.</li>
        <li>Example using a public module:</li>
    </ul>

<pre><code class="language-hcl line-numbers">module "vpc" {
    source = "terraform-aws-modules/vpc/aws"
    version = "~&gt; 5.1"

    name = "prod-vpc"
    cidr = "10.0.0.0/16"
}
</code></pre>

    <ul>
        <li>You can also write your own module:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">
modules/
└── ec2/
    ├── main.tf
    ├── variables.tf
    └── outputs.tf
</code></pre>

    <br/><br/>


    <li><b>Expressions and Interpolation Syntax</b></li>
    <br/>
    <ul>
        <li>Terraform uses <code>${ ... }</code> for interpolation, but modern style allows direct reference:</li>
    </ul>

<pre><code class="language-hcl line-numbers">ami           = data.aws_ami.latest.id
instance_type = var.instance_type
tags          = local.tags
</code></pre>

    <ul>
        <li>Useful functions exist:</li>
    </ul>

<pre><code class="language-hcl line-numbers">timestamp()
upper("hello")
join("-", ["prod", "eu", "vpc"])
</code></pre>

    <br/><br/>


    <li><b>Lifecycle Rules</b></li>
    <br/>
    <ul>
        <li>Used for fine control over create/update/destroy behavior.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "server" {
    ami           = var.ami
    instance_type = "t2.micro"

    lifecycle {
        prevent_destroy = true
    }
}
</code></pre>

    <ul>
        <li>Other lifecycle options:
            <ul>
                <li><code>create_before_destroy</code></li>
                <li><code>ignore_changes</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Putting Everything Together: A Complete Example</b></li>
    <br/>
    <ul>
        <li>This small configuration provisions:
            <ul>
                <li>An EC2 instance</li>
                <li>An elastic IP</li>
                <li>Outputs its public IP</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"
}

variable "instance_type" {
    default = "t2.micro"
}

resource "aws_instance" "vm" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = var.instance_type

    tags = {
        Name = "ExampleVM"
    }
}

resource "aws_eip" "ip" {
    instance = aws_instance.vm.id
}

output "public_ip" {
    value = aws_eip.ip.public_ip
}
</code></pre>

    <ul>
        <li>Run it:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform init
terraform plan
terraform apply
</code></pre>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-aws-intro">Using Terraform with AWS: An Introduction</h3>
<ol>

    <li><b>What Is AWS Terraform?</b></li>
    <br/>
    <ul>
        <li>Terraform can manage nearly all AWS resources using the <b>AWS Provider</b>.</li>
        <br/>
        <li>You write <code>.tf</code> files that describe what AWS infrastructure you want:
            <ul>
                <li>EC2 instances</li>
                <li>VPCs and subnets</li>
                <li>IAM users and roles</li>
                <li>S3 buckets</li>
                <li>RDS databases</li>
                <li>Lambda functions</li>
                <li>CloudWatch alarms</li>
                <li>Load balancers</li>
            </ul>
        </li>
        <br/>
        <li>Terraform then:
            <ul>
                <li>calls AWS APIs via the provider,</li>
                <li>creates/updates/destroys resources,</li>
                <li>tracks them in its state file.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Prerequisites for AWS Terraform</b></li>
    <br/>
    <ul>
        <li>Before using Terraform with AWS, you must have:</li>
        <ul>
            <li>an AWS account,</li>
            <li>an IAM user with enough permissions,</li>
            <li>AWS credentials saved locally.</li>
        </ul>
        <br/>
        <li><b>Store credentials safely</b> using the AWS CLI:</li>
    </ul>

<pre><code class="language-bash line-numbers">aws configure
</code></pre>

    <ul>
        <li>Typical files where credentials go:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">~/.aws/credentials
~/.aws/config
</code></pre>

    <ul>
        <li><b>Never store AWS secret keys directly in Terraform files.</b></li>
    </ul>
    <br/><br/>


    <li><b>AWS Provider Block</b></li>
    <br/>
    <ul>
        <li>The AWS provider connects Terraform to AWS.</li>
        <li>Basic configuration:</li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"
}
</code></pre>

    <ul>
        <li>Terraform loads credentials automatically from environment variables, the AWS config file, or IAM roles (if on EC2).</li>
    </ul>
    <br/><br/>


    <li><b>Deploying Your First AWS Resource: S3 Bucket</b></li>
    <br/>
    <ul>
        <li>S3 buckets are one of the simplest AWS resources to create:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "example" {
    bucket = "junzhe-demo-bucket-12345"

    tags = {
        Purpose = "TerraformIntro"
    }
}
</code></pre>

    <ul>
        <li>Apply it:</li>
    </ul>

<pre><code class="language-bash line-numbers">terraform init
terraform apply
</code></pre>

    <ul>
        <li>You now created your first AWS resource using Terraform.</li>
    </ul>
    <br/><br/>


    <li><b>Creating an EC2 Instance with Terraform</b></li>
    <br/>
    <ul>
        <li>EC2 deployment includes:
            <ul>
                <li>an AMI (machine image)</li>
                <li>instance type</li>
                <li>optional key pair</li>
                <li>security group</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_instance" "web" {
    ami           = "ami-05f7491af5eef733a"
    instance_type = "t2.micro"

    tags = {
        Name = "TerraformWebServer"
    }
}
</code></pre>

    <ul>
        <li>Show the server’s public IP:</li>
    </ul>

<pre><code class="language-hcl line-numbers">output "public_ip" {
    value = aws_instance.web.public_ip
}
</code></pre>

    <br/><br/>


    <li><b>Using Data Sources (AWS Example)</b></li>
    <br/>
    <ul>
        <li>AWS has many dynamic values (latest AMIs, VPC IDs, etc.).</li>
        <li>Data sources allow Terraform to <b>look up existing AWS infrastructure</b>.</li>
    </ul>

<pre><code class="language-hcl line-numbers">data "aws_ami" "amazon_linux" {
    owners      = ["amazon"]
    most_recent = true

    filter {
        name   = "name"
        values = ["amzn2-ami-hvm-*-x86_64-gp2"]
    }
}

resource "aws_instance" "server" {
    ami           = data.aws_ami.amazon_linux.id
    instance_type = "t2.micro"
}
</code></pre>

    <ul>
        <li>Using a data source ensures your AMI is always up to date.</li>
    </ul>
    <br/><br/>


    <li><b>Managing AWS Networking (VPC, Subnets, SG)</b></li>
    <br/>
    <ul>
        <li>A typical AWS Terraform setup includes:
            <ul>
                <li>VPC</li>
                <li>subnets</li>
                <li>route tables</li>
                <li>security groups</li>
            </ul>
        </li>
        <br/>
        <li>A minimal example:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_vpc" "main" {
    cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
    vpc_id                  = aws_vpc.main.id
    cidr_block              = "10.0.1.0/24"
    map_public_ip_on_launch = true
}

resource "aws_security_group" "web_sg" {
    name        = "web-sg"
    description = "Allow HTTP"
    vpc_id      = aws_vpc.main.id

    ingress {
        from_port   = 80
        to_port     = 80
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
    }
}
</code></pre>

    <ul>
        <li>This is the foundation for most AWS architectures.</li>
    </ul>
    <br/><br/>


    <li><b>IAM with Terraform (Users, Roles, Policies)</b></li>
    <br/>
    <ul>
        <li>IAM is fully manageable through Terraform.</li>
        <li>Create a new user:</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_iam_user" "developer" {
    name = "junzhe-dev"
}

resource "aws_iam_access_key" "developer_key" {
    user = aws_iam_user.developer.name
}

output "dev_access_key" {
    value = aws_iam_access_key.developer_key.id
}
</code></pre>

    <ul>
        <li><b>Never output IAM secrets in production environments.</b></li>
    </ul>
    <br/><br/>


    <li><b>S3 + IAM Example (Realistic Use Case)</b></li>
    <br/>
    <ul>
        <li>This example creates a bucket and a policy that grants read/write access.</li>
    </ul>

<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "app_bucket" {
    bucket = "terraform-app-bucket-2025"
}

data "aws_iam_policy_document" "rw_access" {
    statement {
        actions   = ["s3:*"]
        resources = [
            aws_s3_bucket.app_bucket.arn,
            "${aws_s3_bucket.app_bucket.arn}/*"
        ]
    }
}

resource "aws_iam_policy" "app_bucket_policy" {
    name   = "AppBucketRW"
    policy = data.aws_iam_policy_document.rw_access.json
}
</code></pre>

    <br/><br/>


    <li><b>Using AWS Modules</b></li>
    <br/>
    <ul>
        <li>The easiest way to build AWS infrastructure is by using well-maintained Terraform Registry modules.</li>
        <li>Example: AWS VPC module</li>
    </ul>

<pre><code class="language-hcl line-numbers">module "vpc" {
    source  = "terraform-aws-modules/vpc/aws"
    version = "5.1.0"

    name = "production-vpc"
    cidr = "10.1.0.0/16"

    azs             = ["eu-central-1a", "eu-central-1b"]
    public_subnets  = ["10.1.1.0/24", "10.1.2.0/24"]
    private_subnets = ["10.1.3.0/24", "10.1.4.0/24"]
}
</code></pre>

    <ul>
        <li>Modules drastically reduce effort and errors.</li>
    </ul>
    <br/><br/>


    <li><b>Remote State Backend for AWS Projects (Recommended)</b></li>
    <br/>
    <ul>
        <li>For team projects, store Terraform state in S3 and lock with DynamoDB:</li>
    </ul>

<pre><code class="language-hcl line-numbers">terraform {
    backend "s3" {
        bucket         = "my-terraform-state-prod"
        key            = "global/state.tfstate"
        region         = "eu-central-1"
        dynamodb_table = "terraform-locks"
        encrypt        = true
    }
}
</code></pre>

    <ul>
        <li>This prevents:
            <ul>
                <li>conflicting changes,</li>
                <li>lost state files,</li>
                <li>corrupted environments.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Common AWS Terraform Patterns</b></li>
    <br/>
    <ul>
        <li>Almost every AWS Terraform project involves:</li>
        <ul>
            <li>using data sources to fetch AMIs</li>
            <li>creating VPC + subnets</li>
            <li>security groups for inbound/outbound rules</li>
            <li>EC2 instances or ECS/Lambda</li>
            <li>IAM roles for services</li>
            <li>S3 buckets for artifacts</li>
            <li>CloudWatch for monitoring</li>
            <li>Route53 for DNS</li>
        </ul>
        <br/>
        <li>These patterns can scale from tiny personal projects to large enterprise deployments.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-init-command">Understanding the <code>terraform init</code> Command</h3>
<ol>

    <li>What Does <code>terraform init</code> Do?</li>
    <br/>
    <ul>
        <li><code>terraform init</code> is the <b>first command</b> you run in any new or cloned Terraform project directory.</li>
        <br/>
        <li>Its main responsibilities:</li>
        <ul>
            <li>Initialize the working directory as a Terraform project</li>
            <li>Download and install required <b>providers</b> (e.g. AWS, Azure, Google)</li>
            <li>Download <b>modules</b> defined in your configuration</li>
            <li>Initialize and configure the <b>backend</b> (where the state is stored)</li>
            <li>Create internal metadata like <code>.terraform/</code> and <code>.terraform.lock.hcl</code></li>
        </ul>
        <br/>
        <li>Typical workflow:</li>
<pre><code class="language-bash line-numbers">terraform init
terraform plan
terraform apply</code></pre>
        <br/>
        <li>If you skip <code>terraform init</code>, <code>plan</code> and <code>apply</code> will fail because providers/backends are not set up.</li>
    </ul>
    <br/><br/>


    <li>What Happens in the Working Directory?</li>
    <br/>
    <ul>
        <li>After running <code>terraform init</code>, Terraform creates/updates:</li>
        <br/>
        <ul>
            <li><code>.terraform/</code> — internal directory for:
                <ul>
                    <li>downloaded provider plugins</li>
                    <li>downloaded modules</li>
                    <li>backend metadata</li>
                </ul>
            </li>
            <li><code>.terraform.lock.hcl</code> — dependency lockfile (provider versions, etc.)</li>
        </ul>
        <br/>
        <li>This makes your project:
            <ul>
                <li>reproducible (same provider versions)</li>
                <li>ready to run plans/applies</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Basic Usage: <code>terraform init</code></li>
    <br/>
    <ul>
        <li>Inside a folder containing <code>*.tf</code> files:</li>
<pre><code class="language-bash line-numbers">cd my-terraform-project
terraform init</code></pre>
        <br/>
        <li>Terraform then:</li>
        <ul>
            <li>Scans your <code>.tf</code> files for:
                <ul>
                    <li><code>required_providers</code></li>
                    <li><code>terraform</code> block</li>
                    <li><code>backend</code> configuration</li>
                    <li><code>module</code> blocks</li>
                </ul>
            </li>
            <li>Downloads missing providers</li>
            <li>Fetches modules from:
                <ul>
                    <li>Terraform Registry</li>
                    <li>Git repositories</li>
                    <li>local paths</li>
                </ul>
            </li>
            <li>Configures backend (local or remote state)</li>
        </ul>
        <br/>
        <li>You usually run this:
            <ul>
                <li>once when starting a new project</li>
                <li>again when:
                    <ul>
                        <li>changing providers/backends</li>
                        <li>upgrading provider versions</li>
                        <li>adding new modules</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>How <code>terraform init</code> Handles Providers</li>
    <br/>
    <ul>
        <li>Example configuration (<code>main.tf</code>):</li>
<pre><code class="language-hcl line-numbers">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 5.0"
    }
  }
}</code></pre>
        <br/>
        <li>When you run:</li>
<pre><code class="language-bash line-numbers">terraform init</code></pre>
        <br/>
        <li>Terraform will:</li>
        <ul>
            <li>Look up provider <code>"hashicorp/aws"</code> in the Terraform Registry</li>
            <li>Download a version compatible with <code>~&gt; 5.0</code></li>
            <li>Store it under <code>.terraform/providers/...</code></li>
            <li>Record the exact version in <code>.terraform.lock.hcl</code></li>
        </ul>
        <br/>
        <li>This ensures every developer on the project uses exactly the same provider versions.</li>
    </ul>
    <br/><br/>


    <li>How <code>terraform init</code> Handles Modules</li>
    <br/>
    <ul>
        <li>Example module usage:</li>
<pre><code class="language-hcl line-numbers">module "network" {
  source = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"

  name = "example-vpc"
  cidr = "10.0.0.0/16"
}</code></pre>
        <br/>
        <li>On <code>terraform init</code>, Terraform will:</li>
        <ul>
            <li>Locate module <code>terraform-aws-modules/vpc/aws</code> in the Registry</li>
            <li>Download it into <code>.terraform/modules/</code></li>
            <li>Use that local copy when running <code>plan</code>/<code>apply</code></li>
        </ul>
        <br/>
        <li>If you update <code>version</code> or <code>source</code>, re-run <code>terraform init</code> to fetch the new module version.</li>
    </ul>
    <br/><br/>


    <li>Backends and <code>terraform init</code></li>
    <br/>
    <ul>
        <li>The <b>backend</b> defines where your Terraform state (<code>terraform.tfstate</code>) is stored.</li>
        <br/>
        <li>Example local backend (default):</li>
<pre><code class="language-hcl line-numbers">terraform {
  backend "local" {
    path = "terraform.tfstate"
  }
}</code></pre>
        <br/>
        <li>Example remote backend (Amazon S3):</li>
<pre><code class="language-hcl line-numbers">terraform {
  backend "s3" {
    bucket = "my-terraform-state-bucket"
    key    = "envs/prod/terraform.tfstate"
    region = "eu-central-1"
  }
}</code></pre>
        <br/>
        <li>When you run <code>terraform init</code> with a backend block:</li>
        <ul>
            <li>Terraform configures the backend</li>
            <li>It may prompt you to migrate existing local state into the remote backend</li>
            <li>It writes backend metadata into <code>.terraform/</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li>Useful Options for <code>terraform init</code></li>
    <br/>
    <ul>
        <li>1. <code>-upgrade</code> &mdash; Upgrade providers and modules</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -upgrade</code></pre>
        <li>What it does:</li>
        <ul>
            <li>Checks for newer versions of required providers (within your version constraints)</li>
            <li>Redownloads modules to the latest acceptable versions</li>
            <li>Updates <code>.terraform.lock.hcl</code></li>
        </ul>
        <br/>
        <br/>

        <li>2. <code>-backend-config</code> &mdash; Override backend settings</li>
        <br/>
        <li>Instead of putting secrets in <code>.tf</code> files, you can pass them via CLI:</li>
<pre><code class="language-bash line-numbers">terraform init \
  -backend-config="bucket=my-tf-state" \
  -backend-config="region=eu-central-1"</code></pre>
        <br/>
        <li>Each <code>-backend-config</code> argument sets/overrides a backend argument.</li>
        <br/>
        <br/>

        <li>3. <code>-reconfigure</code> &mdash; Force backend reconfiguration</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -reconfigure</code></pre>
        <br/>
        <li>Use when:</li>
        <ul>
            <li>you changed backend type or remote config</li>
            <li>you want Terraform to forget previous backend settings and ask again</li>
        </ul>
        <br/>
        <br/>

        <li>4. <code>-migrate-state</code> &mdash; Move state between backends</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -migrate-state</code></pre>
        <br/>
        <li>Use when you:</li>
        <ul>
            <li>switch from local → remote backend (e.g., local → S3)</li>
            <li>move between two different remote backends</li>
        </ul>
        <br/>
        <li>Terraform will ask for confirmation before physically moving the state file.</li>
        <br/>
        <br/>

        <li>5. <code>-from-module</code> &mdash; Initialize a new project from a module</li>
        <br/>
<pre><code class="language-bash line-numbers">terraform init -from-module=git::https://github.com/example/infra-module.git</code></pre>
        <br/>
        <li>What it does:</li>
        <ul>
            <li>Clones/copies the specified module into the current directory</li>
            <li>Then initializes providers and submodules as usual</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Idempotency: Re-running <code>terraform init</code></li>
    <br/>
    <ul>
        <li>It is <b>safe</b> to run <code>terraform init</code> multiple times.</li>
        <br/>
        <li>On repeated runs, Terraform will:</li>
        <ul>
            <li>Reuse already-downloaded providers (unless <code>-upgrade</code> is set)</li>
            <li>Reuse modules (again, unless <code>-upgrade</code>)</li>
            <li>Verify backend configuration</li>
        </ul>
        <br/>
        <li>You should re-run <code>init</code> when:</li>
        <ul>
            <li>cloning a repo for the first time</li>
            <li>changing provider versions</li>
            <li>changing backend configs</li>
            <li>adding/removing modules</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Putting It All Together: Example Session</li>
    <br/>
    <ul>
        <li>Imagine you have this setup in <code>main.tf</code>:</li>
<pre><code class="language-hcl line-numbers">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 5.0"
    }
  }
  backend "s3" {
    bucket = "my-tf-state-bucket"
    key    = "dev/terraform.tfstate"
    region = "eu-central-1"
  }
}</code></pre>
        <br/>
        <li>Typical usage:</li>
<pre><code class="language-bash line-numbers"># 1. Initialize project, providers, modules, backend
terraform init

# 2. (Later) change versions or modules, then upgrade
terraform init -upgrade

# 3. (Later) migrate from local backend to S3
terraform init -migrate-state -reconfigure</code></pre>
        <br/>
        <li>This sequence is extremely common in real-world Terraform projects.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-block-reference">Understanding the <code>terraform</code> Block in Terraform</h3>
<ol>

    <li>What Is the <code>terraform</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>terraform</code> block is a special <b>top-level</b> configuration block in Terraform that controls:
            <ul>
                <li>required provider versions</li>
                <li>required Terraform CLI version</li>
                <li>backend configuration (state storage)</li>
                <li>module behavior</li>
                <li>dependency lockfile rules</li>
            </ul>
        </li>
        <br/>
        <li>It does <u>not</u> provision infrastructure itself. It only configures Terraform’s behavior.</li>
        <br/>
        <li>This block is normally placed at the top of <code>main.tf</code>.</li>
    </ul>
    <br/><br/>


    <li>The General Structure of the <code>terraform</code> Block</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_version = "~&gt; 1.5.0"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }

    backend "s3" {
        bucket = "my-terraform-state"
        key    = "prod/terraform.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

        <br/>
        <li>This block lets Terraform know:
            <ul>
                <li>What version of Terraform is allowed</li>
                <li>Which providers are required</li>
                <li>Where to store the state</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><code>required_version</code> — Terraform CLI Version Constraint</li>
    <br/>
    <ul>
        <li>Ensures compatibility across team members and CI pipelines.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_version = "&gt;= 1.4.0, < 1.6.0"
}
</code></pre>

        <li>What it means:</li>
        <ul>
            <li>Terraform must be at least version <code>1.4.0</code></li>
            <li>Terraform must be &lt; <code>1.6.0</code></li>
        </ul>
        <br/>
        <li>If you run an incompatible version, Terraform will refuse to continue.</li>
    </ul>
    <br/><br/>


    <li><code>required_providers</code> — Provider Requirements</li>
    <ul>
        <br/>
        <li>This section tells Terraform which providers your configuration needs.</li>
        <br/>
        <li>This also defines:
            <ul>
                <li>provider source (where to download it from)</li>
                <li>provider version constraints</li>
            </ul>
        </li>
        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
        random = {
            source  = "hashicorp/random"
            version = "&gt;= 3.5.0"
        }
    }
}
</code></pre>

        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>aws</code> provider must be downloaded from the Hashicorp registry.</li>
            <li>Version must match <code>~&gt; 5.0</code> means <code>&gt;= 5.0.0, &lt; 6.0.0</code>
            </li>
            <li><code>random</code> provider must be at least <code>3.5.0</code></li>
        </ul>
        <br/>
        <li>These rules will be saved in <code>.terraform.lock.hcl</code> after <code>terraform init</code>.</li>
    </ul>
    <br/><br/>


    <li><code>backend</code> — Terraform State Storage</li>
    <br/>
    <ul>
        <li>Terraform stores its state (<code>terraform.tfstate</code>) externally using backends.</li>
        <br/>
        <li>Backends DO NOT support interpolation. Everything must be hard-coded or supplied via <code>-backend-config</code>.</li>
        <br/>

        <li>Example (S3 backend):</li>
<pre><code class="language-hcl line-numbers">terraform {
    backend "s3" {
        bucket = "my-tf-state"
        key    = "dev/state.tfstate"
        region = "eu-central-1"
    }
}
</code></pre>

        <li>What it does:</li>
        <ul>
            <li>Stores state in S3 bucket</li>
            <li>Key identifies the file path inside the bucket</li>
            <li>Supports locking when combined with DynamoDB</li>
        </ul>
        <br/>

        <li>You can override backend values:</li>
<pre><code class="language-bash line-numbers">terraform init                                  \
    -backend-config="bucket=my-other-bucket"    \
    -backend-config="key=new-key.tfstate"
</code></pre>
    </ul>
    <br/><br/>


    <li>Less Common but Useful Settings</li>
    <br/>
    <ol>
        <li><code>provider_meta</code> (rare)</li>
<pre><code class="language-hcl line-numbers">terraform {
    provider_meta "aws" {
        module_name = "custom-aws-module"
    }
}
</code></pre>

        <br/>

        <li><code>experiments</code> (very rare)</li>
<pre><code class="language-hcl line-numbers">terraform {
    experiments = [module_variable_optional_attrs]
}
</code></pre>

        <br/>

        <li><code>cloud</code> block (Terraform Cloud/Enterprise)</li>
<pre><code class="language-hcl line-numbers">terraform {
    cloud {
        organization = "mycompany"

        workspaces {
            name = "production"
        }
    }
}
</code></pre>
        <ul>
            <li>This integrates Terraform Cloud as the state backend + runs.</li>
        </ul>
        <br/>
    </ol>
    <br/><br/>


    <li>Putting It All Together — Complete Example</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_version = "~&gt; 1.5"

    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
        kubernetes = {
            source  = "hashicorp/kubernetes"
            version = "~&gt; 2.20"
        }
    }

    backend "s3" {
        bucket = "my-terraform-state-bucket"
        key    = "envs/prod/state.tfstate"
        region = "eu-central-1"
        encrypt = true
    }
}
</code></pre>

    <ul>
        <li>This prepares Terraform to:</li>
        <ul>
            <li>Use Terraform CLI 1.5.x</li>
            <li>Download AWS and Kubernetes providers</li>
            <li>Store state remotely in S3</li>
            <li>Use encryption for the state file</li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-provider-block">Understanding the <code>provider</code> Block in Terraform</h3>
<ol>

    <li>What Is the <code>provider</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>provider</code> block configures a specific cloud/vendor provider used by Terraform.</li>
        <br/>
        <li>A provider is responsible for:</li>
        <ul>
            <li>connecting Terraform to an external system (AWS, Azure, GCP, Kubernetes, etc.)</li>
            <li>authenticating</li>
            <li>defining regions/endpoints</li>
            <li>making API requests</li>
            <li>creating/updating/deleting resources</li>
        </ul>
        <br/>
        <li>Every resource (like <code>aws_instance</code>, <code>google_compute_network</code>, <code>kubernetes_deployment</code>) requires a provider.</li>
        <br/>
        <li>The provider block tells Terraform <b>how to configure</b> that provider (not which version—that belongs in the <code>terraform</code> block).</li>
    </ul>
    <br/><br/>


    <li>The Structure of a <code>provider</code> Block</li>
    <br/>
    <ul>
        <li>General form:</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region     = "eu-central-1"
    access_key = "AKIA..."
    secret_key = "SECRET..."
}
</code></pre>

        <li>Important points:</li>
        <ul>
            <li><code>provider "aws"</code> → refers to the AWS provider</li>
            <li>arguments inside → configure authentication, regions, settings</li>
            <li>DO NOT include provider version here</li>
        </ul>

        <br/>
        <li>Basic guideline:
            <ul>
                <li><code>terraform.required_providers</code> → WHICH provider + version</li>
                <li><code>provider</code> → HOW the provider connects to the cloud</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Example: AWS Provider Configuration</li>
    <br/>
    <ul>
        <li>A realistic AWS provider block:</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"

    default_tags {
        tags = {
            project = "terraform-demo"
            owner   = "junzhe"
        }
    }
}
</code></pre>

        <li>Explanation:</li>
        <ul>
            <li><code>region</code> is where Terraform creates AWS resources</li>
            <li><code>default_tags</code> are automatically attached tags to every AWS resource</li>
        </ul>

        <br/>
        <li>Authentication is normally handled externally:
            <ul>
                <li>environment variables</li>
                <li>AWS CLI profile</li>
                <li>EC2 instance role</li>
            </ul>
        </li>

        <br/>
        <li>AWS provider supports many options such as:</li>
        <ul>
            <li><code>profile</code> (use AWS CLI profile)</li>
            <li><code>assume_role</code> blocks</li>
            <li><code>endpoints</code> (custom AWS endpoints)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Example: Google Cloud Provider</li>
<pre><code class="language-hcl line-numbers">provider "google" {
    project = "my-gcp-project"
    region  = "us-central1"
    zone    = "us-central1-a"
}
</code></pre>

    <ul>
        <li>Explanation:</li>
        <ul>
            <li><code>project</code> is your GCP project ID</li>
            <li><code>region</code> are regional GCP resources</li>
            <li><code>zone</code> are zonal resources</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Multiple Provider Configurations</li>
    <br/>
    <ul>
        <li>You can configure multiple provider blocks for:</li>
        <ul>
            <li>multi-region deployments</li>
            <li>multi-account deployments</li>
            <li>multiple Kubernetes clusters</li>
        </ul>
        <br/>

        <li>Example: Two AWS regions</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    alias  = "eu"
    region = "eu-central-1"
}

provider "aws" {
    alias  = "us"
    region = "us-east-1"
}
</code></pre>

        <br/>
        <li>Use them in resources:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "bucket_eu" {
    provider = aws.eu
    bucket   = "bucket-europe"
}

resource "aws_s3_bucket" "bucket_us" {
    provider = aws.us
    bucket   = "bucket-america"
}
</code></pre>

        <br/>
        <li>Aliases allow multiple configurations for the same provider.</li>
    </ul>
    <br/><br/>


    <li>Provider Inheritance Rule</li>
    <br/>
    <ul>
        <li>Resources automatically use the default (non-aliased) provider.</li>
        <br/>
        <li>Only use <code>provider = aws.aliasname</code> when:</li>
        <ul>
            <li>you have multiple provider configs</li>
            <li>a resource belongs to a non-default provider</li>
        </ul>
        <br/>
        <li>Modules inherit provider configs from the root module unless overridden.</li>
    </ul>
    <br/><br/>


    <li><code>provider</code> Blocks vs. <code>required_providers</code></li>
    <br/>
    <ul>
        <li><b>required_providers</b> (inside <code>terraform</code> block):</li>
        <ul>
            <li>States which providers you want</li>
            <li>Specifies versions</li>
            <li>Dictates where to download the provider from</li>
        </ul>

        <br/>

        <li><b>provider</b> block:</li>
        <ul>
            <li>Configures the provider connection</li>
            <li>Sets up authentication</li>
            <li>Specifies region/endpoints</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Passing Variables into Provider Configurations</li>
    <br/>
    <ul>
        <li>You can parameterize provider configuration:</li>
<pre><code class="language-hcl line-numbers">variable "aws_region" {
    default = "eu-central-1"
}

provider "aws" {
    region = var.aws_region
}
</code></pre>

        <li>Don’t hardcode credentials in provider blocks.</li>
    </ul>
    <br/><br/>


    <li>Debugging Provider Issues</li>
    <br/>
    <ul>
        <li>Common mistakes include:</li>
        <ul>
            <li>Missing authentication environment variables</li>
            <li>Using wrong regions</li>
            <li>Incorrect aliases</li>
            <li>Mismatched provider versions (but Terraform catches this)</li>
        </ul>

        <br/>
        <li>Useful debug command:</li>
<pre><code class="language-bash line-numbers">TF_LOG=DEBUG terraform apply</code></pre>
        <li>This prints all API calls and provider loading behavior.</li>
    </ul>
    <br/><br/>


    <li>Complete Example</li>
<pre><code class="language-hcl line-numbers">terraform {
    required_providers {
        aws = {
            source  = "hashicorp/aws"
            version = "~&gt; 5.0"
        }
    }
}

provider "aws" {
    region = "eu-central-1"

    default_tags {
        tags = {
            env = "production"
        }
    }
}

resource "aws_s3_bucket" "example" {
    bucket = "my-s3-bucket-demo-12345"
}
</code></pre>
    <ul>
        <li>Terraform downloads AWS provider version 5.x</li>
        <li>Provider connects to AWS Frankfurt region</li>
        <li>An S3 bucket is created using that provider configuration</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-resource-block">Understanding the <code>resource</code> Block in Terraform</h3>
<ol>

    <li>What Is a <code>resource</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>resource</code> block is the core building block of Terraform.</li>
        <br/>
        <li>It describes:
            <ul>
                <li>WHAT infrastructure should be created</li>
                <li>HOW it should look</li>
                <li>WHICH provider should manage it</li>
                <li>WHAT arguments customize the resource</li>
            </ul>
        </li>
        <br/>
        <li>Example resources include:
            <ul>
                <li><code>aws_instance</code> → EC2 VM</li>
                <li><code>google_compute_network</code> → GCP VPC</li>
                <li><code>kubernetes_deployment</code> → K8S Deployment</li>
                <li><code>azurerm_storage_account</code> → Azure storage</li>
            </ul>
        </li>
        <br/>
        <li>Terraform reads the <code>resource</code> blocks, calculates the desired state, and makes provider API calls to achieve it.</li>
    </ul>
    <br/><br/>


    <li>The Structure of a <code>resource</code> Block</li>
    <br/>
    <ul>
        <li>Basic syntax:</li>
<pre><code class="language-hcl line-numbers">resource "PROVIDER_RESOURCE_TYPE" "LOCAL_NAME" {
    # arguments (config)
}
</code></pre>

        <li>Breakdown:</li>
        <ul>
            <li><code>PROVIDER_RESOURCE_TYPE</code> → e.g. <code>aws_s3_bucket</code></li>
            <li><code>LOCAL_NAME</code> → your own identifier (internal to Terraform)</li>
            <li>arguments inside block → specify configuration</li>
        </ul>

        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "my_bucket" {
    bucket = "junzhe-terraform-demo"
    acl    = "private"
}
</code></pre>

        <li>Here:
            <ul>
                <li><code>aws_s3_bucket</code> is the resource type</li>
                <li><code>my_bucket</code> is the name used within Terraform</li>
                <li>It creates a real AWS S3 bucket</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Understanding Resource Types</li>
    <br/>
    <ul>
        <li>Resource types follow this naming pattern:</li>
<pre><code class="language-plaintext line-numbers">&lt;PROVIDER_NAME&gt;_&lt;RESOURCE_TYPE&gt;
</code></pre>

        <li>Examples:</li>
        <ul>
            <li><code>aws_instance</code></li>
            <li><code>aws_security_group</code></li>
            <li><code>google_storage_bucket</code></li>
            <li><code>kubernetes_service</code></li>
        </ul>

        <br/>
        <li>The provider determines which resource types exist.
            Check your provider documentation for the full list.</li>
    </ul>
    <br/><br/>


    <li>Example 1: AWS EC2 Instance</li>
<pre><code class="language-hcl line-numbers">resource "aws_instance" "web" {
    ami           = "ami-0ff8a91507f77f867"
    instance_type = "t3.micro"

    tags = {
        Name = "WebServer"
    }
}
</code></pre>
    <ul>
        <li>Arguments:</li>
        <ul>
            <li><code>ami</code> → machine image</li>
            <li><code>instance_type</code> → VM size</li>
            <li><code>tags</code> → metadata</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Resource Arguments vs. Attributes</li>
    <br/>
    <ul>
        <li><b>Arguments</b> are input from your configuration</li>
        <br/>
        <li><b>Attributes</b> are output from the infrastructure provider</li>
        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "example" {
    bucket = "my-bucket"
}

output "bucket_arn" {
    value = aws_s3_bucket.example.arn
}
</code></pre>

        <ul>
            <li><code>bucket</code> → argument</li>
            <li><code>arn</code> → computed attribute</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Lifecycles for Resources (<code>lifecycle</code> Block)</li>
    <br/>
    <ul>
        <li>You can customize how Terraform manages updates:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "demo" {
    bucket = "demo-bucket"

    lifecycle {
        prevent_destroy = true
        ignore_changes  = [tags]
        create_before_destroy = true
    }
}
</code></pre>
        <li>Key lifecycle options:</li>
        <ul>
            <li><code>prevent_destroy</code> protects critical resources</li>
            <li><code>ignore_changes</code> makes Terraform ignore drift on selected attributes</li>
            <li><code>create_before_destroy</code> avoids downtime during resource replacement</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Meta-Arguments in Resource Blocks</li>
    <br/>
    <ul>
        <li>1. <code>count</code></li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "buckets" {
    count  = 3
    bucket = "bucket-${count.index}"
}
</code></pre>

        <li>2. <code>for_each</code></li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "buckets" {
    for_each = toset(["a", "b", "c"])
    bucket   = "bucket-${each.key}"
}
</code></pre>

        <li>3. <code>depends_on</code> — force explicit ordering</li>
<pre><code class="language-hcl line-numbers">resource "aws_iam_role" "role" {
    # ...
}

resource "aws_instance" "server" {
    depends_on = [aws_iam_role.role]
    # ...
}
</code></pre>

        <li>4. <code>provider</code> — choose a provider configuration</li>
<pre><code class="language-hcl line-numbers">provider "aws" {
    alias  = "us"
    region = "us-east-1"
}

resource "aws_s3_bucket" "us_bucket" {
    provider = aws.us
    bucket   = "bucket-us"
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Resource Dependencies</li>
    <br/>
    <ul>
        <li>Terraform automatically infers ordering via variables and references:</li>
<pre><code class="language-hcl line-numbers">resource "aws_vpc" "main" {
    cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "subnet" {
    vpc_id = aws_vpc.main.id   # implicit dependency
}
</code></pre>
        <li>If implicit dependencies fail, use <code>depends_on</code>.</li>
    </ul>
    <br/><br/>


    <li>Importing Existing Resources</li>
    <br/>
    <ul>
        <li>You can import existing real cloud resources into Terraform state:</li>
<pre><code class="language-bash line-numbers">terraform import aws_s3_bucket.my_bucket my-real-bucket</code></pre>
        <li>After import:
            <ul>
                <li>The resource exists in state</li>
                <li>You must write the matching <code>resource</code> block manually</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Destroying Resources</li>
    <br/>
    <ul>
        <li>Delete a resource from config → <code>terraform apply</code> will destroy it.</li>
        <br/>
        <li>Or destroy explicitly:</li>
<pre><code class="language-bash line-numbers">terraform destroy -target=aws_s3_bucket.my_bucket</code></pre>
    </ul>
    <br/><br/>


    <li>Complete Example Project</li>
    <ul>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region = "eu-central-1"
}

resource "aws_vpc" "main" {
    cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "subnet" {
    vpc_id            = aws_vpc.main.id
    cidr_block        = "10.0.1.0/24"
    availability_zone = "eu-central-1a"
}

resource "aws_instance" "web" {
    ami           = "ami-0ff8a91507f77f867"
    instance_type = "t3.micro"
    subnet_id     = aws_subnet.subnet.id
}
</code></pre>

        <li>Terraform will automatically create:
            <ul>
                <li>VPC</li>
                <li>Subnet inside that VPC</li>
                <li>EC2 inside that subnet</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-variable-block">Understanding the <code>variable</code> Block in Terraform</h3>
<ol>

    <li>What Is a <code>variable</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>variable</code> block defines an input variable that you can pass into a Terraform module or configuration.</li>
        <br/>
        <li>Input variables allow your Terraform code to be:
            <ul>
                <li>reusable</li>
                <li>parameterized</li>
                <li>dynamic for multiple environments</li>
                <li>clean and maintainable</li>
            </ul>
        </li>
        <br/>
        <li>Variables are evaluated at runtime and can be supplied from:
            <ul>
                <li><code>terraform.tfvars</code></li>
                <li><code>*.auto.tfvars</code></li>
                <li>CLI flags (<code>-var</code>)</li>
                <li>environment variables</li>
                <li>Terraform Cloud variables</li>
                <li>module input parameters</li>
            </ul>
        </li>
        <br/>
        <li>Every variable must be declared using a <code>variable</code> block.</li>
    </ul>
    <br/><br/>


    <li>Basic Structure of a <code>variable</code> Block</li>
    <br/>
    <ul>
        <li>General syntax:</li>
<pre><code class="language-hcl line-numbers">variable "NAME" {
    type        = TYPE
    default     = VALUE
    description = "Human-readable text"
    sensitive   = BOOLEAN
}
</code></pre>
        <li>All attributes inside the block are optional except the variable name.</li>
    </ul>
    <br/><br/>


    <li>Example: A Simple String Variable</li>
    <ul>
<pre><code class="language-hcl line-numbers">variable "region" {
    type        = string
    default     = "eu-central-1"
    description = "AWS region where resources will be created."
}
</code></pre>
        <li>Here:</li>
        <ul>
            <li><code>type</code> → string</li>
            <li><code>default</code> → optional fallback value</li>
            <li><code>description</code> → optional but recommended</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Supported Variable Types</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>string</code></td>
                <td>Text value</td>
                <td><code>"hello"</code></td>
            </tr>
            <tr>
                <td><code>number</code></td>
                <td>Numeric value</td>
                <td><code>42</code></td>
            </tr>
            <tr>
                <td><code>bool</code></td>
                <td>true / false</td>
                <td><code>true</code></td>
            </tr>
            <tr>
                <td><code>list(type)</code></td>
                <td>Ordered list</td>
                <td><code>["a", "b"]</code></td>
            </tr>
            <tr>
                <td><code>map(type)</code></td>
                <td>Key-value map</td>
                <td><code>{ env = "prod" }</code></td>
            </tr>
            <tr>
                <td><code>set(type)</code></td>
                <td>Unique unordered list</td>
                <td><code>set(["a", "b"])</code></td>
            </tr>
            <tr>
                <td><code>object({})</code></td>
                <td>Structured key/value object</td>
                <td><code>{ name = string, size = number }</code></td>
            </tr>
            <tr>
                <td><code>tuple([])</code></td>
                <td>Fixed-length list of various types</td>
                <td><code>[string, number]</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li>Example: List Variable</li>
<pre><code class="language-hcl line-numbers">variable "availability_zones" {
    type = list(string)
    default = ["eu-central-1a", "eu-central-1b"]
}
</code></pre>
    <ul>
        <li>Usage:</li>
    </ul>
<pre><code class="language-hcl line-numbers">subnet_id = var.availability_zones[0]
</code></pre>
    <br/><br/>


    <li>Example: Map Variable</li>
<pre><code class="language-hcl line-numbers">variable "instance_tags" {
    type = map(string)
    default = {
        project = "terraform-demo"
        owner   = "junzhe"
    }
}
</code></pre>

    <ul>
        <li>Usage:</li>
    </ul>
<pre><code class="language-hcl line-numbers">tags = var.instance_tags
</code></pre>
    <br/><br/>


    <li>Example: Object Variable</li>
<pre><code class="language-hcl line-numbers">variable "server_config" {
    type = object({
        size = string
        count = number
        tags = map(string)
    })
}
</code></pre>

    <ul>
        <li>Usage:</li>
    </ul>
<pre><code class="language-hcl line-numbers">instance_type = var.server_config.size
tags          = var.server_config.tags
</code></pre>
    <br/><br/>


    <li>Using Variables in a Configuration</li>
    <br/>
    <ul>
        <li>Reference variables via <code>var.NAME</code>:</li>
    </ul>
<pre><code class="language-hcl line-numbers">provider "aws" {
    region = var.region
}
</code></pre>

    <ul>
        <li>Variables are always prefixed with <code>var.</code>.</li>
    </ul>
    <br/><br/>


    <li>You can set variable values from many sources</li>
    <br/>
    <ul>
        <li>1. <code>terraform.tfvars</code></li>
<pre><code class="language-hcl line-numbers">region = "us-east-1"
</code></pre>

        <br/>
        <li>2. Auto-loaded files: <code>anything.auto.tfvars</code></li>
        <br/>

        <li>3. CLI flags (<code>-var</code>)</li>
<pre><code class="language-bash line-numbers">terraform apply -var="region=us-east-1"
</code></pre>
        <br/>

        <li>4. Variable files (<code>-var-file</code>)</li>
<pre><code class="language-bash line-numbers">terraform apply -var-file="production.tfvars"
</code></pre>
        <br/>

        <li>5. Environment variables</li>
<pre><code class="language-bash line-numbers">export TF_VAR_region=us-east-1
</code></pre>
    </ul>
    <br/><br/>


    <li>Sensitive Variables</li>
    <br/>
    <ul>
        <li>To hide variable values in CLI output, use:</li>
<pre><code class="language-hcl line-numbers">variable "db_password" {
    type      = string
    sensitive = true
}
</code></pre>

        <li>Terraform will:
            <ul>
                <li>avoid printing sensitive values in terminal</li>
                <li>mask outputs</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Default Values</li>
    <br/>
    <ul>
        <li>A variable without a default is <b>required</b>.</li>
        <br/>

        <li>Example required variable:</li>
<pre><code class="language-hcl line-numbers">variable "project_id" {
    type = string
}
</code></pre>

        <li>If you don't supply <code>project_id</code>, <code>terraform plan</code> will ask for it.</li>
    </ul>
    <br/><br/>


    <li>Validation Rules</li>
    <br/>
    <ul>
        <li>Terraform allows validation inside a variable block:</li>
<pre><code class="language-hcl line-numbers">variable "env" {
    type = string

    validation {
        condition     = contains(["dev", "prod"], var.env)
        error_message = "env must be either 'dev' or 'prod'"
    }
}
</code></pre>

        <li>This ensures correct input values.</li>
    </ul>
    <br/><br/>


    <li>Complete Example</li>
<pre><code class="language-hcl line-numbers">variable "region" {
    type        = string
    default     = "eu-central-1"
    description = "The AWS region"
}

variable "tags" {
    type = map(string)
    default = {
        project = "demo"
        owner   = "junzhe"
    }
}

resource "aws_s3_bucket" "example" {
    bucket = "my-demo-bucket"
    tags   = var.tags
}

provider "aws" {
    region = var.region
}
</code></pre>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-output-block">Understanding the <code>output</code> Block in Terraform</h3>
<ol>

    <li>What Is an <code>output</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>output</code> block defines values that are displayed after <code>terraform apply</code> and can be used by:
            <ul>
                <li>the end user</li>
                <li>scripts</li>
                <li>other Terraform modules</li>
            </ul>
        </li>
        <br/>
        <li>Outputs are useful for showing:
            <ul>
                <li>IP addresses</li>
                <li>URLs</li>
                <li>resource IDs</li>
                <li>credentials</li>
                <li>any useful computed value</li>
            </ul>
        </li>
        <br/>
        <li>Outputs reflect data stored in the <b>Terraform state</b>, not live API calls.</li>
    </ul>
    <br/><br/>


    <li>Basic Structure of an <code>output</code> Block</li>
<pre><code class="language-hcl line-numbers">output "NAME" {
    value       = EXPRESSION
    description = "Human-readable text"
    sensitive   = BOOLEAN
}
</code></pre>
    <ul>
        <li>Only <code>value</code> is required.</li>
    </ul>
    <br/><br/>


    <li>Example: Simple Output</li>
<pre><code class="language-hcl line-numbers">output "bucket_name" {
    value = aws_s3_bucket.my_bucket.id
}
</code></pre>
        <ul>
        <li>Usage: after <code>terraform apply</code>, Terraform prints:</li>
        </ul>
<pre><code class="language-plaintext line-numbers">
bucket_name = "my-bucket-123"
</code></pre>
    </ul>
    <br/><br/>


    <li>When Are Outputs Shown?</li>
    <br/>
    <ul>
        <li>Outputs display only after <code>terraform apply</code> or <code>terraform output</code></li>
        <br/>

        <li>Example:</li>
<pre><code class="language-bash line-numbers">terraform output bucket_name</code></pre>

        <br/>

        <li>Terraform stores outputs in the state file.</li>
    </ul>
    <br/><br/>


    <li>The <code>value</code> Argument</li>
    <br/>
    <ul>
        <li>Accepts any Terraform expression:</li>
        <ul>
            <li>resource attributes</li>
            <li>variables</li>
            <li>functions</li>
            <li>maps / lists</li>
        </ul>

        <br/>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">output "instance_url" {
    value = "https://${aws_instance.web.public_ip}"
}
</code></pre>
        <br/>
        <li>Output will look like:</li>
<pre><code class="language-plaintext line-numbers">instance_url = "https://54.23.111.20"
</code></pre>
    </ul>
    <br/><br/>


    <li>Marking Outputs as Sensitive</li>
    <br/>
    <ul>
        <li>Prevent them from appearing in CLI output:</li>
<pre><code class="language-hcl line-numbers">output "db_password" {
    value     = random_password.db.result
    sensitive = true
}
</code></pre>
        <li>CLI output becomes masked:</li>
<pre><code class="language-plaintext line-numbers">db_password = (sensitive value)
</code></pre>
        <li>This prevents accidental exposure in CI/CD logs.</li>
    </ul>
    <br/><br/>


    <li>Using <code>output</code> in Modules</li>
    <br/>
    <ul>
        <li>Outputs from a child module can be referenced by the parent module.</li>
        <br/>

        <li>Child module (<code>modules/network/outputs.tf</code>):</li>
<pre><code class="language-hcl line-numbers">output "vpc_id" {
    value = aws_vpc.main.id
}
</code></pre>

        <li>Parent module:</li>
<pre><code class="language-hcl line-numbers">module "network" {
    source = "./modules/network"
}

resource "aws_subnet" "example" {
    vpc_id = module.network.vpc_id
}
</code></pre>
        <li><code>module.network.vpc_id</code> references the child’s output.</li>
    </ul>
    <br/><br/>


    <li>Using Outputs for Cross-Project Sharing</li>
    <br/>
    <ul>
        <li>Terraform Cloud and some CI setups allow one workspace’s outputs to feed another workspace.</li>
        <br/>
        <li>Example use case:</li>
        <ul>
            <li>Network workspace outputs VPC ID</li>
            <li>Compute workspace uses that VPC ID as input</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Output Format Options: <code>terraform output</code></li>
    <br/>
    <ul>
        <li>Show all outputs:</li>
<pre><code class="language-bash line-numbers">terraform output</code></pre>
        <li>Show one output:</li>
<pre><code class="language-bash line-numbers">terraform output vpc_id</code></pre>
        <li>Show output in JSON (useful for scripts):</li>
<pre><code class="language-bash line-numbers">terraform output -json</code></pre>
        <li>JSON output enables automation with tools such as Ansible, Bash, Python, etc.</li>
    </ul>
    <br/><br/>


    <li>Complex Output Values</li>
    <br/>
    <ul>
        <li>You can output maps, lists, and objects.</li>
        <br/>

        <li>Example 1: List</li>
<pre><code class="language-hcl line-numbers">output "azs" {
    value = var.availability_zones
}
</code></pre>

        <li>Example 2: Map</li>
<pre><code class="language-hcl line-numbers">output "instance_endpoints" {
    value = {
        app  = aws_instance.app.public_ip
        db   = aws_instance.db.private_ip
    }
}
</code></pre>

        <li>Example 3: Object</li>
<pre><code class="language-hcl line-numbers">output "info" {
    value = {
        id   = aws_instance.web.id
        name = aws_instance.web.tags["Name"]
        url  = "https://${aws_instance.web.public_ip}"
    }
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Conditional Outputs</li>
<pre><code class="language-hcl line-numbers">output "endpoint" {
    value = var.is_prod
        ? aws_lb.prod_lb.dns_name
        : aws_lb.dev_lb.dns_name
}
</code></pre>
    <ul>
        <li>You can dynamically output different values depending on environment variables.</li>
    </ul>
    <br/><br/>


    <li>Complete Example</li>
<pre><code class="language-hcl line-numbers">resource "aws_instance" "web" {
    ami           = "ami-0ff8a91507f77f867"
    instance_type = "t3.micro"
}

output "public_ip" {
    value       = aws_instance.web.public_ip
    description = "The public IP of the web server"
}

output "ssh_command" {
    value = "ssh ec2-user@${aws_instance.web.public_ip}"
}
</code></pre>

    <ul>
        <li>Example output:</li>
    </ul>
<pre><code class="language-plaintext line-numbers">public_ip = "54.22.13.91"
ssh_command = "ssh ec2-user@54.22.13.91"
</code></pre>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-locals-block">Understanding the <code>locals</code> Block in Terraform</h3>
<ol>

    <li>What Is a <code>locals</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>locals</code> block defines <b>local values</b> — named expressions that behave like constants inside a Terraform module.</li>
        <br/>
        <li>Locals help you:</li>
        <ul>
            <li>avoid repeating long or complex expressions</li>
            <li>keep configuration clean and readable</li>
            <li>group transformation logic in one place</li>
            <li>compute values dynamically</li>
        </ul>
        <br/>
        <li>Local values cannot be passed from outside the module and cannot be overridden.</li>
        <br/>
        <li>They exist only within the module they're declared in.</li>
    </ul>
    <br/><br/>


    <li>Basic Structure of a <code>locals</code> Block</li>
<pre><code class="language-hcl line-numbers">locals {
    NAME = EXPRESSION
    NAME2 = EXPRESSION
}
</code></pre>
    <ul>
        <li>A module can contain multiple <code>locals</code> blocks; Terraform merges them.</li>
        <br/>
        <li>Define as many locals as you want inside the block.</li>
    </ul>
    <br/><br/>


    <li>Referencing Local Values</li>
    <br/>
    <ul>
        <li>Use the <code>local.</code> prefix:</li>
<pre><code class="language-hcl line-numbers">local.NAME
</code></pre>

        <li>Example:</li>
<pre><code class="language-hcl line-numbers">locals {
    region = "eu-central-1"
}

provider "aws" {
    region = local.region
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Example: Avoiding Duplication</li>
<pre><code class="language-hcl line-numbers">
locals {
  common_tags = {
    project = "demo"
    owner   = "junzhe"
  }
}

resource "aws_s3_bucket" "bucket1" {
  bucket = "bucket-one"
  tags   = local.common_tags
}

resource "aws_s3_bucket" "bucket2" {
  bucket = "bucket-two"
  tags   = local.common_tags
}
</code></pre>

    <ul>
        <li>The same tag structure is reused with consistency.</li>
    </ul>
    <br/><br/>


    <li>Local Values Can Use Expressions</li>
    <br/>
    <ul>
        <li>Locals can compute values dynamically.</li>

<pre><code class="language-hcl line-numbers">locals {
    full_name = "${var.env}-${var.app_name}-${terraform.workspace}"
}
</code></pre>

        <li>Usage:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "app" {
    bucket = local.full_name
}
</code></pre>

        <li>This produces predictable naming conventions.</li>
    </ul>
    <br/><br/>


    <li>Example: Complex Expression</li>
    <br/>
    <ul>
        <li>Compute local values based on logic:</li>
<pre><code class="language-hcl line-numbers">locals {
    is_prod = var.env == "prod"
    instance_type = local.is_prod ? "t3.medium" : "t3.micro"
}
</code></pre>

        <li>This allows declarative environment-based logic.</li>
    </ul>
    <br/><br/>


    <li>Locals with Maps</li>
<pre><code class="language-hcl line-numbers">locals {
    app_ports = {
        http = 80
        https = 443
        metrics = 9100
    }
}

output "http_port" {
    value = local.app_ports["http"]
}
</code></pre>

    <ul>
        <li>Locals help group structured data.</li>
    </ul>
    <br/><br/>


    <li>Locals with Lists</li>
<pre><code class="language-hcl line-numbers">locals {
    zones = [
        "${var.region}a",
        "${var.region}b",
        "${var.region}c"
    ]
}

resource "aws_subnet" "subnet1" {
    availability_zone = local.zones[0]
}
</code></pre>

    <ul>
        <li>Local lists simplify multi-AZ deployments.</li>
    </ul>
    <br/><br/>


    <li>Locals with Resource References</li>
    <br/>
    <ul>
        <li>Locals can include resource attributes:</li>
<pre><code class="language-hcl line-numbers">locals {
    web_url = "http://${aws_instance.web.public_ip}"
}
</code></pre>

        <li>Becomes a reusable reference:</li>
<pre><code class="language-hcl line-numbers">output "website" {
    value = local.web_url
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Example: Combining Map + Logic</li>
<pre><code class="language-hcl line-numbers">
locals {
    configs = {
        dev = { instance = "t3.micro", count = 1 }
        prod = { instance = "t3.large", count = 3 }
    }

    active_config = local.configs[var.env]
}
</code></pre>

    <ul>
        <li>Usage:</li>
    </ul>
<pre><code class="language-hcl line-numbers">resource "aws_instance" "web" {
    instance_type = local.active_config.instance
    count         = local.active_config.count
}
</code></pre>

    <ul>
        <li>This pattern is extremely common in production modules.</li>
    </ul>
    <br/><br/>


    <li>Using Multiple <code>locals</code> Blocks</li>
    <br/>
    <ul>
        <li>You can declare locals in separate files or separate blocks:</li>
<pre><code class="language-hcl line-numbers">locals {
    project = "demo"
}

locals {
    region = "eu-central-1"
}
</code></pre>
        <li>Terraform merges them into a single <code>local</code> namespace.</li>
    </ul>
    <br/><br/>


    <li>Complete Practical Example</li>
<pre><code class="language-hcl line-numbers">variable "env" {
    type    = string
    default = "dev"
}

locals {
    common_tags = {
        project = "terraform-demo"
        owner   = "junzhe"
    }

    full_name = "${var.env}-webserver"
}

resource "aws_instance" "web" {
    ami           = "ami-0ff8a91507f77f867"
    instance_type = "t3.micro"
    tags          = local.common_tags
}

output "name" {
    value = local.full_name
}
</code></pre>

    <ul>
        <li>Locals improve readability, reduce duplication, and centralize logic.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-import-block">Understanding the <code>import</code> Block in Terraform</h3>
<ol>

    <li>What Is the <code>import</code> Block?</li>
    <br/>
    <ul>
        <li>The <code>import</code> block is used to <b>bring existing infrastructure resources</b> (created outside Terraform) under Terraform’s management.</li>
        <br/>
        <li>This allows Terraform to “adopt” a resource instead of recreating it.</li>
    </ul>
    <br/><br/>


    <li>Basic Structure of an <code>import</code> Block</li>
<pre><code class="language-hcl line-numbers">import {
    to = RESOURCE_ADDRESS
    id = PROVIDER_RESOURCE_ID
}
</code></pre>
    <ul>
        <li><code>to</code>: the Terraform resource to map to (must already exist in code)</li>
        <li><code>id</code>: the resource identifier from the cloud provider</li>
    </ul>
    <br/><br/>


    <li>Example: Importing an AWS S3 Bucket</li>
    <br/>
    <ul>
        <li>Terraform resource declared:</li>
<pre><code class="language-hcl line-numbers">resource "aws_s3_bucket" "my_bucket" {}
</code></pre>

        <li>Add an <code>import</code> block:</li>
<pre><code class="language-hcl line-numbers">import {
    to = aws_s3_bucket.my_bucket
    id = "my-existing-bucket"
}
</code></pre>

        <li>Explanation:</li>
        <ul>
            <li><code>aws_s3_bucket.my_bucket</code> → the Terraform resource to link</li>
            <li><code>my-existing-bucket</code> → the name of the actual S3 bucket</li>
        </ul>

        <br/>
        <li>Now run:</li>
<pre><code class="language-bash line-numbers">terraform plan</code></pre>

        <li>Terraform will import the bucket state automatically during <code>apply</code>.</li>
    </ul>
    <br/><br/>


    <li>Full Lifecycle of Import Using the <code>import</code> Block</li>
    <br/>
    <ul>
        <li>Step 1 — Write the <code>resource</code> block:</li>
<pre><code class="language-hcl line-numbers">resource "aws_security_group" "web" {}
</code></pre>

    <li>Step 2 — Add the <code>import</code> block:</li>
<pre><code class="language-hcl line-numbers">import {
    to = aws_security_group.web
    id = "sg-0a1b2c3d4e5f6g7h"
}
</code></pre>

        <li>Step 3 — run:</li>
<pre><code class="language-bash line-numbers">terraform apply</code></pre>

        <li>Terraform imports the SG and writes its state locally.</li>
    </ul>
    <br/><br/>


    <li>Using Terraform to Generate Configuration After Import</li>
    <br/>
    <ul>
        <li>You can ask Terraform to generate resource configuration after import:</li>
<pre><code class="language-bash line-numbers">terraform plan -generate-config-out=generated.tf
</code></pre>

        <li>This creates a file that contains the attributes of the imported resource.</li>
        <br/>
        <li>Useful when importing large or complex resources.</li>
    </ul>
    <br/><br/>


    <li>How Import Works Internally</li>
    <br/>
    <ul>
        <li>Terraform does NOT modify the real resource.</li>
        <br/>
        <li>It simply reads the resource from the provider (AWS, Azure, GCP, etc.) and writes it to <code>terraform.tfstate</code>.</li>
        <br/>
        <li>After import:
            <ul>
                <li>Terraform manages the resource</li>
                <li>Updates are made via Terraform</li>
                <li>Destruction happens via Terraform</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Importing Multiple Resources</li>
<pre><code class="language-hcl line-numbers">import {
    to = aws_iam_role.app_role
    id = "my-app-role"
}

import {
    to = aws_iam_policy.read_policy
    id = "arn:aws:iam::123456789012:policy/ReadPolicy"
}

import {
    to = aws_s3_bucket.data
    id = "data-bucket"
}
</code></pre>

    <ul>
        <li>Terraform will import all during <code>apply</code>.</li>
    </ul>
    <br/><br/>


    <li>Importing Nested or Child Resources</li>
    <br/>
    <ul>
        <li>If a resource exists inside a module:</li>
    </ul>
<pre><code class="language-hcl line-numbers">module "network" {
    source = "./network"
}

import {
    to = module.network.aws_vpc.main
    id = "vpc-123456"
}
</code></pre>

    <ul>
        <li>Terraform supports importing resources inside modules using full resource addresses.</li>
    </ul>
    <br/><br/>


    <li>Example: Importing an Azure Resource</li>
<pre><code class="language-hcl line-numbers">resource "azurerm_resource_group" "main" {
    name = "rg-demo"
    location = "westeurope"
}

import {
    to = azurerm_resource_group.main
    id = "/subscriptions/xxx/resourceGroups/rg-demo"
}
</code></pre>
    <br/><br/>


    <li>Reference: Full Syntax Options</li>
<pre><code class="language-hcl line-numbers">import {
    to         = RESOURCE_ADDRESS
    id         = IDENTIFIER
    provider   = PROVIDER_ALIAS   # optional
}
</code></pre>
    <ul>
        <li><code>provider</code>: Only required when multiple provider aliases exist.</li>
    </ul>
    <br/><br/>


    <li>Common Import Errors</li>
    <ul>
        <br/>
        <li>Error: Resource does not exist</li>
        <ul><li>The provided <code>id</code> is wrong.</li></ul>

        <br/>
        <li>Error: Resource already managed</li>
        <ul><li>The resource is already in the Terraform state.</li></ul>

        <br/>
        <li>Error: Missing required argument</li>
        <ul><li>The resource block must exist before import.</li></ul>

        <br/>
        <li>Error: Provider mismatch</li>
        <ul><li>Check provider aliases and regions.</li></ul>
    </ul>
    <br/><br/>


    <li>Import vs Creating New Resources</li>
    <ul>
        <br/>
        <li>Create new resource:</li>
        <ul><li>Terraform builds the resource using the provider API.</li></ul>

        <br/>
        <li>Import existing resource:</li>
        <ul><li>Terraform only maps state → it does NOT modify the resource.</li></ul>

        <br/>
        <li>After import, Terraform treats the resource like it created it.</li>
    </ul>
    <br/><br/>


    <li>When Should You Use the <code>import</code> Block?</li>
    <br/>
    <ul>
        <li>You should use an import block when:</li>
        <ul>
            <li>you already have cloud infrastructure created manually</li>
            <li>you want to migrate legacy resources under Terraform</li>
            <li>a team member created a resource outside Terraform</li>
            <li>a CI/CD workflow needs reproducible imports</li>
        </ul>

        <br/>

        <li>Import blocks make Terraform ideal for gradual adoption of IaC.</li>
    </ul>
    <br/><br/>


    <li>Complete Practical Example</li>
    <br/>
    <ul>
        <li>Configuration:</li>
<pre><code class="language-hcl line-numbers">
resource "aws_iam_user" "admin" {}

import {
  to = aws_iam_user.admin
  id = "existing-admin-user"
}
</code></pre>
        <li>Run:</li>
<pre><code class="language-bash line-numbers">terraform apply</code></pre>
        <li>Terraform imports the IAM user into state automatically.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="terraform-module-block">Understanding the <code>module</code> Block in Terraform</h3>
<ol>
    <br/>
    <li>A <b>module</b> block is how you call or reuse Terraform configurations stored in another directory or registry.</li>
    <br/><br/>


    <li>Basic Structure of a <code>module</code> Block</li>
<pre><code class="language-hcl line-numbers">module "NAME" {
    source = "SOURCE_LOCATION"

    # input variables
    variable1 = VALUE
    variable2 = VALUE
}
</code></pre>
    <ul>
        <li>A module must always have a <code>source</code> argument.</li>
    </ul>
    <br/><br/>


    <li>Module Source Types</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Source Type</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>Local path</b></td>
                <td><code>./modules/vpc</code></td>
                <td>Call module stored locally</td>
            </tr>
            <tr>
                <td><b>Git Repository</b></td>
                <td><code>git::https://github.com/user/repo.git</code></td>
                <td>Load modules directly from Git</td>
            </tr>
            <tr>
                <td><b>Terraform Registry</b></td>
                <td><code>terraform-aws-modules/vpc/aws</code></td>
                <td>Official or community modules</td>
            </tr>
            <tr>
                <td><b>Private Registry</b></td>
                <td><code>app.terraform.io/org/module/aws</code></td>
                <td>Enterprise patterns</td>
            </tr>
            <tr>
                <td><b>HTTP URL</b></td>
                <td><code>https://example.com/module.zip</code></td>
                <td>Download module archive</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li>Example: Local Module</li>
<pre><code class="language-hcl line-numbers">module "network" {
    source = "./modules/network"

    cidr_block = "10.0.0.0/16"
    env        = var.env
}
</code></pre>

    <ul>
        <li>This loads files from:</li>
    </ul>
<pre><code class="language-plaintext line-numbers">modules/
    network/
        main.tf
        variables.tf
        outputs.tf
</code></pre>
    <br/><br/>


    <li>Example: Using a Public Registry Module</li>
<pre><code class="language-hcl line-numbers">module "vpc" {
    source  = "terraform-aws-modules/vpc/aws"
    version = "5.5.0"

    name = "demo"
    cidr = "10.0.0.0/16"
}
</code></pre>

    <ul>
        <li>Terraform automatically downloads and caches the module.</li>
    </ul>
    <br/><br/>


    <li>Passing Input Variables to a Module</li>
    <br/>
    <ul>
        <li>Modules accept input variables via attributes inside the block:</li>

<pre><code class="language-hcl line-numbers">
module "compute" {
    source = "./modules/compute"

    instance_count = 3
    instance_type  = "t3.micro"
}
</code></pre>

        <li>Inside the module, variables must be declared:</li>

<pre><code class="language-hcl line-numbers">variable "instance_count" { type = number }
variable "instance_type"  { type = string }
</code></pre>
    </ul>
    <br/><br/>


    <li>Consuming Module Outputs</li>
    <br/>
    <ul>
        <li>A module can expose outputs:</li>

<pre><code class="language-hcl line-numbers">output "vpc_id" {
    value = aws_vpc.main.id
}
</code></pre>

        <li>Parent module can access them:</li>

<pre><code class="language-hcl line-numbers">resource "aws_subnet" "subnet1" {
    vpc_id = module.vpc.vpc_id
}
</code></pre>

        <li>Modules behave exactly like objects with attributes.</li>
    </ul>
    <br/><br/>


    <li>Using Multiple Modules</li>
    <ul>
        <br/>
        <li>A real Terraform project may use many modules:</li>
    </ul>
<pre><code class="language-hcl line-numbers">module "network" { ... }
module "database" { ... }
module "frontend" { ... }
module "backend" { ... }
</code></pre>

    <ul>
        <li>Terraform keeps each module isolated and reusable.</li>
    </ul>
    <br/><br/>


    <li>Meta-Arguments in Modules</li>
    <br/>
    <ul>
        <li>Modules support these meta-arguments: <code>depends_on</code>, <code>count</code>, <code>for_each</code></li>

        <br/>

        <li>Example using <code>depends_on</code>:</li>
<pre><code class="language-hcl line-numbers">module "app" {
    source = "./modules/app"
    depends_on = [module.network]
}
</code></pre>

        <li>Example using <code>for_each</code>:</li>
<pre><code class="language-hcl line-numbers">module "bucket" {
    source = "./modules/s3"
    for_each = toset(["dev", "test", "prod"])

    env = each.key
}
</code></pre>

        <li>Modules become fully programmable like resources.</li>
    </ul>
    <br/><br/>


    <li>Versioning Modules</li>
<pre><code class="language-hcl line-numbers">module "vpc" {
    source  = "terraform-aws-modules/vpc/aws"
    version = "~&gt; 5.5"
}
</code></pre>

    <ul>
        <li>Use semantic versioning to control upgrades.</li>
    </ul>
    <br/><br/>


    <li>Complete Real-World Example</li>
    <br/>
    <ul>
        <li>Main project:</li>
    </ul>

<pre><code class="language-hcl line-numbers">module "network" {
    source  = "./modules/network"
    cidr    = "10.0.0.0/16"
}

module "compute" {
    source        = "./modules/compute"
    subnet_ids    = module.network.subnet_ids
    instance_type = "t3.micro"
    count         = 2
}

output "instance_ips" {
    value = module.compute.instance_ips
}
</code></pre>

    <ul>
        <li>This structure keeps the project scalable and clean.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
