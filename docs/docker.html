<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Docker</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/docker.png" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ol style="line-height: 1.8;">
        <li><a href="#docker-overview">Overview</a></li>
        <li><a href="#docker-hub">Hub</a></li>
        <li><a href="#docker-images">Images</a></li>
        <li><a href="#docker-containers">Containers</a></li>
        <li><a href="#docker-dockerfile-anatomy">Dockerfile Anatomy</a></li>
        <li><a href="#docker-commands-intro">Introduction to Docker Commands</a></li>
        <li><a href="#docker-run-command">Understanding the <code>docker run</code> Command</a></li>
        <li><a href="#docker-start-command">Understanding the <code>docker start</code> Command</a></li>
        <li><a href="#docker-stop-command">Understanding the <code>docker stop</code> Command</a></li>
        <li><a href="#docker-restart-command">Understanding the <code>docker restart</code> Command</a></li>
        <li><a href="#docker-exec-command">Understanding the <code>docker exec</code> Command</a></li>
        <li><a href="#docker-logs-command">Understanding the <code>docker logs</code> Command</a></li>
        <li><a href="#docker-build-command">Understanding the <code>docker build</code> Command</a></li>
        <li><a href="#docker-pull-command">Understanding the <code>docker pull</code> Command</a></li>
        <li><a href="#docker-push-command">Understanding the <code>docker push</code> Command</a></li>
        <li><a href="#docker-volume-command">Understanding the <code>docker volume</code> Command</a></li>
        <li><a href="#docker-network-command">Understanding the <code>docker network</code> Command</a></li>
        <li><a href="#docker-daemon-overview">Understanding the Docker Daemon</a></li>
        <li><a href="#docker-compose-command">Understanding the <code>docker compose</code> Command</a></li>
        <li><a href="#docker-compose-yml">How to Write a <code>docker-compose.yml</code> File?</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-overview">Docker Overview</h3>
<ol>

    <li>What Is Docker?</li>
    <br/>
    <ul>
        <li><b>Docker</b> is a platform that allows developers to package, ship, and run applications inside <b>containers</b>.</li>
        <br/>
        <li>A container includes everything an application needs:</li>
        <ul>
            <li>source code</li>
            <li>runtime (Python, Node.js, Java, etc.)</li>
            <li>system tools</li>
            <li>libraries &amp; dependencies</li>
            <li>configuration</li>
        </ul>
        <br/>
        <li>Containers let your app run consistently across different machines:</li>
        <ul>
            <li>developer laptops</li>
            <li>CI/CD servers</li>
            <li>development/production servers</li>
            <li>cloud platforms</li>
        </ul>
        <br/>
        <li>Think of Docker as “lightweight virtual machines” that start in milliseconds and use very little overhead.</li>
    </ul>
    <br/><br/>


    <li>Why Use Docker?</li>
    <br/>
    <ul>
        <li>Docker solves the infamous:</li>
<pre><code class="language-plaintext line-numbers">"It works on my machine" problem</code></pre>
        <br/>
        <li>Docker has become the standard for building and deploying modern applications.</li>
    </ul>
    <br/><br/>


    <li>Understanding Images vs Containers</li>
    <br/>
    <ul>
        <li><b>Docker Image</b>:</li>
        <ul>
            <li>a read-only template that defines a container</li>
            <li>contains your app + dependencies</li>
            <li>built using a <code>Dockerfile</code></li>
        </ul>
        <br/>
        <li><b>Docker Container</b>:</li>
        <ul>
            <li>a running instance of an image</li>
            <li>you can run many containers from one image</li>
            <li>containers can be started, stopped, removed</li>
        </ul>
        <br/>
        <li>Analogy:</li>
<pre><code class="language-plaintext line-numbers">Image = class
Container = object created from that class
</code></pre>
    </ul>
    <br/><br/>


    <li>What Is a Dockerfile?</li>
    <br/>
    <ul>
        <li>A <code>Dockerfile</code> is a text file with instructions on how to build a Docker image.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-docker line-numbers">FROM python:3.12-alpine
COPY app.py /app.py
CMD ["python", "app.py"]
</code></pre>
        <br/>
        <li>Every line creates a new layer in the final Docker image.</li>
    </ul>
    <br/><br/>


    <li>Basic Docker Commands</li>
    <br/>
    <ul>
        <li>Pull an image:</li>
<pre><code class="language-bash line-numbers">docker pull python:3.12</code></pre>
        <br/>
        <li>List images:</li>
<pre><code class="language-bash line-numbers">docker images</code></pre>
        <br/>
        <li>Run a container:</li>
<pre><code class="language-bash line-numbers">docker run python:3.12</code></pre>
        <br/>
        <li>List running containers:</li>
<pre><code class="language-bash line-numbers">docker ps</code></pre>
        <br/>
        <li>Stop a container:</li>
<pre><code class="language-bash line-numbers">docker stop &lt;container_id&gt;</code></pre>
        </br>
        <li>Remove a container:</li>
<pre><code class="language-bash line-numbers">docker rm &lt;container_id&gt;</code></pre>
        <br/>
        <li>Build a Docker image:</li>
<pre><code class="language-bash line-numbers">docker build -t myapp .</code></pre>
    </ul>
    <br/><br/>


    <li>Layered Architecture of Docker</li>
    <br/>
    <ul>
        <li>Docker images are composed of layers:</li>
        <ul>
            <li>each command in <code>Dockerfile</code> creates a layer</li>
            <li>layers are cached → faster builds</li>
            <li>shared layers reduce storage usage</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-plaintext line-numbers">FROM python
COPY . /app
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
</code></pre>
        <br/>
        <li>Changing the last line only rebuilds the last layer → faster development.</li>
    </ul>
    <br/><br/>


    <li>Bind Mounts vs Volumes</li>
    <br/>
    <ul>
        <li>Two ways to persist or share data:</li>
        <br/>
        <li><b>Bind Mounts</b>:</li>
        <ul>
            <li>directly map a folder on your host into the container</li>
            <li>good for development</li>
        </ul>
<pre><code class="language-bash line-numbers">docker run -v $(pwd):/app myapp</code></pre>
        <br/>
        <li><b>Volumes</b>:</li>
        <ul>
            <li>managed by Docker</li>
            <li>best for databases and production</li>
        </ul>
<pre><code class="language-bash line-numbers">docker volume create mydata</code></pre>
    </ul>
    <br/><br/>


    <li>Docker Compose Overview</li>
    <br/>
    <ul>
        <li><b>Docker Compose</b> is a tool for defining and running multi-container applications.</li>
        <br/>
        <li>Useful for apps needing:</li>
        <ul>
            <li>web server</li>
            <li>database</li>
            <li>cache</li>
            <li>background workers</li>
        </ul>
        <br/>
        <li>Example <code>docker-compose.yml</code>:</li>
<pre><code class="language-yaml line-numbers">version: "3"
services:
  web:
    build: .
    ports:
      - "5000:5000"
  db:
    image: postgres:16
</code></pre>
        <br/>
        <li>Start everything:</li>
<pre><code class="language-bash line-numbers">docker compose up</code></pre>
    </ul>
    <br/><br/>


    <li>Docker Hub</li>
    <br/>
    <ul>
        <li><b>Docker Hub</b> is a cloud registry that hosts container images.</li>
        <br/>
        <li>You can:</li>
        <ul>
            <li>pull thousands of official images</li>
            <li>push your own images</li>
            <li>share with teams or make them public</li>
        </ul>
        <br/>
        <li>Push an image:</li>
<pre><code class="language-bash line-numbers">docker push username/myapp</code></pre>
    </ul>
    <br/><br/>


    <li>Docker in Production</li>
    <br/>
    <ul>
        <li>Docker containers are widely used in production because:</li>
        <ul>
            <li>fast deployment</li>
            <li>easy rollbacks</li>
            <li>isolated environments</li>
            <li>consistent builds</li>
        </ul>
        <br/>
        <li>Often combined with:</li>
        <ul>
            <li>NGINX</li>
            <li>reverse proxies</li>
            <li>Kubernetes orchestration</li>
            <li>cloud services (AWS ECS, Azure ACI, Google Cloud Run)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Best Practices</li>
    <br/>
    <ul>
        <li>Use small base images (e.g., <code>alpine</code>)</li>
        <br/>
        <li>Set <code>.dockerignore</code> to exclude unnecessary files</li>
        <br/>
        <li>Keep containers single-purpose (“one container = one process”)</li>
        <br/>
        <li>Use multi-stage builds to reduce final image size</li>
        <br/>
        <li>Use health checks for monitoring</li>
        <br/>
        <li>Tag images properly (<code>latest</code>, version numbers)</li>
        <br/>
        <li>Use docker-compose for development; orchestration tools for production</li>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-hub">Docker Hub</h3>
<ol>

    <li>What Is Docker Hub?</li>
    <br/>
    <ul>
        <li><b>Docker Hub</b> is the official cloud-based registry service provided by Docker.</li>
        <br/>
        <li>It is used to:</li>
        <ul>
            <li>store Docker images</li>
            <li>share images publicly or privately</li>
            <li>distribute images for development and production</li>
            <li>automate image builds</li>
            <li>pull ready-to-use software images (databases, languages, tools)</li>
        </ul>
        <br/>
        <li>Docker Hub is the default registry used when you run:</li>
<pre><code class="language-bash line-numbers">docker pull ubuntu</code></pre>
    </ul>
    <br/><br/>


    <li>Using Docker Hub Without Logging In</li>
    <br/>
    <ul>
        <li>You can pull images from Docker Hub without an account:</li>
<pre><code class="language-bash line-numbers">docker pull python:3.12
docker pull nginx
docker pull redis
</code></pre>
    </ul>
    <br/><br/>


    <li>Creating a Docker Hub Account</li>
    <br/>
    <ul>
        <li>You can create a free account to:</li>
        <ul>
            <li>push your images</li>
            <li>create private repositories</li>
            <li>configure automated builds</li>
            <li>manage collaborators</li>
        </ul>
        <br/>
        <li>Login from CLI:</li>
<pre><code class="language-bash line-numbers">docker login</code></pre>
    </ul>
    <br/><br/>


    <li>Pushing an Image to Docker Hub</li>
    <br/>
    <ul>
        <li>Step 1: Build your image locally</li>
<pre><code class="language-bash line-numbers">docker build -t myapp .
</code></pre>
        <br/>
        <li>Step 2: Tag the image with your Docker Hub username</li>
<pre><code class="language-bash line-numbers">docker tag myapp username/myapp:latest
</code></pre>
        <br/>
        <li>Step 3: Push to Docker Hub</li>
<pre><code class="language-bash line-numbers">docker push username/myapp:latest
</code></pre>
        <br/>
        <li>Now anyone (or only your team, if private) can pull it:</li>
<pre><code class="language-bash line-numbers">docker pull username/myapp:latest
</code></pre>
    </ul>
    <br/><br/>


    <li>Pulling Images from Docker Hub</li>
    <br/>
    <ul>
        <li>Basic usage:</li>
<pre><code class="language-bash line-numbers">docker pull ubuntu
docker pull node:22
docker pull redis:7-alpine
</code></pre>
        <br/>
        <li>Run immediately:</li>
<pre><code class="language-bash line-numbers">docker run -it ubuntu bash
</code></pre>
    </ul>
    <br/><br/>


    <li>Repositories and Tags</li>
    <br/>
    <ul>
        <li>A Docker Hub repository contains multiple versions of an image.</li>
        <br/>
        <li>Example: <code>python</code> repository tags:</li>
        <ul>
            <li><code>3.12</code></li>
            <li><code>3.11-slim</code></li>
            <li><code>3.12-alpine</code></li>
            <li><code>latest</code></li>
        </ul>
        <br/>
        <li>A tag identifies a specific variant of an image:</li>
<pre><code class="language-bash line-numbers">docker pull python:3.12
docker pull python:3.12-slim
docker pull python:alpine
</code></pre>
        <br/>
        <li>If you omit the tag:</li>
<pre><code class="language-bash line-numbers">docker pull python</code></pre>
        <li>You get the <code>latest</code> tag.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-images">Docker Images</h3>
<ol>
    <li>How Docker Images Work?</li>
    <br/>
    <ul>
        <li>Docker images are built in <b>layers</b>.</li>
        <br/>
        <li>Each instruction in a Dockerfile creates a new layer:</li>
<pre><code class="language-docker line-numbers">FROM ubuntu
RUN apt-get update
RUN apt-get install python3
COPY app.py /app/app.py
</code></pre>
        <br/>
        <li>Layers are cached → faster builds.</li>
        <br/>
        <li>If a layer does not change, Docker reuses it.</li>
    </ul>
    <br/><br/>


    <li>Base Images vs Child Images</li>
    <br/>
    <ul>
        <li>Base Image:</li>
        <ul>
            <li>an image that doesn't depend on any other image</li>
            <li>examples: <code>ubuntu</code>, <code>alpine</code>, <code>scratch</code>
            </li>
        </ul>
        <br/>
        <li>Child Image:</li>
        <ul>
            <li>an image built from another image using <code>FROM</code></li>
            <li>example:</li>
<pre><code class="language-docker line-numbers">FROM python:3.12</code></pre>
        </ul>
        <br/>
        <li>Most applications use child images.</li>
    </ul>
    <br/><br/>


    <li>Viewing Docker Images</li>
    <br/>
    <ul>
        <li>List all local images:</li>
<pre><code class="language-bash line-numbers">docker images</code></pre>
        <br/>
        <li>Remove an image:</li>
<pre><code class="language-bash line-numbers">docker rmi image_id</code></pre>
        <br/>
        <li>Inspect image metadata:</li>
<pre><code class="language-bash line-numbers">docker inspect image_id</code></pre>
        <br/>
        <li>Show image history (layers):</li>
<pre><code class="language-bash line-numbers">docker history image_id</code></pre>
    </ul>
    <br/><br/>


    <li>Building Docker Images</li>
    <br/>
    <ul>
        <li>Images are built from a <code>Dockerfile</code>.</li>
        <br/>
        <li>Basic build:</li>
<pre><code class="language-bash line-numbers">docker build -t &lt;name&gt; .</code></pre>
        <br/>
        <li><code>-t &lt;name&gt;</code> gives your image a name.</li>
        <br/>
        <li>Example <code>Dockerfile</code>:</li>
<pre><code class="language-docker line-numbers">FROM python:3.12-alpine
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "main.py"]
</code></pre>
    </ul>
    <br/><br/>


    <li>Tagging Docker Images</li>
    <br/>
    <ul>
        <li>An image can have multiple tags.</li>
        <br/>
        <li>Tags identify versions:</li>
<pre><code class="language-bash line-numbers">docker tag myapp myapp:v1
docker tag myapp username/myapp:latest
</code></pre>
        <br/>
        <li>Common tags:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Docker Image Tag</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>latest</code></td>
            <td>Default tag; points to the most recent stable image.</td>
        </tr>
        <tr>
            <td><code>1.0</code>, <code>2.3.4</code></td>
            <td>Specific version tags for consistent and reproducible builds.</td>
        </tr>
        <tr>
            <td><code>alpine</code></td>
            <td>Lightweight image variant based on Alpine Linux.</td>
        </tr>
        <tr>
            <td><code>slim</code></td>
            <td>Minimal-dependency image variant, smaller than the default.</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Pulling Docker Images</li>
    <br/>
    <ul>
        <li>Pull from Docker Hub:</li>
<pre><code class="language-bash line-numbers">docker pull python:3.12
docker pull node:20-slim
docker pull nginx:alpine
</code></pre>
        <br/>
        <li>Pull default (latest):</li>
<pre><code class="language-bash line-numbers">docker pull redis</code></pre>
    </ul>
    <br/><br/>


    <li>Running Containers from Images</li>
    <br/>
    <ul>
        <li>Every container is created from an image:</li>
<pre><code class="language-bash line-numbers">docker run -it ubuntu bash</code></pre>
        <li>The container runs as an isolated process based on the image’s filesystem.</li>
    </ul>
    <br/><br/>


    <li>Layered Filesystem Explained</li>
    <br/>
    <ul>
        <li>Images use a layered filesystem (UnionFS):</li>
        <ul>
            <li>Bottom layers = read-only</li>
            <li>Top layer (container) = writable</li>
        </ul>
        <br/>
        <li>This means:</li>
        <ul>
            <li>many containers share the same image layers</li>
            <li>saves disk space</li>
            <li>speeds up builds</li>
        </ul>
        <br/>
        <li>Example layer structure:</li>
<pre><code class="language-plaintext line-numbers">Layer 1: FROM python:3.12
Layer 2: WORKDIR /app
Layer 3: COPY . .
Layer 4: RUN pip install -r requirements.txt
Layer 5: CMD ["python", "main.py"]
</code></pre>
    </ul>
    <br/><br/>


    <li>Best Practices for Docker Images</li>
    <br/>
    <ul>
        <li>Use small base images like <code>alpine</code> when possible.</li>
        <br/>
        <li><code>Use .dockerignore</code> to exclude unnecessary files:</li>
<pre><code class="language-plaintext line-numbers">node_modules/
.git/
__pycache__/
</code></pre>
        <br/>
        <li>Keep layers minimal to reduce image size.</li>
        <br/>
        <li>Pin versions to ensure reproducible builds:</li>
<pre><code class="language-docker line-numbers">FROM node:20.9-slim</code></pre>
        <br/>
        <li>Use multi-stage builds for production apps.</li>
        <br/>
        <li>Do not store secrets (API keys, passwords) inside images.</li>
    </ul>
    <br/><br/>


    <li>Multi-Stage Builds (Advanced)</li>
    <br/>
    <ul>
        <li>Used to create small, optimized images.</li>
<pre><code class="language-docker line-numbers">FROM node:20 as builder
WORKDIR /app
COPY . .
RUN npm install &amp;&amp; npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
</code></pre>
        <br/>
        <li>Benefits:</li>
        <ul>
            <li>final image contains only what is needed to run</li>
            <li>build tools stay in the builder stage</li>
            <li>reduces size dramatically</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Summary</li>
    <br/>
    <ul>
        <li>Docker images are read-only templates used to create containers.</li>
        <br/>
        <li>They are built in layers, making them fast, efficient, and easy to reuse.</li>
        <br/>
        <li>Images are created from Dockerfiles and can be tagged, pushed, or pulled from Docker Hub.</li>
        <br/>
        <li>With best practices (small base images, multi-stage builds), images become more secure and efficient.</li>
    </ul>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-containers">Docker Containers</h3>
<ol>

    <li>What Are Docker Containers?</li>
    <br/>
    <ul>
        <li>A <b>Docker container</b> is a <b>running instance</b> of a Docker image.</li>
        <br/>
        <li>It provides:</li>
        <ul>
            <li>an isolated filesystem</li>
            <li>a lightweight runtime environment</li>
            <li>its own processes and network stack</li>
            <li>predictable behavior across machines</li>
        </ul>
        <br/>
        <li>Multiple containers can run from the same image.</li>
    </ul>
    <br/><br/>


    <li>Creating and Running Containers</li>
    <br/>
    <ul>
        <li>Basic container run:</li>
<pre><code class="language-bash line-numbers">docker run ubuntu</code></pre>
        <br/>
        <li>Run interactively:</li>
<pre><code class="language-bash line-numbers">docker run -it ubuntu bash</code></pre>
        <br/>
        <li>Run in detached mode (background):</li>
<pre><code class="language-bash line-numbers">docker run -d nginx</code></pre>
        <br/>
        <li>Run and map ports:</li>
<pre><code class="language-bash line-numbers">docker run -p 8080:80 nginx</code></pre>
        <br/>
        <li>Run with a name:</li>
<pre><code class="language-bash line-numbers">docker run --name mycontainer ubuntu</code></pre>
    </ul>
    <br/><br/>


    <li>Viewing and Managing Containers</li>
    <br/>
    <ul>
        <li>List running containers:</li>
<pre><code class="language-bash line-numbers">docker ps</code></pre>
        <br/>
        <li>List all containers (including stopped):</li>
<pre><code class="language-bash line-numbers">docker ps -a</code></pre>
        <br/>
        <li>Stop a container:</li>
<pre><code class="language-bash line-numbers">docker stop mycontainer</code></pre>
        <br/>
        <li>Start a container:</li>
<pre><code class="language-bash line-numbers">docker start mycontainer</code></pre>
        <br/>
        <li>Remove a container:</li>
<pre><code class="language-bash line-numbers">docker rm mycontainer</code></pre>
    </ul>
    <br/><br/>


    <li>Container File System</li>
    <br/>
    <ul>
        <li>Containers use a layered filesystem:</li>
        <ul>
            <li>Image layers = read-only</li>
            <li>Container layer = writable</li>
        </ul>
        <br/>
        <li>This means:</li>
        <ul>
            <li>modifications exist only inside that container</li>
            <li>destroying the container removes its write layer</li>
        </ul>
        <br/>
        <li>Inspect layers:</li>
<pre><code class="language-bash line-numbers">docker history myimage</code></pre>
    </ul>
    <br/><br/>


    <li>Executing Commands Inside Containers</li>
    <br/>
    <ul>
        <li>Run a command in a running container:</li>
<pre><code class="language-bash line-numbers">docker exec mycontainer ls</code></pre>
        <br/>
        <li>Start an interactive session:</li>
<pre><code class="language-bash line-numbers">docker exec -it mycontainer bash</code></pre>
    </ul>
    <br/><br/>


    <li>Container Networking</li>
    <br/>
    <ul>
        <li>Docker containers can communicate via built-in networks:</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Docker Network Mode</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>bridge</b></td>
            <td>Default network mode, containers get a private internal network and can communicate via virtual interfaces.</td>
        </tr>
        <tr>
            <td><b>host</b></td>
            <td>Shares the host's network stack, container ports map directly to the host's network without NAT.</td>
        </tr>
        <tr>
            <td><b>none</b></td>
            <td>Disables networking entirely, container has no network interfaces except loopback.</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>List networks:</li>
<pre><code class="language-bash line-numbers">docker network ls</code></pre>
        <br/>
        <li>Connect container to network:</li>
<pre><code class="language-bash line-numbers">docker network connect mynet mycontainer</code></pre>
    </ul>
    <br/><br/>


    <li>Container Volumes</li>
    <br/>
    <ul>
        <li>Containers lose data if destroyed (ephemeral).</li>
        <br/>
        <li>Use volumes for persistent data:</li>
<pre><code class="language-bash line-numbers">docker run -v myvolume:/data myimage</code></pre>
        <br/>
        <li>Types of storage:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Storage Type</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Volumes</b></td>
            <td>Managed entirely by Docker; stored in Docker’s internal storage location.</td>
        </tr>
        <tr>
            <td><b>Bind Mounts</b></td>
            <td>Maps a directory or file from the host filesystem directly into the container.</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>List volumes:</li>
<pre><code class="language-bash line-numbers">docker volume ls</code></pre>
    </ul>
    <br/><br/>


    <li>Container Lifecycle</li>
    <br/>
    <ul>
        <li>A container lifecycle includes:</li>
        <ul>
            <li>create</li>
            <li>start</li>
            <li>pause (optional)</li>
            <li>stop</li>
            <li>restart</li>
            <li>remove</li>
        </ul>
        <br/>
        <li>Lifecycle example:</li>
<pre><code class="language-bash line-numbers">docker create myimage
docker start container_id
docker stop container_id
docker rm container_id
</code></pre>
    </ul>
    <br/><br/>


    <li>Container Logs</li>
    <br/>
    <ul>
        <li>View logs:</li>
<pre><code class="language-bash line-numbers">docker logs mycontainer</code></pre>
        <br/>
        <li>Follow logs (like tail -f):</li>
<pre><code class="language-bash line-numbers">docker logs -f mycontainer</code></pre>
    </ul>
    <br/><br/>


    <li>Cleaning Up Containers</li>
    <br/>
    <ul>
        <li>Remove all stopped containers:</li>
<pre><code class="language-bash line-numbers">docker container prune</code></pre>
        <br/>
        <li>Remove everything (CAUTION):</li>
<pre><code class="language-bash line-numbers">docker system prune -a</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-dockerfile-anatomy">Dockerfile Anatomy</h3>
<ol>

    <li>What Is a Dockerfile?</li>
    <br/>
    <ul>
        <li>A <code>Dockerfile</code> is a plain-text script containing step-by-step instructions for building a Docker image.</li>
        <br/>
        <li>Each instruction creates a <b>new layer</b> in the final image.</li>
        <br/>
        <li>Build an image from a Dockerfile:</li>
<pre><code class="language-bash line-numbers">docker build -t myapp .</code></pre>
        <br/>
        <li>The Dockerfile must be named <code>Dockerfile</code> (default) unless you specify:</li>
<pre><code class="language-bash line-numbers">docker build -f CustomFile -t myapp .</code></pre>
    </ul>
    <br/><br/>


    <li>The Structure of a Dockerfile</li>
    <br/>
    <ul>
        <li>A <code>Dockerfile</code> is a sequence of instructions.</li>
        <br/>
        <li>Common instructions:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Instruction</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>FROM</code></td>
            <td>Specifies the base image.</td>
        </tr>
        <tr>
            <td><code>RUN</code></td>
            <td>Executes commands during the build process.</td>
        </tr>
        <tr>
            <td><code>COPY</code></td>
            <td>Copies files from the host into the image.</td>
        </tr>
        <tr>
            <td><code>ADD</code></td>
            <td>Like COPY but supports remote URLs and automatic extraction (use only when necessary).</td>
        </tr>
        <tr>
            <td><code>WORKDIR</code></td>
            <td>Sets the working directory for subsequent instructions.</td>
        </tr>
        <tr>
            <td><code>EXPOSE</code></td>
            <td>Documents the network ports the container listens on.</td>
        </tr>
        <tr>
            <td><code>CMD</code></td>
            <td>Default command executed when the container starts.</td>
        </tr>
        <tr>
            <td><code>ENTRYPOINT</code></td>
            <td>Defines the main entrypoint process of the container.</td>
        </tr>
        <tr>
            <td><code>ENV</code></td>
            <td>Sets environment variables inside the image.</td>
        </tr>
        <tr>
            <td><code>ARG</code></td>
            <td>Defines build-time variables available only during build.</td>
        </tr>
        <tr>
            <td><code>VOLUME</code></td>
            <td>Specifies mount points for data storage.</td>
        </tr>
        <tr>
            <td><code>USER</code></td>
            <td>Changes the user for subsequent instructions.</td>
        </tr>
        <tr>
            <td><code>LABEL</code></td>
            <td>Adds metadata to the image.</td>
        </tr>
        <tr>
            <td><code>HEALTHCHECK</code></td>
            <td>Defines a command that checks if the container is healthy.</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>All Dockerfiles start with <code>FROM</code>.</li>
    </ul>
    <br/><br/>


    <li>FROM — Choosing a Base Image</li>
    <br/>
    <ul>
        <li>The first instruction must specify a base image:</li>
<pre><code class="language-docker line-numbers">FROM python:3.12-slim</code></pre>
        <li>To start completely from zero:</li>
<pre><code class="language-docker line-numbers">FROM scratch</code></pre>
        <li>Used for extremely small images.</li>
    </ul>
    <br/><br/>


    <li>WORKDIR — Setting Working Directory</li>
    <br/>
    <ul>
        <li>Sets the directory for the following commands:</li>
<pre><code class="language-docker line-numbers">WORKDIR /app</code></pre>
        <li>If the directory does not exist, Docker creates it.</li>
    </ul>
    <br/><br/>


    <li>COPY and ADD — Adding Files</li>
    <br/>
    <ul>
        <li><code>COPY</code> copies files from host → image:</li>
<pre><code class="language-docker line-numbers">COPY . /app</code></pre>
        <br/>
        <li><code>ADD</code> should be avoided unless needed:</li>
        <ul>
            <li>It can fetch URLs</li>
            <li>It auto-extracts tar archives</li>
        </ul>
        <br/>
        <li>Prefer <code>COPY</code> for normal usage.</li>
    </ul>
    <br/><br/>


    <li>RUN — Execute Commands During Build</li>
    <br/>
    <ul>
        <li>Used to install dependencies or configure the environment:</li>
<pre><code class="language-docker line-numbers">RUN apt-get update &amp;&amp; apt-get install -y python3</code></pre>
        <br/>
        <li>Each <code>RUN</code> creates a new layer.</li>
        <br/>
        <li>Best practice: combine commands to reduce layers:</li>
<pre><code class="language-docker line-numbers">RUN apt-get update                \
    &amp;&amp; apt-get install -y python3 \
    &amp;&amp; apt-get clean</code></pre>
    </ul>
    <br/><br/>


    <li>ENV — Environment Variables</li>
    <br/>
    <ul>
        <li>Define environment variables accessible inside the container:</li>
<pre><code class="language-docker line-numbers">ENV PORT=8080
ENV MODE=production</code></pre>
        <li>Useful for configuration.</li>
    </ul>
    <br/><br/>


    <li>ARG — Build-Time Variables</li>
    <br/>
    <ul>
        <li>These exist only during the build stage (not at runtime):</li>
<pre><code class="language-docker line-numbers">ARG VERSION=1.0</code></pre>
        <li>You can pass them:</li>
<pre><code class="language-bash line-numbers">docker build --build-arg VERSION=2.0 -t app:2.0 .</code></pre>
    </ul>
    <br/><br/>


    <li>EXPOSE — Documenting Port Usage</li>
    <br/>
    <ul>
        <li>Documents the port your app uses:</li>
<pre><code class="language-docker line-numbers">EXPOSE 8080</code></pre>
        <li>IMPORTANT: It does not actually publish ports.</li>
        <br/>
        <li>Publish using:</li>
<pre><code class="language-bash line-numbers">docker run -p 8080:8080 app</code></pre>
    </ul>
    <br/><br/>


    <li>CMD — The Default Container Command</li>
    <br/>
    <ul>
        <li><code>CMD</code> specifies the command to run when the container starts:</li>
<pre><code class="language-docker line-numbers">CMD ["python", "main.py"]</code></pre>
        <li>If overridden, Docker uses the command passed to <code>docker run</code>.</li>
<pre><code class="language-bash line-numbers">docker run app python other.py</code></pre>
    </ul>
    <br/><br/>


    <li>ENTRYPOINT — Forced Command</li>
    <br/>
    <ul>
        <li><code>ENTRYPOINT</code> defines the main binary for the container:</li>
<pre><code class="language-docker line-numbers">ENTRYPOINT ["python"]</code></pre>
        <br/>
        <li>Combined with <code>CMD</code>:</li>
<pre><code class="language-docker line-numbers">ENTRYPOINT ["python"]
CMD ["main.py"]</code></pre>
        <br/>
        <li>This runs:</li>
<pre><code class="language-plaintext line-numbers">python main.py</code></pre>
        <br/>
        <li><code>ENTRYPOINT</code> cannot be overridden easily.</li>
    </ul>
    <br/><br/>


    <li>VOLUME — Persistent Data Storage</li>
    <br/>
    <ul>
        <li>Define a mount point:</li>
<pre><code class="language-docker line-numbers">VOLUME ["/data"]</code></pre>
        <li>Useful for databases or logs.</li>
    </ul>
    <br/><br/>


    <li>USER — Change the Running User</li>
    <br/>
    <ul>
        <li>Run the container as a non-root user for security:</li>
<pre><code class="language-docker line-numbers">USER appuser</code></pre>
        <li>Helps protect your system if the container is compromised.</li>
    </ul>
    <br/><br/>


    <li>LABEL — Metadata</li>
    <br/>
    <ul>
        <li>Labels add metadata to images:</li>
<pre><code class="language-docker line-numbers">LABEL maintainer="someone@example.com"
LABEL version="1.0"</code></pre>
        <li>Used in CI/CD pipelines, orchestration, and monitoring.</li>
    </ul>
    <br/><br/>


    <li>HEALTHCHECK — Container Health Verification</li>
    <br/>
    <ul>
        <li>Periodically test if your app is healthy:</li>
<pre><code class="language-docker line-numbers">HEALTHCHECK CMD curl --fail http://localhost:8080 || exit 1</code></pre>
        <li>This helps orchestrators restart unhealthy containers.</li>
    </ul>
    <br/><br/>


    <li>Full Dockerfile Example</li>
    <ul>
<pre><code class="language-docker line-numbers">FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PORT=8000

EXPOSE 8000

CMD ["python", "main.py"]
</code></pre>
        <li>This Dockerfile:</li>
        <ul>
            <li>uses a Python base image</li>
            <li>installs dependencies</li>
            <li>copies the application</li>
            <li>sets environment variables</li>
            <li>documents exposed port</li>
            <li>runs the app</li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-commands-intro">Introduction to Docker Commands</h3>
<ol>

    <li>What Are Docker Commands?</li>
    <br/>
    <ul>
        <li>Docker provides a powerful <b>command-line interface (CLI)</b> for interacting with images, containers, networks, and volumes.</li>
        <br/>
        <li>The Docker CLI follows the structure:</li>
<pre><code class="language-plaintext line-numbers">docker &lt;command&gt; &lt;subcommand&gt; [options]</code></pre>
        <br/>
        <li>Examples:
            <ul>
                <li><code>docker run</code></li>
                <li><code>docker build</code></li>
                <li><code>docker pull</code></li>
                <li><code>docker exec</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Types of Docker Commands (High-Level Overview)</li>
    <br/>
    <ol>
        <li>Container Management</b></li><br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr><td><code>docker run</code></td><td>Create and start a new container.</td></tr>
        <tr><td><code>docker start</code></td><td>Start an existing stopped container.</td></tr>
        <tr><td><code>docker stop</code></td><td>Stop a running container.</td></tr>
        <tr><td><code>docker restart</code></td><td>Restart a container.</td></tr>
        <tr><td><code>docker exec</code></td><td>Run a command inside a running container.</td></tr>
        <tr><td><code>docker logs</code></td><td>View container logs.</td></tr>
    </tbody>
</table>

        <br/>

        <li>Image Management</li><br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr><td><code>docker build</code></td><td>Build a Docker image from a Dockerfile.</td></tr>
        <tr><td><code>docker pull</code></td><td>Download an image from a registry.</td></tr>
        <tr><td><code>docker push</code></td><td>Upload an image to a registry.</td></tr>
        <tr><td><code>docker images</code></td><td>List local Docker images.</td></tr>
        <tr><td><code>docker rmi</code></td><td>Remove one or more images.</td></tr>
    </tbody>
</table>
        <br/>

        <li>Volume Management</li><br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr><td><code>docker volume create</code></td><td>Create a volume.</td></tr>
        <tr><td><code>docker volume ls</code></td><td>List volumes.</td></tr>
        <tr><td><code>docker volume inspect</code></td><td>Inspect volume configuration.</td></tr>
    </tbody>
</table>
        <br/>

        <li>Network Management</li><br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr><td><code>docker network create</code></td><td>Create a network.</td></tr>
        <tr><td><code>docker network ls</code></td><td>List networks.</td></tr>
        <tr><td><code>docker network inspect</code></td><td>Display detailed network information.</td></tr>
    </tbody>
</table>
        <br/>

        <li>System Cleanup</li><br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr><td><code>docker system prune</code></td><td>Remove unused containers, networks, images, and cache.</td></tr>
        <tr><td><code>docker container prune</code></td><td>Remove all stopped containers.</td></tr>
        <tr><td><code>docker volume prune</code></td><td>Remove all unused volumes.</td></tr>
    </tbody>
</table>
    </ol>
    <br/><br/>


    <li>System Commands</li>
    <br/>
    <ul>
        <li>Show Docker system info:</li>
<pre><code class="language-bash line-numbers">docker info</code></pre>
        <br/>
        <li>Show disk usage:</li>
<pre><code class="language-bash line-numbers">docker system df</code></pre>
        <br/>
        <li>Clean unused data:</li>
<pre><code class="language-bash line-numbers">docker system prune</code></pre>
        <br/>
        <li>Remove everything (images, volumes, containers):</li>
<pre><code class="language-bash line-numbers">docker system prune -a</code></pre>
    </ul>
    <br/><br/>


    <li>Docker Help Commands</li>
    <br/>
    <ul>
        <li>See all commands:</li>
<pre><code class="language-bash line-numbers">docker help</code></pre>
        <br/>
        <li>See help for a specific command:</li>
<pre><code class="language-bash line-numbers">docker run --help</code></pre>
        <br/>
        <li>Print Docker version:</li>
<pre><code class="language-bash line-numbers">docker --version</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-run-command">Understanding the <code>docker run</code> Command</h3>
<ol>

    <li>What Is It?</li>
    <br/>
    <ul>
        <li>The <code>docker run</code> command is used to <u>create</u> and <u>start</u> a new container from an image.</li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre>
    </ul>
    <br/><br/>


    <li>Running a Simple Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run ubuntu echo "Hello Docker"</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>ubuntu</code> is the image used</li>
            <li><code>echo "Hello Docker"</code> is the command executed inside the container</li>
        </ul>
        <br/>
        <li>This runs the command in a temporary container and exits immediately.</li>
    </ul>
    <br/><br/>


    <li><code>-it</code> — Interactive Mode</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run -it ubuntu bash</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-i</code> keeps the STDIN open</li>
            <li><code>-t</code> allocates a pseudo-TTY (interactive terminal)</li>
            <li><code>ubuntu</code> is the image</li>
            <li><code>bash</code> runs Bash shell inside container</li>
        </ul>
        <br/>
        <li>You get an interactive shell inside the container.</li>
    </ul>
    <br/><br/>


    <li><code>-d</code> — Run in Detached Mode (Background)</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run -d nginx</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-d</code> runs container in background</li>
            <li><code>nginx</code> is the image that runs a web server</li>
        </ul>
        <br/>
        <li>The container runs in background without attaching to your terminal.</li>
    </ul>
    <br/><br/>


    <li><code>-p</code> — Publishing Ports</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run -p 8080:80 nginx</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-p</code> maps host port to container port</li>
            <li><code>8080</code> is the host port (your machine)</li>
            <li><code>80</code> is the container port</li>
            <li><code>nginx</code> is the web server which is listening on port 80 internally</li>
        </ul>
        <br/>
        <li>You access the Nginx webpage via:</li>
<pre><code class="language-plaintext line-numbers">http://localhost:8080</code></pre>
    </ul>
    <br/><br/>


    <li><code>-v</code> — Mounting Volumes</li>
    <br/>
    <ul>
        <li>Example (bind mount):</li>
<pre><code class="language-bash line-numbers">docker run -v /host/data:/container/data ubuntu</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-v</code> mounts the volume</li>
            <li><code>/host/data</code> is the directory on host machine</li>
            <li><code>/container/data</code> is the directory inside container</li>
        </ul>
        <br/>
        <li>Changes inside the container appear on the host, and vice versa.</li>
    </ul>
    <br/><br/>


    <li><code>--name</code> — Naming a Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run --name mynginx -d nginx</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--name mynginx</code> assigns a custom name</li>
            <li><code>-d</code> to enter the detached mode</li>
            <li><code>nginx</code> is the image</li>
        </ul>
        <br/>
        <li>Named containers are easier to manage.</li>
    </ul>
    <br/><br/>


    <li><code>-e</code> — Setting Environment Variables</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run -e MODE=production -e PORT=5000 myapp</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-e MODE=production</code> sets environment variable <code>MODE</code></li>
            <li><code>-e PORT=5000</code> sets environment variable <code>PORT</code></li>
            <li><code>myapp</code> is the image</li>
        </ul>
        <br/>
        <li>The app inside the container can read these values.</li>
    </ul>
    <br/><br/>


    <li><code>--rm</code> — Auto-remove After Exit</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run --rm ubuntu echo "temp"</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--rm</code> deletes the container after it exits</li>
            <li><code>ubuntu</code> is the image</li>
            <li><code>echo "temp"</code> is the temporary command</li>
        </ul>
        <br/>
        <li>Useful for running one-time commands.</li>
    </ul>
    <br/><br/>


    <li><code>-w</code> — Working Directory</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run -w /app ubuntu pwd</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-w /app</code> sets / temporarily overrides the working directory inside container</li>
            <li><code>ubuntu</code> is the image</li>
            <li><code>pwd</code> is the command executed inside <code>/app</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li><code>--network</code> — Attach Container to a Network</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run --network mynet nginx</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--network mynet</code> attaches the container to <code>mynet</code></li>
            <li><code>nginx</code> is the image</li>
        </ul>
        <br/>
        <li>Useful for multi-container applications.</li>
    </ul>
    <br/><br/>


    <li><code>--entrypoint</code> — Override the Default Entry Command</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run --entrypoint ls ubuntu -l /</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--entrypoint ls</code> replaces the image's default entrypoint with <code>ls</code></li>
            <li><code>ubuntu</code> is the image</li>
            <li><code>-l /</code> are arguments for <code>ls</code></li>
        </ul>
        <br/>
        <li>Useful for debugging containers with custom entrypoints.</li>
    </ul>
    <br/><br/>


    <li><code>--cpu</code> and <code>--memory</code> — Resource Limiting</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker run --cpus="1.5" --memory="512m" myapp</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--cpus="1.5"</code> limits container to 1.5 CPU cores</li>
            <li><code>--memory="512m"</code> limits container to 512 MB RAM</li>
            <li><code>myapp</code> is the image</li>
        </ul>
        <br/>
        <li>Important for production deployments.</li>
    </ul>
    <br/><br/>


    <li>Combining Multiple Options</li>
    <br/>
    <ul>
        <li>Example (common real-world):</li>
<pre><code class="language-bash line-numbers">docker run -d                           \
    -p 8080:80                          \
    -v /host/www:/usr/share/nginx/html  \
    -e ENV=production                   \
    --name webserver                    \
    nginx
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-d</code> runs in the background</li>
            <li><code>-p 8080:80</code> maps host 8080 → container 80</li>
            <li><code>-v /host/www:/usr/share/nginx/html</code> mounts the website files</li>
            <li><code>-e ENV=production</code> sets the environment variable</li>
            <li><code>--name webserver</code> sets the container name</li>
            <li><code>nginx</code> is the image</li>
        </ul>
        <br/>
        <li>This starts a complete Nginx web server with custom settings.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-start-command">Understanding the <code>docker start</code> Command</h3>
<ol>

    <li>What Is <code>docker start</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker start</code> command is used to <u>start</u> an existing (stopped) container.</li>
        <br/>
        <li>Unlike <code>docker run</code>:
            <ul>
                <li><code>docker run</code> creates a new container from an image</li>
                <li><code>docker start</code> starts an already created container</li>
            </ul>
        </li>
        <br/>
        <li>It does NOT create new containers.</li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker start [OPTIONS] CONTAINER</code></pre>
    </ul>
    <br/><br/>


    <li>Starting an Existing Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker start mycontainer</code></pre>
        <li>Explanation: <code>mycontainer</code> is the name (or ID) of a previously created container</li>
        <br/>
        <li>The container resumes running from its configured command or entrypoint.</li>
    </ul>
    <br/><br/>


    <li>List Containers Before Starting Them</li>
    <br/>
    <ul>
        <li>Show only stopped containers:</li>
<pre><code class="language-bash line-numbers">docker ps -a</code></pre>
        <br/>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">CONTAINER ID   IMAGE   COMMAND    STATUS
abcd1234       nginx   "nginx…"   Exited (0)
</code></pre>
        </li>
        <br/>
        <li>Now you can start it:</li>
<pre><code class="language-bash line-numbers">docker start abcd1234</code></pre>
    </ul>
    <br/><br/>


    <li><code>-a</code> — Attach to the Container Output</li>
    <br/>
    <ul>
        <li>The <code>-a</code> flag attaches your terminal to the container’s STDOUT/STDERR.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker start -a mycontainer</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-a</code> shows the container output in your terminal</li>
            <li><code>mycontainer</code> is the container name or ID</li>
        </ul>
        <br/>
        <li>Useful when container prints logs or immediately exits.</li>
    </ul>
    <br/><br/>


    <li><code>-i</code> — Attach Standard Input (STDIN)</li>
    <br/>
    <ul>
        <li>Use this when restarting a container that expects terminal input.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker start -i mycontainer</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-i</code> keeps STDIN open for the container</li>
            <li><code>mycontainer</code> is the name of container</li>
        </ul>
        <br/>
        <li>This is similar to <code>docker run -it</code>, but only works if the container was originally created with interactive capabilities.</li>
    </ul>
    <br/><br/>


    <li>Starting Multiple Containers at Once</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker start container1 container2 container3</code></pre>
        <li>Explanation:</li>
        <ul>
            <li>You can pass multiple names/IDs</li>
            <li>Docker starts all of them in sequence</li>
        </ul>
        <br/>
        <li>Useful for restarting a multi-container setup.</li>
    </ul>
    <br/><br/>


    <li>Check Status After Starting</li>
    <br/>
    <ul>
        <li>Inspect running containers:</li>
<pre><code class="language-bash line-numbers">docker ps</code></pre>
        <br/>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">CONTAINER ID   IMAGE   STATUS
abcd1234       nginx   Up 10 seconds
</code></pre>
        </li>
        <br/>
        <li>This confirms the container is running.</li>
    </ul>
    <br/><br/>


    <li>Difference Between <code>docker start</code> and <code>docker restart</code></li>
    <br/>
    <ul>
        <li><code>docker start</code>:</li>
        <ul>
            <li>Starts stopped containers</li>
            <li>Does nothing if already running</li>
        </ul>
        <br/>
        <li><code>docker restart</code>:</li>
        <ul>
            <li>Stops the container first</li>
            <li>Then starts it again</li>
            <li>Works even if container is already running</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker restart mycontainer</code></pre>
    </ul>
    <br/><br/>


    <li>Example Workflow: Create with <code>run</code>, Start Again with <code>start</code></li>
    <br/>
    <ul>
        <li>Step 1: Create a container</li>
<pre><code class="language-bash line-numbers">docker run --name testcontainer ubuntu sleep 1000</code></pre>
        <ul>
            <li>Container sleeps for 1000 seconds</li>
        </ul>
        <br/>

        <li>Step 2: Stop the container</li>
<pre><code class="language-bash line-numbers">docker stop testcontainer</code></pre>

        <br/>
        <li>Step 3: Start it again</li>
<pre><code class="language-bash line-numbers">docker start testcontainer</code></pre>

        <br/>
        <li>This starts the original container without recreating it.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-stop-command">Understanding the <code>docker stop</code> Command</h3>
<ol>

    <li>What Is <code>docker stop</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker stop</code> command gracefully <u>stops</u> one or more running containers.</li>
        <br/>
        <li>Stopping a container means:
            <ul>
                <li>Docker sends a <code>SIGTERM</code> signal to the process</li>
                <li>If it doesn’t exit within 10 seconds (default), Docker sends <code>SIGKILL</code></li>
            </ul>
        </li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker stop [OPTIONS] CONTAINER [CONTAINER...]</code></pre>
        <br/>
        <li>This is the preferred way to stop a running container.</li>
    </ul>
    <br/><br/>


    <li>Stopping a Running Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker stop mycontainer</code></pre>
        <li>Explanation: <code>mycontainer</code> is the container name or ID</li>
        <br/>
        <li>Docker attempts a graceful shutdown via <code>SIGTERM</code>.</li>
    </ul>
    <br/><br/>


    <li>Stopping Multiple Containers</li>
    <br/>
    <ul>
        <li>You can stop multiple containers at once:</li>
<pre><code class="language-bash line-numbers">docker stop container1 container2 container3</code></pre>
        <li>Docker stops each in sequence.</li>
    </ul>
    <br/><br/>


    <li>Understanding Signal Workflow</li>
    <br/>
    <ul>
        <li>When stopping a container:</li>
        <ul>
            <li>Step 1: Docker sends <code>SIGTERM</code></li>
            <li>Step 2: Container has time to exit cleanly (default 10 seconds)</li>
            <li>Step 3: If still running → Docker sends <code>SIGKILL</code></li>
        </ul>
        <br/>
        <li>This prevents abrupt shutdowns unless necessary.</li>
    </ul>
    <br/><br/>


    <li><code>-t</code> — Changing the Timeout Before Force-Kill</li>
    <br/>
    <ul>
        <li>Default timeout: <b>10 seconds</b>.</li>
        <br/>
        <li>You can change this timeout:</li>
<pre><code class="language-bash line-numbers">docker stop -t 3 mycontainer</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-t 3</code> waits only 3 seconds before sending <code>SIGKILL</code></li>
            <li><code>mycontainer</code> is the the container to stop</li>
        </ul>
    </ul>
    <br/><br/>


    <li>What Happens to Processes Inside the Container?</li>
    <br/>
    <ul>
        <li>On <code>docker stop</code>, the main process (PID 1 inside container) receives:
            <ul>
                <li><code>SIGTERM</code> → graceful shutdown</li>
                <li><code>SIGKILL</code> → forced kill if shutdown fails</li>
            </ul>
        </li>
        <br/>
        <li>If the main process handles <code>SIGTERM</code> correctly (web servers, applications), shutdown is clean.</li>
        <br/>
        <li>If the process ignores signals → Docker eventually kills it.</li>
    </ul>
    <br/><br/>


    <li>Stopping All Running Containers</li>
    <br/>
    <ul>
        <li>Example (works via shell expansion):</li>
<pre><code class="language-bash line-numbers">docker stop $(docker ps -q)</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>docker ps -q</code> outputs only container IDs</li>
            <li><code>docker stop ...</code> stops all container IDs given</li>
        </ul>
        <br/>
        <li>This is a commonly used bulk stop command.</li>
    </ul>
    <br/><br/>


    <li>Difference Between <code>docker stop</code> and <code>docker kill</code></li>
    <br/>
    <ul>
        <li><code>docker stop</code> → graceful</li>
        <ul>
            <li>tries <code>SIGTERM</code> first</li>
            <li>forces shutdown only if needed</li>
        </ul>
        <br/>
        <li><code>docker kill</code> → force kill</li>
        <ul>
            <li>immediately sends <code>SIGKILL</code></li>
            <li>no graceful shutdown</li>
        </ul>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker kill mycontainer</code></pre>
        <li>Only use <code>kill</code> if <code>stop</code> does not work.</li>
    </ul>
    <br/><br/>


    <li>Example Workflow: Stop → Start → Attach</li>
    <br/>
    <ul>
        <li>Step 1: Create container</li>
<pre><code class="language-bash line-numbers">docker run -d --name web nginx</code></pre>

        <br/>
        <li>Step 2: Stop the container</li>
<pre><code class="language-bash line-numbers">docker stop web</code></pre>

        <br/>
        <li>Step 3: Start again</li>
<pre><code class="language-bash line-numbers">docker start web</code></pre>

        <br/>
        <li>Step 4: View logs</li>
<pre><code class="language-bash line-numbers">docker logs web</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-restart-command">Understanding the <code>docker restart</code> Command</h3>
<ol>

    <li>What Is <code>docker restart</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker restart</code> command is used to <u>stop and then start</u> one or more containers in a single operation.</li>
        <br/>
        <li>It is essentially the combination of:</li>
<pre><code class="language-plaintext line-numbers">docker stop [container]
docker start [container]
</code></pre>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker restart [OPTIONS] CONTAINER [CONTAINER...]</code></pre>
        <li>Useful when you want the container to restart with updated configurations or refreshed network connections.</li>
    </ul>
    <br/><br/>


    <li>Restarting a Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker restart mycontainer</code></pre>
        <li>Explanation: <code>mycontainer</code> is the container name or ID</li>
        <br/>
        <li>Docker performs:
            <ul>
                <li><code>SIGTERM</code> → graceful stop</li>
                <li><code>SIGKILL</code> → after timeout (default 10 sec, configurable just like in <code>docker stop</code>)</li>
                <li>Then starts the container again</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Using Timeout with <code>-t</code></li>
    <br/>
    <ul>
        <li>You can customize the shutdown timeout before the restart begins.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker restart -t 3 mycontainer</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-t 3</code> waits 3 seconds before force-killing during stop</li>
            <li><code>mycontainer</code> is the container to restart</li>
        </ul>
        <br/>
        <li>Useful for applications needing faster restart cycles.</li>
    </ul>
    <br/><br/>


    <li>Restarting Multiple Containers</li>
    <br/>
    <ul>
        <li>You can restart multiple containers at once:</li>
<pre><code class="language-bash line-numbers">docker restart web app db</code></pre>
        <li>Explanation: Restarts <code>web</code>, <code>app</code>, and <code>db</code> containers sequentially</li>
        <br/>
        <li>Useful for multi-container environments.</li>
    </ul>
    <br/><br/>


    <li>Example Workflow: Updating Configuration and Restarting</li>
    <br/>
    <ul>
        <li>Step 1: Modify a config file inside a volume</li>
<pre><code class="language-bash line-numbers">vim /host/config/nginx.conf
</code></pre>

        <br/>
        <li>Step 2: Restart Nginx container</li>
<pre><code class="language-bash line-numbers">docker restart nginx-server</code></pre>

        <br/>
        <li>Step 3: Confirm status</li>
<pre><code class="language-bash line-numbers">docker ps</code></pre>
    </ul>
    <br/><br/>


    <li>Example: Fast Restart with Custom Timeout</li>
    <br/>
    <ul>
        <li>Some applications take too long to shut down gracefully.</li>
        <br/>
        <li>Use a shorter timeout:</li>
<pre><code class="language-bash line-numbers">docker restart -t 1 backend</code></pre>
        <br/>
        <li>Meaning: wait at most 1 second before restarting.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-exec-command">Understanding the <code>docker exec</code> Command</h3>
<ol>

    <li>What Is <code>docker exec</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker exec</code> command is used to run a new command inside an <b>already running</b> container.</li>
        <br/>
        <li>It does NOT start a new container — instead, it:
            <ul>
                <li>executes a process in an existing one</li>
                <li>allows debugging, inspection, and tooling</li>
                <li>can open an interactive shell</li>
            </ul>
        </li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre>
    </ul>
    <br/><br/>


    <li>Running a Simple Command Inside a Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker exec mycontainer ls /</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>mycontainer</code> is the name or ID of running container</li>
            <li><code>ls /</code> is the command executed inside the container's filesystem</li>
        </ul>
        <br/>
        <li>Useful for checking files or verifying application structure.</li>
    </ul>
    <br/><br/>


    <li><code>-it</code> — Interactive Shell Inside the Container</li>
    <br/>
    <ul>
        <li>Example (open a Bash shell):</li>
<pre><code class="language-bash line-numbers">docker exec -it mycontainer bash</code></pre>
        <li>If the container uses Alpine Linux (no bash installed):</li>
<pre><code class="language-bash line-numbers">docker exec -it mycontainer sh</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-i</code> keeps STDIN open</li>
            <li><code>-t</code> allocates an interactive terminal (TTY)</li>
            <li><code>bash</code> or <code>sh</code> is the shell inside the container</li>
        </ul>
        <br/>
        <li>This is the most common use of <code>docker exec</code> — for debugging and exploration.</li>
    </ul>
    <br/><br/>


    <li><code>-d</code> — Execute in Detached Mode</li>
    <br/>
    <ul>
        <li>Run a command in the background:</li>
<pre><code class="language-bash line-numbers">docker exec -d mycontainer touch /tmp/file.txt</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-d</code> runs command in background</li>
            <li><code>touch /tmp/file.txt</code> is the command executed without blocking your terminal</li>
        </ul>
        <br/>
        <li>Useful for administrative tasks during runtime.</li>
    </ul>
    <br/><br/>


    <li>Executing Commands as Another User (<code>-u</code>)</li>
    <br/>
    <ul>
        <li>Run as root (default user is often root, but not always):</li>
<pre><code class="language-bash line-numbers">docker exec -u root mycontainer whoami</code></pre>
        <li>Run as a specific user inside container:</li>
<pre><code class="language-bash line-numbers">docker exec -u www-data mycontainer ls /var/www</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-u</code> specifies user</li>
            <li><code>www-data</code> is the user inside container</li>
        </ul>
        <br/>
        <li>Useful for permission testing or debugging web servers.</li>
    </ul>
    <br/><br/>


    <li>Passing Environment Variables Using <code>env</code></li>
    <br/>
    <ul>
        <li>You cannot pass <code>-e</code> in <code>docker exec</code>, but you can wrap commands:</li>
<pre><code class="language-bash line-numbers">docker exec mycontainer env MODE=dev sh -c 'echo $MODE'</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>env MODE=dev</code> creates a temporary environment variable</li>
            <li><code>sh -c</code> runs shell with command inside quotes</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Executing Long-Running Processes</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker exec myapp python script.py</code></pre>
        <br/>
        <li>The process runs alongside the container’s main process.</li>
        <br/>
        <li>This is helpful for maintenance scripts.</li>
    </ul>
    <br/><br/>


    <li>Checking Process Status Inside Container</li>
    <br/>
    <ul>
        <li>You can use <code>ps</code> or similar tools:</li>
<pre><code class="language-bash line-numbers">docker exec myapp ps aux</code></pre>
        <br/>
        <li>Useful for debugging memory or CPU usage of running processes.</li>
    </ul>
    <br/><br/>


    <li>Example: Inspect an Nginx Web Server Container</li>
    <br/>
    <ul>
        <li>Check configuration:</li>
<pre><code class="language-bash line-numbers">docker exec -it webserver cat /etc/nginx/nginx.conf</code></pre>
        <li>Restart Nginx inside container:</li>
<pre><code class="language-bash line-numbers">docker exec webserver nginx -s reload</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>nginx -s reload</code> hot-reloads config</li>
            <li>Exec runs it inside container</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Example: Debugging a Python App</li>
    <br/>
    <ul>
        <li>View logs stored inside container:</li>
<pre><code class="language-bash line-numbers">docker exec myapp tail -n 50 /app/logs/error.log</code></pre>
        <li>Restart worker process:</li>
<pre><code class="language-bash line-numbers">docker exec myapp pkill -f worker.py</code></pre>
    </ul>
    <br/><br/>


    <li>Important Limitations of <code>docker exec</code></li>
    <br/>
    <ul>
        <li>Cannot exec into stopped containers → must use <code>docker start</code> first.</li>
        <br/>
        <li>Does not modify or change the Dockerfile / image.</li>
        <br/>
        <li>Commands executed via <code>exec</code> disappear when container stops unless data is saved.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-logs-command">Understanding the <code>docker logs</code> Command</h3>
<ol>

    <li>What Is <code>docker logs</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker logs</code> command <u>displays logs</u> generated by a running or stopped container.</li>
        <br/>
        <li>Logs include anything written to:
            <ul>
                <li><code>STDOUT</code> (standard output)</li>
                <li><code>STDERR</code> (standard error)</li>
            </ul>
        </li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker logs [OPTIONS] CONTAINER</code></pre>
        <br/>
        <li>Useful for debugging application output, errors, and behavior.</li>
    </ul>
    <br/><br/>


    <li>Viewing Logs of a Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker logs mycontainer</code></pre>
        <li>Explanation: <code>mycontainer</code> is the container name or ID</li>
        <br/>
        <li>Shows all logs since the container started, printed in chronological order.</li>
    </ul>
    <br/><br/>


    <li><code>-f</code> — Follow Logs in Real Time</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker logs -f mycontainer</code></pre>
        <li>Explanation: <code>-f</code> follows log output (like <code>tail -f</code>)</li>
        <br/>
        <li>Used to monitor apps in real time (web servers, workers, cron jobs).</li>
    </ul>
    <br/><br/>


    <li><code>--tail</code> — View Only the Last X Lines</li>
    <br/>
    <ul>
        <li>Example: see only the last 50 lines</li>
<pre><code class="language-bash line-numbers">docker logs --tail 50 mycontainer</code></pre>
        <li>Useful for large log output.</li>
    </ul>
    <br/><br/>


    <li><code>-t</code> — Show Timestamps</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker logs -t mycontainer</code></pre>
        <li>Helps correlate logs with events or external systems.</li>
    </ul>
    <br/><br/>


    <li>Combine Options: Follow + Tail + Timestamp</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker logs -f --tail 20 -t mycontainer</code></pre>
        <li>This means:</li>
        <ul>
            <li><code>--tail 20</code> shows last 20 lines</li>
            <li><code>-t</code> includes timestamps</li>
            <li><code>-f</code> continues watching logs live</li>
        </ul>
        <br/>
        <li>This is the most common real-time monitoring pattern.</li>
    </ul>
    <br/><br/>


    <li>Viewing Logs from Stopped Containers</li>
    <br/>
    <ul>
        <li>Docker stores logs even after the container stops.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker logs my-stopped-container</code></pre>
        <br/>
        <li>Useful for debugging crashes or unexpected exits.</li>
    </ul>
    <br/><br/>


    <li>Example: Debugging a Crash</li>
    <br/>
    <ul>
        <li>Step 1: Check container status:</li>
<pre><code class="language-bash line-numbers">docker ps -a</code></pre>
        <br/>
        <li>Step 2: View logs:</li>
<pre><code class="language-bash line-numbers">docker logs myapp</code></pre>
        <br/>
        <li>Step 3: Look for exceptions, Python stack traces, Nginx errors, etc.</li>
    </ul>
    <br/><br/>


    <li>Log Output from a Web Server (Example)</li>
    <br/>
    <ul>
        <li>Nginx container logs:</li>
<pre><code class="language-bash line-numbers">docker logs nginx-server</code></pre>
        <br/>
        <li>Shows access logs + error logs because both go to STDOUT/STDERR.</li>
    </ul>
    <br/><br/>


    <li>Filtering Output with <code>grep</code> (Shell Feature)</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker logs myapp | grep "ERROR"</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li>This is NOT a Docker feature — just shell piping</li>
            <li>Filters logs for the keyword <code>ERROR</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li>Difference Between <code>docker logs</code> and <code>docker exec</code> for Log Files</li>
    <br/>
    <ul>
        <li><code>docker logs</code> only shows STDOUT/STDERR.</li>
        <br/>
        <li>If logs are stored in files inside container:</li>
<pre><code class="language-bash line-numbers">docker exec myapp cat /app/logs/server.log</code></pre>
        <li>Many applications log internally and not to STDOUT — these logs require <code>docker exec</code>.</li>
    </ul>
    <br/><br/>


    <li>Where Are Docker Logs Stored on Host?</li>
    <br/>
    <ul>
        <li>Under the hood, Docker stores logs in:</li>
<pre><code class="language-plaintext line-numbers">/var/lib/docker/containers/[ID]/[ID]-json.log</code></pre>
        </li>
        <li>But you rarely need to access this manually.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-build-command">Understanding the <code>docker build</code> Command</h3>
<ol>

    <li>What Is <code>docker build</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker build</code> command is used to create a Docker image from a set of instructions written in a <code>Dockerfile</code>.</li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker build [OPTIONS] PATH | URL | -</code></pre>
        <br/>
        <li><code>PATH</code> is usually the directory containing your <code>Dockerfile</code>.</li>
    </ul>
    <br/><br/>


    <li>Building an Image from a Dockerfile</li>
    <br/>
    <ul>
        <li>Most common example:</li>
<pre><code class="language-bash line-numbers">docker build -t myapp:latest .</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-t myapp:latest</code> tags the new image as <code>myapp:latest</code></li>
            <li><code>.</code> is the current directory (where Dockerfile is located)</li>
        </ul>
        <br/>
        <li>Docker will:
            <ul>
                <li>read the Dockerfile</li>
                <li>execute each instruction (FROM, COPY, RUN…)</li>
                <li>build layers</li>
                <li>produce an image</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><code>-t</code> — Tagging an Image</li>
    <br/>
    <ul>
        <li>Tag format:</li>
<pre><code class="language-plaintext line-numbers">&lt;name&gt;:&lt;tag&gt;</code></pre>
        </li>
        <li>Example with custom tag:</li>
<pre><code class="language-bash line-numbers">docker build -t backend:v1.0 .</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>backend</code> is the image name</li>
            <li><code>v1.0</code> is the version tag</li>
        </ul>
        <br/>
        <li>Tags help version and identify images for deployments.</li>
    </ul>
    <br/><br/>


    <li><code>-f</code> — Build with a Custom Dockerfile Name</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker build -f Dockerfile.prod -t web:prod .</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-f Dockerfile.prod</code> means using this file instead of <code>Dockerfile</code></li>
            <li><code>-t web:prod</code> tags image with <code>web:prod</code></li>
            <li><code>.</code> builds context directory</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Understanding the Build Context</li>
    <br/>
    <ul>
        <li>The path you pass to <code>docker build</code> (usually <code>.</code>) is the <u>build context</u>.</li>
        <br/>
        <li>Docker sends this entire directory to the Docker daemon.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker build -t app .</code></pre>
        <br/>
        <li>Everything inside <code>.</code> becomes available to <code>COPY</code> and <code>ADD</code> commands in the Dockerfile.</li>
        <br/>
        <li>Use <code>.dockerignore</code> to prevent sending unnecessary files.</li>
    </ul>
    <br/><br/>


    <li><code>--no-cache</code> — Build Without Using Cache</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker build --no-cache -t app:clean .</code></pre>
        <li>Explanation:</li>
        <ul>
            <li>Forces Docker to execute all instructions from scratch</li>
            <li>Good for ensuring fresh dependencies</li>
        </ul>
    </ul>
    <br/><br/>


    <li><code>--pull</code> — Always Pull the Newest Base Image</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker build --pull -t api:latest .</code></pre>
        <li>Explanation: <code>--pull</code> forces Docker to download the newest image used in <code>FROM</code></li>
    </ul>
    <br/><br/>


    <li><code>--build-arg</code> — Pass Build Arguments</li>
    <br/>
    <ul>
        <li>Dockerfile example:</li>
<pre><code class="language-dockerfile line-numbers">ARG VERSION
RUN echo "Building version $VERSION"</code></pre>
        <li>Build command:</li>
<pre><code class="language-bash line-numbers">docker build --build-arg VERSION=1.2.3 -t app:v1 .</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>ARG VERSION</code> defines a variable usable only during build</li>
            <li><code>--build-arg VERSION=1.2.3</code> assigns the value</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Building from a Git Repository</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker build -t app https://github.com/user/repo.git</code></pre>
        <li>Docker automatically downloads and builds from the repository root.</li>
    </ul>
    <br/><br/>


    <li>Building from Standard Input (<code>-</code>)</li>
    <br/>
    <ul>
        <li>Example using inline Dockerfile:</li>
<pre><code class="language-bash line-numbers">
echo -e "FROM alpine\nCMD echo Hello" | docker build -t hello -
</code></pre>
        <br/>
        <li>Explanation: <code>-</code> tells Docker to read the Dockerfile from stdin</li>
    </ul>
    <br/><br/>


    <li>Checking Built Images</li>
    <br/>
    <ul>
        <li>After building:</li>
<pre><code class="language-bash line-numbers">docker images</code></pre>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">REPOSITORY   TAG     IMAGE ID       SIZE
myapp        latest  7f8a1b23b123   125MB
</code></pre>
    </ul>
    <br/><br/>


    <li>Example Workflow: Build → Run → Test</li>
    <br/>
    <ul>
        <li>Step 1: Build the image</li>
<pre><code class="language-bash line-numbers">docker build -t webapp .</code></pre>

        <br/>
        <li>Step 2: Run a container</li>
<pre><code class="language-bash line-numbers">docker run -d -p 8080:80 --name web webapp</code></pre>

        <br/>
        <li>Step 3: View logs</li>
<pre><code class="language-bash line-numbers">docker logs web</code></pre>
    </ul>
    <br/><br/>


    <li>Common Mistakes and Tips</li>
    <br/>
    <ul>
        <li>Copying too many files into the context</li>
        <li>Fix: use <code>.dockerignore</code></li>
        <br/>
        <li>Large images</li>
        <li>Fix: use multi-stage builds</li>
        <br/>
        <li>Missing explicit versions</li>
        <li>Fix: always pin versions in <code>FROM</code> and <code>RUN</code></li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-pull-command">Understanding the <code>docker pull</code> Command</h3>
<ol>

    <li>What Is <code>docker pull</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker pull</code> command is used to download Docker images from a registry (usually Docker Hub).</li>
        <br/>
        <li>It retrieves:</li>
        <ul>
            <li>the image manifest</li>
            <li>all required layers</li>
            <li>metadata (tags, architecture, digest)</li>
        </ul>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></pre>
        <br/>
        <li>If no tag is provided, Docker pulls the <code>latest</code> tag by default.</li>
    </ul>
    <br/><br/>


    <li>Pulling an Image from Docker Hub</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker pull nginx</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>nginx</code> is the image name</li>
            <li>No tag means Docker pulls <code>nginx:latest</code></li>
        </ul>
        <br/>
        <li>Docker will:
            <ul>
                <li>connect to Docker Hub</li>
                <li>download layers</li>
                <li>save the image locally</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Pulling a Specific Tagged Version</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker pull python:3.11</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>python</code> is the image name</li>
            <li><code>3.11</code> is the specific version tag</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Pulling by Digest (<code>@sha256:...</code>)</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker pull ubuntu@sha256:3af...
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li>Pulls an exact, immutable version of an image</li>
            <li>Useful for production-grade reproducibility</li>
        </ul>
    </ul>
    <br/><br/>


    <li><code>--platform</code> — Pull Image for Specific Architecture</li>
    <br/>
    <ul>
        <li>Example (for Apple Silicon pulling x86_64 image):</li>
<pre><code class="language-bash line-numbers">docker pull --platform linux/amd64 node:18
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--platform linux/amd64</code> forces specific architecture</li>
            <li><code>node:18</code> are the image name and tag</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Pulling Images from Private Registries</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker pull myregistry.com/myapp/backend:latest</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>myregistry.com</code> is the custom registry URL</li>
            <li><code>myapp/backend</code> is the repository</li>
            <li><code>latest</code> is the tag</li>
        </ul>
        <br/>
        <li>It requires login via:</li>
<pre><code class="language-bash line-numbers">docker login myregistry.com</code></pre>
    </ul>
    <br/><br/>


    <li>Pulling All Tags of an Image (Not Native to Docker)</li>
    <br/>
    <ul>
        <li>Docker has no built-in “pull all tags” command.</li>
        <br/>
        <li>You can do it via scripting:</li>
<pre><code class="language-bash line-numbers">for tag in $(docker search nginx --format "{{.Name}}" | grep nginx); do
    docker pull nginx:$tag
done
</code></pre>
    </ul>
    <br/><br/>


    <li>When Should You Run <code>docker pull</code>?</li>
    <ul>
        <br/>
        <li>You need the newest version of an image</li>
        <br/>
        <li>You want to sync a Dockerfile <code>FROM</code> image</li>
        <br/>
        <li>You are preparing a deployment</li>
        <br/>
        <li>CI pipelines need predictable base images</li>
        <br/>
        <li>Local images are outdated</li>
    </ul>
    <br/><br/>


    <li>Example Workflow: Pull → Run → Inspect</li>
    <br/>
    <ul>
        <li>Step 1: Pull</li>
<pre><code class="language-bash line-numbers">docker pull redis:7</code></pre>

        <br/>
        <li>Step 2: Run</li>
<pre><code class="language-bash line-numbers">docker run -d --name cache redis:7</code></pre>

        <br/>
        <li>Step 3: Logs</li>
<pre><code class="language-bash line-numbers">docker logs cache</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-push-command">Understanding the <code>docker push</code> Command</h3>
<ol>

    <li>What Is <code>docker push</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker push</code> command is used to upload (publish) Docker images from your local machine to a remote registry such as:</li>
        <ul>
            <li>Docker Hub (default)</li>
            <li>GitHub Container Registry</li>
            <li>GitLab Container Registry</li>
            <li>Private registries</li>
        </ul>
        <br/>
        <li>This allows you to share images with others, deploy images to servers, or store them for CI/CD.</li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker push NAME[:TAG]</code></pre>
    </ul>
    <br/><br/>


    <li>Tagging an Image Before Pushing</li>
    <br/>
    <ul>
        <li>You can only push images that are properly tagged with a registry prefix.</li>
        <br/>
        <li>Example: tag an image for Docker Hub:</li>
<pre><code class="language-bash line-numbers">docker tag myapp:latest myusername/myapp:latest</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>myapp:latest</code> is the local image</li>
            <li><code>myusername/myapp:latest</code> is the image in your Docker Hub namespace</li>
        </ul>
        <br/>
        <li>Now the image is ready to be pushed.</li>
    </ul>
    <br/><br/>


    <li>Pushing an Image to Docker Hub</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker push myusername/myapp:latest</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>myusername</code> is your Docker Hub username</li>
            <li><code>myapp</code> is the repository name</li>
            <li><code>latest</code> is the tag being uploaded</li>
        </ul>
        <br/>
        <li>Docker uploads all image layers that are not already present in the registry.</li>
    </ul>
    <br/><br/>


    <li>Logging In Before Pushing</li>
    <br/>
    <ul>
        <li>If you are not logged in, Docker will reject the push.</li>
        <br/>
        <li>Login to Docker Hub:</li>
<pre><code class="language-bash line-numbers">docker login</code></pre>
        <li>For private registries:</li>
<pre><code class="language-bash line-numbers">docker login myregistry.com</code></pre>
    </ul>
    <br/><br/>


    <li>Pushing to a Private Registry</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker tag api:latest myregistry.com/team/api:v2</code></pre>
<pre><code class="language-bash line-numbers">docker push myregistry.com/team/api:v2</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>myregistry.com</code> is the registry host</li>
            <li><code>team/api</code> is the repository inside registry</li>
            <li><code>v2</code> is the version tag</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Pushing Multiple Tags</li>
    <br/>
    <ul>
        <li>Each tag must be pushed separately:</li>
<pre><code class="language-bash line-numbers">docker push myapp:latest</code></pre>
<pre><code class="language-bash line-numbers">docker push myapp:v1.0</code></pre>
    </ul>
    <br/><br/>


    <li>Pushing by Digest</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker push myapp@sha256:4bb42ad...</code></pre>
        <li>Useful for verifying that a specific immutable image is uploaded.</li>
    </ul>
    <br/><br/>


    <li>Checking Local Images Before Pushing</li>
    <br/>
    <ul>
<pre><code class="language-bash line-numbers">docker images</code></pre>
        <br/>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">REPOSITORY             TAG     IMAGE ID      SIZE
myusername/myapp       latest  09be1234abc   155MB
</code></pre>
    </ul>
    <br/><br/>


    <li>Example Workflow: Build → Tag → Push</li>
    <br/>
    <ul>
        <li>Step 1: Build image</li>
<pre><code class="language-bash line-numbers">docker build -t myapp .</code></pre>

        <br/>
        <li>Step 2: Tag for Docker Hub</li>
<pre><code class="language-bash line-numbers">docker tag myapp myusername/myapp:latest</code></pre>

        <br/>
        <li>Step 3: Push to registry</li>
<pre><code class="language-bash line-numbers">docker push myusername/myapp:latest</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-volume-command">Understanding the <code>docker volume</code> Command</h3>
<ol>

    <li>What Is <code>docker volume</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker volume</code> command manages Docker-managed storage volumes that persist data outside container lifecycles.</li>
        <br/>
        <li>Volumes allow you to:</li>
        <ul>
            <li>persist database files</li>
            <li>share data between containers</li>
            <li>keep data even after containers are removed</li>
            <li>avoid storing data inside container layers</li>
        </ul>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker volume [COMMAND]</code></pre>
    </ul>
    <br/><br/>


    <li>Listing Volumes with <code>docker volume ls</code></li>
    <br/>
    <ul>
        <li>Shows all existing volumes:</li>
<pre><code class="language-bash line-numbers">docker volume ls</code></pre>
        <br/>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">DRIVER    VOLUME NAME
local     mydata
local     db-volume
</code></pre>
        </li>
        <br/>
        <li><u>DRIVER</u> is usually <code>local</code>, the default storage backend.</li>
    </ul>
    <br/><br/>


    <li>Creating a New Volume</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker volume create mydata</code></pre>
        <br/>
        <li>Explanation: <code>mydata</code> is the name of the new volume</li>
        <br/>
        <li>Volumes are created empty and ready to be mounted into containers.</li>
    </ul>
    <br/><br/>


    <li>Inspecting a Volume</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker volume inspect mydata</code></pre>
        <br/>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">[
    {
        "Name": "mydata",
        "Mountpoint": "/var/lib/docker/volumes/mydata/_data",
        "Driver": "local"
    }
]
</code></pre>
        </li>
        <li>Explanation:</li>
        <ul>
            <li><code>Mountpoint</code> is the actual storage location on host</li>
            <li><code>Driver</code> is the storage backend</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Using a Volume with <code>docker run</code></li>
    <br/>
    <ul>
        <li>Example: mount a volume to a container:</li>
<pre><code class="language-bash line-numbers">docker run -d --name db     \
  -v mydata:/var/lib/mysql  \
  mysql:8
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>-v mydata:/var/lib/mysql</code> mounts the volume <code>mydata</code> to MySQL data folder inside the container</li>
            <li><code>/var/lib/mysql</code> is the path inside container</li>
            <li>All MySQL data becomes persistent</li>
        </ul>
        <br/>
        <li>If the container is removed, the volume persists.</li>
    </ul>
    <br/><br/>


    <li>Creating and Mounting Volume Automatically</li>
    <br/>
    <ul>
        <li>If you use a volume that doesn’t exist:</li>
<pre><code class="language-bash line-numbers">docker run -v newvol:/data alpine
</code></pre>
        <li>Docker will automatically create <code>newvol</code>.</li>
    </ul>
    <br/><br/>


    <li>Viewing Mounted Volumes Inside a Container</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker inspect container-name</code></pre>
        <li>Then look under <code>.Mounts</code> for volume configuration.</li>
    </ul>
    <br/><br/>


    <li>Removing a Volume (<code>docker volume rm</code>)</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker volume rm mydata</code></pre>
    <li>Important: You can <u>not</u> remove a volume that is currently in use by a container.</li>
    </ul>
    <br/><br/>


    <li>Removing All Unused Volumes — <code>docker volume prune</code></li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker volume prune</code></pre>
        <li>Explanation:</li>
        <ul>
            <li>Deletes all volumes not referenced by any container</li>
            <li>Helpful for cleaning disk space</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Difference Between Volumes, Bind Mounts, and tmpfs</li>
    <br/>
    <ul>
        <li><code>Volumes</code> are managed by Docker, best for persistence.</li>
        <br/>
        <li><code>Bind mounts</code> map a specific host directory:</li>
<pre><code class="language-bash line-numbers">docker run -v /host/path:/container/path app
</code></pre>
        <li><code>tmpfs</code> is memory-only storage:</li>
<pre><code class="language-bash line-numbers">docker run --tmpfs /cache app
</code></pre>
    </ul>
    <br/><br/>


    <li>Example: Persisting PostgreSQL Data</li>
<pre><code class="language-bash line-numbers">docker volume create pgdata

docker run -d                        \
  --name pg                          \
  -e POSTGRES_PASSWORD=12345         \
  -v pgdata:/var/lib/postgresql/data \
  postgres:15
</code></pre>
    <ul>
        <li>Now database data persists across container restarts or removals.</li>
    </ul>
    <br/><br/>


    <li>Example: Sharing a Volume Between Multiple Containers</li>
<pre><code class="language-bash line-numbers">docker run -d --name c1 -v sharedvol:/data alpine
docker run -d --name c2 -v sharedvol:/data alpine
</code></pre>
    <ul>
        <li>Both containers share the same storage location.</li>
    </ul>
    <br/><br/>


    <li>Where Docker Volumes Are Stored on Host</li>
    <br/>
    <ul>
        <li>Default path:</li>
<pre><code class="language-plaintext line-numbers">/var/lib/docker/volumes/[VOLUME_NAME]/_data
</code></pre>
        <li>But you should not directly modify those files unless necessary.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-network-command">Understanding the <code>docker network</code> Command</h3>
<ol>

    <li>What Is <code>docker network</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker network</code> command manages Docker's virtual networks that containers use to communicate with each other and the outside world.</li>
        <br/>
        <li>Docker networks allow you to:</li>
        <ul>
            <li>connect containers together</li>
            <li>isolate services</li>
            <li>assign custom IP ranges</li>
            <li>control DNS resolution inside Docker</li>
            <li>create multi-container apps</li>
        </ul>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-plaintext line-numbers">docker network [COMMAND]</code></pre>
    </ul>
    <br/><br/>


    <li>Listing Existing Docker Networks</li>
    <ul>
<pre><code class="language-bash line-numbers">docker network ls</code></pre>
        <li>Example output:</li>
<pre><code class="language-plaintext line-numbers">NETWORK ID     NAME      DRIVER    SCOPE
ad8c32f1c012   bridge    bridge    local
bfd9a1023cd2   host      host      local
cd1fc8c98bb1   none      null      local
</code></pre>
        <li>Default networks:</li>
        <ul>
            <li><code>bridge</code> → default virtual network for containers</li>
            <li><code>host</code> → container shares host networking stack</li>
            <li><code>none</code> → no networking</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Creating a Custom Network</li>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-bash line-numbers">docker network create mynet</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>mynet</code> is the name of the new network</li>
            <li>Driver defaults to <code>bridge</code></li>
        </ul>
        <br/>
        <li>Custom networks allow automatic container name-based DNS.</li>
    </ul>
    <br/><br/>


    <li>Creating a Network with Custom Subnet and Gateway</li>
    <ul>
<pre><code class="language-bash line-numbers">docker network create           \
    --subnet=192.168.10.0/24    \
    --gateway=192.168.10.1      \
    mycustomnet
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>--subnet</code> is the CIDR block for IP allocation</li>
            <li><code>--gateway</code> is the network gateway</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Inspecting a Network</li>
<pre><code class="language-bash line-numbers">docker network inspect mynet</code></pre>
    <ul>
        <li>Example output section:</li>
    </ul>
<pre><code class="language-plaintext line-numbers">{
    "Name": "mynet",
    "Driver": "bridge",
    "Containers": {
        "abcd1234": {
            "Name": "web",
            "IPv4Address": "172.18.0.2/16"
        }
    }
}
</code></pre>
    <br/><br/>


    <li>Running a Container Attached to a Network</li>
<pre><code class="language-bash line-numbers">docker run -d --name webapp --network mynet nginx
</code></pre>
    <ul>
        <li>Explanation: <code>--network mynet</code> → container joins the <code>mynet</code> network</li>
        <br/>
        <li>Containers on the same network can reach each other by name.</li>
    </ul>
    <br/><br/>


    <li>Connecting an Existing Container to a Network</li>
<pre><code class="language-bash line-numbers">docker network connect mynet backend</code></pre>
    <ul>
        <li>Explanation:</li>
        <ul>
            <li><code>mynet</code> is the network</li>
            <li><code>backend</code> is the existing container</li>
        </ul>
        <br/>
        <li>This allows dynamic network changes without restarting containers.</li>
    </ul>
    <br/><br/>


    <li>Disconnecting a Container from a Network</li>
<pre><code class="language-bash line-numbers">docker network disconnect mynet backend</code></pre>
    <ul>
        <li>Explanation: it removes the <code>backend</code> container from <code>mynet</code></li>
    </ul>
    <br/><br/>


    <li>Removing a Docker Network</li>
<pre><code class="language-bash line-numbers">docker network rm mynet</code></pre>
    <ul>
        <li>Important: you cannot remove a network while containers are attached</li>
    </ul>
    <br/><br/>


    <li>Removing All Unused Networks — <code>docker network prune</code></li>
<pre><code class="language-bash line-numbers">docker network prune</code></pre>
    <ul>
        <li>Deletes all networks not being used by any container.</li>
    </ul>
    <br/><br/>


    <li>Understanding Docker Network Drivers</li>
    <br/>
    <ul>
        <li>Docker supports multiple network drivers:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Network Driver</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>bridge</code></td>
            <td>Default driver; best for communication between local containers.</td>
        </tr>
        <tr>
            <td><code>host</code></td>
            <td>Container shares the host's network stack directly.</td>
        </tr>
        <tr>
            <td><code>none</code></td>
            <td>Disables networking entirely.</td>
        </tr>
        <tr>
            <td><code>overlay</code></td>
            <td>Used for multi-host networking in Docker Swarm.</td>
        </tr>
        <tr>
            <td><code>macvlan</code></td>
            <td>Assigns each container its own MAC address on the physical LAN.</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Most users only need <code>bridge</code>.</li>
    </ul>
    <br/><br/>


    <li>Example: Two Containers Talking to Each Other</li>
    <br/>
    <ul>
        <li>Create network:</li>
<pre><code class="language-bash line-numbers">docker network create appnet</code></pre>
        <br/>
        <li>Start containers:</li>
<pre><code class="language-bash line-numbers">docker run -d --name api --network appnet node:18
docker run -d --name web --network appnet nginx
</code></pre>
        <br/>
        <li>Now inside <code>web</code> container:</li>
<pre><code class="language-bash line-numbers">curl http://api:3000
</code></pre>
        <br/>
        <li><code>api</code> is resolved by Docker DNS!</li>
    </ul>
    <br/><br/>


    <li>Example: Static IP Assignment</li>
<pre><code class="language-bash line-numbers">
docker network create --subnet=172.20.0.0/16 appnet

docker run -d --name app1 --network appnet --ip 172.20.0.10 alpine
docker run -d --name app2 --network appnet --ip 172.20.0.11 alpine
</code></pre>
    <ul>
        <li>Allows fixed IPs for legacy systems.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-daemon-overview">Understanding the Docker Daemon (dockerd)</h3>
<ol>

    <li>What Is the Docker Daemon?</li>
    <br/>
    <ul>
        <li>The <b>Docker daemon</b> (the process named <code>dockerd</code>) is the <b>system-level background service</b> responsible for managing every Docker operation.</li>
        <br/>
        <li>It runs continuously in the background and handles:
            <ul>
                <li>container lifecycle (start, stop, restart)</li>
                <li>building and running images</li>
                <li>networking between containers</li>
                <li>storage (volumes, layers)</li>
                <li>pulling/pushing images from registries</li>
                <li>API communication with Docker CLI</li>
            </ul>
        </li>
        <br/>
        <li>The daemon exposes a REST API that the <code>docker</code> CLI communicates with.</li>
        <br/>
        <li>Process name on Linux:</li>
<pre><code class="language-plaintext line-numbers">/usr/bin/dockerd</code></pre>
    </ul>
    <br/><br/>


    <li>Architecture: How Docker CLI Talks to the Daemon</li>
    <br/>
    <ul>
        <li>Docker uses a client–server architecture:</li>

<pre><code class="language-plaintext line-numbers">
+----------------------+           +-----------------+
|  Docker CLI (client) |  -----&gt;   |  Docker Daemon  |
|  "docker run ..."    |   API     |  dockerd        |
+----------------------+           +-----------------+
                                         |
                                         v
                                Containers, Images,
                                Volumes, Networks
</code></pre>
        <br/>
        <li>You never interact with containers directly — everything goes through the daemon’s API.</li>
    </ul>
    <br/><br/>


    <li>Why the Docker Daemon Requires Root Privileges</li>
    <br/>
    <ul>
        <li>Historically, <code>dockerd</code> runs as <code>root</code> because it manages:
            <ul>
                <li>network namespaces</li>
                <li>cgroups (CPU/memory control)</li>
                <li>iptables firewall rules</li>
                <li>mounting filesystems</li>
                <li>kernel features for containers</li>
            </ul>
        </li>
        <br/>
        <li>These are privileged operations → only root can perform them.</li>
        <br/>
        <li>Therefore:
            <ul>
                <li>Docker daemon runs as <code>root</code></li>
                <li>the <code>docker</code> CLI communicates with it over a privileged Unix socket at <code>/var/run/docker.sock</code></li>
            </ul>
        </li>
        <br/>
        <li>This root-level nature is the source of many security concerns.</li>
    </ul>
    <br/><br/>


    <li>The Famous Security Problem: Access to <code>/var/run/docker.sock</code></li>
    <br/>
    <ul>
        <li>If a user can access this socket, they effectively have <b>root permissions on the host machine</b>.</li>
        <br/>
        <li>This means:
            <ul>
                <li>They can mount root filesystem</li>
                <li>Launch privileged containers</li>
                <li>Run commands as root</li>
                <li>Modify system files</li>
            </ul>
        </li>
        <br/>
        <li>For example:</li>
<pre><code class="language-bash line-numbers">docker run -v /:/host -it ubuntu chroot /host
</code></pre>
        <li>This gives full root access to the host.</li>
        <br/>
        <li><b>This is why giving users Docker access is equivalent to giving them sudo.</b></li>
    </ul>
    <br/><br/>


    <li>Rootless Docker: Attempt to Solve the Problem</li>
    <br/>
    <ul>
        <li>Docker now supports <b>rootless mode</b>, where <code>dockerd</code> runs as a normal user.</li>
        <br/>
        <li>Benefits:</li>
        <ul>
            <li>No root privileges required</li>
            <li>Safer in multi-user environments</li>
            <li>User cannot modify critical system structures</li>
        </ul>
        <br/>
        <li>Limitations:</li>
        <ul>
            <li>Cannot use privileged ports (&lt;1024)</li>
            <li>Weaker performance in some operations</li>
            <li>Networking is more limited</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Why Kubernetes Stopped Using Docker as Runtime</li>
    <br/>
    <ul>
        <li>Kubernetes deprecated Docker as a container runtime because:</li>
        <ul>
            <li>It depends on the system-level daemon</li>
            <li>Not compliant with Kubernetes CRI (Container Runtime Interface)</li>
            <li>Kubernetes prefers <b>containerd</b> and <b>CRI-O</b></li>
        </ul>
        <br/>
        <li><b>Important:</b> Kubernetes still uses Docker images, but NOT the Docker daemon.</li>
    </ul>
    <br/><br/>


    <li>Alternatives to Docker That Avoid the Daemon</li>
    <br/>
    <ul>
        <li>Tools like <b>Podman</b> avoid the daemon entirely.</li>
        <br/>
        <li>Podman features:</li>
        <ul>
            <li>Daemonless</li>
            <li>Rootless by default</li>
            <li>Docker CLI compatible (<code>alias docker=podman</code>)</li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-compose-command">Understanding the <code>docker compose</code> Command</h3>
<ol>

    <li>What Is <code>docker compose</code>?</li>
    <br/>
    <ul>
        <li>The <code>docker compose</code> command is used to run multi-container applications using a single configuration file: <code>docker-compose.yml</code>.</li>
        <br/>
        <li>Purpose:</li>
        <ul>
            <li>Start multiple services (containers) together</li>
            <li>Create networks automatically</li>
            <li>Create volumes automatically</li>
            <li>Define environment variables, ports, dependencies</li>
            <li>Manage an entire stack with one command</li>
        </ul>
        <br/>
        <li> Docker Compose is ideal for:</li>
        <ul>
            <li>Web applications</li>
            <li>Microservices</li>
            <li>Local development environments</li>
            <li>Database + application stacks</li>
        </ul>
        <br/>
        <li>Newer versions use:</li>
<pre><code class="language-plaintext line-numbers">docker compose</code></pre>
        <br/>
        <li>(not <code>docker-compose</code> with a hyphen).</li>
    </ul>
    <br/><br/>


    <li>Understanding the <code>docker-compose.yml</code> Structure</li>
    <br/>
    <ul>
        <li>A basic example:</li>
<pre><code class="language-yaml line-numbers">version: "3.9"
services:
  web:
    image: nginx
    ports:
      - "8080:80"
  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: 12345
</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>version</code> → Compose schema version</li>
            <li><code>services</code> → each container definition</li>
            <li><code>web</code> → first service</li>
            <li><code>db</code> → second service</li>
            <li>Compose will:
                <ul>
                    <li>create a shared network</li>
                    <li>allow <code>web</code> to connect to <code>db</code> by name</li>
                </ul>
            </li>
        </ul>
    </ul>
    <br/><br/>


    <li>Starting a Compose Application — <code>docker compose up</code></li>
    <br/>
    <ul>
        <li>Run everything defined in <code>docker-compose.yml</code>:</li>
<pre><code class="language-bash line-numbers">docker compose up</code></pre>
        <li>Foreground mode: streams logs of all services.</li>
        <br/>
        <li>Run in background:</li>
<pre><code class="language-bash line-numbers">docker compose up -d</code></pre>
        <li>What happens under the hood?</li>
        <ul>
            <li>Networks created</li>
            <li>Volumes created (if any)</li>
            <li>Containers started in dependency order</li>
            <li>Name format: <code>foldername_service_index</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li>Stopping a Compose Application — <code>docker compose down</code></li>
    <ul>
<pre><code class="language-bash line-numbers">docker compose down</code></pre>
        <li>Removes:</li>
        <ul>
            <li>containers</li>
            <li>networks created by Compose</li>
        </ul>
        <br/>
        <li>Does NOT remove:
            <ul>
                <li>named volumes</li>
                <li>images</li>
            </ul>
        </li>
        <br/>
        <li>Remove volumes too:</li>
<pre><code class="language-bash line-numbers">docker compose down -v</code></pre>
    </ul>
    <br/><br/>


    <li>Viewing Logs — <code>docker compose logs</code></li>
    <ul>
<pre><code class="language-bash line-numbers">docker compose logs</code></pre>
        <li>Real-time logs:</li>
<pre><code class="language-bash line-numbers">docker compose logs -f</code></pre>
        <li>Logs from specific service:</li>
<pre><code class="language-bash line-numbers">docker compose logs web</code></pre>
    </ul>
    <br/><br/>


    <li>Listing All Services — <code>docker compose ps</code></li>
    <ul>
<pre><code class="language-bash line-numbers">docker compose ps</code></pre>
        <li>Shows container status and exposed ports.</li>
    </ul>
    <br/><br/>


    <li>Building Images — <code>docker compose build</code></li>
    <br/>
    <ul>
        <li>If your service uses a <code>Dockerfile</code>:</li>
<pre><code class="language-bash line-numbers">docker compose build</code></pre>
        </li>
        <br/>
        <li>Force rebuild (ignore cache):</li>
<pre><code class="language-bash line-numbers">docker compose build --no-cache</code></pre>
        <br/>
        <li>Build a specific service:</li>
<pre><code class="language-bash line-numbers">docker compose build web</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Running Commands in Services — <code>docker compose exec</code></li>
    <br/>
    <ul>
        <li>Example: open a shell in <code>db</code> service:</li>
<pre><code class="language-bash line-numbers">docker compose exec db bash</code></pre>
        <li>If the container only has <code>sh</code>:</li>
<pre><code class="language-bash line-numbers">docker compose exec db sh</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Viewing Container Resource Usage — <code>docker compose top</code></li>
<pre><code class="language-bash line-numbers">docker compose top</code></pre>
    <ul>
        <li>Shows running processes inside services.</li>
    </ul>
    <br/><br/>


    <li>Stopping and Starting Individual Services</li>
    <br/>
    <ul>
        <li>Stop one service:</li>
<pre><code class="language-bash line-numbers">docker compose stop web</code></pre>
        <br/>
        <li>Start one service:</li>
<pre><code class="language-bash line-numbers">docker compose start web</code></pre>
    </ul>
    <br/><br/>


    <li>Scaling Services — <code>--scale</code></li>
<pre><code class="language-bash line-numbers">docker compose up -d --scale web=3</code></pre>
    <ul>
        <li>Runs 3 instances of the <code>web</code> service.</li>
        <br/>
        <li>Great for load-balancing demos or worker clusters.</li>
    </ul>
    <br/><br/>


    <li>Using Environment Files</li>
    <br/>
    <ul>
        <li>Inside <code>docker-compose.yml</code>:</li>
<pre><code class="language-yaml line-numbers">services:
    app:
        env_file:
            - .env
</code></pre>
        <br/>
        <li>Your <code>.env</code> file:</li>
<pre><code class="language-plaintext line-numbers">API_KEY=12345
DEBUG=true
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Example: Web + Database Compose Setup</li>
    <br/>
    <ul>
        <li>A common stack:</li>
<pre><code class="language-yaml line-numbers">services:
    web:
        image: nginx
        ports:
            - "8080:80"
        depends_on:
            - db

    db:
        image: postgres
        environment:
            POSTGRES_PASSWORD: secret
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>depends_on</code> ensures DB starts before web</li>
            <li>Both share an automatically created network</li>
            <li>Web can reach DB via hostname <code>db</code></li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="docker-compose-yml">How to Write a <code>docker-compose.yml</code> File</h3>
<ol>

    <li>What Is <code>docker-compose.yml</code>?</li>
    <br/>
    <ul>
        <li><code>docker-compose.yml</code> is a YAML configuration file that describes a <b>multi-container application</b>.</li>
        <br/>
        <li>In this file you define:
            <ul>
                <li>which services (containers) exist</li>
                <li>which images they use or how they are built</li>
                <li>ports to expose</li>
                <li>volumes to persist data</li>
                <li>environment variables</li>
                <li>networks and dependencies</li>
            </ul>
        </li>
        <br/>
        <li>Once defined, you can start everything with a single command:</li>
<pre><code class="language-bash line-numbers">docker compose up</code></pre>
        <br/>
        <li>YAML is whitespace-sensitive, so indentation (2 spaces) is extremely important.</li>
    </ul>
    <br/><br/>


    <li>Basic Structure of a Compose File</li>
    <br/>
    <ul>
        <li>A minimal structure looks like this:</li>
<pre><code class="language-yaml line-numbers">services:
  servicename:
    image: some-image
</code></pre>
        <br/>
        <li>Common top-level keys:
            <ul>
                <li><code>version</code> (optional in newer Compose specs)</li>
                <li><code>services</code> → your containers</li>
                <li><code>volumes</code> &nbsp; → named volumes (optional)</li>
                <li><code>networks</code> → named networks (optional)</li>
            </ul>
        </li>
        <br/>
        <li>We will build up a realistic example step by step: a simple web app + database.</li>
    </ul>
    <br/><br/>


    <li>Step 1: Start with <code>services</code></li>
    <br/>
    <ul>
        <li>Every Compose file starts by defining your services:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    # web service config will go here
  db:
    # database service config will go here
</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>services:</code> → top-level key</li>
            <li><code>web:</code> → name of first service (later becomes container name prefix)</li>
            <li><code>db:</code> &nbsp; → name of second service</li>
        </ul>
        <br/>
        <li>Service names are how containers talk to each other via DNS (e.g. <code>web</code> can reach <code>db</code> using hostname <code>db</code>).</li>
    </ul>
    <br/><br/>


    <li>Step 2: Choose <code>image</code> or <code>build</code> for Each Service</li>
    <br/>
    <ul>
        <li>You can either:
            <ul>
                <li>use an existing image from Docker Hub → <code>image:</code></li>
                <li>build your own image from a Dockerfile → <code>build:</code></li>
            </ul>
        </li>
        <br/>

        <li>Example: <code>web</code> uses a local Dockerfile, <code>db</code> uses official Postgres image</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
  db:
    image: postgres:15
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>build: ./web</code> → Docker will look for a <code>Dockerfile</code> in the <code>./web</code> directory.</li>
            <li><code>image: postgres:15</code> → pulls and runs the official <code>postgres</code> image tag <code>15</code>.</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 3: Expose Ports with <code>ports</code></li>
    <br/>
    <ul>
        <li>To access your service from the host machine, map host port → container port:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
    ports:
      - "8080:80"
</code></pre>
        <li>Explanation of <code>"8080:80"</code>:</li>
        <ul>
            <li><code>8080</code> is the host port (browser will connect to <code>localhost:8080</code>)</li>
            <li><code>80</code> is the port inside container (your app listens on <code>80</code>)</li>
        </ul>
        <br/>
        <li>You can define multiple ports as a YAML list:</li>
<pre><code class="language-yaml line-numbers">ports:
  - "8080:80"
  - "8443:443"
</code></pre>
    </ul>
    <br/><br/>


    <li>Step 4: Add Environment Variables with <code>environment</code></li>
    <br/>
    <ul>
        <li>Environment variables configure things like passwords, modes, etc.</li>
        <br/>
        <li>Example for Postgres:</li>
<pre><code class="language-yaml line-numbers">services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: secret123
      POSTGRES_DB: appdb
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>environment:</code> is a map of key/value pairs</li>
            <li><code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_DB</code> are variables understood by the Postgres image</li>
        </ul>
        <br/>
        <li>You can also load from a <code>.env</code> file using <code>env_file</code>, but for learning, inline variables are clearer.</li>
    </ul>
    <br/><br/>


    <li>Step 5: Persist Data with <code>volumes</code></li>
    <br/>
    <ul>
        <li>Database data must survive container restarts → use a named volume.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-yaml line-numbers">services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret123
    volumes:
      - dbdata:/var/lib/postgresql/data

volumes:
  dbdata:
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li>Service-level <code>volumes:</code>: <code>dbdata:/var/lib/postgresql/data</code> mounts named volume <code>dbdata</code> into container data directory.</li>
            <li>Top-level <code>volumes:</code>: <code>dbdata:</code> declares the named volume so Docker knows it exists.</li>
        </ul>
        <br/>
        <li>Now deleting the <code>db</code> container will not delete your database data.</li>
    </ul>
    <br/><br/>


    <li>Step 6: Define Networks (Optional but Helpful)</li>
    <br/>
    <ul>
        <li>By default, Compose creates one network for your project and puts all services inside it.</li>
        <br/>
        <li>You can explicitly define networks to be more clear:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
    networks:
      - appnet

  db:
    image: postgres:15
    networks:
      - appnet

networks:
  appnet:
</code></pre>
        <br/>
        <li>Explanation:</li>
        <ul>
            <li><code>networks:</code> under each service, attaches the service to the <code>appnet</code> network.</li>
            <li>Top-level <code>networks:</code> defines the named network.</li>
        </ul>
        <br/>
        <li>Within the same network: <code>web</code> can reach database using <code>db:5432</code></li>
    </ul>
    <br/><br/>


    <li>Step 7: Control Start Order with <code>depends_on</code></li>
    <br/>
    <ul>
        <li>Web service should wait for DB to at least start its container.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
    depends_on:
      - db

  db:
    image: postgres:15
</code></pre>
        <br/>
        <li>Explanation: <code>depends_on:</code> list → tells Compose to start <code>db</code> before <code>web</code>.</li>
        <br/>
        <li>Note: this checks container start order, not full DB readiness. For production, you’d often add retry logic in your app or use healthchecks.</li>
    </ul>
    <br/><br/>


    <li>Step 8: Override Commands with <code>command</code> and <code>restart</code> Policy</li>
    <br/>
    <ul>
        <li>You can replace the default command of the image using <code>command</code>:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
    command: ["python", "app.py"]
</code></pre>
        <li>Explanation:</li>
        <ul>
            <li><code>command:</code> accepts either a string or YAML list.</li>
            <li>Here it runs <code>python app.py</code> inside the container.</li>
        </ul>
        <br/>
        <li>Add a restart policy, e.g. auto-restart on failure:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
    restart: on-failure
</code></pre>
        <li>Common values for <code>restart</code>:
            <ul>
                <li><code>no</code> (default)</li>
                <li><code>on-failure</code></li>
                <li><code>always</code></li>
                <li><code>unless-stopped</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Step 9: Full Example – Simple Web + Postgres Stack</li>
    <br/>
    <ul>
        <li>Here is a complete, consistent <code>docker-compose.yml</code> that uses everything we discussed:</li>
<pre><code class="language-yaml line-numbers">services:
  web:
    build: ./web
    ports:
      - "8080:80"
    environment:
      DATABASE_HOST: db
      DATABASE_NAME: appdb
      DATABASE_USER: appuser
      DATABASE_PASSWORD: secret123
    depends_on:
      - db
    networks:
      - appnet
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: secret123
      POSTGRES_DB: appdb
    volumes:
      - dbdata:/var/lib/postgresql/data
    networks:
      - appnet
    restart: unless-stopped

volumes:
  dbdata:

networks:
  appnet:
</code></pre>
        <br/>
        <li>How the pieces connect:</li>
        <ul>
            <li><code>web</code>:
                <ul>
                    <li>built from <code>./web</code> directory</li>
                    <li>accessible on <code>localhost:8080</code></li>
                    <li>knows DB connection details via environment variables</li>
                    <li>shares network <code>appnet</code> with <code>db</code></li>
                </ul>
            </li>
            <li><code>db</code>:
                <ul>
                    <li>uses official <code>postgres:15</code> image</li>
                    <li>stores data in named volume <code>dbdata</code></li>
                    <li>exposed internally as host <code>db</code> on port <code>5432</code> to <code>web</code></li>
                </ul>
            </li>
            <li><code>volumes</code> / <code>networks</code> declared at bottom:
                <ul>
                    <li><code>dbdata</code> persists data</li>
                    <li><code>appnet</code> connects the two services</li>
                </ul>
            </li>
        </ul>
    </ul>
    <br/><br/>


    <li>Step 10: Using the Compose File</li>
    <br/>
    <ul>
        <li>Save the YAML content into <code>docker-compose.yml</code> at your project root.</li>
        <br/>
        <li>Then run:</li>
<pre><code class="language-bash line-numbers">docker compose up</code></pre>
        <br/>
        <li>Run in background:</li>
<pre><code class="language-bash line-numbers">docker compose up -d</code></pre>
        <br/>
        <li>Stop and clean up containers and network:</li>
<pre><code class="language-bash line-numbers">docker compose down</code></pre>
        <br/>
        <li>Stop and also remove volumes:</li>
<pre><code class="language-bash line-numbers">docker compose down -v</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
