<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>My Insights About Compiler Design</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }

    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }

    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/compiler.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#compiler-intro">Introduction</a></li>
        <li><a href="#compiler-phases">Phases</a></li>
        <li><a href="#compiler-lexical-analyzer">Lexical Analyzer</a></li>
        <li><a href="#compiler-dfa-intro">Deterministic Finite Automata (DFA)</a></li>
        <li><a href="#compiler-left-refactoring">Left Refactoring</a></li>
        <li><a href="#compiler-predictive-parsing">Predictive Parsing</a></li>
        <li><a href="#laotzus">A Simple Compiler I Wrote When I Was About 9 ~ 10</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-intro">Introduction to Compiler Design</h3>
<ol>
    <li><mark>NOTE</mark>:<br/>
        I'm not a professional computer scientist, so the whole content here is based on my poor knowledge.<br/>
        Therefore, it might contain inefficient thinking ways or even wrong thinking ways. I do not assume any responsibility from it.
        <br/>That's it, thanks for your understanding.</li>
    <br/>

    <li><b>What Is a Compiler?</b></li>
    <ul>
        <li>A <u>compiler</u> is a program that transforms source code written in one language
            (e.g., C, Rust, TypeScript) into another form (usually machine code, bytecode, or another high-level language).</li>
        <li>Examples of compilers:
            <ul>
                <li>
                    GCC / Clang
                </li>
                <li>
                    Rustc
                </li>
            </ul>
        </li>
        </li>
    </ul>

    <br/><br/>


    <li><b>The Big Picture: Stages of a Compiler</b></li>
    <br/>
    <ol>
        <li><b>Lexical Analysis</b> (tokenization)</li>
        <ul>
            <li>Breaks raw text into tokens: keywords, identifiers, literals, symbols.</li>
            <li>Example: <code>a = 3 + b</code> → <code>[ID("a"), '=', INT(3), '+', ID("b")]</code></li>
        </ul>
        <br/>

        <li><b>Syntax Analysis</b> (parsing)</li>
        <ul>
            <li>Builds a tree structure called an <u>AST</u> (Abstract Syntax Tree).</li>
            <li>Example: <code>3 + u</code> becomes a <u>binary operation node</u>.</li>
        </ul>
        <br/>

        <li><b>Semantic Analysis</b></li>
        <ul>
            <li>Checks correctness:
                <ul>
                    <li>types</li>
                    <li>scope</li>
                    <li>variable declarations</li>
                    <li>function signatures</li>
                </ul>
            </li>
            <li>Example: <code>"abc" + 5</code> is invalid in many languages.</li>
        </ul>
        <br/>

        <li><b>Intermediate Representation</b> (IR)</li>
        <ul>
            <li>The AST is transformed into a lower-level language closer to machine operations.</li>
            <li>Common IRs:
                <ul>
                    <li>LLVM IR</li>
                    <li>bytecode</li>
                    <li>three-address code (TAC)</li>
                </ul>
            </li>
        </ul>
        <br/>

        <li><b>Optimization</b></li>
        <ul>
            <li>The compiler improves your code:
                <ul>
                    <li>dead code elimination</li>
                    <li>constant folding</li>
                    <li>loop optimizations</li>
                    <li>register allocation</li>
                </ul>
            </li>
        </ul>
        <br/>

        <li><b>Code Generation</b></li>
        <ul>
            <li>Final stage: output machine code, bytecode, JS, etc.</li>
        </ul>
    </ol>

    <br/><br/>


    <li><b>Compiler vs Interpreter</b></li>
    <br/>
    <ul>
        <li><b>Compilers</b>: translate entire program before running.</li>
        <li><b>Interpreters</b>: execute code step-by-step.</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Compiler</th>
                <th>Interpreter</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Produces binary or bytecode</td>
                <td>Runs line-by-line</td>
            </tr>
            <tr>
                <td>Faster execution</td>
                <td>More flexible debugging</td>
            </tr>
            <tr>
                <td>Example: C, Rust</td>
                <td>Example: Python, Ruby</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>The AST (Abstract Syntax Tree)</b></li>
    <br/>
    <ul>
        <li>The AST is the core internal structure produced by the parser.</li>
        <li>Example AST for <code>1 + 2 * 3</code>:</li>
    </ul>

<pre><code class="language-text line-numbers">Add
 ├── Int(1)
 └── Mul
      ├── Int(2)
      └── Int(3)
</code></pre>

    <ul>
        <li>The tree respects precedence: multiplication evaluated before addition.</li>
    </ul>

    <br/><br/>


    <li><b>Intermediate Representation (IR)</b></li>
    <br/>
    <ul>
        <li>An IR is a lower-level representation used for:
            <ul>
                <li>optimization</li>
                <li>analysis</li>
                <li>machine-code generation</li>
            </ul>
        </li>
        <li>A simple “three-address code” example:</li>
    </ul>

<pre><code class="language-text line-numbers">t1 = 2 * 3
t2 = 1 + t1
</code></pre>

    <ul>
        <li>LLVM IR is a real-world example:</li>
    </ul>

<pre><code class="language-llvm line-numbers">%t1 = mul i32 2, 3
%t2 = add i32 1, %t1
</code></pre>

    <br/><br/>


    <li><b>Optimizations</b></li>
    <br/>
    <ul>
        <li>Compilers apply many optimizations automatically:</li>
        <ul>
            <li><b>constant folding</b>: <code>2 * 3</code> → <code>6</code></li>
            <li><b>dead code elimination</b>: remove unused variables</li>
            <li><b>inlining</b>: replace function calls with their bodies</li>
            <li><b>loop unrolling</b></li>
            <li><b>common subexpression elimination</b></li>
        </ul>
    </ul>

    <br/><br/>


    <li><b>Back Ends and Code Generation</b></li>
    <br/>
    <ul>
        <li>The back end turns IR into:
            <ul>
                <li>machine code (x86, ARM)</li>
                <li>bytecode (Python, Java)</li>
                <li>another language (TS → JS)</li>
            </ul>
        </li>
        <li>Example: LLVM back end produces machine instructions:</li>
    </ul>

<pre><code class="language-nasm line-numbers">mov eax, 2
imul eax, 3
add eax, 1
</code></pre>

    <br/><br/>


    <li><b>Front-End vs Back-End</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Front-End</th>
                <th>Back-End</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lexing</td>
                <td>IR to machine code</td>
            </tr>
            <tr>
                <td>Parsing</td>
                <td>Register allocation</td>
            </tr>
            <tr>
                <td>Semantic analysis</td>
                <td>Optimization passes</td>
            </tr>
            <tr>
                <td>AST generation</td>
                <td>Instruction scheduling</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-phases">Different Phases of a Compiler</h3>
<ol>

    <li><b>Prior Knowledge</b></li>
    <br/>
    <ul>
        <li>A compiler transforms <b>source code</b> written in a high-level language (like C, Rust, or Haskell) into <b>machine code</b> or an <b>intermediate form</b>.</li>
        <br/>
        <li>This transformation happens in several well-structured phases.</li>
        <br/>
        <li>Each phase handles one part of the job:
            <ul>
                <li>understanding the program,</li>
                <li>checking for correctness,</li>
                <li>optimizing,</li>
                <li>and generating low-level code.</li>
            </ul>
        </li>
        <br/>
        <li>Although implementations vary between compilers (e.g., GCC, LLVM Clang, Rustc), the overall architecture remains similar.</li>
    </ul>
    <br/><br/>


    <li><b>Lexical Analysis (Scanning)</b></li>
    <br/>
    <ul>
        <li>The first phase of compilation.</li>
        <br/>
        <li>Converts a raw source code string into a sequence of <b>tokens</b>.</li>
        <br/>
        <li>A token is a meaningful atomic unit:
            <ul>
                <li>keywords (<code>if</code>, <code>while</code>)</li>
                <li>identifiers (<code>x</code>, <code>count</code>)</li>
                <li>literals (<code>10</code>, <code>"hello"</code>)</li>
                <li>operators (<code>+</code>, <code>*</code>, <code>==</code>)</li>
                <li>punctuation (<code>;</code>, <code>(</code>, <code>)</code>)</li>
            </ul>
        </li>
        <br/>
        <li>A <b>lexer</b> removes:
            <ul>
                <li>spaces,</li>
                <li>comments,</li>
                <li>line breaks,</li>
                <li>unnecessary formatting.</li>
            </ul>
        </li>
        <br/>
        <li>Example:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Source:     x = 3 + 5;
Tokens:     IDENTIFIER("x"), EQUALS, NUMBER(3), PLUS, NUMBER(5), SEMICOLON

Or in more details as
Tokens:     IDENTIFIER("x"), OPERATOR("="), NUMBER(3), OPERATOR("+"), NUMBER(5), PUNCTUATION(";")
</code></pre>

    <br/><br/>


    <li><b>Syntax Analysis (Parsing)</b></li>
    <br/>
    <ul>
        <li>Given the sequence of tokens, the <b>parser</b> checks whether the code follows the grammatical structure of the language.</li>
        <br/>
        <li>It produces an <b>AST</b> (Abstract Syntax Tree), a hierarchical representation of the program.</li>
        <br/>
        <li>Example: <code>x = 3 + 5</code> becomes:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">      Assignment
     /          \
   Variable     Add
    |          /   \
   "x"        3     5
</code></pre>

    <br/>
    <ul>
        <li>The parser enforces:
            <ul>
                <li>operator precedence,</li>
                <li>parentheses grouping,</li>
                <li>valid statements and expressions.</li>
            </ul>
        </li>
        <br/>
        <li>Parser types:
            <ul>
                <li>Top-down: LL(k), recursive-descent (easy to implement)</li>
                <li>Bottom-up: LR(k), LALR, GLR (used by many production compilers)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Semantic Analysis</b></li>
    <br/>
    <ul>
        <li>The semantic analyzer checks for <b>meaningful correctness</b> of the AST.</li>
        <br/>
        <li>Examples of semantic checks:</li>
        <ul>
            <li>Type checking</li>
            <li>Variable declarations and scopes</li>
            <li>Function arity (argument count)</li>
            <li>Operator/type compatibility</li>
            <li>Control-flow correctness</li>
        </ul>
        <br/>
        <li>The compiler builds:
            <ul>
                <li>a <b>symbol table</b> mapping names to types/locations,</li>
                <li>a <b>type environment</b>,</li>
                <li>a <b>scope tree</b>.</li>
            </ul>
        </li>
        <br/>
        <li>Example error caught here:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">x = "hello" + 5  -- type error: cannot add string and integer
</code></pre>

    <br/>
    <ul>
        <li>Semantic analysis transforms the AST into a <b>typed AST</b> (or annotates nodes with type info).</li>
    </ul>
    <br/><br/>


    <li><b>Intermediate Representation (IR) Generation</b></li>
    <br/>
    <ul>
        <li>Once semantics are validated, the compiler transforms the AST into an <b>IR</b> (Intermediate Representation).</li>
        <br/>
        <li>IR is a lower-level, more regular representation than the AST.</li>
        <br/>
        <li>Most modern compilers use a form of SSA (Static Single Assignment) IR.</li>
        <br/>
        <li>Purpose:
            <ul>
                <li>enable optimizations,</li>
                <li>provide target-independence,</li>
                <li>simplify code generation.</li>
            </ul>
        </li>
        <br/>
        <li>Example (LLVM IR):</li>
    </ul>

<pre><code class="language-plaintext line-numbers">%1 = add i32 3, 5
store i32 %1, i32* @x
</code></pre>

    <br/>
    <ul>
        <li>The IR removes high-level syntax and resolves many abstractions.</li>
    </ul>
    <br/><br/>


    <li><b>Optimization</b></li>
    <br/>
    <ul>
        <li>This is often the largest and most complex phase.</li>
        <br/>
        <li>Perform optimizations on IR to:
            <ul>
                <li>minimize runtime,</li>
                <li>minimize memory,</li>
                <li>increase CPU instruction-level parallelism,</li>
                <li>reduce branches and allocations.</li>
            </ul>
        </li>
        <br/>
        <li>Typical optimizations include:</li>
        <ul>
            <li>Constant folding</li>
            <li>Dead code elimination</li>
            <li>Loop unrolling</li>
            <li>Function inlining</li>
            <li>Common subexpression elimination</li>
            <li>Escape analysis (eliminate heap allocations)</li>
            <li>Copy propagation</li>
        </ul>
        <br/>
        <li>Optimizations may occur at:
            <ul>
                <li>high-level AST,</li>
                <li>mid-level IR (LLVM),</li>
                <li>low-level machine code.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Code Generation</b></li>
    <br/>
    <ul>
        <li>Transforms the optimized IR into:
            <ul>
                <li>target machine code,</li>
                <li>assembly, or</li>
                <li>bytecode (for JVM, CLR, BEAM, etc.).</li>
            </ul>
        </li>
        <br/>
        <li>This phase handles:
            <ul>
                <li>register allocation,</li>
                <li>calling conventions,</li>
                <li>instruction selection,</li>
                <li>stack frame setup,</li>
                <li>function prologues/epilogues.</li>
            </ul>
        </li>
        <br/>
        <li>Example (x86-64 assembly):</li>
    </ul>

<pre><code class="language-plaintext line-numbers">mov eax, 3
add eax, 5
mov [x], eax
</code></pre>

    <br/><br/>


    <li><b>Linking</b></li>
    <br/>
    <ul>
        <li>Final phase: combining all compiled units and libraries into an executable.</li>
        <br/>
        <li>The linker resolves:
            <ul>
                <li>symbol references,</li>
                <li>external functions (e.g., <code>printf</code>),</li>
                <li>imported modules,</li>
                <li>static libraries,</li>
                <li>shared libraries.</li>
            </ul>
        </li>
        <br/>
        <li>For languages like C/C++, linking is separate.</li>
        <br/>
        <li>For languages like Go, Rust, and Haskell, the compiler internally orchestrates linking.</li>
    </ul>
    <br/><br/>


    <li><b>The Big Picture Diagram</b></li>
<pre><code class="language-plaintext line-numbers">    Source Code
         |
         v
  [Lexical Analysis]
         |
         v
   [Syntax Parsing]
         |
         v
 [Semantic Analysis]
         |
         v
 [Intermediate Representation]
         |
         v
     [Optimization]
         |
         v
  [Code Generation]
         |
         v
      [Linking]
         |
         v
    Executable
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-lexical-analyzer">Introduction to the Lexical Analyzer</h3>
<ol>

    <li><b>What Is a Lexical Analyzer?</b></li>
    <br/>
    <ul>
        <li>A <b>lexical analyzer</b>, also called a <b>lexer</b> or <b>scanner</b>, is the first phase of a compiler.</li>
        <br/>
        <li>Its job is to transform raw source code (a stream of characters) into a stream of <b>tokens</b>.</li>
        <br/>
        <li>A token is a structured, meaningful element such as:
            <ul>
                <li>Keywords: <code>if</code>, <code>let</code>, <code>while</code></li>
                <li>Identifiers: <code>x</code>, <code>totalAmount</code></li>
                <li>Literals: <code>42</code>, <code>"hello"</code>, <code>true</code></li>
                <li>Operators: <code>+</code>, <code>-</code>, <code>==</code>, <code>=</code></li>
                <li>Punctuation: <code>;</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code></li>
            </ul>
        </li>
        <br/>
        <li>The lexer removes:
            <ul>
                <li>whitespace (spaces, tabs, newlines),</li>
                <li>comments,</li>
                <li>formatting irrelevant to syntax.</li>
            </ul>
        </li>
        <br/>
        <li>The output of a lexer is a clean token stream ready for parsing.</li>
    </ul>
    <br/><br/>


    <li><b>Why Is Lexical Analysis Needed?</b></li>
    <br/>
    <ul>
        <li>Languages are easier to reason about when reduced to meaningful units.</li>
        <br/>
        <li>A parser should process <b>tokens</b>, not raw characters.</li>
        <br/>
        <li>Lexers simplify parsing by:
            <ul>
                <li>grouping multi-character operators (<code>==</code>, <code>&gt;=</code>)</li>
                <li>handling keywords vs identifiers</li>
                <li>normalizing whitespace</li>
                <li>detecting early lexical errors (invalid characters)</li>
            </ul>
        </li>
        <br/>
        <li>Without a lexer, parsers become extremely complicated.</li>
    </ul>
    <br/><br/>


    <li><b>The Lexical Unit: Tokens</b></li>
    <br/>
    <ul>
        <li>Each token has generally:
            <ul>
                <li><b>type</b> (e.g., NUMBER, IDENTIFIER)</li>
                <li><b>lexeme</b> — the exact string matched</li>
                <li><b>literal value</b> (optional, e.g. integer value 42)</li>
                <li><b>position</b> (line/column for error reporting)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-plaintext line-numbers">Token {
    type: IDENTIFIER,
    lexeme: "total",
    literal: null,
    line: 3
}
</code></pre>

    <br/>
    <ul>
        <li>Tokens form a clean “interface” between source text and syntax analysis.</li>
    </ul>
    <br/><br/>


    <li><b>How the Lexer Works</b></li>
    <br/>
    <ul>
        <li>Lexers commonly operate using:
            <ul>
                <li><b>Deterministic Finite Automata (DFA)</b></li>
                <li><b>Regular expressions</b></li>
            </ul>
        </li>
        <br/>
        <li>The lexer scans the input left to right, grouping characters into the longest valid token.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Example:
Input:   x = 12 + 7
Output:  IDENT("x"), EQUALS, NUMBER(12), PLUS, NUMBER(7)
</code></pre>

    <br/><br/>


    <li><b>Token Categories (Example)</b></li>
    <br/>

    <ul>
        <li><b>Identifiers</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">myVar, count1, is_valid</code></pre>

    <ul>
        <li><b>Keywords</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">if, else, while, return</code></pre>

    <ul>
        <li><b>Literals</b>: integers, floats, strings, booleans</li>
    </ul>

<pre><code class="language-plaintext line-numbers">42, 3.14, "abc", true</code></pre>

    <ul>
        <li><b>Operators</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">+, -, *, /, ==, !=, &gt;=, &lt;=, =</code></pre>

    <ul>
        <li><b>Punctuation</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">;, ,, (, ), {, }</code></pre>

    <ul>
        <li><b>Comments</b> (ignored by the lexer)</li>
    </ul>

<pre><code class="language-plaintext line-numbers">// single-line
/* multi-line */
</code></pre>

    <br/><br/>


    <li><b>Lexical Errors</b></li>
    <br/>
    <ul>
        <li>The lexer is also responsible for catching invalid characters:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">abc @ def
    ^
    error: unexpected character '@'
</code></pre>

    <br/>
    <ul>
        <li>If an invalid lexeme is encountered, compilation stops at the lexical phase.</li>
    </ul>
    <br/><br/>


    <li>There are several common ways to build a lexer:</li>
    <ul>
        <br/>
        <li><b>Regex-based lexers</b></li>
        <br/>
        <li><b>DFA-based scanners</b></li>
        <br/>
        <li><b>Hand-written lexers</b> — common in simpler compilers</li>
    </ul>
    <br/><br/>


    <li><b>Longest Match Rule</b></li>
    <br/>
    <ul>
        <li>Lexers usually apply the <b>maximal match</b> principle:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Input:           &gt;=
Lexer picks:    "&gt;="   (not just "&gt;")
</code></pre>

    <br/>
    <ul>
        <li>This ensures ambiguous prefixes are handled properly.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-dfa-intro">Introduction to Deterministic Finite Automata (DFA)</h3>
<ol>

    <li><b>What Is a DFA? (In Simple Words, About Strict Definitions Please Go Read A Professional Book)</b></li>
    <br/>
    <ul>
        <li>A Deterministic Finite Automaton (<u>DFA</u>) is a simple mathematical machine used to recognize and process patterns in strings.</li>
        <br/>
        <li>A DFA reads an input string character by character and uses <u>states</u> to decide what to do next.</li>
        <br/>
        <li>If the machine ends in an <u>accept state</u>, then the string matches the pattern.</li>
    </ul>

    <br/><br/>


    <li><b>Formal Definition of a DFA</b></li>
    <br/>
    <ul>
        <li>A DFA consists of 5 components:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">DFA = (Q, Σ, δ, q₀, F)

Q   = set of states
Σ   = input alphabet (characters allowed)
δ   = transition function: Q × Σ → Q
q₀  = start state
F   = set of accepting states
</code></pre>
    <br/><br/>


    <li><b>Example 1: DFA for Recognizing Strings That End With "ab"</b></li>
    <br/>

<pre><code class="language-plaintext line-numbers">Alphabet: {a, b}
Language: All strings that end with "ab"
Examples accept:  "ab", "aab", "bbab", "aaab"
Examples reject:  "a", "ba", "abb", "bbaa"
</code></pre>

    <br/>
    <ul>
        <li>The DFA Transition Table:</li>
        <br/>
    <table>
        <thead>
            <tr>
                <th>State</th>
                <th>On <code>a</code></th>
                <th>On <code>b</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>q0</code> (start)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
            <tr>
                <td><code>q1</code></td>
                <td><code>q1</code></td>
                <td><code>q2</code></td>
            </tr>
            <tr>
                <td><code>q2</code> (accept)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
        </tbody>
    </table>
    </ul>

    <br/>
    <ul>
        <li>State meanings:</li>
        <ul>
            <li><b>q0</b>: nothing matched yet</li>
            <li><b>q1</b>: last char was 'a'</li>
            <li><b>q2</b> (accept): last two chars are "ab"</li>
        </ul>
    </ul>

    <br/>
    <ul>
        <li>Simulating input <code>aab</code>:</li>

<pre><code class="language-plaintext line-numbers">Start in q0
Read 'a' → q1
Read 'a' → q1
Read 'b' → q2 (accept!)
</code></pre>

    </ul>

    <br/><br/>


    <li><b>Example 2: DFA for Numbers with Even Number of 0s</b></li>
    <br/>
    <ul>
        <li>This DFA checks whether the number of <code>0</code> characters is <b>even</b>.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Alphabet: {0, 1}
Accept: strings with even number of 0s
</code></pre>

    <br/>
    <table>
        <thead>
            <tr>
                <th>State</th>
                <th>On <code>0</code></th>
                <th>On <code>1</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>Even</code> (start, accept)</td>
                <td><code>Odd</code></td>
                <td><code>Even</code></td>
            </tr>
            <tr>
                <td><code>Odd</code></td>
                <td><code>Even</code></td>
                <td><code>Odd</code></td>
            </tr>
        </tbody>
    </table>
    <br/>

    <ul>
        <li>State meaning:
            <ul>
                <li><b>Even</b>: seen even number of 0s (accept state)</li>
                <li><b>Odd</b>: seen odd number of 0s</li>
            </ul>
        </li>

<pre><code class="language-plaintext line-numbers">Example: 10100
Even --1--&gt; Even --0--&gt; Odd --1--&gt; Odd --0--&gt; Even --0--&gt; Odd (reject)
</code></pre>
    </ul>

    <br/><br/>


    <li><b>Transition Table Representation</b></li>
    <br/>
    <ul>
        <li>A DFA can also be represented using a table.</li>
        <li>For the &quot;ends with ab&quot; automaton:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">       |   a   |   b
--------------------------------
q0     |  q1   |  q0
q1     |  q1   |  q2
q2     |  q1   |  q0
</code></pre>

    <br/>
    <ul>
        <li>The table precisely defines the behaviour of the machine.</li>
    </ul>
    <br/><br/>


    <li><b>DFA Simulation (Pseudocode)</b></li>
    <br/>
    <ul>
        <li>Every DFA can be simulated by repeatedly applying the transition function.</li>
    </ul>

<pre><code class="language-c line-numbers">def run_dfa(trans, start, accepts, s):
    state = start
    for c in s:
        state = trans[state][c]
    return state in accepts

transition = {
    "q0": {"a": "q1", "b": "q0"},
    "q1": {"a": "q1", "b": "q2"},
    "q2": {"a": "q1", "b": "q0"},
}

print(run_dfa(transition, "q0", {"q2"}, "aab"))   // True
</code></pre>

    <br/><br/>


    <li><b>DFA vs NFA (Briefly)</b></li>
    <br/>
    <ul>
        <li>A DFA has:
            <ul>
                <li>exactly one transition per input symbol,</li>
                <li>exactly one active state at any time.</li>
            </ul>
        </li>
        <li>An NFA (nondeterministic finite automaton) may have:
            <ul>
                <li>multiple possible transitions,</li>
                <li>ε-transitions (move without input),</li>
                <li>multiple active states.</li>
            </ul>
        </li>
        <li>But both recognize exactly the same class of languages (<u>regular languages</u>).</li>
    </ul>
    <br/><br/>
    <br/>
    <table>
        <thead>
            <tr>
                <th colspan="3">DFA: Strings Ending with "ab"</th>
            </tr>
            <tr>
                <th>State</th>
                <th>On <code>a</code></th>
                <th>On <code>b</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>q0</code> (start)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
            <tr>
                <td><code>q1</code></td>
                <td><code>q1</code></td>
                <td><code>q2</code></td>
            </tr>
            <tr>
                <td><code>q2</code> (accept)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
<table>
    <thead>
        <tr>
            <th colspan="3">NFA: Strings Ending with "ab"</th>
        </tr>
        <tr>
            <th>State</th>
            <th>On <code>a</code></th>
            <th>On <code>b</code></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>q0</code> (start)</td>
            <td>{q0, q1}</td>
            <td>{q0}</td>
        </tr>
        <tr>
            <td><code>q1</code></td>
            <td>{q1}</td>
            <td>{q2}</td>
        </tr>
        <tr>
            <td><code>q2</code> (accept)</td>
            <td>{q1}</td>
            <td>{q0}</td>
        </tr>
    </tbody>
</table>
<br/>


</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-left-refactoring">Left Factoring</h3>
<ol>
    <li><b>What Is Left Factoring?</b></li>

    <ul>
        <br/>
        <li/>
            Left factoring is a grammar transformation technique used in compiler design.<br/>
            It's essential for building <u>predictive parsers</u> (like LL(1) parsers) that need to decide which production to use by looking at only one token ahead.
        </li>
        <br/>
        <li>When two or more productions for the same non-terminal start with the same symbol(s), the parser cannot decide which rule to apply.</li>
        <br/>
        <li>Left factoring extracts the common prefix into a single production, deferring the decision until after the prefix is consumed.</li>
    </ul>
    <br/>


    <br/><br/>


    <li><b>Why Do We Need It?</b></li>
    <br/>
    <ul>
        <li>Consider a predictive parser looking at input and trying to choose a production:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Grammar:
    A -&gt; α β₁
    A -&gt; α β₂

Problem: When parser sees the start of α, it cannot decide between the two rules!
</code></pre>

    <ul>
        <li>The parser would need to "look ahead" beyond α to make a decision — but LL(1) parsers only look at <b>one</b> token.</li>
        <li>Left factoring solves this by restructuring the grammar:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After left factoring:
    A  -&gt; α A'
    A' -&gt; β₁
    A' -&gt; β₂

Now: Parser consumes α first, THEN decides between β₁ and β₂.
</code></pre>

    <br/><br/>


    <li><b>The General Algorithm</b></li>
    <br/>
    <ul>
        <li>For each non-terminal A with productions that share a common prefix α:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before:
    A -&gt; α β₁ | α β₂ | ... | α βₙ | γ

After:
    A  -&gt; α A' | γ
    A' -&gt; β₁ | β₂ | ... | βₙ
</code></pre>

    <ul>
        <li>Where γ represents any alternatives that don't share the prefix α.</li>
        <li>If βᵢ is empty for some i, then A' -&gt; ε (epsilon) is one of the alternatives.</li>
    </ul>

    <br/><br/>


    <li><b>Example 1: Simple Arithmetic Expression</b></li>
    <br/>
    <ul>
        <li>A classic example from expression parsing:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    expr -&gt; term + expr
    expr -&gt; term

Problem: Both start with "term" — parser can't decide!
</code></pre>

    <br/>
    <ul>
        <li>After left factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    expr  -&gt; term expr'
    expr' -&gt; + expr
    expr' -&gt; ε
</code></pre>

    <br/>
    <ul>
        <li>Visualization of the transformation:</li>
    </ul>
    <br/>

    <svg viewBox="0 0 700 200" style="max-width: 700px; font-family: monospace;">
        <!-- Before side -->
        <text x="100" y="20" font-size="14" font-weight="bold" text-anchor="middle">Before</text>
        <circle cx="100" cy="60" r="25" fill="#ffe6e6" stroke="#333" stroke-width="2"/>
        <text x="100" y="65" font-size="12" text-anchor="middle">expr</text>

        <line x1="85" y1="85" x2="50" y2="130" stroke="#333" stroke-width="1.5"/>
        <line x1="115" y1="85" x2="150" y2="130" stroke="#333" stroke-width="1.5"/>

        <text x="50" y="150" font-size="11" text-anchor="middle">term + expr</text>
        <text x="150" y="150" font-size="11" text-anchor="middle">term</text>

        <text x="100" y="180" font-size="11" fill="#c00" text-anchor="middle">⚠ Common prefix "term"</text>

        <!-- Arrow -->
        <line x1="220" y1="100" x2="280" y2="100" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
            </marker>
        </defs>

        <!-- After side -->
        <text x="480" y="20" font-size="14" font-weight="bold" text-anchor="middle">After</text>
        <circle cx="400" cy="60" r="25" fill="#e6ffe6" stroke="#333" stroke-width="2"/>
        <text x="400" y="65" font-size="12" text-anchor="middle">expr</text>

        <line x1="400" y1="85" x2="400" y2="115" stroke="#333" stroke-width="1.5"/>
        <text x="400" y="135" font-size="11" text-anchor="middle">term expr'</text>

        <circle cx="560" cy="60" r="25" fill="#e6f3ff" stroke="#333" stroke-width="2"/>
        <text x="560" y="65" font-size="12" text-anchor="middle">expr'</text>

        <line x1="545" y1="85" x2="510" y2="130" stroke="#333" stroke-width="1.5"/>
        <line x1="575" y1="85" x2="610" y2="130" stroke="#333" stroke-width="1.5"/>

        <text x="510" y="150" font-size="11" text-anchor="middle">+ expr</text>
        <text x="610" y="150" font-size="11" text-anchor="middle">ε</text>

        <text x="480" y="180" font-size="11" fill="#080" text-anchor="middle">✓ Decision deferred to expr'</text>
    </svg>

    <br/><br/>


    <li><b>Example 2: The Dangling Else Problem</b></li>
    <br/>
    <ul>
        <li>This is a famous ambiguity in programming language grammars:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    stmt -&gt; if ( expr ) stmt else stmt
    stmt -&gt; if ( expr ) stmt
    stmt -&gt; while ( expr ) stmt
    stmt -&gt; id = expr ;

Problem: Both "if" rules share a long common prefix!
</code></pre>

    <br/>
    <ul>
        <li>After left factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    stmt  -&gt; if ( expr ) stmt stmt'
    stmt  -&gt; while ( expr ) stmt
    stmt  -&gt; id = expr ;
    stmt' -&gt; else stmt
    stmt' -&gt; ε
</code></pre>

    <br/>
    <ul>
        <li>The common prefix <code>if ( expr ) stmt</code> is factored out.</li>
        <li>The decision between "else" and "nothing" is deferred to <code>stmt'</code>.</li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Input After Parsing <code>if(expr)stmt</code></th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Next token is <code>else</code></td>
                <td>Use <code>stmt' -&gt; else stmt</code></td>
            </tr>
            <tr>
                <td>Next token is something else</td>
                <td>Use <code>stmt' -&gt; ε</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Example 3: Multiple Groups of Common Prefixes</b></li>
    <br/>
    <ul>
        <li>Sometimes you have multiple different prefixes that each need factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    decl -&gt; int id ;
    decl -&gt; int id [ num ] ;
    decl -&gt; float id ;
    decl -&gt; float id [ num ] ;
</code></pre>

    <br/>
    <ul>
        <li>Here we have TWO groups of common prefixes: <code>int id</code> and <code>float id</code>.</li>
        <li>First pass — factor out within each group:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    decl  -&gt; int id decl'
    decl  -&gt; float id decl'
    decl' -&gt; ;
    decl' -&gt; [ num ] ;
</code></pre>

    <br/>
    <ul>
        <li>We can go even further by factoring out the type:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Even more factored (optional):
    decl  -&gt; type id decl'
    type  -&gt; int
    type  -&gt; float
    decl' -&gt; ;
    decl' -&gt; [ num ] ;
</code></pre>

    <br/><br/>


    <li><b>Example 4: Three or More Alternatives</b></li>
    <br/>
    <ul>
        <li>When more than two alternatives share a prefix, you may need multiple passes:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    print_stmt -&gt; print expr ;
    print_stmt -&gt; print expr , expr ;
    print_stmt -&gt; print expr , expr , expr ;
</code></pre>

    <br/>
    <ul>
        <li>First pass — factor out <code>print expr</code>:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (first pass):
    print_stmt  -&gt; print expr print_stmt'
    print_stmt' -&gt; ;
    print_stmt' -&gt; , expr ;
    print_stmt' -&gt; , expr , expr ;
</code></pre>

    <br/>
    <ul>
        <li>But wait! <code>print_stmt'</code> still has common prefixes. Second pass:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (second pass):
    print_stmt   -&gt; print expr print_stmt'
    print_stmt'  -&gt; ;
    print_stmt'  -&gt; , expr print_stmt''
    print_stmt'' -&gt; ;
    print_stmt'' -&gt; , expr ;
</code></pre>

    <br/><br/>


    <li><b>Example 5: Nested Factoring (Iterative Process)</b></li>
    <br/>
    <ul>
        <li>A more complex example showing how factoring can require multiple iterations:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    S -&gt; a b c d
    S -&gt; a b c e
    S -&gt; a b f
    S -&gt; a g
    S -&gt; h
</code></pre>

    <br/>
    <ul>
        <li>This requires THREE passes to fully factor. Here's the progression:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Pass</th>
                <th>Common Prefix Found</th>
                <th>Result</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><code>a</code></td>
                <td>Extract <code>S'</code> for what follows <code>a</code></td>
            </tr>
            <tr>
                <td>2</td>
                <td><code>b</code> (in S')</td>
                <td>Extract <code>S''</code> for what follows <code>b</code></td>
            </tr>
            <tr>
                <td>3</td>
                <td><code>c</code> (in S'')</td>
                <td>Extract <code>S'''</code> for what follows <code>c</code></td>
            </tr>
        </tbody>
    </table>

    <br/>

<pre><code class="language-plaintext line-numbers">After (pass 1):
    S  -&gt; a S'
    S  -&gt; h
    S' -&gt; b c d
    S' -&gt; b c e
    S' -&gt; b f
    S' -&gt; g

After (pass 2):
    S   -&gt; a S'
    S   -&gt; h
    S'  -&gt; b S''
    S'  -&gt; g
    S'' -&gt; c d
    S'' -&gt; c e
    S'' -&gt; f

After (pass 3 — final):
    S    -&gt; a S'
    S    -&gt; h
    S'   -&gt; b S''
    S'   -&gt; g
    S''  -&gt; c S'''
    S''  -&gt; f
    S''' -&gt; d
    S''' -&gt; e
</code></pre>

    <br/>
    <ul>
        <li>Visualizing the final grammar as a decision tree:</li>
    </ul>
    <br/>

    <svg viewBox="-100 0 550 420" style="max-width: 500px; font-family: monospace;">
        <!-- S node -->
        <circle cx="200" cy="30" r="20" fill="#fffacd" stroke="#333" stroke-width="2"/>
        <text x="200" y="35" font-size="12" text-anchor="middle">S</text>

        <!-- S branches -->
        <line x1="185" y1="48" x2="100" y2="90" stroke="#333" stroke-width="1.5"/>
        <line x1="215" y1="48" x2="300" y2="90" stroke="#333" stroke-width="1.5"/>
        <text x="135" y="65" font-size="10" fill="#666">a</text>
        <text x="265" y="65" font-size="10" fill="#666">h</text>

        <!-- S' node -->
        <circle cx="100" cy="110" r="20" fill="#e6f3ff" stroke="#333" stroke-width="2"/>
        <text x="100" y="115" font-size="12" text-anchor="middle">S'</text>

        <!-- h terminal -->
        <rect x="280" y="95" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="300" y="112" font-size="11" text-anchor="middle">h</text>

        <!-- S' branches -->
        <line x1="85" y1="128" x2="40" y2="170" stroke="#333" stroke-width="1.5"/>
        <line x1="115" y1="128" x2="160" y2="170" stroke="#333" stroke-width="1.5"/>
        <text x="55" y="145" font-size="10" fill="#666">b</text>
        <text x="145" y="145" font-size="10" fill="#666">g</text>

        <!-- S'' node -->
        <circle cx="40" cy="190" r="20" fill="#ffe6f0" stroke="#333" stroke-width="2"/>
        <text x="40" y="195" font-size="12" text-anchor="middle">S''</text>

        <!-- g terminal -->
        <rect x="140" y="175" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="160" y="190" font-size="11" text-anchor="middle">g</text>

        <!-- S'' branches -->
        <line x1="25" y1="208" x2="0" y2="250" stroke="#333" stroke-width="1.5"/>
        <line x1="55" y1="208" x2="80" y2="250" stroke="#333" stroke-width="1.5"/>
        <text x="5" y="225" font-size="10" fill="#666">c</text>
        <text x="75" y="225" font-size="10" fill="#666">f</text>

        <!-- S''' node -->
        <circle cx="0" cy="270" r="18" fill="#f0e6ff" stroke="#333" stroke-width="2"/>
        <text x="0" y="275" font-size="11" text-anchor="middle">S'''</text>

        <!-- f terminal -->
        <rect x="60" y="255" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="80" y="272" font-size="11" text-anchor="middle">f</text>

        <!-- S''' branches -->
        <line x1="-12" y1="286" x2="-30" y2="310" stroke="#333" stroke-width="1.5"/>
        <line x1="12" y1="286" x2="30" y2="310" stroke="#333" stroke-width="1.5"/>
        <text x="-35" y="300" font-size="10" fill="#666">d</text>
        <text x="35" y="300" font-size="10" fill="#666">e</text>
        <!-- d terminal -->
        <rect x="-60" y="315" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="-40" y="332" font-size="11" text-anchor="middle">d</text>
        <!-- e terminal -->
        <rect x="20" y="315" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="40" y="332" font-size="11" text-anchor="middle">e</text>

        <!-- Legend -->
        <rect x="350" y="150" width="15" height="15" fill="#fffacd" stroke="#333" stroke-width="1"/>
        <text x="370" y="162" font-size="10">Non-terminal</text>
        <rect x="350" y="175" width="15" height="15" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="370" y="187" font-size="10">Terminal</text>
    </svg>

    <br/><br/>


    <li><b>Example 6: A Realistic Function Definition Grammar</b></li>
    <br/>
    <ul>
        <li>Real programming languages have complex grammars. Here's a function definition:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    func -&gt; id ( ) { stmts }
    func -&gt; id ( ) : type { stmts }
    func -&gt; id ( params ) { stmts }
    func -&gt; id ( params ) : type { stmts }
</code></pre>

    <br/>
    <ul>
        <li>All four start with <code>id (</code> — a parser seeing <code>foo(</code> has no idea which rule to use!</li>
        <li>After careful factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    func    -&gt; id ( func'
    func'   -&gt; ) func''
    func'   -&gt; params ) func''
    func''  -&gt; { stmts }
    func''  -&gt; : type { stmts }
</code></pre>

    <br/>
    <ul>
        <li>Decision points:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>After Seeing</th>
                <th>Look At</th>
                <th>Decision</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>id (</code></td>
                <td>Next token</td>
                <td><code>)</code> → no params; otherwise → has params</td>
            </tr>
            <tr>
                <td><code>id ( ... )</code></td>
                <td>Next token</td>
                <td><code>{</code> → no return type; <code>:</code> → has return type</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>When Left Factoring Is Not Enough</b></li>
    <br/>
    <ul>
        <li>Left factoring only helps with common <b>prefixes</b>.</li>
        <li>It does NOT solve:
            <ul>
                <li><b>Left recursion</b>: <code>A -&gt; A α | β</code> (needs different transformation)</li>
                <li><b>Ambiguity</b>: when the grammar genuinely allows multiple parse trees</li>
                <li><b>Non-LL(1) grammars</b>: some grammars simply cannot be made LL(1)</li>
            </ul>
        </li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Problem</th>
                <th>Solution</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Common prefixes</td>
                <td>Left factoring ✓</td>
            </tr>
            <tr>
                <td>Left recursion</td>
                <td>Left recursion elimination</td>
            </tr>
            <tr>
                <td>Ambiguity</td>
                <td>Rewrite grammar or use precedence rules</td>
            </tr>
            <tr>
                <td>Inherently non-LL(1)</td>
                <td>Use more powerful parser (LR, GLR, etc.)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li>Left factoring transforms: <code>A -&gt; αβ₁ | αβ₂</code> into <code>A -&gt; αA'</code> and <code>A' -&gt; β₁ | β₂</code></li>
        <li>It enables predictive (LL) parsing by deferring decisions until after common prefixes.</li>
        <li>May require multiple passes for deeply nested common prefixes.</li>
        <li>Often used together with left recursion elimination when building LL(1) parsers.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="predictive-parsing">Predictive Parsing</h3>
<ol>
    <li><b>What Is Predictive Parsing?</b></li>
    <ul>
        <br/>
        <li>
            Predictive parsing is what you get when you've successfully transformed your grammar
            (using left factoring, left recursion elimination, etc.) so that one token of lookahead
            is always sufficient to make the right choice—no guessing, no backtracking, no regrets.
        </li>
        <br/>
        <li>A <u>predictive parser</u> is a top-down parser that never backtracks.</li>
        <br/>
        <li>At each step, it looks at the current non-terminal and the next input token, then <b>deterministically</b> chooses which production to use.</li>
        <br/>
        <li>This is only possible when the grammar has been carefully prepared (no left recursion, no common prefixes).</li>
    </ul>
    <br/>


<pre><code class="language-plaintext line-numbers">The Promise of Predictive Parsing:

    Current state: I'm trying to expand non-terminal A
    I see token t in the input
    ↓
    I know EXACTLY which production to use (or that there's an error)
    ↓
    No guessing. No trying one rule and backtracking if it fails.
</code></pre>

    <br/><br/>


    <li><b>The Key Insight: FIRST Sets</b></li>
    <br/>
    <ul>
        <li>For predictive parsing to work, we need to know: "What tokens can a production <i>start</i> with?"</li>
        <li>This is captured by the <u>FIRST set</u>.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Definition:

    FIRST(α) = the set of all terminals (tokens) that can appear
               as the first symbol of any string derived from α

    If α can derive ε (empty string), then ε ∈ FIRST(α) as well.
</code></pre>

    <br/>
    <ul>
        <li>Simple examples:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">FIRST(if ( expr ) stmt)  = { if }       — always starts with "if"
FIRST(while ( expr ) stmt) = { while }  — always starts with "while"
FIRST(id = expr ;)       = { id }       — always starts with an identifier
FIRST(+ term)            = { + }        — always starts with "+"
FIRST(ε)                 = { ε }        — the empty string "starts with" nothing
</code></pre>

    <br/><br/>


    <li><b>The Golden Rule for Predictive Parsing</b></li>
    <br/>
    <ul>
        <li>If <code>A -&gt; α</code> and <code>A -&gt; β</code> are two different productions for the same non-terminal:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">FIRST(α) ∩ FIRST(β) = ∅    (must be empty!)

If they overlap, seeing a token in the overlap wouldn't tell you which production to use.
</code></pre>

    <br/>
    <ul>
        <li>When this condition holds for all non-terminals, the grammar is suitable for predictive parsing.</li>
    </ul>

    <br/><br/>


    <li><b>Example: Good Grammar (Predictive Parsing Works)</b></li>
    <br/>

<pre><code class="language-plaintext line-numbers">Grammar:
    stmt -&gt; if ( expr ) stmt
    stmt -&gt; while ( expr ) stmt
    stmt -&gt; id = expr ;

FIRST sets:
    FIRST(if ( expr ) stmt)     = { if }
    FIRST(while ( expr ) stmt)  = { while }
    FIRST(id = expr ;)          = { id }
</code></pre>

    <br/>
    <ul>
        <li>Checking for overlap:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Pair</th>
                <th>Intersection</th>
                <th>Result</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>{ if } ∩ { while }</td>
                <td>∅</td>
                <td>✓</td>
            </tr>
            <tr>
                <td>{ if } ∩ { id }</td>
                <td>∅</td>
                <td>✓</td>
            </tr>
            <tr>
                <td>{ while } ∩ { id }</td>
                <td>∅</td>
                <td>✓</td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>No overlap! The parser can always decide:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">See "if"    → use stmt -&gt; if ( expr ) stmt
See "while" → use stmt -&gt; while ( expr ) stmt
See "id"    → use stmt -&gt; id = expr ;
See anything else → syntax error!
</code></pre>

    <br/><br/>


    <li><b>Example: Bad Grammar (Predictive Parsing Fails)</b></li>
    <br/>

<pre><code class="language-plaintext line-numbers">Grammar:
    expr -&gt; term + expr
    expr -&gt; term

Assume term can start with digits (0-9):
    FIRST(term + expr) = { 0, 1, 2, ..., 9 }
    FIRST(term)        = { 0, 1, 2, ..., 9 }
</code></pre>

    <br/>
    <ul>
        <li>The problem:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">FIRST(term + expr) ∩ FIRST(term) = { 0, 1, 2, ..., 9 }

                                    ↑ Complete overlap!
</code></pre>

    <br/>
    <ul>
        <li>If the parser sees <code>5</code>, it has no idea whether to use <code>expr -&gt; term + expr</code> or <code>expr -&gt; term</code>.</li>
        <li>This is exactly why we need <b>left factoring</b>!</li>
    </ul>

    <br/>

    <svg viewBox="0 0 600 180" style="max-width: 600px; font-family: monospace;">
        <!-- Before -->
        <text x="120" y="20" font-size="14" font-weight="bold" text-anchor="middle">Before (Bad)</text>

        <circle cx="120" cy="60" r="25" fill="#ffe6e6" stroke="#c00" stroke-width="2"/>
        <text x="120" y="65" font-size="12" text-anchor="middle">expr</text>

        <text x="120" y="105" font-size="11" text-anchor="middle">Sees token "5"</text>
        <text x="120" y="125" font-size="11" text-anchor="middle" fill="#c00">Which rule? 🤷</text>

        <line x1="95" y1="135" x2="60" y2="160" stroke="#999" stroke-width="1" stroke-dasharray="4"/>
        <line x1="145" y1="135" x2="180" y2="160" stroke="#999" stroke-width="1" stroke-dasharray="4"/>
        <text x="60" y="175" font-size="10" text-anchor="middle" fill="#666">term + expr ?</text>
        <text x="180" y="175" font-size="10" text-anchor="middle" fill="#666">term ?</text>

        <!-- Arrow -->
        <line x1="240" y1="90" x2="300" y2="90" stroke="#333" stroke-width="2" marker-end="url(#arrow2)"/>
        <text x="270" y="80" font-size="10" text-anchor="middle">left factor</text>
        <defs>
            <marker id="arrow2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
            </marker>
        </defs>

        <!-- After -->
        <text x="450" y="20" font-size="14" font-weight="bold" text-anchor="middle">After (Good)</text>

        <circle cx="380" cy="60" r="25" fill="#e6ffe6" stroke="#080" stroke-width="2"/>
        <text x="380" y="65" font-size="12" text-anchor="middle">expr</text>

        <line x1="380" y1="85" x2="380" y2="110" stroke="#333" stroke-width="1.5"/>
        <text x="380" y="130" font-size="11" text-anchor="middle">term expr'</text>

        <circle cx="520" cy="60" r="25" fill="#e6f3ff" stroke="#333" stroke-width="2"/>
        <text x="520" y="65" font-size="12" text-anchor="middle">expr'</text>

        <text x="520" y="105" font-size="11" text-anchor="middle">Sees "+" or end</text>
        <text x="520" y="125" font-size="11" text-anchor="middle" fill="#080">Now it's clear! ✓</text>

        <line x1="500" y1="135" x2="470" y2="160" stroke="#333" stroke-width="1"/>
        <line x1="540" y1="135" x2="570" y2="160" stroke="#333" stroke-width="1"/>
        <text x="470" y="175" font-size="10" text-anchor="middle">+ expr</text>
        <text x="570" y="175" font-size="10" text-anchor="middle">ε</text>
    </svg>

    <br/><br/>


    <li><b>Computing FIRST Sets: The Algorithm</b></li>
    <br/>
    <ul>
        <li>For a terminal <code>a</code>: <code>FIRST(a) = { a }</code></li>
        <li>For epsilon: <code>FIRST(ε) = { ε }</code></li>
        <li>For a non-terminal <code>A</code>, look at all its productions and take the union.</li>
        <li>For a sequence <code>X₁ X₂ ... Xₙ</code>:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">FIRST(X₁ X₂ ... Xₙ):

    1. Start with FIRST(X₁) (excluding ε)
    2. If ε ∈ FIRST(X₁), also add FIRST(X₂) (excluding ε)
    3. If ε ∈ FIRST(X₁) and ε ∈ FIRST(X₂), also add FIRST(X₃) ...
    4. Continue until you hit an Xᵢ where ε ∉ FIRST(Xᵢ)
    5. If ALL of X₁...Xₙ can derive ε, then add ε to the result
</code></pre>

    <br/>
    <ul>
        <li>Example calculation:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Grammar:
    E  -&gt; T E'
    E' -&gt; + T E' | ε
    T  -&gt; F T'
    T' -&gt; * F T' | ε
    F  -&gt; ( E ) | id

Computing FIRST sets (iteratively):
    FIRST(F)  = { (, id }
    FIRST(T') = { *, ε }
    FIRST(T)  = FIRST(F) = { (, id }
    FIRST(E') = { +, ε }
    FIRST(E)  = FIRST(T) = { (, id }
</code></pre>

    <br/><br/>


    <li><b>FOLLOW Sets: Handling Epsilon</b></li>
    <br/>
    <ul>
        <li>When a production can derive ε, we also need to know what can <i>follow</i> that non-terminal.</li>
        <li><u>FOLLOW(A)</u> = the set of terminals that can appear immediately after A in some derivation.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Why we need FOLLOW:

    E' -&gt; + T E'
    E' -&gt; ε

    If we see something NOT in FIRST(+ T E'), should we use E' -&gt; ε?
    Only if that something is in FOLLOW(E')!
</code></pre>

    <br/>
    <ul>
        <li>FOLLOW set rules:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">1. $ ∈ FOLLOW(S) where S is the start symbol ($ = end of input)

2. If A -&gt; α B β, then:
   FIRST(β) - {ε} ⊆ FOLLOW(B)

3. If A -&gt; α B, or A -&gt; α B β where ε ∈ FIRST(β), then:
   FOLLOW(A) ⊆ FOLLOW(B)
</code></pre>

    <br/><br/>


    <li><b>The Parsing Table</b></li>
    <br/>
    <ul>
        <li>Once we have FIRST and FOLLOW sets, we can build a <u>parsing table</u>.</li>
        <li>The table tells us: "Given non-terminal A and lookahead token t, which production to use?"</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Table construction:

    For each production A -&gt; α:
        1. For each terminal a ∈ FIRST(α), add A -&gt; α to Table[A, a]
        2. If ε ∈ FIRST(α), for each terminal b ∈ FOLLOW(A), add A -&gt; α to Table[A, b]
</code></pre>

    <br/>
    <ul>
        <li>Example parsing table for arithmetic expressions:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th></th>
                <th><code>id</code></th>
                <th><code>+</code></th>
                <th><code>*</code></th>
                <th><code>(</code></th>
                <th><code>)</code></th>
                <th><code>$</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>E</code></td>
                <td>E -&gt; T E'</td>
                <td></td>
                <td></td>
                <td>E -&gt; T E'</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><code>E'</code></td>
                <td></td>
                <td>E' -&gt; + T E'</td>
                <td></td>
                <td></td>
                <td>E' -&gt; ε</td>
                <td>E' -&gt; ε</td>
            </tr>
            <tr>
                <td><code>T</code></td>
                <td>T -&gt; F T'</td>
                <td></td>
                <td></td>
                <td>T -&gt; F T'</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><code>T'</code></td>
                <td></td>
                <td>T' -&gt; ε</td>
                <td>T' -&gt; * F T'</td>
                <td></td>
                <td>T' -&gt; ε</td>
                <td>T' -&gt; ε</td>
            </tr>
            <tr>
                <td><code>F</code></td>
                <td>F -&gt; id</td>
                <td></td>
                <td></td>
                <td>F -&gt; ( E )</td>
                <td></td>
                <td></td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>Empty cells = syntax error. Multiple entries in one cell = grammar is not LL(1).</li>
    </ul>

    <br/><br/>


    <li><b>The Predictive Parsing Algorithm</b></li>
    <br/>
    <ul>
        <li>Uses a stack to track what we're expecting to see.</li>
        <li>Matches terminals, expands non-terminals using the table.</li>
    </ul>

<pre><code class="language-python line-numbers">def predictive_parse(input_tokens, table, start_symbol):
    stack = ['$', start_symbol]  # $ marks bottom
    tokens = input_tokens + ['$']
    pos = 0

    while stack:
        top = stack.pop()
        current = tokens[pos]

        if top == '$':
            if current == '$':
                return True  # Success!
            else:
                return False  # Error: extra input

        elif top is terminal:
            if top == current:
                pos += 1  # Match! Consume token
            else:
                return False  # Error: mismatch

        else:  # top is non-terminal
            if (top, current) in table:
                production = table[(top, current)]
                # Push RHS in reverse order
                for symbol in reversed(production.rhs):
                    if symbol != 'ε':
                        stack.append(symbol)
            else:
                return False  # Error: no rule

    return pos == len(tokens) - 1
</code></pre>

    <br/><br/>


    <li><b>Trace: Parsing <code>id + id * id</code></b></li>
    <br/>
    <ul>
        <li>Let's trace through parsing the expression <code>id + id * id</code>:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Stack</th>
                <th>Input</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>$ E</code></td>
                <td><code>id + id * id $</code></td>
                <td>E -&gt; T E' (Table[E, id])</td>
            </tr>
            <tr>
                <td><code>$ E' T</code></td>
                <td><code>id + id * id $</code></td>
                <td>T -&gt; F T' (Table[T, id])</td>
            </tr>
            <tr>
                <td><code>$ E' T' F</code></td>
                <td><code>id + id * id $</code></td>
                <td>F -&gt; id (Table[F, id])</td>
            </tr>
            <tr>
                <td><code>$ E' T' id</code></td>
                <td><code>id + id * id $</code></td>
                <td>Match id</td>
            </tr>
            <tr>
                <td><code>$ E' T'</code></td>
                <td><code>+ id * id $</code></td>
                <td>T' -&gt; ε (Table[T', +])</td>
            </tr>
            <tr>
                <td><code>$ E'</code></td>
                <td><code>+ id * id $</code></td>
                <td>E' -&gt; + T E' (Table[E', +])</td>
            </tr>
            <tr>
                <td><code>$ E' T +</code></td>
                <td><code>+ id * id $</code></td>
                <td>Match +</td>
            </tr>
            <tr>
                <td><code>$ E' T</code></td>
                <td><code>id * id $</code></td>
                <td>T -&gt; F T'</td>
            </tr>
            <tr>
                <td><code>$ E' T' F</code></td>
                <td><code>id * id $</code></td>
                <td>F -&gt; id</td>
            </tr>
            <tr>
                <td><code>$ E' T' id</code></td>
                <td><code>id * id $</code></td>
                <td>Match id</td>
            </tr>
            <tr>
                <td><code>$ E' T'</code></td>
                <td><code>* id $</code></td>
                <td>T' -&gt; * F T'</td>
            </tr>
            <tr>
                <td><code>$ E' T' F *</code></td>
                <td><code>* id $</code></td>
                <td>Match *</td>
            </tr>
            <tr>
                <td><code>$ E' T' F</code></td>
                <td><code>id $</code></td>
                <td>F -&gt; id</td>
            </tr>
            <tr>
                <td><code>$ E' T' id</code></td>
                <td><code>id $</code></td>
                <td>Match id</td>
            </tr>
            <tr>
                <td><code>$ E' T'</code></td>
                <td><code>$</code></td>
                <td>T' -&gt; ε</td>
            </tr>
            <tr>
                <td><code>$ E'</code></td>
                <td><code>$</code></td>
                <td>E' -&gt; ε</td>
            </tr>
            <tr>
                <td><code>$</code></td>
                <td><code>$</code></td>
                <td>Accept! ✓</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>LL(1) — What Does It Mean?</b></li>
    <br/>
    <ul>
        <li>Predictive parsers are also called <u>LL(1) parsers</u>:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Letter</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>L</b></td>
                <td>Left-to-right scan of input</td>
            </tr>
            <tr>
                <td><b>L</b></td>
                <td>Leftmost derivation (expand leftmost non-terminal first)</td>
            </tr>
            <tr>
                <td><b>1</b></td>
                <td>One token of lookahead</td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>A grammar is LL(1) if and only if its parsing table has no multiply-defined entries.</li>
        <li>Not all grammars can be made LL(1) — some languages require more powerful parsers.</li>
    </ul>

    <br/><br/>


    <li><b>After Parsing: Intermediate Representation</b></li>
    <br/>
    <ul>
        <li>Once parsing succeeds, the compiler typically builds an <u>Intermediate Representation</u> (IR).</li>
        <li>When computer scientists say "representation," they mean "how we encode or store information" — it doesn't have to be text.</li>
        <li>Two main styles:</li>
    </ul>

    <br/>

    <table>
        <thead>
            <tr>
                <th>Tree-Based IR (AST)</th>
                <th>Linear IR (Three-Address Code)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Preserves hierarchical, nested structure</td>
                <td>Flattens into a sequence of instructions</td>
            </tr>
            <tr>
                <td>Each node = operation, children = operands</td>
                <td>Explicit temporaries and jumps</td>
            </tr>
            <tr>
                <td>Good for analysis and transformation</td>
                <td>Closer to machine code</td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>Example for <code>a + b * c</code>:</li>
    </ul>
    <br/>

    <svg viewBox="0 0 750 300" style="max-width: 650px; font-family: monospace;">
        <!-- AST side -->
        <text x="120" y="20" font-size="14" font-weight="bold" text-anchor="middle">Tree-Based (AST)</text>

        <circle cx="120" cy="60" r="20" fill="#fffacd" stroke="#333" stroke-width="2"/>
        <text x="120" y="65" font-size="14" text-anchor="middle">+</text>

        <line x1="105" y1="78" x2="60" y2="120" stroke="#333" stroke-width="1.5"/>
        <line x1="135" y1="78" x2="180" y2="120" stroke="#333" stroke-width="1.5"/>

        <circle cx="60" cy="140" r="18" fill="#e6ffe6" stroke="#333" stroke-width="1.5"/>
        <text x="60" y="145" font-size="12" text-anchor="middle">a</text>

        <circle cx="180" cy="140" r="20" fill="#fffacd" stroke="#333" stroke-width="2"/>
        <text x="180" y="145" font-size="14" text-anchor="middle">*</text>

        <line x1="165" y1="158" x2="140" y2="185" stroke="#333" stroke-width="1.5"/>
        <line x1="195" y1="158" x2="220" y2="185" stroke="#333" stroke-width="1.5"/>

        <circle cx="140" cy="195" r="15" fill="#e6ffe6" stroke="#333" stroke-width="1.5"/>
        <text x="140" y="200" font-size="12" text-anchor="middle">b</text>

        <circle cx="220" cy="195" r="15" fill="#e6ffe6" stroke="#333" stroke-width="1.5"/>
        <text x="220" y="200" font-size="12" text-anchor="middle">c</text>

        <!-- Divider -->
        <line x1="320" y1="30" x2="320" y2="190" stroke="#ccc" stroke-width="1" stroke-dasharray="5"/>

        <!-- Linear IR side -->
        <text x="500" y="20" font-size="14" font-weight="bold" text-anchor="middle">Linear IR (Three-Address Code)</text>

        <rect x="380" y="40" width="240" height="130" fill="#f6f8fa" stroke="#d0d7de" rx="5"/>

        <text x="400" y="70" font-size="13">t1 = b * c</text>
        <text x="400" y="100" font-size="13">t2 = a + t1</text>
        <text x="400" y="130" font-size="13" fill="#666">// result in t2</text>

        <text x="400" y="160" font-size="11" fill="#888">↑ Sequential, explicit temps</text>
    </svg>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="laotzus">A Simple Compiler</h3>
<ol>

    <li><b>About It</b></li>
    <br/>
    <ul>
        <li>This is a simple compiler I wrote when I was 9 ~ 10, which is super super minimal and I couldn't even guarantee it still runs.</li>
        <li>However, I found it weeks ago from my old hard drive. Therefore, I'll uploading it in my GitHub and named it <a href="https://github.com/hwang-fu/Laotzus">Laotzus</a>.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
