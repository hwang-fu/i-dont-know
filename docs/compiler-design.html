<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>My Insights About Compiler Design</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }

    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }

    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/compiler.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#compiler-intro">Introduction</a></li>
        <li><a href="#compiler-phases">Phases</a></li>
        <li><a href="#compiler-lexical-analyzer">Lexical Analyzer</a></li>
        <li><a href="#compiler-dfa-intro">Deterministic Finite Automata (DFA)</a></li>
        <li><a href="#compiler-left-refactoring">Left Refactoring</a></li>
        <li><a href="#laotzus">A Simple Compiler I Wrote When I Was About 9 ~ 10</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-intro">Introduction to Compiler Design</h3>
<ol>
    <li><mark>NOTE</mark>:<br/>
        I'm not a professional computer scientist, so the whole content here is based on my poor knowledge.<br/>
        Therefore, it might contain inefficient thinking ways or even wrong thinking ways. I do not assume any responsibility from it.
        <br/>That's it, thanks for your understanding.</li>
    <br/>

    <li><b>What Is a Compiler?</b></li>
    <ul>
        <li>A <u>compiler</u> is a program that transforms source code written in one language
            (e.g., C, Rust, TypeScript) into another form (usually machine code, bytecode, or another high-level language).</li>
        <li>Examples of compilers:
            <ul>
                <li>
                    GCC / Clang
                </li>
                <li>
                    Rustc
                </li>
            </ul>
        </li>
        </li>
    </ul>

    <br/><br/>


    <li><b>The Big Picture: Stages of a Compiler</b></li>
    <br/>
    <ol>
        <li><b>Lexical Analysis</b> (tokenization)</li>
        <ul>
            <li>Breaks raw text into tokens: keywords, identifiers, literals, symbols.</li>
            <li>Example: <code>a = 3 + b</code> → <code>[ID("a"), '=', INT(3), '+', ID("b")]</code></li>
        </ul>
        <br/>

        <li><b>Syntax Analysis</b> (parsing)</li>
        <ul>
            <li>Builds a tree structure called an <u>AST</u> (Abstract Syntax Tree).</li>
            <li>Example: <code>3 + u</code> becomes a <u>binary operation node</u>.</li>
        </ul>
        <br/>

        <li><b>Semantic Analysis</b></li>
        <ul>
            <li>Checks correctness:
                <ul>
                    <li>types</li>
                    <li>scope</li>
                    <li>variable declarations</li>
                    <li>function signatures</li>
                </ul>
            </li>
            <li>Example: <code>"abc" + 5</code> is invalid in many languages.</li>
        </ul>
        <br/>

        <li><b>Intermediate Representation</b> (IR)</li>
        <ul>
            <li>The AST is transformed into a lower-level language closer to machine operations.</li>
            <li>Common IRs:
                <ul>
                    <li>LLVM IR</li>
                    <li>bytecode</li>
                    <li>three-address code (TAC)</li>
                </ul>
            </li>
        </ul>
        <br/>

        <li><b>Optimization</b></li>
        <ul>
            <li>The compiler improves your code:
                <ul>
                    <li>dead code elimination</li>
                    <li>constant folding</li>
                    <li>loop optimizations</li>
                    <li>register allocation</li>
                </ul>
            </li>
        </ul>
        <br/>

        <li><b>Code Generation</b></li>
        <ul>
            <li>Final stage: output machine code, bytecode, JS, etc.</li>
        </ul>
    </ol>

    <br/><br/>


    <li><b>Compiler vs Interpreter</b></li>
    <br/>
    <ul>
        <li><b>Compilers</b>: translate entire program before running.</li>
        <li><b>Interpreters</b>: execute code step-by-step.</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Compiler</th>
                <th>Interpreter</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Produces binary or bytecode</td>
                <td>Runs line-by-line</td>
            </tr>
            <tr>
                <td>Faster execution</td>
                <td>More flexible debugging</td>
            </tr>
            <tr>
                <td>Example: C, Rust</td>
                <td>Example: Python, Ruby</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>The AST (Abstract Syntax Tree)</b></li>
    <br/>
    <ul>
        <li>The AST is the core internal structure produced by the parser.</li>
        <li>Example AST for <code>1 + 2 * 3</code>:</li>
    </ul>

<pre><code class="language-text line-numbers">Add
 ├── Int(1)
 └── Mul
      ├── Int(2)
      └── Int(3)
</code></pre>

    <ul>
        <li>The tree respects precedence: multiplication evaluated before addition.</li>
    </ul>

    <br/><br/>


    <li><b>Intermediate Representation (IR)</b></li>
    <br/>
    <ul>
        <li>An IR is a lower-level representation used for:
            <ul>
                <li>optimization</li>
                <li>analysis</li>
                <li>machine-code generation</li>
            </ul>
        </li>
        <li>A simple “three-address code” example:</li>
    </ul>

<pre><code class="language-text line-numbers">t1 = 2 * 3
t2 = 1 + t1
</code></pre>

    <ul>
        <li>LLVM IR is a real-world example:</li>
    </ul>

<pre><code class="language-llvm line-numbers">%t1 = mul i32 2, 3
%t2 = add i32 1, %t1
</code></pre>

    <br/><br/>


    <li><b>Optimizations</b></li>
    <br/>
    <ul>
        <li>Compilers apply many optimizations automatically:</li>
        <ul>
            <li><b>constant folding</b>: <code>2 * 3</code> → <code>6</code></li>
            <li><b>dead code elimination</b>: remove unused variables</li>
            <li><b>inlining</b>: replace function calls with their bodies</li>
            <li><b>loop unrolling</b></li>
            <li><b>common subexpression elimination</b></li>
        </ul>
    </ul>

    <br/><br/>


    <li><b>Back Ends and Code Generation</b></li>
    <br/>
    <ul>
        <li>The back end turns IR into:
            <ul>
                <li>machine code (x86, ARM)</li>
                <li>bytecode (Python, Java)</li>
                <li>another language (TS → JS)</li>
            </ul>
        </li>
        <li>Example: LLVM back end produces machine instructions:</li>
    </ul>

<pre><code class="language-nasm line-numbers">mov eax, 2
imul eax, 3
add eax, 1
</code></pre>

    <br/><br/>


    <li><b>Front-End vs Back-End</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Front-End</th>
                <th>Back-End</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lexing</td>
                <td>IR to machine code</td>
            </tr>
            <tr>
                <td>Parsing</td>
                <td>Register allocation</td>
            </tr>
            <tr>
                <td>Semantic analysis</td>
                <td>Optimization passes</td>
            </tr>
            <tr>
                <td>AST generation</td>
                <td>Instruction scheduling</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-phases">Different Phases of a Compiler</h3>
<ol>

    <li><b>Prior Knowledge</b></li>
    <br/>
    <ul>
        <li>A compiler transforms <b>source code</b> written in a high-level language (like C, Rust, or Haskell) into <b>machine code</b> or an <b>intermediate form</b>.</li>
        <br/>
        <li>This transformation happens in several well-structured phases.</li>
        <br/>
        <li>Each phase handles one part of the job:
            <ul>
                <li>understanding the program,</li>
                <li>checking for correctness,</li>
                <li>optimizing,</li>
                <li>and generating low-level code.</li>
            </ul>
        </li>
        <br/>
        <li>Although implementations vary between compilers (e.g., GCC, LLVM Clang, Rustc), the overall architecture remains similar.</li>
    </ul>
    <br/><br/>


    <li><b>Lexical Analysis (Scanning)</b></li>
    <br/>
    <ul>
        <li>The first phase of compilation.</li>
        <br/>
        <li>Converts a raw source code string into a sequence of <b>tokens</b>.</li>
        <br/>
        <li>A token is a meaningful atomic unit:
            <ul>
                <li>keywords (<code>if</code>, <code>while</code>)</li>
                <li>identifiers (<code>x</code>, <code>count</code>)</li>
                <li>literals (<code>10</code>, <code>"hello"</code>)</li>
                <li>operators (<code>+</code>, <code>*</code>, <code>==</code>)</li>
                <li>punctuation (<code>;</code>, <code>(</code>, <code>)</code>)</li>
            </ul>
        </li>
        <br/>
        <li>A <b>lexer</b> removes:
            <ul>
                <li>spaces,</li>
                <li>comments,</li>
                <li>line breaks,</li>
                <li>unnecessary formatting.</li>
            </ul>
        </li>
        <br/>
        <li>Example:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Source:     x = 3 + 5;
Tokens:     IDENTIFIER("x"), EQUALS, NUMBER(3), PLUS, NUMBER(5), SEMICOLON

Or in more details as
Tokens:     IDENTIFIER("x"), OPERATOR("="), NUMBER(3), OPERATOR("+"), NUMBER(5), PUNCTUATION(";")
</code></pre>

    <br/><br/>


    <li><b>Syntax Analysis (Parsing)</b></li>
    <br/>
    <ul>
        <li>Given the sequence of tokens, the <b>parser</b> checks whether the code follows the grammatical structure of the language.</li>
        <br/>
        <li>It produces an <b>AST</b> (Abstract Syntax Tree), a hierarchical representation of the program.</li>
        <br/>
        <li>Example: <code>x = 3 + 5</code> becomes:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">      Assignment
     /          \
   Variable     Add
    |          /   \
   "x"        3     5
</code></pre>

    <br/>
    <ul>
        <li>The parser enforces:
            <ul>
                <li>operator precedence,</li>
                <li>parentheses grouping,</li>
                <li>valid statements and expressions.</li>
            </ul>
        </li>
        <br/>
        <li>Parser types:
            <ul>
                <li>Top-down: LL(k), recursive-descent (easy to implement)</li>
                <li>Bottom-up: LR(k), LALR, GLR (used by many production compilers)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Semantic Analysis</b></li>
    <br/>
    <ul>
        <li>The semantic analyzer checks for <b>meaningful correctness</b> of the AST.</li>
        <br/>
        <li>Examples of semantic checks:</li>
        <ul>
            <li>Type checking</li>
            <li>Variable declarations and scopes</li>
            <li>Function arity (argument count)</li>
            <li>Operator/type compatibility</li>
            <li>Control-flow correctness</li>
        </ul>
        <br/>
        <li>The compiler builds:
            <ul>
                <li>a <b>symbol table</b> mapping names to types/locations,</li>
                <li>a <b>type environment</b>,</li>
                <li>a <b>scope tree</b>.</li>
            </ul>
        </li>
        <br/>
        <li>Example error caught here:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">x = "hello" + 5  -- type error: cannot add string and integer
</code></pre>

    <br/>
    <ul>
        <li>Semantic analysis transforms the AST into a <b>typed AST</b> (or annotates nodes with type info).</li>
    </ul>
    <br/><br/>


    <li><b>Intermediate Representation (IR) Generation</b></li>
    <br/>
    <ul>
        <li>Once semantics are validated, the compiler transforms the AST into an <b>IR</b> (Intermediate Representation).</li>
        <br/>
        <li>IR is a lower-level, more regular representation than the AST.</li>
        <br/>
        <li>Most modern compilers use a form of SSA (Static Single Assignment) IR.</li>
        <br/>
        <li>Purpose:
            <ul>
                <li>enable optimizations,</li>
                <li>provide target-independence,</li>
                <li>simplify code generation.</li>
            </ul>
        </li>
        <br/>
        <li>Example (LLVM IR):</li>
    </ul>

<pre><code class="language-plaintext line-numbers">%1 = add i32 3, 5
store i32 %1, i32* @x
</code></pre>

    <br/>
    <ul>
        <li>The IR removes high-level syntax and resolves many abstractions.</li>
    </ul>
    <br/><br/>


    <li><b>Optimization</b></li>
    <br/>
    <ul>
        <li>This is often the largest and most complex phase.</li>
        <br/>
        <li>Perform optimizations on IR to:
            <ul>
                <li>minimize runtime,</li>
                <li>minimize memory,</li>
                <li>increase CPU instruction-level parallelism,</li>
                <li>reduce branches and allocations.</li>
            </ul>
        </li>
        <br/>
        <li>Typical optimizations include:</li>
        <ul>
            <li>Constant folding</li>
            <li>Dead code elimination</li>
            <li>Loop unrolling</li>
            <li>Function inlining</li>
            <li>Common subexpression elimination</li>
            <li>Escape analysis (eliminate heap allocations)</li>
            <li>Copy propagation</li>
        </ul>
        <br/>
        <li>Optimizations may occur at:
            <ul>
                <li>high-level AST,</li>
                <li>mid-level IR (LLVM),</li>
                <li>low-level machine code.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Code Generation</b></li>
    <br/>
    <ul>
        <li>Transforms the optimized IR into:
            <ul>
                <li>target machine code,</li>
                <li>assembly, or</li>
                <li>bytecode (for JVM, CLR, BEAM, etc.).</li>
            </ul>
        </li>
        <br/>
        <li>This phase handles:
            <ul>
                <li>register allocation,</li>
                <li>calling conventions,</li>
                <li>instruction selection,</li>
                <li>stack frame setup,</li>
                <li>function prologues/epilogues.</li>
            </ul>
        </li>
        <br/>
        <li>Example (x86-64 assembly):</li>
    </ul>

<pre><code class="language-plaintext line-numbers">mov eax, 3
add eax, 5
mov [x], eax
</code></pre>

    <br/><br/>


    <li><b>Linking</b></li>
    <br/>
    <ul>
        <li>Final phase: combining all compiled units and libraries into an executable.</li>
        <br/>
        <li>The linker resolves:
            <ul>
                <li>symbol references,</li>
                <li>external functions (e.g., <code>printf</code>),</li>
                <li>imported modules,</li>
                <li>static libraries,</li>
                <li>shared libraries.</li>
            </ul>
        </li>
        <br/>
        <li>For languages like C/C++, linking is separate.</li>
        <br/>
        <li>For languages like Go, Rust, and Haskell, the compiler internally orchestrates linking.</li>
    </ul>
    <br/><br/>


    <li><b>The Big Picture Diagram</b></li>
<pre><code class="language-plaintext line-numbers">    Source Code
         |
         v
  [Lexical Analysis]
         |
         v
   [Syntax Parsing]
         |
         v
 [Semantic Analysis]
         |
         v
 [Intermediate Representation]
         |
         v
     [Optimization]
         |
         v
  [Code Generation]
         |
         v
      [Linking]
         |
         v
    Executable
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-lexical-analyzer">Introduction to the Lexical Analyzer</h3>
<ol>

    <li><b>What Is a Lexical Analyzer?</b></li>
    <br/>
    <ul>
        <li>A <b>lexical analyzer</b>, also called a <b>lexer</b> or <b>scanner</b>, is the first phase of a compiler.</li>
        <br/>
        <li>Its job is to transform raw source code (a stream of characters) into a stream of <b>tokens</b>.</li>
        <br/>
        <li>A token is a structured, meaningful element such as:
            <ul>
                <li>Keywords: <code>if</code>, <code>let</code>, <code>while</code></li>
                <li>Identifiers: <code>x</code>, <code>totalAmount</code></li>
                <li>Literals: <code>42</code>, <code>"hello"</code>, <code>true</code></li>
                <li>Operators: <code>+</code>, <code>-</code>, <code>==</code>, <code>=</code></li>
                <li>Punctuation: <code>;</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code></li>
            </ul>
        </li>
        <br/>
        <li>The lexer removes:
            <ul>
                <li>whitespace (spaces, tabs, newlines),</li>
                <li>comments,</li>
                <li>formatting irrelevant to syntax.</li>
            </ul>
        </li>
        <br/>
        <li>The output of a lexer is a clean token stream ready for parsing.</li>
    </ul>
    <br/><br/>


    <li><b>Why Is Lexical Analysis Needed?</b></li>
    <br/>
    <ul>
        <li>Languages are easier to reason about when reduced to meaningful units.</li>
        <br/>
        <li>A parser should process <b>tokens</b>, not raw characters.</li>
        <br/>
        <li>Lexers simplify parsing by:
            <ul>
                <li>grouping multi-character operators (<code>==</code>, <code>&gt;=</code>)</li>
                <li>handling keywords vs identifiers</li>
                <li>normalizing whitespace</li>
                <li>detecting early lexical errors (invalid characters)</li>
            </ul>
        </li>
        <br/>
        <li>Without a lexer, parsers become extremely complicated.</li>
    </ul>
    <br/><br/>


    <li><b>The Lexical Unit: Tokens</b></li>
    <br/>
    <ul>
        <li>Each token has generally:
            <ul>
                <li><b>type</b> (e.g., NUMBER, IDENTIFIER)</li>
                <li><b>lexeme</b> — the exact string matched</li>
                <li><b>literal value</b> (optional, e.g. integer value 42)</li>
                <li><b>position</b> (line/column for error reporting)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-plaintext line-numbers">Token {
    type: IDENTIFIER,
    lexeme: "total",
    literal: null,
    line: 3
}
</code></pre>

    <br/>
    <ul>
        <li>Tokens form a clean “interface” between source text and syntax analysis.</li>
    </ul>
    <br/><br/>


    <li><b>How the Lexer Works</b></li>
    <br/>
    <ul>
        <li>Lexers commonly operate using:
            <ul>
                <li><b>Deterministic Finite Automata (DFA)</b></li>
                <li><b>Regular expressions</b></li>
            </ul>
        </li>
        <br/>
        <li>The lexer scans the input left to right, grouping characters into the longest valid token.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Example:
Input:   x = 12 + 7
Output:  IDENT("x"), EQUALS, NUMBER(12), PLUS, NUMBER(7)
</code></pre>

    <br/><br/>


    <li><b>Token Categories (Example)</b></li>
    <br/>

    <ul>
        <li><b>Identifiers</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">myVar, count1, is_valid</code></pre>

    <ul>
        <li><b>Keywords</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">if, else, while, return</code></pre>

    <ul>
        <li><b>Literals</b>: integers, floats, strings, booleans</li>
    </ul>

<pre><code class="language-plaintext line-numbers">42, 3.14, "abc", true</code></pre>

    <ul>
        <li><b>Operators</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">+, -, *, /, ==, !=, &gt;=, &lt;=, =</code></pre>

    <ul>
        <li><b>Punctuation</b></li>
    </ul>

<pre><code class="language-plaintext line-numbers">;, ,, (, ), {, }</code></pre>

    <ul>
        <li><b>Comments</b> (ignored by the lexer)</li>
    </ul>

<pre><code class="language-plaintext line-numbers">// single-line
/* multi-line */
</code></pre>

    <br/><br/>


    <li><b>Lexical Errors</b></li>
    <br/>
    <ul>
        <li>The lexer is also responsible for catching invalid characters:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">abc @ def
    ^
    error: unexpected character '@'
</code></pre>

    <br/>
    <ul>
        <li>If an invalid lexeme is encountered, compilation stops at the lexical phase.</li>
    </ul>
    <br/><br/>


    <li>There are several common ways to build a lexer:</li>
    <ul>
        <br/>
        <li><b>Regex-based lexers</b></li>
        <br/>
        <li><b>DFA-based scanners</b></li>
        <br/>
        <li><b>Hand-written lexers</b> — common in simpler compilers</li>
    </ul>
    <br/><br/>


    <li><b>Longest Match Rule</b></li>
    <br/>
    <ul>
        <li>Lexers usually apply the <b>maximal match</b> principle:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Input:           &gt;=
Lexer picks:    "&gt;="   (not just "&gt;")
</code></pre>

    <br/>
    <ul>
        <li>This ensures ambiguous prefixes are handled properly.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-dfa-intro">Introduction to Deterministic Finite Automata (DFA)</h3>
<ol>

    <li><b>What Is a DFA? (In Simple Words, About Strict Definitions Please Go Read A Professional Book)</b></li>
    <br/>
    <ul>
        <li>A Deterministic Finite Automaton (<u>DFA</u>) is a simple mathematical machine used to recognize and process patterns in strings.</li>
        <br/>
        <li>A DFA reads an input string character by character and uses <u>states</u> to decide what to do next.</li>
        <br/>
        <li>If the machine ends in an <u>accept state</u>, then the string matches the pattern.</li>
    </ul>

    <br/><br/>


    <li><b>Formal Definition of a DFA</b></li>
    <br/>
    <ul>
        <li>A DFA consists of 5 components:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">DFA = (Q, Σ, δ, q₀, F)

Q   = set of states
Σ   = input alphabet (characters allowed)
δ   = transition function: Q × Σ → Q
q₀  = start state
F   = set of accepting states
</code></pre>
    <br/><br/>


    <li><b>Example 1: DFA for Recognizing Strings That End With "ab"</b></li>
    <br/>

<pre><code class="language-plaintext line-numbers">Alphabet: {a, b}
Language: All strings that end with "ab"
Examples accept:  "ab", "aab", "bbab", "aaab"
Examples reject:  "a", "ba", "abb", "bbaa"
</code></pre>

    <br/>
    <ul>
        <li>The DFA Transition Table:</li>
        <br/>
    <table>
        <thead>
            <tr>
                <th>State</th>
                <th>On <code>a</code></th>
                <th>On <code>b</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>q0</code> (start)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
            <tr>
                <td><code>q1</code></td>
                <td><code>q1</code></td>
                <td><code>q2</code></td>
            </tr>
            <tr>
                <td><code>q2</code> (accept)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
        </tbody>
    </table>
    </ul>

    <br/>
    <ul>
        <li>State meanings:</li>
        <ul>
            <li><b>q0</b>: nothing matched yet</li>
            <li><b>q1</b>: last char was 'a'</li>
            <li><b>q2</b> (accept): last two chars are "ab"</li>
        </ul>
    </ul>

    <br/>
    <ul>
        <li>Simulating input <code>aab</code>:</li>

<pre><code class="language-plaintext line-numbers">Start in q0
Read 'a' → q1
Read 'a' → q1
Read 'b' → q2 (accept!)
</code></pre>

    </ul>

    <br/><br/>


    <li><b>Example 2: DFA for Numbers with Even Number of 0s</b></li>
    <br/>
    <ul>
        <li>This DFA checks whether the number of <code>0</code> characters is <b>even</b>.</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Alphabet: {0, 1}
Accept: strings with even number of 0s
</code></pre>

    <br/>
    <table>
        <thead>
            <tr>
                <th>State</th>
                <th>On <code>0</code></th>
                <th>On <code>1</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>Even</code> (start, accept)</td>
                <td><code>Odd</code></td>
                <td><code>Even</code></td>
            </tr>
            <tr>
                <td><code>Odd</code></td>
                <td><code>Even</code></td>
                <td><code>Odd</code></td>
            </tr>
        </tbody>
    </table>
    <br/>

    <ul>
        <li>State meaning:
            <ul>
                <li><b>Even</b>: seen even number of 0s (accept state)</li>
                <li><b>Odd</b>: seen odd number of 0s</li>
            </ul>
        </li>

<pre><code class="language-plaintext line-numbers">Example: 10100
Even --1--&gt; Even --0--&gt; Odd --1--&gt; Odd --0--&gt; Even --0--&gt; Odd (reject)
</code></pre>
    </ul>

    <br/><br/>


    <li><b>Transition Table Representation</b></li>
    <br/>
    <ul>
        <li>A DFA can also be represented using a table.</li>
        <li>For the &quot;ends with ab&quot; automaton:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">       |   a   |   b
--------------------------------
q0     |  q1   |  q0
q1     |  q1   |  q2
q2     |  q1   |  q0
</code></pre>

    <br/>
    <ul>
        <li>The table precisely defines the behaviour of the machine.</li>
    </ul>
    <br/><br/>


    <li><b>DFA Simulation (Pseudocode)</b></li>
    <br/>
    <ul>
        <li>Every DFA can be simulated by repeatedly applying the transition function.</li>
    </ul>

<pre><code class="language-c line-numbers">def run_dfa(trans, start, accepts, s):
    state = start
    for c in s:
        state = trans[state][c]
    return state in accepts

transition = {
    "q0": {"a": "q1", "b": "q0"},
    "q1": {"a": "q1", "b": "q2"},
    "q2": {"a": "q1", "b": "q0"},
}

print(run_dfa(transition, "q0", {"q2"}, "aab"))   // True
</code></pre>

    <br/><br/>


    <li><b>DFA vs NFA (Briefly)</b></li>
    <br/>
    <ul>
        <li>A DFA has:
            <ul>
                <li>exactly one transition per input symbol,</li>
                <li>exactly one active state at any time.</li>
            </ul>
        </li>
        <li>An NFA (nondeterministic finite automaton) may have:
            <ul>
                <li>multiple possible transitions,</li>
                <li>ε-transitions (move without input),</li>
                <li>multiple active states.</li>
            </ul>
        </li>
        <li>But both recognize exactly the same class of languages (<u>regular languages</u>).</li>
    </ul>
    <br/><br/>
    <br/>
    <table>
        <thead>
            <tr>
                <th colspan="3">DFA: Strings Ending with "ab"</th>
            </tr>
            <tr>
                <th>State</th>
                <th>On <code>a</code></th>
                <th>On <code>b</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>q0</code> (start)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
            <tr>
                <td><code>q1</code></td>
                <td><code>q1</code></td>
                <td><code>q2</code></td>
            </tr>
            <tr>
                <td><code>q2</code> (accept)</td>
                <td><code>q1</code></td>
                <td><code>q0</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
<table>
    <thead>
        <tr>
            <th colspan="3">NFA: Strings Ending with "ab"</th>
        </tr>
        <tr>
            <th>State</th>
            <th>On <code>a</code></th>
            <th>On <code>b</code></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>q0</code> (start)</td>
            <td>{q0, q1}</td>
            <td>{q0}</td>
        </tr>
        <tr>
            <td><code>q1</code></td>
            <td>{q1}</td>
            <td>{q2}</td>
        </tr>
        <tr>
            <td><code>q2</code> (accept)</td>
            <td>{q1}</td>
            <td>{q0}</td>
        </tr>
    </tbody>
</table>
<br/>


</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="compiler-left-refactoring">Left Factoring</h3>
<ol>
    <li><b>What Is Left Factoring?</b></li>

    <ul>
        <br/>
        <li/>
            Left factoring is a grammar transformation technique used in compiler design.<br/>
            It's essential for building <u>predictive parsers</u> (like LL(1) parsers) that need to decide which production to use by looking at only one token ahead.
        </li>
        <br/>
        <li>When two or more productions for the same non-terminal start with the same symbol(s), the parser cannot decide which rule to apply.</li>
        <br/>
        <li>Left factoring extracts the common prefix into a single production, deferring the decision until after the prefix is consumed.</li>
    </ul>
    <br/>


    <br/><br/>


    <li><b>Why Do We Need It?</b></li>
    <br/>
    <ul>
        <li>Consider a predictive parser looking at input and trying to choose a production:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Grammar:
    A -> α β₁
    A -> α β₂

Problem: When parser sees the start of α, it cannot decide between the two rules!
</code></pre>

    <ul>
        <li>The parser would need to "look ahead" beyond α to make a decision — but LL(1) parsers only look at <b>one</b> token.</li>
        <li>Left factoring solves this by restructuring the grammar:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After left factoring:
    A  -> α A'
    A' -> β₁
    A' -> β₂

Now: Parser consumes α first, THEN decides between β₁ and β₂.
</code></pre>

    <br/><br/>


    <li><b>The General Algorithm</b></li>
    <br/>
    <ul>
        <li>For each non-terminal A with productions that share a common prefix α:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before:
    A -> α β₁ | α β₂ | ... | α βₙ | γ

After:
    A  -> α A' | γ
    A' -> β₁ | β₂ | ... | βₙ
</code></pre>

    <ul>
        <li>Where γ represents any alternatives that don't share the prefix α.</li>
        <li>If βᵢ is empty for some i, then A' -> ε (epsilon) is one of the alternatives.</li>
    </ul>

    <br/><br/>


    <li><b>Example 1: Simple Arithmetic Expression</b></li>
    <br/>
    <ul>
        <li>A classic example from expression parsing:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    expr -> term + expr
    expr -> term

Problem: Both start with "term" — parser can't decide!
</code></pre>

    <br/>
    <ul>
        <li>After left factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    expr  -> term expr'
    expr' -> + expr
    expr' -> ε
</code></pre>

    <br/>
    <ul>
        <li>Visualization of the transformation:</li>
    </ul>
    <br/>

    <svg viewBox="0 0 700 200" style="max-width: 700px; font-family: monospace;">
        <!-- Before side -->
        <text x="100" y="20" font-size="14" font-weight="bold" text-anchor="middle">Before</text>
        <circle cx="100" cy="60" r="25" fill="#ffe6e6" stroke="#333" stroke-width="2"/>
        <text x="100" y="65" font-size="12" text-anchor="middle">expr</text>

        <line x1="85" y1="85" x2="50" y2="130" stroke="#333" stroke-width="1.5"/>
        <line x1="115" y1="85" x2="150" y2="130" stroke="#333" stroke-width="1.5"/>

        <text x="50" y="150" font-size="11" text-anchor="middle">term + expr</text>
        <text x="150" y="150" font-size="11" text-anchor="middle">term</text>

        <text x="100" y="180" font-size="11" fill="#c00" text-anchor="middle">⚠ Common prefix "term"</text>

        <!-- Arrow -->
        <line x1="220" y1="100" x2="280" y2="100" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
            </marker>
        </defs>

        <!-- After side -->
        <text x="480" y="20" font-size="14" font-weight="bold" text-anchor="middle">After</text>
        <circle cx="400" cy="60" r="25" fill="#e6ffe6" stroke="#333" stroke-width="2"/>
        <text x="400" y="65" font-size="12" text-anchor="middle">expr</text>

        <line x1="400" y1="85" x2="400" y2="115" stroke="#333" stroke-width="1.5"/>
        <text x="400" y="135" font-size="11" text-anchor="middle">term expr'</text>

        <circle cx="560" cy="60" r="25" fill="#e6f3ff" stroke="#333" stroke-width="2"/>
        <text x="560" y="65" font-size="12" text-anchor="middle">expr'</text>

        <line x1="545" y1="85" x2="510" y2="130" stroke="#333" stroke-width="1.5"/>
        <line x1="575" y1="85" x2="610" y2="130" stroke="#333" stroke-width="1.5"/>

        <text x="510" y="150" font-size="11" text-anchor="middle">+ expr</text>
        <text x="610" y="150" font-size="11" text-anchor="middle">ε</text>

        <text x="480" y="180" font-size="11" fill="#080" text-anchor="middle">✓ Decision deferred to expr'</text>
    </svg>

    <br/><br/>


    <li><b>Example 2: The Dangling Else Problem</b></li>
    <br/>
    <ul>
        <li>This is a famous ambiguity in programming language grammars:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    stmt -> if ( expr ) stmt else stmt
    stmt -> if ( expr ) stmt
    stmt -> while ( expr ) stmt
    stmt -> id = expr ;

Problem: Both "if" rules share a long common prefix!
</code></pre>

    <br/>
    <ul>
        <li>After left factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    stmt  -> if ( expr ) stmt stmt'
    stmt  -> while ( expr ) stmt
    stmt  -> id = expr ;
    stmt' -> else stmt
    stmt' -> ε
</code></pre>

    <br/>
    <ul>
        <li>The common prefix <code>if ( expr ) stmt</code> is factored out.</li>
        <li>The decision between "else" and "nothing" is deferred to <code>stmt'</code>.</li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Input After Parsing <code>if(expr)stmt</code></th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Next token is <code>else</code></td>
                <td>Use <code>stmt' -> else stmt</code></td>
            </tr>
            <tr>
                <td>Next token is something else</td>
                <td>Use <code>stmt' -> ε</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Example 3: Multiple Groups of Common Prefixes</b></li>
    <br/>
    <ul>
        <li>Sometimes you have multiple different prefixes that each need factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    decl -> int id ;
    decl -> int id [ num ] ;
    decl -> float id ;
    decl -> float id [ num ] ;
</code></pre>

    <br/>
    <ul>
        <li>Here we have TWO groups of common prefixes: <code>int id</code> and <code>float id</code>.</li>
        <li>First pass — factor out within each group:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    decl  -> int id decl'
    decl  -> float id decl'
    decl' -> ;
    decl' -> [ num ] ;
</code></pre>

    <br/>
    <ul>
        <li>We can go even further by factoring out the type:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Even more factored (optional):
    decl  -> type id decl'
    type  -> int
    type  -> float
    decl' -> ;
    decl' -> [ num ] ;
</code></pre>

    <br/><br/>


    <li><b>Example 4: Three or More Alternatives</b></li>
    <br/>
    <ul>
        <li>When more than two alternatives share a prefix, you may need multiple passes:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    print_stmt -> print expr ;
    print_stmt -> print expr , expr ;
    print_stmt -> print expr , expr , expr ;
</code></pre>

    <br/>
    <ul>
        <li>First pass — factor out <code>print expr</code>:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (first pass):
    print_stmt  -> print expr print_stmt'
    print_stmt' -> ;
    print_stmt' -> , expr ;
    print_stmt' -> , expr , expr ;
</code></pre>

    <br/>
    <ul>
        <li>But wait! <code>print_stmt'</code> still has common prefixes. Second pass:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (second pass):
    print_stmt   -> print expr print_stmt'
    print_stmt'  -> ;
    print_stmt'  -> , expr print_stmt''
    print_stmt'' -> ;
    print_stmt'' -> , expr ;
</code></pre>

    <br/><br/>


    <li><b>Example 5: Nested Factoring (Iterative Process)</b></li>
    <br/>
    <ul>
        <li>A more complex example showing how factoring can require multiple iterations:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    S -> a b c d
    S -> a b c e
    S -> a b f
    S -> a g
    S -> h
</code></pre>

    <br/>
    <ul>
        <li>This requires THREE passes to fully factor. Here's the progression:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Pass</th>
                <th>Common Prefix Found</th>
                <th>Result</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><code>a</code></td>
                <td>Extract <code>S'</code> for what follows <code>a</code></td>
            </tr>
            <tr>
                <td>2</td>
                <td><code>b</code> (in S')</td>
                <td>Extract <code>S''</code> for what follows <code>b</code></td>
            </tr>
            <tr>
                <td>3</td>
                <td><code>c</code> (in S'')</td>
                <td>Extract <code>S'''</code> for what follows <code>c</code></td>
            </tr>
        </tbody>
    </table>

    <br/>

<pre><code class="language-plaintext line-numbers">After (pass 1):
    S  -> a S'
    S  -> h
    S' -> b c d
    S' -> b c e
    S' -> b f
    S' -> g

After (pass 2):
    S   -> a S'
    S   -> h
    S'  -> b S''
    S'  -> g
    S'' -> c d
    S'' -> c e
    S'' -> f

After (pass 3 — final):
    S    -> a S'
    S    -> h
    S'   -> b S''
    S'   -> g
    S''  -> c S'''
    S''  -> f
    S''' -> d
    S''' -> e
</code></pre>

    <br/>
    <ul>
        <li>Visualizing the final grammar as a decision tree:</li>
    </ul>
    <br/>

    <svg viewBox="-100 0 550 420" style="max-width: 500px; font-family: monospace;">
        <!-- S node -->
        <circle cx="200" cy="30" r="20" fill="#fffacd" stroke="#333" stroke-width="2"/>
        <text x="200" y="35" font-size="12" text-anchor="middle">S</text>

        <!-- S branches -->
        <line x1="185" y1="48" x2="100" y2="90" stroke="#333" stroke-width="1.5"/>
        <line x1="215" y1="48" x2="300" y2="90" stroke="#333" stroke-width="1.5"/>
        <text x="135" y="65" font-size="10" fill="#666">a</text>
        <text x="265" y="65" font-size="10" fill="#666">h</text>

        <!-- S' node -->
        <circle cx="100" cy="110" r="20" fill="#e6f3ff" stroke="#333" stroke-width="2"/>
        <text x="100" y="115" font-size="12" text-anchor="middle">S'</text>

        <!-- h terminal -->
        <rect x="280" y="95" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="300" y="112" font-size="11" text-anchor="middle">h</text>

        <!-- S' branches -->
        <line x1="85" y1="128" x2="40" y2="170" stroke="#333" stroke-width="1.5"/>
        <line x1="115" y1="128" x2="160" y2="170" stroke="#333" stroke-width="1.5"/>
        <text x="55" y="145" font-size="10" fill="#666">b</text>
        <text x="145" y="145" font-size="10" fill="#666">g</text>

        <!-- S'' node -->
        <circle cx="40" cy="190" r="20" fill="#ffe6f0" stroke="#333" stroke-width="2"/>
        <text x="40" y="195" font-size="12" text-anchor="middle">S''</text>

        <!-- g terminal -->
        <rect x="140" y="175" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="160" y="190" font-size="11" text-anchor="middle">g</text>

        <!-- S'' branches -->
        <line x1="25" y1="208" x2="0" y2="250" stroke="#333" stroke-width="1.5"/>
        <line x1="55" y1="208" x2="80" y2="250" stroke="#333" stroke-width="1.5"/>
        <text x="5" y="225" font-size="10" fill="#666">c</text>
        <text x="75" y="225" font-size="10" fill="#666">f</text>

        <!-- S''' node -->
        <circle cx="0" cy="270" r="18" fill="#f0e6ff" stroke="#333" stroke-width="2"/>
        <text x="0" y="275" font-size="11" text-anchor="middle">S'''</text>

        <!-- f terminal -->
        <rect x="60" y="255" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="80" y="272" font-size="11" text-anchor="middle">f</text>

        <!-- S''' branches -->
        <line x1="-12" y1="286" x2="-30" y2="310" stroke="#333" stroke-width="1.5"/>
        <line x1="12" y1="286" x2="30" y2="310" stroke="#333" stroke-width="1.5"/>
        <text x="-35" y="300" font-size="10" fill="#666">d</text>
        <text x="35" y="300" font-size="10" fill="#666">e</text>
        <!-- d terminal -->
        <rect x="-60" y="315" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="-40" y="332" font-size="11" text-anchor="middle">d</text>
        <!-- e terminal -->
        <rect x="20" y="315" width="40" height="25" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="40" y="332" font-size="11" text-anchor="middle">e</text>

        <!-- Legend -->
        <rect x="350" y="150" width="15" height="15" fill="#fffacd" stroke="#333" stroke-width="1"/>
        <text x="370" y="162" font-size="10">Non-terminal</text>
        <rect x="350" y="175" width="15" height="15" fill="#e6ffe6" stroke="#333" stroke-width="1"/>
        <text x="370" y="187" font-size="10">Terminal</text>
    </svg>

    <br/><br/>


    <li><b>Example 6: A Realistic Function Definition Grammar</b></li>
    <br/>
    <ul>
        <li>Real programming languages have complex grammars. Here's a function definition:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">Before (problematic):
    func -> id ( ) { stmts }
    func -> id ( ) : type { stmts }
    func -> id ( params ) { stmts }
    func -> id ( params ) : type { stmts }
</code></pre>

    <br/>
    <ul>
        <li>All four start with <code>id (</code> — a parser seeing <code>foo(</code> has no idea which rule to use!</li>
        <li>After careful factoring:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">After (left-factored):
    func    -> id ( func'
    func'   -> ) func''
    func'   -> params ) func''
    func''  -> { stmts }
    func''  -> : type { stmts }
</code></pre>

    <br/>
    <ul>
        <li>Decision points:</li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>After Seeing</th>
                <th>Look At</th>
                <th>Decision</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>id (</code></td>
                <td>Next token</td>
                <td><code>)</code> → no params; otherwise → has params</td>
            </tr>
            <tr>
                <td><code>id ( ... )</code></td>
                <td>Next token</td>
                <td><code>{</code> → no return type; <code>:</code> → has return type</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>When Left Factoring Is Not Enough</b></li>
    <br/>
    <ul>
        <li>Left factoring only helps with common <b>prefixes</b>.</li>
        <li>It does NOT solve:
            <ul>
                <li><b>Left recursion</b>: <code>A -> A α | β</code> (needs different transformation)</li>
                <li><b>Ambiguity</b>: when the grammar genuinely allows multiple parse trees</li>
                <li><b>Non-LL(1) grammars</b>: some grammars simply cannot be made LL(1)</li>
            </ul>
        </li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Problem</th>
                <th>Solution</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Common prefixes</td>
                <td>Left factoring ✓</td>
            </tr>
            <tr>
                <td>Left recursion</td>
                <td>Left recursion elimination</td>
            </tr>
            <tr>
                <td>Ambiguity</td>
                <td>Rewrite grammar or use precedence rules</td>
            </tr>
            <tr>
                <td>Inherently non-LL(1)</td>
                <td>Use more powerful parser (LR, GLR, etc.)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li>Left factoring transforms: <code>A -> αβ₁ | αβ₂</code> into <code>A -> αA'</code> and <code>A' -> β₁ | β₂</code></li>
        <li>It enables predictive (LL) parsing by deferring decisions until after common prefixes.</li>
        <li>May require multiple passes for deeply nested common prefixes.</li>
        <li>Often used together with left recursion elimination when building LL(1) parsers.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="laotzus">A Simple Compiler</h3>
<ol>

    <li><b>About It</b></li>
    <br/>
    <ul>
        <li>This is a simple compiler I wrote when I was 9 ~ 10, which is super super minimal and I couldn't even guarantee it still runs.</li>
        <li>However, I found it weeks ago from my old hard drive. Therefore, I'll uploading it in my GitHub and named it <a href="https://github.com/hwang-fu/Laotzus">Laotzus</a>.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
