<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Prisma</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/prisma.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#prisma-introduction">Introduction</a></li>
        <li><a href="#prisma-database-connections">Database Connection Configuration</a></li>
        <li><a href="#prisma-connection-pooling">Connection Pooling vs Direct Connection</a></li>
        <li><a href="#prisma-shadow-database">Shadow Database</a></li>
        <li><a href="#prisma-read-replicas">Read Replicas</a></li>
        <li><a href="#prisma-schema-overview">Schema Overview</a></li>
        <li><a href="#prisma-relationships">Understanding Relationships</a></li>
        <li><a href="#prisma-read-operations">Reading Data</a></li>
        <li><a href="#prisma-create-operations">Creating Data</a></li>
        <li><a href="#prisma-update-operations">Upadting Data</a></li>
        <li><a href="#prisma-delete-operations">Deleting Data</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-introduction">Introduction to Prisma ORM</h3>
<ol>

    <li>What Is Prisma?</li>
    <br/>
    <ul>
        <li><b>Prisma</b> is a modern, type-safe ORM (Object-Relational Mapping) for Node.js and TypeScript.</li>
        <br/>
        <li>Prisma is not just an ORM - it's a complete database toolkit that includes:</li>
        <ul>
            <li><code>Prisma Client</code>: auto-generated query builder</li>
            <li><code>Prisma Migrate</code>: declarative database migrations</li>
            <li><code>Prisma Studio</code>: visual database editor</li>
        </ul>
        <br/>
        <li>Official website: <code>https://www.prisma.io</code></li>
    </ul>
    <br/><br/>


    <li>Why Use Prisma?</li>
    <br/>
    <ul>
        <li>Prisma solves common problems with traditional ORMs:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Traditional ORMs</th>
            <th>Prisma</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Complex entity classes</td>
            <td>Simple schema definition</td>
        </tr>
        <tr>
            <td>Runtime type safety issues</td>
            <td>Compile-time type safety</td>
        </tr>
        <tr>
            <td>Poor TypeScript support</td>
            <td>First-class TypeScript support</td>
        </tr>
        <tr>
            <td>N+1 query problems</td>
            <td>Optimized query generation</td>
        </tr>
        <tr>
            <td>Manual migration scripts</td>
            <td>Declarative migrations</td>
        </tr>
        <tr>
            <td>Complex query builder APIs</td>
            <td>Intuitive, readable API</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Supported Databases</li>
    <br/>
    <ul>
        <li>Prisma supports major relational and NoSQL databases:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Database</th>
            <th>Status</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>MongoDB</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>CockroachDB</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>PlanetScale</td>
            <td>✓ Fully supported</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Database-specific features are supported where available (enums, JSON types, etc.).</li>
    </ul>
    <br/><br/>


    <li>Core Concepts</li>
    <br/>
    <ul>
        <li><b>Prisma Schema:</b> A single source of truth for your database structure.</li>
<pre><code class="language-prisma line-numbers">// schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
}</code></pre>
        <br/>
        <li><b>Prisma Client:</b> Auto-generated, type-safe database client.</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Type-safe query
const user = await prisma.user.findUnique({
  where: { email: 'alice@example.com' }
})</code></pre>
        <br/>
        <li><b>Migrations:</b> Version-controlled database schema changes.</li>
<pre><code class="language-bash line-numbers">npx prisma migrate dev --name add_user_model</code></pre>
        <br/>
        <li><b>Prisma Studio:</b> Visual database browser and editor.</li>
<pre><code class="language-bash line-numbers">npx prisma studio</code></pre>
    </ul>
    <br/><br/>


    <li>Installation and Setup</li>
    <br/>
    <ul>
        <li>Install Prisma in your Node.js project:</li>
<pre><code class="language-bash line-numbers">npm install prisma --save-dev
npm install @prisma/client</code></pre>
        <br/>
        <li>Initialize Prisma in your project:</li>
<pre><code class="language-bash line-numbers">npx prisma init</code></pre>
        <br/>
        <li>This creates:</li>
<pre><code class="language-plaintext line-numbers">project/
├── prisma/
│   └── schema.prisma
└── .env</code></pre>
        <br/>
        <li>Configure database connection in <code>.env</code>:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:password@localhost:5432/mydb"</code></pre>
        <br/>
        <li>Example for different databases:</li>
<pre><code class="language-plaintext line-numbers"># PostgreSQL
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"

# MySQL
DATABASE_URL="mysql://user:password@localhost:3306/mydb"

# SQLite
DATABASE_URL="file:./dev.db"

# SQL Server
DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=Password123"

# MongoDB
DATABASE_URL="mongodb://user:password@localhost:27017/mydb"</code></pre>
    </ul>
    <br/><br/>


    <li>The Prisma Schema File</li>
    <br/>
    <ul>
        <li>The <code>schema.prisma</code> file defines your database structure:</li>
<pre><code class="language-prisma line-numbers">// Data source configuration
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Generator configuration
generator client {
  provider = "prisma-client-js"
}

// Data model
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li>Schema components:</li>
<table>
    <thead>
        <tr>
            <th>Component</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>datasource</code></td>
            <td>Database connection configuration</td>
        </tr>
        <tr>
            <td><code>generator</code></td>
            <td>Specifies what to generate (Prisma Client, etc.)</td>
        </tr>
        <tr>
            <td><code>model</code></td>
            <td>Defines database tables/collections</td>
        </tr>
        <tr>
            <td><code>enum</code></td>
            <td>Defines enumeration types</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Creating Your First Model</li>
    <br/>
    <ul>
        <li>Define a simple User model:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}</code></pre>
        <br/>
        <li>Field type modifiers:</li>
<table>
    <thead>
        <tr>
            <th>Modifier</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@id</code></td>
            <td>Defines primary key</td>
        </tr>
        <tr>
            <td><code>@unique</code></td>
            <td>Ensures field values are unique</td>
        </tr>
        <tr>
            <td><code>@default()</code></td>
            <td>Sets default value</td>
        </tr>
        <tr>
            <td><code>@updatedAt</code></td>
            <td>Automatically updates on record modification</td>
        </tr>
        <tr>
            <td><code>?</code></td>
            <td>Makes field optional (nullable)</td>
        </tr>
        <tr>
            <td><code>[]</code></td>
            <td>Defines array/list type</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Common field types:</li>
<pre><code class="language-prisma line-numbers">model Example {
  id        Int      @id
  text      String
  number    Int
  decimal   Float
  boolean   Boolean
  date      DateTime
  json      Json
  bytes     Bytes
}</code></pre>
    </ul>
    <br/><br/>


    <li>Generating Prisma Client</li>
    <br/>
    <ul>
        <li>After defining your schema, generate the Prisma Client:</li>
<pre><code class="language-bash line-numbers">npx prisma generate</code></pre>
        <br/>
        <li>This generates a type-safe client in <code>node_modules/@prisma/client</code>.</li>
        <br/>
        <li>The client is automatically regenerated when you run migrations.</li>
        <br/>
        <li>Import and use the client in your code:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  const user = await prisma.user.create({
    data: {
      email: 'alice@example.com',
      name: 'Alice'
    }
  })
  console.log(user)
}

main()
  .catch(console.error)
  .finally(() =&gt; prisma.$disconnect())</code></pre>
    </ul>
    <br/><br/>


    <li>Database Migrations</li>
    <br/>
    <ul>
        <li>Create and apply migrations during development:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate dev --name init</code></pre>
        <br/>
        <li>This command:</li>
        <ul>
            <li>creates a new migration file</li>
            <li>applies the migration to the database</li>
            <li>regenerates Prisma Client</li>
        </ul>
        <br/>
        <li>Migration files are stored in:</li>
<pre><code class="language-plaintext line-numbers">prisma/
└── migrations/
    └── 20240101000000_init/
        └── migration.sql</code></pre>
        <br/>
        <li>Apply migrations in production:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate deploy</code></pre>
        <br/>
        <li>View migration status:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate status</code></pre>
        <br/>
        <li>Reset database (caution - deletes all data):</li>
<pre><code class="language-bash line-numbers">npx prisma migrate reset</code></pre>
    </ul>
    <br/><br/>


    <li>Basic CRUD Operations</li>
    <br/>
    <ul>
        <li><b>Create:</b> Insert new records</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    name: 'Alice'
  }
})</code></pre>
        <br/>
        <li><b>Read:</b> Query records</li>
<pre><code class="language-typescript line-numbers">// Find unique record
const user = await prisma.user.findUnique({
  where: { email: 'alice@example.com' }
})

// Find many records
const users = await prisma.user.findMany({
  where: { name: { contains: 'Alice' } }
})

// Find first matching record
const user = await prisma.user.findFirst({
  where: { email: 'alice@example.com' }
})</code></pre>
        <br/>
        <li><b>Update:</b> Modify existing records</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.update({
  where: { id: 1 },
  data: { name: 'Alice Updated' }
})</code></pre>
        <br/>
        <li><b>Delete:</b> Remove records</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.delete({
  where: { id: 1 }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Prisma Studio</li>
    <br/>
    <ul>
        <li>Prisma Studio is a visual database browser and editor.</li>
        <br/>
        <li>Start Prisma Studio:</li>
<pre><code class="language-bash line-numbers">npx prisma studio</code></pre>
        <br/>
        <li>This opens a web interface (usually at <code>http://localhost:5555</code>).</li>
    </ul>
    <br/><br/>


    <li>Introspection</li>
    <br/>
    <ul>
        <li>Prisma can introspect existing databases to generate a schema:</li>
<pre><code class="language-bash line-numbers">npx prisma db pull</code></pre>
        <br/>
        <li>This command:</li>
        <ul>
            <li>connects to your database</li>
            <li>analyzes the database schema</li>
            <li>generates corresponding Prisma models</li>
        </ul>
        <br/>
        <li>Useful when:</li>
        <ul>
            <li>adding Prisma to an existing project</li>
            <li>working with a legacy database</li>
            <li>synchronizing schema after manual database changes</li>
        </ul>
        <br/>
        <li>Example workflow with existing database:</li>
<pre><code class="language-bash line-numbers"># 1. Initialize Prisma
npx prisma init

# 2. Configure DATABASE_URL in .env

# 3. Introspect database
npx prisma db pull

# 4. Generate Prisma Client
npx prisma generate</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-database-connections">Database Connection Configuration</h3>
<ol>

    <li>Basic Connection String</li>
    <br/>
    <ul>
        <li>Database connection is configured in <code>.env</code> file:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="provider://user:password@host:port/database?options"</code></pre>
        <br/>
        <li>Referenced in <code>schema.prisma</code>:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Strings by Database</li>
    <br/>
    <ul>
        <li><b>PostgreSQL:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"</code></pre>
        <br/>
        <li><b>MySQL:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mysql://user:password@localhost:3306/mydb"</code></pre>
        <br/>
        <li><b>SQLite:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="file:./dev.db"</code></pre>
        <br/>
        <li><b>SQL Server:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=Pass123;encrypt=true"</code></pre>
        <br/>
        <li><b>MongoDB:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mongodb+srv://user:password@cluster.mongodb.net/mydb?retryWrites=true"</code></pre>
        <br/>
        <li><b>CockroachDB:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:password@host:26257/mydb?sslmode=verify-full"</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Parameters</li>
    <br/>
    <ul>
        <li>PostgreSQL parameters:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?schema=public&connection_limit=10&pool_timeout=20&sslmode=require"</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>schema</code></td>
            <td>PostgreSQL schema name (default: <code>public</code>)</td>
        </tr>
        <tr>
            <td><code>connection_limit</code></td>
            <td>Max number of connections in pool</td>
        </tr>
        <tr>
            <td><code>pool_timeout</code></td>
            <td>Seconds to wait for connection (default: 10)</td>
        </tr>
        <tr>
            <td><code>sslmode</code></td>
            <td><code>disable</code>, <code>prefer</code>, <code>require</code></td>
        </tr>
        <tr>
            <td><code>sslcert</code></td>
            <td>Path to SSL certificate</td>
        </tr>
        <tr>
            <td><code>connect_timeout</code></td>
            <td>Seconds to wait for initial connection</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>MySQL parameters:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mysql://user:pass@localhost:3306/db?connection_limit=10&socket_timeout=10&ssl=true"</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>connection_limit</code></td>
            <td>Max connections in pool</td>
        </tr>
        <tr>
            <td><code>socket_timeout</code></td>
            <td>Seconds before socket timeout</td>
        </tr>
        <tr>
            <td><code>ssl</code></td>
            <td>SSL/TLS configuration</td>
        </tr>
        <tr>
            <td><code>sslcert</code></td>
            <td>Path to SSL certificate</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Connection Pooling</li>
    <br/>
    <ul>
        <li>Set connection pool size:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=20"</code></pre>
        <br/>
        <li>Default pool sizes by database:</li>
<table>
    <thead>
        <tr>
            <th>Database</th>
            <th>Default Pool Size</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td>num_cpus * 2 + 1</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>num_cpus * 2 + 1</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>num_cpus * 2 + 1</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>1 (no pooling)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Configure pool behavior:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=50&pool_timeout=30"</code></pre>
    </ul>
    <br/><br/>


    <li>SSL/TLS Configuration</li>
    <br/>
    <ul>
        <li>PostgreSQL SSL modes:</li>
<pre><code class="language-plaintext line-numbers"># Disable SSL
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=disable"

# Prefer SSL but allow non-SSL
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=prefer"

# Require SSL
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=require"

# Require SSL with certificate verification
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=verify-full&sslcert=./cert.pem&sslidentity=./identity.p12&sslpassword=password"</code></pre>
        <br/>
        <li>MySQL SSL:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mysql://user:pass@localhost:3306/db?ssl=true&sslcert=./cert.pem"</code></pre>
        <br/>
        <li>Certificate-based authentication:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user@localhost:5432/db?sslmode=require&sslcert=/path/to/client-cert.pem&sslkey=/path/to/client-key.pem&sslrootcert=/path/to/ca-cert.pem"</code></pre>
    </ul>
    <br/><br/>


    <li>Environment-Specific Configuration</li>
    <br/>
    <ul>
        <li>Use different URLs per environment:</li>
<pre><code class="language-plaintext line-numbers"># .env.development
DATABASE_URL="postgresql://localhost:5432/mydb_dev"

# .env.test
DATABASE_URL="postgresql://localhost:5432/mydb_test"

# .env.production
DATABASE_URL="postgresql://prod-host:5432/mydb?connection_limit=100&sslmode=require"</code></pre>
        <br/>
        <li>Runtime environment variable:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const databaseUrl = process.env.NODE_ENV === 'test'
  ? process.env.TEST_DATABASE_URL
  : process.env.DATABASE_URL

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: databaseUrl
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Connection URL from Multiple Sources</li>
    <br/>
    <ul>
        <li>Override in schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Optional: direct URL for migrations
  directUrl = env("DIRECT_DATABASE_URL")
}</code></pre>
        <br/>
        <li>Override at runtime:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.CUSTOM_DATABASE_URL
    }
  }
})</code></pre>
        <br/>
        <li>Build connection URL dynamically:</li>
<pre><code class="language-typescript line-numbers">const host = process.env.DB_HOST
const port = process.env.DB_PORT
const user = process.env.DB_USER
const password = process.env.DB_PASSWORD
const database = process.env.DB_NAME

const url = `postgresql://${user}:${password}@${host}:${port}/${database}?schema=public`

const prisma = new PrismaClient({
  datasources: { db: { url } }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Pooling vs Direct Connection</li>
    <br/>
    <ul>
        <li>Use <code>directUrl</code> for migrations with connection poolers:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")        // Pooled connection
  directUrl = env("DIRECT_DATABASE_URL") // Direct connection for migrations
}</code></pre>
        <br/>
        <li>Example with PgBouncer:</li>
<pre><code class="language-plaintext line-numbers"># Pooled connection (application queries)
DATABASE_URL="postgresql://user:pass@pgbouncer:6432/db?pgbouncer=true"

# Direct connection (migrations)
DIRECT_DATABASE_URL="postgresql://user:pass@postgres:5432/db"</code></pre>
        <br/>
        <li>PlanetScale example:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma" // Required for PlanetScale
}</code></pre>
    </ul>
    <br/><br/>


    <li>Shadow Database</li>
    <br/>
    <ul>
        <li>Configure shadow database for development migrations:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"</code></pre>
        <br/>
        <li>Required when:</li>
        <ul>
            <li>database provider doesn't support automatic shadow database creation</li>
            <li>insufficient permissions to create databases</li>
            <li>using managed database services with restrictions</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Read Replicas</li>
    <br/>
    <ul>
        <li>Configure read replicas (Prisma 5.0+):</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [
    {
      name = "read_replicas"
      url  = env("READ_REPLICA_URL")
    }
  ]
}</code></pre>
        <br/>
        <li>Use read replicas in code:</li>
<pre><code class="language-typescript line-numbers">// Write to primary
await prisma.user.create({
  data: { email: 'user@example.com' }
})

// Read from replica
const users = await prisma.user.findMany().$replica()</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Timeouts</li>
    <br/>
    <ul>
        <li>Configure various timeout values:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?connect_timeout=10&pool_timeout=20&socket_timeout=30"</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Timeout Type</th>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Connect</td>
            <td><code>connect_timeout</code></td>
            <td>Seconds to wait for initial connection</td>
        </tr>
        <tr>
            <td>Pool</td>
            <td><code>pool_timeout</code></td>
            <td>Seconds to wait for connection from pool</td>
        </tr>
        <tr>
            <td>Socket</td>
            <td><code>socket_timeout</code></td>
            <td>Seconds to wait for query response</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Special Characters in Connection String</li>
    <br/>
    <ul>
        <li>URL-encode special characters in passwords:</li>
<pre><code class="language-typescript line-numbers">// Password: p@ss:word/123
// Encoded: p%40ss%3Aword%2F123
DATABASE_URL="postgresql://user:p%40ss%3Aword%2F123@localhost:5432/db"</code></pre>
        <br/>
        <li>Common encodings:</li>
<table>
    <thead>
        <tr>
            <th>Character</th>
            <th>Encoded</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@</code></td>
            <td><code>%40</code></td>
        </tr>
        <tr>
            <td><code>:</code></td>
            <td><code>%3A</code></td>
        </tr>
        <tr>
            <td><code>/</code></td>
            <td><code>%2F</code></td>
        </tr>
        <tr>
            <td><code>?</code></td>
            <td><code>%3F</code></td>
        </tr>
        <tr>
            <td><code>#</code></td>
            <td><code>%23</code></td>
        </tr>
        <tr>
            <td><code>&</code></td>
            <td><code>%26</code></td>
        </tr>
        <tr>
            <td><code>=</code></td>
            <td><code>%3D</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Encode programmatically:</li>
<pre><code class="language-typescript line-numbers">const password = "p@ss:word"
const encoded = encodeURIComponent(password)
const url = `postgresql://user:${encoded}@localhost:5432/db`</code></pre>
    </ul>
    <br/><br/>


    <li>Connection String Templates</li>
    <br/>
    <ul>
        <li><b>Local development:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb?schema=public"</code></pre>
        <br/>
        <li><b>Docker Compose:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:postgres@db:5432/mydb?schema=public"</code></pre>
        <br/>
        <li><b>Heroku:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@ec2-host.compute-1.amazonaws.com:5432/db?sslmode=require"</code></pre>
        <br/>
        <li><b>AWS RDS:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@mydb.123456.us-east-1.rds.amazonaws.com:5432/mydb?sslmode=require"</code></pre>
        <br/>
        <li><b>Supabase:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:pass@db.project.supabase.co:5432/postgres?pgbouncer=true"
DIRECT_DATABASE_URL="postgresql://postgres:pass@db.project.supabase.co:5432/postgres"</code></pre>
        <br/>
        <li><b>Railway:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@containers-us-west-123.railway.app:5432/railway"</code></pre>
        <br/>
        <li><b>Neon:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@ep-cool-name-123456.us-east-2.aws.neon.tech/neondb?sslmode=require"</code></pre>
    </ul>
    <br/><br/>


    <li>Testing Connection</li>
    <br/>
    <ul>
        <li>Test database connection:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function testConnection() {
  try {
    await prisma.$connect()
    console.log('Database connection successful')
  } catch (error) {
    console.error('Database connection failed:', error)
  } finally {
    await prisma.$disconnect()
  }
}

testConnection()</code></pre>
        <br/>
        <li>Execute raw query to test:</li>
<pre><code class="language-typescript line-numbers">const result = await prisma.$queryRaw`SELECT 1`
console.log('Connection test:', result)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Connection Issues</li>
    <br/>
    <ul>
        <li>Connection refused:</li>
<pre><code class="language-plaintext line-numbers">Error: Can't reach database server at `localhost:5432`

Solutions:
- Check if database is running
- Verify host and port
- Check firewall rules</code></pre>
        <br/>
        <li>Authentication failed:</li>
<pre><code class="language-plaintext line-numbers">Error: Authentication failed against database server

Solutions:
- Verify username and password
- Check user permissions
- Ensure URL encoding for special characters</code></pre>
        <br/>
        <li>Database does not exist:</li>
<pre><code class="language-plaintext line-numbers">Error: Database `mydb` does not exist

Solutions:
- Create database manually
- Check database name in connection string
- Run migrations to create schema</code></pre>
        <br/>
        <li>SSL required:</li>
<pre><code class="language-plaintext line-numbers">Error: SSL connection is required

Solution:
DATABASE_URL="postgresql://user:pass@host:5432/db?sslmode=require"</code></pre>
        <br/>
        <li>Connection pool exhausted:</li>
<pre><code class="language-plaintext line-numbers">Error: Timed out fetching a connection from the pool

Solutions:
- Increase connection_limit
- Ensure connections are properly closed
- Check for connection leaks</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Database Connections</li>
    <br/>
    <ul>
        <li>Multiple Prisma instances for different databases:</li>
<pre><code class="language-typescript line-numbers">// lib/prisma-main.ts
import { PrismaClient } from '@prisma/client'

export const prismaMain = new PrismaClient({
  datasources: {
    db: { url: process.env.MAIN_DATABASE_URL }
  }
})

// lib/prisma-analytics.ts
import { PrismaClient } from '@prisma/client'

export const prismaAnalytics = new PrismaClient({
  datasources: {
    db: { url: process.env.ANALYTICS_DATABASE_URL }
  }
})</code></pre>
        <br/>
        <li>Multiple schemas (PostgreSQL):</li>
<pre><code class="language-prisma line-numbers">// schema1.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public", "auth"]
}

model User {
  id    Int    @id
  email String

  @@schema("auth")
}

model Post {
  id    Int    @id
  title String

  @@schema("public")
}</code></pre>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-connection-pooling">Connection Pooling vs Direct Connection</h3>
<ol>

    <li>What Is Connection Pooling?</li>
    <br/>
    <ul>
        <li>A <b>connection pool</b> maintains a set of reusable database connections instead of creating new connections for each request.</li>
        <br/>
        <li>Connection lifecycle:</li>
<pre><code class="language-plaintext line-numbers">Without pooling:
Request → Create Connection → Execute Query → Close Connection → Response
(Expensive: ~20-50ms overhead per request)

With pooling:
Request → Get Connection from Pool → Execute Query → Return to Pool → Response
(Fast: ~1-2ms overhead per request)</code></pre>
        <br/>
        <li>Built-in pooling in Prisma:</li>
        <ul>
            <li>Prisma Client includes connection pooling by default</li>
            <li>pool size defaults to <code>(num_cpus * 2) + 1</code></li>
            <li>connections are kept alive and reused</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Direct Connection vs Pooled Connection</li>
    <br/>
    <ul>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>Direct Connection</th>
            <th>Pooled Connection</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Connection Creation</b></td>
            <td>Per request</td>
            <td>Reused from pool</td>
        </tr>
        <tr>
            <td><b>Latency</b></td>
            <td>Higher (20-50ms overhead)</td>
            <td>Lower (1-2ms overhead)</td>
        </tr>
        <tr>
            <td><b>Database Load</b></td>
            <td>High (many connections)</td>
            <td>Low (controlled connections)</td>
        </tr>
        <tr>
            <td><b>Scalability</b></td>
            <td>Limited by max connections</td>
            <td>Better (pool manages connections)</td>
        </tr>
        <tr>
            <td><b>Features</b></td>
            <td>All database features</td>
            <td>May have limitations</td>
        </tr>
        <tr>
            <td><b>Migrations</b></td>
            <td>Supported</td>
            <td>Often not supported</td>
        </tr>
        <tr>
            <td><b>Prepared Statements</b></td>
            <td>Fully supported</td>
            <td>Limited in transaction mode</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Configuring Both in Prisma</li>
    <br/>
    <ul>
        <li>Use <code>url</code> for pooled, <code>directUrl</code> for direct:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")        // Pooled connection
  directUrl = env("DIRECT_DATABASE_URL") // Direct connection
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers"># Pooled connection (via PgBouncer)
DATABASE_URL="postgresql://user:pass@pgbouncer:6432/mydb?pgbouncer=true"

# Direct connection (to PostgreSQL)
DIRECT_DATABASE_URL="postgresql://user:pass@postgres:5432/mydb"</code></pre>
        <br/>
        <li>Behavior:</li>
        <ul>
            <li><code>url</code> - used for queries (<code>prisma.user.findMany()</code>)</li>
            <li><code>directUrl</code> - used for migrations (<code>prisma migrate</code>)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>PgBouncer Configuration</li>
    <br/>
    <ul>
        <li>PgBouncer is a popular PostgreSQL connection pooler.</li>
        <br/>
        <li>Connection modes:</li>
<table>
    <thead>
        <tr>
            <th>Mode</th>
            <th>Description</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>session</code></td>
            <td>Connection held for entire session</td>
            <td>Full PostgreSQL feature support</td>
        </tr>
        <tr>
            <td><code>transaction</code></td>
            <td>Connection held for transaction</td>
            <td>Most common, good performance</td>
        </tr>
        <tr>
            <td><code>statement</code></td>
            <td>Connection returned after each statement</td>
            <td>Maximum connection reuse</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Basic PgBouncer setup:</li>
<pre><code class="language-ini line-numbers"># pgbouncer.ini
[databases]
mydb = host=postgres port=5432 dbname=mydb

[pgbouncer]
listen_port = 6432
listen_addr = *
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20</code></pre>
        <br/>
        <li>Prisma configuration:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:6432/mydb?pgbouncer=true"
DIRECT_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"</code></pre>
        <br/>
        <li>The <code>?pgbouncer=true</code> parameter tells Prisma to use transaction mode optimizations.</li>
    </ul>
    <br/><br/>


    <li>Connection Pool Exhaustion</li>
    <br/>
    <ul>
        <li>Common problem when pool size is too small:</li>
<pre><code class="language-plaintext line-numbers">Error: Timed out fetching a new connection from the connection pool.
More info: http://pris.ly/d/connection-pool</code></pre>
        <br/>
        <li>Causes:</li>
        <ul>
            <li>too many concurrent requests</li>
            <li>connections not being released</li>
            <li>long-running queries</li>
            <li>connection leaks</li>
        </ul>
        <br/>
        <li>Solutions:</li>
<pre><code class="language-plaintext line-numbers"># Increase pool size
DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=50"

# Increase pool timeout
DATABASE_URL="postgresql://user:pass@host:5432/db?pool_timeout=30"</code></pre>
        <br/>
        <li>Always disconnect in scripts:</li>
<pre><code class="language-typescript line-numbers">async function script() {
  try {
    // Your database operations
  } finally {
    await prisma.$disconnect()  // Release connections
  }
}</code></pre>
        <br/>
        <li>Check for connection leaks:</li>
<pre><code class="language-typescript line-numbers">// Bad - connection leak
async function badExample() {
  const prisma = new PrismaClient()
  const users = await prisma.user.findMany()
  return users  // Never disconnects!
}

// Good - proper cleanup
const prisma = new PrismaClient()  // Singleton
async function goodExample() {
  const users = await prisma.user.findMany()
  return users  // Prisma instance managed globally
}</code></pre>
    </ul>
    <br/><br/>


    <li>Calculating Optimal Pool Size</li>
    <br/>
    <ul>
        <li>Formula for traditional servers:</li>
<pre><code class="language-plaintext line-numbers">pool_size = (num_cores * 2) + effective_spindle_count

Example: 4 cores, 1 disk = (4 * 2) + 1 = 9 connections</code></pre>
        <br/>
        <li>Serverless considerations:</li>
<pre><code class="language-plaintext line-numbers">max_connections = max_concurrent_invocations * connection_limit

Example:
- 100 concurrent Lambda invocations
- connection_limit = 1 per invocation
- Total = 100 connections needed

Solution: Use connection pooler to reduce to 10-20 actual connections</code></pre>
        <br/>
        <li>Configure per environment:</li>
<pre><code class="language-plaintext line-numbers"># Development (single developer)
DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=5"

# Production (high traffic)
DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=50"

# Serverless (via pooler)
DATABASE_URL="postgresql://user:pass@pooler:6432/db?connection_limit=1"</code></pre>
    </ul>
    <br/><br/>


    <li>Monitoring Connection Usage</li>
    <br/>
    <ul>
        <li>Check active connections in PostgreSQL:</li>
<pre><code class="language-sql line-numbers">SELECT count(*)
FROM pg_stat_activity
WHERE state = 'active';</code></pre>
        <br/>
        <li>View connection pool metrics in Prisma:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'info', emit: 'event' },
  ]
})

prisma.$on('query', (e) =&gt; {
  console.log('Query:', e.query)
  console.log('Duration:', e.duration, 'ms')
})

// Check pool metrics
const metrics = await prisma.$metrics.json()
console.log(metrics)</code></pre>
        <br/>
        <li>Monitor pool exhaustion events:</li>
<pre><code class="language-typescript line-numbers">prisma.$on('info', (e) => {
  if (e.message.includes('pool timeout')) {
    console.error('Pool exhausted:', e)
    // Alert or scale up
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Migration Strategies</li>
    <br/>
    <ul>
        <li>Always use direct connection for migrations:</li>
<pre><code class="language-bash line-numbers"># This uses directUrl automatically
npx prisma migrate deploy</code></pre>
        <br/>
        <li>If no <code>directUrl</code> configured:</li>
<pre><code class="language-bash line-numbers"># Temporarily set direct connection
DATABASE_URL="postgresql://user:pass@postgres:5432/db" npx prisma migrate deploy</code></pre>
        <br/>
        <li>CI/CD pipeline example:</li>
<pre><code class="language-yaml line-numbers"># GitHub Actions
- name: Run migrations
  env:
    DATABASE_URL: ${{ secrets.DIRECT_DATABASE_URL }}
  run: npx prisma migrate deploy</code></pre>
        <br/>
        <li>Docker Compose setup:</li>
<pre><code class="language-yaml line-numbers">services:
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"

  pgbouncer:
    image: pgbouncer/pgbouncer
    depends_on:
      - postgres
    ports:
      - "6432:6432"

  app:
    environment:
      DATABASE_URL: "postgresql://user:pass@pgbouncer:6432/db?pgbouncer=true"
      DIRECT_DATABASE_URL: "postgresql://user:pass@postgres:5432/db"</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-shadow-database">Shadow Database</h3>
<ol>

    <li>What Is a Shadow Database?</li>
    <br/>
    <ul>
        <li>A <b>shadow database</b> is a temporary database used by Prisma Migrate during development to detect schema drift and generate migrations.</li>
        <br/>
        <li>Purpose:</li>
        <ul>
            <li>validates migration files are correct</li>
            <li>detects manual schema changes</li>
            <li>ensures migrations can be applied cleanly</li>
            <li>generates accurate migration SQL</li>
        </ul>
        <br/>
        <li>Lifecycle:</li>
<pre><code class="language-plaintext line-numbers">1. Prisma creates shadow database
2. Applies all existing migrations
3. Compares result with your schema.prisma
4. Generates new migration if differences found
5. Drops shadow database</code></pre>
        <br/>
        <li>Only used during <code>prisma migrate dev</code>, not in production.</li>
    </ul>
    <br/><br/>


    <li>Automatic vs Manual Configuration</li>
    <br/>
    <ul>
        <li>Prisma automatically creates shadow databases when possible:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Database</th>
            <th>Automatic Shadow DB</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>✓ Yes (creates temporary file)</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
        <tr>
            <td>CockroachDB</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Manual configuration required when:</li>
        <ul>
            <li>user lacks <code>CREATE DATABASE</code> permission</li>
            <li>using managed database services with restrictions</li>
            <li>cloud providers with strict permission models</li>
            <li>database connection via pooler</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Configuring Shadow Database</li>
    <br/>
    <ul>
        <li>Add <code>shadowDatabaseUrl</code> to schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"</code></pre>
        <br/>
        <li>Create shadow database manually:</li>
<pre><code class="language-sql line-numbers">-- PostgreSQL
CREATE DATABASE mydb_shadow;

-- MySQL
CREATE DATABASE mydb_shadow;</code></pre>
        <br/>
        <li>Shadow database must be empty - Prisma will manage its schema.</li>
    </ul>
    <br/><br/>


    <li>How Shadow Database Works</li>
    <br/>
    <ul>
        <li>Step-by-step process during <code>prisma migrate dev</code>:</li>
        <br/>
        <li><b>Step 1: Create or connect to shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Connecting to shadow database...</code></pre>
        <br/>
        <li><b>Step 2: Apply all existing migrations to shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Applying migration `20240101_init`
Applying migration `20240102_add_users`
...</code></pre>
        <br/>
        <li><b>Step 3: Compare shadow database schema with schema.prisma</b></li>
<pre><code class="language-plaintext line-numbers">Detecting schema drift...
Found differences:
  + Added table: posts
  + Added column: users.email</code></pre>
        <br/>
        <li><b>Step 4: Generate migration SQL for differences</b></li>
<pre><code class="language-sql line-numbers">-- CreateTable
CREATE TABLE "posts" (
  "id" SERIAL PRIMARY KEY,
  "title" TEXT NOT NULL
);

-- AlterTable
ALTER TABLE "users" ADD COLUMN "email" TEXT;</code></pre>
        <br/>
        <li><b>Step 5: Apply new migration to main database</b></li>
<pre><code class="language-plaintext line-numbers">Applying migration `20240103_add_posts`</code></pre>
        <br/>
        <li><b>Step 6: Drop shadow database (or keep for next run)</b></li>
<pre><code class="language-plaintext line-numbers">Cleaning up shadow database...</code></pre>
    </ul>
    <br/><br/>


    <li>Schema Drift Detection</li>
    <br/>
    <ul>
        <li>Shadow database enables detection of manual schema changes:</li>
        <br/>
        <li>Scenario: Developer manually adds column to database:</li>
<pre><code class="language-sql line-numbers">-- Manual change (NOT via Prisma)
ALTER TABLE users ADD COLUMN phone VARCHAR(20);</code></pre>
        <br/>
        <li>Running <code>prisma migrate dev</code> detects drift:</li>
<pre><code class="language-plaintext line-numbers">⚠️ We found changes that cannot be executed:

  • Added column `phone` on table `users`

These changes were made outside of Prisma Migrate.
Do you want to:
  1. Mark as applied (skip)
  2. Reset database
  3. Cancel</code></pre>
        <br/>
        <li>Without shadow database, Prisma couldn't detect these changes reliably.</li>
    </ul>
    <br/><br/>


    <li>Error Messages and Solutions</li>
    <br/>
    <ul>
        <li><b>Error: Cannot create shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Error: A migration failed when applied to the shadow database
Database error: permission denied to create database</code></pre>
        <li>Solution: Configure <code>shadowDatabaseUrl</code> manually:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}</code></pre>
        <br/>
        <li><b>Error: Shadow database not empty</b></li>
<pre><code class="language-plaintext line-numbers">Error: The shadow database contains tables that are not tracked by migrations</code></pre>
        <li>Solution: Drop all tables or recreate shadow database:</li>
<pre><code class="language-sql line-numbers">DROP DATABASE mydb_shadow;
CREATE DATABASE mydb_shadow;</code></pre>
        <br/>
        <li><b>Error: Cannot connect to shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Error: Can't reach shadow database server</code></pre>
        <li>Solution: Verify shadow database URL and ensure database exists:</li>
<pre><code class="language-bash line-numbers">psql postgresql://user:pass@localhost:5432/mydb_shadow -c "SELECT 1"</code></pre>
        <br/>
        <li><b>Error: Shadow database URL same as main database</b></li>
<pre><code class="language-plaintext line-numbers">Error: The shadow database and main database cannot be the same</code></pre>
        <li>Solution: Use different database name:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"  # Different name</code></pre>
    </ul>
    <br/><br/>


    <li>Shadow Database with Docker</li>
    <br/>
    <ul>
        <li>Docker Compose example with shadow database:</li>
<pre><code class="language-yaml line-numbers">services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: mydb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Create shadow database on startup
      - ./init-shadow-db.sh:/docker-entrypoint-initdb.d/init-shadow-db.sh

volumes:
  postgres_data:</code></pre>
        <br/>
        <li>Initialization script:</li>
<pre><code class="language-bash line-numbers">#!/bin/bash
# init-shadow-db.sh
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    CREATE DATABASE mydb_shadow;
EOSQL</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb_shadow"</code></pre>
    </ul>
    <br/><br/>


    <li>CI/CD Pipeline Configuration</li>
    <br/>
    <ul>
        <li>GitHub Actions example:</li>
<pre><code class="language-yaml line-numbers">name: Database Migrations

on: [push]

jobs:
  migrate:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Create shadow database
        run: |
          psql postgresql://postgres:postgres@localhost:5432/test_db \
            -c "CREATE DATABASE test_db_shadow;"
        env:
          PGPASSWORD: postgres

      - name: Run migrations
        run: npx prisma migrate dev
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          SHADOW_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db_shadow</code></pre>
    </ul>
    <br/><br/>


    <li>Different Databases for Main and Shadow</li>
    <br/>
    <ul>
        <li>Shadow database can be on different server:</li>
<pre><code class="language-plaintext line-numbers"># Main database on production server
DATABASE_URL="postgresql://user:pass@prod-server.com:5432/mydb"

# Shadow database on local machine
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"</code></pre>
        <br/>
        <li>Useful when:</li>
        <ul>
            <li>production database has strict permissions</li>
            <li>want to avoid any impact on production</li>
            <li>testing migrations locally before production</li>
        </ul>
        <br/>
        <li>Requirements:</li>
        <ul>
            <li>both databases must be same type (PostgreSQL, MySQL, etc.)</li>
            <li>both must be accessible from development machine</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Disabling Shadow Database</li>
    <br/>
    <ul>
        <li>Some scenarios don't require shadow database:</li>
        <br/>
        <li><b>MongoDB:</b> Schema-less, shadow database not applicable</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Use: prisma db push
// Migrations not supported for MongoDB</code></pre>
        <br/>
        <li>Use <code>--skip-seed</code> and <code>--skip-generate</code> flags if needed:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate dev --skip-seed --skip-generate</code></pre>
    </ul>
    <br/><br/>


    <li>Testing Migrations with Shadow Database</li>
    <br/>
    <ul>
        <li>Verify migration before applying to production:</li>
<pre><code class="language-bash line-numbers"># 1. Create migration using shadow database
npx prisma migrate dev --name add_users

# 2. Review generated SQL
cat prisma/migrations/*/migration.sql

# 3. Test on separate staging database
DATABASE_URL=$STAGING_URL npx prisma migrate deploy

# 4. If successful, deploy to production
DATABASE_URL=$PRODUCTION_URL npx prisma migrate deploy</code></pre>
        <br/>
        <li>Dry run with shadow database:</li>
<pre><code class="language-bash line-numbers"># Create migration without applying to main database
npx prisma migrate dev --create-only

# Review and edit migration.sql if needed

# Apply when ready
npx prisma migrate dev</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-read-replicas">Read Replicas</h3>
<ol>

    <li>What Are Read Replicas?</li>
    <br/>
    <ul>
        <li>A <b>read replica</b> is a copy of your primary database that handles read operations only.</li>
        <br/>
        <li>Characteristics:</li>
        <ul>
            <li>primary handles all writes (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>)</li>
            <li>replicas handle reads (<code>SELECT</code>)</li>
            <li>data replicates from primary to replicas (asynchronous)</li>
            <li>replicas are eventually consistent</li>
        </ul>
        <br/>
        <li>Prisma 5.0+ includes native read replica support.</li>
    </ul>
    <br/><br/>


    <li>Typical read/write ratios that benefit from replicas:</li>
    <ul>
        <br/>
        <li>80/20 reads to writes - moderate benefit</li>
        <br/>
        <li>90/10 reads to writes - significant benefit</li>
        <br/>
        <li>95/5+ reads to writes - major benefit</li>
    </ul>
    <br/><br/>


    <li>Basic Configuration</li>
    <br/>
    <ul>
        <li>Configure read replicas in Prisma schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [prismaClientExtension()]
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["readReplicas"]
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers"># Primary database (writes)
DATABASE_URL="postgresql://user:pass@primary.example.com:5432/mydb"

# Read replicas
DATABASE_REPLICA_1="postgresql://user:pass@replica-1.example.com:5432/mydb"
DATABASE_REPLICA_2="postgresql://user:pass@replica-2.example.com:5432/mydb"</code></pre>
        <br/>
        <li>Initialize Prisma Client with replicas:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'
import { readReplicas } from '@prisma/extension-read-replicas'

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: [
      process.env.DATABASE_REPLICA_1!,
      process.env.DATABASE_REPLICA_2!
    ]
  })
)</code></pre>
    </ul>
    <br/><br/>


    <li>Using Read Replicas</li>
    <br/>
    <ul>
        <li>Explicit replica reads with <code>$replica()</code>:</li>
<pre><code class="language-typescript line-numbers">// Read from replica
const users = await prisma.user.findMany().$replica()

// Write to primary (default)
await prisma.user.create({
  data: { email: 'user@example.com' }
})</code></pre>
        <br/>
        <li>All writes automatically go to primary:</li>
<pre><code class="language-typescript line-numbers">// These ALWAYS use primary, no matter what
await prisma.user.create({ data: { email: 'new@example.com' } })
await prisma.user.update({ where: { id: 1 }, data: { name: 'Updated' } })
await prisma.user.delete({ where: { id: 1 } })
await prisma.user.upsert({ where: { id: 1 }, create: {...}, update: {...} })</code></pre>
        <br/>
        <li>Read operations default to primary unless using <code>$replica()</code>:</li>
<pre><code class="language-typescript line-numbers">// Uses primary (default)
const users = await prisma.user.findMany()

// Uses replica (explicit)
const users = await prisma.user.findMany().$replica()</code></pre>
    </ul>
    <br/><br/>


    <li>Load Balancing Strategies</li>
    <br/>
    <ul>
        <li>Prisma uses round-robin load balancing by default:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient().$extends(
  readReplicas({
    url: [
      process.env.DATABASE_REPLICA_1!,  // Request 1, 3, 5...
      process.env.DATABASE_REPLICA_2!   // Request 2, 4, 6...
    ]
  })
)</code></pre>
        <br/>
        <li>Custom load balancing:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient().$extends(
  readReplicas({
    url: async () =&gt; {
      // Custom logic: geography-based routing
      const userRegion = await getUserRegion()

      if (userRegion === 'us-east') {
        return process.env.DATABASE_REPLICA_US_EAST!
      } else if (userRegion === 'eu-west') {
        return process.env.DATABASE_REPLICA_EU_WEST!
      }

      return process.env.DATABASE_REPLICA_1!
    }
  })
)</code></pre>
        <br/>
        <li>Random selection strategy:</li>
<pre><code class="language-typescript line-numbers">const replicas = [
  process.env.DATABASE_REPLICA_1!,
  process.env.DATABASE_REPLICA_2!,
  process.env.DATABASE_REPLICA_3!
]

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: () => {
      const random = Math.floor(Math.random() * replicas.length)
      return replicas[random]
    }
  })
)</code></pre>
        <br/>
        <li>Weighted load balancing:</li>
<pre><code class="language-typescript line-numbers">const replicaWeights = [
  { url: process.env.DATABASE_REPLICA_1!, weight: 50 },  // 50%
  { url: process.env.DATABASE_REPLICA_2!, weight: 30 },  // 30%
  { url: process.env.DATABASE_REPLICA_3!, weight: 20 }   // 20%
]

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: () => {
      const total = replicaWeights.reduce((sum, r) => sum + r.weight, 0)
      let random = Math.random() * total

      for (const replica of replicaWeights) {
        random -= replica.weight
        if (random <= 0) return replica.url
      }

      return replicaWeights[0].url
    }
  })
)</code></pre>
    </ul>
    <br/><br/>


    <li>Replication Lag and Consistency</li>
    <br/>
    <ul>
        <li>Read replicas use <b>asynchronous replication</b> - data isn't immediately consistent.</li>
        <br/>
        <li>Typical replication lag:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Scenario</th>
            <th>Typical Lag</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Same datacenter</td>
            <td>10-100ms</td>
        </tr>
        <tr>
            <td>Same region</td>
            <td>100-500ms</td>
        </tr>
        <tr>
            <td>Cross-region</td>
            <td>500ms-5s</td>
        </tr>
        <tr>
            <td>Heavy load</td>
            <td>Can increase significantly</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Problem scenario:</li>
<pre><code class="language-typescript line-numbers">// Write to primary
await prisma.user.create({
  data: { id: 1, email: 'new@example.com' }
})

// Immediately read from replica - may not exist yet!
const user = await prisma.user.findUnique({
  where: { id: 1 }
}).$replica()

console.log(user) // Might be null due to replication lag</code></pre>
        <br/>
        <li>Solution: Read from primary after writes:</li>
<pre><code class="language-typescript line-numbers">// Write to primary
await prisma.user.create({
  data: { id: 1, email: 'new@example.com' }
})

// Read from primary (not replica) to ensure consistency
const user = await prisma.user.findUnique({
  where: { id: 1 }
})

console.log(user) // Always exists</code></pre>
    </ul>
    <br/><br/>


    <li>Read-After-Write Consistency Pattern</li>
    <br/>
    <ul>
        <li>Ensure users see their own writes immediately:</li>
<pre><code class="language-typescript line-numbers">async function createAndReturnUser(email: string) {
  // Write to primary
  const newUser = await prisma.user.create({
    data: { email }
  })

  // Return from primary, not replica
  return newUser
}

async function updateAndReturnUser(id: number, data: any) {
  // Update on primary
  const updated = await prisma.user.update({
    where: { id },
    data
  })

  // Return from primary
  return updated
}</code></pre>
        <br/>
        <li>Session-based routing:</li>
<pre><code class="language-typescript line-numbers">// Track recent writes per session
const recentWrites = new Map<string, number>()

async function getUserWithConsistency(userId: number, sessionId: string) {
  const lastWrite = recentWrites.get(sessionId) || 0
  const timeSinceWrite = Date.now() - lastWrite

  // If wrote within last 5 seconds, use primary
  if (timeSinceWrite < 5000) {
    return prisma.user.findUnique({ where: { id: userId } })
  }

  // Otherwise use replica
  return prisma.user.findUnique({ where: { id: userId } }).$replica()
}

async function updateUser(userId: number, data: any, sessionId: string) {
  recentWrites.set(sessionId, Date.now())
  return prisma.user.update({ where: { id: userId }, data })
}</code></pre>
    </ul>
    <br/><br/>


    <li>Transactions and Read Replicas</li>
    <br/>
    <ul>
        <li>Transactions always use primary database:</li>
<pre><code class="language-typescript line-numbers">// All operations in transaction use primary
await prisma.$transaction(async (tx) => {
  const user = await tx.user.findUnique({ where: { id: 1 } })  // Primary
  await tx.post.create({ data: { userId: 1, title: 'Post' } }) // Primary

  // Cannot use $replica() inside transactions
  // This would throw an error:
  // await tx.user.findMany().$replica()
})</code></pre>
        <br/>
        <li>Sequential transactions:</li>
<pre><code class="language-typescript line-numbers">const [user, posts] = await prisma.$transaction([
  prisma.user.findUnique({ where: { id: 1 } }),     // Primary
  prisma.post.findMany({ where: { userId: 1 } })    // Primary
  // All queries in $transaction use primary
])</code></pre>
        <br/>
        <li>Mix transactions with replica reads:</li>
<pre><code class="language-typescript line-numbers">// Write operation in transaction
await prisma.$transaction(async (tx) => {
  await tx.user.update({
    where: { id: 1 },
    data: { credits: { increment: 100 } }
  })
})

// Later, read from replica if consistency not critical
const allUsers = await prisma.user.findMany().$replica()</code></pre>
    </ul>
    <br/><br/>


    <li>Geographic Distribution</li>
    <br/>
    <ul>
        <li>Deploy replicas close to users for lower latency:</li>
<pre><code class="language-plaintext line-numbers">Primary: us-east-1 (Virginia)
Replica 1: us-west-2 (Oregon)
Replica 2: eu-west-1 (Ireland)
Replica 3: ap-southeast-1 (Singapore)</code></pre>
        <br/>
        <li>Region-based routing:</li>
<pre><code class="language-typescript line-numbers">const REPLICA_BY_REGION: Record<string, string> = {
  'us-east': process.env.DATABASE_REPLICA_US_EAST!,
  'us-west': process.env.DATABASE_REPLICA_US_WEST!,
  'eu': process.env.DATABASE_REPLICA_EU!,
  'asia': process.env.DATABASE_REPLICA_ASIA!
}

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: async () => {
      const region = await detectUserRegion()
      return REPLICA_BY_REGION[region] || process.env.DATABASE_URL!
    }
  })
)

async function detectUserRegion(): Promise<string> {
  // Detect from request headers, IP geolocation, etc.
  const cloudflareCountry = request.headers.get('cf-ipcountry')

  if (['US', 'CA', 'MX'].includes(cloudflareCountry)) {
    return 'us-east'
  } else if (['GB', 'FR', 'DE'].includes(cloudflareCountry)) {
    return 'eu'
  } else if (['JP', 'SG', 'AU'].includes(cloudflareCountry)) {
    return 'asia'
  }

  return 'us-east'
}</code></pre>
    </ul>
    <br/><br/>


    <li>Monitoring and Observability</li>
    <br/>
    <ul>
        <li>Track which database handles each query:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' }
  ]
}).$extends(
  readReplicas({
    url: [
      process.env.DATABASE_REPLICA_1!,
      process.env.DATABASE_REPLICA_2!
    ]
  })
)

prisma.$on('query', (e) => {
  console.log({
    query: e.query,
    duration: e.duration,
    target: e.target // 'primary' or replica URL
  })
})</code></pre>
        <br/>
        <li>Count queries per database:</li>
<pre><code class="language-typescript line-numbers">const queryStats = {
  primary: 0,
  replica: 0
}

prisma.$on('query', (e) => {
  if (e.target === process.env.DATABASE_URL) {
    queryStats.primary++
  } else {
    queryStats.replica++
  }
})

// Expose metrics endpoint
app.get('/metrics', (req, res) => {
  res.json({
    queries: queryStats,
    ratio: {
      reads: queryStats.replica,
      writes: queryStats.primary
    }
  })
})</code></pre>
        <br/>
        <li>Alert on replica failures:</li>
<pre><code class="language-typescript line-numbers">prisma.$on('error', (e) => {
  if (e.message.includes('replica')) {
    // Alert: replica unavailable
    notifyOps('Replica database unavailable', e)

    // Prisma automatically falls back to primary
  }
})</code></pre>
    </ul>
    <br/><br/>



    <li>Testing with Read Replicas</li>
    <br/>
    <ul>
        <li>Test environment without replicas:</li>
<pre><code class="language-typescript line-numbers">// lib/prisma.ts
const prisma = new PrismaClient()

// Only add read replicas in production
const client = process.env.NODE_ENV === 'production'
  ? prisma.$extends(
      readReplicas({
        url: [
          process.env.DATABASE_REPLICA_1!,
          process.env.DATABASE_REPLICA_2!
        ]
      })
    )
  : prisma

export { client as prisma }</code></pre>
        <br/>
        <li>Simulate replication lag in tests:</li>
<pre><code class="language-typescript line-numbers">async function testReplicationLag() {
  // Write to primary
  await prisma.user.create({
    data: { id: 999, email: 'test@example.com' }
  })

  // Simulate replication lag
  await new Promise(resolve => setTimeout(resolve, 100))

  // Try reading from replica
  const user = await prisma.user.findUnique({
    where: { id: 999 }
  }).$replica()

  // May be null due to lag
  if (!user) {
    console.log('Replication lag detected')
  }
}</code></pre>
        <br/>
        <li>Mock replica for unit tests:</li>
<pre><code class="language-typescript line-numbers">// test/setup.ts
jest.mock('@prisma/extension-read-replicas', () => ({
  readReplicas: () => ({
    // All replica reads use primary in tests
    $replica: () => prisma
  })
}))</code></pre>
    </ul>
    <br/><br/>


    <li>Common Pitfalls</li>
    <br/>
    <ul>
        <li><b>Reading immediately after write:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - may not see new data
await prisma.user.create({ data: { email: 'new@example.com' } })
const user = await prisma.user.findFirst({
  where: { email: 'new@example.com' }
}).$replica() // May return null

// ✓ Good - read from primary
await prisma.user.create({ data: { email: 'new@example.com' } })
const user = await prisma.user.findFirst({
  where: { email: 'new@example.com' }
}) // Uses primary</code></pre>
        <br/>
        <li><b>Using replicas for financial data:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - account balance must be accurate
const balance = await prisma.account.findUnique({
  where: { userId }
}).$replica() // Could show stale balance

// ✓ Good - always use primary for critical data
const balance = await prisma.account.findUnique({
  where: { userId }
})</code></pre>
        <br/>
        <li><b>Not handling replica failures:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - no error handling
const users = await prisma.user.findMany().$replica()

// ✓ Good - Prisma handles failover automatically
// But monitor and alert on failures
const users = await prisma.user.findMany().$replica()
// Automatically falls back to primary if replica fails</code></pre>
        <br/>
        <li><b>Over-using replicas:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - using replica for everything
const session = await prisma.session.findUnique({
  where: { token }
}).$replica() // Session data should be fresh

const notification = await prisma.notification.findFirst({
  where: { userId, read: false }
}).$replica() // Real-time data needs consistency

// ✓ Good - use primary for real-time/critical data
const session = await prisma.session.findUnique({ where: { token } })
const notification = await prisma.notification.findFirst({
  where: { userId, read: false }
})</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-schema-overview">Prisma Schema Overview</h3>
<ol>

    <li>What Is the Prisma Schema?</li>
    <br/>
    <ul>
        <li>The Prisma schema is a declarative configuration file that defines:</li>
        <ul>
            <li>database connection</li>
            <li>Prisma Client generator</li>
            <li>data models (tables/collections)</li>
            <li>relationships between models</li>
            <li>field types and constraints</li>
        </ul>
        <br/>
        <li>Single source of truth for database structure.</li>
        <br/>
        <li>File location: <code>prisma/schema.prisma</code></li>
        <br/>
        <li>Uses Prisma Schema Language (PSL), not SQL or a programming language.</li>
    </ul>
    <br/><br/>


    <li>Schema File Structure</li>
    <br/>
    <ul>
        <li>A complete schema has three main blocks:</li>
<pre><code class="language-prisma line-numbers">// 1. Data source - database connection
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 2. Generator - what to generate
generator client {
  provider = "prisma-client-js"
}

// 3. Data models - your tables/collections
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li>Order of blocks doesn't matter, but conventionally it is datasource → generator → models.</li>
    </ul>
    <br/><br/>


    <li>Data Source Configuration</li>
    <br/>
    <ul>
        <li>Defines database connection:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}</code></pre>
        <br/>
        <li>Supported providers:</li>
<table>
    <thead>
        <tr>
            <th>Provider</th>
            <th>Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td><code>"postgresql"</code></td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td><code>"mysql"</code></td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td><code>"sqlite"</code></td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td><code>"sqlserver"</code></td>
        </tr>
        <tr>
            <td>MongoDB</td>
            <td><code>"mongodb"</code></td>
        </tr>
        <tr>
            <td>CockroachDB</td>
            <td><code>"cockroachdb"</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Additional datasource options:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DIRECT_DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  schemas           = ["public", "auth"]
}</code></pre>
    </ul>
    <br/><br/>


    <li>Generator Configuration</li>
    <br/>
    <ul>
        <li>Defines what Prisma generates:</li>
<pre><code class="language-prisma line-numbers">generator client {
  provider = "prisma-client-js"
}</code></pre>
        <br/>
        <li>Common generator options:</li>
<pre><code class="language-prisma line-numbers">generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma-client"
  previewFeatures = ["readReplicas", "fullTextSearch"]
  binaryTargets   = ["native", "rhel-openssl-1.0.x"]
  engineType      = "binary"
}</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Option</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>provider</code></td>
            <td>Generator to use (usually <code>prisma-client-js</code>)</td>
        </tr>
        <tr>
            <td><code>output</code></td>
            <td>Custom output location for generated client</td>
        </tr>
        <tr>
            <td><code>previewFeatures</code></td>
            <td>Array of preview features to enable</td>
        </tr>
        <tr>
            <td><code>binaryTargets</code></td>
            <td>Target platforms for Prisma engines</td>
        </tr>
        <tr>
            <td><code>engineType</code></td>
            <td><code>"binary"</code> or <code>"library"</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Multiple generators:</li>
<pre><code class="language-prisma line-numbers">generator client {
  provider = "prisma-client-js"
}

generator docs {
  provider = "prisma-docs-generator"
}

generator erd {
  provider = "prisma-erd-generator"
}</code></pre>
    </ul>
    <br/><br/>


    <li>Model Definition</li>
    <br/>
    <ul>
        <li>Models represent database tables (SQL) or collections (MongoDB):</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  age       Int
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}</code></pre>
        <br/>
        <li>Model naming conventions:</li>
        <ul>
            <li>singular PascalCase (e.g., <code>User</code>, not <code>users</code>)</li>
            <li>Prisma automatically pluralizes for database table names</li>
            <li>use <code>@@map</code> to override table name</li>
        </ul>
        <br/>
        <li>Custom table name:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id
  email String

  @@map("custom_users_table")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Field Types</li>
    <ul>
    <br/>
        <li>Scalar types:</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Prisma Type</th>
            <th>PostgreSQL</th>
            <th>MySQL</th>
            <th>SQLite</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>String</code></td>
            <td>text, varchar</td>
            <td>varchar, text</td>
            <td>text</td>
        </tr>
        <tr>
            <td><code>Int</code></td>
            <td>integer</td>
            <td>int</td>
            <td>integer</td>
        </tr>
        <tr>
            <td><code>BigInt</code></td>
            <td>bigint</td>
            <td>bigint</td>
            <td>integer</td>
        </tr>
        <tr>
            <td><code>Float</code></td>
            <td>double precision</td>
            <td>double</td>
            <td>real</td>
        </tr>
        <tr>
            <td><code>Decimal</code></td>
            <td>decimal</td>
            <td>decimal</td>
            <td>N/A</td>
        </tr>
        <tr>
            <td><code>Boolean</code></td>
            <td>boolean</td>
            <td>tinyint(1)</td>
            <td>integer</td>
        </tr>
        <tr>
            <td><code>DateTime</code></td>
            <td>timestamp</td>
            <td>datetime</td>
            <td>numeric</td>
        </tr>
        <tr>
            <td><code>Json</code></td>
            <td>jsonb</td>
            <td>json</td>
            <td>text</td>
        </tr>
        <tr>
            <td><code>Bytes</code></td>
            <td>bytea</td>
            <td>longblob</td>
            <td>blob</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example with different types:</li>
<pre><code class="language-prisma line-numbers">model Product {
  id          Int      @id @default(autoincrement())
  name        String
  price       Decimal  @db.Decimal(10, 2)
  quantity    Int
  inStock     Boolean  @default(true)
  metadata    Json?
  image       Bytes?
  releaseDate DateTime
  views       BigInt   @default(0)
  rating      Float?
}</code></pre>
        <br/>
        <li>Field modifiers:</li>
<table>
    <thead>
        <tr>
            <th>Modifier</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>?</code></td>
            <td>Optional (nullable)</td>
            <td><code>name String?</code></td>
        </tr>
        <tr>
            <td><code>[]</code></td>
            <td>Array/List</td>
            <td><code>tags String[]</code></td>
        </tr>
        <tr>
            <td>none</td>
            <td>Required</td>
            <td><code>email String</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Arrays example:</li>
<pre><code class="language-prisma line-numbers">model Article {
  id        Int      @id @default(autoincrement())
  title     String
  tags      String[]
  viewCount Int[]
}</code></pre>
    </ul>
    <br/><br/>


    <li>Field Attributes</li>
    <br/>
    <ul>
        <li>Attributes modify field behavior using <code>@</code>:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  username  String   @db.VarChar(50)
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@unique([username, email])
}</code></pre>
        <br/>
        <li>Common field attributes:</li>
<table>
    <thead>
        <tr>
            <th>Attribute</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@id</code></td>
            <td>Primary key</td>
        </tr>
        <tr>
            <td><code>@default()</code></td>
            <td>Default value</td>
        </tr>
        <tr>
            <td><code>@unique</code></td>
            <td>Unique constraint</td>
        </tr>
        <tr>
            <td><code>@relation()</code></td>
            <td>Define relationship</td>
        </tr>
        <tr>
            <td><code>@map()</code></td>
            <td>Custom column name</td>
        </tr>
        <tr>
            <td><code>@db.</code></td>
            <td>Native database type</td>
        </tr>
        <tr>
            <td><code>@updatedAt</code></td>
            <td>Auto-update timestamp</td>
        </tr>
        <tr>
            <td><code>@ignore</code></td>
            <td>Exclude from Prisma Client</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Default value functions:</li>
<pre><code class="language-prisma line-numbers">model Example {
  id         String   @id @default(uuid())
  autoId     Int      @default(autoincrement())
  timestamp  DateTime @default(now())
  randomNum  Int      @default(dbgenerated("floor(random() * 100)"))
  constant   String   @default("PENDING")
  boolean    Boolean  @default(true)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Block Attributes</li>
    <br/>
    <ul>
        <li>Block attributes apply to entire model using <code>@@</code>:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String
  firstName String
  lastName  String
  age       Int
  city      String

  @@unique([email, firstName])
  @@index([city])
  @@index([lastName, firstName])
  @@map("users_table")
}</code></pre>
        <br/>
        <li>Common block attributes:</li>
<table>
    <thead>
        <tr>
            <th>Attribute</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@@id([])</code></td>
            <td>Composite primary key</td>
        </tr>
        <tr>
            <td><code>@@unique([])</code></td>
            <td>Composite unique constraint</td>
        </tr>
        <tr>
            <td><code>@@index([])</code></td>
            <td>Database index</td>
        </tr>
        <tr>
            <td><code>@@map()</code></td>
            <td>Custom table name</td>
        </tr>
        <tr>
            <td><code>@@schema()</code></td>
            <td>PostgreSQL schema</td>
        </tr>
        <tr>
            <td><code>@@ignore</code></td>
            <td>Exclude model from Prisma Client</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Composite primary key:</li>
<pre><code class="language-prisma line-numbers">model UserRole {
  userId Int
  roleId Int

  user User @relation(fields: [userId], references: [id])
  role Role @relation(fields: [roleId], references: [id])

  @@id([userId, roleId])
}</code></pre>
        <br/>
        <li>Multiple indexes:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String
  published Boolean
  authorId  Int

  @@index([authorId])
  @@index([published, authorId])
  @@index([title(ops: raw("gin_trgm_ops"))], type: Gin)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Relations</li>
    <br/>
    <ul>
        <li><b>One-to-Many:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  posts Post[]  // Relation field (not in database)
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int    // Foreign key
  author   User   @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li><b>One-to-One:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  userId Int    @unique
  user   User   @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li><b>Many-to-Many (implicit):</b></li>
<pre><code class="language-prisma line-numbers">model Post {
  id         Int        @id @default(autoincrement())
  title      String
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

// Prisma creates join table automatically: _CategoryToPost</code></pre>
        <br/>
        <li><b>Many-to-Many (explicit):</b></li>
<pre><code class="language-prisma line-numbers">model Post {
  id                 Int                  @id @default(autoincrement())
  title              String
  postCategories     PostCategory[]
}

model Category {
  id                 Int                  @id @default(autoincrement())
  name               String
  postCategories     PostCategory[]
}

model PostCategory {
  postId     Int
  categoryId Int
  assignedAt DateTime @default(now())

  post       Post     @relation(fields: [postId], references: [id])
  category   Category @relation(fields: [categoryId], references: [id])

  @@id([postId, categoryId])
}</code></pre>
        <br/>
        <li><b>Self-relations:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id         Int    @id @default(autoincrement())
  name       String
  invitedBy  Int?
  inviter    User?  @relation("UserInvites", fields: [invitedBy], references: [id])
  invitees   User[] @relation("UserInvites")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Relation Actions</li>
    <br/>
    <ul>
        <li>Define behavior when referenced record is deleted/updated:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}</code></pre>
        <br/>
        <li>Available actions:</li>
<table>
    <thead>
        <tr>
            <th>Action</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Cascade</code></td>
            <td>Delete/update related records</td>
        </tr>
        <tr>
            <td><code>Restrict</code></td>
            <td>Prevent if related records exist</td>
        </tr>
        <tr>
            <td><code>NoAction</code></td>
            <td>Database default behavior</td>
        </tr>
        <tr>
            <td><code>SetNull</code></td>
            <td>Set foreign key to NULL</td>
        </tr>
        <tr>
            <td><code>SetDefault</code></td>
            <td>Set foreign key to default value</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Examples:</li>
<pre><code class="language-prisma line-numbers">// Delete user → delete all their posts
author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

// Delete user → set posts.authorId to NULL
author User @relation(fields: [authorId], references: [id], onDelete: SetNull)

// Prevent user deletion if posts exist
author User @relation(fields: [authorId], references: [id], onDelete: Restrict)</code></pre>
    </ul>
    <br/><br/>


    <li>Enums</li>
    <br/>
    <ul>
        <li>Define enumeration types:</li>
<pre><code class="language-prisma line-numbers">enum Role {
  USER
  ADMIN
  MODERATOR
}

model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  role  Role   @default(USER)
}</code></pre>
        <br/>
        <li>With custom database values:</li>
<pre><code class="language-prisma line-numbers">enum Status {
  PENDING   @map("pending")
  APPROVED  @map("approved")
  REJECTED  @map("rejected")
}

model Application {
  id     Int    @id
  status Status @default(PENDING)
}</code></pre>
        <br/>
        <li>Array of enums:</li>
<pre><code class="language-prisma line-numbers">enum Permission {
  READ
  WRITE
  DELETE
}

model User {
  id          Int          @id
  permissions Permission[]
}</code></pre>
        <br/>
        <li>Note: Not supported in SQLite (use String instead).</li>
    </ul>
    <br/><br/>


    <li>Native Database Types</li>
    <br/>
    <ul>
        <li>Specify exact database column type using <code>@db.</code>:</li>
        <br/>
        <li><b>PostgreSQL:</b></li>
<pre><code class="language-prisma line-numbers">model Product {
  id          Int      @id
  name        String   @db.VarChar(255)
  description String   @db.Text
  price       Decimal  @db.Decimal(10, 2)
  metadata    Json     @db.JsonB
  tags        String[] @db.VarChar(100)
  count       BigInt   @db.BigInt
}</code></pre>
        <br/>
        <li><b>MySQL:</b></li>
<pre><code class="language-prisma line-numbers">model Product {
  id          Int     @id
  name        String  @db.VarChar(255)
  description String  @db.Text
  price       Decimal @db.Decimal(10, 2)
  metadata    Json
  tiny        Int     @db.TinyInt
  medium      String  @db.MediumText
}</code></pre>
        <br/>
        <li><b>Common native types:</b></li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>PostgreSQL</th>
            <th>MySQL</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Variable string</td>
            <td><code>@db.VarChar(n)</code></td>
            <td><code>@db.VarChar(n)</code></td>
        </tr>
        <tr>
            <td>Long text</td>
            <td><code>@db.Text</code></td>
            <td><code>@db.Text</code></td>
        </tr>
        <tr>
            <td>Decimal</td>
            <td><code>@db.Decimal(p,s)</code></td>
            <td><code>@db.Decimal(p,s)</code></td>
        </tr>
        <tr>
            <td>Timestamp</td>
            <td><code>@db.Timestamp(p)</code></td>
            <td><code>@db.DateTime(p)</code></td>
        </tr>
        <tr>
            <td>JSON</td>
            <td><code>@db.JsonB</code></td>
            <td><code>@db.Json</code></td>
        </tr>
        <tr>
            <td>UUID</td>
            <td><code>@db.Uuid</code></td>
            <td>N/A</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Comments and Documentation</li>
    <br/>
    <ul>
        <li>Single-line comments:</li>
<pre><code class="language-prisma line-numbers">model User {
  // Primary identifier
  id    Int    @id @default(autoincrement())

  // Unique email for authentication
  email String @unique

  name  String? // Optional display name
}</code></pre>
        <br/>
        <li>Multi-line comments:</li>
<pre><code class="language-prisma line-numbers">/*
 * User model represents application users
 * Supports authentication and profile management
 */
model User {
  id    Int    @id
  email String @unique
}</code></pre>
        <br/>
        <li>Documentation comments (appear in generated types):</li>
<pre><code class="language-prisma line-numbers">/// User account information
model User {
  id    Int    @id @default(autoincrement())

  /// User's email address (used for login)
  email String @unique

  /// Optional display name
  name  String?
}

/// User role enumeration
enum Role {
  /// Standard user permissions
  USER

  /// Administrator with full access
  ADMIN
}</code></pre>
        <br/>
        <li>Documentation comments use <code>///</code> and show in IDE tooltips and generated code.</li>
    </ul>
    <br/><br/>


    <li>Unsupported Features</li>
    <br/>
    <ul>
        <li>Mark models/fields to ignore:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id
  email String

  /// @ignore: deprecated field
  oldField String @ignore
}

/// @ignore: legacy table not used by application
model LegacyData {
  id Int @id

  @@ignore
}</code></pre>
        <br/>
        <li>Ignored models/fields:</li>
        <ul>
            <li>excluded from Prisma Client</li>
            <li>not validated by Prisma</li>
            <li>preserved in database</li>
            <li>useful for gradual migration</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Multi-Schema Support</li>
    <br/>
    <ul>
        <li>PostgreSQL supports multiple schemas:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public", "auth", "analytics"]
}

model User {
  id    Int    @id
  email String

  @@schema("auth")
}

model Post {
  id    Int    @id
  title String

  @@schema("public")
}

model Event {
  id   Int      @id
  data Json

  @@schema("analytics")
}</code></pre>
        <br/>
        <li>Models can reference across schemas:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id
  posts Post[]

  @@schema("auth")
}

model Post {
  id       Int  @id
  authorId Int
  author   User @relation(fields: [authorId], references: [id])

  @@schema("public")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Views</li>
    <br/>
    <ul>
        <li>Define database views as models:</li>
<pre><code class="language-prisma line-numbers">/// Database view for user statistics
view UserStats {
  userId     Int    @unique
  postCount  Int
  totalViews BigInt

  @@map("user_stats_view")
}</code></pre>
        <br/>
        <li>Views are read-only:</li>
<pre><code class="language-typescript line-numbers">// ✓ Can read from views
const stats = await prisma.userStats.findMany()

// ✗ Cannot write to views
await prisma.userStats.create({ data: {} }) // Error</code></pre>
        <br/>
        <li>Create view manually in database:</li>
<pre><code class="language-sql line-numbers">CREATE VIEW user_stats_view AS
SELECT
  u.id as userId,
  COUNT(p.id) as postCount,
  SUM(p.views) as totalViews
FROM users u
LEFT JOIN posts p ON p.author_id = u.id
GROUP BY u.id;</code></pre>
    </ul>
    <br/><br/>


    <li>Schema Organization</li>
    <br/>
    <ul>
        <li>Organize large schemas with comments:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================
// Authentication Models
// ============================================

model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  password String
  sessions Session[]
}

model Session {
  id        String   @id @default(uuid())
  userId    Int
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

// ============================================
// Content Models
// ============================================

model Post {
  id       Int      @id @default(autoincrement())
  title    String
  content  String
  authorId Int
}

model Comment {
  id      Int    @id @default(autoincrement())
  text    String
  postId  Int
  userId  Int
}

// ============================================
// E-commerce Models
// ============================================

model Product {
  id    Int     @id @default(autoincrement())
  name  String
  price Decimal
}

model Order {
  id     Int      @id @default(autoincrement())
  total  Decimal
  userId Int
}</code></pre>
        <br/>
        <li>Consider splitting very large schemas:</li>
<pre><code class="language-plaintext line-numbers">prisma/
├── schema.prisma           # Main schema (datasource + generator)
├── schema/
│   ├── auth.prisma        # Authentication models
│   ├── content.prisma     # Content models
│   └── ecommerce.prisma   # E-commerce models</code></pre>
        <br/>
        <li>Note: Prisma doesn't officially support multiple schema files yet, but tools like <code>prisma-merge</code> can help.</li>
    </ul>
    <br/><br/>


    <li>Schema Validation</li>
    <br/>
    <ul>
        <li>Validate schema without database connection:</li>
<pre><code class="language-bash line-numbers">npx prisma validate</code></pre>
        <br/>
        <li>Format schema file:</li>
<pre><code class="language-bash line-numbers">npx prisma format</code></pre>
        <br/>
        <li>Common validation errors:</li>
<table>
    <thead>
        <tr>
            <th>Error</th>
            <th>Cause</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Missing <code>@relation</code></td>
            <td>Ambiguous relation, needs explicit definition</td>
        </tr>
        <tr>
            <td>Invalid field type</td>
            <td>Unsupported type for database provider</td>
        </tr>
        <tr>
            <td>Missing required field</td>
            <td>Non-optional field without default value</td>
        </tr>
        <tr>
            <td>Duplicate model name</td>
            <td>Two models with same name</td>
        </tr>
        <tr>
            <td>Invalid attribute</td>
            <td>Attribute not supported for field type</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Complete Schema Example</li>
    <br/>
    <ul>
        <li>Real-world blog application schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  AUTHOR
  ADMIN
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  username      String    @unique @db.VarChar(30)
  passwordHash  String
  role          Role      @default(USER)
  posts         Post[]
  comments      Comment[]
  profile       Profile?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([email])
  @@map("users")
}

model Profile {
  id       Int     @id @default(autoincrement())
  bio      String? @db.Text
  avatar   String?
  website  String?
  userId   Int     @unique
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Post {
  id          Int        @id @default(autoincrement())
  title       String     @db.VarChar(200)
  slug        String     @unique
  content     String     @db.Text
  excerpt     String?    @db.VarChar(500)
  coverImage  String?
  status      PostStatus @default(DRAFT)
  published   Boolean    @default(false)
  publishedAt DateTime?
  views       Int        @default(0)
  authorId    Int
  author      User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments    Comment[]
  tags        Tag[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([slug])
  @@index([authorId])
  @@index([published, publishedAt])
  @@map("posts")
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String   @db.Text
  postId    Int
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentId  Int?
  parent    Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([userId])
  @@map("comments")
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique @db.VarChar(50)
  slug  String @unique
  posts Post[]

  @@map("tags")
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-relationships">Understanding Relationships in Prisma</h3>
<ol>

    <li>What Are Foreign Keys and Relationships?</li>
    <br/>
    <ul>
        <li>A <b>foreign key</b> is a field that references the primary key of another table.</li>
        <br/>
        <li>In traditional SQL:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE posts (
  id INT PRIMARY KEY,
  title VARCHAR(200),
  author_id INT,  -- This is the foreign key
  FOREIGN KEY (author_id) REFERENCES users(id)
);</code></pre>
        <li>Prisma on the other hand, represents this relationship in the schema file, not with raw SQL.</li>
    </ul>
    <br/><br/>


    <li>The Two Sides of Every Relationship</li>
    <br/>
    <ul>
        <li>Every relationship in Prisma has <u>two</u> sides:</li>
        <br/>
        <li><b>Side 1: The field that stores the foreign key (the ID)</b></li>
        <ul>
            <li>This is a regular field that exists in the database</li>
            <li>Example: <code>authorId Int</code></li>
            <li>This actually stores a number in the database</li>
        </ul>
        <br/>
        <li><b>Side 2: The relation field (the connection)</b></li>
        <ul>
            <li>This does NOT exist in the database as a column</li>
            <li>Example: <code>author User</code></li>
            <li>This is virtual - Prisma uses it to navigate relationships</li>
        </ul>
        <br/>
        <li>Think of it like this:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int    // Real column in database: stores user ID
  author   User   @relation(fields: [authorId], references: [id])
                  // Virtual: lets you access the User object
}</code></pre>
        <br/>
        <li>The database table <code>posts</code> has columns: <code>id</code>, <code>title</code>, <code>authorId</code></li>
        <br/>
        <li>It does NOT have a column called <code>author</code> - that's just for Prisma to use.</li>
    </ul>
    <br/><br/>


    <li>One-to-Many: The Most Common Relationship</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> One user can have many posts, but each post belongs to one user.</li>
        <br/>
        <li>Complete example:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id @default(autoincrement())
  name  String
  email String @unique
  posts Post[]  // Array because one user has MANY posts
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  content  String
  authorId Int    // Foreign key: stores which user owns this post
  author   User   @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li>Breaking down the <code>@relation</code> attribute:</li>
<table>
    <thead>
        <tr>
            <th>Part</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fields: [authorId]</code></td>
            <td>This model's field that stores the foreign key</td>
        </tr>
        <tr>
            <td><code>references: [id]</code></td>
            <td>The field in the User model being referenced</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>"The <code>authorId</code> field references the <code>id</code> field in User"</li>
        <br/>
        <li>Database structure created:</li>
<pre><code class="language-sql line-numbers">-- users table
id   | name      | email
-----|-----------|------------------
1    | Alice     | alice@example.com
2    | Bob       | bob@example.com

-- posts table
id   | title          | content        | authorId
-----|----------------|----------------|----------
1    | First Post     | Hello world    | 1
2    | Second Post    | More content   | 1
3    | Bob's Post     | Hi there       | 2</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Get posts WITH their author information
const posts = await prisma.post.findMany({
  include: {
    author: true  // Include the related User
  }
})

// Result:
// [
//   {
//     id: 1,
//     title: "First Post",
//     authorId: 1,
//     author: { id: 1, name: "Alice", email: "alice@example.com" }
//   },
//   ...
// ]

// Get user WITH all their posts
const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: true  // Include all related Posts
  }
})

// Result:
// {
//   id: 1,
//   name: "Alice",
//   posts: [
//     { id: 1, title: "First Post", ... },
//     { id: 2, title: "Second Post", ... }
//   ]
// }</code></pre>
    </ul>
    <br/><br/>


    <li>Which Side Gets the Foreign Key?</li>
    <br/>
    <ul>
        <li><b>Rule:</b> The "many" side stores the foreign key.</li>
        <br/>
        <li>Visualizing the relationship:</li>
<pre><code class="language-plaintext line-numbers">User (ONE)                    Post (MANY)
-----------                   -----------
id                            id
name                          title
email                         authorId ← Foreign key here!
posts [] ← Virtual            author ← Virtual</code></pre>
        <br/>
        <li>Why? Because many posts can point to one user.</li>
        <br/>
        <li>If we put it on User, we could only store ONE post ID (not many).</li>
        <br/>
        <li>Another example:</li>
<pre><code class="language-prisma line-numbers">// One category can have many products
model Category {
  id       Int       @id @default(autoincrement())
  name     String
  products Product[] // Virtual: "this category has many products"
}

model Product {
  id         Int      @id @default(autoincrement())
  name       String
  categoryId Int      // Real: stores the category ID
  category   Category @relation(fields: [categoryId], references: [id])
                      // Virtual: "this product belongs to a category"
}</code></pre>
        <br/>
        <li>Remember: Foreign key goes on the <u>many</u> side, array goes on the <u>one</u> side.</li>
    </ul>
    <br/><br/>


    <li>One-to-One Relationships</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> One user has exactly one profile.</li>
        <br/>
        <li>Complete example:</li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  profile Profile? // Optional (?) because user might not have profile yet
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  avatar String?
  userId Int    @unique  // Must be @unique for one-to-one!
  user   User   @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li>Key difference from one-to-many:</li>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>One-to-Many</th>
            <th>One-to-One</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Foreign key</td>
            <td><code>authorId Int</code></td>
            <td><code>userId Int @unique</code></td>
        </tr>
        <tr>
            <td>Other side</td>
            <td><code>posts Post[]</code> (array)</td>
            <td><code>profile Profile?</code> (single, optional)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The <code>@unique</code> constraint ensures one user can have only one profile.</li>
        <br/>
        <li>Database structure:</li>
<pre><code class="language-sql line-numbers">-- users table
id   | email
-----|------------------
1    | alice@example.com
2    | bob@example.com

-- profiles table
id   | bio              | avatar       | userId (UNIQUE)
-----|------------------|--------------|----------------
1    | I love coding    | pic1.jpg     | 1
2    | Hello world      | pic2.jpg     | 2</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Create user with profile
const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    profile: {
      create: {
        bio: 'I love coding',
        avatar: 'pic1.jpg'
      }
    }
  }
})

// Get user with profile
const userWithProfile = await prisma.user.findUnique({
  where: { id: 1 },
  include: { profile: true }
})

// Result:
// {
//   id: 1,
//   email: "alice@example.com",
//   profile: {
//     id: 1,
//     bio: "I love coding",
//     avatar: "pic1.jpg",
//     userId: 1
//   }
// }</code></pre>
    </ul>
    <br/><br/>


    <li>Why Use <code>?</code> (Optional) on Relations?</li>
    <br/>
    <ul>
        <li>The <code>?</code> makes a relation optional:</li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int      @id
  profile Profile? // User might not have a profile
}

model Profile {
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li><b>With</b> <code>?</code>: User can exist without a profile</li>
<pre><code class="language-typescript line-numbers">// Valid: user without profile
await prisma.user.create({
  data: { email: 'test@example.com' }
})</code></pre>
        <br/>
        <li><b>Without</b> <code>?</code>: Every user MUST have a profile immediately</li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int     @id
  profile Profile // Required! Must provide profile when creating user
}</code></pre>
<pre><code class="language-typescript line-numbers">// Must create profile with user
await prisma.user.create({
  data: {
    email: 'test@example.com',
    profile: {
      create: { bio: 'Required!' }
    }
  }
})</code></pre>
        <br/>
        <li>Common pattern: Make optional on the side without the foreign key.</li>
<pre><code class="language-prisma line-numbers">model User {
  profile Profile? // Optional here
}

model Profile {
  userId Int  // Required here (no ?)
  user   User @relation(fields: [userId], references: [id])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Many-to-Many: Implicit (Simple)</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> Posts can have many tags, tags can be on many posts.</li>
        <br/>
        <li>Implicit many-to-many (Prisma creates join table automatically):</li>
<pre><code class="language-prisma line-numbers">model Post {
  id    Int     @id @default(autoincrement())
  title String
  tags  Tag[]   // Array of tags
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[] // Array of posts
}</code></pre>
        <br/>
        <li>Notice: NO foreign keys defined explicitly!</li>
        <br/>
        <li>Prisma automatically creates a join table named <code>_PostToTag</code>:</li>
<pre><code class="language-sql line-numbers">-- posts table
id   | title
-----|------------------
1    | First Post
2    | Second Post

-- tags table
id   | name
-----|-------------
1    | JavaScript
2    | Tutorial

-- _PostToTag (created automatically by Prisma)
A (postId) | B (tagId)
-----------|----------
1          | 1
1          | 2
2          | 1</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Create post with tags
await prisma.post.create({
  data: {
    title: 'First Post',
    tags: {
      create: [
        { name: 'JavaScript' },
        { name: 'Tutorial' }
      ]
    }
  }
})

// Connect existing tags
await prisma.post.create({
  data: {
    title: 'Second Post',
    tags: {
      connect: [
        { id: 1 }, // Connect to JavaScript tag
      ]
    }
  }
})

// Get post with all tags
const post = await prisma.post.findUnique({
  where: { id: 1 },
  include: { tags: true }
})

// Result:
// {
//   id: 1,
//   title: "First Post",
//   tags: [
//     { id: 1, name: "JavaScript" },
//     { id: 2, name: "Tutorial" }
//   ]
// }</code></pre>
    </ul>
    <br/><br/>


    <li>Many-to-Many: Explicit (With Extra Fields)</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> Track WHEN a tag was added to a post.</li>
        <br/>
        <li>You need the join table to store extra data:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int              @id @default(autoincrement())
  title    String
  postTags PostTag[]        // Connection to join table
}

model Tag {
  id       Int              @id @default(autoincrement())
  name     String
  postTags PostTag[]        // Connection to join table
}

// Explicit join table with extra fields
model PostTag {
  postId     Int
  tagId      Int
  assignedAt DateTime @default(now()) // Extra field!

  post       Post     @relation(fields: [postId], references: [id])
  tag        Tag      @relation(fields: [tagId], references: [id])

  @@id([postId, tagId]) // Composite primary key
}</code></pre>
        <br/>
        <li>Database structure:</li>
<pre><code class="language-sql line-numbers">-- posts table
id   | title
-----|------------------
1    | First Post

-- tags table
id   | name
-----|-------------
1    | JavaScript

-- post_tags table (explicit join table)
postId | tagId | assignedAt
-------|-------|------------------------
1      | 1     | 2024-01-15 10:30:00</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Create relationship with timestamp
await prisma.postTag.create({
  data: {
    postId: 1,
    tagId: 1,
    assignedAt: new Date()
  }
})

// Get post with tags AND assignment timestamps
const post = await prisma.post.findUnique({
  where: { id: 1 },
  include: {
    postTags: {
      include: {
        tag: true // Include the actual tag data
      }
    }
  }
})

// Result:
// {
//   id: 1,
//   title: "First Post",
//   postTags: [
//     {
//       postId: 1,
//       tagId: 1,
//       assignedAt: "2024-01-15T10:30:00Z",
//       tag: { id: 1, name: "JavaScript" }
//     }
//   ]
// }</code></pre>
    </ul>
    <br/><br/>


    <li>When to Use Implicit vs Explicit Many-to-Many</li>
    <br/>
    <ul>
        <li><b>Use implicit (simple) when:</b></li>
        <ul>
            <li>you only need to connect two models</li>
            <li>no extra data needed on the relationship</li>
            <li>simpler API is preferred</li>
        </ul>
<pre><code class="language-prisma line-numbers">// Simple: just connect posts and categories
model Post {
  categories Category[]
}

model Category {
  posts Post[]
}</code></pre>
        <br/>
        <li><b>Use explicit when:</b></li>
        <ul>
            <li>need to store when relationship was created</li>
            <li>need to track who created the relationship</li>
            <li>need any extra metadata about the connection</li>
        </ul>
<pre><code class="language-prisma line-numbers">// Complex: track when user joined team and their role
model UserTeam {
  userId    Int
  teamId    Int
  role      String   // Extra field
  joinedAt  DateTime @default(now()) // Extra field

  user      User     @relation(fields: [userId], references: [id])
  team      Team     @relation(fields: [teamId], references: [id])

  @@id([userId, teamId])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Self-Relations: Model Relating to Itself</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> Users can follow other users.</li>
        <br/>
        <li>Self-relation example:</li>
<pre><code class="language-prisma line-numbers">model User {
  id         Int    @id @default(autoincrement())
  name       String

  // Users I follow
  following  User[] @relation("UserFollows")

  // Users who follow me
  followers  User[] @relation("UserFollows")
}</code></pre>
        <br/>
        <li>Prisma creates implicit join table <code>_UserFollows</code>:</li>
<pre><code class="language-sql line-numbers">-- users table
id   | name
-----|-------
1    | Alice
2    | Bob
3    | Carol

-- _UserFollows (A follows B)
A    | B
-----|-----
1    | 2    -- Alice follows Bob
1    | 3    -- Alice follows Carol
2    | 1    -- Bob follows Alice</code></pre>
        <br/>
        <li>The <code>"UserFollows"</code> name is a label - you can name it anything:</li>
<pre><code class="language-prisma line-numbers">following User[] @relation("UserFollows")
followers User[] @relation("UserFollows")
// Both must have the SAME name to connect them</code></pre>
        <br/>
        <li>Explicit self-relation with extra data:</li>
<pre><code class="language-prisma line-numbers">model User {
  id         Int       @id @default(autoincrement())
  name       String
  following  Follow[]  @relation("Follower")
  followers  Follow[]  @relation("Following")
}

model Follow {
  followerId  Int
  followingId Int
  createdAt   DateTime @default(now())

  follower    User     @relation("Follower", fields: [followerId], references: [id])
  following   User     @relation("Following", fields: [followingId], references: [id])

  @@id([followerId, followingId])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding Relation Names</li>
    <br/>
    <ul>
        <li>Relation names are needed when you have <b>multiple relations</b> between same models.</li>
        <br/>
        <li>Example: Posts have an author AND an editor:</li>
<pre><code class="language-prisma line-numbers">model User {
  id            Int    @id @default(autoincrement())
  name          String
  authoredPosts Post[] @relation("PostAuthor")
  editedPosts   Post[] @relation("PostEditor")
}

model Post {
  id        Int    @id @default(autoincrement())
  title     String

  authorId  Int
  author    User   @relation("PostAuthor", fields: [authorId], references: [id])

  editorId  Int?
  editor    User?  @relation("PostEditor", fields: [editorId], references: [id])
}</code></pre>
        <br/>
        <li>Without names, Prisma can't tell which foreign key connects to which relation.</li>
        <br/>
        <li>The name can be anything descriptive:</li>
<pre><code class="language-prisma line-numbers">@relation("PostAuthor")    // Good
@relation("AuthorPosts")   // Good
@relation("WrittenBy")     // Good
@relation("abc123")        // Valid but unclear</code></pre>
        <br/>
        <li>Both sides must use the <b>exact same name</b>:</li>
<pre><code class="language-prisma line-numbers">// ✓ Correct - same name on both sides
author User @relation("PostAuthor", fields: [...])
authoredPosts Post[] @relation("PostAuthor")

// ✗ Wrong - different names
author User @relation("PostAuthor", fields: [...])
authoredPosts Post[] @relation("AuthoredPosts") // Mismatch!</code></pre>
    </ul>
    <br/><br/>


    <li>Optional vs Required Relations</li>
    <br/>
    <ul>
        <li>Relations can be optional or required:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int   @id

  // Required: every post MUST have an author
  authorId Int   // No ?
  author   User  @relation(fields: [authorId], references: [id])

  // Optional: post MAY have an editor
  editorId Int?  // With ?
  editor   User? @relation(fields: [editorId], references: [id])
}</code></pre>
        <br/>
        <li>Rule: If foreign key is optional (<code>Int?</code>), relation must be too (<code>User?</code>):</li>
<table>
    <thead>
        <tr>
            <th>Foreign Key</th>
            <th>Relation Field</th>
            <th>Valid?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>authorId Int</code></td>
            <td><code>author User</code></td>
            <td>✓ Both required</td>
        </tr>
        <tr>
            <td><code>editorId Int?</code></td>
            <td><code>editor User?</code></td>
            <td>✓ Both optional</td>
        </tr>
        <tr>
            <td><code>authorId Int</code></td>
            <td><code>author User?</code></td>
            <td>✗ Mismatch</td>
        </tr>
        <tr>
            <td><code>editorId Int?</code></td>
            <td><code>editor User</code></td>
            <td>✗ Mismatch</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>For arrays, never use <code>?</code>:</li>
<pre><code class="language-prisma line-numbers">model User {
  posts Post[]  // ✓ Correct: array is never optional
  // posts Post[]? // ✗ Wrong: syntax error
}</code></pre>
        <br/>
        <li>An empty array <code>[]</code> represents "no posts" - no need for <code>?</code>.</li>
    </ul>
    <br/><br/>


    <li>Cascade Delete and Update Actions</li>
    <br/>
    <ul>
        <li>Control what happens when related record is deleted/updated:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int  @id
  authorId Int
  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model User {
  id    Int    @id
  posts Post[]
}</code></pre>
        <br/>
        <li>Available actions:</li>
<table>
    <thead>
        <tr>
            <th>Action</th>
            <th>What Happens</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Cascade</code></td>
            <td>Delete user → delete all their posts</td>
        </tr>
        <tr>
            <td><code>SetNull</code></td>
            <td>Delete user → set posts.authorId to NULL</td>
        </tr>
        <tr>
            <td><code>Restrict</code></td>
            <td>Cannot delete user if they have posts</td>
        </tr>
        <tr>
            <td><code>NoAction</code></td>
            <td>Database decides (usually same as Restrict)</td>
        </tr>
        <tr>
            <td><code>SetDefault</code></td>
            <td>Set to default value (if defined)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example behaviors:</li>
<pre><code class="language-prisma line-numbers">// Delete user → delete their posts
author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

// Delete user → set authorId to NULL (requires authorId to be Int?)
author User? @relation(fields: [authorId], references: [id], onDelete: SetNull)

// Prevent user deletion if they have posts
author User @relation(fields: [authorId], references: [id], onDelete: Restrict)</code></pre>
        <br/>
        <li><code>onUpdate</code> works similarly but for ID changes (less common):</li>
<pre><code class="language-prisma line-numbers">author User @relation(
  fields: [authorId],
  references: [id],
  onDelete: Cascade,
  onUpdate: Cascade
)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Relationship Patterns</li>
    <br/>
    <ul>
        <li><b>Blog system:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  posts    Post[]
  comments Comment[]
}

model Post {
  id       Int       @id @default(autoincrement())
  title    String
  authorId Int
  author   User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments Comment[]
  tags     Tag[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  text    String
  postId  Int
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId  Int
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}</code></pre>
        <br/>
        <li><b>E-commerce:</b></li>
<pre><code class="language-prisma line-numbers">model Customer {
  id     Int     @id @default(autoincrement())
  email  String  @unique
  orders Order[]
}

model Order {
  id         Int         @id @default(autoincrement())
  customerId Int
  customer   Customer    @relation(fields: [customerId], references: [id])
  items      OrderItem[]
  total      Decimal
}

model Product {
  id         Int         @id @default(autoincrement())
  name       String
  price      Decimal
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId Int
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  price     Decimal
}</code></pre>
        <br/>
        <li><b>Organization hierarchy:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id           Int            @id @default(autoincrement())
  email        String         @unique
  memberships  Membership[]
}

model Organization {
  id          Int            @id @default(autoincrement())
  name        String
  memberships Membership[]
}

model Membership {
  id             Int          @id @default(autoincrement())
  userId         Int
  organizationId Int
  role           String
  joinedAt       DateTime     @default(now())

  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Common Mistakes and How to Fix Them</li>
    <br/>
    <ul>
        <li><b>Mistake 1: Forgetting @unique on one-to-one</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - missing @unique
model Profile {
  userId Int
  user   User @relation(fields: [userId], references: [id])
}

// ✓ Correct - has @unique
model Profile {
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li><b>Mistake 2: Mismatched optional markers</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - foreign key required but relation optional
model Post {
  editorId Int   // Required
  editor   User? // Optional - mismatch!
}

// ✓ Correct - both match
model Post {
  editorId Int?  // Optional
  editor   User? // Optional
}</code></pre>
        <br/>
        <li><b>Mistake 3: Wrong side has foreign key</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - foreign key on "one" side
model User {
  id     Int   @id
  postId Int   // Wrong! Can only reference ONE post
  post   Post  @relation(fields: [postId], references: [id])
}

// ✓ Correct - foreign key on "many" side
model Post {
  id       Int  @id
  authorId Int
  author   User @relation(fields: [authorId], references: [id])
}

model User {
  id    Int    @id
  posts Post[] // One user has many posts
}</code></pre>
        <br/>
        <li><b>Mistake 4: Not using arrays on one-to-many</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - not an array
model User {
  posts Post  // Wrong! Should be Post[]
}

// ✓ Correct - array for multiple posts
model User {
  posts Post[]
}</code></pre>
        <br/>
        <li><b>Mistake 5: Ambiguous relations without names</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - Prisma can't tell which is which
model Post {
  authorId Int
  author   User @relation(fields: [authorId], references: [id])

  editorId Int
  editor   User @relation(fields: [editorId], references: [id])
}

// ✓ Correct - use relation names
model Post {
  authorId Int
  author   User @relation("PostAuthor", fields: [authorId], references: [id])

  editorId Int
  editor   User @relation("PostEditor", fields: [editorId], references: [id])
}

model User {
  authoredPosts Post[] @relation("PostAuthor")
  editedPosts   Post[] @relation("PostEditor")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Practice Examples</li>
    <br/>
    <ul>
        <li><b>Exercise 1:</b> Movies and directors (one-to-many)</li>
<pre><code class="language-prisma line-numbers">model Director {
  id     Int     @id @default(autoincrement())
  name   String
  movies Movie[]
}

model Movie {
  id         Int      @id @default(autoincrement())
  title      String
  directorId Int
  director   Director @relation(fields: [directorId], references: [id])
}</code></pre>
        <br/>
        <li><b>Exercise 2:</b> Student and student card (one-to-one)</li>
<pre><code class="language-prisma line-numbers">model Student {
  id          Int           @id @default(autoincrement())
  name        String
  studentCard StudentCard?
}

model StudentCard {
  id        Int     @id @default(autoincrement())
  cardNumber String @unique
  studentId Int     @unique
  student   Student @relation(fields: [studentId], references: [id])
}</code></pre>
        <br/>
        <li><b>Exercise 3:</b> Students and courses (many-to-many)</li>
<pre><code class="language-prisma line-numbers">model Student {
  id      Int      @id @default(autoincrement())
  name    String
  courses Course[]
}

model Course {
  id       Int       @id @default(autoincrement())
  name     String
  students Student[]
}</code></pre>
        <br/>
        <li><b>Exercise 4:</b> Students and courses with enrollment date (explicit many-to-many)</li>
<pre><code class="language-prisma line-numbers">model Student {
  id          Int          @id @default(autoincrement())
  name        String
  enrollments Enrollment[]
}

model Course {
  id          Int          @id @default(autoincrement())
  name        String
  enrollments Enrollment[]
}

model Enrollment {
  studentId  Int
  courseId   Int
  enrolledAt DateTime @default(now())
  grade      String?

  student    Student  @relation(fields: [studentId], references: [id])
  course     Course   @relation(fields: [courseId], references: [id])

  @@id([studentId, courseId])
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-read-operations">Reading Data with Prisma</h3>
<ol>

    <li>Understanding Read Operations</li>
    <ul>
        <br/>
        <li>Reading (retrieving) data means fetching records from your database.</li>
        <br/>
        <li>Prisma provides several methods for reading data:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Returns</th>
            <th>Use When</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>findUnique()</code></td>
            <td>Single record or null</td>
            <td>You have a unique identifier (ID, email)</td>
        </tr>
        <tr>
            <td><code>findUniqueOrThrow()</code></td>
            <td>Single record or throws error</td>
            <td>Record must exist, want error if not found</td>
        </tr>
        <tr>
            <td><code>findFirst()</code></td>
            <td>First matching record or null</td>
            <td>You want one record matching criteria</td>
        </tr>
        <tr>
            <td><code>findFirstOrThrow()</code></td>
            <td>First record or throws error</td>
            <td>Record must exist, want error if not found</td>
        </tr>
        <tr>
            <td><code>findMany()</code></td>
            <td>Array of records (may be empty)</td>
            <td>You want multiple records</td>
        </tr>
        <tr>
            <td><code>count()</code></td>
            <td>Number</td>
            <td>You only need to count records</td>
        </tr>
        <tr>
            <td><code>aggregate()</code></td>
            <td>Aggregated data</td>
            <td>You need sum, average, min, max</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>All examples assume this schema:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  age       Int
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String
  published Boolean  @default(false)
  views     Int      @default(0)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}</code></pre>
    </ul>
    <br/><br/>


    <li>findUnique: Get One Record by Unique Field</li>
    <br/>
    <ul>
        <li>Use <code>findUnique()</code> when you know a unique value (ID, email, etc.).</li>
        <br/>
        <li>Basic example - find by ID:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: {
    id: 1
  }
})

console.log(user)
// Returns:
// { id: 1, email: 'alice@example.com', name: 'Alice', age: 25, ... }
// or null if not found</code></pre>
        <br/>
        <li>Find by unique email:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: {
    email: 'alice@example.com'
  }
})</code></pre>
        <br/>
        <li><b>Important:</b> Can only use fields marked with <code>@unique</code> or <code>@id</code> in the schema.</li>
<pre><code class="language-typescript line-numbers">// ✓ Valid - id is unique
where: { id: 1 }

// ✓ Valid - email has @unique
where: { email: 'alice@example.com' }

// ✗ Invalid - name is not unique
where: { name: 'Alice' }  // Error!</code></pre>
        <br/>
        <li>Returns <code>null</code> if not found:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 9999 }  // Doesn't exist
})

console.log(user)  // null</code></pre>
    </ul>
    <br/><br/>


    <li>findUniqueOrThrow: Get One Record or Error</li>
    <br/>
    <ul>
        <li>Same as <code>findUnique()</code>, but throws error instead of returning <code>null</code>.</li>
        <br/>
        <li>Example:</li>
<pre><code class="language-typescript line-numbers">try {
  const user = await prisma.user.findUniqueOrThrow({
    where: { id: 9999 }  // Doesn't exist
  })
} catch (error) {
  console.log(error.message)
  // "No User found"
}</code></pre>
        <br/>
        <li>Use when the record <u>must</u> exist (otherwise it's a bug):</li>
<pre><code class="language-typescript line-numbers">// If user doesn't exist, something is seriously wrong
const currentUser = await prisma.user.findUniqueOrThrow({
  where: { id: session.userId }
})</code></pre>
    </ul>
    <br/><br/>


    <li>findFirst: Get First Matching Record</li>
    <br/>
    <ul>
        <li>Use <code>findFirst()</code> when you want the first record matching criteria.</li>
        <br/>
        <li>Unlike <code>findUnique()</code>, you can filter by <u>any</u> field:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findFirst({
  where: {
    name: 'Alice'  // Not unique - might have multiple Alices
  }
})

// Returns the first Alice found (or null)</code></pre>
        <br/>
        <li>Multiple conditions:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findFirst({
  where: {
    name: 'Alice',
    age: 25,
    isActive: true
  }
})

// Returns first user matching ALL conditions</code></pre>
        <br/>
        <li>With ordering:</li>
<pre><code class="language-typescript line-numbers">const newestUser = await prisma.user.findFirst({
  where: {
    isActive: true
  },
  orderBy: {
    createdAt: 'desc'  // Newest first
  }
})

// Returns the most recently created active user</code></pre>
        <br/>
        <li>Returns <code>null</code> if no match found:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findFirst({
  where: { age: 150 }  // Unlikely to exist
})

console.log(user)  // null</code></pre>
    </ul>
    <br/><br/>


    <li>findMany: Get Multiple Records</li>
    <br/>
    <ul>
        <li>Use <code>findMany()</code> to get an array of records.</li>
        <br/>
        <li>Get all records:</li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany()

console.log(users)
// [
//   { id: 1, email: 'alice@example.com', ... },
//   { id: 2, email: 'bob@example.com', ... },
//   { id: 3, email: 'carol@example.com', ... }
// ]</code></pre>
        <br/>
        <li>With filtering:</li>
<pre><code class="language-typescript line-numbers">const activeUsers = await prisma.user.findMany({
  where: {
    isActive: true
  }
})</code></pre>
        <br/>
        <li>Returns empty array if no matches:</li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: { age: 150 }
})

console.log(users)  // []</code></pre>
        <br/>
        <li>Never returns <code>null</code>, always an array (even if empty).</li>
    </ul>
    <br/><br/>


    <li>Filtering with where</li>
    <br/>
    <ul>
        <li>The <code>where</code> clause filters which records to retrieve.</li>
        <br/>
        <li><b>Exact match:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    age: 25  // age equals 25
  }
})</code></pre>
        <br/>
        <li><b>Multiple conditions (AND):</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    age: 25,
    isActive: true,
    name: 'Alice'
    // All conditions must be true
  }
})</code></pre>
        <br/>
        <li><b>Comparison operators:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    age: {
      gt: 18,      // Greater than
      lte: 65      // Less than or equal
    }
  }
})

// Users between 19 and 65 years old</code></pre>
        <br/>
        <li>Available comparison operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>equals</code></td>
            <td>Equal to</td>
            <td><code>age: { equals: 25 }</code></td>
        </tr>
        <tr>
            <td><code>not</code></td>
            <td>Not equal to</td>
            <td><code>age: { not: 25 }</code></td>
        </tr>
        <tr>
            <td><code>gt</code></td>
            <td>Greater than</td>
            <td><code>age: { gt: 18 }</code></td>
        </tr>
        <tr>
            <td><code>gte</code></td>
            <td>Greater than or equal</td>
            <td><code>age: { gte: 18 }</code></td>
        </tr>
        <tr>
            <td><code>lt</code></td>
            <td>Less than</td>
            <td><code>age: { lt: 65 }</code></td>
        </tr>
        <tr>
            <td><code>lte</code></td>
            <td>Less than or equal</td>
            <td><code>age: { lte: 65 }</code></td>
        </tr>
        <tr>
            <td><code>in</code></td>
            <td>In array</td>
            <td><code>age: { in: [25, 30, 35] }</code></td>
        </tr>
        <tr>
            <td><code>notIn</code></td>
            <td>Not in array</td>
            <td><code>age: { notIn: [25, 30] }</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>String filters:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    email: {
      contains: '@gmail.com'  // Email contains this string
    }
  }
})</code></pre>
        <br/>
        <li>String filter operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>contains</code></td>
            <td>Contains substring</td>
            <td><code>email: { contains: 'gmail' }</code></td>
        </tr>
        <tr>
            <td><code>startsWith</code></td>
            <td>Starts with</td>
            <td><code>name: { startsWith: 'A' }</code></td>
        </tr>
        <tr>
            <td><code>endsWith</code></td>
            <td>Ends with</td>
            <td><code>email: { endsWith: '.com' }</code></td>
        </tr>
        <tr>
            <td><code>mode</code></td>
            <td>Case sensitivity</td>
            <td><code>name: { equals: 'alice', mode: 'insensitive' }</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Case-insensitive search:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    email: {
      contains: 'GMAIL',
      mode: 'insensitive'  // Matches 'gmail', 'Gmail', 'GMAIL'
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Logical Operators: AND, OR, NOT</li>
    <br/>
    <ul>
        <li><b>AND (default behavior):</b></li>
<pre><code class="language-typescript line-numbers">// These are equivalent:
where: {
  age: 25,
  isActive: true
}

where: {
  AND: [
    { age: 25 },
    { isActive: true }
  ]
}</code></pre>
        <br/>
        <li><b>OR (any condition matches):</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    OR: [
      { age: { lt: 18 } },    // Under 18
      { age: { gt: 65 } }     // Over 65
    ]
  }
})

// Returns users who are EITHER under 18 OR over 65</code></pre>
        <br/>
        <li><b>NOT (negation):</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    NOT: {
      email: {
        endsWith: '@gmail.com'
      }
    }
  }
})

// Returns users whose email does NOT end with @gmail.com</code></pre>
        <br/>
        <li><b>Combining operators:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    AND: [
      { isActive: true },
      {
        OR: [
          { age: { lt: 18 } },
          { age: { gt: 65 } }
        ]
      }
    ]
  }
})

// Active users who are EITHER under 18 OR over 65</code></pre>
    </ul>
    <br/><br/>


    <li>Filtering by Related Data</li>
    <br/>
    <ul>
        <li>You can filter based on relationships.</li>
        <br/>
        <li><b>Find users who have posts:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    posts: {
      some: {}  // Has at least one post
    }
  }
})</code></pre>
        <br/>
        <li><b>Find users who have NO posts:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    posts: {
      none: {}  // Has zero posts
    }
  }
})</code></pre>
        <br/>
        <li><b>Find users with published posts:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    posts: {
      some: {
        published: true  // Has at least one published post
      }
    }
  }
})</code></pre>
        <br/>
        <li><b>Find users where ALL posts are published:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    posts: {
      every: {
        published: true  // Every post is published
      }
    }
  }
})</code></pre>
        <br/>
        <li>Relation filter operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>some</code></td>
            <td>At least one related record matches</td>
        </tr>
        <tr>
            <td><code>none</code></td>
            <td>No related records match</td>
        </tr>
        <tr>
            <td><code>every</code></td>
            <td>All related records match</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Filter posts by author data:</b></li>
<pre><code class="language-typescript line-numbers">const posts = await prisma.post.findMany({
  where: {
    author: {
      age: { gt: 18 },
      isActive: true
    }
  }
})

// Posts written by active users over 18</code></pre>
    </ul>
    <br/><br/>


    <li>Selecting Specific Fields</li>
    <br/>
    <ul>
        <li>By default, Prisma returns <u>all</u> fields. Use <code>select</code> to choose specific fields.</li>
        <br/>
        <li><b>Without select (default):</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 }
})

console.log(user)
// {
//   id: 1,
//   email: 'alice@example.com',
//   name: 'Alice',
//   age: 25,
//   isActive: true,
//   createdAt: 2024-01-01T00:00:00.000Z
// }</code></pre>
        <br/>
        <li><b>With select:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    id: true,
    name: true,
    email: true
  }
})

console.log(user)
// {
//   id: 1,
//   name: 'Alice',
//   email: 'alice@example.com'
// }
// age, isActive, createdAt are NOT included</code></pre>
        <br/>
        <li>Select only what you need - improves performance:</li>
<pre><code class="language-typescript line-numbers">// Good - only select needed fields
const users = await prisma.user.findMany({
  select: {
    id: true,
    email: true
  }
})

// Less efficient - fetches all fields
const users = await prisma.user.findMany()</code></pre>
    </ul>
    <br/><br/>


    <li>Including Related Data</li>
    <br/>
    <ul>
        <li>Use <code>include</code> to fetch related records.</li>
        <br/>
        <li><b>Without include:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 }
})

console.log(user.posts)  // undefined - posts not fetched</code></pre>
        <br/>
        <li><b>With include:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: true
  }
})

console.log(user)
// {
//   id: 1,
//   name: 'Alice',
//   email: 'alice@example.com',
//   posts: [
//     { id: 1, title: 'First Post', ... },
//     { id: 2, title: 'Second Post', ... }
//   ]
// }</code></pre>
        <br/>
        <li><b>Include with filtering:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: {
      where: {
        published: true  // Only published posts
      }
    }
  }
})</code></pre>
        <br/>
        <li><b>Include with ordering:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: {
      orderBy: {
        createdAt: 'desc'  // Newest first
      },
      take: 5  // Only 5 most recent
    }
  }
})</code></pre>
        <br/>
        <li><b>Nested includes:</b></li>
<pre><code class="language-typescript line-numbers">const post = await prisma.post.findUnique({
  where: { id: 1 },
  include: {
    author: {
      include: {
        posts: true  // Include author's other posts too
      }
    }
  }
})

console.log(post.author.posts)  // All posts by this author</code></pre>
    </ul>
    <br/><br/>


    <li>Combining select and include</li>
    <br/>
    <ul>
        <li>You can <u>not</u> use <code>select</code> and <code>include</code> at the same level:</li>
<pre><code class="language-typescript line-numbers">// ✗ Error - can't use both
const user = await prisma.user.findUnique({
  where: { id: 1 },
  select: { name: true },
  include: { posts: true }  // Error!
})</code></pre>
        <br/>
        <li><b>Solution:</b> Use <code>select</code> with relation selects:</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    email: true,
    posts: true  // Include posts via select
  }
})

// Or with nested select:
const user = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    email: true,
    posts: {
      select: {
        id: true,
        title: true
        // Only these post fields
      }
    }
  }
})</code></pre>
        <li>Rule of thumb:</li>
        <ul>
            <li>Use <code>include</code> for simple "give me everything" scenarios</li>
            <li>Use <code>select</code> when you need precise control over fields</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Sorting Results with orderBy</li>
    <br/>
    <ul>
        <li>Use <code>orderBy</code> to sort results.</li>
        <br/>
        <li><b>Single field, ascending:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  orderBy: {
    name: 'asc'  // A to Z
  }
})</code></pre>
        <br/>
        <li><b>Single field, descending:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  orderBy: {
    createdAt: 'desc'  // Newest first
  }
})</code></pre>
        <br/>
        <li><b>Multiple fields:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  orderBy: [
    { age: 'desc' },      // Sort by age first (oldest first)
    { name: 'asc' }       // Then by name (A to Z)
  ]
})</code></pre>
        <br/>
        <li><b>Sort by related field:</b></li>
<pre><code class="language-typescript line-numbers">const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: 'asc'  // Sort posts by author name
    }
  }
})</code></pre>
        <br/>
        <li><b>Sort by relation count:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  orderBy: {
    posts: {
      _count: 'desc'  // Users with most posts first
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Pagination: skip and take</li>
    <br/>
    <ul>
        <li>Use <code>skip</code> and <code>take</code> for pagination.</li>
        <br/>
        <li><b>take (limit):</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  take: 10  // Get first 10 users
})</code></pre>
        <br/>
        <li><b>skip (offset):</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  skip: 20,  // Skip first 20 users
  take: 10   // Then take 10 (users 21-30)
})</code></pre>
        <br/>
        <li><b>Page-based pagination:</b></li>
<pre><code class="language-typescript line-numbers">const page = 3
const pageSize = 10

const users = await prisma.user.findMany({
  skip: (page - 1) * pageSize,  // Skip 20 (pages 1 and 2)
  take: pageSize,                // Take 10 (page 3)
  orderBy: { id: 'asc' }
})

// Page 1: skip 0, take 10   (users 1-10)
// Page 2: skip 10, take 10  (users 11-20)
// Page 3: skip 20, take 10  (users 21-30)</code></pre>
        <br/>
        <li><b>Complete pagination example:</b></li>
<pre><code class="language-typescript line-numbers">async function getUsersPage(page: number, pageSize: number) {
  const [users, totalCount] = await Promise.all([
    prisma.user.findMany({
      skip: (page - 1) * pageSize,
      take: pageSize,
      orderBy: { createdAt: 'desc' }
    }),
    prisma.user.count()
  ])

  return {
    users,
    totalCount,
    totalPages: Math.ceil(totalCount / pageSize),
    currentPage: page
  }
}

const result = await getUsersPage(1, 10)
// {
//   users: [...],
//   totalCount: 247,
//   totalPages: 25,
//   currentPage: 1
// }</code></pre>
        <br/>
        <li><b>Cursor-based pagination (better for large datasets):</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  take: 10,
  skip: 1,  // Skip the cursor itself
  cursor: {
    id: 20  // Start after this ID
  },
  orderBy: { id: 'asc' }
})

// Returns 10 users starting after ID 20</code></pre>
    </ul>
    <br/><br/>


    <li>Counting Records</li>
    <br/>
    <ul>
        <li>Use <code>count()</code> to count records without fetching them.</li>
        <br/>
        <li><b>Count all:</b></li>
<pre><code class="language-typescript line-numbers">const userCount = await prisma.user.count()

console.log(userCount)  // 247</code></pre>
        <br/>
        <li><b>Count with filter:</b></li>
<pre><code class="language-typescript line-numbers">const activeUserCount = await prisma.user.count({
  where: {
    isActive: true
  }
})

console.log(activeUserCount)  // 189</code></pre>
        <br/>
        <li><b>Count by groups:</b></li>
<pre><code class="language-typescript line-numbers">const counts = await prisma.user.groupBy({
  by: ['isActive'],
  _count: {
    _all: true
  }
})

console.log(counts)
// [
//   { isActive: true, _count: { _all: 189 } },
//   { isActive: false, _count: { _all: 58 } }
// ]</code></pre>
    </ul>
    <br/><br/>


    <li>Aggregations</li>
    <br/>
    <ul>
        <li>Use <code>aggregate()</code> for calculations on numeric fields.</li>
        <br/>
        <li><b>Available aggregations:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>_count</code></td>
            <td>Count records</td>
        </tr>
        <tr>
            <td><code>_sum</code></td>
            <td>Sum values</td>
        </tr>
        <tr>
            <td><code>_avg</code></td>
            <td>Average value</td>
        </tr>
        <tr>
            <td><code>_min</code></td>
            <td>Minimum value</td>
        </tr>
        <tr>
            <td><code>_max</code></td>
            <td>Maximum value</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Single aggregation:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.post.aggregate({
  _avg: {
    views: true
  }
})

console.log(result)
// { _avg: { views: 342.5 } }</code></pre>
        <br/>
        <li><b>Multiple aggregations:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.post.aggregate({
  _count: { _all: true },
  _sum: { views: true },
  _avg: { views: true },
  _min: { views: true },
  _max: { views: true }
})

console.log(result)
// {
//   _count: { _all: 150 },
//   _sum: { views: 51375 },
//   _avg: { views: 342.5 },
//   _min: { views: 0 },
//   _max: { views: 9845 }
// }</code></pre>
        <br/>
        <li><b>Aggregation with filter:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.post.aggregate({
  where: {
    published: true
  },
  _avg: {
    views: true
  }
})

// Average views of published posts only</code></pre>
    </ul>
    <br/><br/>


    <li>Group By</li>
    <br/>
    <ul>
        <li>Use <code>groupBy()</code> to group and aggregate data.</li>
        <br/>
        <li><b>Group posts by author:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.post.groupBy({
  by: ['authorId'],
  _count: {
    _all: true
  }
})

console.log(result)
// [
//   { authorId: 1, _count: { _all: 5 } },
//   { authorId: 2, _count: { _all: 3 } },
//   { authorId: 3, _count: { _all: 7 } }
// ]</code></pre>
        <br/>
        <li><b>Group with multiple fields:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.post.groupBy({
  by: ['authorId', 'published'],
  _count: {
    _all: true
  },
  _sum: {
    views: true
  }
})

console.log(result)
// [
//   { authorId: 1, published: true, _count: { _all: 3 }, _sum: { views: 1500 } },
//   { authorId: 1, published: false, _count: { _all: 2 }, _sum: { views: 50 } },
//   ...
// ]</code></pre>
        <br/>
        <li><b>Group with filtering:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.post.groupBy({
  by: ['authorId'],
  where: {
    published: true  // Only count published posts
  },
  _count: {
    _all: true
  },
  having: {
    _count: {
      _all: {
        gt: 5  // Only authors with more than 5 published posts
      }
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Distinct Records</li>
    <br/>
    <ul>
        <li>Use <code>distinct</code> to get unique values.</li>
        <br/>
        <li><b>Get unique ages:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  distinct: ['age'],
  select: {
    age: true
  }
})

console.log(users)
// [
//   { age: 25 },
//   { age: 30 },
//   { age: 35 }
// ]
// No duplicate ages</code></pre>
        <br/>
        <li><b>Distinct on multiple fields:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  distinct: ['age', 'isActive'],
  select: {
    age: true,
    isActive: true
  }
})

// Unique combinations of age and isActive</code></pre>
    </ul>
    <br/><br/>


    <li>Null and Undefined Handling</li>
    <br/>
    <ul>
        <li>Filter for null values:</li>
<pre><code class="language-typescript line-numbers">// Find users with no name
const users = await prisma.user.findMany({
  where: {
    name: null
  }
})

// Find users WITH a name
const users = await prisma.user.findMany({
  where: {
    name: {
      not: null
    }
  }
})</code></pre>
        <br/>
        <li>Check if field is set:</li>
<pre><code class="language-typescript line-numbers">const users = await prisma.user.findMany({
  where: {
    name: {
      isSet: true  // Name field has been set (not undefined)
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Raw Queries</li>
    <br/>
    <ul>
        <li>When Prisma's query builder isn't enough, use raw SQL.</li>
        <br/>
        <li><b>Raw query with $queryRaw:</b></li>
<pre><code class="language-typescript line-numbers">const users = await prisma.$queryRaw`
  SELECT * FROM "User" WHERE age > 25
`

console.log(users)  // Array of raw database rows</code></pre>
        <br/>
        <li><b>With parameters (safe from SQL injection):</b></li>
<pre><code class="language-typescript line-numbers">const minAge = 25
const users = await prisma.$queryRaw`
  SELECT * FROM "User" WHERE age > ${minAge}
`

// Prisma safely escapes the parameter</code></pre>
        <br/>
        <li><b>Type-safe raw queries:</b></li>
<pre><code class="language-typescript line-numbers">import { Prisma } from '@prisma/client'

const users = await prisma.$queryRaw<User[]>`
  SELECT * FROM "User" WHERE age > 25
`

// users is typed as User[]</code></pre>
        <br/>
        <li><b>Unsafe raw query (use with caution):</b></li>
<pre><code class="language-typescript line-numbers">const tableName = 'User'
const users = await prisma.$queryRawUnsafe(
  `SELECT * FROM "${tableName}"`
)

// Only use $queryRawUnsafe when you need dynamic table/column names</code></pre>
    </ul>
    <br/><br/>


    <li>Common Query Patterns</li>
    <br/>
    <ul>
        <li><b>Search pattern:</b></li>
<pre><code class="language-typescript line-numbers">async function searchUsers(searchTerm: string) {
  return await prisma.user.findMany({
    where: {
      OR: [
        { name: { contains: searchTerm, mode: 'insensitive' } },
        { email: { contains: searchTerm, mode: 'insensitive' } }
      ]
    }
  })
}</code></pre>
        <br/>
        <li><b>Get or create pattern:</b></li>
<pre><code class="language-typescript line-numbers">async function getOrCreateUser(email: string) {
  let user = await prisma.user.findUnique({
    where: { email }
  })

  if (!user) {
    user = await prisma.user.create({
      data: { email, name: 'New User' }
    })
  }

  return user
}</code></pre>
        <br/>
        <li><b>Fetch with default value:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 1 }
}) ?? { id: 0, name: 'Guest', email: 'guest@example.com' }

// If user not found, use default object</code></pre>
    </ul>
    <br/><br/>


    <li>Performance Tips</li>
    <br/>
    <ul>
        <li><b>Select only needed fields:</b></li>
<pre><code class="language-typescript line-numbers">// ✓ Good - only fetch what you need
const users = await prisma.user.findMany({
  select: { id: true, email: true }
})

// ✗ Bad - fetches all fields
const users = await prisma.user.findMany()</code></pre>
        <br/>
        <li><b>Use pagination for large datasets:</b></li>
<pre><code class="language-typescript line-numbers">// ✓ Good - paginate
const users = await prisma.user.findMany({
  take: 100,
  skip: 0
})

// ✗ Bad - fetches all records (could be millions)
const users = await prisma.user.findMany()</code></pre>
        <br/>
        <li><b>Use count instead of fetching when possible:</b></li>
<pre><code class="language-typescript line-numbers">// ✓ Good - just count
const userCount = await prisma.user.count()

// ✗ Bad - fetches all records just to count
const users = await prisma.user.findMany()
const userCount = users.length</code></pre>
        <br/>
        <li><b>Avoid N+1 queries with include:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Bad - N+1 query problem
const users = await prisma.user.findMany()
for (const user of users) {
  const posts = await prisma.post.findMany({
    where: { authorId: user.id }
  })
  console.log(user.name, posts.length)
}

// ✓ Good - single query with include
const users = await prisma.user.findMany({
  include: {
    posts: true
  }
})
for (const user of users) {
  console.log(user.name, user.posts.length)
}</code></pre>
        <br/>
        <li><b>Use indexes for frequently filtered fields:</b></li>
<pre><code class="language-prisma line-numbers">// Add to schema
model User {
  email String @unique
  age   Int

  @@index([age])  // Index for frequent age queries
}</code></pre>
    </ul>
    <br/><br/>


    <li>Error Handling</li>
    <br/>
    <ul>
        <li><b>Handle not found:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.findUnique({
  where: { id: 9999 }
})

if (!user) {
  throw new Error('User not found')
}

// Or use findUniqueOrThrow
const user = await prisma.user.findUniqueOrThrow({
  where: { id: 9999 }
})
// Automatically throws if not found</code></pre>
        <br/>
        <li><b>Handle database errors:</b></li>
<pre><code class="language-typescript line-numbers">try {
  const users = await prisma.user.findMany()
} catch (error) {
  if (error.code === 'P2002') {
    console.log('Unique constraint violation')
  } else if (error.code === 'P2025') {
    console.log('Record not found')
  } else {
    console.log('Database error:', error.message)
  }
}</code></pre>
    </ul>
    <br/><br/>


    <li>Quick Reference Cheat Sheet</li>
    <br/>
    <ul>
<table>
    <thead>
        <tr>
            <th>Task</th>
            <th>Code</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Get by ID</td>
            <td><code>findUnique({ where: { id: 1 } })</code></td>
        </tr>
        <tr>
            <td>Get all</td>
            <td><code>findMany()</code></td>
        </tr>
        <tr>
            <td>Filter</td>
            <td><code>findMany({ where: { age: 25 } })</code></td>
        </tr>
        <tr>
            <td>Greater than</td>
            <td><code>where: { age: { gt: 18 } }</code></td>
        </tr>
        <tr>
            <td>Contains text</td>
            <td><code>where: { email: { contains: 'gmail' } }</code></td>
        </tr>
        <tr>
            <td>OR condition</td>
            <td><code>where: { OR: [{...}, {...}] }</code></td>
        </tr>
        <tr>
            <td>Select fields</td>
            <td><code>select: { id: true, name: true }</code></td>
        </tr>
        <tr>
            <td>Include relations</td>
            <td><code>include: { posts: true }</code></td>
        </tr>
        <tr>
            <td>Sort</td>
            <td><code>orderBy: { createdAt: 'desc' }</code></td>
        </tr>
        <tr>
            <td>Limit</td>
            <td><code>take: 10</code></td>
        </tr>
        <tr>
            <td>Skip/Offset</td>
            <td><code>skip: 20</code></td>
        </tr>
        <tr>
            <td>Count</td>
            <td><code>count({ where: {...} })</code></td>
        </tr>
        <tr>
            <td>Average</td>
            <td><code>aggregate({ _avg: { views: true } })</code></td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-create-operations">Creating Data with Prisma</h3>
<ol>

    <li>Understanding Create Syntax Structure</li>
    <br/>
    <ul>
        <li>The <code>create()</code> method follows this structure:</li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL_NAME.create({
  data: {
    // Field assignments go here
  },
  select: {
    // Optional: choose which fields to return
  },
  include: {
    // Optional: include related data in response
  }
})</code></pre>
        <br/>
        <li>Only <code>data</code> is <u>required</u>. <code>select</code> and <code>include</code> are <u>optional</u>.</li>
        <br/>
        <li>The <code>data</code> object contains field assignments using this pattern:</li>
<pre><code class="language-typescript line-numbers">data: {
  fieldName: value,           // Set literal value
  fieldName: { ... },         // Set with operation or relation
  relationName: { ... }       // Create/connect related records
}</code></pre>
        <br/>
        <li>Example schema for this chapter:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  age       Int?
  role      Role     @default(USER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  profile   Profile?
  posts     Post[]
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  userId Int    @unique
  user   User   @relation(fields: [userId], references: [id])
}

model Post {
  id       Int     @id @default(autoincrement())
  title    String
  content  String?
  authorId Int
  author   User    @relation(fields: [authorId], references: [id])
  tags     Tag[]
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}

enum Role {
  USER
  ADMIN
  MODERATOR
}</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Field Assignment Syntax</li>
    <br/>
    <ul>
        <li><b>Rule:</b> Required fields (no <code>?</code> or <code>@default</code>) MUST be provided.</li>
        <br/>
        <li>Field assignment patterns:</li>
<table>
    <thead>
        <tr>
            <th>Field Type in Schema</th>
            <th>Required in create()?</th>
            <th>Syntax</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>name String</code></td>
            <td>Yes</td>
            <td><code>name: "Alice"</code></td>
        </tr>
        <tr>
            <td><code>age Int?</code></td>
            <td>No (optional)</td>
            <td><code>age: 25</code> or omit</td>
        </tr>
        <tr>
            <td><code>isActive Boolean @default(true)</code></td>
            <td>No (has default)</td>
            <td><code>isActive: false</code> or omit</td>
        </tr>
        <tr>
            <td><code>id Int @id @default(autoincrement())</code></td>
            <td>No (auto-generated)</td>
            <td>Cannot set (Prisma generates it)</td>
        </tr>
        <tr>
            <td><code>createdAt DateTime @default(now())</code></td>
            <td>No (has default)</td>
            <td><code>createdAt: new Date()</code> or omit</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Examples of field assignments:</li>
<pre><code class="language-typescript line-numbers">// String
name: "Alice"

// Number
age: 25

// Boolean
isActive: true

// Date
createdAt: new Date()
createdAt: new Date("2024-01-01")

// Enum
role: "ADMIN"  // or Role.ADMIN if imported

// Null (only for optional fields)
age: null

// Array (PostgreSQL/MongoDB)
tags: ["javascript", "typescript"]</code></pre>
        <br/>
        <li><b>Rule:</b> You CANNOT set fields that have <code>@default(autoincrement())</code> or <code>@updatedAt</code>.</li>
<pre><code class="language-typescript line-numbers">// ✗ Error - cannot set auto-increment ID
data: {
  id: 5,  // Error!
  name: "Alice"
}

// ✓ Correct - let Prisma generate ID
data: {
  name: "Alice"
}</code></pre>
    </ul>
    <br/><br/>


    <li>Complete Syntax: Required vs Optional Fields</li>
    <br/>
    <ul>
        <li>When creating a record, you must understand which fields are required:</li>
        <br/>
        <li><b>Required fields:</b> Fields without <code>?</code>, without <code>@default()</code>, and not auto-generated.</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id @default(autoincrement())  // Not required (auto)
  email String @unique                        // REQUIRED
  name  String                                // REQUIRED
  age   Int?                                  // Not required (optional)
  role  Role   @default(USER)                 // Not required (has default)
}</code></pre>
        <br/>
        <li>Minimum valid create:</li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",  // Required
    name: "Alice"                // Required
    // id: auto-generated
    // age: null (optional, not provided)
    // role: USER (default)
  }
})</code></pre>
        <br/>
        <li>Override defaults and optionals:</li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    age: 25,           // Override optional
    role: "ADMIN",     // Override default
    isActive: false    // Override default
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Relation Field Syntax: The Three Operations</li>
    <br/>
    <ul>
        <li>When creating a record with relations, you have <b>three operations</b>:</li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>When to Use</th>
            <th>Syntax Pattern</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>create</code></td>
            <td>Create new related record(s)</td>
            <td><code>relationName: { create: { ... } }</code></td>
        </tr>
        <tr>
            <td><code>connect</code></td>
            <td>Link to existing record(s)</td>
            <td><code>relationName: { connect: { id: 1 } }</code></td>
        </tr>
        <tr>
            <td><code>connectOrCreate</code></td>
            <td>Connect if exists, create if not</td>
            <td><code>relationName: { connectOrCreate: { ... } }</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Important:</b> Relation operations apply to the <b>relation field</b> (e.g., <code>author</code>, <code>posts</code>), NOT the foreign key field (e.g., <code>authorId</code>).</li>
    </ul>
    <br/><br/>


    <li>One-to-Many: Creating with Related Records</li>
    <br/>
    <ul>
        <li>Scenario: User (one) has many Posts (many).</li>
        <br/>
        <li><b>Pattern 1: Create user with new posts</b></li>
<pre><code class="language-typescript line-numbers">// Syntax structure:
await prisma.user.create({
  data: {
    // User fields
    email: "...",
    name: "...",

    // Relation field (array for one-to-many)
    posts: {
      create: [
        { /* post 1 data */ },
        { /* post 2 data */ }
      ]
    }
  }
})</code></pre>
<pre><code class="language-typescript line-numbers">// Actual example:
await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    posts: {
      create: [
        { title: "First Post", content: "Hello" },
        { title: "Second Post", content: "World" }
      ]
    }
  }
})

// Creates: 1 user + 2 posts
// Posts automatically get authorId set to new user's id</code></pre>
        <br/>
        <li><b>Pattern 2: Create single related record (not array)</b></li>
<pre><code class="language-typescript line-numbers">// For single record, use object instead of array:
posts: {
  create: { title: "First Post", content: "Hello" }
}

// Both work, but single object is cleaner for one record</code></pre>
        <br/>
        <li><b>Pattern 3: Connect to existing posts</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    posts: {
      connect: [
        { id: 1 },  // Connect to post with id 1
        { id: 2 }   // Connect to post with id 2
      ]
    }
  }
})

// Prerequisite: Posts with id 1 and 2 must already exist
// Changes their authorId to point to new user</code></pre>
        <br/>
        <li><b>Pattern 4: Mix create and connect</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    posts: {
      create: [
        { title: "New Post", content: "Fresh content" }
      ],
      connect: [
        { id: 5 }  // Also connect existing post
      ]
    }
  }
})

// Creates 1 new post AND connects to existing post 5</code></pre>
        <br/>
        <li><b>Rule:</b> For one-to-many, the relation field accepts <b>arrays</b> (<code>[]</code>).</li>
    </ul>
    <br/><br/>


    <li>One-to-One: Creating with Single Related Record</li>
    <br/>
    <ul>
        <li>Scenario: User (one) has one Profile (one).</li>
        <br/>
        <li><b>Pattern 1: Create user with new profile</b></li>
<pre><code class="language-typescript line-numbers">// Syntax structure:
await prisma.user.create({
  data: {
    // User fields
    email: "...",
    name: "...",

    // Relation field (single object for one-to-one)
    profile: {
      create: {
        /* profile data */
      }
    }
  }
})</code></pre>
<pre><code class="language-typescript line-numbers">// Actual example:
await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    profile: {
      create: {
        bio: "Software developer"
      }
    }
  }
})

// Creates: 1 user + 1 profile
// Profile automatically gets userId set to new user's id</code></pre>
        <br/>
        <li><b>Pattern 2: Connect to existing profile</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    profile: {
      connect: { id: 3 }  // Single object, not array
    }
  }
})

// Prerequisite: Profile with id 3 must exist
// Sets profile's userId to new user's id</code></pre>
        <br/>
        <li><b>Rule:</b> For one-to-one, the relation field accepts <b>single object</b>, NOT arrays.</li>
<pre><code class="language-typescript line-numbers">// ✓ Correct - single object
profile: { create: { bio: "..." } }

// ✗ Wrong - cannot use array for one-to-one
profile: { create: [{ bio: "..." }] }  // Error!</code></pre>
    </ul>
    <br/><br/>


    <li>Creating from the "Many" Side</li>
    <br/>
    <ul>
        <li>When creating from the "many" side (e.g., Post), you can set the foreign key OR use relation syntax.</li>
        <br/>
        <li><b>Method 1: Set foreign key directly</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    content: "Content here",
    authorId: 1  // Set foreign key directly
  }
})

// Prerequisite: User with id 1 must exist</code></pre>
        <br/>
        <li><b>Method 2: Use connect</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    content: "Content here",
    author: {
      connect: { id: 1 }  // Connect to user via relation
    }
  }
})

// Same result as Method 1, but uses relation syntax</code></pre>
        <br/>
        <li><b>Method 3: Create new parent</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    content: "Content here",
    author: {
      create: {
        email: "alice@example.com",
        name: "Alice"
      }
    }
  }
})

// Creates both post AND user</code></pre>
        <br/>
        <li><b>Rule:</b> You can EITHER set <code>authorId</code> OR use <code>author: { connect/create }</code>, but NOT both.</li>
<pre><code class="language-typescript line-numbers">// ✗ Error - conflicting operations
data: {
  title: "My Post",
  authorId: 1,  // Setting foreign key
  author: {
    connect: { id: 1 }  // Also trying to connect via relation
  }
}

// ✓ Choose one approach
data: {
  title: "My Post",
  authorId: 1  // Either this
}

// Or
data: {
  title: "My Post",
  author: { connect: { id: 1 } }  // Or this
}</code></pre>
    </ul>
    <br/><br/>


    <li>Many-to-Many: Creating with Multiple Relations</li>
    <br/>
    <ul>
        <li>Scenario: Post has many Tags, Tag has many Posts.</li>
        <br/>
        <li><b>Pattern 1: Create post with new tags</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    authorId: 1,
    tags: {
      create: [
        { name: "javascript" },
        { name: "typescript" }
      ]
    }
  }
})

// Creates: 1 post + 2 tags + 2 join table entries</code></pre>
        <br/>
        <li><b>Pattern 2: Connect to existing tags</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    authorId: 1,
    tags: {
      connect: [
        { id: 1 },
        { id: 2 }
      ]
    }
  }
})

// Tags must already exist
// Creates: 1 post + 2 join table entries</code></pre>
        <br/>
        <li><b>Pattern 3: Connect by unique field</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    authorId: 1,
    tags: {
      connect: [
        { name: "javascript" },  // Connect by unique name
        { name: "typescript" }
      ]
    }
  }
})

// name must be @unique in schema</code></pre>
        <br/>
        <li><b>Pattern 4: Mix create and connect</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    authorId: 1,
    tags: {
      create: [
        { name: "newTag" }  // Create new tag
      ],
      connect: [
        { id: 1 }  // Connect existing tag
      ]
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>connectOrCreate: Conditional Creation</li>
    <br/>
    <ul>
        <li><code>connectOrCreate</code> connects to existing record if found, creates if not found.</li>
        <br/>
        <li><b>Syntax structure:</b></li>
<pre><code class="language-typescript line-numbers">relationName: {
  connectOrCreate: {
    where: {
      // How to find existing record (must use unique field)
    },
    create: {
      // What to create if not found
    }
  }
}</code></pre>
        <br/>
        <li><b>Example: Create post with tags (create tag if doesn't exist)</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.create({
  data: {
    title: "My Post",
    authorId: 1,
    tags: {
      connectOrCreate: [
        {
          where: { name: "javascript" },
          create: { name: "javascript" }
        },
        {
          where: { name: "typescript" },
          create: { name: "typescript" }
        }
      ]
    }
  }
})

// If tag "javascript" exists: connects to it
// If tag "javascript" doesn't exist: creates it
// Same for "typescript"</code></pre>
        <br/>
        <li><b>Rule:</b> The <code>where</code> clause in <code>connectOrCreate</code> MUST use a unique field.</li>
<pre><code class="language-typescript line-numbers">// ✓ Correct - name is @unique
where: { name: "javascript" }

// ✓ Correct - id is unique
where: { id: 1 }

// ✗ Error - title is not unique
where: { title: "Some Title" }  // Error!</code></pre>
        <br/>
        <li><b>For one-to-one relations:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    profile: {
      connectOrCreate: {
        where: { id: 5 },
        create: { bio: "New profile" }
      }
    }
  }
})

// Single object for one-to-one (not array)</code></pre>
    </ul>
    <br/><br/>


    <li>Nested Creates: Multiple Levels Deep</li>
    <br/>
    <ul>
        <li>You can nest creates multiple levels deep.</li>
        <br/>
        <li><b>Pattern: Create user → profile → posts → tags</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",

    // Level 1: Create profile
    profile: {
      create: {
        bio: "Developer"
      }
    },

    // Level 1: Create posts
    posts: {
      create: [
        {
          title: "First Post",
          content: "Content",

          // Level 2: Create tags for this post
          tags: {
            create: [
              { name: "javascript" },
              { name: "typescript" }
            ]
          }
        }
      ]
    }
  }
})

// Creates: 1 user + 1 profile + 1 post + 2 tags</code></pre>
        <br/>
        <li>No arbitrary depth limit, but keep it reasonable for readability.</li>
    </ul>
    <br/><br/>


    <li>Creating Multiple Records: createMany</li>
    <br/>
    <ul>
        <li><code>createMany</code> inserts multiple records in one operation (bulk insert).</li>
        <br/>
        <li><b>Syntax structure:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL_NAME.createMany({
  data: [
    { /* record 1 */ },
    { /* record 2 */ },
    { /* record 3 */ }
  ],
  skipDuplicates: true  // Optional: skip records that violate unique constraints
})</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.createMany({
  data: [
    { email: "alice@example.com", name: "Alice" },
    { email: "bob@example.com", name: "Bob" },
    { email: "carol@example.com", name: "Carol" }
  ]
})

// Creates 3 users in one database operation</code></pre>
        <br/>
        <li><b>Return value:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.user.createMany({
  data: [...]
})

console.log(result)
// { count: 3 }

// Note: createMany does NOT return the created records
// It only returns count of records created</code></pre>
        <br/>
        <li><b>Skip duplicates:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.createMany({
  data: [
    { email: "alice@example.com", name: "Alice" },
    { email: "alice@example.com", name: "Alice2" },  // Duplicate email
    { email: "bob@example.com", name: "Bob" }
  ],
  skipDuplicates: true  // Skip the duplicate instead of erroring
})

// Creates Alice and Bob, skips duplicate Alice
// Returns: { count: 2 }</code></pre>
        <br/>
        <li><b>Important limitations of createMany:</b></li>
<table>
    <thead>
        <tr>
            <th>Limitation</th>
            <th>Explanation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>No nested creates</td>
            <td>Cannot use <code>create</code>, <code>connect</code>, etc. in relations</td>
        </tr>
        <tr>
            <td>No return of created records</td>
            <td>Only returns <code>{ count: n }</code>, not the actual records</td>
        </tr>
        <tr>
            <td>No select/include</td>
            <td>Cannot choose fields to return (because nothing is returned)</td>
        </tr>
        <tr>
            <td>SQLite limitation</td>
            <td>SQLite doesn't support <code>skipDuplicates</code></td>
        </tr>
    </tbody>
</table>
<pre><code class="language-typescript line-numbers">// ✗ Error - cannot use nested creates in createMany
await prisma.user.createMany({
  data: [
    {
      email: "alice@example.com",
      name: "Alice",
      posts: {  // Error!
        create: [{ title: "Post" }]
      }
    }
  ]
})

// ✓ Correct - only flat data
await prisma.user.createMany({
  data: [
    { email: "alice@example.com", name: "Alice" },
    { email: "bob@example.com", name: "Bob" }
  ]
})</code></pre>
        <br/>
        <li><b>When to use createMany vs multiple create:</b></li>
<pre><code class="language-typescript line-numbers">// Use createMany when:
// - Creating many simple records
// - No relations needed
// - Performance is important (single query)
await prisma.user.createMany({
  data: users  // Array of user data
})

// Use multiple create when:
// - Need to create with relations
// - Need to get created records back
// - Need select/include
for (const userData of users) {
  await prisma.user.create({
    data: {
      ...userData,
      posts: { create: [...] }
    }
  })
}</code></pre>
    </ul>
    <br/><br/>


    <li>Selecting Return Data</li>
    <br/>
    <ul>
        <li>By default, <code>create()</code> returns the entire created record.</li>
        <br/>
        <li><b>Default behavior:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice"
  }
})

console.log(user)
// {
//   id: 1,
//   email: "alice@example.com",
//   name: "Alice",
//   age: null,
//   role: "USER",
//   isActive: true,
//   createdAt: 2024-01-01T00:00:00.000Z
// }</code></pre>
        <br/>
        <li><b>Select specific fields:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice"
  },
  select: {
    id: true,
    email: true
  }
})

console.log(user)
// { id: 1, email: "alice@example.com" }
// Other fields not included</code></pre>
        <br/>
        <li><b>Include related data:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    posts: {
      create: [
        { title: "First Post", content: "Hello" }
      ]
    }
  },
  include: {
    posts: true
  }
})

console.log(user)
// {
//   id: 1,
//   email: "alice@example.com",
//   ...
//   posts: [
//     { id: 1, title: "First Post", content: "Hello", authorId: 1 }
//   ]
// }</code></pre>
        <br/>
        <li><b>Cannot use select and include together (at same level):</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error
const user = await prisma.user.create({
  data: { ... },
  select: { id: true },
  include: { posts: true }  // Error!
})

// ✓ Use select with nested relation select
const user = await prisma.user.create({
  data: { ... },
  select: {
    id: true,
    email: true,
    posts: {
      select: {
        id: true,
        title: true
      }
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Handling Unique Constraint Violations</li>
    <br/>
    <ul>
        <li>If you try to create a record that violates a unique constraint, Prisma throws an error.</li>
        <br/>
        <li><b>Example error:</b></li>
<pre><code class="language-typescript line-numbers">// First create
await prisma.user.create({
  data: { email: "alice@example.com", name: "Alice" }
})

// Try to create duplicate email
await prisma.user.create({
  data: { email: "alice@example.com", name: "Alice2" }
})

// Throws: PrismaClientKnownRequestError
// Code: P2002
// Message: "Unique constraint failed on the fields: (`email`)"</code></pre>
        <br/>
        <li><b>Handle with try-catch:</b></li>
<pre><code class="language-typescript line-numbers">try {
  const user = await prisma.user.create({
    data: { email: "alice@example.com", name: "Alice" }
  })
} catch (error) {
  if (error.code === 'P2002') {
    console.log('User with this email already exists')
    // Handle duplicate gracefully
  } else {
    throw error
  }
}</code></pre>
        <br/>
        <li><b>Alternative: upsert (create or update):</b></li>
<pre><code class="language-typescript line-numbers">// If user exists: update it
// If user doesn't exist: create it
const user = await prisma.user.upsert({
  where: {
    email: "alice@example.com"
  },
  update: {
    name: "Alice Updated"
  },
  create: {
    email: "alice@example.com",
    name: "Alice"
  }
})

// No error, handles both cases</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding Data Validation</li>
    <br/>
    <ul>
        <li>Prisma validates data types before sending to database.</li>
        <br/>
        <li><b>Type validation:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error - wrong type
await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    age: "25"  // Error! Should be number, not string
  }
})

// ✓ Correct
await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    age: 25  // Number
  }
})</code></pre>
        <br/>
        <li><b>Required field validation:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error - missing required field
await prisma.user.create({
  data: {
    email: "alice@example.com"
    // Missing required field: name
  }
})

// Error: "Argument `name` is missing"</code></pre>
        <br/>
        <li><b>Enum validation:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error - invalid enum value
await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    role: "SUPERADMIN"  // Not in enum
  }
})

// ✓ Correct - valid enum value
await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    role: "ADMIN"  // Valid: USER | ADMIN | MODERATOR
  }
})</code></pre>
        <br/>
        <li>Validation happens at TypeScript level (if using TypeScript) AND at Prisma level.</li>
    </ul>
    <br/><br/>


    <li>Working with JSON Fields</li>
    <br/>
    <ul>
        <li>If you have a <code>Json</code> field in your schema, you can store any valid JSON.</li>
<pre><code class="language-prisma line-numbers">model User {
  id       Int  @id @default(autoincrement())
  metadata Json?
}</code></pre>
        <br/>
        <li><b>Store JSON object:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    metadata: {
      preferences: {
        theme: "dark",
        notifications: true
      },
      tags: ["developer", "typescript"]
    }
  }
})

// Stored as JSON in database</code></pre>
        <br/>
        <li><b>Store JSON array:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    metadata: ["tag1", "tag2", "tag3"]
  }
})</code></pre>
        <br/>
        <li><b>Store null:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
    metadata: null  // Only if field is optional (Json?)
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Summary: Create Syntax Patterns</li>
    <br/>
    <ul>
        <li><b>Basic create:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.create({
  data: { field: value }
})</code></pre>
        <br/>
        <li><b>Create with one-to-many (new related records):</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.create({
  data: {
    field: value,
    relationMany: {
      create: [{ }, { }]  // Array for many
    }
  }
})</code></pre>
        <br/>
        <li><b>Create with one-to-one (new related record):</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.create({
  data: {
    field: value,
    relationOne: {
      create: { }  // Object for one
    }
  }
})</code></pre>
        <br/>
        <li><b>Connect existing relations:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.create({
  data: {
    field: value,
    relationMany: {
      connect: [{ id: 1 }, { id: 2 }]  // Array
    },
    relationOne: {
      connect: { id: 3 }  // Object
    }
  }
})</code></pre>
        <br/>
        <li><b>ConnectOrCreate:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.create({
  data: {
    field: value,
    relation: {
      connectOrCreate: {
        where: { uniqueField: value },
        create: { }
      }
    }
  }
})</code></pre>
        <br/>
        <li><b>Multiple records:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.createMany({
  data: [{ }, { }, { }],
  skipDuplicates: true
})</code></pre>
        <br/>
        <li><b>With select/include:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.create({
  data: { },
  select: { field: true }
  // OR
  include: { relation: true }
})</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-update-operations">Updating Data with Prisma</h3>
<ol>

    <li>Understanding Update Syntax Structure</li>
    <br/>
    <ul>
        <li>Prisma provides several update methods:</li>
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Updates</th>
            <th>Returns</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>update()</code></td>
            <td>Single record (must exist)</td>
            <td>Updated record or throws error</td>
        </tr>
        <tr>
            <td><code>updateMany()</code></td>
            <td>Multiple records</td>
            <td><code>{ count: n }</code></td>
        </tr>
        <tr>
            <td><code>upsert()</code></td>
            <td>Update if exists, create if not</td>
            <td>Updated or created record</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Basic <code>update()</code> structure:</li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL_NAME.update({
  where: {
    // How to find the record (must use unique field)
  },
  data: {
    // What to update
  },
  select: {
    // Optional: which fields to return
  },
  include: {
    // Optional: include related data in response
  }
})</code></pre>
        <br/>
        <li>Only <code>where</code> and <code>data</code> are required.</li>
        <br/>
        <li>Example schema for this chapter:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  age       Int?
  role      Role     @default(USER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  profile   Profile?
  posts     Post[]
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  userId Int    @unique
  user   User   @relation(fields: [userId], references: [id])
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  views     Int      @default(0)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}

enum Role {
  USER
  ADMIN
  MODERATOR
}</code></pre>
    </ul>
    <br/><br/>


    <li>The where Clause: Finding Records to Update</li>
    <br/>
    <ul>
        <li><b>Rule:</b> The <code>where</code> clause in <code>update()</code> MUST use a <b>unique field</b>.</li>
        <br/>
        <li><b>Valid unique fields:</b></li>
        <ul>
            <li>Fields marked with <code>@id</code></li>
            <li>Fields marked with <code>@unique</code></li>
            <li>Combinations marked with <code>@@unique</code></li>
        </ul>
        <br/>
        <li><b>Update by ID:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: {
    id: 1  // id is unique (@id)
  },
  data: {
    name: "Alice Updated"
  }
})</code></pre>
        <br/>
        <li><b>Update by unique email:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: {
    email: "alice@example.com"  // email is @unique
  },
  data: {
    name: "Alice Updated"
  }
})</code></pre>
        <br/>
        <li><b>Update by composite unique:</b></li>
<pre><code class="language-prisma line-numbers">model UserRole {
  userId Int
  roleId Int

  @@unique([userId, roleId])
}</code></pre>
<pre><code class="language-typescript line-numbers">await prisma.userRole.update({
  where: {
    userId_roleId: {  // Composite unique field
      userId: 1,
      roleId: 2
    }
  },
  data: {
    // updates
  }
})</code></pre>
        <br/>
        <li><b>Cannot use non-unique fields:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error - name is not unique
await prisma.user.update({
  where: {
    name: "Alice"  // Error!
  },
  data: { age: 26 }
})

// Use updateMany for non-unique fields (covered later)</code></pre>
        <br/>
        <li><b>If record not found, throws error:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 9999 },  // Doesn't exist
  data: { name: "Updated" }
})

// Throws: PrismaClientKnownRequestError
// Code: P2025
// Message: "Record to update not found"</code></pre>
    </ul>
    <br/><br/>


    <li>The data Clause: Basic Field Updates</li>
    <br/>
    <ul>
        <li>The <code>data</code> clause specifies what to update.</li>
        <br/>
        <li><b>Set field to new value:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    name: "New Name"  // Replace old value with new value
  }
})</code></pre>
        <br/>
        <li><b>Update multiple fields:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    name: "Alice",
    age: 26,
    isActive: false
  }
})</code></pre>
        <br/>
        <li><b>Set field to null (only for optional fields):</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    age: null  // Only works if age is Int? (optional)
  }
})</code></pre>
        <br/>
        <li><b>Update with different types:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    name: "Alice",          // String
    age: 26,                // Number
    isActive: true,         // Boolean
    role: "ADMIN",          // Enum
    updatedAt: new Date()   // DateTime (usually auto-updated)
  }
})</code></pre>
        <br/>
        <li><b>Cannot update auto-generated fields:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error - cannot update @id field
data: {
  id: 5  // Error!
}

// ✗ Usually don't need to update @updatedAt (auto-updates)
// But technically allowed:
data: {
  updatedAt: new Date()  // Allowed but unnecessary
}</code></pre>
        <br/>
        <li><b>Fields not mentioned remain unchanged:</b></li>
<pre><code class="language-typescript line-numbers">// Before update:
// { id: 1, name: "Alice", age: 25, email: "alice@example.com" }

await prisma.user.update({
  where: { id: 1 },
  data: {
    age: 26  // Only update age
  }
})

// After update:
// { id: 1, name: "Alice", age: 26, email: "alice@example.com" }
// name and email unchanged</code></pre>
    </ul>
    <br/><br/>


    <li>Atomic Number Operations</li>
    <br/>
    <ul>
        <li>For numeric fields, you can perform <b>atomic operations</b> instead of setting values.</li>
        <br/>
        <li><b>Available operations:</b></li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Syntax</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Increment</td>
            <td><code>{ increment: n }</code></td>
            <td>Add n to current value</td>
        </tr>
        <tr>
            <td>Decrement</td>
            <td><code>{ decrement: n }</code></td>
            <td>Subtract n from current value</td>
        </tr>
        <tr>
            <td>Multiply</td>
            <td><code>{ multiply: n }</code></td>
            <td>Multiply current value by n</td>
        </tr>
        <tr>
            <td>Divide</td>
            <td><code>{ divide: n }</code></td>
            <td>Divide current value by n</td>
        </tr>
        <tr>
            <td>Set</td>
            <td><code>value</code> or <code>{ set: value }</code></td>
            <td>Replace with new value</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Increment:</b></li>
<pre><code class="language-typescript line-numbers">// Before: views = 100
await prisma.post.update({
  where: { id: 1 },
  data: {
    views: {
      increment: 1  // Add 1
    }
  }
})
// After: views = 101</code></pre>
        <br/>
        <li><b>Decrement:</b></li>
<pre><code class="language-typescript line-numbers">// Before: age = 25
await prisma.user.update({
  where: { id: 1 },
  data: {
    age: {
      decrement: 1  // Subtract 1
    }
  }
})
// After: age = 24</code></pre>
        <br/>
        <li><b>Multiply:</b></li>
<pre><code class="language-typescript line-numbers">// Before: views = 100
await prisma.post.update({
  where: { id: 1 },
  data: {
    views: {
      multiply: 2  // Double it
    }
  }
})
// After: views = 200</code></pre>
        <br/>
        <li><b>Divide:</b></li>
<pre><code class="language-typescript line-numbers">// Before: views = 100
await prisma.post.update({
  where: { id: 1 },
  data: {
    views: {
      divide: 2  // Halve it
    }
  }
})
// After: views = 50</code></pre>
        <br/>
        <li><b>Example: Race condition with regular set</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Bad - race condition possible
// User A reads views: 100
const post = await prisma.post.findUnique({ where: { id: 1 } })
// User B reads views: 100
// User A updates: 100 + 1 = 101
await prisma.post.update({
  where: { id: 1 },
  data: { views: post.views + 1 }
})
// User B updates: 100 + 1 = 101 (should be 102!)
// Lost one increment!

// ✓ Good - atomic operation, no race condition
await prisma.post.update({
  where: { id: 1 },
  data: {
    views: { increment: 1 }
  }
})
// Database handles it atomically</code></pre>
        <br/>
        <li><b>Combine with regular updates:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    title: "Updated Title",  // Regular update
    views: { increment: 1 }   // Atomic operation
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Updating Relations: Connect and Disconnect</li>
    <br/>
    <ul>
        <li>When updating relations, you have several operations:</li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Effect</th>
            <th>Syntax Pattern</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>set</code></td>
            <td>Replace all relations</td>
            <td><code>relation: { set: [...] }</code></td>
        </tr>
        <tr>
            <td><code>connect</code></td>
            <td>Add relations</td>
            <td><code>relation: { connect: [...] }</code></td>
        </tr>
        <tr>
            <td><code>disconnect</code></td>
            <td>Remove relations</td>
            <td><code>relation: { disconnect: [...] }</code></td>
        </tr>
        <tr>
            <td><code>create</code></td>
            <td>Create and connect new records</td>
            <td><code>relation: { create: [...] }</code></td>
        </tr>
        <tr>
            <td><code>delete</code></td>
            <td>Disconnect and delete records</td>
            <td><code>relation: { delete: [...] }</code></td>
        </tr>
        <tr>
            <td><code>update</code></td>
            <td>Update related records</td>
            <td><code>relation: { update: {...} }</code></td>
        </tr>
        <tr>
            <td><code>upsert</code></td>
            <td>Update if exists, create if not</td>
            <td><code>relation: { upsert: {...} }</code></td>
        </tr>
        <tr>
            <td><code>connectOrCreate</code></td>
            <td>Connect if exists, create if not</td>
            <td><code>relation: { connectOrCreate: {...} }</code></td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Updating One-to-Many Relations</li>
    <br/>
    <ul>
        <li>Scenario: User has many Posts.</li>
        <br/>
        <li><b>Connect new posts to user:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      connect: [
        { id: 5 },  // Connect existing post 5
        { id: 6 }   // Connect existing post 6
      ]
    }
  }
})

// Posts 5 and 6 now have authorId = 1
// User's existing posts are NOT affected</code></pre>
        <br/>
        <li><b>Disconnect posts from user:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      disconnect: [
        { id: 2 },  // Disconnect post 2
        { id: 3 }   // Disconnect post 3
      ]
    }
  }
})

// Posts 2 and 3 now have authorId = null (if optional)
// or throws error if authorId is required</code></pre>
        <br/>
        <li><b>Set (replace all relations):</b></li>
<pre><code class="language-typescript line-numbers">// User currently has posts: [1, 2, 3, 4]

await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      set: [
        { id: 5 },
        { id: 6 }
      ]
    }
  }
})

// User now has posts: [5, 6]
// Posts 1, 2, 3, 4 are disconnected</code></pre>
        <br/>
        <li><b>Create new posts while updating:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      create: [
        { title: "New Post 1", content: "Content" },
        { title: "New Post 2", content: "More content" }
      ]
    }
  }
})

// Creates 2 new posts and connects them to user
// Existing posts remain connected</code></pre>
        <br/>
        <li><b>Delete related posts:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      delete: [
        { id: 2 },  // Delete post 2
        { id: 3 }   // Delete post 3
      ]
    }
  }
})

// Posts 2 and 3 are DELETED from database
// Not just disconnected!</code></pre>
        <br/>
        <li><b>Combine multiple operations:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      create: [
        { title: "New Post", content: "Content" }
      ],
      connect: [
        { id: 10 }
      ],
      disconnect: [
        { id: 2 }
      ],
      delete: [
        { id: 3 }
      ]
    }
  }
})

// Creates new post
// Connects existing post 10
// Disconnects post 2
// Deletes post 3</code></pre>
    </ul>
    <br/><br/>


    <li>Updating One-to-One Relations</li>
    <br/>
    <ul>
        <li>Scenario: User has one Profile.</li>
        <br/>
        <li><b>Connect a profile:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      connect: { id: 5 }  // Single object, not array
    }
  }
})

// Profile 5 now has userId = 1</code></pre>
        <br/>
        <li><b>Disconnect profile:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      disconnect: true  // For one-to-one, just true
    }
  }
})

// Profile's userId is set to null (if optional)</code></pre>
        <br/>
        <li><b>Create new profile:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      create: {
        bio: "New bio"
      }
    }
  }
})

// Creates new profile connected to user</code></pre>
        <br/>
        <li><b>Delete existing profile:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      delete: true  // For one-to-one, just true
    }
  }
})

// Deletes the user's profile from database</code></pre>
        <br/>
        <li><b>Update existing profile:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      update: {
        bio: "Updated bio"
      }
    }
  }
})

// Updates the user's existing profile
// Throws error if user has no profile</code></pre>
        <br/>
        <li><b>Upsert profile (update if exists, create if not):</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      upsert: {
        create: {
          bio: "New bio"
        },
        update: {
          bio: "Updated bio"
        }
      }
    }
  }
})

// If user has profile: updates bio
// If user has no profile: creates one</code></pre>
        <br/>
        <li><b>Rule:</b> One-to-one uses <b>single objects</b>, one-to-many uses <b>arrays</b>.</li>
<pre><code class="language-typescript line-numbers">// One-to-one (User → Profile)
profile: {
  connect: { id: 1 }     // Object
  disconnect: true       // Boolean
  delete: true           // Boolean
}

// One-to-many (User → Posts)
posts: {
  connect: [{ id: 1 }]   // Array
  disconnect: [{ id: 1 }] // Array
  delete: [{ id: 1 }]    // Array
}</code></pre>
    </ul>
    <br/><br/>


    <li>Updating Many-to-Many Relations</li>
    <br/>
    <ul>
        <li>Scenario: Post has many Tags, Tag has many Posts.</li>
        <br/>
        <li><b>Add tags to post:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      connect: [
        { id: 1 },
        { id: 2 }
      ]
    }
  }
})

// Creates entries in join table
// Existing tag connections remain</code></pre>
        <br/>
        <li><b>Remove tags from post:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      disconnect: [
        { id: 1 },
        { id: 2 }
      ]
    }
  }
})

// Removes entries from join table
// Tags themselves are NOT deleted</code></pre>
        <br/>
        <li><b>Replace all tags:</b></li>
<pre><code class="language-typescript line-numbers">// Post currently has tags: [1, 2, 3]

await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      set: [
        { id: 4 },
        { id: 5 }
      ]
    }
  }
})

// Post now has tags: [4, 5]
// Tags 1, 2, 3 are disconnected from this post</code></pre>
        <br/>
        <li><b>Create and connect new tags:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      create: [
        { name: "newtag1" },
        { name: "newtag2" }
      ]
    }
  }
})

// Creates 2 new tags and connects them to post</code></pre>
        <br/>
        <li><b>Connect by unique field:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      connect: [
        { name: "javascript" },  // Connect by unique name
        { name: "typescript" }
      ]
    }
  }
})

// Connects to tags with these names (must exist)</code></pre>
        <br/>
        <li><b>ConnectOrCreate tags:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      connectOrCreate: [
        {
          where: { name: "javascript" },
          create: { name: "javascript" }
        },
        {
          where: { name: "newTag" },
          create: { name: "newTag" }
        }
      ]
    }
  }
})

// Connects to "javascript" if exists, creates if not
// Connects to "newTag" if exists, creates if not</code></pre>
    </ul>
    <br/><br/>


    <li>Updating Nested Relations</li>
    <br/>
    <ul>
        <li>You can update relations of relations (nested updates).</li>
        <br/>
        <li><b>Update user's posts' tags:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      update: [
        {
          where: { id: 5 },
          data: {
            title: "Updated Title",
            tags: {
              connect: [{ id: 1 }]
            }
          }
        }
      ]
    }
  }
})

// Updates post 5's title
// Connects tag 1 to post 5</code></pre>
        <br/>
        <li><b>Update or create in nested relation:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    profile: {
      upsert: {
        create: {
          bio: "New bio"
        },
        update: {
          bio: "Updated bio"
        }
      }
    },
    posts: {
      update: [
        {
          where: { id: 3 },
          data: {
            published: true
          }
        }
      ]
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Updating from the Foreign Key Side</li>
    <br/>
    <ul>
        <li>When updating from the "many" side, you can set foreign key OR use relation operations.</li>
        <br/>
        <li><b>Method 1: Set foreign key directly:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    authorId: 5  // Change author to user 5
  }
})</code></pre>
        <br/>
        <li><b>Method 2: Use connect:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    author: {
      connect: { id: 5 }
    }
  }
})

// Same result as Method 1</code></pre>
        <br/>
        <li><b>Method 3: Disconnect:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    author: {
      disconnect: true
    }
  }
})

// Sets authorId to null (only if optional)</code></pre>
        <br/>
        <li><b>Rule:</b> Cannot use BOTH foreign key and relation operation.</li>
<pre><code class="language-typescript line-numbers">// ✗ Error - conflicting
data: {
  authorId: 5,
  author: {
    connect: { id: 5 }
  }
}

// ✓ Choose one
data: {
  authorId: 5
}

// Or
data: {
  author: { connect: { id: 5 } }
}</code></pre>
    </ul>
    <br/><br/>


    <li>updateMany: Updating Multiple Records</li>
    <br/>
    <ul>
        <li><code>updateMany()</code> updates all records matching criteria.</li>
        <br/>
        <li><b>Syntax structure:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL_NAME.updateMany({
  where: {
    // Filter criteria (can use ANY fields, not just unique)
  },
  data: {
    // What to update
  }
})</code></pre>
        <br/>
        <li><b>Key differences from update():</b></li>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>update()</th>
            <th>updateMany()</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>where clause</td>
            <td>Must use unique field</td>
            <td>Can use any field(s)</td>
        </tr>
        <tr>
            <td>Records affected</td>
            <td>Exactly one (or error)</td>
            <td>Zero or more</td>
        </tr>
        <tr>
            <td>Return value</td>
            <td>Updated record</td>
            <td><code>{ count: n }</code></td>
        </tr>
        <tr>
            <td>Relation operations</td>
            <td>Supported</td>
            <td>NOT supported</td>
        </tr>
        <tr>
            <td>select/include</td>
            <td>Supported</td>
            <td>NOT supported</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Update all matching records:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.user.updateMany({
  where: {
    isActive: false
  },
  data: {
    isActive: true
  }
})

console.log(result)
// { count: 5 }  // Updated 5 users</code></pre>
        <br/>
        <li><b>Update with multiple conditions:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.updateMany({
  where: {
    published: false,
    authorId: 1
  },
  data: {
    published: true
  }
})

// Publishes all unpublished posts by user 1</code></pre>
        <br/>
        <li><b>Update with comparison operators:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.updateMany({
  where: {
    age: {
      lt: 18
    }
  },
  data: {
    role: "USER"  // Set all minors to USER role
  }
})</code></pre>
        <br/>
        <li><b>Update all records (no where clause):</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.updateMany({
  data: {
    isActive: true
  }
})

// Updates ALL users (use with caution!)</code></pre>
        <br/>
        <li><b>Atomic operations work with updateMany:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.updateMany({
  where: {
    published: true
  },
  data: {
    views: {
      increment: 1  // Increment all published posts' views
    }
  }
})</code></pre>
        <br/>
        <li><b>Cannot update relations:</b></li>
<pre><code class="language-typescript line-numbers">// ✗ Error - cannot update relations in updateMany
await prisma.user.updateMany({
  where: { age: { gt: 18 } },
  data: {
    posts: {  // Error!
      create: [{ title: "Post" }]
    }
  }
})</code></pre>
        <br/>
        <li><b>No return of updated records:</b></li>
<pre><code class="language-typescript line-numbers">const result = await prisma.user.updateMany({
  where: { age: 25 },
  data: { role: "ADMIN" }
})

console.log(result)
// { count: 3 }

// To get updated records, query again:
const updatedUsers = await prisma.user.findMany({
  where: { age: 25 }
})</code></pre>
    </ul>
    <br/><br/>


    <li>upsert: Update or Create</li>
    <br/>
    <ul>
        <li><code>upsert()</code> updates record if it exists, creates if it doesn't.</li>
        <br/>
        <li><b>Syntax structure:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL_NAME.upsert({
  where: {
    // How to find record (must use unique field)
  },
  update: {
    // What to update if record exists
  },
  create: {
    // What to create if record doesn't exist
  }
})</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.upsert({
  where: {
    email: "alice@example.com"
  },
  update: {
    name: "Alice Updated"
  },
  create: {
    email: "alice@example.com",
    name: "Alice New"
  }
})

// If user with this email exists: updates name to "Alice Updated"
// If user doesn't exist: creates with name "Alice New"</code></pre>
        <br/>
        <li><b>Return value is the updated or created record:</b></li>
<pre><code class="language-typescript line-numbers">console.log(user)
// {
//   id: 1,
//   email: "alice@example.com",
//   name: "Alice Updated",  // or "Alice New"
//   ...
// }</code></pre>
        <br/>
        <li><b>Common use case: Idempotent operations</b></li>
<pre><code class="language-typescript line-numbers">// Safe to call multiple times - same result
await prisma.user.upsert({
  where: { email: "alice@example.com" },
  update: { lastLogin: new Date() },
  create: {
    email: "alice@example.com",
    name: "Alice",
    lastLogin: new Date()
  }
})

// First call: creates user
// Subsequent calls: update lastLogin</code></pre>
        <br/>
        <li><b>Different data in update vs create:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.upsert({
  where: { email: "alice@example.com" },
  update: {
    // Only update these fields
    name: "Alice",
    age: 26
  },
  create: {
    // Must provide all required fields for create
    email: "alice@example.com",
    name: "Alice",
    age: 26,
    role: "USER"
  }
})</code></pre>
        <br/>
        <li><b>With relations:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.upsert({
  where: { email: "alice@example.com" },
  update: {
    name: "Alice Updated",
    posts: {
      create: [{ title: "New Post", content: "Content" }]
    }
  },
  create: {
    email: "alice@example.com",
    name: "Alice",
    posts: {
      create: [{ title: "First Post", content: "Content" }]
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Conditional Updates with update.where</li>
    <br/>
    <ul>
        <li>When updating arrays of relations, you can filter which items to update.</li>
        <br/>
        <li><b>Update specific posts in array:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      update: [
        {
          where: { id: 5 },  // Which post to update
          data: {
            published: true  // What to update
          }
        },
        {
          where: { id: 6 },
          data: {
            published: true
          }
        }
      ]
    }
  }
})

// Only updates posts 5 and 6</code></pre>
        <br/>
        <li><b>Update matching criteria:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      updateMany: {
        where: {
          published: false  // Filter posts to update
        },
        data: {
          published: true
        }
      }
    }
  }
})

// Updates all unpublished posts for this user</code></pre>
        <br/>
        <li><b>Delete matching posts:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    posts: {
      deleteMany: {
        where: {
          views: { lt: 10 }  // Delete posts with few views
        }
      }
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Updating JSON Fields</li>
    <br/>
    <ul>
        <li>JSON fields can be updated completely or partially.</li>
        <br/>
        <li><b>Replace entire JSON:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    metadata: {
      theme: "dark",
      notifications: true
    }
  }
})

// Replaces entire JSON field</code></pre>
        <br/>
        <li><b>Update nested JSON path (PostgreSQL only):</b></li>
<pre><code class="language-typescript line-numbers">// Current: { preferences: { theme: "light" }, tags: ["a"] }

await prisma.user.update({
  where: { id: 1 },
  data: {
    metadata: {
      path: ['preferences', 'theme'],
      set: 'dark'
    }
  }
})

// Result: { preferences: { theme: "dark" }, tags: ["a"] }
// Only updates the nested path</code></pre>
        <br/>
        <li><b>Set to null:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    metadata: null  // Clear JSON field
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Updating Arrays (PostgreSQL/MongoDB)</li>
    <br/>
    <ul>
        <li>For databases that support arrays (PostgreSQL, MongoDB), you can update array fields.</li>
        <br/>
        <li><b>Replace entire array:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    tags: ["javascript", "typescript"]
  }
})

// Replaces entire array</code></pre>
        <br/>
        <li><b>Add to array:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    tags: {
      push: "react"  // Add to end
    }
  }
})

// Before: ["javascript", "typescript"]
// After: ["javascript", "typescript", "react"]</code></pre>
        <br/>
        <li><b>Add multiple items:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    tags: {
      push: ["react", "vue"]
    }
  }
})</code></pre>
        <br/>
        <li><b>Set to empty array:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    tags: []  // or { set: [] }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Error Handling</li>
    <br/>
    <ul>
        <li><b>Record not found:</b></li>
<pre><code class="language-typescript line-numbers">try {
  await prisma.user.update({
    where: { id: 9999 },
    data: { name: "Updated" }
  })
} catch (error) {
  if (error.code === 'P2025') {
    console.log('Record to update not found')
  }
}</code></pre>
        <br/>
        <li><b>Unique constraint violation:</b></li>
<pre><code class="language-typescript line-numbers">try {
  await prisma.user.update({
    where: { id: 1 },
    data: { email: "existing@example.com" }  // Email already used
  })
} catch (error) {
  if (error.code === 'P2002') {
    console.log('Email already exists')
  }
}</code></pre>
        <br/>
        <li><b>Foreign key constraint:</b></li>
<pre><code class="language-typescript line-numbers">try {
  await prisma.post.update({
    where: { id: 1 },
    data: { authorId: 9999 }  // User doesn't exist
  })
} catch (error) {
  if (error.code === 'P2003') {
    console.log('Foreign key constraint failed')
  }
}</code></pre>
    </ul>
    <br/><br/>


    <li>Selecting Return Data</li>
    <br/>
    <ul>
        <li>Like create, you can control what update returns.</li>
        <br/>
        <li><b>Default - returns full record:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.update({
  where: { id: 1 },
  data: { name: "Alice" }
})

// Returns all fields</code></pre>
        <br/>
        <li><b>Select specific fields:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.update({
  where: { id: 1 },
  data: { name: "Alice" },
  select: {
    id: true,
    name: true,
    email: true
  }
})

// Returns only id, name, email</code></pre>
        <br/>
        <li><b>Include relations:</b></li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.update({
  where: { id: 1 },
  data: { name: "Alice" },
  include: {
    posts: true,
    profile: true
  }
})

// Returns user with posts and profile</code></pre>
    </ul>
    <br/><br/>


    <li>Common Update Patterns</li>
    <br/>
    <ul>
        <li><b>Toggle boolean:</b></li>
<pre><code class="language-typescript line-numbers">// Get current state and toggle
const user = await prisma.user.findUnique({ where: { id: 1 } })
await prisma.user.update({
  where: { id: 1 },
  data: { isActive: !user.isActive }
})</code></pre>
        <br/>
        <li><b>Increment counter:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    views: { increment: 1 }
  }
})</code></pre>
        <br/>
        <li><b>Update timestamp:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.user.update({
  where: { id: 1 },
  data: {
    lastLogin: new Date()
  }
})</code></pre>
        <br/>
        <li><b>Add tag to post:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.update({
  where: { id: 1 },
  data: {
    tags: {
      connectOrCreate: {
        where: { name: "javascript" },
        create: { name: "javascript" }
      }
    }
  }
})</code></pre>
        <br/>
        <li><b>Transfer ownership:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.post.updateMany({
  where: { authorId: 1 },  // All posts by user 1
  data: { authorId: 2 }     // Transfer to user 2
})</code></pre>
    </ul>
    <br/><br/>


    <li>Summary: Update Syntax Patterns</li>
    <br/>
    <ul>
        <li><b>Basic update:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.update({
  where: { uniqueField: value },
  data: { field: value }
})</code></pre>
        <br/>
        <li><b>Atomic operations:</b></li>
<pre><code class="language-typescript line-numbers">data: {
  numericField: { increment: n }  // or decrement, multiply, divide
}</code></pre>
        <br/>
        <li><b>Relation operations (one-to-many):</b></li>
<pre><code class="language-typescript line-numbers">data: {
  relationMany: {
    set: [{ id: 1 }],        // Replace all
    connect: [{ id: 2 }],    // Add
    disconnect: [{ id: 3 }], // Remove
    create: [{ }],           // Create and add
    delete: [{ id: 4 }],     // Remove and delete
    update: [{               // Update specific
      where: { id: 5 },
      data: { }
    }]
  }
}</code></pre>
        <br/>
        <li><b>Relation operations (one-to-one):</b></li>
<pre><code class="language-typescript line-numbers">data: {
  relationOne: {
    connect: { id: 1 },      // Connect
    disconnect: true,        // Disconnect
    create: { },             // Create and connect
    delete: true,            // Disconnect and delete
    update: { },             // Update
    upsert: {                // Update or create
      create: { },
      update: { }
    }
  }
}</code></pre>
        <br/>
        <li><b>Update many:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.updateMany({
  where: { anyField: value },  // Can use any field
  data: { field: value }       // No relations allowed
})
// Returns: { count: n }</code></pre>
        <br/>
        <li><b>Upsert:</b></li>
<pre><code class="language-typescript line-numbers">await prisma.MODEL.upsert({
  where: { uniqueField: value },
  update: { field: value },
  create: { field: value }
})</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
