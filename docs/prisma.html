<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Prisma</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/prisma.png" alt="Logo" class="nav-icon"/> </h2>
    <ol style="line-height: 1.8;">
        <li><a href="#prisma-introduction">Introduction</a></li>
        <li><a href="#prisma-database-connections">Database Connection Configuration</a></li>
        <li><a href="#prisma-connection-pooling">Connection Pooling vs Direct Connection</a></li>
        <li><a href="#prisma-shadow-database">Shadow Database</a></li>
        <li><a href="#prisma-read-replicas">Read Replicas</a></li>
        <li><a href="#prisma-schema-overview">Schema Overview</a></li>
        <li><a href="#prisma-relationships">Understanding Relationships</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-introduction">Introduction to Prisma ORM</h3>
<ol>

    <li>What Is Prisma?</li>
    <br/>
    <ul>
        <li><b>Prisma</b> is a modern, type-safe ORM (Object-Relational Mapping) for Node.js and TypeScript.</li>
        <br/>
        <li>Prisma is not just an ORM - it's a complete database toolkit that includes:</li>
        <ul>
            <li><code>Prisma Client</code>: auto-generated query builder</li>
            <li><code>Prisma Migrate</code>: declarative database migrations</li>
            <li><code>Prisma Studio</code>: visual database editor</li>
        </ul>
        <br/>
        <li>Official website: <code>https://www.prisma.io</code></li>
    </ul>
    <br/><br/>


    <li>Why Use Prisma?</li>
    <br/>
    <ul>
        <li>Prisma solves common problems with traditional ORMs:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Traditional ORMs</th>
            <th>Prisma</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Complex entity classes</td>
            <td>Simple schema definition</td>
        </tr>
        <tr>
            <td>Runtime type safety issues</td>
            <td>Compile-time type safety</td>
        </tr>
        <tr>
            <td>Poor TypeScript support</td>
            <td>First-class TypeScript support</td>
        </tr>
        <tr>
            <td>N+1 query problems</td>
            <td>Optimized query generation</td>
        </tr>
        <tr>
            <td>Manual migration scripts</td>
            <td>Declarative migrations</td>
        </tr>
        <tr>
            <td>Complex query builder APIs</td>
            <td>Intuitive, readable API</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Supported Databases</li>
    <br/>
    <ul>
        <li>Prisma supports major relational and NoSQL databases:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Database</th>
            <th>Status</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>MongoDB</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>CockroachDB</td>
            <td>✓ Fully supported</td>
        </tr>
        <tr>
            <td>PlanetScale</td>
            <td>✓ Fully supported</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Database-specific features are supported where available (enums, JSON types, etc.).</li>
    </ul>
    <br/><br/>


    <li>Core Concepts</li>
    <br/>
    <ul>
        <li><b>Prisma Schema:</b> A single source of truth for your database structure.</li>
<pre><code class="language-prisma line-numbers">// schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
}</code></pre>
        <br/>
        <li><b>Prisma Client:</b> Auto-generated, type-safe database client.</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Type-safe query
const user = await prisma.user.findUnique({
  where: { email: 'alice@example.com' }
})</code></pre>
        <br/>
        <li><b>Migrations:</b> Version-controlled database schema changes.</li>
<pre><code class="language-bash line-numbers">npx prisma migrate dev --name add_user_model</code></pre>
        <br/>
        <li><b>Prisma Studio:</b> Visual database browser and editor.</li>
<pre><code class="language-bash line-numbers">npx prisma studio</code></pre>
    </ul>
    <br/><br/>


    <li>Installation and Setup</li>
    <br/>
    <ul>
        <li>Install Prisma in your Node.js project:</li>
<pre><code class="language-bash line-numbers">npm install prisma --save-dev
npm install @prisma/client</code></pre>
        <br/>
        <li>Initialize Prisma in your project:</li>
<pre><code class="language-bash line-numbers">npx prisma init</code></pre>
        <br/>
        <li>This creates:</li>
<pre><code class="language-plaintext line-numbers">project/
├── prisma/
│   └── schema.prisma
└── .env</code></pre>
        <br/>
        <li>Configure database connection in <code>.env</code>:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:password@localhost:5432/mydb"</code></pre>
        <br/>
        <li>Example for different databases:</li>
<pre><code class="language-plaintext line-numbers"># PostgreSQL
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"

# MySQL
DATABASE_URL="mysql://user:password@localhost:3306/mydb"

# SQLite
DATABASE_URL="file:./dev.db"

# SQL Server
DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=Password123"

# MongoDB
DATABASE_URL="mongodb://user:password@localhost:27017/mydb"</code></pre>
    </ul>
    <br/><br/>


    <li>The Prisma Schema File</li>
    <br/>
    <ul>
        <li>The <code>schema.prisma</code> file defines your database structure:</li>
<pre><code class="language-prisma line-numbers">// Data source configuration
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Generator configuration
generator client {
  provider = "prisma-client-js"
}

// Data model
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li>Schema components:</li>
<table>
    <thead>
        <tr>
            <th>Component</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>datasource</code></td>
            <td>Database connection configuration</td>
        </tr>
        <tr>
            <td><code>generator</code></td>
            <td>Specifies what to generate (Prisma Client, etc.)</td>
        </tr>
        <tr>
            <td><code>model</code></td>
            <td>Defines database tables/collections</td>
        </tr>
        <tr>
            <td><code>enum</code></td>
            <td>Defines enumeration types</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Creating Your First Model</li>
    <br/>
    <ul>
        <li>Define a simple User model:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}</code></pre>
        <br/>
        <li>Field type modifiers:</li>
<table>
    <thead>
        <tr>
            <th>Modifier</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@id</code></td>
            <td>Defines primary key</td>
        </tr>
        <tr>
            <td><code>@unique</code></td>
            <td>Ensures field values are unique</td>
        </tr>
        <tr>
            <td><code>@default()</code></td>
            <td>Sets default value</td>
        </tr>
        <tr>
            <td><code>@updatedAt</code></td>
            <td>Automatically updates on record modification</td>
        </tr>
        <tr>
            <td><code>?</code></td>
            <td>Makes field optional (nullable)</td>
        </tr>
        <tr>
            <td><code>[]</code></td>
            <td>Defines array/list type</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Common field types:</li>
<pre><code class="language-prisma line-numbers">model Example {
  id        Int      @id
  text      String
  number    Int
  decimal   Float
  boolean   Boolean
  date      DateTime
  json      Json
  bytes     Bytes
}</code></pre>
    </ul>
    <br/><br/>


    <li>Generating Prisma Client</li>
    <br/>
    <ul>
        <li>After defining your schema, generate the Prisma Client:</li>
<pre><code class="language-bash line-numbers">npx prisma generate</code></pre>
        <br/>
        <li>This generates a type-safe client in <code>node_modules/@prisma/client</code>.</li>
        <br/>
        <li>The client is automatically regenerated when you run migrations.</li>
        <br/>
        <li>Import and use the client in your code:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  const user = await prisma.user.create({
    data: {
      email: 'alice@example.com',
      name: 'Alice'
    }
  })
  console.log(user)
}

main()
  .catch(console.error)
  .finally(() =&gt; prisma.$disconnect())</code></pre>
    </ul>
    <br/><br/>


    <li>Database Migrations</li>
    <br/>
    <ul>
        <li>Create and apply migrations during development:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate dev --name init</code></pre>
        <br/>
        <li>This command:</li>
        <ul>
            <li>creates a new migration file</li>
            <li>applies the migration to the database</li>
            <li>regenerates Prisma Client</li>
        </ul>
        <br/>
        <li>Migration files are stored in:</li>
<pre><code class="language-plaintext line-numbers">prisma/
└── migrations/
    └── 20240101000000_init/
        └── migration.sql</code></pre>
        <br/>
        <li>Apply migrations in production:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate deploy</code></pre>
        <br/>
        <li>View migration status:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate status</code></pre>
        <br/>
        <li>Reset database (caution - deletes all data):</li>
<pre><code class="language-bash line-numbers">npx prisma migrate reset</code></pre>
    </ul>
    <br/><br/>


    <li>Basic CRUD Operations</li>
    <br/>
    <ul>
        <li><b>Create:</b> Insert new records</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    name: 'Alice'
  }
})</code></pre>
        <br/>
        <li><b>Read:</b> Query records</li>
<pre><code class="language-typescript line-numbers">// Find unique record
const user = await prisma.user.findUnique({
  where: { email: 'alice@example.com' }
})

// Find many records
const users = await prisma.user.findMany({
  where: { name: { contains: 'Alice' } }
})

// Find first matching record
const user = await prisma.user.findFirst({
  where: { email: 'alice@example.com' }
})</code></pre>
        <br/>
        <li><b>Update:</b> Modify existing records</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.update({
  where: { id: 1 },
  data: { name: 'Alice Updated' }
})</code></pre>
        <br/>
        <li><b>Delete:</b> Remove records</li>
<pre><code class="language-typescript line-numbers">const user = await prisma.user.delete({
  where: { id: 1 }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Prisma Studio</li>
    <br/>
    <ul>
        <li>Prisma Studio is a visual database browser and editor.</li>
        <br/>
        <li>Start Prisma Studio:</li>
<pre><code class="language-bash line-numbers">npx prisma studio</code></pre>
        <br/>
        <li>This opens a web interface (usually at <code>http://localhost:5555</code>).</li>
    </ul>
    <br/><br/>


    <li>Introspection</li>
    <br/>
    <ul>
        <li>Prisma can introspect existing databases to generate a schema:</li>
<pre><code class="language-bash line-numbers">npx prisma db pull</code></pre>
        <br/>
        <li>This command:</li>
        <ul>
            <li>connects to your database</li>
            <li>analyzes the database schema</li>
            <li>generates corresponding Prisma models</li>
        </ul>
        <br/>
        <li>Useful when:</li>
        <ul>
            <li>adding Prisma to an existing project</li>
            <li>working with a legacy database</li>
            <li>synchronizing schema after manual database changes</li>
        </ul>
        <br/>
        <li>Example workflow with existing database:</li>
<pre><code class="language-bash line-numbers"># 1. Initialize Prisma
npx prisma init

# 2. Configure DATABASE_URL in .env

# 3. Introspect database
npx prisma db pull

# 4. Generate Prisma Client
npx prisma generate</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-database-connections">Database Connection Configuration</h3>
<ol>

    <li>Basic Connection String</li>
    <br/>
    <ul>
        <li>Database connection is configured in <code>.env</code> file:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="provider://user:password@host:port/database?options"</code></pre>
        <br/>
        <li>Referenced in <code>schema.prisma</code>:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Strings by Database</li>
    <br/>
    <ul>
        <li><b>PostgreSQL:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"</code></pre>
        <br/>
        <li><b>MySQL:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mysql://user:password@localhost:3306/mydb"</code></pre>
        <br/>
        <li><b>SQLite:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="file:./dev.db"</code></pre>
        <br/>
        <li><b>SQL Server:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=Pass123;encrypt=true"</code></pre>
        <br/>
        <li><b>MongoDB:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mongodb+srv://user:password@cluster.mongodb.net/mydb?retryWrites=true"</code></pre>
        <br/>
        <li><b>CockroachDB:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:password@host:26257/mydb?sslmode=verify-full"</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Parameters</li>
    <br/>
    <ul>
        <li>PostgreSQL parameters:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?schema=public&connection_limit=10&pool_timeout=20&sslmode=require"</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>schema</code></td>
            <td>PostgreSQL schema name (default: <code>public</code>)</td>
        </tr>
        <tr>
            <td><code>connection_limit</code></td>
            <td>Max number of connections in pool</td>
        </tr>
        <tr>
            <td><code>pool_timeout</code></td>
            <td>Seconds to wait for connection (default: 10)</td>
        </tr>
        <tr>
            <td><code>sslmode</code></td>
            <td><code>disable</code>, <code>prefer</code>, <code>require</code></td>
        </tr>
        <tr>
            <td><code>sslcert</code></td>
            <td>Path to SSL certificate</td>
        </tr>
        <tr>
            <td><code>connect_timeout</code></td>
            <td>Seconds to wait for initial connection</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>MySQL parameters:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mysql://user:pass@localhost:3306/db?connection_limit=10&socket_timeout=10&ssl=true"</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>connection_limit</code></td>
            <td>Max connections in pool</td>
        </tr>
        <tr>
            <td><code>socket_timeout</code></td>
            <td>Seconds before socket timeout</td>
        </tr>
        <tr>
            <td><code>ssl</code></td>
            <td>SSL/TLS configuration</td>
        </tr>
        <tr>
            <td><code>sslcert</code></td>
            <td>Path to SSL certificate</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Connection Pooling</li>
    <br/>
    <ul>
        <li>Set connection pool size:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=20"</code></pre>
        <br/>
        <li>Default pool sizes by database:</li>
<table>
    <thead>
        <tr>
            <th>Database</th>
            <th>Default Pool Size</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td>num_cpus * 2 + 1</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>num_cpus * 2 + 1</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>num_cpus * 2 + 1</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>1 (no pooling)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Configure pool behavior:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=50&pool_timeout=30"</code></pre>
    </ul>
    <br/><br/>


    <li>SSL/TLS Configuration</li>
    <br/>
    <ul>
        <li>PostgreSQL SSL modes:</li>
<pre><code class="language-plaintext line-numbers"># Disable SSL
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=disable"

# Prefer SSL but allow non-SSL
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=prefer"

# Require SSL
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=require"

# Require SSL with certificate verification
DATABASE_URL="postgresql://user:pass@localhost:5432/db?sslmode=verify-full&sslcert=./cert.pem&sslidentity=./identity.p12&sslpassword=password"</code></pre>
        <br/>
        <li>MySQL SSL:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="mysql://user:pass@localhost:3306/db?ssl=true&sslcert=./cert.pem"</code></pre>
        <br/>
        <li>Certificate-based authentication:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user@localhost:5432/db?sslmode=require&sslcert=/path/to/client-cert.pem&sslkey=/path/to/client-key.pem&sslrootcert=/path/to/ca-cert.pem"</code></pre>
    </ul>
    <br/><br/>


    <li>Environment-Specific Configuration</li>
    <br/>
    <ul>
        <li>Use different URLs per environment:</li>
<pre><code class="language-plaintext line-numbers"># .env.development
DATABASE_URL="postgresql://localhost:5432/mydb_dev"

# .env.test
DATABASE_URL="postgresql://localhost:5432/mydb_test"

# .env.production
DATABASE_URL="postgresql://prod-host:5432/mydb?connection_limit=100&sslmode=require"</code></pre>
        <br/>
        <li>Runtime environment variable:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const databaseUrl = process.env.NODE_ENV === 'test'
  ? process.env.TEST_DATABASE_URL
  : process.env.DATABASE_URL

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: databaseUrl
    }
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Connection URL from Multiple Sources</li>
    <br/>
    <ul>
        <li>Override in schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Optional: direct URL for migrations
  directUrl = env("DIRECT_DATABASE_URL")
}</code></pre>
        <br/>
        <li>Override at runtime:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.CUSTOM_DATABASE_URL
    }
  }
})</code></pre>
        <br/>
        <li>Build connection URL dynamically:</li>
<pre><code class="language-typescript line-numbers">const host = process.env.DB_HOST
const port = process.env.DB_PORT
const user = process.env.DB_USER
const password = process.env.DB_PASSWORD
const database = process.env.DB_NAME

const url = `postgresql://${user}:${password}@${host}:${port}/${database}?schema=public`

const prisma = new PrismaClient({
  datasources: { db: { url } }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Pooling vs Direct Connection</li>
    <br/>
    <ul>
        <li>Use <code>directUrl</code> for migrations with connection poolers:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")        // Pooled connection
  directUrl = env("DIRECT_DATABASE_URL") // Direct connection for migrations
}</code></pre>
        <br/>
        <li>Example with PgBouncer:</li>
<pre><code class="language-plaintext line-numbers"># Pooled connection (application queries)
DATABASE_URL="postgresql://user:pass@pgbouncer:6432/db?pgbouncer=true"

# Direct connection (migrations)
DIRECT_DATABASE_URL="postgresql://user:pass@postgres:5432/db"</code></pre>
        <br/>
        <li>PlanetScale example:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma" // Required for PlanetScale
}</code></pre>
    </ul>
    <br/><br/>


    <li>Shadow Database</li>
    <br/>
    <ul>
        <li>Configure shadow database for development migrations:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"</code></pre>
        <br/>
        <li>Required when:</li>
        <ul>
            <li>database provider doesn't support automatic shadow database creation</li>
            <li>insufficient permissions to create databases</li>
            <li>using managed database services with restrictions</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Read Replicas</li>
    <br/>
    <ul>
        <li>Configure read replicas (Prisma 5.0+):</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [
    {
      name = "read_replicas"
      url  = env("READ_REPLICA_URL")
    }
  ]
}</code></pre>
        <br/>
        <li>Use read replicas in code:</li>
<pre><code class="language-typescript line-numbers">// Write to primary
await prisma.user.create({
  data: { email: 'user@example.com' }
})

// Read from replica
const users = await prisma.user.findMany().$replica()</code></pre>
    </ul>
    <br/><br/>


    <li>Connection Timeouts</li>
    <br/>
    <ul>
        <li>Configure various timeout values:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/db?connect_timeout=10&pool_timeout=20&socket_timeout=30"</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Timeout Type</th>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Connect</td>
            <td><code>connect_timeout</code></td>
            <td>Seconds to wait for initial connection</td>
        </tr>
        <tr>
            <td>Pool</td>
            <td><code>pool_timeout</code></td>
            <td>Seconds to wait for connection from pool</td>
        </tr>
        <tr>
            <td>Socket</td>
            <td><code>socket_timeout</code></td>
            <td>Seconds to wait for query response</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Special Characters in Connection String</li>
    <br/>
    <ul>
        <li>URL-encode special characters in passwords:</li>
<pre><code class="language-typescript line-numbers">// Password: p@ss:word/123
// Encoded: p%40ss%3Aword%2F123
DATABASE_URL="postgresql://user:p%40ss%3Aword%2F123@localhost:5432/db"</code></pre>
        <br/>
        <li>Common encodings:</li>
<table>
    <thead>
        <tr>
            <th>Character</th>
            <th>Encoded</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@</code></td>
            <td><code>%40</code></td>
        </tr>
        <tr>
            <td><code>:</code></td>
            <td><code>%3A</code></td>
        </tr>
        <tr>
            <td><code>/</code></td>
            <td><code>%2F</code></td>
        </tr>
        <tr>
            <td><code>?</code></td>
            <td><code>%3F</code></td>
        </tr>
        <tr>
            <td><code>#</code></td>
            <td><code>%23</code></td>
        </tr>
        <tr>
            <td><code>&</code></td>
            <td><code>%26</code></td>
        </tr>
        <tr>
            <td><code>=</code></td>
            <td><code>%3D</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Encode programmatically:</li>
<pre><code class="language-typescript line-numbers">const password = "p@ss:word"
const encoded = encodeURIComponent(password)
const url = `postgresql://user:${encoded}@localhost:5432/db`</code></pre>
    </ul>
    <br/><br/>


    <li>Connection String Templates</li>
    <br/>
    <ul>
        <li><b>Local development:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb?schema=public"</code></pre>
        <br/>
        <li><b>Docker Compose:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:postgres@db:5432/mydb?schema=public"</code></pre>
        <br/>
        <li><b>Heroku:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@ec2-host.compute-1.amazonaws.com:5432/db?sslmode=require"</code></pre>
        <br/>
        <li><b>AWS RDS:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@mydb.123456.us-east-1.rds.amazonaws.com:5432/mydb?sslmode=require"</code></pre>
        <br/>
        <li><b>Supabase:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:pass@db.project.supabase.co:5432/postgres?pgbouncer=true"
DIRECT_DATABASE_URL="postgresql://postgres:pass@db.project.supabase.co:5432/postgres"</code></pre>
        <br/>
        <li><b>Railway:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@containers-us-west-123.railway.app:5432/railway"</code></pre>
        <br/>
        <li><b>Neon:</b></li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@ep-cool-name-123456.us-east-2.aws.neon.tech/neondb?sslmode=require"</code></pre>
    </ul>
    <br/><br/>


    <li>Testing Connection</li>
    <br/>
    <ul>
        <li>Test database connection:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function testConnection() {
  try {
    await prisma.$connect()
    console.log('Database connection successful')
  } catch (error) {
    console.error('Database connection failed:', error)
  } finally {
    await prisma.$disconnect()
  }
}

testConnection()</code></pre>
        <br/>
        <li>Execute raw query to test:</li>
<pre><code class="language-typescript line-numbers">const result = await prisma.$queryRaw`SELECT 1`
console.log('Connection test:', result)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Connection Issues</li>
    <br/>
    <ul>
        <li>Connection refused:</li>
<pre><code class="language-plaintext line-numbers">Error: Can't reach database server at `localhost:5432`

Solutions:
- Check if database is running
- Verify host and port
- Check firewall rules</code></pre>
        <br/>
        <li>Authentication failed:</li>
<pre><code class="language-plaintext line-numbers">Error: Authentication failed against database server

Solutions:
- Verify username and password
- Check user permissions
- Ensure URL encoding for special characters</code></pre>
        <br/>
        <li>Database does not exist:</li>
<pre><code class="language-plaintext line-numbers">Error: Database `mydb` does not exist

Solutions:
- Create database manually
- Check database name in connection string
- Run migrations to create schema</code></pre>
        <br/>
        <li>SSL required:</li>
<pre><code class="language-plaintext line-numbers">Error: SSL connection is required

Solution:
DATABASE_URL="postgresql://user:pass@host:5432/db?sslmode=require"</code></pre>
        <br/>
        <li>Connection pool exhausted:</li>
<pre><code class="language-plaintext line-numbers">Error: Timed out fetching a connection from the pool

Solutions:
- Increase connection_limit
- Ensure connections are properly closed
- Check for connection leaks</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Database Connections</li>
    <br/>
    <ul>
        <li>Multiple Prisma instances for different databases:</li>
<pre><code class="language-typescript line-numbers">// lib/prisma-main.ts
import { PrismaClient } from '@prisma/client'

export const prismaMain = new PrismaClient({
  datasources: {
    db: { url: process.env.MAIN_DATABASE_URL }
  }
})

// lib/prisma-analytics.ts
import { PrismaClient } from '@prisma/client'

export const prismaAnalytics = new PrismaClient({
  datasources: {
    db: { url: process.env.ANALYTICS_DATABASE_URL }
  }
})</code></pre>
        <br/>
        <li>Multiple schemas (PostgreSQL):</li>
<pre><code class="language-prisma line-numbers">// schema1.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public", "auth"]
}

model User {
  id    Int    @id
  email String

  @@schema("auth")
}

model Post {
  id    Int    @id
  title String

  @@schema("public")
}</code></pre>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-connection-pooling">Connection Pooling vs Direct Connection</h3>
<ol>

    <li>What Is Connection Pooling?</li>
    <br/>
    <ul>
        <li>A <b>connection pool</b> maintains a set of reusable database connections instead of creating new connections for each request.</li>
        <br/>
        <li>Connection lifecycle:</li>
<pre><code class="language-plaintext line-numbers">Without pooling:
Request → Create Connection → Execute Query → Close Connection → Response
(Expensive: ~20-50ms overhead per request)

With pooling:
Request → Get Connection from Pool → Execute Query → Return to Pool → Response
(Fast: ~1-2ms overhead per request)</code></pre>
        <br/>
        <li>Built-in pooling in Prisma:</li>
        <ul>
            <li>Prisma Client includes connection pooling by default</li>
            <li>pool size defaults to <code>(num_cpus * 2) + 1</code></li>
            <li>connections are kept alive and reused</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Direct Connection vs Pooled Connection</li>
    <br/>
    <ul>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>Direct Connection</th>
            <th>Pooled Connection</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Connection Creation</b></td>
            <td>Per request</td>
            <td>Reused from pool</td>
        </tr>
        <tr>
            <td><b>Latency</b></td>
            <td>Higher (20-50ms overhead)</td>
            <td>Lower (1-2ms overhead)</td>
        </tr>
        <tr>
            <td><b>Database Load</b></td>
            <td>High (many connections)</td>
            <td>Low (controlled connections)</td>
        </tr>
        <tr>
            <td><b>Scalability</b></td>
            <td>Limited by max connections</td>
            <td>Better (pool manages connections)</td>
        </tr>
        <tr>
            <td><b>Features</b></td>
            <td>All database features</td>
            <td>May have limitations</td>
        </tr>
        <tr>
            <td><b>Migrations</b></td>
            <td>Supported</td>
            <td>Often not supported</td>
        </tr>
        <tr>
            <td><b>Prepared Statements</b></td>
            <td>Fully supported</td>
            <td>Limited in transaction mode</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Configuring Both in Prisma</li>
    <br/>
    <ul>
        <li>Use <code>url</code> for pooled, <code>directUrl</code> for direct:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")        // Pooled connection
  directUrl = env("DIRECT_DATABASE_URL") // Direct connection
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers"># Pooled connection (via PgBouncer)
DATABASE_URL="postgresql://user:pass@pgbouncer:6432/mydb?pgbouncer=true"

# Direct connection (to PostgreSQL)
DIRECT_DATABASE_URL="postgresql://user:pass@postgres:5432/mydb"</code></pre>
        <br/>
        <li>Behavior:</li>
        <ul>
            <li><code>url</code> - used for queries (<code>prisma.user.findMany()</code>)</li>
            <li><code>directUrl</code> - used for migrations (<code>prisma migrate</code>)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>PgBouncer Configuration</li>
    <br/>
    <ul>
        <li>PgBouncer is a popular PostgreSQL connection pooler.</li>
        <br/>
        <li>Connection modes:</li>
<table>
    <thead>
        <tr>
            <th>Mode</th>
            <th>Description</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>session</code></td>
            <td>Connection held for entire session</td>
            <td>Full PostgreSQL feature support</td>
        </tr>
        <tr>
            <td><code>transaction</code></td>
            <td>Connection held for transaction</td>
            <td>Most common, good performance</td>
        </tr>
        <tr>
            <td><code>statement</code></td>
            <td>Connection returned after each statement</td>
            <td>Maximum connection reuse</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Basic PgBouncer setup:</li>
<pre><code class="language-ini line-numbers"># pgbouncer.ini
[databases]
mydb = host=postgres port=5432 dbname=mydb

[pgbouncer]
listen_port = 6432
listen_addr = *
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20</code></pre>
        <br/>
        <li>Prisma configuration:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:6432/mydb?pgbouncer=true"
DIRECT_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"</code></pre>
        <br/>
        <li>The <code>?pgbouncer=true</code> parameter tells Prisma to use transaction mode optimizations.</li>
    </ul>
    <br/><br/>


    <li>Connection Pool Exhaustion</li>
    <br/>
    <ul>
        <li>Common problem when pool size is too small:</li>
<pre><code class="language-plaintext line-numbers">Error: Timed out fetching a new connection from the connection pool.
More info: http://pris.ly/d/connection-pool</code></pre>
        <br/>
        <li>Causes:</li>
        <ul>
            <li>too many concurrent requests</li>
            <li>connections not being released</li>
            <li>long-running queries</li>
            <li>connection leaks</li>
        </ul>
        <br/>
        <li>Solutions:</li>
<pre><code class="language-plaintext line-numbers"># Increase pool size
DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=50"

# Increase pool timeout
DATABASE_URL="postgresql://user:pass@host:5432/db?pool_timeout=30"</code></pre>
        <br/>
        <li>Always disconnect in scripts:</li>
<pre><code class="language-typescript line-numbers">async function script() {
  try {
    // Your database operations
  } finally {
    await prisma.$disconnect()  // Release connections
  }
}</code></pre>
        <br/>
        <li>Check for connection leaks:</li>
<pre><code class="language-typescript line-numbers">// Bad - connection leak
async function badExample() {
  const prisma = new PrismaClient()
  const users = await prisma.user.findMany()
  return users  // Never disconnects!
}

// Good - proper cleanup
const prisma = new PrismaClient()  // Singleton
async function goodExample() {
  const users = await prisma.user.findMany()
  return users  // Prisma instance managed globally
}</code></pre>
    </ul>
    <br/><br/>


    <li>Calculating Optimal Pool Size</li>
    <br/>
    <ul>
        <li>Formula for traditional servers:</li>
<pre><code class="language-plaintext line-numbers">pool_size = (num_cores * 2) + effective_spindle_count

Example: 4 cores, 1 disk = (4 * 2) + 1 = 9 connections</code></pre>
        <br/>
        <li>Serverless considerations:</li>
<pre><code class="language-plaintext line-numbers">max_connections = max_concurrent_invocations * connection_limit

Example:
- 100 concurrent Lambda invocations
- connection_limit = 1 per invocation
- Total = 100 connections needed

Solution: Use connection pooler to reduce to 10-20 actual connections</code></pre>
        <br/>
        <li>Configure per environment:</li>
<pre><code class="language-plaintext line-numbers"># Development (single developer)
DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=5"

# Production (high traffic)
DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=50"

# Serverless (via pooler)
DATABASE_URL="postgresql://user:pass@pooler:6432/db?connection_limit=1"</code></pre>
    </ul>
    <br/><br/>


    <li>Monitoring Connection Usage</li>
    <br/>
    <ul>
        <li>Check active connections in PostgreSQL:</li>
<pre><code class="language-sql line-numbers">SELECT count(*)
FROM pg_stat_activity
WHERE state = 'active';</code></pre>
        <br/>
        <li>View connection pool metrics in Prisma:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'info', emit: 'event' },
  ]
})

prisma.$on('query', (e) =&gt; {
  console.log('Query:', e.query)
  console.log('Duration:', e.duration, 'ms')
})

// Check pool metrics
const metrics = await prisma.$metrics.json()
console.log(metrics)</code></pre>
        <br/>
        <li>Monitor pool exhaustion events:</li>
<pre><code class="language-typescript line-numbers">prisma.$on('info', (e) => {
  if (e.message.includes('pool timeout')) {
    console.error('Pool exhausted:', e)
    // Alert or scale up
  }
})</code></pre>
    </ul>
    <br/><br/>


    <li>Migration Strategies</li>
    <br/>
    <ul>
        <li>Always use direct connection for migrations:</li>
<pre><code class="language-bash line-numbers"># This uses directUrl automatically
npx prisma migrate deploy</code></pre>
        <br/>
        <li>If no <code>directUrl</code> configured:</li>
<pre><code class="language-bash line-numbers"># Temporarily set direct connection
DATABASE_URL="postgresql://user:pass@postgres:5432/db" npx prisma migrate deploy</code></pre>
        <br/>
        <li>CI/CD pipeline example:</li>
<pre><code class="language-yaml line-numbers"># GitHub Actions
- name: Run migrations
  env:
    DATABASE_URL: ${{ secrets.DIRECT_DATABASE_URL }}
  run: npx prisma migrate deploy</code></pre>
        <br/>
        <li>Docker Compose setup:</li>
<pre><code class="language-yaml line-numbers">services:
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"

  pgbouncer:
    image: pgbouncer/pgbouncer
    depends_on:
      - postgres
    ports:
      - "6432:6432"

  app:
    environment:
      DATABASE_URL: "postgresql://user:pass@pgbouncer:6432/db?pgbouncer=true"
      DIRECT_DATABASE_URL: "postgresql://user:pass@postgres:5432/db"</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-shadow-database">Shadow Database</h3>
<ol>

    <li>What Is a Shadow Database?</li>
    <br/>
    <ul>
        <li>A <b>shadow database</b> is a temporary database used by Prisma Migrate during development to detect schema drift and generate migrations.</li>
        <br/>
        <li>Purpose:</li>
        <ul>
            <li>validates migration files are correct</li>
            <li>detects manual schema changes</li>
            <li>ensures migrations can be applied cleanly</li>
            <li>generates accurate migration SQL</li>
        </ul>
        <br/>
        <li>Lifecycle:</li>
<pre><code class="language-plaintext line-numbers">1. Prisma creates shadow database
2. Applies all existing migrations
3. Compares result with your schema.prisma
4. Generates new migration if differences found
5. Drops shadow database</code></pre>
        <br/>
        <li>Only used during <code>prisma migrate dev</code>, not in production.</li>
    </ul>
    <br/><br/>


    <li>Automatic vs Manual Configuration</li>
    <br/>
    <ul>
        <li>Prisma automatically creates shadow databases when possible:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Database</th>
            <th>Automatic Shadow DB</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>✓ Yes (creates temporary file)</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
        <tr>
            <td>CockroachDB</td>
            <td>✓ Yes (if user has <code>CREATE DATABASE</code> permission)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Manual configuration required when:</li>
        <ul>
            <li>user lacks <code>CREATE DATABASE</code> permission</li>
            <li>using managed database services with restrictions</li>
            <li>cloud providers with strict permission models</li>
            <li>database connection via pooler</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Configuring Shadow Database</li>
    <br/>
    <ul>
        <li>Add <code>shadowDatabaseUrl</code> to schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"</code></pre>
        <br/>
        <li>Create shadow database manually:</li>
<pre><code class="language-sql line-numbers">-- PostgreSQL
CREATE DATABASE mydb_shadow;

-- MySQL
CREATE DATABASE mydb_shadow;</code></pre>
        <br/>
        <li>Shadow database must be empty - Prisma will manage its schema.</li>
    </ul>
    <br/><br/>


    <li>How Shadow Database Works</li>
    <br/>
    <ul>
        <li>Step-by-step process during <code>prisma migrate dev</code>:</li>
        <br/>
        <li><b>Step 1: Create or connect to shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Connecting to shadow database...</code></pre>
        <br/>
        <li><b>Step 2: Apply all existing migrations to shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Applying migration `20240101_init`
Applying migration `20240102_add_users`
...</code></pre>
        <br/>
        <li><b>Step 3: Compare shadow database schema with schema.prisma</b></li>
<pre><code class="language-plaintext line-numbers">Detecting schema drift...
Found differences:
  + Added table: posts
  + Added column: users.email</code></pre>
        <br/>
        <li><b>Step 4: Generate migration SQL for differences</b></li>
<pre><code class="language-sql line-numbers">-- CreateTable
CREATE TABLE "posts" (
  "id" SERIAL PRIMARY KEY,
  "title" TEXT NOT NULL
);

-- AlterTable
ALTER TABLE "users" ADD COLUMN "email" TEXT;</code></pre>
        <br/>
        <li><b>Step 5: Apply new migration to main database</b></li>
<pre><code class="language-plaintext line-numbers">Applying migration `20240103_add_posts`</code></pre>
        <br/>
        <li><b>Step 6: Drop shadow database (or keep for next run)</b></li>
<pre><code class="language-plaintext line-numbers">Cleaning up shadow database...</code></pre>
    </ul>
    <br/><br/>


    <li>Schema Drift Detection</li>
    <br/>
    <ul>
        <li>Shadow database enables detection of manual schema changes:</li>
        <br/>
        <li>Scenario: Developer manually adds column to database:</li>
<pre><code class="language-sql line-numbers">-- Manual change (NOT via Prisma)
ALTER TABLE users ADD COLUMN phone VARCHAR(20);</code></pre>
        <br/>
        <li>Running <code>prisma migrate dev</code> detects drift:</li>
<pre><code class="language-plaintext line-numbers">⚠️ We found changes that cannot be executed:

  • Added column `phone` on table `users`

These changes were made outside of Prisma Migrate.
Do you want to:
  1. Mark as applied (skip)
  2. Reset database
  3. Cancel</code></pre>
        <br/>
        <li>Without shadow database, Prisma couldn't detect these changes reliably.</li>
    </ul>
    <br/><br/>


    <li>Error Messages and Solutions</li>
    <br/>
    <ul>
        <li><b>Error: Cannot create shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Error: A migration failed when applied to the shadow database
Database error: permission denied to create database</code></pre>
        <li>Solution: Configure <code>shadowDatabaseUrl</code> manually:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}</code></pre>
        <br/>
        <li><b>Error: Shadow database not empty</b></li>
<pre><code class="language-plaintext line-numbers">Error: The shadow database contains tables that are not tracked by migrations</code></pre>
        <li>Solution: Drop all tables or recreate shadow database:</li>
<pre><code class="language-sql line-numbers">DROP DATABASE mydb_shadow;
CREATE DATABASE mydb_shadow;</code></pre>
        <br/>
        <li><b>Error: Cannot connect to shadow database</b></li>
<pre><code class="language-plaintext line-numbers">Error: Can't reach shadow database server</code></pre>
        <li>Solution: Verify shadow database URL and ensure database exists:</li>
<pre><code class="language-bash line-numbers">psql postgresql://user:pass@localhost:5432/mydb_shadow -c "SELECT 1"</code></pre>
        <br/>
        <li><b>Error: Shadow database URL same as main database</b></li>
<pre><code class="language-plaintext line-numbers">Error: The shadow database and main database cannot be the same</code></pre>
        <li>Solution: Use different database name:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"  # Different name</code></pre>
    </ul>
    <br/><br/>


    <li>Shadow Database with Docker</li>
    <br/>
    <ul>
        <li>Docker Compose example with shadow database:</li>
<pre><code class="language-yaml line-numbers">services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: mydb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Create shadow database on startup
      - ./init-shadow-db.sh:/docker-entrypoint-initdb.d/init-shadow-db.sh

volumes:
  postgres_data:</code></pre>
        <br/>
        <li>Initialization script:</li>
<pre><code class="language-bash line-numbers">#!/bin/bash
# init-shadow-db.sh
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    CREATE DATABASE mydb_shadow;
EOSQL</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers">DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb"
SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb_shadow"</code></pre>
    </ul>
    <br/><br/>


    <li>CI/CD Pipeline Configuration</li>
    <br/>
    <ul>
        <li>GitHub Actions example:</li>
<pre><code class="language-yaml line-numbers">name: Database Migrations

on: [push]

jobs:
  migrate:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Create shadow database
        run: |
          psql postgresql://postgres:postgres@localhost:5432/test_db \
            -c "CREATE DATABASE test_db_shadow;"
        env:
          PGPASSWORD: postgres

      - name: Run migrations
        run: npx prisma migrate dev
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          SHADOW_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db_shadow</code></pre>
    </ul>
    <br/><br/>


    <li>Different Databases for Main and Shadow</li>
    <br/>
    <ul>
        <li>Shadow database can be on different server:</li>
<pre><code class="language-plaintext line-numbers"># Main database on production server
DATABASE_URL="postgresql://user:pass@prod-server.com:5432/mydb"

# Shadow database on local machine
SHADOW_DATABASE_URL="postgresql://user:pass@localhost:5432/mydb_shadow"</code></pre>
        <br/>
        <li>Useful when:</li>
        <ul>
            <li>production database has strict permissions</li>
            <li>want to avoid any impact on production</li>
            <li>testing migrations locally before production</li>
        </ul>
        <br/>
        <li>Requirements:</li>
        <ul>
            <li>both databases must be same type (PostgreSQL, MySQL, etc.)</li>
            <li>both must be accessible from development machine</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Disabling Shadow Database</li>
    <br/>
    <ul>
        <li>Some scenarios don't require shadow database:</li>
        <br/>
        <li><b>MongoDB:</b> Schema-less, shadow database not applicable</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Use: prisma db push
// Migrations not supported for MongoDB</code></pre>
        <br/>
        <li>Use <code>--skip-seed</code> and <code>--skip-generate</code> flags if needed:</li>
<pre><code class="language-bash line-numbers">npx prisma migrate dev --skip-seed --skip-generate</code></pre>
    </ul>
    <br/><br/>


    <li>Testing Migrations with Shadow Database</li>
    <br/>
    <ul>
        <li>Verify migration before applying to production:</li>
<pre><code class="language-bash line-numbers"># 1. Create migration using shadow database
npx prisma migrate dev --name add_users

# 2. Review generated SQL
cat prisma/migrations/*/migration.sql

# 3. Test on separate staging database
DATABASE_URL=$STAGING_URL npx prisma migrate deploy

# 4. If successful, deploy to production
DATABASE_URL=$PRODUCTION_URL npx prisma migrate deploy</code></pre>
        <br/>
        <li>Dry run with shadow database:</li>
<pre><code class="language-bash line-numbers"># Create migration without applying to main database
npx prisma migrate dev --create-only

# Review and edit migration.sql if needed

# Apply when ready
npx prisma migrate dev</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-read-replicas">Read Replicas</h3>
<ol>

    <li>What Are Read Replicas?</li>
    <br/>
    <ul>
        <li>A <b>read replica</b> is a copy of your primary database that handles read operations only.</li>
        <br/>
        <li>Characteristics:</li>
        <ul>
            <li>primary handles all writes (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>)</li>
            <li>replicas handle reads (<code>SELECT</code>)</li>
            <li>data replicates from primary to replicas (asynchronous)</li>
            <li>replicas are eventually consistent</li>
        </ul>
        <br/>
        <li>Prisma 5.0+ includes native read replica support.</li>
    </ul>
    <br/><br/>


    <li>Typical read/write ratios that benefit from replicas:</li>
    <ul>
        <br/>
        <li>80/20 reads to writes - moderate benefit</li>
        <br/>
        <li>90/10 reads to writes - significant benefit</li>
        <br/>
        <li>95/5+ reads to writes - major benefit</li>
    </ul>
    <br/><br/>


    <li>Basic Configuration</li>
    <br/>
    <ul>
        <li>Configure read replicas in Prisma schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [prismaClientExtension()]
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["readReplicas"]
}</code></pre>
        <br/>
        <li>Environment variables:</li>
<pre><code class="language-plaintext line-numbers"># Primary database (writes)
DATABASE_URL="postgresql://user:pass@primary.example.com:5432/mydb"

# Read replicas
DATABASE_REPLICA_1="postgresql://user:pass@replica-1.example.com:5432/mydb"
DATABASE_REPLICA_2="postgresql://user:pass@replica-2.example.com:5432/mydb"</code></pre>
        <br/>
        <li>Initialize Prisma Client with replicas:</li>
<pre><code class="language-typescript line-numbers">import { PrismaClient } from '@prisma/client'
import { readReplicas } from '@prisma/extension-read-replicas'

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: [
      process.env.DATABASE_REPLICA_1!,
      process.env.DATABASE_REPLICA_2!
    ]
  })
)</code></pre>
    </ul>
    <br/><br/>


    <li>Using Read Replicas</li>
    <br/>
    <ul>
        <li>Explicit replica reads with <code>$replica()</code>:</li>
<pre><code class="language-typescript line-numbers">// Read from replica
const users = await prisma.user.findMany().$replica()

// Write to primary (default)
await prisma.user.create({
  data: { email: 'user@example.com' }
})</code></pre>
        <br/>
        <li>All writes automatically go to primary:</li>
<pre><code class="language-typescript line-numbers">// These ALWAYS use primary, no matter what
await prisma.user.create({ data: { email: 'new@example.com' } })
await prisma.user.update({ where: { id: 1 }, data: { name: 'Updated' } })
await prisma.user.delete({ where: { id: 1 } })
await prisma.user.upsert({ where: { id: 1 }, create: {...}, update: {...} })</code></pre>
        <br/>
        <li>Read operations default to primary unless using <code>$replica()</code>:</li>
<pre><code class="language-typescript line-numbers">// Uses primary (default)
const users = await prisma.user.findMany()

// Uses replica (explicit)
const users = await prisma.user.findMany().$replica()</code></pre>
    </ul>
    <br/><br/>


    <li>Load Balancing Strategies</li>
    <br/>
    <ul>
        <li>Prisma uses round-robin load balancing by default:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient().$extends(
  readReplicas({
    url: [
      process.env.DATABASE_REPLICA_1!,  // Request 1, 3, 5...
      process.env.DATABASE_REPLICA_2!   // Request 2, 4, 6...
    ]
  })
)</code></pre>
        <br/>
        <li>Custom load balancing:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient().$extends(
  readReplicas({
    url: async () =&gt; {
      // Custom logic: geography-based routing
      const userRegion = await getUserRegion()

      if (userRegion === 'us-east') {
        return process.env.DATABASE_REPLICA_US_EAST!
      } else if (userRegion === 'eu-west') {
        return process.env.DATABASE_REPLICA_EU_WEST!
      }

      return process.env.DATABASE_REPLICA_1!
    }
  })
)</code></pre>
        <br/>
        <li>Random selection strategy:</li>
<pre><code class="language-typescript line-numbers">const replicas = [
  process.env.DATABASE_REPLICA_1!,
  process.env.DATABASE_REPLICA_2!,
  process.env.DATABASE_REPLICA_3!
]

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: () => {
      const random = Math.floor(Math.random() * replicas.length)
      return replicas[random]
    }
  })
)</code></pre>
        <br/>
        <li>Weighted load balancing:</li>
<pre><code class="language-typescript line-numbers">const replicaWeights = [
  { url: process.env.DATABASE_REPLICA_1!, weight: 50 },  // 50%
  { url: process.env.DATABASE_REPLICA_2!, weight: 30 },  // 30%
  { url: process.env.DATABASE_REPLICA_3!, weight: 20 }   // 20%
]

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: () => {
      const total = replicaWeights.reduce((sum, r) => sum + r.weight, 0)
      let random = Math.random() * total

      for (const replica of replicaWeights) {
        random -= replica.weight
        if (random <= 0) return replica.url
      }

      return replicaWeights[0].url
    }
  })
)</code></pre>
    </ul>
    <br/><br/>


    <li>Replication Lag and Consistency</li>
    <br/>
    <ul>
        <li>Read replicas use <b>asynchronous replication</b> - data isn't immediately consistent.</li>
        <br/>
        <li>Typical replication lag:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Scenario</th>
            <th>Typical Lag</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Same datacenter</td>
            <td>10-100ms</td>
        </tr>
        <tr>
            <td>Same region</td>
            <td>100-500ms</td>
        </tr>
        <tr>
            <td>Cross-region</td>
            <td>500ms-5s</td>
        </tr>
        <tr>
            <td>Heavy load</td>
            <td>Can increase significantly</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Problem scenario:</li>
<pre><code class="language-typescript line-numbers">// Write to primary
await prisma.user.create({
  data: { id: 1, email: 'new@example.com' }
})

// Immediately read from replica - may not exist yet!
const user = await prisma.user.findUnique({
  where: { id: 1 }
}).$replica()

console.log(user) // Might be null due to replication lag</code></pre>
        <br/>
        <li>Solution: Read from primary after writes:</li>
<pre><code class="language-typescript line-numbers">// Write to primary
await prisma.user.create({
  data: { id: 1, email: 'new@example.com' }
})

// Read from primary (not replica) to ensure consistency
const user = await prisma.user.findUnique({
  where: { id: 1 }
})

console.log(user) // Always exists</code></pre>
    </ul>
    <br/><br/>


    <li>Read-After-Write Consistency Pattern</li>
    <br/>
    <ul>
        <li>Ensure users see their own writes immediately:</li>
<pre><code class="language-typescript line-numbers">async function createAndReturnUser(email: string) {
  // Write to primary
  const newUser = await prisma.user.create({
    data: { email }
  })

  // Return from primary, not replica
  return newUser
}

async function updateAndReturnUser(id: number, data: any) {
  // Update on primary
  const updated = await prisma.user.update({
    where: { id },
    data
  })

  // Return from primary
  return updated
}</code></pre>
        <br/>
        <li>Session-based routing:</li>
<pre><code class="language-typescript line-numbers">// Track recent writes per session
const recentWrites = new Map<string, number>()

async function getUserWithConsistency(userId: number, sessionId: string) {
  const lastWrite = recentWrites.get(sessionId) || 0
  const timeSinceWrite = Date.now() - lastWrite

  // If wrote within last 5 seconds, use primary
  if (timeSinceWrite < 5000) {
    return prisma.user.findUnique({ where: { id: userId } })
  }

  // Otherwise use replica
  return prisma.user.findUnique({ where: { id: userId } }).$replica()
}

async function updateUser(userId: number, data: any, sessionId: string) {
  recentWrites.set(sessionId, Date.now())
  return prisma.user.update({ where: { id: userId }, data })
}</code></pre>
    </ul>
    <br/><br/>


    <li>Transactions and Read Replicas</li>
    <br/>
    <ul>
        <li>Transactions always use primary database:</li>
<pre><code class="language-typescript line-numbers">// All operations in transaction use primary
await prisma.$transaction(async (tx) => {
  const user = await tx.user.findUnique({ where: { id: 1 } })  // Primary
  await tx.post.create({ data: { userId: 1, title: 'Post' } }) // Primary

  // Cannot use $replica() inside transactions
  // This would throw an error:
  // await tx.user.findMany().$replica()
})</code></pre>
        <br/>
        <li>Sequential transactions:</li>
<pre><code class="language-typescript line-numbers">const [user, posts] = await prisma.$transaction([
  prisma.user.findUnique({ where: { id: 1 } }),     // Primary
  prisma.post.findMany({ where: { userId: 1 } })    // Primary
  // All queries in $transaction use primary
])</code></pre>
        <br/>
        <li>Mix transactions with replica reads:</li>
<pre><code class="language-typescript line-numbers">// Write operation in transaction
await prisma.$transaction(async (tx) => {
  await tx.user.update({
    where: { id: 1 },
    data: { credits: { increment: 100 } }
  })
})

// Later, read from replica if consistency not critical
const allUsers = await prisma.user.findMany().$replica()</code></pre>
    </ul>
    <br/><br/>


    <li>Geographic Distribution</li>
    <br/>
    <ul>
        <li>Deploy replicas close to users for lower latency:</li>
<pre><code class="language-plaintext line-numbers">Primary: us-east-1 (Virginia)
Replica 1: us-west-2 (Oregon)
Replica 2: eu-west-1 (Ireland)
Replica 3: ap-southeast-1 (Singapore)</code></pre>
        <br/>
        <li>Region-based routing:</li>
<pre><code class="language-typescript line-numbers">const REPLICA_BY_REGION: Record<string, string> = {
  'us-east': process.env.DATABASE_REPLICA_US_EAST!,
  'us-west': process.env.DATABASE_REPLICA_US_WEST!,
  'eu': process.env.DATABASE_REPLICA_EU!,
  'asia': process.env.DATABASE_REPLICA_ASIA!
}

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: async () => {
      const region = await detectUserRegion()
      return REPLICA_BY_REGION[region] || process.env.DATABASE_URL!
    }
  })
)

async function detectUserRegion(): Promise<string> {
  // Detect from request headers, IP geolocation, etc.
  const cloudflareCountry = request.headers.get('cf-ipcountry')

  if (['US', 'CA', 'MX'].includes(cloudflareCountry)) {
    return 'us-east'
  } else if (['GB', 'FR', 'DE'].includes(cloudflareCountry)) {
    return 'eu'
  } else if (['JP', 'SG', 'AU'].includes(cloudflareCountry)) {
    return 'asia'
  }

  return 'us-east'
}</code></pre>
    </ul>
    <br/><br/>


    <li>Monitoring and Observability</li>
    <br/>
    <ul>
        <li>Track which database handles each query:</li>
<pre><code class="language-typescript line-numbers">const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' }
  ]
}).$extends(
  readReplicas({
    url: [
      process.env.DATABASE_REPLICA_1!,
      process.env.DATABASE_REPLICA_2!
    ]
  })
)

prisma.$on('query', (e) => {
  console.log({
    query: e.query,
    duration: e.duration,
    target: e.target // 'primary' or replica URL
  })
})</code></pre>
        <br/>
        <li>Count queries per database:</li>
<pre><code class="language-typescript line-numbers">const queryStats = {
  primary: 0,
  replica: 0
}

prisma.$on('query', (e) => {
  if (e.target === process.env.DATABASE_URL) {
    queryStats.primary++
  } else {
    queryStats.replica++
  }
})

// Expose metrics endpoint
app.get('/metrics', (req, res) => {
  res.json({
    queries: queryStats,
    ratio: {
      reads: queryStats.replica,
      writes: queryStats.primary
    }
  })
})</code></pre>
        <br/>
        <li>Alert on replica failures:</li>
<pre><code class="language-typescript line-numbers">prisma.$on('error', (e) => {
  if (e.message.includes('replica')) {
    // Alert: replica unavailable
    notifyOps('Replica database unavailable', e)

    // Prisma automatically falls back to primary
  }
})</code></pre>
    </ul>
    <br/><br/>



    <li>Testing with Read Replicas</li>
    <br/>
    <ul>
        <li>Test environment without replicas:</li>
<pre><code class="language-typescript line-numbers">// lib/prisma.ts
const prisma = new PrismaClient()

// Only add read replicas in production
const client = process.env.NODE_ENV === 'production'
  ? prisma.$extends(
      readReplicas({
        url: [
          process.env.DATABASE_REPLICA_1!,
          process.env.DATABASE_REPLICA_2!
        ]
      })
    )
  : prisma

export { client as prisma }</code></pre>
        <br/>
        <li>Simulate replication lag in tests:</li>
<pre><code class="language-typescript line-numbers">async function testReplicationLag() {
  // Write to primary
  await prisma.user.create({
    data: { id: 999, email: 'test@example.com' }
  })

  // Simulate replication lag
  await new Promise(resolve => setTimeout(resolve, 100))

  // Try reading from replica
  const user = await prisma.user.findUnique({
    where: { id: 999 }
  }).$replica()

  // May be null due to lag
  if (!user) {
    console.log('Replication lag detected')
  }
}</code></pre>
        <br/>
        <li>Mock replica for unit tests:</li>
<pre><code class="language-typescript line-numbers">// test/setup.ts
jest.mock('@prisma/extension-read-replicas', () => ({
  readReplicas: () => ({
    // All replica reads use primary in tests
    $replica: () => prisma
  })
}))</code></pre>
    </ul>
    <br/><br/>


    <li>Common Pitfalls</li>
    <br/>
    <ul>
        <li><b>Reading immediately after write:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - may not see new data
await prisma.user.create({ data: { email: 'new@example.com' } })
const user = await prisma.user.findFirst({
  where: { email: 'new@example.com' }
}).$replica() // May return null

// ✓ Good - read from primary
await prisma.user.create({ data: { email: 'new@example.com' } })
const user = await prisma.user.findFirst({
  where: { email: 'new@example.com' }
}) // Uses primary</code></pre>
        <br/>
        <li><b>Using replicas for financial data:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - account balance must be accurate
const balance = await prisma.account.findUnique({
  where: { userId }
}).$replica() // Could show stale balance

// ✓ Good - always use primary for critical data
const balance = await prisma.account.findUnique({
  where: { userId }
})</code></pre>
        <br/>
        <li><b>Not handling replica failures:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - no error handling
const users = await prisma.user.findMany().$replica()

// ✓ Good - Prisma handles failover automatically
// But monitor and alert on failures
const users = await prisma.user.findMany().$replica()
// Automatically falls back to primary if replica fails</code></pre>
        <br/>
        <li><b>Over-using replicas:</b></li>
<pre><code class="language-typescript line-numbers">// ❌ Bad - using replica for everything
const session = await prisma.session.findUnique({
  where: { token }
}).$replica() // Session data should be fresh

const notification = await prisma.notification.findFirst({
  where: { userId, read: false }
}).$replica() // Real-time data needs consistency

// ✓ Good - use primary for real-time/critical data
const session = await prisma.session.findUnique({ where: { token } })
const notification = await prisma.notification.findFirst({
  where: { userId, read: false }
})</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-schema-overview">Prisma Schema Overview</h3>
<ol>

    <li>What Is the Prisma Schema?</li>
    <br/>
    <ul>
        <li>The Prisma schema is a declarative configuration file that defines:</li>
        <ul>
            <li>database connection</li>
            <li>Prisma Client generator</li>
            <li>data models (tables/collections)</li>
            <li>relationships between models</li>
            <li>field types and constraints</li>
        </ul>
        <br/>
        <li>Single source of truth for database structure.</li>
        <br/>
        <li>File location: <code>prisma/schema.prisma</code></li>
        <br/>
        <li>Uses Prisma Schema Language (PSL), not SQL or a programming language.</li>
    </ul>
    <br/><br/>


    <li>Schema File Structure</li>
    <br/>
    <ul>
        <li>A complete schema has three main blocks:</li>
<pre><code class="language-prisma line-numbers">// 1. Data source - database connection
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 2. Generator - what to generate
generator client {
  provider = "prisma-client-js"
}

// 3. Data models - your tables/collections
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li>Order of blocks doesn't matter, but conventionally it is datasource → generator → models.</li>
    </ul>
    <br/><br/>


    <li>Data Source Configuration</li>
    <br/>
    <ul>
        <li>Defines database connection:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}</code></pre>
        <br/>
        <li>Supported providers:</li>
<table>
    <thead>
        <tr>
            <th>Provider</th>
            <th>Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>PostgreSQL</td>
            <td><code>"postgresql"</code></td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td><code>"mysql"</code></td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td><code>"sqlite"</code></td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td><code>"sqlserver"</code></td>
        </tr>
        <tr>
            <td>MongoDB</td>
            <td><code>"mongodb"</code></td>
        </tr>
        <tr>
            <td>CockroachDB</td>
            <td><code>"cockroachdb"</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Additional datasource options:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DIRECT_DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  schemas           = ["public", "auth"]
}</code></pre>
    </ul>
    <br/><br/>


    <li>Generator Configuration</li>
    <br/>
    <ul>
        <li>Defines what Prisma generates:</li>
<pre><code class="language-prisma line-numbers">generator client {
  provider = "prisma-client-js"
}</code></pre>
        <br/>
        <li>Common generator options:</li>
<pre><code class="language-prisma line-numbers">generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma-client"
  previewFeatures = ["readReplicas", "fullTextSearch"]
  binaryTargets   = ["native", "rhel-openssl-1.0.x"]
  engineType      = "binary"
}</code></pre>
        <br/>
<table>
    <thead>
        <tr>
            <th>Option</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>provider</code></td>
            <td>Generator to use (usually <code>prisma-client-js</code>)</td>
        </tr>
        <tr>
            <td><code>output</code></td>
            <td>Custom output location for generated client</td>
        </tr>
        <tr>
            <td><code>previewFeatures</code></td>
            <td>Array of preview features to enable</td>
        </tr>
        <tr>
            <td><code>binaryTargets</code></td>
            <td>Target platforms for Prisma engines</td>
        </tr>
        <tr>
            <td><code>engineType</code></td>
            <td><code>"binary"</code> or <code>"library"</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Multiple generators:</li>
<pre><code class="language-prisma line-numbers">generator client {
  provider = "prisma-client-js"
}

generator docs {
  provider = "prisma-docs-generator"
}

generator erd {
  provider = "prisma-erd-generator"
}</code></pre>
    </ul>
    <br/><br/>


    <li>Model Definition</li>
    <br/>
    <ul>
        <li>Models represent database tables (SQL) or collections (MongoDB):</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  age       Int
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}</code></pre>
        <br/>
        <li>Model naming conventions:</li>
        <ul>
            <li>singular PascalCase (e.g., <code>User</code>, not <code>users</code>)</li>
            <li>Prisma automatically pluralizes for database table names</li>
            <li>use <code>@@map</code> to override table name</li>
        </ul>
        <br/>
        <li>Custom table name:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id
  email String

  @@map("custom_users_table")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Field Types</li>
    <ul>
    <br/>
        <li>Scalar types:</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Prisma Type</th>
            <th>PostgreSQL</th>
            <th>MySQL</th>
            <th>SQLite</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>String</code></td>
            <td>text, varchar</td>
            <td>varchar, text</td>
            <td>text</td>
        </tr>
        <tr>
            <td><code>Int</code></td>
            <td>integer</td>
            <td>int</td>
            <td>integer</td>
        </tr>
        <tr>
            <td><code>BigInt</code></td>
            <td>bigint</td>
            <td>bigint</td>
            <td>integer</td>
        </tr>
        <tr>
            <td><code>Float</code></td>
            <td>double precision</td>
            <td>double</td>
            <td>real</td>
        </tr>
        <tr>
            <td><code>Decimal</code></td>
            <td>decimal</td>
            <td>decimal</td>
            <td>N/A</td>
        </tr>
        <tr>
            <td><code>Boolean</code></td>
            <td>boolean</td>
            <td>tinyint(1)</td>
            <td>integer</td>
        </tr>
        <tr>
            <td><code>DateTime</code></td>
            <td>timestamp</td>
            <td>datetime</td>
            <td>numeric</td>
        </tr>
        <tr>
            <td><code>Json</code></td>
            <td>jsonb</td>
            <td>json</td>
            <td>text</td>
        </tr>
        <tr>
            <td><code>Bytes</code></td>
            <td>bytea</td>
            <td>longblob</td>
            <td>blob</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example with different types:</li>
<pre><code class="language-prisma line-numbers">model Product {
  id          Int      @id @default(autoincrement())
  name        String
  price       Decimal  @db.Decimal(10, 2)
  quantity    Int
  inStock     Boolean  @default(true)
  metadata    Json?
  image       Bytes?
  releaseDate DateTime
  views       BigInt   @default(0)
  rating      Float?
}</code></pre>
        <br/>
        <li>Field modifiers:</li>
<table>
    <thead>
        <tr>
            <th>Modifier</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>?</code></td>
            <td>Optional (nullable)</td>
            <td><code>name String?</code></td>
        </tr>
        <tr>
            <td><code>[]</code></td>
            <td>Array/List</td>
            <td><code>tags String[]</code></td>
        </tr>
        <tr>
            <td>none</td>
            <td>Required</td>
            <td><code>email String</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Arrays example:</li>
<pre><code class="language-prisma line-numbers">model Article {
  id        Int      @id @default(autoincrement())
  title     String
  tags      String[]
  viewCount Int[]
}</code></pre>
    </ul>
    <br/><br/>


    <li>Field Attributes</li>
    <br/>
    <ul>
        <li>Attributes modify field behavior using <code>@</code>:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  username  String   @db.VarChar(50)
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@unique([username, email])
}</code></pre>
        <br/>
        <li>Common field attributes:</li>
<table>
    <thead>
        <tr>
            <th>Attribute</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@id</code></td>
            <td>Primary key</td>
        </tr>
        <tr>
            <td><code>@default()</code></td>
            <td>Default value</td>
        </tr>
        <tr>
            <td><code>@unique</code></td>
            <td>Unique constraint</td>
        </tr>
        <tr>
            <td><code>@relation()</code></td>
            <td>Define relationship</td>
        </tr>
        <tr>
            <td><code>@map()</code></td>
            <td>Custom column name</td>
        </tr>
        <tr>
            <td><code>@db.</code></td>
            <td>Native database type</td>
        </tr>
        <tr>
            <td><code>@updatedAt</code></td>
            <td>Auto-update timestamp</td>
        </tr>
        <tr>
            <td><code>@ignore</code></td>
            <td>Exclude from Prisma Client</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Default value functions:</li>
<pre><code class="language-prisma line-numbers">model Example {
  id         String   @id @default(uuid())
  autoId     Int      @default(autoincrement())
  timestamp  DateTime @default(now())
  randomNum  Int      @default(dbgenerated("floor(random() * 100)"))
  constant   String   @default("PENDING")
  boolean    Boolean  @default(true)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Block Attributes</li>
    <br/>
    <ul>
        <li>Block attributes apply to entire model using <code>@@</code>:</li>
<pre><code class="language-prisma line-numbers">model User {
  id        Int      @id @default(autoincrement())
  email     String
  firstName String
  lastName  String
  age       Int
  city      String

  @@unique([email, firstName])
  @@index([city])
  @@index([lastName, firstName])
  @@map("users_table")
}</code></pre>
        <br/>
        <li>Common block attributes:</li>
<table>
    <thead>
        <tr>
            <th>Attribute</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>@@id([])</code></td>
            <td>Composite primary key</td>
        </tr>
        <tr>
            <td><code>@@unique([])</code></td>
            <td>Composite unique constraint</td>
        </tr>
        <tr>
            <td><code>@@index([])</code></td>
            <td>Database index</td>
        </tr>
        <tr>
            <td><code>@@map()</code></td>
            <td>Custom table name</td>
        </tr>
        <tr>
            <td><code>@@schema()</code></td>
            <td>PostgreSQL schema</td>
        </tr>
        <tr>
            <td><code>@@ignore</code></td>
            <td>Exclude model from Prisma Client</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Composite primary key:</li>
<pre><code class="language-prisma line-numbers">model UserRole {
  userId Int
  roleId Int

  user User @relation(fields: [userId], references: [id])
  role Role @relation(fields: [roleId], references: [id])

  @@id([userId, roleId])
}</code></pre>
        <br/>
        <li>Multiple indexes:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String
  published Boolean
  authorId  Int

  @@index([authorId])
  @@index([published, authorId])
  @@index([title(ops: raw("gin_trgm_ops"))], type: Gin)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Relations</li>
    <br/>
    <ul>
        <li><b>One-to-Many:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  posts Post[]  // Relation field (not in database)
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int    // Foreign key
  author   User   @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li><b>One-to-One:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  userId Int    @unique
  user   User   @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li><b>Many-to-Many (implicit):</b></li>
<pre><code class="language-prisma line-numbers">model Post {
  id         Int        @id @default(autoincrement())
  title      String
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

// Prisma creates join table automatically: _CategoryToPost</code></pre>
        <br/>
        <li><b>Many-to-Many (explicit):</b></li>
<pre><code class="language-prisma line-numbers">model Post {
  id                 Int                  @id @default(autoincrement())
  title              String
  postCategories     PostCategory[]
}

model Category {
  id                 Int                  @id @default(autoincrement())
  name               String
  postCategories     PostCategory[]
}

model PostCategory {
  postId     Int
  categoryId Int
  assignedAt DateTime @default(now())

  post       Post     @relation(fields: [postId], references: [id])
  category   Category @relation(fields: [categoryId], references: [id])

  @@id([postId, categoryId])
}</code></pre>
        <br/>
        <li><b>Self-relations:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id         Int    @id @default(autoincrement())
  name       String
  invitedBy  Int?
  inviter    User?  @relation("UserInvites", fields: [invitedBy], references: [id])
  invitees   User[] @relation("UserInvites")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Relation Actions</li>
    <br/>
    <ul>
        <li>Define behavior when referenced record is deleted/updated:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}</code></pre>
        <br/>
        <li>Available actions:</li>
<table>
    <thead>
        <tr>
            <th>Action</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Cascade</code></td>
            <td>Delete/update related records</td>
        </tr>
        <tr>
            <td><code>Restrict</code></td>
            <td>Prevent if related records exist</td>
        </tr>
        <tr>
            <td><code>NoAction</code></td>
            <td>Database default behavior</td>
        </tr>
        <tr>
            <td><code>SetNull</code></td>
            <td>Set foreign key to NULL</td>
        </tr>
        <tr>
            <td><code>SetDefault</code></td>
            <td>Set foreign key to default value</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Examples:</li>
<pre><code class="language-prisma line-numbers">// Delete user → delete all their posts
author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

// Delete user → set posts.authorId to NULL
author User @relation(fields: [authorId], references: [id], onDelete: SetNull)

// Prevent user deletion if posts exist
author User @relation(fields: [authorId], references: [id], onDelete: Restrict)</code></pre>
    </ul>
    <br/><br/>


    <li>Enums</li>
    <br/>
    <ul>
        <li>Define enumeration types:</li>
<pre><code class="language-prisma line-numbers">enum Role {
  USER
  ADMIN
  MODERATOR
}

model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  role  Role   @default(USER)
}</code></pre>
        <br/>
        <li>With custom database values:</li>
<pre><code class="language-prisma line-numbers">enum Status {
  PENDING   @map("pending")
  APPROVED  @map("approved")
  REJECTED  @map("rejected")
}

model Application {
  id     Int    @id
  status Status @default(PENDING)
}</code></pre>
        <br/>
        <li>Array of enums:</li>
<pre><code class="language-prisma line-numbers">enum Permission {
  READ
  WRITE
  DELETE
}

model User {
  id          Int          @id
  permissions Permission[]
}</code></pre>
        <br/>
        <li>Note: Not supported in SQLite (use String instead).</li>
    </ul>
    <br/><br/>


    <li>Native Database Types</li>
    <br/>
    <ul>
        <li>Specify exact database column type using <code>@db.</code>:</li>
        <br/>
        <li><b>PostgreSQL:</b></li>
<pre><code class="language-prisma line-numbers">model Product {
  id          Int      @id
  name        String   @db.VarChar(255)
  description String   @db.Text
  price       Decimal  @db.Decimal(10, 2)
  metadata    Json     @db.JsonB
  tags        String[] @db.VarChar(100)
  count       BigInt   @db.BigInt
}</code></pre>
        <br/>
        <li><b>MySQL:</b></li>
<pre><code class="language-prisma line-numbers">model Product {
  id          Int     @id
  name        String  @db.VarChar(255)
  description String  @db.Text
  price       Decimal @db.Decimal(10, 2)
  metadata    Json
  tiny        Int     @db.TinyInt
  medium      String  @db.MediumText
}</code></pre>
        <br/>
        <li><b>Common native types:</b></li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>PostgreSQL</th>
            <th>MySQL</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Variable string</td>
            <td><code>@db.VarChar(n)</code></td>
            <td><code>@db.VarChar(n)</code></td>
        </tr>
        <tr>
            <td>Long text</td>
            <td><code>@db.Text</code></td>
            <td><code>@db.Text</code></td>
        </tr>
        <tr>
            <td>Decimal</td>
            <td><code>@db.Decimal(p,s)</code></td>
            <td><code>@db.Decimal(p,s)</code></td>
        </tr>
        <tr>
            <td>Timestamp</td>
            <td><code>@db.Timestamp(p)</code></td>
            <td><code>@db.DateTime(p)</code></td>
        </tr>
        <tr>
            <td>JSON</td>
            <td><code>@db.JsonB</code></td>
            <td><code>@db.Json</code></td>
        </tr>
        <tr>
            <td>UUID</td>
            <td><code>@db.Uuid</code></td>
            <td>N/A</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Comments and Documentation</li>
    <br/>
    <ul>
        <li>Single-line comments:</li>
<pre><code class="language-prisma line-numbers">model User {
  // Primary identifier
  id    Int    @id @default(autoincrement())

  // Unique email for authentication
  email String @unique

  name  String? // Optional display name
}</code></pre>
        <br/>
        <li>Multi-line comments:</li>
<pre><code class="language-prisma line-numbers">/*
 * User model represents application users
 * Supports authentication and profile management
 */
model User {
  id    Int    @id
  email String @unique
}</code></pre>
        <br/>
        <li>Documentation comments (appear in generated types):</li>
<pre><code class="language-prisma line-numbers">/// User account information
model User {
  id    Int    @id @default(autoincrement())

  /// User's email address (used for login)
  email String @unique

  /// Optional display name
  name  String?
}

/// User role enumeration
enum Role {
  /// Standard user permissions
  USER

  /// Administrator with full access
  ADMIN
}</code></pre>
        <br/>
        <li>Documentation comments use <code>///</code> and show in IDE tooltips and generated code.</li>
    </ul>
    <br/><br/>


    <li>Unsupported Features</li>
    <br/>
    <ul>
        <li>Mark models/fields to ignore:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id
  email String

  /// @ignore: deprecated field
  oldField String @ignore
}

/// @ignore: legacy table not used by application
model LegacyData {
  id Int @id

  @@ignore
}</code></pre>
        <br/>
        <li>Ignored models/fields:</li>
        <ul>
            <li>excluded from Prisma Client</li>
            <li>not validated by Prisma</li>
            <li>preserved in database</li>
            <li>useful for gradual migration</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Multi-Schema Support</li>
    <br/>
    <ul>
        <li>PostgreSQL supports multiple schemas:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public", "auth", "analytics"]
}

model User {
  id    Int    @id
  email String

  @@schema("auth")
}

model Post {
  id    Int    @id
  title String

  @@schema("public")
}

model Event {
  id   Int      @id
  data Json

  @@schema("analytics")
}</code></pre>
        <br/>
        <li>Models can reference across schemas:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id
  posts Post[]

  @@schema("auth")
}

model Post {
  id       Int  @id
  authorId Int
  author   User @relation(fields: [authorId], references: [id])

  @@schema("public")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Views</li>
    <br/>
    <ul>
        <li>Define database views as models:</li>
<pre><code class="language-prisma line-numbers">/// Database view for user statistics
view UserStats {
  userId     Int    @unique
  postCount  Int
  totalViews BigInt

  @@map("user_stats_view")
}</code></pre>
        <br/>
        <li>Views are read-only:</li>
<pre><code class="language-typescript line-numbers">// ✓ Can read from views
const stats = await prisma.userStats.findMany()

// ✗ Cannot write to views
await prisma.userStats.create({ data: {} }) // Error</code></pre>
        <br/>
        <li>Create view manually in database:</li>
<pre><code class="language-sql line-numbers">CREATE VIEW user_stats_view AS
SELECT
  u.id as userId,
  COUNT(p.id) as postCount,
  SUM(p.views) as totalViews
FROM users u
LEFT JOIN posts p ON p.author_id = u.id
GROUP BY u.id;</code></pre>
    </ul>
    <br/><br/>


    <li>Schema Organization</li>
    <br/>
    <ul>
        <li>Organize large schemas with comments:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================
// Authentication Models
// ============================================

model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  password String
  sessions Session[]
}

model Session {
  id        String   @id @default(uuid())
  userId    Int
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

// ============================================
// Content Models
// ============================================

model Post {
  id       Int      @id @default(autoincrement())
  title    String
  content  String
  authorId Int
}

model Comment {
  id      Int    @id @default(autoincrement())
  text    String
  postId  Int
  userId  Int
}

// ============================================
// E-commerce Models
// ============================================

model Product {
  id    Int     @id @default(autoincrement())
  name  String
  price Decimal
}

model Order {
  id     Int      @id @default(autoincrement())
  total  Decimal
  userId Int
}</code></pre>
        <br/>
        <li>Consider splitting very large schemas:</li>
<pre><code class="language-plaintext line-numbers">prisma/
├── schema.prisma           # Main schema (datasource + generator)
├── schema/
│   ├── auth.prisma        # Authentication models
│   ├── content.prisma     # Content models
│   └── ecommerce.prisma   # E-commerce models</code></pre>
        <br/>
        <li>Note: Prisma doesn't officially support multiple schema files yet, but tools like <code>prisma-merge</code> can help.</li>
    </ul>
    <br/><br/>


    <li>Schema Validation</li>
    <br/>
    <ul>
        <li>Validate schema without database connection:</li>
<pre><code class="language-bash line-numbers">npx prisma validate</code></pre>
        <br/>
        <li>Format schema file:</li>
<pre><code class="language-bash line-numbers">npx prisma format</code></pre>
        <br/>
        <li>Common validation errors:</li>
<table>
    <thead>
        <tr>
            <th>Error</th>
            <th>Cause</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Missing <code>@relation</code></td>
            <td>Ambiguous relation, needs explicit definition</td>
        </tr>
        <tr>
            <td>Invalid field type</td>
            <td>Unsupported type for database provider</td>
        </tr>
        <tr>
            <td>Missing required field</td>
            <td>Non-optional field without default value</td>
        </tr>
        <tr>
            <td>Duplicate model name</td>
            <td>Two models with same name</td>
        </tr>
        <tr>
            <td>Invalid attribute</td>
            <td>Attribute not supported for field type</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Complete Schema Example</li>
    <br/>
    <ul>
        <li>Real-world blog application schema:</li>
<pre><code class="language-prisma line-numbers">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  AUTHOR
  ADMIN
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  username      String    @unique @db.VarChar(30)
  passwordHash  String
  role          Role      @default(USER)
  posts         Post[]
  comments      Comment[]
  profile       Profile?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([email])
  @@map("users")
}

model Profile {
  id       Int     @id @default(autoincrement())
  bio      String? @db.Text
  avatar   String?
  website  String?
  userId   Int     @unique
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Post {
  id          Int        @id @default(autoincrement())
  title       String     @db.VarChar(200)
  slug        String     @unique
  content     String     @db.Text
  excerpt     String?    @db.VarChar(500)
  coverImage  String?
  status      PostStatus @default(DRAFT)
  published   Boolean    @default(false)
  publishedAt DateTime?
  views       Int        @default(0)
  authorId    Int
  author      User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments    Comment[]
  tags        Tag[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([slug])
  @@index([authorId])
  @@index([published, publishedAt])
  @@map("posts")
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String   @db.Text
  postId    Int
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentId  Int?
  parent    Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([userId])
  @@map("comments")
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique @db.VarChar(50)
  slug  String @unique
  posts Post[]

  @@map("tags")
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="prisma-relationships">Understanding Relationships in Prisma</h3>
<ol>

    <li>What Are Foreign Keys and Relationships?</li>
    <br/>
    <ul>
        <li>A <b>foreign key</b> is a field that references the primary key of another table.</li>
        <br/>
        <li>In traditional SQL:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE posts (
  id INT PRIMARY KEY,
  title VARCHAR(200),
  author_id INT,  -- This is the foreign key
  FOREIGN KEY (author_id) REFERENCES users(id)
);</code></pre>
        <li>Prisma on the other hand, represents this relationship in the schema file, not with raw SQL.</li>
    </ul>
    <br/><br/>


    <li>The Two Sides of Every Relationship</li>
    <br/>
    <ul>
        <li>Every relationship in Prisma has <u>two</u> sides:</li>
        <br/>
        <li><b>Side 1: The field that stores the foreign key (the ID)</b></li>
        <ul>
            <li>This is a regular field that exists in the database</li>
            <li>Example: <code>authorId Int</code></li>
            <li>This actually stores a number in the database</li>
        </ul>
        <br/>
        <li><b>Side 2: The relation field (the connection)</b></li>
        <ul>
            <li>This does NOT exist in the database as a column</li>
            <li>Example: <code>author User</code></li>
            <li>This is virtual - Prisma uses it to navigate relationships</li>
        </ul>
        <br/>
        <li>Think of it like this:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int    // Real column in database: stores user ID
  author   User   @relation(fields: [authorId], references: [id])
                  // Virtual: lets you access the User object
}</code></pre>
        <br/>
        <li>The database table <code>posts</code> has columns: <code>id</code>, <code>title</code>, <code>authorId</code></li>
        <br/>
        <li>It does NOT have a column called <code>author</code> - that's just for Prisma to use.</li>
    </ul>
    <br/><br/>


    <li>One-to-Many: The Most Common Relationship</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> One user can have many posts, but each post belongs to one user.</li>
        <br/>
        <li>Complete example:</li>
<pre><code class="language-prisma line-numbers">model User {
  id    Int    @id @default(autoincrement())
  name  String
  email String @unique
  posts Post[]  // Array because one user has MANY posts
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  content  String
  authorId Int    // Foreign key: stores which user owns this post
  author   User   @relation(fields: [authorId], references: [id])
}</code></pre>
        <br/>
        <li>Breaking down the <code>@relation</code> attribute:</li>
<table>
    <thead>
        <tr>
            <th>Part</th>
            <th>Meaning</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fields: [authorId]</code></td>
            <td>This model's field that stores the foreign key</td>
        </tr>
        <tr>
            <td><code>references: [id]</code></td>
            <td>The field in the User model being referenced</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>"The <code>authorId</code> field references the <code>id</code> field in User"</li>
        <br/>
        <li>Database structure created:</li>
<pre><code class="language-sql line-numbers">-- users table
id   | name      | email
-----|-----------|------------------
1    | Alice     | alice@example.com
2    | Bob       | bob@example.com

-- posts table
id   | title          | content        | authorId
-----|----------------|----------------|----------
1    | First Post     | Hello world    | 1
2    | Second Post    | More content   | 1
3    | Bob's Post     | Hi there       | 2</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Get posts WITH their author information
const posts = await prisma.post.findMany({
  include: {
    author: true  // Include the related User
  }
})

// Result:
// [
//   {
//     id: 1,
//     title: "First Post",
//     authorId: 1,
//     author: { id: 1, name: "Alice", email: "alice@example.com" }
//   },
//   ...
// ]

// Get user WITH all their posts
const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: true  // Include all related Posts
  }
})

// Result:
// {
//   id: 1,
//   name: "Alice",
//   posts: [
//     { id: 1, title: "First Post", ... },
//     { id: 2, title: "Second Post", ... }
//   ]
// }</code></pre>
    </ul>
    <br/><br/>


    <li>Which Side Gets the Foreign Key?</li>
    <br/>
    <ul>
        <li><b>Rule:</b> The "many" side stores the foreign key.</li>
        <br/>
        <li>Visualizing the relationship:</li>
<pre><code class="language-plaintext line-numbers">User (ONE)                    Post (MANY)
-----------                   -----------
id                            id
name                          title
email                         authorId ← Foreign key here!
posts [] ← Virtual            author ← Virtual</code></pre>
        <br/>
        <li>Why? Because many posts can point to one user.</li>
        <br/>
        <li>If we put it on User, we could only store ONE post ID (not many).</li>
        <br/>
        <li>Another example:</li>
<pre><code class="language-prisma line-numbers">// One category can have many products
model Category {
  id       Int       @id @default(autoincrement())
  name     String
  products Product[] // Virtual: "this category has many products"
}

model Product {
  id         Int      @id @default(autoincrement())
  name       String
  categoryId Int      // Real: stores the category ID
  category   Category @relation(fields: [categoryId], references: [id])
                      // Virtual: "this product belongs to a category"
}</code></pre>
        <br/>
        <li>Remember: Foreign key goes on the <u>many</u> side, array goes on the <u>one</u> side.</li>
    </ul>
    <br/><br/>


    <li>One-to-One Relationships</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> One user has exactly one profile.</li>
        <br/>
        <li>Complete example:</li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  profile Profile? // Optional (?) because user might not have profile yet
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  avatar String?
  userId Int    @unique  // Must be @unique for one-to-one!
  user   User   @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li>Key difference from one-to-many:</li>
<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>One-to-Many</th>
            <th>One-to-One</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Foreign key</td>
            <td><code>authorId Int</code></td>
            <td><code>userId Int @unique</code></td>
        </tr>
        <tr>
            <td>Other side</td>
            <td><code>posts Post[]</code> (array)</td>
            <td><code>profile Profile?</code> (single, optional)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The <code>@unique</code> constraint ensures one user can have only one profile.</li>
        <br/>
        <li>Database structure:</li>
<pre><code class="language-sql line-numbers">-- users table
id   | email
-----|------------------
1    | alice@example.com
2    | bob@example.com

-- profiles table
id   | bio              | avatar       | userId (UNIQUE)
-----|------------------|--------------|----------------
1    | I love coding    | pic1.jpg     | 1
2    | Hello world      | pic2.jpg     | 2</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Create user with profile
const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    profile: {
      create: {
        bio: 'I love coding',
        avatar: 'pic1.jpg'
      }
    }
  }
})

// Get user with profile
const userWithProfile = await prisma.user.findUnique({
  where: { id: 1 },
  include: { profile: true }
})

// Result:
// {
//   id: 1,
//   email: "alice@example.com",
//   profile: {
//     id: 1,
//     bio: "I love coding",
//     avatar: "pic1.jpg",
//     userId: 1
//   }
// }</code></pre>
    </ul>
    <br/><br/>


    <li>Why Use <code>?</code> (Optional) on Relations?</li>
    <br/>
    <ul>
        <li>The <code>?</code> makes a relation optional:</li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int      @id
  profile Profile? // User might not have a profile
}

model Profile {
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li><b>With</b> <code>?</code>: User can exist without a profile</li>
<pre><code class="language-typescript line-numbers">// Valid: user without profile
await prisma.user.create({
  data: { email: 'test@example.com' }
})</code></pre>
        <br/>
        <li><b>Without</b> <code>?</code>: Every user MUST have a profile immediately</li>
<pre><code class="language-prisma line-numbers">model User {
  id      Int     @id
  profile Profile // Required! Must provide profile when creating user
}</code></pre>
<pre><code class="language-typescript line-numbers">// Must create profile with user
await prisma.user.create({
  data: {
    email: 'test@example.com',
    profile: {
      create: { bio: 'Required!' }
    }
  }
})</code></pre>
        <br/>
        <li>Common pattern: Make optional on the side without the foreign key.</li>
<pre><code class="language-prisma line-numbers">model User {
  profile Profile? // Optional here
}

model Profile {
  userId Int  // Required here (no ?)
  user   User @relation(fields: [userId], references: [id])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Many-to-Many: Implicit (Simple)</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> Posts can have many tags, tags can be on many posts.</li>
        <br/>
        <li>Implicit many-to-many (Prisma creates join table automatically):</li>
<pre><code class="language-prisma line-numbers">model Post {
  id    Int     @id @default(autoincrement())
  title String
  tags  Tag[]   // Array of tags
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[] // Array of posts
}</code></pre>
        <br/>
        <li>Notice: NO foreign keys defined explicitly!</li>
        <br/>
        <li>Prisma automatically creates a join table named <code>_PostToTag</code>:</li>
<pre><code class="language-sql line-numbers">-- posts table
id   | title
-----|------------------
1    | First Post
2    | Second Post

-- tags table
id   | name
-----|-------------
1    | JavaScript
2    | Tutorial

-- _PostToTag (created automatically by Prisma)
A (postId) | B (tagId)
-----------|----------
1          | 1
1          | 2
2          | 1</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Create post with tags
await prisma.post.create({
  data: {
    title: 'First Post',
    tags: {
      create: [
        { name: 'JavaScript' },
        { name: 'Tutorial' }
      ]
    }
  }
})

// Connect existing tags
await prisma.post.create({
  data: {
    title: 'Second Post',
    tags: {
      connect: [
        { id: 1 }, // Connect to JavaScript tag
      ]
    }
  }
})

// Get post with all tags
const post = await prisma.post.findUnique({
  where: { id: 1 },
  include: { tags: true }
})

// Result:
// {
//   id: 1,
//   title: "First Post",
//   tags: [
//     { id: 1, name: "JavaScript" },
//     { id: 2, name: "Tutorial" }
//   ]
// }</code></pre>
    </ul>
    <br/><br/>


    <li>Many-to-Many: Explicit (With Extra Fields)</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> Track WHEN a tag was added to a post.</li>
        <br/>
        <li>You need the join table to store extra data:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int              @id @default(autoincrement())
  title    String
  postTags PostTag[]        // Connection to join table
}

model Tag {
  id       Int              @id @default(autoincrement())
  name     String
  postTags PostTag[]        // Connection to join table
}

// Explicit join table with extra fields
model PostTag {
  postId     Int
  tagId      Int
  assignedAt DateTime @default(now()) // Extra field!

  post       Post     @relation(fields: [postId], references: [id])
  tag        Tag      @relation(fields: [tagId], references: [id])

  @@id([postId, tagId]) // Composite primary key
}</code></pre>
        <br/>
        <li>Database structure:</li>
<pre><code class="language-sql line-numbers">-- posts table
id   | title
-----|------------------
1    | First Post

-- tags table
id   | name
-----|-------------
1    | JavaScript

-- post_tags table (explicit join table)
postId | tagId | assignedAt
-------|-------|------------------------
1      | 1     | 2024-01-15 10:30:00</code></pre>
        <br/>
        <li>Using in code:</li>
<pre><code class="language-typescript line-numbers">// Create relationship with timestamp
await prisma.postTag.create({
  data: {
    postId: 1,
    tagId: 1,
    assignedAt: new Date()
  }
})

// Get post with tags AND assignment timestamps
const post = await prisma.post.findUnique({
  where: { id: 1 },
  include: {
    postTags: {
      include: {
        tag: true // Include the actual tag data
      }
    }
  }
})

// Result:
// {
//   id: 1,
//   title: "First Post",
//   postTags: [
//     {
//       postId: 1,
//       tagId: 1,
//       assignedAt: "2024-01-15T10:30:00Z",
//       tag: { id: 1, name: "JavaScript" }
//     }
//   ]
// }</code></pre>
    </ul>
    <br/><br/>


    <li>When to Use Implicit vs Explicit Many-to-Many</li>
    <br/>
    <ul>
        <li><b>Use implicit (simple) when:</b></li>
        <ul>
            <li>you only need to connect two models</li>
            <li>no extra data needed on the relationship</li>
            <li>simpler API is preferred</li>
        </ul>
<pre><code class="language-prisma line-numbers">// Simple: just connect posts and categories
model Post {
  categories Category[]
}

model Category {
  posts Post[]
}</code></pre>
        <br/>
        <li><b>Use explicit when:</b></li>
        <ul>
            <li>need to store when relationship was created</li>
            <li>need to track who created the relationship</li>
            <li>need any extra metadata about the connection</li>
        </ul>
<pre><code class="language-prisma line-numbers">// Complex: track when user joined team and their role
model UserTeam {
  userId    Int
  teamId    Int
  role      String   // Extra field
  joinedAt  DateTime @default(now()) // Extra field

  user      User     @relation(fields: [userId], references: [id])
  team      Team     @relation(fields: [teamId], references: [id])

  @@id([userId, teamId])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Self-Relations: Model Relating to Itself</li>
    <br/>
    <ul>
        <li><b>Scenario:</b> Users can follow other users.</li>
        <br/>
        <li>Self-relation example:</li>
<pre><code class="language-prisma line-numbers">model User {
  id         Int    @id @default(autoincrement())
  name       String

  // Users I follow
  following  User[] @relation("UserFollows")

  // Users who follow me
  followers  User[] @relation("UserFollows")
}</code></pre>
        <br/>
        <li>Prisma creates implicit join table <code>_UserFollows</code>:</li>
<pre><code class="language-sql line-numbers">-- users table
id   | name
-----|-------
1    | Alice
2    | Bob
3    | Carol

-- _UserFollows (A follows B)
A    | B
-----|-----
1    | 2    -- Alice follows Bob
1    | 3    -- Alice follows Carol
2    | 1    -- Bob follows Alice</code></pre>
        <br/>
        <li>The <code>"UserFollows"</code> name is a label - you can name it anything:</li>
<pre><code class="language-prisma line-numbers">following User[] @relation("UserFollows")
followers User[] @relation("UserFollows")
// Both must have the SAME name to connect them</code></pre>
        <br/>
        <li>Explicit self-relation with extra data:</li>
<pre><code class="language-prisma line-numbers">model User {
  id         Int       @id @default(autoincrement())
  name       String
  following  Follow[]  @relation("Follower")
  followers  Follow[]  @relation("Following")
}

model Follow {
  followerId  Int
  followingId Int
  createdAt   DateTime @default(now())

  follower    User     @relation("Follower", fields: [followerId], references: [id])
  following   User     @relation("Following", fields: [followingId], references: [id])

  @@id([followerId, followingId])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding Relation Names</li>
    <br/>
    <ul>
        <li>Relation names are needed when you have <b>multiple relations</b> between same models.</li>
        <br/>
        <li>Example: Posts have an author AND an editor:</li>
<pre><code class="language-prisma line-numbers">model User {
  id            Int    @id @default(autoincrement())
  name          String
  authoredPosts Post[] @relation("PostAuthor")
  editedPosts   Post[] @relation("PostEditor")
}

model Post {
  id        Int    @id @default(autoincrement())
  title     String

  authorId  Int
  author    User   @relation("PostAuthor", fields: [authorId], references: [id])

  editorId  Int?
  editor    User?  @relation("PostEditor", fields: [editorId], references: [id])
}</code></pre>
        <br/>
        <li>Without names, Prisma can't tell which foreign key connects to which relation.</li>
        <br/>
        <li>The name can be anything descriptive:</li>
<pre><code class="language-prisma line-numbers">@relation("PostAuthor")    // Good
@relation("AuthorPosts")   // Good
@relation("WrittenBy")     // Good
@relation("abc123")        // Valid but unclear</code></pre>
        <br/>
        <li>Both sides must use the <b>exact same name</b>:</li>
<pre><code class="language-prisma line-numbers">// ✓ Correct - same name on both sides
author User @relation("PostAuthor", fields: [...])
authoredPosts Post[] @relation("PostAuthor")

// ✗ Wrong - different names
author User @relation("PostAuthor", fields: [...])
authoredPosts Post[] @relation("AuthoredPosts") // Mismatch!</code></pre>
    </ul>
    <br/><br/>


    <li>Optional vs Required Relations</li>
    <br/>
    <ul>
        <li>Relations can be optional or required:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int   @id

  // Required: every post MUST have an author
  authorId Int   // No ?
  author   User  @relation(fields: [authorId], references: [id])

  // Optional: post MAY have an editor
  editorId Int?  // With ?
  editor   User? @relation(fields: [editorId], references: [id])
}</code></pre>
        <br/>
        <li>Rule: If foreign key is optional (<code>Int?</code>), relation must be too (<code>User?</code>):</li>
<table>
    <thead>
        <tr>
            <th>Foreign Key</th>
            <th>Relation Field</th>
            <th>Valid?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>authorId Int</code></td>
            <td><code>author User</code></td>
            <td>✓ Both required</td>
        </tr>
        <tr>
            <td><code>editorId Int?</code></td>
            <td><code>editor User?</code></td>
            <td>✓ Both optional</td>
        </tr>
        <tr>
            <td><code>authorId Int</code></td>
            <td><code>author User?</code></td>
            <td>✗ Mismatch</td>
        </tr>
        <tr>
            <td><code>editorId Int?</code></td>
            <td><code>editor User</code></td>
            <td>✗ Mismatch</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>For arrays, never use <code>?</code>:</li>
<pre><code class="language-prisma line-numbers">model User {
  posts Post[]  // ✓ Correct: array is never optional
  // posts Post[]? // ✗ Wrong: syntax error
}</code></pre>
        <br/>
        <li>An empty array <code>[]</code> represents "no posts" - no need for <code>?</code>.</li>
    </ul>
    <br/><br/>


    <li>Cascade Delete and Update Actions</li>
    <br/>
    <ul>
        <li>Control what happens when related record is deleted/updated:</li>
<pre><code class="language-prisma line-numbers">model Post {
  id       Int  @id
  authorId Int
  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model User {
  id    Int    @id
  posts Post[]
}</code></pre>
        <br/>
        <li>Available actions:</li>
<table>
    <thead>
        <tr>
            <th>Action</th>
            <th>What Happens</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Cascade</code></td>
            <td>Delete user → delete all their posts</td>
        </tr>
        <tr>
            <td><code>SetNull</code></td>
            <td>Delete user → set posts.authorId to NULL</td>
        </tr>
        <tr>
            <td><code>Restrict</code></td>
            <td>Cannot delete user if they have posts</td>
        </tr>
        <tr>
            <td><code>NoAction</code></td>
            <td>Database decides (usually same as Restrict)</td>
        </tr>
        <tr>
            <td><code>SetDefault</code></td>
            <td>Set to default value (if defined)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example behaviors:</li>
<pre><code class="language-prisma line-numbers">// Delete user → delete their posts
author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

// Delete user → set authorId to NULL (requires authorId to be Int?)
author User? @relation(fields: [authorId], references: [id], onDelete: SetNull)

// Prevent user deletion if they have posts
author User @relation(fields: [authorId], references: [id], onDelete: Restrict)</code></pre>
        <br/>
        <li><code>onUpdate</code> works similarly but for ID changes (less common):</li>
<pre><code class="language-prisma line-numbers">author User @relation(
  fields: [authorId],
  references: [id],
  onDelete: Cascade,
  onUpdate: Cascade
)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Relationship Patterns</li>
    <br/>
    <ul>
        <li><b>Blog system:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  posts    Post[]
  comments Comment[]
}

model Post {
  id       Int       @id @default(autoincrement())
  title    String
  authorId Int
  author   User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments Comment[]
  tags     Tag[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  text    String
  postId  Int
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId  Int
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}</code></pre>
        <br/>
        <li><b>E-commerce:</b></li>
<pre><code class="language-prisma line-numbers">model Customer {
  id     Int     @id @default(autoincrement())
  email  String  @unique
  orders Order[]
}

model Order {
  id         Int         @id @default(autoincrement())
  customerId Int
  customer   Customer    @relation(fields: [customerId], references: [id])
  items      OrderItem[]
  total      Decimal
}

model Product {
  id         Int         @id @default(autoincrement())
  name       String
  price      Decimal
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId Int
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  price     Decimal
}</code></pre>
        <br/>
        <li><b>Organization hierarchy:</b></li>
<pre><code class="language-prisma line-numbers">model User {
  id           Int            @id @default(autoincrement())
  email        String         @unique
  memberships  Membership[]
}

model Organization {
  id          Int            @id @default(autoincrement())
  name        String
  memberships Membership[]
}

model Membership {
  id             Int          @id @default(autoincrement())
  userId         Int
  organizationId Int
  role           String
  joinedAt       DateTime     @default(now())

  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
}</code></pre>
    </ul>
    <br/><br/>


    <li>Common Mistakes and How to Fix Them</li>
    <br/>
    <ul>
        <li><b>Mistake 1: Forgetting @unique on one-to-one</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - missing @unique
model Profile {
  userId Int
  user   User @relation(fields: [userId], references: [id])
}

// ✓ Correct - has @unique
model Profile {
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])
}</code></pre>
        <br/>
        <li><b>Mistake 2: Mismatched optional markers</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - foreign key required but relation optional
model Post {
  editorId Int   // Required
  editor   User? // Optional - mismatch!
}

// ✓ Correct - both match
model Post {
  editorId Int?  // Optional
  editor   User? // Optional
}</code></pre>
        <br/>
        <li><b>Mistake 3: Wrong side has foreign key</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - foreign key on "one" side
model User {
  id     Int   @id
  postId Int   // Wrong! Can only reference ONE post
  post   Post  @relation(fields: [postId], references: [id])
}

// ✓ Correct - foreign key on "many" side
model Post {
  id       Int  @id
  authorId Int
  author   User @relation(fields: [authorId], references: [id])
}

model User {
  id    Int    @id
  posts Post[] // One user has many posts
}</code></pre>
        <br/>
        <li><b>Mistake 4: Not using arrays on one-to-many</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - not an array
model User {
  posts Post  // Wrong! Should be Post[]
}

// ✓ Correct - array for multiple posts
model User {
  posts Post[]
}</code></pre>
        <br/>
        <li><b>Mistake 5: Ambiguous relations without names</b></li>
<pre><code class="language-prisma line-numbers">// ✗ Wrong - Prisma can't tell which is which
model Post {
  authorId Int
  author   User @relation(fields: [authorId], references: [id])

  editorId Int
  editor   User @relation(fields: [editorId], references: [id])
}

// ✓ Correct - use relation names
model Post {
  authorId Int
  author   User @relation("PostAuthor", fields: [authorId], references: [id])

  editorId Int
  editor   User @relation("PostEditor", fields: [editorId], references: [id])
}

model User {
  authoredPosts Post[] @relation("PostAuthor")
  editedPosts   Post[] @relation("PostEditor")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Practice Examples</li>
    <br/>
    <ul>
        <li><b>Exercise 1:</b> Movies and directors (one-to-many)</li>
<pre><code class="language-prisma line-numbers">model Director {
  id     Int     @id @default(autoincrement())
  name   String
  movies Movie[]
}

model Movie {
  id         Int      @id @default(autoincrement())
  title      String
  directorId Int
  director   Director @relation(fields: [directorId], references: [id])
}</code></pre>
        <br/>
        <li><b>Exercise 2:</b> Student and student card (one-to-one)</li>
<pre><code class="language-prisma line-numbers">model Student {
  id          Int           @id @default(autoincrement())
  name        String
  studentCard StudentCard?
}

model StudentCard {
  id        Int     @id @default(autoincrement())
  cardNumber String @unique
  studentId Int     @unique
  student   Student @relation(fields: [studentId], references: [id])
}</code></pre>
        <br/>
        <li><b>Exercise 3:</b> Students and courses (many-to-many)</li>
<pre><code class="language-prisma line-numbers">model Student {
  id      Int      @id @default(autoincrement())
  name    String
  courses Course[]
}

model Course {
  id       Int       @id @default(autoincrement())
  name     String
  students Student[]
}</code></pre>
        <br/>
        <li><b>Exercise 4:</b> Students and courses with enrollment date (explicit many-to-many)</li>
<pre><code class="language-prisma line-numbers">model Student {
  id          Int          @id @default(autoincrement())
  name        String
  enrollments Enrollment[]
}

model Course {
  id          Int          @id @default(autoincrement())
  name        String
  enrollments Enrollment[]
}

model Enrollment {
  studentId  Int
  courseId   Int
  enrolledAt DateTime @default(now())
  grade      String?

  student    Student  @relation(fields: [studentId], references: [id])
  course     Course   @relation(fields: [courseId], references: [id])

  @@id([studentId, courseId])
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
