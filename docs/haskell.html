<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>HASKELL</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 28px;
        height: 28px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/haskell.png" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#haskell-intro">Introduction</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-intro">Introduction to Haskell</h3>
<ol>

    <li><b>What Is Haskell?</b></li>
    <br/>
    <ul>
        <li><u>Haskell</u> is a purely functional, statically typed programming language with:
            <ul>
                <li><b>no side effects by default</b></li>
                <li><b>lazy evaluation</b></li>
                <li>a <b>powerful type system</b> (type inference, typeclasses, algebraic data types)</li>
            </ul>
        </li>
        <br/>
        <li>It is named after the logician <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>.</li>
        <br/>
        <li>Haskell is used in:
            <ul>
                <li>finance</li>
                <li>compilers</li>
                <li>blockchain (e.g., Cardano)</li>
                <li>research</li>
                <li>formal verification</li>
            </ul>
        </li>
        <br/>
        <li>Haskell encourages a <u>mathematical, declarative style</u> of programming.</li>
    </ul>

    <br/><br/>


    <li><b>Key Features of Haskell</b></li>
    <br/>
    <ol>
        <li><b>Pure Functional Programming</b></li>
        <ul>
            <li>Functions have no side effects:
                <ul>
                    <li>no global variables</li>
                    <li>no random mutations</li>
                    <li>same input → same output forever</li>
                </ul>
            </li>
            <li>This makes reasoning and testing easier.</li>
        </ul>

        <br/>

        <li><b>Lazy Evaluation</b></li>
        <ul>
            <li>Expressions are evaluated only when needed.</li>
            <li>This enables:
                <ul>
                    <li>infinite lists</li>
                    <li>performance optimization</li>
                </ul>
            </li>
        </ul>

        <br/>

        <li><b>Static Strong Typing with Type Inference</b></li>
        <ul>
            <li>You rarely write types manually—Haskell infers them.</li>
            <li>Compiler catches many errors at compile time.</li>
        </ul>

        <br/>

        <li><b>Typeclasses</b></li>
        <ul>
            <li>They define behavior that types must implement.</li>
            <li>Similar to Rust traits or Java interfaces.</li>
        </ul>

        <br/>

        <li><b>Algebraic Data Types (ADTs)</b></li>
        <ul>
            <li>Powerful ways to model data structures.</li>
            <li>Variants, recursion, pattern matching.</li>
        </ul>

        <br/>

        <li><b>Monads & Pure I/O</b></li>
        <ul>
            <li>Haskell keeps side effects in controlled “containers.”</li>
            <li>The most famous example → <b>IO Monad</b>.</li>
        </ul>
    </ol>

    <br/><br/>


    <li><b>Basic Syntax</b></li>
    <br/>
    <ul>
        <li>Python example:</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    return a + b
</code></pre>

    <ul>
        <li>Haskell equivalent:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add a b = a + b
</code></pre>

    <ul>
        <li>Notice:
            <ul>
                <li>No parentheses</li>
                <li>No commas</li>
                <li>No return keyword</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Functions Are First-Class</b></li>
    <br/>
    <ul>
        <li>You can pass functions as arguments or return them.</li>
    </ul>

<pre><code class="language-haskell line-numbers">applyTwice f x = f (f x)</code></pre>

    <ul>
        <li>A function <code>f</code> applied two times to <code>x</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Type Annotations (Optional)</b></li>
    <br/>
    <ul>
        <li>Haskell infers types, but you can write them explicitly:</li>
    </ul>
<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add a b = a + b
</code></pre>

    <ul>
        <li>This says:
            <ul>
                <li>Add takes two Ints</li>
                <li>Returns an Int</li>
            </ul>
        </li>
        <li>Arrow <code>-&gt;</code> separates parameters.</li>
    </ul>

    <br/><br/>


    <li><b>Immutable Variables</b></li>
    <br/>
    <ul>
        <li>Variables cannot change after assignment.</li>
        <li>This is a core principle of functional programming.</li>
    </ul>

<pre><code class="language-haskell line-numbers">x = 10
-- x = 20   -- INVALID
</code></pre>

    <br/><br/>


    <li><b>Lists</b></li>

<pre><code class="language-haskell line-numbers">nums = [1, 2, 3, 4]</code></pre>

    <ul>
        <li>All elements must be the same type.</li>
        <li>List comprehension:</li>
    </ul>

<pre><code class="language-haskell line-numbers">squares = [x * x | x &lt;- [1..5]]</code></pre>

    <br/><br/>


    <li><b>Pattern Matching</b></li>
    <br/>
    <ul>
        <li>A superpower in Haskell, similar to Rust.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe :: Int -&gt; String
describe 0 = "Zero"
describe 1 = "One"
describe _ = "Other number"
</code></pre>

    <ul><li><code>_</code> is the catch-all (like Rust).</li></ul>

    <br/><br/>


    <li><b>Recursion (Fundamental in Haskell)</b></li>

<pre><code class="language-haskell line-numbers">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
</code></pre>

    <ul>
        <li>Loops are less common; you use recursion or higher-order functions.</li>
    </ul>

    <br/><br/>


    <li><b>Higher-Order Functions</b></li>

<pre><code class="language-haskell line-numbers">doubleAll xs = map (\x -&gt; x * 2) xs</code></pre>

    <ul>
        <li><code>map</code>, <code>filter</code>, and <code>foldr</code> are essential tools.</li>
    </ul>

    <br/><br/>


    <li><b>Typeclasses (Extremely Important)</b></li>
    <br/>
    <ul>
        <li>A typeclass defines behavior.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
</code></pre>

    <ul>
        <li>Instances implement that behavior:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Blue

instance Eq Color where
    Red == Red = True
    Blue == Blue = True
    _ == _ = False
</code></pre>

    <br/><br/>


    <li><b>Algebraic Data Types (ADTs)</b></li>
    <br/>
    <ul>
        <li>One of Haskell’s most beloved features.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Shape
    = Circle Float
    | Rectangle Float Float
</code></pre>

    <ul>
        <li>Pattern matching on ADTs is extremely expressive:</li>
    </ul>

<pre><code class="language-haskell line-numbers">area :: Shape -&gt; Float
area (Circle r) = pi * r * r
area (Rectangle w h) = w * h
</code></pre>

    <br/><br/>


    <li><b>The IO Monad (Side Effects in Haskell)</b></li>
    <br/>
    <ul>
        <li>Because Haskell is pure, side effects cannot be done normally.</li>
        <li>Instead, Haskell uses the <code>IO Monad</code> to contain and sequence effects.</li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    putStrLn "Hello!"
    name &lt;- getLine
    putStrLn ("Hi, " ++ name)
</code></pre>

    <br/><br/>


    <li><b>Lazy Evaluation and Infinite Lists</b></li>
    <br/>
    <ul>
        <li>You can create infinite sequences:</li>
    </ul>

<pre><code class="language-haskell line-numbers">naturals = [1..]    -- infinite list!</code></pre>

    <ul>
        <li>Lazy evaluation makes this safe:</li>
    </ul>

<pre><code class="language-haskell line-numbers">take 5 naturals   -- [1,2,3,4,5]</code></pre>

    <br/><br/>


    <li><b>How to Get Started</b></li>
    <br/>
    <ul>
        <li>Install GHC (compiler) and Stack or Cabal (build tool):</li>
    </ul>

<pre><code class="language-bash line-numbers">sudo apt install ghc cabal-install
# OR
curl -sSL https://get.haskellstack.org/ | sh
</code></pre>

    <ul>
        <li>Run REPL (GHCI):</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci</code></pre>

    <ul>
        <li>Create a new project (Stack):</li>
    </ul>

<pre><code class="language-bash line-numbers">stack new myproject
cd myproject
stack run
</code></pre>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
