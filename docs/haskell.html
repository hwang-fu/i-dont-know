<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>HASKELL</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 28px;
        height: 28px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/haskell.png" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#haskell-intro">Introduction</a></li>
        <li><a href="#haskell-ghci">Using GHCi: The Interactive Haskell Environment</a></li>
        <li><a href="#haskell-comparison-operations">Comparison Operations</a></li>
        <li><a href="#haskell-lists-introduction">Lists Introduction</a></li>
        <li><a href="#haskell-list-concatenation">List Concatenation</a></li>
        <li><a href="#haskell-list-comprehension">List Comprehension</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-intro">Introduction to Haskell</h3>
<ol>

    <li><b>What Is Haskell?</b></li>
    <br/>
    <ul>
        <li><u>Haskell</u> is a purely functional, statically typed programming language with:
            <ul>
                <li><b>no side effects by default</b></li>
                <li><b>lazy evaluation</b></li>
                <li>a <b>powerful type system</b> (type inference, typeclasses, algebraic data types)</li>
            </ul>
        </li>
        <br/>
        <li>It is named after the logician <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>.</li>
        <br/>
        <li>Haskell is used in:
            <ul>
                <li>finance</li>
                <li>compilers</li>
                <li>blockchain (e.g., Cardano)</li>
                <li>research</li>
                <li>formal verification</li>
            </ul>
        </li>
        <br/>
        <li>Haskell encourages a <u>mathematical, declarative style</u> of programming.</li>
    </ul>

    <br/><br/>


    <li><b>Key Features of Haskell</b></li>
    <br/>
    <ol>
        <li><b>Pure Functional Programming</b></li>
        <ul>
            <li>Functions have no side effects:
                <ul>
                    <li>no global variables</li>
                    <li>no random mutations</li>
                    <li>same input → same output forever</li>
                </ul>
            </li>
            <li>This makes reasoning and testing easier.</li>
        </ul>

        <br/>

        <li><b>Lazy Evaluation</b></li>
        <ul>
            <li>Expressions are evaluated only when needed.</li>
            <li>This enables:
                <ul>
                    <li>infinite lists</li>
                    <li>performance optimization</li>
                </ul>
            </li>
        </ul>

        <br/>

        <li><b>Static Strong Typing with Type Inference</b></li>
        <ul>
            <li>You rarely write types manually—Haskell infers them.</li>
            <li>Compiler catches many errors at compile time.</li>
        </ul>

        <br/>

        <li><b>Typeclasses</b></li>
        <ul>
            <li>They define behavior that types must implement.</li>
            <li>Similar to Rust traits or Java interfaces.</li>
        </ul>

        <br/>

        <li><b>Algebraic Data Types (ADTs)</b></li>
        <ul>
            <li>Powerful ways to model data structures.</li>
            <li>Variants, recursion, pattern matching.</li>
        </ul>

        <br/>

        <li><b>Monads & Pure I/O</b></li>
        <ul>
            <li>Haskell keeps side effects in controlled “containers.”</li>
            <li>The most famous example → <b>IO Monad</b>.</li>
        </ul>
    </ol>

    <br/><br/>


    <li><b>Basic Syntax</b></li>
    <br/>
    <ul>
        <li>Python example:</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    return a + b
</code></pre>

    <ul>
        <li>Haskell equivalent:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add a b = a + b
</code></pre>

    <ul>
        <li>Notice:
            <ul>
                <li>No parentheses</li>
                <li>No commas</li>
                <li>No return keyword</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Functions Are First-Class</b></li>
    <br/>
    <ul>
        <li>You can pass functions as arguments or return them.</li>
    </ul>

<pre><code class="language-haskell line-numbers">applyTwice f x = f (f x)</code></pre>

    <ul>
        <li>A function <code>f</code> applied two times to <code>x</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Type Annotations (Optional)</b></li>
    <br/>
    <ul>
        <li>Haskell infers types, but you can write them explicitly:</li>
    </ul>
<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add a b = a + b
</code></pre>

    <ul>
        <li>This says:
            <ul>
                <li>Add takes two Ints</li>
                <li>Returns an Int</li>
            </ul>
        </li>
        <li>Arrow <code>-&gt;</code> separates parameters.</li>
    </ul>

    <br/><br/>


    <li><b>Immutable Variables</b></li>
    <br/>
    <ul>
        <li>Variables cannot change after assignment.</li>
        <li>This is a core principle of functional programming.</li>
    </ul>

<pre><code class="language-haskell line-numbers">x = 10
-- x = 20   -- INVALID
</code></pre>

    <br/><br/>


    <li><b>Lists</b></li>

<pre><code class="language-haskell line-numbers">nums = [1, 2, 3, 4]</code></pre>

    <ul>
        <li>All elements must be the same type.</li>
        <li>List comprehension:</li>
    </ul>

<pre><code class="language-haskell line-numbers">squares = [x * x | x &lt;- [1..5]]</code></pre>

    <br/><br/>


    <li><b>Pattern Matching</b></li>
    <br/>
    <ul>
        <li>A superpower in Haskell, similar to Rust.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe :: Int -&gt; String
describe 0 = "Zero"
describe 1 = "One"
describe _ = "Other number"
</code></pre>

    <ul><li><code>_</code> is the catch-all (like Rust).</li></ul>

    <br/><br/>


    <li><b>Recursion (Fundamental in Haskell)</b></li>

<pre><code class="language-haskell line-numbers">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
</code></pre>

    <ul>
        <li>Loops are less common; you use recursion or higher-order functions.</li>
    </ul>

    <br/><br/>


    <li><b>Higher-Order Functions</b></li>

<pre><code class="language-haskell line-numbers">doubleAll xs = map (\x -&gt; x * 2) xs</code></pre>

    <ul>
        <li><code>map</code>, <code>filter</code>, and <code>foldr</code> are essential tools.</li>
    </ul>

    <br/><br/>


    <li><b>Typeclasses (Extremely Important)</b></li>
    <br/>
    <ul>
        <li>A typeclass defines behavior.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
</code></pre>

    <ul>
        <li>Instances implement that behavior:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Blue

instance Eq Color where
    Red == Red = True
    Blue == Blue = True
    _ == _ = False
</code></pre>

    <br/><br/>


    <li><b>Algebraic Data Types (ADTs)</b></li>
    <br/>
    <ul>
        <li>One of Haskell’s most beloved features.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Shape
    = Circle Float
    | Rectangle Float Float
</code></pre>

    <ul>
        <li>Pattern matching on ADTs is extremely expressive:</li>
    </ul>

<pre><code class="language-haskell line-numbers">area :: Shape -&gt; Float
area (Circle r) = pi * r * r
area (Rectangle w h) = w * h
</code></pre>

    <br/><br/>


    <li><b>The IO Monad (Side Effects in Haskell)</b></li>
    <br/>
    <ul>
        <li>Because Haskell is pure, side effects cannot be done normally.</li>
        <li>Instead, Haskell uses the <code>IO Monad</code> to contain and sequence effects.</li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    putStrLn "Hello!"
    name &lt;- getLine
    putStrLn ("Hi, " ++ name)
</code></pre>

    <br/><br/>


    <li><b>Lazy Evaluation and Infinite Lists</b></li>
    <br/>
    <ul>
        <li>You can create infinite sequences:</li>
    </ul>

<pre><code class="language-haskell line-numbers">naturals = [1..]    -- infinite list!</code></pre>

    <ul>
        <li>Lazy evaluation makes this safe:</li>
    </ul>

<pre><code class="language-haskell line-numbers">take 5 naturals   -- [1,2,3,4,5]</code></pre>

    <br/><br/>


    <li><b>How to Get Started</b></li>
    <br/>
    <ul>
        <li>Install GHC (compiler) and Stack or Cabal (build tool):</li>
    </ul>

<pre><code class="language-bash line-numbers">sudo apt install ghc cabal-install
# OR
curl -sSL https://get.haskellstack.org/ | sh
</code></pre>

    <ul>
        <li>Run REPL (GHCI):</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci</code></pre>

    <ul>
        <li>Create a new project (Stack):</li>
    </ul>

<pre><code class="language-bash line-numbers">stack new myproject
cd myproject
stack run
</code></pre>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-ghci">Using GHCi: The Interactive Haskell Environment</h3>
<ol>

    <li><b>What Is GHCi?</b></li>
    <br/>
    <ul>
        <li><b>GHCi</b> (Glasgow Haskell Compiler interactive) is Haskell’s interactive REPL:</li>
        <ul>
            <li>runs Haskell expressions immediately</li>
            <li>loads modules and files</li>
            <li>tests functions without compiling a full project</li>
            <li>inspects types, evaluates expressions, debugs code</li>
            <li>ideal for learning, experimenting, and prototyping</li>
        </ul>
        <br/>
        <li>GHCi comes bundled with GHC, Stack, and Cabal.</li>
    </ul>

    <br/><br/>


    <li><b>Starting GHCi</b></li>
    <br/>
    <ul>
        <li>Simply run:</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci
</code></pre>

    <ul>
        <li>You will see a prompt like:</li>
    </ul>

<pre><code class="language-text line-numbers">GHCi, version 9.x.x: http://www.haskell.org/ghc/  :? for help
Prelude&gt;
</code></pre>

    <ul>
        <li>Now you can type Haskell expressions directly.</li>
    </ul>

    <br/><br/>


    <li><b>Evaluating Expressions</b></li>
    <br/>
    <ul>
        <li>GHCi acts like a calculator:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; 2 + 3 * 4
14

Prelude&gt; take 5 [1..]
[1,2,3,4,5]
</code></pre>

    <ul>
        <li>Expressions can be arbitrarily complex:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; map (*2) [1..10]
[2,4,6,8,10,12,14,16,18,20]
</code></pre>

    <br/><br/>


    <li><b>Checking Types with</b> <code>:type</code> <b>or</b> <code>:t</code></b></li>
    <br/>
    <ul>
        <li>GHCi’s type inspection is one of its greatest strengths.</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :t 42
42 :: Num a =&gt; a

Prelude&gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>

    <ul>
        <li>Useful for learning Haskell’s type system.</li>
    </ul>

    <br/><br/>


    <li><b>Loading Haskell Files</b></li>
    <br/>
    <ul>
        <li>You can load a file (e.g., <code>mycode.hs</code>):</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci mycode.hs
</code></pre>

    <ul>
        <li>Inside GHCi you can reload after edits using:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :reload
-- or shorthand:
Prelude&gt; :r
</code></pre>

    <ul>
        <li>Useful workflow:
            <ul>
                <li>edit code in editor</li>
                <li>reload in GHCi</li>
                <li>test functions live</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Running Main</b></li>
    <br/>
    <ul>
        <li>If a file defines <code>main :: IO ()</code> in a module, GHCi can run it:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :main
</code></pre>

    <ul>
        <li>You can pass arguments too:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :main 10 20
</code></pre>

    <br/><br/>


    <li><b>Using</b> <code>let</code> <b>to Define Local Bindings</b></li>
    <br/>
    <ul>
        <li>Inside GHCi, use <code>let</code> to define values:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; let x = 10
Prelude&gt; x * 2
20
</code></pre>

    <ul>
        <li>You can also define functions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; let square n = n * n
Prelude&gt; square 7
49
</code></pre>

    <br/><br/>


    <li><b>Browsing Loaded Modules</b></li>
    <br/>
    <ul>
        <li>List loaded modules:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :show modules
</code></pre>

    <ul>
        <li>List functions in the current module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :browse
</code></pre>

    <ul>
        <li>Browse a specific module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :browse Data.List
</code></pre>

    <br/><br/>


    <li><b>Reloading Automatically</b></li>
    <br/>
    <ul>
        <li>Enable auto-reload when files change:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :set -fobject-code
Prelude&gt; :set -fdefer-type-errors
Prelude&gt; :set -package mtl
</code></pre>

    <ul>
        <li>Or reload manually:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :reload
</code></pre>

    <br/><br/>


    <li><b>Importing Modules</b></li>
    <br/>
    <ul>
        <li>You can import modules directly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; import Data.List
Prelude Data.List&gt;
</code></pre>

    <ul>
        <li>Qualified import:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; import qualified Data.Map as M
Prelude&gt; M.fromList [(1,"a"), (2,"b")]
fromList [(1,"a"),(2,"b")]
</code></pre>

    <br/><br/>


    <li><b>Loading Multiple Files</b></li>
    <br/>
    <ul>
        <li>GHCi understands projects with multiple modules:</li>
    </ul>

<pre><code class="language-haskell line-numbers">ghci Main.hs Utils.hs Types.hs
</code></pre>

    <ul>
        <li>Or load an entire directory using <code>:set</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :set -i src
</code></pre>

    <br/><br/>


    <li><b>Debugging with GHCi</b></li>
    <br/>
    <ul>
        <li>GHCi includes a debugger:</li>
        <ul>
            <li>set breakpoints</li>
            <li>step through evaluation</li>
            <li>inspect variables</li>
        </ul>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :break myFunction
Prelude&gt; :trace main
Prelude&gt; :history
Prelude&gt; :continue
</code></pre>

    <br/><br/>


    <li><b>Useful GHCi Commands</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>:t expr</code></td>
                <td>Show the type of an expression</td>
            </tr>
            <tr>
                <td><code>:i name</code></td>
                <td>Show info about a type or function</td>
            </tr>
            <tr>
                <td><code>:l file</code></td>
                <td>Load a file</td>
            </tr>
            <tr>
                <td><code>:r</code></td>
                <td>Reload current modules</td>
            </tr>
            <tr>
                <td><code>:main</code></td>
                <td>Run the <code>main</code> function</td>
            </tr>
            <tr>
                <td><code>:q</code></td>
                <td>Quit GHCi</td>
            </tr>
            <tr>
                <td><code>:set -XExtension</code></td>
                <td>Enable language extensions</td>
            </tr>
            <tr>
                <td><code>:browse</code></td>
                <td>List contents of current module</td>
            </tr>
            <tr>
                <td><code>:module + Data.Map</code></td>
                <td>Temporarily import a module</td>
            </tr>
            <tr>
                <td><code>:set prompt "ghci&gt;"</code></td>
                <td>Customize the prompt based on your taste</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li>GHCi is Haskell’s interactive environment — powerful for learning and development.</li>
        <li>Helps evaluate expressions, inspect types, load modules, and debug programs.</li>
        <li>Common uses include:
            <ul>
                <li>testing functions quickly</li>
                <li>experimenting with the type system</li>
                <li>loading and reloading project files</li>
                <li>interactive debugging</li>
                <li>prototype-driven development</li>
            </ul>
        </li>
        <li>Mastering GHCi greatly improves Haskell productivity.</li>
    </ul>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-comparison-operations">Comparison Operations in Haskell</h3>
<ol>
    <li><b>What Are Comparison Operations?</b></li>
    <br/>
    <ul>
        <li>Comparison operations in Haskell determine the <u>ordering</u> and <u>equality</u> relationships between values.</li>
        <br/>
        <li>They are provided mainly by two important typeclasses:
            <ul>
                <li><code>Eq</code> — supports equality / inequality</li>
                <li><code>Ord</code> — supports ordering (less than, greater than, etc.)</li>
            </ul>
        </li>
        <br/>
        <li>Comparison is always <u>type-safe</u>: you can only compare values whose types implement these typeclasses.</li>
        <br/>
        <li>Many built-in types (<code>Int</code>, <code>Float</code>, <code>Bool</code>, <code>Char</code>, <code>List</code>, <code>Tuple</code>, etc.) already derive <code>Eq</code> and <code>Ord</code>.</li>
    </ul>
    <br/><br/>

    <li><b>The</b> <code>Eq</code> <b>Typeclass: Equality</b></li>
    <br/>
    <ul>
        <li><code>Eq</code> defines two operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
(/=) :: Eq a =&gt; a -&gt; a -&gt; Bool
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">5 == 5          -- True
5 /= 3          -- True
'a' == 'b'      -- False
[1,2] == [1,2]  -- True
</code></pre>

    <br/>
    <ul>
        <li>If a type implements <code>Eq</code>, it must satisfy:
            <ul>
                <li><b>Reflexive</b>: x == x == True</li>
                <li><b>Symmetric</b>: if x == y then y == x</li>
                <li><b>Transitive</b>: if x == y and y == z then x == z</li>
            </ul>
        </li>
        <br/>
        <li>These mathematical guarantees make reasoning about comparisons reliable.</li>
    </ul>
    <br/><br/>

    <li><b>The</b> <code>Ord</code> <b>Typeclass: Ordering</b></li>
    <br/>
    <ul>
        <li><code>Ord</code> defines ordering functions. A type must be <code>Eq</code> before it can be <code>Ord</code>.</li>
        <li>Important operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(&lt;)  :: Ord a =&gt; a -&gt; a -&gt; Bool
(&gt;)  :: Ord a =&gt; a -&gt; a -&gt; Bool
(&lt;=) :: Ord a =&gt; a -&gt; a -&gt; Bool
(&gt;=) :: Ord a =&gt; a -&gt; a -&gt; Bool
compare :: Ord a =&gt; a -&gt; a -&gt; Ordering
</code></pre>

    <br/>
    <ul>
        <li><code>Ordering</code> is a simple type:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Ordering = LT | EQ | GT
</code></pre>

    <br/>
    <ul>
        <li>Example usage:</li>
    </ul>

<pre><code class="language-haskell line-numbers">3 &lt; 5        -- True
"hi" &gt; "ha"  -- True (lexicographical)
compare 10 7 -- GT
</code></pre>

    <br/>
    <ul>
        <li><code>Ord</code> must satisfy total ordering rules:
            <ul>
                <li>No contradictions (x &lt; y and y &lt; x cannot both be true)</li>
                <li>Transitivity</li>
                <li>Totality: for any x, y exactly one of:
                    <ul>
                        <li>x &lt; y</li>
                        <li>x == y</li>
                        <li>x &gt; y</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <br/><br/>

    <li><b>Comparing Basic Types</b></li>
    <br/>
    <ul>
        <li>All primitive types implement <code>Eq</code> and <code>Ord</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">True &lt; False      -- False
'A' &lt; 'a'         -- True (ASCII/Unicode ordering)
1.0 == 1.0        -- True
2.3 &gt;= 2.1        -- True
</code></pre>

    <br/>
    <ul>
        <li><b>Lists</b> compare lexicographically:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3] &lt; [1,2,4]     -- True
"abc" &gt; "abb"         -- True
</code></pre>

    <br/>
    <ul>
        <li><b>Tuples</b> also compare lexicographically (element by element):</li>
    </ul>

<pre><code class="language-haskell line-numbers">(3, "x") &lt; (3, "y")   -- True
(2, 5) &gt; (1, 100)      -- True
</code></pre>

    <br/><br/>

    <li><b>Using</b> <code>max</code>, <code>min</code>, <code>compare</code></li>
    <br/>
    <ul>
        <li>Because <code>Ord</code> is defined, many utilities work automatically:</li>
    </ul>

<pre><code class="language-haskell line-numbers">max 3 10            -- 10
min "apple" "dog"   -- "apple"
compare 1 1         -- EQ
</code></pre>

    <br/><br/>

    <li><b>Sort Using Comparison</b></li>
    <br/>
    <ul>
        <li><code>sort</code> uses <code>Ord</code> to determine ordering:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List (sort)

sort [3,1,4,1]          -- [1,1,3,4]
sort ["z", "b", "aa"]   -- ["aa","b","z"]
</code></pre>

    <br/><br/>

    <li><b>Deriving</b> <code>Eq</code>, <code>Ord</code> <b>for Custom Types</b></li>
    <br/>
    <ul>
        <li>You can automatically derive comparison operations for your own data types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue
  deriving (Eq, Ord, Show)

Red &lt; Blue   -- True (ordering = definition order)
</code></pre>

    <br/>
    <ul>
        <li>For more complex types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Point = Point Int Int
  deriving (Eq, Ord, Show)

Point 1 3 &lt; Point 1 4   -- True (lexicographic)
</code></pre>

    <br/><br/>

    <li><b>Custom Comparison Logic</b></li>
    <br/>
    <ul>
        <li>You can manually implement <code>Eq</code> or <code>Ord</code> to override behavior:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Person = Person { name :: String, age :: Int }

instance Eq Person where
    p1 == p2 = age p1 == age p2

instance Ord Person where
    compare p1 p2 = compare (age p1) (age p2)
</code></pre>

    <ul>
        <li>Now persons compare by <b>age only</b>, ignoring the name.</li>
    </ul>

    <br/><br/>

    <li><b>Chaining Comparisons Using</b> <code>Ordering</code></li>
    <br/>
    <ul>
        <li>Sometimes you want to compare multiple fields manually:</li>
    </ul>

<pre><code class="language-haskell line-numbers">comparePoints (x1,y1) (x2,y2) =
    compare x1 x2 &lt;&gt; compare y1 y2
</code></pre>

    <br/>
    <ul>
        <li><code>(&lt;&gt;)</code> is monoid append for <code>Ordering</code>:
            <ul>
                <li><code>EQ</code> continues comparison</li>
                <li><code>LT</code> or <code>GT</code> stops immediately</li>
            </ul>
        </li>
    </ul>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-lists-introduction">Introduction to Lists in Haskell</h3>
<ol>
    <li><b>What Are Lists in Haskell?</b></li>
    <br/>
    <ul>
        <li>Lists are one of the most fundamental and commonly used data structures in Haskell.</li>
        <br/>
        <li>A list is a <b>homogeneous</b> collection of elements:
            <ul>
                <li>every element must have the same type,</li>
                <li>the list itself has type <code>[T]</code> where <code>T</code> is the element type.</li>
            </ul>
        </li>
        <br/>
        <li>Lists are <b>linked structures</b>, not arrays:
            <ul>
                <li>fast at prepending (O(1)),</li>
                <li>slow at indexing (O(n)).</li>
            </ul>
        </li>
        <br/>
        <li>Examples of list types:
            <ul>
                <li><code>[Int]</code> — list of integers</li>
                <li><code>[Char]</code> — list of characters</li>
                <li><code>[[Int]]</code> — list of lists</li>
            </ul>
        </li>
        <br/>
        <li>Haskell lists are <b>immutable</b> — once built, they cannot be modified.</li>
    </ul>
    <br/><br/>

    <li><b>Creating Lists</b></li>
    <br/>
    <ul>
        <li>The simplest way is using square brackets:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3]
['a','b','c']
["hello", "world"]
</code></pre>

    <br/>
    <ul>
        <li>Lists can also be constructed using the <code>:</code> operator (cons):</li>
    </ul>

<pre><code class="language-haskell line-numbers">1 : 2 : 3 : []      -- equals [1,2,3]
'a' : 'b' : []      -- equals ['a','b']
</code></pre>

    <br/>
    <ul>
        <li><code>:</code> attaches a single element to the front of a list.</li>
        <li>The empty list is written as <code>[]</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Strings Are Lists of Characters</b></li>
    <br/>
    <ul>
        <li>In Haskell, <code>String</code> is just a type alias for <code>[Char]</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">"hello" == ['h','e','l','l','o']  -- True
</code></pre>

    <ul>
        <li>This makes string manipulation consistent with list operations.</li>
    </ul>
    <br/><br/>

    <li><b>List Ranges and Sequences</b></li>
    <br/>
    <ul>
        <li>Haskell supports a compact syntax for sequences:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..5]         -- [1,2,3,4,5]
['a'..'e']     -- ['a','b','c','d','e']
[0,2..10]      -- [0,2,4,6,8,10] (step of 2)
</code></pre>

    <br/>
    <ul>
        <li>For infinite lists (lazy evaluation):</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..]          -- infinite list of natural numbers
take 5 [1..]   -- [1,2,3,4,5]
</code></pre>

    <br/><br/>

    <li><b>Basic List Operations</b></li>
    <br/>
    <ul>
        <li>Head (first element):</li>
    </ul>

<pre><code class="language-haskell line-numbers">head [1,2,3]    -- 1
</code></pre>

    <br/>
    <ul>
        <li>Tail (everything except the first element):</li>
    </ul>

<pre><code class="language-haskell line-numbers">tail [1,2,3]    -- [2,3]
</code></pre>

    <br/>
    <ul>
        <li>Last element:</li>
    </ul>

<pre><code class="language-haskell line-numbers">last [1,2,3]    -- 3
</code></pre>

    <br/>
    <ul>
        <li>Length:</li>
    </ul>

<pre><code class="language-haskell line-numbers">length [1,2,3]  -- 3
</code></pre>

    <br/>
    <ul>
        <li>Indexing (0-based):</li>
    </ul>

<pre><code class="language-haskell line-numbers">[10,20,30] !! 1  -- 20
</code></pre>

    <br/>
    <ul>
        <li>List concatenation:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2] ++ [3,4]   -- [1,2,3,4]
</code></pre>

    <br/>
    <ul>
        <li>Prepending with <code>:</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">5 : [6,7]   -- [5,6,7]
</code></pre>

    <br/><br/>

    <li><b>Immutable Structure and Sharing</b></li>
    <br/>
    <ul>
        <li>Lists are immutable; any “modification” creates a new list.</li>
        <li>However, Haskell shares memory efficiently via pointers:</li>
    </ul>

<pre><code class="language-haskell line-numbers">let xs = [1,2,3]
let ys = 0 : xs     -- shares tail nodes of xs
</code></pre>

    <ul>
        <li>No copying occurs — only the new head <code>0</code> is added.</li>
    </ul>
    <br/><br/>

    <li><b>Pattern Matching on Lists</b></li>
    <br/>
    <ul>
        <li>Lists have a simple recursive definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[]       -- empty list
x : xs   -- head :: tail
</code></pre>

    <br/>
    <ul>
        <li>This makes lists ideal for pattern matching:</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe []     = "empty"
describe (x:xs) = "head is " ++ show x
</code></pre>

    <br/>
    <ul>
        <li>Pattern matching on lists is the basis for most recursive algorithms in Haskell.</li>
    </ul>
    <br/><br/>

    <li><b>Higher-Order List Functions</b></li>
    <br/>
    <ul>
        <li>Haskell’s standard library provides many powerful list functions.</li>
        <li><code>map</code>: apply a function to each element</li>
    </ul>

<pre><code class="language-haskell line-numbers">map (*2) [1,2,3]  -- [2,4,6]
</code></pre>

    <br/>
    <ul>
        <li><code>filter</code>: keep elements that satisfy a predicate</li>
    </ul>

<pre><code class="language-haskell line-numbers">filter even [1,2,3,4]  -- [2,4]
</code></pre>

    <br/>
    <ul>
        <li><code>foldr</code>: reduce a list from the right</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldr (+) 0 [1,2,3]  -- 6
</code></pre>

    <br/>
    <ul>
        <li><code>foldl</code>: reduce a list from the left</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldl (+) 0 [1,2,3]  -- 6
</code></pre>

    <br/><br/>

    <li><b>Infinite Lists and Laziness</b></li>
    <br/>
    <ul>
        <li>One of Haskell’s superpowers: lists can be infinite!</li>
        <li>Because Haskell is lazy, values are computed only when needed.</li>
    </ul>

<pre><code class="language-haskell line-numbers">evens = [0,2..]     -- infinite list
take 5 evens        -- [0,2,4,6,8]
</code></pre>

    <ul>
        <li>This enables elegant definitions of sequences and streams.</li>
    </ul>
    <br/><br/>

    <li><b>Common Pitfalls</b></li>
    <br/>
    <ul>
        <li><b>head/tail on empty lists</b> cause runtime errors:</li>
    </ul>

<pre><code class="language-haskell line-numbers">head []     -- Exception
</code></pre>

    <br/>
    <ul>
        <li>Prefer pattern matching or safe variants like <code>headMay</code> from <code>safe</code> package.</li>
    </ul>

    <ul>
        <li>Beware of using <code>!!</code> too often (linear time access).</li>
        <li>Heavy list concatenation <code>++</code> inside loops can be slow — prefer <code>:</code> and build from the left.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-list-concatenation">List Concatenation in Haskell</h3>
<ol>
    <li><b>What Is List Concatenation?</b></li>
    <br/>
    <ul>
        <li><u>List concatenation</u> is the operation of joining two (or more) lists into a single list.</li>
        <li>In Haskell, concatenation is performed using the <code>++</code> operator.</li>
        <li>Type of <code>++</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(++) :: [a] -&gt; [a] -&gt; [a]
</code></pre>

    <br/>
    <ul>
        <li>Both operands must be lists of the same element type.</li>
        <li>The result is a new list containing all elements of the first list followed by all elements of the second.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Examples</b></li>
    <br/>
    <ul>
        <li>Concatenating two lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3] ++ [4,5]       -- [1,2,3,4,5]
"hi" ++ "!"            -- "hi!"
['a'] ++ ['b','c']     -- ['a','b','c']
</code></pre>

    <ul>
        <li><b>NOTE</b>: <code>String</code>s in Haskell are lists of characters (<code>[Char]</code>), so <code>++</code> works naturally on them.</li>
    </ul>
    <br/><br/>


    <li><b>Concatenating Multiple Lists</b></li>
    <br/>
    <ul>
        <li>Concatenating several lists is simply repeated application of <code>++</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1] ++ [2] ++ [3,4]     -- [1,2,3,4]
</code></pre>

    <br/>
    <ul>
        <li>You can also use <code>concat</code> to flatten a list of lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">concat [[1,2], [3], [4,5]]   -- [1,2,3,4,5]
concat ["hi", " ", "there"]  -- "hi there"
</code></pre>

    <br/><br/>


    <li><b>Performance Characteristics</b></li>
    <br/>
    <ul>
        <li>Lists in Haskell are linked lists (constructed via <code>:</code>), so concatenation is <b>linear in the length of the first list</b>.</li>
        <li>Specifically: <code>xs ++ ys</code> must traverse all elements of <code>xs</code> to attach <code>ys</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Slow pattern:
xs = [1..100000]
result = xs ++ [100001]   -- O(length xs)
</code></pre>

    <br/>
    <ul>
        <li><b>Best Practice:</b> Prefer placing the shorter list on the left side of <code>++</code> when possible.</li>
        <li>Better alternative for building long lists: use <code>:</code> repeatedly, then reverse at the end.</li>
    </ul>

<pre><code class="language-haskell line-numbers">buildSlow xs = xs ++ [1]         -- bad
buildFast xs = 1 : xs            -- good
</code></pre>

    <br/><br/>


    <li><b>How</b> <code>++</code> <b>Actually Works (Definition)</b></li>
    <br/>
    <ul>
        <li>The operator is defined recursively in the Prelude:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
</code></pre>

    <br/>
    <ul>
        <li>This explains the performance behavior:
            <ul>
                <li>The left list is walked until empty (base case),</li>
                <li>Then <code>ys</code> is attached.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Concatenating Strings</b></li>
    <br/>
    <ul>
        <li>Since <code>String = [Char]</code>, concatenation works the same:</li>
    </ul>

<pre><code class="language-haskell line-numbers">"Hello " ++ "World"      -- "Hello World"
['H'] ++ "askell"        -- "Haskell"
</code></pre>

    <br/>
    <ul>
        <li>However, for performance-sensitive text operations, alternatives like <b>Text</b> or <b>ByteString</b> are recommended.</li>
    </ul>
    <br/><br/>


    <li><b>Using</b> <code>concatMap</code> <b>for Mapping + Concatenation</b></li>
    <br/>
    <ul>
        <li><code>concatMap</code> applies a function that returns a list and then concatenates the results:</li>
    </ul>

<pre><code class="language-haskell line-numbers">concatMap (\x -&gt; [x,x]) [1,2,3]
-- [1,1,2,2,3,3]
</code></pre>

    <ul>
        <li>Equivalent to: <code>concat (map f xs)</code></li>
    </ul>
    <br/><br/>


    <li><b>Concatenation Using List Comprehensions</b></li>
    <br/>
    <ul>
        <li>List comprehensions produce lists, which may then be concatenated:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..3] ] ++ [ x | x &lt;- [4..6] ]
-- [1,2,3,4,5,6]
</code></pre>

    <br/>
    <ul>
        <li>Nested comprehensions can naturally produce a list of lists, which <code>concat</code> can flatten:</li>
    </ul>

<pre><code class="language-haskell line-numbers">concat [[ (x,y) | y &lt;- [1..3] ] | x &lt;- [1..2] ]
-- [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
</code></pre>

    <br/><br/>


    <li><b>Concatenation and Infinite Lists</b></li>
    <br/>
    <ul>
        <li>Because Haskell is lazy, <code>++</code> works with infinite lists as long as the left list is <b>finite</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3] ++ [4..]
-- [1,2,3,4,5,6,7,8,...]
</code></pre>

    <br/>
    <ul>
        <li>But if the left list is infinite:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..] ++ [999]
-- never reaches 999 (left list never ends)
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-list-comprehension">List Comprehension in Haskell</h3>
<ol>
    <li><b>What Are List Comprehensions?</b></li>
    <br/>
    <ul>
        <li>A <u>list comprehension</u> is a concise and expressive way to construct lists in Haskell.</li>
        <br/>
        <li>Inspired by mathematical set-builder notation, such as:
            <ul>
                <li>{ x² | x ∈ ℕ, x &lt; 10 }</li>
            </ul>
        </li>
        <br/>
        <li>General syntax:</li>
<pre><code class="language-haskell line-numbers">[ expression | qualifiers ]
</code></pre>
    <ul>
        <li><code>expression</code>: what values to produce</li>
        <li><code>qualifiers</code>: generators, filters, or let bindings</li>
    </ul>
    </ul>

    <br/><br/>

    <li><b>Basic List Comprehension</b></li>
    <br/>
    <ul>
        <li>The simplest form uses a generator:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x * 2 | x &lt;- [1,2,3] ]
-- [2,4,6]
</code></pre>

    <ul>
        <li>This reads: "for each <code>x</code> drawn from <code>[1,2,3]</code>, compute <code>x * 2</code>."</li>
    </ul>
    <br/><br/>

    <li><b>Generators</b></li>
    <br/>
    <ul>
        <li>A generator has the form <code>x &lt;- someList</code>.</li>
        <li>You can have multiple generators:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x, y) | x &lt;- [1,2], y &lt;- [10,20] ]
-- [(1,10),(1,20),(2,10),(2,20)]
</code></pre>

    <ul>
        <li>Multiple generators produce a Cartesian product.</li>
    </ul>
    <br/><br/>

    <li><b>Filters (Predicates)</b></li>
    <br/>
    <ul>
        <li>Filters restrict results by keeping only values that satisfy conditions.</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..10], even x ]
-- [2,4,6,8,10]
</code></pre>

    <br/>
    <ul>
        <li>Filters appear after generators and must evaluate to <code>Bool</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x,y) | x &lt;- [1..5], y &lt;- [1..5], x &lt; y ]
-- [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
</code></pre>

    <br/><br/>

    <li><b>Using</b> <code>let</code> <b>Bindings Inside Comprehensions</b></li>
    <br/>
    <ul>
        <li>You can define local variables using <code>let</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ area | r &lt;- [1..5], let area = pi * r^2 ]
-- [3.14,12.56,28.27,50.27,78.54]
</code></pre>

    <ul>
        <li>A <code>let</code> binding does not require an <code>in</code> clause inside a comprehension.</li>
    </ul>
    <br/><br/>

    <li><b>Combining Generators, Filters, and Let</b></li>
    <br/>
    <ul>
        <li>You can mix all three kinds of qualifiers seamlessly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x, y, z)
| x &lt;- [1..5]
, let y = x * 2
, z &lt;- [y..10]
, odd z
]
</code></pre>

    <br/><br/>

    <li><b>List Comprehensions as Map + Filter</b></li>
    <br/>
    <ul>
        <li>Many list comprehensions correspond directly to:</li>
    </ul>

<pre><code class="language-haskell line-numbers">map f (filter p xs)
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x*2 | x &lt;- [1..10], odd x ]
-- same as:
map (*2) (filter odd [1..10])
</code></pre>

    <br/><br/>

    <li><b>Nested Comprehensions</b></li>
    <br/>
    <ul>
        <li>Comprehensions can be nested to generate structured output:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ [ x*y | y &lt;- [1..3] ] | x &lt;- [1..3] ]
-- [[1,2,3],[2,4,6],[3,6,9]]
</code></pre>

    <ul>
        <li>This is especially common when constructing matrices or grids.</li>
    </ul>
    <br/><br/>

    <li><b>List Comprehensions and Strings</b></li>
    <br/>
    <ul>
        <li>Strings work naturally because <code>String = [Char]</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ toUpper c | c &lt;- "hello" ]
-- "HELLO"
</code></pre>

    <br/><br/>

    <li><b>Guards and Multiple Filters</b></li>
    <br/>
    <ul>
        <li>You can chain multiple conditions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..50], x `mod` 7 == 0, x &gt; 20 ]
-- [28,35,42,49]
</code></pre>

    <br/><br/>

    <li><b>Using</b> <code>if</code> <b>Expressions Inside Comprehensions</b></li>
    <br/>
    <ul>
        <li>Because the expression is unrestricted, you can use <code>if</code> statements to transform results:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ if even x then "even" else "odd" | x &lt;- [1..5] ]
-- ["odd","even","odd","even","odd"]
</code></pre>

    <br/><br/>

    <li><b>Flattening with</b> <code>concat</code> <b>and Comprehensions</b></li>
    <br/>
    <ul>
        <li>A list comprehension with multiple generators is equivalent to <code>concat</code> of mapped lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x,y) | x &lt;- [1..2], y &lt;- [1..2] ]
-- same as:
concat [ [ (x,y) | y &lt;- [1..2] ] | x &lt;- [1..2] ]
</code></pre>

    <br/><br/>

    <li><b>Infinite Lists and Laziness</b></li>
    <br/>
    <ul>
        <li>List comprehensions work naturally with infinite lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">take 10 [ x^2 | x &lt;- [1..] ]
-- [1,4,9,16,25,36,49,64,81,100]
</code></pre>

    <br/>
    <ul>
        <li>Laziness ensures values are computed only on demand.</li>
    </ul>
    <br/><br/>

    <li><b>Common Pitfalls</b></li>
    <br/>
    <ul>
        <li><b>Order of qualifiers matters</b>: Generators must appear before filters dependent on them.</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | even x, x &lt;- [1..10] ]
-- ERROR: x is used before its generator
</code></pre>

    <br/>
    <ul>
        <li>Correct version:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..10], even x ]
</code></pre>

    <ul>
        <li>Be careful when using multiple generators with infinite lists: Some comprehensions may fail to terminate.</li>
    </ul>
    <br/><br/>
</ol>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
