<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>HASKELL</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 28px;
        height: 28px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/haskell.png" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#haskell-intro">Introduction</a></li>
        <li><a href="#haskell-ghci">Using GHCi: The Interactive Haskell Environment</a></li>
        <li><a href="#haskell-comparison-operations">Comparison Operations</a></li>
        <li><a href="#haskell-lists-introduction">Lists Introduction</a></li>
        <li><a href="#haskell-list-concatenation">List Concatenation</a></li>
        <li><a href="#haskell-list-comprehension">List Comprehension</a></li>
        <li><a href="#haskell-tuples">Tuples</a></li>
        <li><a href="#haskell-types-typeclasses">Types and Typeclasses</a></li>
        <li><a href="#haskell-adts">ADTs</a></li>
        <li><a href="#haskell-typeclasses">Typeclasses</a></li>
        <li><a href="#haskell-pattern-matching">Pattern Matching</a></li>
        <li><a href="#haskell-guards">Guards</a></li>
        <li><a href="#haskell-built-in-types">Built-in Types</a></li>
        <li><a href="#haskell-import"><code>import</code></a></li>
        <li><a href="#haskell-higher-order-functions">Higher Order Functions</a></li>
        <li><a href="#haskell-lambdas">Lambdas</a></li>
        <li><a href="#haskell-modules">Modules</a></li>
        <li><a href="#haskell-deriving">Deriving Instances</a></li>
        <li><a href="#haskell-constraint-arrow">The <code>=></code> Operator (Constraint Arrow)</a></li>
        <li><a href="#haskell-kinds-star">Kinds <code>*</code> and <code>* -&gt; *</code> Operators</a></li>
        <li><a href="#haskell-io">Input and Output</a></li>
        <li><a href="#haskell-functor-applicative-monoid">Functors, Applicative Functors, and Monoids</a></li>
        <li><a href="#haskell-type-constructors">What Exactly Does <code>f a</code> (Type Constructor) Mean?</a></li>
        <li><a href="#haskell-monads">Monads</a></li>
        <li><a href="#haskell-zippers">Zippers</a></li>
        <li><a href="#haskell-let-in"><code>let ... in</code> Expressions</a></li>
        <li><a href="#haskell-do-notation"><code>do</code> Notation</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-intro">Introduction to Haskell</h3>
<ol>

    <li><b>What Is Haskell?</b></li>
    <br/>
    <ul>
        <li><u>Haskell</u> is a purely functional, statically typed programming language with:
            <ul>
                <li><b>no side effects by default</b></li>
                <li><b>lazy evaluation</b></li>
                <li>a <b>powerful type system</b> (type inference, typeclasses, algebraic data types)</li>
            </ul>
        </li>
        <br/>
        <li>It is named after the logician <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>.</li>
        <br/>
        <li>Haskell is used in:
            <ul>
                <li>finance</li>
                <li>compilers</li>
                <li>blockchain (e.g., Cardano)</li>
                <li>research</li>
                <li>formal verification</li>
            </ul>
        </li>
        <br/>
        <li>Haskell encourages a <u>mathematical, declarative style</u> of programming.</li>
    </ul>

    <br/><br/>


    <li><b>Key Features of Haskell</b></li>
    <br/>
    <ol>
        <li><b>Pure Functional Programming</b></li>
        <ul>
            <li>Functions have no side effects:
                <ul>
                    <li>no global variables</li>
                    <li>no random mutations</li>
                    <li>same input → same output forever</li>
                </ul>
            </li>
            <li>This makes reasoning and testing easier.</li>
        </ul>

        <br/>

        <li><b>Lazy Evaluation</b></li>
        <ul>
            <li>Expressions are evaluated only when needed.</li>
            <li>This enables:
                <ul>
                    <li>infinite lists</li>
                    <li>performance optimization</li>
                </ul>
            </li>
        </ul>

        <br/>

        <li><b>Static Strong Typing with Type Inference</b></li>
        <ul>
            <li>You rarely write types manually—Haskell infers them.</li>
            <li>Compiler catches many errors at compile time.</li>
        </ul>

        <br/>

        <li><b>Typeclasses</b></li>
        <ul>
            <li>They define behavior that types must implement.</li>
            <li>Similar to Rust traits or Java interfaces.</li>
        </ul>

        <br/>

        <li><b>Algebraic Data Types (ADTs)</b></li>
        <ul>
            <li>Powerful ways to model data structures.</li>
            <li>Variants, recursion, pattern matching.</li>
        </ul>

        <br/>

        <li><b>Monads & Pure I/O</b></li>
        <ul>
            <li>Haskell keeps side effects in controlled “containers.”</li>
            <li>The most famous example → <b>IO Monad</b>.</li>
        </ul>
    </ol>

    <br/><br/>


    <li><b>Basic Syntax</b></li>
    <br/>
    <ul>
        <li>Python example:</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    return a + b
</code></pre>

    <ul>
        <li>Haskell equivalent:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add a b = a + b
</code></pre>

    <ul>
        <li>Notice:
            <ul>
                <li>No parentheses</li>
                <li>No commas</li>
                <li>No return keyword</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Functions Are First-Class</b></li>
    <br/>
    <ul>
        <li>You can pass functions as arguments or return them.</li>
    </ul>

<pre><code class="language-haskell line-numbers">applyTwice f x = f (f x)</code></pre>

    <ul>
        <li>A function <code>f</code> applied two times to <code>x</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Type Annotations (Optional)</b></li>
    <br/>
    <ul>
        <li>Haskell infers types, but you can write them explicitly:</li>
    </ul>
<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add a b = a + b
</code></pre>

    <ul>
        <li>This says:
            <ul>
                <li>Add takes two Ints</li>
                <li>Returns an Int</li>
            </ul>
        </li>
        <li>Arrow <code>-&gt;</code> separates parameters.</li>
    </ul>

    <br/><br/>


    <li><b>Immutable Variables</b></li>
    <br/>
    <ul>
        <li>Variables cannot change after assignment.</li>
        <li>This is a core principle of functional programming.</li>
    </ul>

<pre><code class="language-haskell line-numbers">x = 10
-- x = 20   -- INVALID
</code></pre>

    <br/><br/>


    <li><b>Lists</b></li>

<pre><code class="language-haskell line-numbers">nums = [1, 2, 3, 4]</code></pre>

    <ul>
        <li>All elements must be the same type.</li>
        <li>List comprehension:</li>
    </ul>

<pre><code class="language-haskell line-numbers">squares = [x * x | x &lt;- [1..5]]</code></pre>

    <br/><br/>


    <li><b>Pattern Matching</b></li>
    <br/>
    <ul>
        <li>A superpower in Haskell, similar to Rust.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe :: Int -&gt; String
describe 0 = "Zero"
describe 1 = "One"
describe _ = "Other number"
</code></pre>

    <ul><li><code>_</code> is the catch-all (like Rust).</li></ul>

    <br/><br/>


    <li><b>Recursion (Fundamental in Haskell)</b></li>

<pre><code class="language-haskell line-numbers">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
</code></pre>

    <ul>
        <li>Loops are less common; you use recursion or higher-order functions.</li>
    </ul>

    <br/><br/>


    <li><b>Higher-Order Functions</b></li>

<pre><code class="language-haskell line-numbers">doubleAll xs = map (\x -&gt; x * 2) xs</code></pre>

    <ul>
        <li><code>map</code>, <code>filter</code>, and <code>foldr</code> are essential tools.</li>
    </ul>

    <br/><br/>


    <li><b>Typeclasses (Extremely Important)</b></li>
    <br/>
    <ul>
        <li>A typeclass defines behavior.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
</code></pre>

    <ul>
        <li>Instances implement that behavior:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Blue

instance Eq Color where
    Red == Red = True
    Blue == Blue = True
    _ == _ = False
</code></pre>

    <br/><br/>


    <li><b>Algebraic Data Types (ADTs)</b></li>
    <br/>
    <ul>
        <li>One of Haskell’s most beloved features.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Shape
    = Circle Float
    | Rectangle Float Float
</code></pre>

    <ul>
        <li>Pattern matching on ADTs is extremely expressive:</li>
    </ul>

<pre><code class="language-haskell line-numbers">area :: Shape -&gt; Float
area (Circle r) = pi * r * r
area (Rectangle w h) = w * h
</code></pre>

    <br/><br/>


    <li><b>The IO Monad (Side Effects in Haskell)</b></li>
    <br/>
    <ul>
        <li>Because Haskell is pure, side effects cannot be done normally.</li>
        <li>Instead, Haskell uses the <code>IO Monad</code> to contain and sequence effects.</li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    putStrLn "Hello!"
    name &lt;- getLine
    putStrLn ("Hi, " ++ name)
</code></pre>

    <br/><br/>


    <li><b>Lazy Evaluation and Infinite Lists</b></li>
    <br/>
    <ul>
        <li>You can create infinite sequences:</li>
    </ul>

<pre><code class="language-haskell line-numbers">naturals = [1..]    -- infinite list!</code></pre>

    <ul>
        <li>Lazy evaluation makes this safe:</li>
    </ul>

<pre><code class="language-haskell line-numbers">take 5 naturals   -- [1,2,3,4,5]</code></pre>

    <br/><br/>


    <li><b>How to Get Started</b></li>
    <br/>
    <ul>
        <li>Install GHC (compiler) and Stack or Cabal (build tool):</li>
    </ul>

<pre><code class="language-bash line-numbers">sudo apt install ghc cabal-install
# OR
curl -sSL https://get.haskellstack.org/ | sh
</code></pre>

    <ul>
        <li>Run REPL (GHCI):</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci</code></pre>

    <ul>
        <li>Create a new project (Stack):</li>
    </ul>

<pre><code class="language-bash line-numbers">stack new myproject
cd myproject
stack run
</code></pre>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-ghci">Using GHCi: The Interactive Haskell Environment</h3>
<ol>

    <li><b>What Is GHCi?</b></li>
    <br/>
    <ul>
        <li><b>GHCi</b> (Glasgow Haskell Compiler interactive) is Haskell’s interactive REPL:</li>
        <ul>
            <li>runs Haskell expressions immediately</li>
            <li>loads modules and files</li>
            <li>tests functions without compiling a full project</li>
            <li>inspects types, evaluates expressions, debugs code</li>
            <li>ideal for learning, experimenting, and prototyping</li>
        </ul>
        <br/>
        <li>GHCi comes bundled with GHC, Stack, and Cabal.</li>
    </ul>

    <br/><br/>


    <li><b>Starting GHCi</b></li>
    <br/>
    <ul>
        <li>Simply run:</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci
</code></pre>

    <ul>
        <li>You will see a prompt like:</li>
    </ul>

<pre><code class="language-text line-numbers">GHCi, version 9.x.x: http://www.haskell.org/ghc/  :? for help
Prelude&gt;
</code></pre>

    <ul>
        <li>Now you can type Haskell expressions directly.</li>
    </ul>

    <br/><br/>


    <li><b>Evaluating Expressions</b></li>
    <br/>
    <ul>
        <li>GHCi acts like a calculator:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; 2 + 3 * 4
14

Prelude&gt; take 5 [1..]
[1,2,3,4,5]
</code></pre>

    <ul>
        <li>Expressions can be arbitrarily complex:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; map (*2) [1..10]
[2,4,6,8,10,12,14,16,18,20]
</code></pre>

    <br/><br/>


    <li><b>Checking Types with</b> <code>:type</code> <b>or</b> <code>:t</code></b></li>
    <br/>
    <ul>
        <li>GHCi’s type inspection is one of its greatest strengths.</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :t 42
42 :: Num a =&gt; a

Prelude&gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>

    <ul>
        <li>Useful for learning Haskell’s type system.</li>
    </ul>

    <br/><br/>


    <li><b>Loading Haskell Files</b></li>
    <br/>
    <ul>
        <li>You can load a file (e.g., <code>mycode.hs</code>):</li>
    </ul>

<pre><code class="language-bash line-numbers">ghci mycode.hs
</code></pre>

    <ul>
        <li>Inside GHCi you can reload after edits using:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :reload
-- or shorthand:
Prelude&gt; :r
</code></pre>

    <ul>
        <li>Useful workflow:
            <ul>
                <li>edit code in editor</li>
                <li>reload in GHCi</li>
                <li>test functions live</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Running Main</b></li>
    <br/>
    <ul>
        <li>If a file defines <code>main :: IO ()</code> in a module, GHCi can run it:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :main
</code></pre>

    <ul>
        <li>You can pass arguments too:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :main 10 20
</code></pre>

    <br/><br/>


    <li><b>Using</b> <code>let</code> <b>to Define Local Bindings</b></li>
    <br/>
    <ul>
        <li>Inside GHCi, use <code>let</code> to define values:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; let x = 10
Prelude&gt; x * 2
20
</code></pre>

    <ul>
        <li>You can also define functions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; let square n = n * n
Prelude&gt; square 7
49
</code></pre>

    <br/><br/>


    <li><b>Browsing Loaded Modules</b></li>
    <br/>
    <ul>
        <li>List loaded modules:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :show modules
</code></pre>

    <ul>
        <li>List functions in the current module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :browse
</code></pre>

    <ul>
        <li>Browse a specific module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :browse Data.List
</code></pre>

    <br/><br/>


    <li><b>Reloading Automatically</b></li>
    <br/>
    <ul>
        <li>Enable auto-reload when files change:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :set -fobject-code
Prelude&gt; :set -fdefer-type-errors
Prelude&gt; :set -package mtl
</code></pre>

    <ul>
        <li>Or reload manually:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :reload
</code></pre>

    <br/><br/>


    <li><b>Importing Modules</b></li>
    <br/>
    <ul>
        <li>You can import modules directly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; import Data.List
Prelude Data.List&gt;
</code></pre>

    <ul>
        <li>Qualified import:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; import qualified Data.Map as M
Prelude&gt; M.fromList [(1,"a"), (2,"b")]
fromList [(1,"a"),(2,"b")]
</code></pre>

    <br/><br/>


    <li><b>Loading Multiple Files</b></li>
    <br/>
    <ul>
        <li>GHCi understands projects with multiple modules:</li>
    </ul>

<pre><code class="language-haskell line-numbers">ghci Main.hs Utils.hs Types.hs
</code></pre>

    <ul>
        <li>Or load an entire directory using <code>:set</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :set -i src
</code></pre>

    <br/><br/>


    <li><b>Debugging with GHCi</b></li>
    <br/>
    <ul>
        <li>GHCi includes a debugger:</li>
        <ul>
            <li>set breakpoints</li>
            <li>step through evaluation</li>
            <li>inspect variables</li>
        </ul>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :break myFunction
Prelude&gt; :trace main
Prelude&gt; :history
Prelude&gt; :continue
</code></pre>

    <br/><br/>


    <li><b>Useful GHCi Commands</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>:t expr</code></td>
                <td>Show the type of an expression</td>
            </tr>
            <tr>
                <td><code>:i name</code></td>
                <td>Show info about a type or function</td>
            </tr>
            <tr>
                <td><code>:l file</code></td>
                <td>Load a file</td>
            </tr>
            <tr>
                <td><code>:r</code></td>
                <td>Reload current modules</td>
            </tr>
            <tr>
                <td><code>:main</code></td>
                <td>Run the <code>main</code> function</td>
            </tr>
            <tr>
                <td><code>:q</code></td>
                <td>Quit GHCi</td>
            </tr>
            <tr>
                <td><code>:set -XExtension</code></td>
                <td>Enable language extensions</td>
            </tr>
            <tr>
                <td><code>:browse</code></td>
                <td>List contents of current module</td>
            </tr>
            <tr>
                <td><code>:module + Data.Map</code></td>
                <td>Temporarily import a module</td>
            </tr>
            <tr>
                <td><code>:set prompt "ghci&gt;"</code></td>
                <td>Customize the prompt based on your taste</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li>GHCi is Haskell’s interactive environment — powerful for learning and development.</li>
        <li>Helps evaluate expressions, inspect types, load modules, and debug programs.</li>
        <li>Common uses include:
            <ul>
                <li>testing functions quickly</li>
                <li>experimenting with the type system</li>
                <li>loading and reloading project files</li>
                <li>interactive debugging</li>
                <li>prototype-driven development</li>
            </ul>
        </li>
        <li>Mastering GHCi greatly improves Haskell productivity.</li>
    </ul>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-comparison-operations">Comparison Operations in Haskell</h3>
<ol>
    <li><b>What Are Comparison Operations?</b></li>
    <br/>
    <ul>
        <li>Comparison operations in Haskell determine the <u>ordering</u> and <u>equality</u> relationships between values.</li>
        <br/>
        <li>They are provided mainly by two important typeclasses:
            <ul>
                <li><code>Eq</code> — supports equality / inequality</li>
                <li><code>Ord</code> — supports ordering (less than, greater than, etc.)</li>
            </ul>
        </li>
        <br/>
        <li>Comparison is always <u>type-safe</u>: you can only compare values whose types implement these typeclasses.</li>
        <br/>
        <li>Many built-in types (<code>Int</code>, <code>Float</code>, <code>Bool</code>, <code>Char</code>, <code>List</code>, <code>Tuple</code>, etc.) already derive <code>Eq</code> and <code>Ord</code>.</li>
    </ul>
    <br/><br/>

    <li><b>The</b> <code>Eq</code> <b>Typeclass: Equality</b></li>
    <br/>
    <ul>
        <li><code>Eq</code> defines two operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
(/=) :: Eq a =&gt; a -&gt; a -&gt; Bool
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">5 == 5          -- True
5 /= 3          -- True
'a' == 'b'      -- False
[1,2] == [1,2]  -- True
</code></pre>

    <br/>
    <ul>
        <li>If a type implements <code>Eq</code>, it must satisfy:
            <ul>
                <li><b>Reflexive</b>: x == x == True</li>
                <li><b>Symmetric</b>: if x == y then y == x</li>
                <li><b>Transitive</b>: if x == y and y == z then x == z</li>
            </ul>
        </li>
        <br/>
        <li>These mathematical guarantees make reasoning about comparisons reliable.</li>
    </ul>
    <br/><br/>

    <li><b>The</b> <code>Ord</code> <b>Typeclass: Ordering</b></li>
    <br/>
    <ul>
        <li><code>Ord</code> defines ordering functions. A type must be <code>Eq</code> before it can be <code>Ord</code>.</li>
        <li>Important operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(&lt;)  :: Ord a =&gt; a -&gt; a -&gt; Bool
(&gt;)  :: Ord a =&gt; a -&gt; a -&gt; Bool
(&lt;=) :: Ord a =&gt; a -&gt; a -&gt; Bool
(&gt;=) :: Ord a =&gt; a -&gt; a -&gt; Bool
compare :: Ord a =&gt; a -&gt; a -&gt; Ordering
</code></pre>

    <br/>
    <ul>
        <li><code>Ordering</code> is a simple type:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Ordering = LT | EQ | GT
</code></pre>

    <br/>
    <ul>
        <li>Example usage:</li>
    </ul>

<pre><code class="language-haskell line-numbers">3 &lt; 5        -- True
"hi" &gt; "ha"  -- True (lexicographical)
compare 10 7 -- GT
</code></pre>

    <br/>
    <ul>
        <li><code>Ord</code> must satisfy total ordering rules:
            <ul>
                <li>No contradictions (x &lt; y and y &lt; x cannot both be true)</li>
                <li>Transitivity</li>
                <li>Totality: for any x, y exactly one of:
                    <ul>
                        <li>x &lt; y</li>
                        <li>x == y</li>
                        <li>x &gt; y</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <br/><br/>

    <li><b>Comparing Basic Types</b></li>
    <br/>
    <ul>
        <li>All primitive types implement <code>Eq</code> and <code>Ord</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">True &lt; False      -- False
'A' &lt; 'a'         -- True (ASCII/Unicode ordering)
1.0 == 1.0        -- True
2.3 &gt;= 2.1        -- True
</code></pre>

    <br/>
    <ul>
        <li><b>Lists</b> compare lexicographically:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3] &lt; [1,2,4]     -- True
"abc" &gt; "abb"         -- True
</code></pre>

    <br/>
    <ul>
        <li><b>Tuples</b> also compare lexicographically (element by element):</li>
    </ul>

<pre><code class="language-haskell line-numbers">(3, "x") &lt; (3, "y")   -- True
(2, 5) &gt; (1, 100)      -- True
</code></pre>

    <br/><br/>

    <li><b>Using</b> <code>max</code>, <code>min</code>, <code>compare</code></li>
    <br/>
    <ul>
        <li>Because <code>Ord</code> is defined, many utilities work automatically:</li>
    </ul>

<pre><code class="language-haskell line-numbers">max 3 10            -- 10
min "apple" "dog"   -- "apple"
compare 1 1         -- EQ
</code></pre>

    <br/><br/>

    <li><b>Sort Using Comparison</b></li>
    <br/>
    <ul>
        <li><code>sort</code> uses <code>Ord</code> to determine ordering:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List (sort)

sort [3,1,4,1]          -- [1,1,3,4]
sort ["z", "b", "aa"]   -- ["aa","b","z"]
</code></pre>

    <br/><br/>

    <li><b>Deriving</b> <code>Eq</code>, <code>Ord</code> <b>for Custom Types</b></li>
    <br/>
    <ul>
        <li>You can automatically derive comparison operations for your own data types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue
  deriving (Eq, Ord, Show)

Red &lt; Blue   -- True (ordering = definition order)
</code></pre>

    <br/>
    <ul>
        <li>For more complex types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Point = Point Int Int
  deriving (Eq, Ord, Show)

Point 1 3 &lt; Point 1 4   -- True (lexicographic)
</code></pre>

    <br/><br/>

    <li><b>Custom Comparison Logic</b></li>
    <br/>
    <ul>
        <li>You can manually implement <code>Eq</code> or <code>Ord</code> to override behavior:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Person = Person { name :: String, age :: Int }

instance Eq Person where
    p1 == p2 = age p1 == age p2

instance Ord Person where
    compare p1 p2 = compare (age p1) (age p2)
</code></pre>

    <ul>
        <li>Now persons compare by <b>age only</b>, ignoring the name.</li>
    </ul>

    <br/><br/>

    <li><b>Chaining Comparisons Using</b> <code>Ordering</code></li>
    <br/>
    <ul>
        <li>Sometimes you want to compare multiple fields manually:</li>
    </ul>

<pre><code class="language-haskell line-numbers">comparePoints (x1,y1) (x2,y2) =
    compare x1 x2 &lt;&gt; compare y1 y2
</code></pre>

    <br/>
    <ul>
        <li><code>(&lt;&gt;)</code> is monoid append for <code>Ordering</code>:
            <ul>
                <li><code>EQ</code> continues comparison</li>
                <li><code>LT</code> or <code>GT</code> stops immediately</li>
            </ul>
        </li>
    </ul>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-lists-introduction">Introduction to Lists in Haskell</h3>
<ol>
    <li><b>What Are Lists in Haskell?</b></li>
    <br/>
    <ul>
        <li>Lists are one of the most fundamental and commonly used data structures in Haskell.</li>
        <br/>
        <li>A list is a <b>homogeneous</b> collection of elements:
            <ul>
                <li>every element must have the same type,</li>
                <li>the list itself has type <code>[T]</code> where <code>T</code> is the element type.</li>
            </ul>
        </li>
        <br/>
        <li>Lists are <b>linked structures</b>, not arrays:
            <ul>
                <li>fast at prepending (O(1)),</li>
                <li>slow at indexing (O(n)).</li>
            </ul>
        </li>
        <br/>
        <li>Examples of list types:
            <ul>
                <li><code>[Int]</code> — list of integers</li>
                <li><code>[Char]</code> — list of characters</li>
                <li><code>[[Int]]</code> — list of lists</li>
            </ul>
        </li>
        <br/>
        <li>Haskell lists are <b>immutable</b> — once built, they cannot be modified.</li>
    </ul>
    <br/><br/>

    <li><b>Creating Lists</b></li>
    <br/>
    <ul>
        <li>The simplest way is using square brackets:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3]
['a','b','c']
["hello", "world"]
</code></pre>

    <br/>
    <ul>
        <li>Lists can also be constructed using the <code>:</code> operator (cons):</li>
    </ul>

<pre><code class="language-haskell line-numbers">1 : 2 : 3 : []      -- equals [1,2,3]
'a' : 'b' : []      -- equals ['a','b']
</code></pre>

    <br/>
    <ul>
        <li><code>:</code> attaches a single element to the front of a list.</li>
        <li>The empty list is written as <code>[]</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Strings Are Lists of Characters</b></li>
    <br/>
    <ul>
        <li>In Haskell, <code>String</code> is just a type alias for <code>[Char]</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">"hello" == ['h','e','l','l','o']  -- True
</code></pre>

    <ul>
        <li>This makes string manipulation consistent with list operations.</li>
    </ul>
    <br/><br/>

    <li><b>List Ranges and Sequences</b></li>
    <br/>
    <ul>
        <li>Haskell supports a compact syntax for sequences:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..5]         -- [1,2,3,4,5]
['a'..'e']     -- ['a','b','c','d','e']
[0,2..10]      -- [0,2,4,6,8,10] (step of 2)
</code></pre>

    <br/>
    <ul>
        <li>For infinite lists (lazy evaluation):</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..]          -- infinite list of natural numbers
take 5 [1..]   -- [1,2,3,4,5]
</code></pre>

    <br/><br/>

    <li><b>Basic List Operations</b></li>
    <br/>
    <ul>
        <li>Head (first element):</li>
    </ul>

<pre><code class="language-haskell line-numbers">head [1,2,3]    -- 1
</code></pre>

    <br/>
    <ul>
        <li>Tail (everything except the first element):</li>
    </ul>

<pre><code class="language-haskell line-numbers">tail [1,2,3]    -- [2,3]
</code></pre>

    <br/>
    <ul>
        <li>Last element:</li>
    </ul>

<pre><code class="language-haskell line-numbers">last [1,2,3]    -- 3
</code></pre>

    <br/>
    <ul>
        <li>Length:</li>
    </ul>

<pre><code class="language-haskell line-numbers">length [1,2,3]  -- 3
</code></pre>

    <br/>
    <ul>
        <li>Indexing (0-based):</li>
    </ul>

<pre><code class="language-haskell line-numbers">[10,20,30] !! 1  -- 20
</code></pre>

    <br/>
    <ul>
        <li>List concatenation:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2] ++ [3,4]   -- [1,2,3,4]
</code></pre>

    <br/>
    <ul>
        <li>Prepending with <code>:</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">5 : [6,7]   -- [5,6,7]
</code></pre>

    <br/><br/>

    <li><b>Immutable Structure and Sharing</b></li>
    <br/>
    <ul>
        <li>Lists are immutable; any “modification” creates a new list.</li>
        <li>However, Haskell shares memory efficiently via pointers:</li>
    </ul>

<pre><code class="language-haskell line-numbers">let xs = [1,2,3]
let ys = 0 : xs     -- shares tail nodes of xs
</code></pre>

    <ul>
        <li>No copying occurs — only the new head <code>0</code> is added.</li>
    </ul>
    <br/><br/>

    <li><b>Pattern Matching on Lists</b></li>
    <br/>
    <ul>
        <li>Lists have a simple recursive definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[]       -- empty list
x : xs   -- head :: tail
</code></pre>

    <br/>
    <ul>
        <li>This makes lists ideal for pattern matching:</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe []     = "empty"
describe (x:xs) = "head is " ++ show x
</code></pre>

    <br/>
    <ul>
        <li>Pattern matching on lists is the basis for most recursive algorithms in Haskell.</li>
    </ul>
    <br/><br/>

    <li><b>Higher-Order List Functions</b></li>
    <br/>
    <ul>
        <li>Haskell’s standard library provides many powerful list functions.</li>
        <li><code>map</code>: apply a function to each element</li>
    </ul>

<pre><code class="language-haskell line-numbers">map (*2) [1,2,3]  -- [2,4,6]
</code></pre>

    <br/>
    <ul>
        <li><code>filter</code>: keep elements that satisfy a predicate</li>
    </ul>

<pre><code class="language-haskell line-numbers">filter even [1,2,3,4]  -- [2,4]
</code></pre>

    <br/>
    <ul>
        <li><code>foldr</code>: reduce a list from the right</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldr (+) 0 [1,2,3]  -- 6
</code></pre>

    <br/>
    <ul>
        <li><code>foldl</code>: reduce a list from the left</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldl (+) 0 [1,2,3]  -- 6
</code></pre>

    <br/><br/>

    <li><b>Infinite Lists and Laziness</b></li>
    <br/>
    <ul>
        <li>One of Haskell’s superpowers: lists can be infinite!</li>
        <li>Because Haskell is lazy, values are computed only when needed.</li>
    </ul>

<pre><code class="language-haskell line-numbers">evens = [0,2..]     -- infinite list
take 5 evens        -- [0,2,4,6,8]
</code></pre>

    <ul>
        <li>This enables elegant definitions of sequences and streams.</li>
    </ul>
    <br/><br/>

    <li><b>Common Pitfalls</b></li>
    <br/>
    <ul>
        <li><b>head/tail on empty lists</b> cause runtime errors:</li>
    </ul>

<pre><code class="language-haskell line-numbers">head []     -- Exception
</code></pre>

    <br/>
    <ul>
        <li>Prefer pattern matching or safe variants like <code>headMay</code> from <code>safe</code> package.</li>
    </ul>

    <ul>
        <li>Beware of using <code>!!</code> too often (linear time access).</li>
        <li>Heavy list concatenation <code>++</code> inside loops can be slow — prefer <code>:</code> and build from the left.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-list-concatenation">List Concatenation in Haskell</h3>
<ol>
    <li><b>What Is List Concatenation?</b></li>
    <br/>
    <ul>
        <li><u>List concatenation</u> is the operation of joining two (or more) lists into a single list.</li>
        <li>In Haskell, concatenation is performed using the <code>++</code> operator.</li>
        <li>Type of <code>++</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(++) :: [a] -&gt; [a] -&gt; [a]
</code></pre>

    <br/>
    <ul>
        <li>Both operands must be lists of the same element type.</li>
        <li>The result is a new list containing all elements of the first list followed by all elements of the second.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Examples</b></li>
    <br/>
    <ul>
        <li>Concatenating two lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3] ++ [4,5]       -- [1,2,3,4,5]
"hi" ++ "!"            -- "hi!"
['a'] ++ ['b','c']     -- ['a','b','c']
</code></pre>

    <ul>
        <li><b>NOTE</b>: <code>String</code>s in Haskell are lists of characters (<code>[Char]</code>), so <code>++</code> works naturally on them.</li>
    </ul>
    <br/><br/>


    <li><b>Concatenating Multiple Lists</b></li>
    <br/>
    <ul>
        <li>Concatenating several lists is simply repeated application of <code>++</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1] ++ [2] ++ [3,4]     -- [1,2,3,4]
</code></pre>

    <br/>
    <ul>
        <li>You can also use <code>concat</code> to flatten a list of lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">concat [[1,2], [3], [4,5]]   -- [1,2,3,4,5]
concat ["hi", " ", "there"]  -- "hi there"
</code></pre>

    <br/><br/>


    <li><b>Performance Characteristics</b></li>
    <br/>
    <ul>
        <li>Lists in Haskell are linked lists (constructed via <code>:</code>), so concatenation is <b>linear in the length of the first list</b>.</li>
        <li>Specifically: <code>xs ++ ys</code> must traverse all elements of <code>xs</code> to attach <code>ys</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Slow pattern:
xs = [1..100000]
result = xs ++ [100001]   -- O(length xs)
</code></pre>

    <br/>
    <ul>
        <li><b>Best Practice:</b> Prefer placing the shorter list on the left side of <code>++</code> when possible.</li>
        <li>Better alternative for building long lists: use <code>:</code> repeatedly, then reverse at the end.</li>
    </ul>

<pre><code class="language-haskell line-numbers">buildSlow xs = xs ++ [1]         -- bad
buildFast xs = 1 : xs            -- good
</code></pre>

    <br/><br/>


    <li><b>How</b> <code>++</code> <b>Actually Works (Definition)</b></li>
    <br/>
    <ul>
        <li>The operator is defined recursively in the Prelude:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
</code></pre>

    <br/>
    <ul>
        <li>This explains the performance behavior:
            <ul>
                <li>The left list is walked until empty (base case),</li>
                <li>Then <code>ys</code> is attached.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Concatenating Strings</b></li>
    <br/>
    <ul>
        <li>Since <code>String = [Char]</code>, concatenation works the same:</li>
    </ul>

<pre><code class="language-haskell line-numbers">"Hello " ++ "World"      -- "Hello World"
['H'] ++ "askell"        -- "Haskell"
</code></pre>

    <br/>
    <ul>
        <li>However, for performance-sensitive text operations, alternatives like <b>Text</b> or <b>ByteString</b> are recommended.</li>
    </ul>
    <br/><br/>


    <li><b>Using</b> <code>concatMap</code> <b>for Mapping + Concatenation</b></li>
    <br/>
    <ul>
        <li><code>concatMap</code> applies a function that returns a list and then concatenates the results:</li>
    </ul>

<pre><code class="language-haskell line-numbers">concatMap (\x -&gt; [x,x]) [1,2,3]
-- [1,1,2,2,3,3]
</code></pre>

    <ul>
        <li>Equivalent to: <code>concat (map f xs)</code></li>
    </ul>
    <br/><br/>


    <li><b>Concatenation Using List Comprehensions</b></li>
    <br/>
    <ul>
        <li>List comprehensions produce lists, which may then be concatenated:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..3] ] ++ [ x | x &lt;- [4..6] ]
-- [1,2,3,4,5,6]
</code></pre>

    <br/>
    <ul>
        <li>Nested comprehensions can naturally produce a list of lists, which <code>concat</code> can flatten:</li>
    </ul>

<pre><code class="language-haskell line-numbers">concat [[ (x,y) | y &lt;- [1..3] ] | x &lt;- [1..2] ]
-- [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
</code></pre>

    <br/><br/>


    <li><b>Concatenation and Infinite Lists</b></li>
    <br/>
    <ul>
        <li>Because Haskell is lazy, <code>++</code> works with infinite lists as long as the left list is <b>finite</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3] ++ [4..]
-- [1,2,3,4,5,6,7,8,...]
</code></pre>

    <br/>
    <ul>
        <li>But if the left list is infinite:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..] ++ [999]
-- never reaches 999 (left list never ends)
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-list-comprehension">List Comprehension in Haskell</h3>
<ol>
    <li><b>What Are List Comprehensions?</b></li>
    <br/>
    <ul>
        <li>A <u>list comprehension</u> is a concise and expressive way to construct lists in Haskell.</li>
        <br/>
        <li>Inspired by mathematical set-builder notation, such as:
            <ul>
                <li>{ x² | x ∈ ℕ, x &lt; 10 }</li>
            </ul>
        </li>
        <br/>
        <li>General syntax:</li>
<pre><code class="language-haskell line-numbers">[ expression | qualifiers ]
</code></pre>
    <ul>
        <li><code>expression</code>: what values to produce</li>
        <li><code>qualifiers</code>: generators, filters, or let bindings</li>
    </ul>
    </ul>

    <br/><br/>

    <li><b>Basic List Comprehension</b></li>
    <br/>
    <ul>
        <li>The simplest form uses a generator:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x * 2 | x &lt;- [1,2,3] ]
-- [2,4,6]
</code></pre>

    <ul>
        <li>This reads: "for each <code>x</code> drawn from <code>[1,2,3]</code>, compute <code>x * 2</code>."</li>
    </ul>
    <br/><br/>

    <li><b>Generators</b></li>
    <br/>
    <ul>
        <li>A generator has the form <code>x &lt;- someList</code>.</li>
        <li>You can have multiple generators:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x, y) | x &lt;- [1,2], y &lt;- [10,20] ]
-- [(1,10),(1,20),(2,10),(2,20)]
</code></pre>

    <ul>
        <li>Multiple generators produce a Cartesian product.</li>
    </ul>
    <br/><br/>

    <li><b>Filters (Predicates)</b></li>
    <br/>
    <ul>
        <li>Filters restrict results by keeping only values that satisfy conditions.</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..10], even x ]
-- [2,4,6,8,10]
</code></pre>

    <br/>
    <ul>
        <li>Filters appear after generators and must evaluate to <code>Bool</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x,y) | x &lt;- [1..5], y &lt;- [1..5], x &lt; y ]
-- [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
</code></pre>

    <br/><br/>

    <li><b>Using</b> <code>let</code> <b>Bindings Inside Comprehensions</b></li>
    <br/>
    <ul>
        <li>You can define local variables using <code>let</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ area | r &lt;- [1..5], let area = pi * r^2 ]
-- [3.14,12.56,28.27,50.27,78.54]
</code></pre>

    <ul>
        <li>A <code>let</code> binding does not require an <code>in</code> clause inside a comprehension.</li>
    </ul>
    <br/><br/>

    <li><b>Combining Generators, Filters, and Let</b></li>
    <br/>
    <ul>
        <li>You can mix all three kinds of qualifiers seamlessly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x, y, z)
| x &lt;- [1..5]
, let y = x * 2
, z &lt;- [y..10]
, odd z
]
</code></pre>

    <br/><br/>

    <li><b>List Comprehensions as Map + Filter</b></li>
    <br/>
    <ul>
        <li>Many list comprehensions correspond directly to:</li>
    </ul>

<pre><code class="language-haskell line-numbers">map f (filter p xs)
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x*2 | x &lt;- [1..10], odd x ]
-- same as:
map (*2) (filter odd [1..10])
</code></pre>

    <br/><br/>

    <li><b>Nested Comprehensions</b></li>
    <br/>
    <ul>
        <li>Comprehensions can be nested to generate structured output:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ [ x*y | y &lt;- [1..3] ] | x &lt;- [1..3] ]
-- [[1,2,3],[2,4,6],[3,6,9]]
</code></pre>

    <ul>
        <li>This is especially common when constructing matrices or grids.</li>
    </ul>
    <br/><br/>

    <li><b>List Comprehensions and Strings</b></li>
    <br/>
    <ul>
        <li>Strings work naturally because <code>String = [Char]</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ toUpper c | c &lt;- "hello" ]
-- "HELLO"
</code></pre>

    <br/><br/>

    <li><b>Guards and Multiple Filters</b></li>
    <br/>
    <ul>
        <li>You can chain multiple conditions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..50], x `mod` 7 == 0, x &gt; 20 ]
-- [28,35,42,49]
</code></pre>

    <br/><br/>

    <li><b>Using</b> <code>if</code> <b>Expressions Inside Comprehensions</b></li>
    <br/>
    <ul>
        <li>Because the expression is unrestricted, you can use <code>if</code> statements to transform results:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ if even x then "even" else "odd" | x &lt;- [1..5] ]
-- ["odd","even","odd","even","odd"]
</code></pre>

    <br/><br/>

    <li><b>Flattening with</b> <code>concat</code> <b>and Comprehensions</b></li>
    <br/>
    <ul>
        <li>A list comprehension with multiple generators is equivalent to <code>concat</code> of mapped lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x,y) | x &lt;- [1..2], y &lt;- [1..2] ]
-- same as:
concat [ [ (x,y) | y &lt;- [1..2] ] | x &lt;- [1..2] ]
</code></pre>

    <br/><br/>

    <li><b>Infinite Lists and Laziness</b></li>
    <br/>
    <ul>
        <li>List comprehensions work naturally with infinite lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">take 10 [ x^2 | x &lt;- [1..] ]
-- [1,4,9,16,25,36,49,64,81,100]
</code></pre>

    <br/>
    <ul>
        <li>Laziness ensures values are computed only on demand.</li>
    </ul>
    <br/><br/>

    <li><b>Common Pitfalls</b></li>
    <br/>
    <ul>
        <li><b>Order of qualifiers matters</b>: Generators must appear before filters dependent on them.</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | even x, x &lt;- [1..10] ]
-- ERROR: x is used before its generator
</code></pre>

    <br/>
    <ul>
        <li>Correct version:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x | x &lt;- [1..10], even x ]
</code></pre>

    <ul>
        <li>Be careful when using multiple generators with infinite lists: Some comprehensions may fail to terminate.</li>
    </ul>
    <br/><br/>
</ol>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-tuples">Tuples in Haskell</h3>
<ol>
    <li><b>What Are Tuples?</b></li>
    <br/>
    <ul>
        <li>A <code>tuple</code> in Haskell is a fixed-size collection of values.</li>
        <br/>
        <li>Unlike lists:
            <ul>
                <li>Tuples may contain <u>different types</u> in each position.</li>
                <li>Tuples have <u>fixed length</u>: a 2-tuple (pair) always has two elements, a 3-tuple always has three, etc.</li>
            </ul>
        </li>
        <br/>
        <li>Tuples are written using parentheses and commas.</li>
    </ul>

<pre><code class="language-haskell line-numbers">(1, "hello")       -- a pair (2-tuple)
(True, 3.14, 'x')  -- a triple (3-tuple)
</code></pre>

    <br/>
    <ul>
        <li>Tuples are extremely common for returning multiple values or structuring small groups of data.</li>
    </ul>
    <br/><br/>

    <li><b>Tuple Types</b></li>
    <br/>
    <ul>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(1, "abc")        -- (Int, String)
(True, False)     -- (Bool, Bool)
(1, 2.0, 'c')     -- (Int, Double, Char)
</code></pre>

    <ul>
        <li>Tuples are not “lists with commas” — they are their own data structures.</li>
    </ul>
    <br/><br/>

    <li><b>The Unit Type:</b> <code>()</code></li>
    <br/>
    <ul>
        <li><code>()</code> is a special tuple type of length 0.</li>
        <li>It has exactly one value: <code>()</code>.</li>
        <li>Often used as a placeholder when a function returns “nothing useful”.</li>
    </ul>

<pre><code class="language-haskell line-numbers">() :: ()
</code></pre>

    <br/><br/>

    <li><b>Accessing Tuple Elements</b></li>
    <br/>
    <ul>
        <li>You can extract elements using <u>pattern matching</u>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">let (x, y) = (10, 20)
-- x = 10, y = 20
</code></pre>

    <br/>
    <ul>
        <li>Works with any tuple:</li>
    </ul>

<pre><code class="language-haskell line-numbers">let (a, b, c) = (True, 3, "hi")
-- a = True, b = 3, c = "hi"
</code></pre>

    <br/>
    <ul>
        <li>You can also use <code>fst</code> and <code>snd</code> for pairs:</li>
    </ul>

<pre><code class="language-haskell line-numbers">fst (3,4)   -- 3
snd (3,4)   -- 4
</code></pre>

    <br/>
    <ul>
        <li>There are no built-in functions for triples or larger tuples — pattern matching is used instead.</li>
    </ul>
    <br/><br/>

    <li><b>Tuple Construction</b></li>
    <br/>
    <ul>
        <li>Tuples can be built simply by writing values inside parentheses:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(10, "apple")        -- a pair
(1, 2, 3, 4)         -- a 4-tuple
</code></pre>

    <br/>
    <ul>
        <li>Tuples are often useful to return multiple values from a function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">coords :: Double -&gt; (Double, Double)
coords r = (cos r, sin r)
</code></pre>

    <br/><br/>

    <li><b>Using Tuples in Functions</b></li>
    <br/>
    <ul>
        <li>Functions can accept tuples as parameters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">addPair :: (Int, Int) -&gt; Int
addPair (a, b) = a + b
</code></pre>

    <br/>
    <ul>
        <li>Functions returning tuples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">divide :: Double -&gt; Double -&gt; (Double, Double)
divide x y = (x / y, x `mod'` y)
</code></pre>

    <br/><br/>

    <li><b>Tuples Inside Lists</b></li>
    <br/>
    <ul>
        <li>You can have a list of tuples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">pairs :: [(Int, String)]
pairs = [(1, "a"), (2, "b"), (3, "c")]
</code></pre>

    <br/>
    <ul>
        <li>Useful for representing associations or keyed data.</li>
    </ul>

<pre><code class="language-haskell line-numbers">lookup 2 pairs    -- Just "b"
</code></pre>

    <br/><br/>

    <li><b>Tuples and List Comprehensions</b></li>
    <br/>
    <ul>
        <li>List comprehensions often produce tuples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ (x, y) | x &lt;- [1..3], y &lt;- [1..3] ]
-- [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
</code></pre>

    <br/>
    <ul>
        <li>You can also unpack tuples inside comprehensions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[ x+y | (x, y) &lt;- [(1,2),(3,4),(5,6)] ]
-- [3,7,11]
</code></pre>

    <br/><br/>

    <li><b>Comparisons Between Tuples</b></li>
    <br/>
    <ul>
        <li>If the element types implement <code>Eq</code> and <code>Ord</code>, tuples do too.</li>
        <li>Comparison is lexicographical:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(2, 5) &lt; (3, 1)      -- True
(3, "a") &gt; (3, "Z")  -- True (compare second element)
</code></pre>

    <br/><br/>

    <li><b>Curried Functions vs. Tupled Arguments</b></li>
    <br/>
    <ul>
        <li>Haskell prefers <u>curried</u> functions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>

    <br/>
    <ul>
        <li>But tupled arguments group multiple parameters into one:</li>
    </ul>

<pre><code class="language-haskell line-numbers">addT :: (Int, Int) -&gt; Int
addT (x, y) = x + y
</code></pre>

    <br/>
    <ul>
        <li>Use curried forms when possible; tupled forms when logically grouping values.</li>
    </ul>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-types-typeclasses">Types and Typeclasses in Haskell</h3>
<ol>
    <li><b>Why Types Matter in Haskell</b></li>
    <br/>
    <ul>
        <li>Haskell is a <b>statically typed</b> language:
            <ul>
                <li>Every expression has a type, known at <b>compile time</b>.</li>
                <li>The compiler checks type correctness before running your program.</li>
            </ul>
        </li>
        <br/>
        <li>Haskell also has <b>type inference</b>:
            <ul>
                <li>you usually do not need to write types explicitly,</li>
                <li>the compiler can infer them from the code.</li>
            </ul>
        </li>
        <br/>
        <li>Typeclasses add another layer: they describe <b>behavior</b> that types can implement.</li>
    </ul>
    <br/><br/>

    <li><b>Basic Built-in Types</b></li>
    <br/>
    <ul>
        <li>Some common primitive types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">42        :: Int        -- fixed-size integer
3.14      :: Double     -- double-precision floating point
True      :: Bool       -- boolean
'a'       :: Char       -- character
"hello"   :: String     -- String = [Char]
</code></pre>

    <br/>
    <ul>
        <li>You can always ask GHCi for the type of an expression using <code>:t</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :t 42
42 :: Num a =&gt; a
</code></pre>

    <br/>
    <ul>
        <li>Note: The compiler often shows <b>polymorphic</b> types (like <code>Num a =&gt; a</code>) instead of a concrete <code>Int</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Type Signatures for Functions</b></li>
    <br/>
    <ul>
        <li>Type signatures document what a function takes and returns.</li>
        <li>General form:</li>
    </ul>

<pre><code class="language-haskell line-numbers">name :: TypeOfArg1 -&gt; TypeOfArg2 -&gt; ... -&gt; ResultType
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>

    <br/>
    <ul>
        <li>Read as: <code>add</code> is a function that takes an <code>Int</code>, then another <code>Int</code>, and returns an <code>Int</code>.</li>
        <li>Because functions are <u>curried</u>, <code>Int -&gt; Int -&gt; Int</code> is really <code>Int -&gt; (Int -&gt; Int)</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Type Variables and Polymorphism</b></li>
    <br/>
    <ul>
        <li>Haskell supports <b>parametric polymorphism</b> via <b>type variables</b>.</li>
        <li>A type variable is a lowercase letter like <code>a</code>, <code>b</code>, <code>t</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">identity :: a -&gt; a
identity x = x
</code></pre>

    <br/>
    <ul>
        <li><code>identity</code> works for <u>any</u> type <code>a</code>:
            <ul>
                <li><code>identity 3        -&gt; 3</code></li>
                <li><code>identity "hi"     -&gt; "hi"</code></li>
                <li><code>identity True     -&gt; True</code></li>
            </ul>
        </li>
        <li>This is true parametric polymorphism: behavior does not depend on the specific type.</li>
    </ul>
    <br/><br/>

    <li><b>Type Constructors and Parameterized Types</b></li>
    <br/>
    <ul>
        <li>Types can be <b>parameterized</b> by other types, just like generic types in other languages.</li>
        <li>Example: <code>Maybe a</code>, <code>[a]</code>, <code>Either e a</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">Just 5       :: Maybe Int
Nothing      :: Maybe a
[1,2,3]      :: [Int]
Right "ok"   :: Either e String
Left "err"   :: Either String a
</code></pre>

    <br/>
    <ul>
        <li>Here, <code>Maybe</code>, <code>[]</code> (list), and <code>Either</code> are <b>type constructors</b>:
            <ul>
                <li>They are not full types until you give them a parameter.</li>
                <li>E.g. <code>Maybe</code> alone is like a function at the type level: it maps <code>a</code> to <code>Maybe a</code>.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

    <li><b>Type Synonyms (Type Aliases)</b></li>
    <br/>
    <ul>
        <li>You can give a new name to an existing type using <code>type</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">type UserName = String
type Age      = Int

greet :: UserName -&gt; String
greet name = "Hello, " ++ name
</code></pre>

    <ul>
        <li>This does <u>not</u> create a new type, just a <u>nickname</u> for an existing one.</li>
        <li>The compiler treats <code>UserName</code> as <code>String</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Algebraic Data Types (ADTs)</b></li>
    <br/>
    <ul>
        <li>Haskell allows you to define your own types using <code>data</code>.</li>
        <li>General forms:
            <ul>
                <li><b>Sum types</b> (one of several constructors),</li>
                <li><b>Product types</b> (constructors with multiple fields).</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Sum type: a value is either a Circle or a Rectangle
data Shape
    = Circle    Double          -- radius
    | Rectangle Double Double   -- width height

-- Product type with a single constructor and multiple fields
data Person = Person
    { name :: String
    , age  :: Int
    }
</code></pre>

    <ul>
        <li>ADTs combine:
            <ul>
                <li><b>Choice</b> (which constructor?)</li>
                <li><b>Structure</b> (what fields in each constructor?)</li>
            </ul>
        </li>
        <li>You use <u>pattern matching</u> to work with custom types.</li>
    </ul>
    <br/><br/>

    <li><b>What Is a Typeclass?</b></li>
    <br/>
    <ul>
        <li>A <b>typeclass</b> is a way to define a set of operations (methods) that a type can implement.</li>
        <li>Think of it as an interface of behavior, but:
            <ul>
                <li>It works at the <b>type level</b>,</li>
                <li>It supports <b>ad-hoc polymorphism</b> (overloading by type).</li>
            </ul>
        </li>
        <li>Example: the <code>Eq</code> typeclass defines equality operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
</code></pre>

    <br/>
    <ul>
        <li>Any type <code>a</code> that provides definitions for <code>(==)</code> and <code>(/=)</code> can be an instance of <code>Eq</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Typeclass Constraints</b></li>
    <br/>
    <ul>
        <li>A function can require that its type parameters belong to certain typeclasses.</li>
        <li>General form:</li>
    </ul>

<pre><code class="language-haskell line-numbers">function :: (Constraint1 a, Constraint2 a, Constraint3 b) =&gt; a -&gt; b -&gt; ...
</code></pre>

    <br/>
    <ul>
        <li>Example: a function that compares and prints something:</li>
    </ul>

<pre><code class="language-haskell line-numbers">showIfEqual :: (Eq a, Show a) =&gt; a -&gt; a -&gt; String
showIfEqual x y =
    if x == y
        then "Equal: " ++ show x
        else "Not equal"
</code></pre>

    <ul>
        <li>For any type <code>a</code> that implements <code>Eq</code> and <code>Show</code>,</li>
        <li><code>showIfEqual</code> takes two <code>a</code>s and returns a <code>String</code>.</li>
    </ul>
    <br/><br/>

    <li><b>Common Standard Typeclasses</b></li>
    <br/>
    <ul>
        <li><code>Eq</code> — equality and inequality: <code>(==)</code>, <code>(/=)</code></li>
        <li><code>Ord</code> — ordering: <code>(&lt;)</code>, <code>(&gt;)</code>, <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>compare</code></li>
        <li><code>Show</code> — convert to human-readable <code>String</code>: <code>show :: Show a =&gt; a -&gt; String</code></li>
        <li><code>Read</code> — parse from <code>String</code>:</li>
        <li><code>Num</code> — numeric types (supports <code>+ - * fromInteger</code>):</li>
        <li><code>Integral</code> — integer types (<code>Int</code>, <code>Integer</code>):</li>
        <li><code>Fractional</code> — fractional types (<code>Float</code>, <code>Double</code>):</li>
        <li><code>Functor</code> — types you can map over: <code>fmap :: Functor f =&gt; (a -&gt; code) -&gt; f a -&gt; f code</code></li>
        <li><code>Applicative</code>, <code>Monad</code> — types supporting sequencing and effects.</li>
    </ul>
    <br/><br/>

    <li><b>Defining Instances: Making a Type Implement a Typeclass</b></li>
    <br/>
    <ul>
        <li>To make a type implement a typeclass, you write an <code>instance</code> declaration.</li>
        <li>Example: implement <code>Eq</code> and <code>Show</code> for a custom type.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue

instance Eq Color where
    Red   == Red   = True
    Green == Green = True
    Blue  == Blue  = True
    _     == _     = False

instance Show Color where
    show Red   = "Red"
    show Green = "Green"
    show Blue  = "Blue"
</code></pre>

    <br/>
    <ul>
        <li>Now you can write:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Red == Green      -- False
show Blue         -- "Blue"
</code></pre>

    <br/><br/>

    <li><b>Deriving Typeclass Instances Automatically</b></li>
    <br/>
    <ul>
        <li>Writing instances by hand can be repetitive, so Haskell supports <code>deriving</code>.</li>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue
    deriving (Eq, Show, Ord)
</code></pre>

    <ul>
        <li>The compiler automatically creates reasonable implementations of these typeclasses.</li>
        <li>Now you get:
            <ul>
                <li><code>Red == Red</code> works,</li>
                <li><code>show Green</code> yields <code>"Green"</code>,</li>
                <li><code>Red &lt; Green</code> based on constructor order.</li>
            </ul>
        </li>
        <li>Many standard typeclasses can be derived: <code>Eq</code>, <code>Ord</code>, <code>Show</code>, <code>Read</code>, <code>Enum</code>, <code>Bounded</code>, etc.</li>
    </ul>
    <br/><br/>

    <li><b>Parametric vs Ad-hoc Polymorphism</b></li>
    <br/>
    <ul>
        <li><b>Parametric polymorphism</b> (via type variables):
            <ul>
                <li>Same implementation for all types.</li>
                <li>Example: <code>identity :: a -&gt; a</code>.</li>
            </ul>
        </li>
        <br/>
        <li><b>Ad-hoc polymorphism</b> (via typeclasses):
            <ul>
                <li>Different implementation depending on the type.</li>
                <li>Example: <code>show :: Show a =&gt; a -&gt; String</code> behaves differently for <code>Int</code> vs <code>Bool</code>.</li>
            </ul>
        </li>
        <br/>
        <li>Haskell lets you mix both:
            <ul>
                <li>type variables for generality,</li>
                <li>typeclass constraints for required capabilities.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

    <li><b>Putting It Together: A Small Example</b></li>
    <br/>
    <ul>
        <li>Define a custom type, derive some typeclasses, and write a polymorphic function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Point a = Point a a
    deriving (Eq, Show)

-- Distance squared between two points (works for any Num type)
distSquared :: Num a =&gt; Point a -&gt; Point a -&gt; a
distSquared (Point x1 y1) (Point x2 y2) =
    (x2 - x1) ^ 2 + (y2 - y1) ^ 2

-- Check if two points are the same and show a message
describePoints :: (Eq a, Show a, Num a) =&gt; Point a -&gt; Point a -&gt; String
describePoints p1 p2 =
    if p1 == p2
        then "Same point: " ++ show p1
        else "Different points: " ++ show p1 ++ " and " ++ show p2
</code></pre>

    <ul>
        <li>Key ideas:
            <ul>
                <li><code>Point a</code> is a parameterized type.</li>
                <li>We derive <code>Eq</code> and <code>Show</code> automatically.</li>
                <li><code>distSquared</code> uses <code>Num a</code> because it needs <code>(-)</code> and <code>(^)</code>.</li>
                <li><code>describePoints</code> uses both <code>Eq</code> and <code>Show</code> for comparison and printing.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-adts">Algebraic Data Types (ADTs) in Haskell</h3>
<ol>
    <li><b>What Are ADTs?</b></li>
    <br/>
    <ul>
        <li>An <b>Algebraic Data Type (ADT)</b> is a user-defined type created by combining other types using either <b>Sum types</b> (choices) or <b>Product types</b> (combinations)</li>
        </li>
        <br/>
        <li>They are called “algebraic” because they combine types using algebra-like operations:
            <ul>
                <li><b>+</b> = either/or (sum types)</li>
                <li><b>×</b> = “and” (product types)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Sum Types: Representing Alternatives</b></li>
    <br/>
    <ul>
        <li>A sum type describes a value that may be one of several <u>variants</u>.</li>
        <li>Each variant is called a <u>constructor</u>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Shape
    = Circle Double             -- radius
    | Rectangle Double Double   -- width height
</code></pre>

    <ul>
        <li>A <code>Shape</code> value is either a <code>Circle</code> with a radius, or a <code>Rectangle</code> with width and height.</li>
        <br/>
        <li>Pattern matching is used to work with sum types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">area :: Shape -&gt; Double
area (Circle r)        = pi * r^2
area (Rectangle w h)   = w * h
</code></pre>

    <br/><br/>


    <li><b>Product Types: Grouping Multiple Values Together</b></li>
    <br/>
    <ul>
        <li>A product type contains <b>multiple fields at once</b>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Person = Person String Int
--            name   age
</code></pre>

    <br/>
    <ul>
        <li>Meaning: a <code>Person</code> is constructed with a <code>String</code> and an <code>Int</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">greet :: Person -&gt; String
greet (Person name age) =
    "Hello, " ++ name ++ ", age " ++ show age
</code></pre>

    <br/><br/>


    <li><b>Record Syntax for Product Types</b></li>
    <br/>
    <ul>
        <li>Record syntax provides named fields:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data User = User
    { username :: String
    , password :: String
    , userAge  :: Int
    }
</code></pre>

    <br/>
    <ul>
        <li>Automatic getters are created:</li>
    </ul>

<pre><code class="language-haskell line-numbers">username (User "a" "b" 21)   -- "a"
userAge  (User "a" "b" 21)   -- 21
</code></pre>

    <br/>
    <ul>
        <li>Record updates create modified copies:</li>
    </ul>

<pre><code class="language-haskell line-numbers">let u = User "bob" "pass" 30
u { userAge = 31 }
</code></pre>

    <br/><br/>


    <li><b>Combining Sum + Product: The Real Power of ADTs</b></li>
    <br/>
    <ul>
        <li>Real-world ADTs often combine both approaches:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Expr
    = Lit Int                 -- product type (literal)
    | Add Expr Expr           -- product type
    | Mul Expr Expr
</code></pre>

    <br/>
    <ul>
        <li>Pattern matching lets us write logic elegantly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">eval :: Expr -&gt; Int
eval (Lit n)     = n
eval (Add a b)   = eval a + eval b
eval (Mul a b)   = eval a * eval b
</code></pre>

    <br/>
    <ul>
        <li>ADTs can model algebraic expressions, ASTs, API responses, states, and more.</li>
    </ul>
    <br/><br/>


    <li><b>Recursive ADTs</b></li>
    <br/>
    <ul>
        <li>Constructors can refer to the type being defined.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data List a
    = Empty
    | Cons a (List a)
</code></pre>

    <br/>
    <ul>
        <li>This is essentially how Haskell’s built-in list <code>[a]</code> works!</li>
        <li>Recursive types allow:
            <ul>
                <li>trees</li>
                <li>graphs</li>
                <li>linked structures</li>
                <li>ASTs (Abstract Syntax Trees)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">data Tree a
    = Leaf a
    | Node (Tree a) (Tree a)
</code></pre>

    <br/><br/>


    <li><b>Parameterized ADTs (Generics)</b></li>
    <br/>
    <ul>
        <li>ADTs often take type parameters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Maybe a
    = Nothing
    | Just a
</code></pre>

    <br/>
    <ul>
        <li>This is a generic container type:
            <ul>
                <li><code>Maybe Int</code></li>
                <li><code>Maybe String</code></li>
                <li><code>Maybe (Int, Bool)</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">Just 5     :: Maybe Int
Nothing    :: Maybe a
</code></pre>

    <br/><br/>


    <li><b>Derived Instances for ADTs</b></li>
    <br/>
    <ul>
        <li>Most ADTs can automatically derive useful typeclass instances:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color
    = Red | Green | Blue
    deriving (Eq, Show, Ord)
</code></pre>

    <br/>
    <ul>
        <li>Automatic benefits:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Red == Blue    -- False
show Green     -- "Green"
Red &lt; Blue     -- True (constructor order)
</code></pre>

    <br/><br/>


    <li><b>Pattern Matching with ADTs</b></li>
    <br/>
    <ul>
        <li>Pattern matching is the primary way to consume ADTs.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describeColor :: Color -&gt; String
describeColor Red   = "Warm color"
describeColor Green = "Natural color"
describeColor Blue  = "Cool color"
</code></pre>

    <br/>
    <ul>
        <li>Pattern matching ensures:
            <ul>
                <li>exhaustiveness checking,</li>
                <li>safe decomposition of product types,</li>
                <li>errors caught at compile time.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Real-World Example: Handling API Results</b></li>
    <br/>
    <ul>
        <li>ADTs allow representing cases cleanly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Result a
    = Success a
    | Error String
</code></pre>

    <br/>
    <ul>
        <li>Usage:</li>
    </ul>

<pre><code class="language-haskell line-numbers">handle :: Result Int -&gt; String
handle (Success n) = "Value: " ++ show n
handle (Error msg) = "Error: " ++ msg
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-typeclasses">Typeclasses in Haskell</h3>
<ol>
    <li><b>What Are Typeclasses?</b></li>
    <br/>
    <ul>
        <li>A <b>typeclass</b> in Haskell defines a set of behaviors (operations) that a type can implement.</li>
        <br/>
        <li>You can think of a typeclass as:
            <ul>
                <li>an interface (like in Java or TypeScript), but more general and more powerful,</li>
                <li>a way to describe <b>overloaded functions</b> that behave differently based on type,</li>
                <li>a mechanism for <b>ad-hoc polymorphism</b>.</li>
            </ul>
        </li>
        <br/>
        <li>A typeclass does <u>not</u> define data, it defines functions that types must provide.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
</code></pre>

    <br/>
    <ul>
        <li>This means: any type <code>a</code> that implements <code>Eq</code> must define <code>(==)</code> and <code>(/=)</code>.</li>
    </ul>
    <br/><br/>



    <li><b>The Role of Typeclass Constraints</b></li>
    <br/>
    <ul>
        <li>Functions often restrict type variables to only those types that implement a required typeclass.</li>
    </ul>

<pre><code class="language-haskell line-numbers">equalMessage :: Eq a =&gt; a -&gt; a -&gt; String
equalMessage x y =
    if x == y then "Equal" else "Not equal"
</code></pre>

    <br/>
    <ul>
        <li><code>Eq a =&gt;</code> is a <u>constraint</u> meaning: "this function only works for types that implement <code>Eq</code>."</li>
        <li>You can have multiple constraints:</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe :: (Eq a, Show a) =&gt; a -&gt; a -&gt; String
</code></pre>

    <br/><br/>



    <li><b>Defining a Typeclass</b></li>
    <br/>
    <ul>
        <li>You define a typeclass using the <code>class</code> keyword.</li>
        <li>Example of a custom typeclass:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Printable a where
    toText :: a -&gt; String
</code></pre>

    <ul>
        <li>Any type that implements <code>Printable</code> must define <code>toText</code>.</li>
    </ul>
    <br/><br/>



    <li><b>Creating a Typeclass Instance</b></li>
    <br/>
    <ul>
        <li>To make a type implement a typeclass, write an <code>instance</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue

instance Printable Color where
    toText Red   = "Red"
    toText Green = "Green"
    toText Blue  = "Blue"
</code></pre>

    <br/>
    <ul>
        <li>Now you can call:</li>
    </ul>

<pre><code class="language-haskell line-numbers">toText Red      -- "Red"
toText Blue     -- "Blue"
</code></pre>

    <br/><br/>



    <li><b>Automatic Instance Derivation</b></li>
    <br/>
    <ul>
        <li>Haskell can auto-generate implementations for many standard typeclasses:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Point = Point Int Int
    deriving (Eq, Show)
</code></pre>

    <br/>
    <ul>
        <li><code>Eq</code>: now <code>(==)</code> compares coordinates</li>
        <li><code>Show</code>: allows <code>show (Point 1 2)</code> =&gt; <code>"Point 1 2"</code></li>
    </ul>
    <br/><br/>



    <li><b>Typeclasses as Constraints on Polymorphic Functions</b></li>
    <br/>
    <ul>
        <li>Typeclasses let you write functions that work for many types, but only those that implement required behaviors.</li>
    </ul>

<pre><code class="language-haskell line-numbers">max3 :: Ord a =&gt; a -&gt; a -&gt; a -&gt; a
max3 a b c = max a (max b c)
</code></pre>

    <ul>
        <li>Because <code>max</code> needs ordering, the function requires <code>Ord a</code>.</li>
    </ul>
    <br/><br/>



    <li><b>Multiple Typeclass Constraints</b></li>
    <br/>
    <ul>
        <li>You can require several typeclasses at once:</li>
    </ul>

<pre><code class="language-haskell line-numbers">format :: (Show a, Ord a) =&gt; a -&gt; a -&gt; String
format x y =
    if x &lt; y
        then "Ascending: " ++ show x ++ ", " ++ show y
        else "Descending: " ++ show y ++ ", " ++ show x
</code></pre>

    <br/><br/>



    <li><b>Typeclasses for Parameterized Types</b></li>
    <br/>
    <ul>
        <li>Typeclasses can reference types of the form <code>f a</code> (e.g., <code>Maybe a</code>, <code>[a]</code>).</li>
        <li>This allows modeling behaviors of containers.</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance Functor Maybe where
    fmap _ Nothing  = Nothing
    fmap f (Just x) = Just (f x)
</code></pre>

    <br/>
    <ul>
        <li>Any type constructor <code>f</code> of kind <code>* -&gt; *</code> can implement <code>Functor</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Subclassing in Typeclasses</b></li>
    <br/>
    <ul>
        <li>Typeclasses can depend on other typeclasses.</li>
        <li>Example: <code>Ord</code> requires <code>Eq</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Eq a =&gt; Ord a where
    (&lt;)  :: a -&gt; a -&gt; Bool
    (&gt;)  :: a -&gt; a -&gt; Bool
    compare :: a -&gt; a -&gt; Ordering
</code></pre>

    <br/>
    <ul>
        <li>Meaning: "Any <code>Ord</code> instance must also implement <code>Eq</code>."</li>
    </ul>
    <br/><br/>


    <li><b>Advanced Feature: Default Method Implementations</b></li>
    <br/>
    <ul>
        <li>Typeclasses can provide default method bodies, which instances may override or keep.</li>
        <li>If an instance does not define the method, the default version is used automatically.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Size a where
    size :: a -&gt; Int
    size _ = 1     -- default implementation
</code></pre>

    <br/>
    <ul>
        <li>Here, any type that derives <code>Size</code> without defining <code>size</code> will return <code>1</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Point = Point Int Int

-- Using the default implementation
instance Size Point
</code></pre>

<pre><code class="language-haskell line-numbers">main = print (size (Point 3 4))   -- prints 1
</code></pre>

    <br/>
    <ul>
        <li>You can also override the default:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Pair a = Pair a a

instance Size (Pair a) where
    size (Pair _ _) = 2   -- custom implementation
</code></pre>

<pre><code class="language-haskell line-numbers">main = do
    print (size (Point 3 4))      -- uses default: 1
    print (size (Pair 10 20))     -- uses custom: 2
</code></pre>

    <br/><br/>




    <li><b>Higher-Kinded Typeclasses</b></li>
    <br/>
    <ul>
        <li>Some typeclasses work on <u>type constructors</u> (not simple types).</li>
        <li>Examples:
            <ul>
                <li><b>Functor</b>: <code>fmap</code></li>
                <li><b>Applicative</b>: <code>pure</code>, <code>(&lt;*&gt;)</code></li>
                <li><b>Monad</b>: <code>(&gt;&gt;=)</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Real-World Example: Defining Equality and Display</b></li>
    <br/>
    <ul>
        <li>Create a custom type and implement two typeclasses:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Pair a = Pair a a

instance Eq a =&gt; Eq (Pair a) where
    Pair x1 y1 == Pair x2 y2 = x1 == x2 &amp;&amp; y1 == y2

instance Show a =&gt; Show (Pair a) where
    show (Pair x y) = "Pair(" ++ show x ++ ", " ++ show y ++ ")"
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-pattern-matching">Pattern Matching in Haskell</h3>
<ol>
    <li><b>What Is Pattern Matching?</b></li>
    <br/>
    <ul>
        <li>It allows you to “deconstruct” values by matching them against patterns, and automatically bind variables.</li>
        <br/>
        <li>Patterns may describe:
            <ul>
                <li>literal values,</li>
                <li>data constructors,</li>
                <li>tuples, lists, records,</li>
                <li>wildcards <code>_</code>,</li>
                <li>nested structures,</li>
                <li>guards combined with patterns.</li>
            </ul>
        </li>
        <br/>
        <li>Pattern matching is everywhere: in function definitions, <code>case</code> expressions, <code>let</code> bindings, and list comprehensions.</li>
    </ul>
    <br/><br/>


    <li><b>Pattern Matching in Function Definitions</b></li>
    <br/>
    <ul>
        <li>Functions can define multiple equations using different patterns.</li>
    </ul>

<pre><code class="language-haskell line-numbers">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
</code></pre>

    <ul>
        <li>Explanation:
            <ul>
                <li>If input is 0, match first case.</li>
                <li>Else <code>n</code> matches the second pattern.</li>
            </ul>
        </li>
        <li>Patterns are matched from top to bottom.</li>
    </ul>
    <br/><br/>


    <li><b>The Wildcard Pattern <code>_</code></b></li>
    <br/>
    <ul>
        <li><code>_</code> matches anything without binding a variable.</li>
        <li>Useful for ignoring values you don’t care about.</li>
    </ul>

<pre><code class="language-haskell line-numbers">isZero :: Int -&gt; Bool
isZero 0 = True
isZero _ = False
</code></pre>

    <br/><br/>


    <li><b>Pattern Matching and Tuples</b></li>
    <br/>
    <ul>
        <li>Tuples can be decomposed directly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">addPair :: (Int, Int) -&gt; Int
addPair (x, y) = x + y
</code></pre>

    <br/>
    <ul>
        <li>Nested tuples work too:</li>
    </ul>

<pre><code class="language-haskell line-numbers">fstOfTriple :: (a, b, c) -&gt; a
fstOfTriple (x, _, _) = x
</code></pre>

    <br/><br/>


    <li><b>Pattern Matching Lists</b></li>
    <br/>
    <ul>
        <li>Lists can be matched using:
            <ul>
                <li><code>[]</code> — empty list</li>
                <li><code>(x:xs)</code> — head + tail</li>
                <li>Specific shapes: <code>[a,b,c]</code></li>
                <li>Nested list patterns</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">describe :: [Int] -&gt; String
describe []        = "empty"
describe [x]       = "one element"
describe (x:y:_)   = "at least two elements"
</code></pre>

    <br/>
    <ul>
        <li>Use <code>x:xs</code> to recursively process lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">sumList :: [Int] -&gt; Int
sumList []     = 0
sumList (x:xs) = x + sumList xs
</code></pre>

    <br/><br/>


    <li><b>Pattern Matching with Data Constructors (ADTs)</b></li>
    <br/>
    <ul>
        <li>When working with algebraic data types, pattern matching is essential.</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Shape
    = Circle Double
    | Rectangle Double Double

area :: Shape -&gt; Double
area (Circle r) = pi * r^2
area (Rectangle w h) = w * h
</code></pre>

    <ul>
        <li>You extract fields naturally as part of the pattern.</li>
    </ul>
    <br/><br/>


    <li><b>Pattern Matching with Records</b></li>
    <br/>
    <ul>
        <li>Record fields can be extracted by naming them in patterns:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data User = User
    { name :: String
    , age  :: Int
    }

describeUser :: User -&gt; String
describeUser User { name = n, age = a } =
    n ++ " is " ++ show a ++ " years old"
</code></pre>

    <ul>
        <li>You may also mix record syntax with positional patterns.</li>
    </ul>
    <br/><br/>


    <li><b>As-patterns</b></li>
    <br/>
    <ul>
        <li>An <b>as-pattern</b> lets you refer to the entire matched value <b>and</b> its components.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describeList :: [a] -&gt; String
describeList xs@(x:_) = "first element: " ++ show x ++ ", full list: " ++ show xs
describeList []       = "empty list"
</code></pre>

    <br/>
    <ul>
        <li><code>xs@(x:_)</code> means:
            <ul>
                <li><code>x:_</code> matches first element + rest</li>
                <li><code>xs</code> is bound to the whole list</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Pattern Matching in <code>case</code> Expressions</b></li>
    <br/>
    <ul>
        <li>Useful when you want pattern matching inside an expression instead of top-level definitions.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describeBool :: Bool -&gt; String
describeBool b =
    case b of
        True  -&gt; "yes"
        False -&gt; "no"
</code></pre>

    <ul>
        <li><code>case</code> expressions follow the same matching rules as functions.</li>
    </ul>
    <br/><br/>


    <li><b>Guards Together with Pattern Matching</b></li>
    <br/>
    <ul>
        <li>When matching is not enough, guards add conditional logic.</li>
    </ul>

<pre><code class="language-haskell line-numbers">classify :: Int -&gt; String
classify n
    | n &lt; 0     = "negative"
    | n == 0    = "zero"
    | otherwise = "positive"
</code></pre>

    <br/>
    <ul>
        <li>Patterns match structure, guards match conditions.</li>
    </ul>
    <br/><br/>


    <li><b>Matching Failure: Why Order Matters</b></li>
    <br/>
    <ul>
        <li>Patterns are checked top to bottom.</li>
        <li>If a pattern fails, Haskell tries the next one.</li>
        <li>This can affect correctness:</li>
    </ul>

<pre><code class="language-haskell line-numbers">bad :: [a] -&gt; String
bad (x:xs) = "nonempty"
bad []     = "empty"
-- The order here is fine.
</code></pre>

    <br/>
    <ul>
        <li>But reversing them breaks logic:</li>
    </ul>

<pre><code class="language-haskell line-numbers">bad2 :: [a] -&gt; String
bad2 []     = "empty"
bad2 (x:xs) = "nonempty"
</code></pre>

    <br/>
    <ul>
        <li>If written reversed like below:</li>
    </ul>

<pre><code class="language-haskell line-numbers">bad3 :: [a] -&gt; String
bad3 xs = "always matches first!"
bad3 [] = "never reached"
</code></pre>

    <br/>
    <ul>
        <li>The first line <code>bad3 xs = ...</code> matches <b>every</b> list, making the second unreachable.</li>
    </ul>
    <br/><br/>


    <li><b>Irrefutable Patterns</b></li>
    <br/>
    <ul>
        <li>An <b>irrefutable pattern</b> never fails immediately.</li>
        <li>Prefix a pattern with <code>~</code> to delay matching until needed:</li>
    </ul>

<pre><code class="language-haskell line-numbers">lazyTuple :: (a, b) -&gt; String
lazyTuple ~(x, y) = "always matches"
</code></pre>

    <ul>
        <li>Useful in lazy computations to avoid forcing structure prematurely.</li>
    </ul>
    <br/><br/>


    <li><b>Pattern Matching in List Comprehensions</b></li>
    <br/>
    <ul>
        <li>You can pattern match inside generators:</li>
    </ul>

<pre><code class="language-haskell line-numbers">pairs :: [(Int, Int)]
pairs = [ (x, y) | (x, y) &lt;- [(1,2), (3,4)] ]
</code></pre>

    <br/>
    <ul>
        <li>If a pattern cannot match, the element is skipped:</li>
    </ul>

<pre><code class="language-haskell line-numbers">firsts :: [(Int, Int)] -&gt; [Int]
firsts xs = [ x | (x, _) &lt;- xs ]
</code></pre>

    <br/><br/>


    <li><b>Pattern Matching and Exhaustiveness Checking</b></li>
    <br/>
    <ul>
        <li>Haskell warns when:
            <ul>
                <li>patterns are missing cases (non-exhaustive),</li>
                <li>pattern matches are redundant (never reached).</li>
            </ul>
        </li>
        <li>This helps prevent runtime errors.</li>
    </ul>

<pre><code class="language-haskell line-numbers">describeMaybe :: Maybe Int -&gt; String
describeMaybe (Just n) = "number"
describeMaybe Nothing  = "none"
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-guards">Guards in Haskell</h3>
<ol>
    <li><b>What Are Guards?</b></li>
    <br/>
    <ul>
        <li><b>Guards</b> are Boolean expressions used to choose between different function definitions or cases.</li>
        <br/>
        <li>Think of guards as a more elegant alternative to nested <code>if/else</code>.</li>
        <br/>
        <li>General form:</li>
<pre><code class="language-haskell line-numbers">function args
    | condition1 = result1
    | condition2 = result2
    | otherwise  = defaultResult
</code></pre>
    </ul>

    <br/>
    <ul>
        <li>Each guard is checked from <b>top to bottom</b>.</li>
        <br/>
        <li><code>otherwise</code> is just a synonym for <code>True</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Example of Guards</b></li>
    <br/>
    <ul>
        <li>Using guards to classify numbers:</li>
    </ul>

<pre><code class="language-haskell line-numbers">sign :: Int -&gt; String
sign n
    | n &lt; 0     = "negative"
    | n == 0    = "zero"
    | otherwise = "positive"
</code></pre>

    <ul>
        <li>This replaces what in many languages would be a clumsy chain of <code>if/else if</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Guards with Multiple Conditions</b></li>
    <br/>
    <ul>
        <li>You can combine guards with logical operators:</li>
    </ul>

<pre><code class="language-haskell line-numbers">bmiInfo :: Double -&gt; String
bmiInfo bmi
    | bmi &lt; 18.5                     = "underweight"
    | bmi &gt;= 18.5 &amp;&amp; bmi &lt; 25.0      = "normal"
    | bmi &gt;= 25.0 &amp;&amp; bmi &lt; 30.0      = "overweight"
    | otherwise                      = "obese"
</code></pre>

    <br/><br/>


    <li><b>Pattern Matching Combined with Guards</b></li>
    <br/>
    <ul>
        <li>Guards and pattern matching are often used together.</li>
    </ul>

<pre><code class="language-haskell line-numbers">classifyList :: [a] -&gt; String
classifyList [] = "empty"
classifyList xs
    | length xs == 1 = "singleton"
    | length xs &lt; 5  = "short list"
    | otherwise      = "long list"
</code></pre>

    <br/>
    <ul>
        <li>Order of evaluation: first match a pattern, then check guards inside that pattern’s branch.</li>
    </ul>
    <br/><br/>


    <li><b>Using Guards in</b> <code>case</code> <b>Expressions</b></li>
    <br/>
    <ul>
        <li>You can use guards directly inside a <code>case</code> expression:</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe :: Int -&gt; String
describe n = case n of
    _ | n &lt; 0     -&gt; "negative"
    _ | n == 0    -&gt; "zero"
    _ | otherwise -&gt; "positive"
</code></pre>

    <br/>
    <ul>
        <li>This is useful when you want expression-style matching rather than function-level matching.</li>
    </ul>
    <br/><br/>

    <li><b>Guards with Let Bindings</b></li>
    <br/>
    <ul>
        <li>Guards can use additional logic defined with <code>where</code> or <code>let</code> to keep the guard expressions clean and readable.</li>
        <br/>
        <li>This is useful when multiple guards rely on the same computed value.</li>
        <br/>
        <li><code>where</code> attaches definitions to the entire set of guards, while <code>let</code> introduces bindings inside a single guard expression.</li>
    </ul>

<pre><code class="language-haskell line-numbers">bmiTell :: Double -&gt; Double -&gt; String
bmiTell weight height
    | bmi &lt; 18.5 = "underweight"
    | bmi &lt; 25.0 = "normal"
    | bmi &lt; 30.0 = "overweight"
    | otherwise  = "obese"
  where
    bmi = weight / (height ^ 2)
</code></pre>
    <ul>
        <li>Here <code>bmi</code> is computed once in the <code>where</code> block and shared across all guards.</li>
        <br/>
        <li>Without <code>where</code>, you would have to repeat the computation in each guard, making the code harder to maintain.</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Equivalent but repetitive:
bmiTell w h
    | w / (h ^ 2) &lt; 18.5 = "underweight"
    | w / (h ^ 2) &lt; 25.0 = "normal"
    | w / (h ^ 2) &lt; 30.0 = "overweight"
    | otherwise          = "obese"
</code></pre>

    <br/>
    <ul>
        <li>You can also use <code>let</code> inside a guard if only one guard needs extra logic.</li>
    </ul>

<pre><code class="language-haskell line-numbers">bmiTell2 weight height
    | let bmi = weight / (height ^ 2)
    , bmi &lt; 18.5 = "underweight"
    | otherwise  = "others"
</code></pre>

    <ul>
        <li>Here <code>let</code> binds <code>bmi</code> only for this single guard.</li>
        <li>Multiple comma-separated conditions act as multiple guard checks.</li>
    </ul>

    <br/><br/>



    <li><b>Using</b> <code>otherwise</code> <b>Safely</b></li>
    <br/>
    <ul>
        <li><code>otherwise</code> is simply:</li>
    </ul>

<pre><code class="language-haskell line-numbers">otherwise = True
</code></pre>

    <ul>
        <li>It must appear at the last. If placed earlier, all following guards become unreachable.</li>
        <li>A correct example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">describe n
    | n &gt; 10    = "big"
    | otherwise = "small or equal to 10"
</code></pre>

    <br/><br/>


    <li><b>Guards vs If/Else</b></li>
    <br/>
    <ul>
        <li>Guards:
            <ul>
                <li>cleaner syntax for many branches,</li>
                <li>work well with pattern matching,</li>
                <li>read top–down like logic rules,</li>
                <li>avoid nesting.</li>
            </ul>
        </li>

        <li>If/else:
            <ul>
                <li>better for small, inline conditions,</li>
                <li>less readable for multi-branch logic.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Guards with Multiple Arguments</b></li>
    <br/>
    <ul>
        <li>Patterns can match arguments, and guards refine conditions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">max3 :: Ord a =&gt; a -&gt; a -&gt; a -&gt; a
max3 x y z
    | x &gt;= y &amp;&amp; x &gt;= z = x
    | y &gt;= x &amp;&amp; y &gt;= z = y
    | otherwise        = z
</code></pre>

    <br/><br/>


    <li><b>Guards with Pattern Guards (Advanced)</b></li>
    <br/>
    <ul>
        <li>Pattern guards allow matching and binding inside a guard expression.</li>
        <li>Syntax:</li>
    </ul>

<pre><code class="language-haskell line-numbers">f x
    | Just y &lt;- lookup x table = "found " ++ show y
    | otherwise                = "not found"
</code></pre>

    <br/>
    <ul>
        <li>Pattern guards:
            <ul>
                <li>first try the pattern,</li>
                <li>bind its contents,</li>
                <li>continue if match succeeds.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Example: Combining Everything</b></li>
    <br/>
    <ul>
        <li>A function that classifies triangles:</li>
    </ul>

<pre><code class="language-haskell line-numbers">triangleType :: (Eq a, Ord a, Num a) =&gt; a -&gt; a -&gt; a -&gt; String
triangleType a b c
    | a + b &lt;= c || b + c &lt;= a || a + c &lt;= b = "not a triangle"
    | a == b &amp;&amp; b == c                       = "equilateral"
    | a == b || b == c || a == c             = "isosceles"
    | otherwise                              = "scalene"
</code></pre>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-built-in-types">Built-in Types in Haskell</h3>
<ol>
    <li><b>Big Picture</b></li>
    <br/>
    <ul>
        <li>Many types you use come from:
            <ul>
                <li>The <code>Prelude</code> (imported automatically),</li>
                <li>The <code>base</code> library (standard library),</li>
                <li>Other common libraries (<code>containers</code>, <code>text</code>, <code>bytestring</code>, <code>scientific</code>, etc.).</li>
            </ul>
        </li>
        <br/>
        <li>This chapter focuses on:
            <ul>
                <li><b>Primitive &amp; core types</b>: <code>Bool</code>, <code>Char</code>, numeric types</li>
                <li><b>Composite types</b>: lists, tuples</li>
                <li><b>Algebraic types</b>: <code>Maybe</code>, <code>Either</code>, <code>Ordering</code></li>
                <li><b>Special types</b>: <code>()</code>, <code>IO a</code>, function types <code>a -&gt; b</code></li>
                <li><b>Type constructors &amp; kinds</b>, and <b>typeclass relationships</b></li>
                <li>Some widely used numeric &amp; scientific types (<code>Rational</code>, <code>Complex</code>, <code>Natural</code>, <code>Scientific</code>-like)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b><code>Bool</code>: Boolean Type</b></li>
    <br/>
    <ul>
        <li><code>Bool</code> has exactly two values:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Bool = False | True
</code></pre>

    <br/>
    <ul>
        <li>Main operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
(||) :: Bool -&gt; Bool -&gt; Bool
not  :: Bool -&gt; Bool

True  &amp;&amp; False   -- False
True  || False   -- True
not True        -- False
</code></pre>

    <br/>
    <ul>
        <li><code>Bool</code> instances:
            <ul>
                <li><code>Eq</code> (can compare with <code>==</code>),</li>
                <li><code>Ord</code> (<code>False &lt; True</code>),</li>
                <li><code>Show</code> (<code>show True == "True"</code>).</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><code>Char</code><b>: Unicode Characters</b></li>
    <br/>
    <ul>
        <li><code>Char</code> represents a single Unicode code point.</li>
        <li>Written with <b>single quotes</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">'a'  :: Char
'Z'  :: Char
'\n' :: Char
'中' :: Char
</code></pre>

    <br/>
    <ul>
        <li>Common operations (from <code>Data.Char</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">isAlpha  :: Char -&gt; Bool
isDigit  :: Char -&gt; Bool
toUpper  :: Char -&gt; Char
toLower  :: Char -&gt; Char
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Char (toUpper, isDigit)

toUpper 'a'        -- 'A'
isDigit '3'        -- True
isDigit 'x'        -- False
</code></pre>

    <br/><br/>


    <li><code>String</code><b>: Text Built from</b> <code>[Char]</code></li>
    <br/>
    <ul>
        <li><code>String</code> is just a <b>type synonym</b> for a list of characters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">type String = [Char]
</code></pre>

    <br/>
    <ul>
        <li>Text literals are written with <b>double quotes</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">"hello"       :: String
"λ-calculus"  :: String
</code></pre>

    <br/>
    <ul>
        <li>Because <code>String = [Char]</code>, all list operations work on strings:</li>
    </ul>

<pre><code class="language-haskell line-numbers">length :: [a] -&gt; Int

length "haskell"       -- 7
'h' : "askell"         -- "haskell"
"foo" ++ "bar"         -- "foobar"
</code></pre>

    <br/>
    <ul>
        <li><code>String</code> is easy to reason about but inefficient for large text (linked list of <code>Char</code>).</li>
        <li>For serious text processing, libraries use:
            <ul>
                <li><code>Data.Text.Text</code> (Unicode, packed array),</li>
                <li><code>Data.ByteString.ByteString</code> (binary data, bytes).</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Numeric Tower Overview</b></li>
    <br/>
    <ul>
        <li>Haskell uses <b>typeclasses</b> to organize numeric types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Num a where ...
class Real a where ...
class Integral a where ...
class Fractional a where ...
class Floating a where ...
class RealFrac a where ...
class RealFloat a where ...
</code></pre>

    <br/>
    <ul>
        <li>Rough hierarchy (simplified):</li>
    </ul>

<pre><code class="language-haskell line-numbers">Integral ⊆ Real ⊆ Num
Fractional ⊆ Num
Floating   ⊆ Fractional
RealFrac   ⊆ Real &amp; Fractional
RealFloat  ⊆ RealFrac &amp; Floating
</code></pre>

    <br/>
    <ul>
        <li>Numeric literals are polymorphic:</li>
    </ul>

<pre><code class="language-haskell line-numbers">5   :: Num a =&gt; a         -- can be Int, Integer, Double, ...
3.5 :: Fractional a =&gt; a  -- can be Float or Double
</code></pre>

    <br/><br/>


    <li><b>Integral Types</b></li>
    <br/>
    <ul>
        <li><code>Int</code>:
            <ul>
                <li>Fixed-size, machine integer (usually 64-bit).</li>
                <li>Fast, but can <b>overflow</b> on very large values.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">42    :: Int
(-10) :: Int
</code></pre>

    <br/>
    <ul>
        <li><code>Integer</code>:
            <ul>
                <li>Arbitrary-precision integer (no overflow, limited only by memory).</li>
                <li>Great for exact math or big integers, slower than <code>Int</code>.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">123456789012345678901234567890 :: Integer
</code></pre>

    <br/>
    <ul>
        <li><b>Fixed-width integer types</b> (from <code>Data.Int</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Int

Int8, Int16, Int32, Int64  -- signed fixed-width
</code></pre>

    <br/>
    <ul>
        <li><b>Unsigned</b> integer types (from <code>Data.Word</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Word

Word8, Word16, Word32, Word64  -- unsigned
</code></pre>

    <br/>
    <ul>
        <li><code>Natural</code> (from <code>Numeric.Natural</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Numeric.Natural

0    :: Natural
123  :: Natural
</code></pre>

    <br/>
    <ul>
        <li><b>Integral typeclass:</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">class (Real a, Enum a) =&gt; Integral a where
    quot, rem, div, mod :: a -&gt; a -&gt; a
    ...
</code></pre>

    <br/>
    <ul>
        <li>Instances include <code>Int</code>, <code>Integer</code>, and some fixed-width variants.</li>
    </ul>
    <br/><br/>


    <li><b>Fractional &amp; Floating Types</b></li>
    <br/>
    <ul>
        <li><code>Float</code>:
            <ul>
                <li>Single-precision floating point (32-bit, IEEE 754).</li>
                <li>Usually used less often.</li>
            </ul>
        </li>
        <li><code>Double</code>:
            <ul>
                <li>Double-precision floating point (64-bit, IEEE 754).</li>
                <li>Default for most real-number computations.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">3.14   :: Float
2.718  :: Double
</code></pre>

    <br/>
    <ul>
        <li><code>Fractional</code> typeclass:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class (Num a) =&gt; Fractional a where
    (/)          :: a -&gt; a -&gt; a
    fromRational :: Rational -&gt; a
</code></pre>

    <br/>
    <ul>
        <li>Exact rational numbers: <code>Rational</code></li>
    </ul>

<pre><code class="language-haskell line-numbers">type Rational = Ratio Integer
</code></pre>

    <br/>
    <ul>
        <li>Constructed using <code>%</code> (from <code>Data.Ratio</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Ratio

1 % 3        :: Rational
(1 % 3) + (1 % 6)  -- 1 % 2  (exact 1/2)
</code></pre>

    <br/>
    <ul>
        <li><b>Scientific / decimal types</b>:
            <ul>
                <li>Libraries (e.g. <code>Data.Scientific</code>) provide decimal-like types for precise numeric I/O (e.g. JSON numbers).</li>
                <li>Not in Prelude but very common in practice.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Complex Numbers</b></li>
    <br/>
    <ul>
        <li>From <code>Data.Complex</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Complex

(3 :+ 4)        :: Complex Double
magnitude (3 :+ 4)   -- 5.0
</code></pre>

    <br/>
    <ul>
        <li>Definition (simplified):</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Complex a = !a :+ !a
</code></pre>

    <br/>
    <ul>
        <li>Supports standard numeric operations (<code>Num</code>, <code>Fractional</code>, <code>Floating</code> instances).</li>
    </ul>
    <br/><br/>


    <li><b>Lists:</b> <code>[a]</code> <b>and Lazy Sequences</b></li>
    <br/>
    <ul>
        <li>Lists are homogeneous, immutable, linked lists.</li>
        <li>Definition (conceptually):</li>
    </ul>

<pre><code class="language-haskell line-numbers">data [] a = [] | a : [a]
</code></pre>

    <br/>
    <ul>
        <li>Syntax examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1,2,3]        :: [Int]
[]             :: [a]
1 : 2 : 3 : [] :: [Int]
</code></pre>

    <br/>
    <ul>
        <li>Common operations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">head, tail     :: [a] -&gt; a / [a]
length         :: [a] -&gt; Int
(++)           :: [a] -&gt; [a] -&gt; [a]
map, filter    :: (a -&gt; b) -&gt; [a] -&gt; [b] / (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code></pre>

    <br/>
    <ul>
        <li><b>Infinite lists</b> via laziness:</li>
    </ul>

<pre><code class="language-haskell line-numbers">[1..]              -- infinite list of Ints
take 5 [1..]       -- [1,2,3,4,5]
</code></pre>

    <br/>
    <ul>
        <li>Lists are very flexible but not always optimal for performance; other structures (<code>Vector</code>, <code>Seq</code>, etc.) may be better.</li>
    </ul>
    <br/><br/>


    <li><b>Tuples and the Unit Type</b> <code>()</code></li>
    <br/>
    <ul>
        <li>Tuples group a fixed number of possibly heterogeneous values.</li>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(1, "hi")         :: (Int, String)
(True, 3.14, 'x') :: (Bool, Double, Char)
</code></pre>

    <br/>
    <ul>
        <li>Special case: the <b>unit type</b> <code>()</code> is a tuple of length 0:</li>
    </ul>

<pre><code class="language-haskell line-numbers">() :: ()
</code></pre>

    <br/>
    <ul>
        <li>Unit is used when a function conceptually returns “no meaningful value” (similar to <code>void</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">print :: Show a =&gt; a -&gt; IO ()
</code></pre>

    <br/>
    <ul>
        <li>For pairs, there are helpers:</li>
    </ul>

<pre><code class="language-haskell line-numbers">fst :: (a, b) -&gt; a
snd :: (a, b) -&gt; b
</code></pre>

    <br/><br/>


    <li><code>Maybe a</code>: <b>Optional Values</b></li>
    <br/>
    <ul>
        <li><code>Maybe</code> is a core ADT representing optional values:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Maybe a = Nothing | Just a
</code></pre>

    <br/>
    <ul>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Just 5      :: Maybe Int
Nothing     :: Maybe a
</code></pre>

    <br/>
    <ul>
        <li>Used heavily to avoid <code>null</code>-like errors.</li>
        <li>Typical usage:</li>
    </ul>

<pre><code class="language-haskell line-numbers">safeHead :: [a] -&gt; Maybe a
safeHead []    = Nothing
safeHead (x:_) = Just x
</code></pre>

    <br/>
    <ul>
        <li><code>Maybe</code> has <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances; it composes nicely in pure code.</li>
    </ul>
    <br/><br/>


    <li><code>Either e a</code>: <b>Two-way Choice (Often for Errors)</b></li>
    <br/>
    <ul>
        <li>Definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Either a b = Left a | Right b
</code></pre>

    <br/>
    <ul>
        <li>Common convention:
            <ul>
                <li><code>Left e</code>: error or exceptional value</li>
                <li><code>Right x</code>: successful result</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">parseInt :: String -&gt; Either String Int
parseInt s =
    case reads s of
        [(n, "")] -&gt; Right n
        _         -&gt; Left "not a number"
</code></pre>

    <br/>
    <ul>
        <li><code>Either e</code> also has <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances (biased toward <code>Right</code>).</li>
    </ul>
    <br/><br/>


    <li><code>Ordering</code>: <b>Result of Comparisons</b></li>
    <br/>
    <ul>
        <li>Used by the <code>Ord</code> typeclass, especially <code>compare</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Ordering = LT | EQ | GT
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">compare 3 5  -- LT
compare 5 5  -- EQ
compare 7 2  -- GT
</code></pre>

    <br/>
    <ul>
        <li>Useful when writing custom sort logic or combining comparisons.</li>
    </ul>
    <br/><br/>


    <li><b>Function Types:</b> <code>a -&gt; b</code></li>
    <br/>
    <ul>
        <li>Functions themselves are values and have types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">increment :: Int -&gt; Int
increment x = x + 1
</code></pre>

    <br/>
    <ul>
        <li>Functions are <u>curried</u> by default:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add x y = x + y

-- add has type: Int -&gt; (Int -&gt; Int)
</code></pre>

    <br/>
    <ul>
        <li>You can pass functions as arguments and return them (higher-order functions):</li>
    </ul>

<pre><code class="language-haskell line-numbers">applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)
</code></pre>

    <br/>
    <ul>
        <li>There is also a <b>function type constructor</b> at the type level, commonly written as <code>(-&gt;)</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">( -&gt; ) :: * -&gt; * -&gt; *
</code></pre>

    <br/><br/>


    <li><code>IO a</code>: <b>Side Effects and the Outside World</b></li>
    <br/>
    <ul>
        <li><code>IO a</code> is the type of an <b>effectful computation</b> that, when executed by the runtime, may:
            <ul>
                <li>perform side effects (read/write files, print, network I/O, etc.),</li>
                <li>and eventually produce a value of type <code>a</code>.</li>
            </ul>
        </li>
        <li>Some examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">getLine  :: IO String
putStrLn :: String -&gt; IO ()
readFile :: FilePath -&gt; IO String
</code></pre>

    <br/>
    <ul>
        <li>A typical <code>main</code> function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    putStrLn "What is your name?"
    name &lt;- getLine
    putStrLn ("Hello, " ++ name)
</code></pre>

    <br/>
    <ul>
        <li><b>Key idea:</b> <code>IO a</code> keeps <b>pure code</b> separate from <b>effectful code</b>, while still being strongly typed.</li>
    </ul>
    <br/><br/>


    <li><b>Type Constructors &amp; Kinds for Built-in Types</b></li>
    <br/>
    <ul>
        <li>Many built-in types are actually <b>type constructors</b>:
            <ul>
                <li><code>Maybe    :: * -&gt; *</code></li>
                <li><code>[]       :: * -&gt; *</code></li>
                <li><code>Either   :: * -&gt; * -&gt; *</code></li>
                <li><code>(-&gt;)  :: * -&gt; * -&gt; *</code></li>
                <li><code>IO       :: * -&gt; *</code></li>
            </ul>
        </li>
        <li><b>Kinds</b> are “types of types”:
            <ul>
                <li><code>*</code> (or <code>Type</code>) means “a concrete type of values”.</li>
                <li><code>* -&gt; *</code> means “takes a type and returns a type”.</li>
            </ul>
        </li>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Maybe     :: * -&gt; *
Maybe Int :: *

Either :: * -&gt; * -&gt; *
Either String Int :: *
</code></pre>

    <br/>
    <ul>
        <li>This is analogous to generics/templated types in other languages, but with a more explicit type-level structure.</li>
    </ul>
    <br/><br/>


    <li><b>Laziness, Memory, and Performance Notes</b></li>
    <br/>
    <ul>
        <li><b>Laziness:</b>
            <ul>
                <li>Most Haskell types are evaluated lazily: values are computed when needed.</li>
                <li>Lists and <code>String</code> can represent infinite sequences thanks to laziness.</li>
            </ul>
        </li>
        <br/>
        <li><b>Strict fields:</b>
            <ul>
                <li>Some types (like <code>Complex</code>) use <code>!</code> to make fields strict, avoiding thunks and reducing memory overhead.</li>
            </ul>
        </li>
        <br/>
        <li><b>Performance rules of thumb:</b>
            <ul>
                <li>Use <code>Int</code> when you want speed and can tolerate overflow, <code>Integer</code> for exact big integers.</li>
                <li>Use <code>Double</code> for most floating-point computations, <code>Rational</code> for exact rational math.</li>
                <li>Use <code>String</code> for simple examples and small text, <code>Text</code> or <code>ByteString</code> for serious IO or large data.</li>
                <li>Lists are great for streaming and combinators, arrays/vectors are better for random access and numeric performance.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-import">Imports and Modules in Haskell</h3>
<ol>
    <li><b>What Does <code>import</code> Do in Haskell?</b></li>
    <br/>
    <ul>
        <li>Haskell code is organized into <b>modules</b>. Each source file typically defines one module.</li>
        <br/>
        <li>The <code>import</code> keyword brings names (functions, types, typeclasses, constructors) from another module into the current module’s scope.</li>
        <br/>
        <li>Imports are usually placed at the top of the file, after the optional <code>module</code> declaration.</li>
<pre><code class="language-haskell line-numbers">module Main where

import Data.List

main :: IO ()
main = print (sort [3,1,2])   -- sort comes from Data.List
</code></pre>
    </ul>


    <br/>
    <ul>
        <li>Without <code>import Data.List</code>, the name <code>sort</code> would not be available in this module.</li>
    </ul>
    <br/><br/>


    <li><b>Basic</b> <code>import</code> <b>Syntax</b></li>
    <br/>
    <ul>
        <li>The simple form of an import is:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Module.Name
</code></pre>

    <br/>
    <ul>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Maybe
import System.IO
import Control.Monad
</code></pre>

    <br/>
    <ul>
        <li>This brings <u>all exported names</u> from the module into scope (unqualified, unless you add <code>qualified</code>).</li>
        <li>Haskell modules form a hierarchy that mirrors directories:
            <ul>
                <li><code>Data.List</code> usually comes from <code>Data/List.hs</code></li>
                <li><code>MyApp.Utils.Strings</code> from <code>MyApp/Utils/Strings.hs</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Importing Specific Names</b></li>
    <br/>
    <ul>
        <li>You can restrict imports to a <u>selected list</u> of names using an import list in parentheses:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List (sort, nub)
</code></pre>

    <ul>
        <li>This imports only <code>sort</code> and <code>nub</code> from <code>Data.List</code>.</li>
        <br/>
        <li>You can also import type constructors and their constructors:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Maybe (Maybe(..))
-- imports the type Maybe and its constructors: Just, Nothing

import Data.Either (Either(Left, Right))
</code></pre>

    <ul>
        <li><code>Type(..)</code> means “import the type and all of its constructors”.</li>
        <li>You may also list constructors explicitly instead of <code>(..)</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Hiding Names with</b> <code>hiding</code></li>
    <br/>
    <ul>
        <li>You can import everything <u>except</u> some names using <code>hiding</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List hiding (sort)
</code></pre>

    <br/>
    <ul>
        <li>This imports all exported names from <code>Data.List</code> except <code>sort</code>.</li>
        <li>You can hide multiple names:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Prelude hiding (head, tail)
</code></pre>

    <br/>
    <ul>
        <li>Useful when:
            <ul>
                <li>you want to define your own version of a common function (e.g. a safer <code>head</code>), or</li>
                <li>you want to avoid name clashes with another module.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Qualified Imports</b></li>
    <br/>
    <ul>
        <li>A <u>qualified import</u> requires you to prefix names with the module name when using them:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import qualified Data.Map

example :: Data.Map.Map String Int
example = Data.Map.fromList [("a", 1), ("b", 2)]
</code></pre>

    <br/>
    <ul>
        <li>Advantages:
            <ul>
                <li>avoids name clashes (e.g. <code>Data.Map.lookup</code> vs <code>Data.List.lookup</code>),</li>
                <li>makes code more explicit about where functions come from.</li>
            </ul>
        </li>
        <li>Disadvantage:
            <ul>
                <li>can be verbose, especially with long module names.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Qualified Imports with</b> <code>as</code> (Aliases)</li>
    <br/>
    <ul>
        <li>You can combine <code>qualified</code> with an alias using <code>as</code> to shorten names:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import qualified Data.Map as M

example :: M.Map String Int
example = M.fromList [("a", 1), ("b", 2)]
</code></pre>

    <ul>
        <br/>
        <li>This is a very common style:
            <ul>
                <li><code>Data.Map</code> as <code>M</code></li>
                <li><code>Data.Set</code> as <code>S</code></li>
                <li><code>Data.Text</code> as <code>T</code> or <code>Text</code></li>
            </ul>
        </li>
        <br/>
        <li>You must always use the alias to refer to imported names.</li>
    </ul>
    <br/><br/>


    <li><b>Combining Qualified, Explicit, and Hiding</b></li>
    <br/>
    <ul>
        <li>You can combine many import options:</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- 1. Qualified with explicit import list
import qualified Data.Map as M (Map, fromList, lookup)

-- 2. Unqualified with explicit list
import Data.List (sort, nub)

-- 3. Qualified hiding some names (less common)
import qualified Data.List as L hiding (nub)
</code></pre>

    <br/>
    <ul>
        <li>Most typical patterns in real projects:
            <ul>
                <li>Unqualified + explicit list for small utility modules.</li>
                <li>Qualified + alias for large libraries (Maps, Sets, Text, Conduit, etc.).</li>
                <li><code>hiding</code> to avoid conflicts with Prelude or to override a function.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Dealing with Name Clashes</b></li>
    <br/>
    <ul>
        <li>Sometimes two modules export functions with the same name (e.g. <code>Data.List.map</code> and <code>Prelude.map</code>).</li>
        <li>Strategies to handle clashes:</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Strategy 1: qualified import
import qualified Data.Map as M

-- Strategy 2: hide conflicting names
import Prelude hiding (lookup)
import qualified Data.Map as M
</code></pre>

    <br/>
    <ul>
        <li>Example: using both <code>lookup</code> from <code>Data.Map</code> and <code>Data.List</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import qualified Data.Map as M
import qualified Data.List as L

foo :: Maybe Int
foo =
    let m = M.fromList [("a", 1)]
    in  M.lookup "a" m   -- clearly from Data.Map

bar :: Maybe Int
bar =
    L.lookup "a" [("a", 1)]  -- from Data.List
</code></pre>

    <br/><br/>


    <li><b>The Prelude and Turning It Off</b></li>
    <br/>
    <ul>
        <li><code>Prelude</code> is the default module imported into every Haskell module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Implicitly:
import Prelude
</code></pre>

    <br/>
    <ul>
        <li>It provides:
            <ul>
                <li>basic types (<code>Int</code>, <code>Bool</code>, <code>Maybe</code>, <code>[]</code>, <code>Either</code>...)</li>
                <li>basic functions (<code>map</code>, <code>foldr</code>, <code>length</code>, etc.)</li>
            </ul>
        </li>
        <li>You can <u>disable</u> the implicit Prelude import with a language pragma:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE NoImplicitPrelude #-}
module Main where

import MyCustomPrelude
</code></pre>

    <br/>
    <ul>
        <li>This is used in some projects to define their own “prelude” or to have stricter control over imports.</li>
    </ul>
    <br/><br/>


    <li><b>Importing Your Own Modules</b></li>
    <br/>
    <ul>
        <li>Project modules are just modules you define yourself.</li>
        <li>Directory structure mirrors module hierarchy:</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- File: src/MyApp/Utils/Math.hs
module MyApp.Utils.Math where

square :: Int -&gt; Int
square x = x * x
</code></pre>

    <br/>
    <ul>
        <li>From another module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- File: src/MyApp/Main.hs
module MyApp.Main where

import MyApp.Utils.Math (square)

foo :: Int
foo = square 10
</code></pre>

    <br/>
    <ul>
        <li>Your build tool (Cabal, Stack, etc.) must be configured so that <code>src</code> is on the module search path.</li>
    </ul>
    <br/><br/>


    <li><code>import</code> <b>in GHCi</b></li>
    <br/>
    <ul>
        <li>In GHCi (the interactive REPL), you can also use <code>import</code> statements, or the <code>:m</code> command:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; import Data.List
Prelude Data.List&gt; sort [3,1,2]
[1,2,3]
</code></pre>

    <br/>
    <ul>
        <li>Or using <code>:m</code> (module command):</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :m + Data.List Data.Maybe
</code></pre>

    <br/>
    <ul>
        <li><code>:m +</code> adds modules; <code>:m -</code> removes.</li>
        <li>You can still use <code>qualified</code> and <code>as</code> in GHCi just like in source files.</li>
    </ul>
    <br/><br/>


    <li><b>Safe Imports (Safe Haskell)</b></li>
    <br/>
    <ul>
        <li>Safe Haskell is a feature for controlling what code can do, especially in untrusted contexts.</li>
        <li>You may see imports like:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import safe Data.List
</code></pre>

    <ul>
        <li>This is a more advanced feature and not needed for everyday coding, but you may encounter it in libraries focused on security or sandboxing.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-higher-order-functions">Higher-Order Functions in Haskell</h3>
<ol>
    <li><b>What Are Higher-Order Functions (HOFs)?</b></li>
    <br/>
    <ul>
        <li>A <b>higher-order function</b> (HOF) is any function that:
            <ul>
                <li>takes another function as an argument, <b>or</b></li>
                <li>returns a function as its result.</li>
            </ul>
        </li>
        <br/>
        <li>Haskell is a <b>functional</b> language, so higher-order functions are extremely common and central to everyday programming.</li>
        <br/>
        <li>Because functions are <b>first-class values</b>, you can:
            <ul>
                <li>store functions in variables,</li>
                <li>pass them around,</li>
                <li>return them from other functions,</li>
                <li>compose them into larger behavior.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Functions as Arguments</b></li>
    <br/>
    <ul>
        <li>A function can take another function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)

applyTwice (+1) 3   -- 5
applyTwice (*2) 4   -- 16
</code></pre>

    <br/>
    <ul>
        <li>The type <code>(a -&gt; a) -&gt; a -&gt; a</code> means:</li>
        <ul>
            <li>the first argument is a function of type <code>a -&gt; a</code>,</li>
            <li>the second argument is a value of type <code>a</code>.</li>
        </ul>
        <li>Because Haskell functions are <u>curried</u>, every function actually takes one argument and returns a new function.</li>
    </ul>
    <br/><br/>


    <li><b>Functions Returning Functions</b></li>
    <br/>
    <ul>
        <li>Any function can return another function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">makeAdder :: Int -&gt; (Int -&gt; Int)
makeAdder n = \x -&gt; x + n

add10 = makeAdder 10      -- add10 :: Int -&gt; Int
add10 5                   -- 15
</code></pre>

    <br/>
    <ul>
        <li>This is extremely powerful for constructing reusable behavior.</li>
        <li>Example: “configuration-style” function builders:</li>
    </ul>

<pre><code class="language-haskell line-numbers">makeMultiplier :: Int -&gt; (Int -&gt; Int)
makeMultiplier m = \x -&gt; x * m

double = makeMultiplier 2
double 21        -- 42
</code></pre>

    <br/><br/>


    <li><b>Anonymous Functions (Lambdas)</b></li>
    <br/>
    <ul>
        <li>A lambda expression <code>\x -&gt; ...</code> creates a function without naming it.</li>
    </ul>

<pre><code class="language-haskell line-numbers">map (\x -&gt; x * 2) [1,2,3]   -- [2,4,6]
</code></pre>

    <br/>
    <ul>
        <li>Lambdas allow you to write functions inline where they are used.</li>
        <li>Lambdas can take multiple arguments:</li>
    </ul>

<pre><code class="language-haskell line-numbers">\x y -&gt; x + y
</code></pre>

    <br/><br/>


    <li><code>map</code>: <b>Apply a Function to Each Element</b></li>
    <br/>
    <ul>
        <li><code>map</code> takes a function and applies it to each element of a list:</li>
    </ul>

<pre><code class="language-haskell line-numbers">map :: (a -&gt; b) -&gt; [a] -&gt; [b]

map (*2) [1,2,3]    -- [2,4,6]
map show [1,2,3]    -- ["1","2","3"]
</code></pre>

    <br/>
    <ul>
        <li><code>map</code> is a fundamental higher-order function provided by the <code>Functor</code> class.</li>
        <li>Its general version is <code>fmap</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

    <br/><br/>


    <li><code>filter</code>: <b>Keep Elements That Match a Predicate</b></li>
    <br/>
    <ul>
        <li><code>filter</code> takes a function returning <code>Bool</code> and keeps only items that satisfy it.</li>
    </ul>

<pre><code class="language-haskell line-numbers">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]

filter odd [1..10]       -- [1,3,5,7,9]
filter (\x -&gt; x &gt; 5) [3,6,7]  -- [6,7]
</code></pre>

    <br/>
    <ul>
        <li>Common use cases:
            <ul>
                <li>filtering data,</li>
                <li>searching lists,</li>
                <li>building pipelines of list transformations.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><code>foldr</code> <b>and</b> <code>foldl</code>: <b>Reduce a List</b></li>
    <br/>
    <ul>
        <li><code>foldr</code> and <code>foldl</code> are extremely important higher-order functions that collapse a list into a single value.</li>
        <li><code>foldr</code> (fold right):</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b

foldr (+) 0 [1,2,3]   -- 6
foldr (:) [] [1,2,3] -- [1,2,3]
</code></pre>

    <br/>
    <ul>
        <li><code>foldl</code> (fold left):</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b

foldl (+) 0 [1,2,3]  -- 6
</code></pre>

    <br/>
    <ul>
        <li><b>Difference</b>:
            <ul>
                <li><code>foldr</code> works well with infinite lists due to laziness.</li>
                <li><code>foldl</code> builds huge thunks, use <code>foldl'</code> instead (from <code>Data.List</code>) for strict evaluation.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List (foldl')
foldl' (+) 0 [1..]   -- will run indefinitely but without memory leak
</code></pre>

    <br/><br/>


    <li><b>Function Composition with</b> <code>.</code></li>
    <br/>
    <ul>
        <li>Function composition builds new functions by chaining others:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)

(f . g) x = f (g x)
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(negate . abs) (-10)   -- -10
map (show . (*2)) [1,2,3]  -- ["2","4","6"]
</code></pre>

    <br/><br/>


    <li><b>Function Application with <code>$</code></b></li>
    <br/>
    <ul>
        <li><code>($)</code> is a function that simply applies another function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">($) :: (a -&gt; b) -&gt; a -&gt; b
f $ x = f x
</code></pre>

    <br/>
    <ul>
        <li>It is useful to reduce parentheses:</li>
    </ul>

<pre><code class="language-haskell line-numbers">sum (map abs [1,-2,3])
sum $ map abs [1,-2,3]
</code></pre>

    <br/>
    <ul>
        <li>Common in pipelines.</li>
    </ul>
    <br/><br/>


    <li><b>Partial Application</b></li>
    <br/>
    <ul>
        <li>Because functions in Haskell are curried, you can call a function with fewer arguments than it expects.</li>
        <li>This creates a new function (higher-order behavior).</li>
    </ul>

<pre><code class="language-haskell line-numbers">add :: Int -&gt; Int -&gt; Int
add x y = x + y

addFive = add 5     -- addFive :: Int -&gt; Int
addFive 10          -- 15
</code></pre>

    <br/>
    <ul>
        <li>This technique is used constantly in functional programming.</li>
    </ul>
    <br/><br/>


    <li><b>Sections: Turning Operators into Functions</b></li>
    <br/>
    <ul>
        <li>Operators can be partially applied using parentheses:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(+) 3      -- \x -&gt; 3 + x
(3 +)      -- same as above
(+ 3)      -- \x -&gt; x + 3
(*2)       -- \x -&gt; x * 2
</code></pre>

    <br/>
    <ul>
        <li>These are higher-order functions created automatically by partial application.</li>
    </ul>
    <br/><br/>


    <li><b>Zip Functions</b></li>
    <br/>
    <ul>
        <li><code>zipWith</code> is a classic higher-order function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]

zipWith (+) [1,2,3] [4,5,6]    -- [5,7,9]
zipWith max [1,5,2] [3,2,8]    -- [3,5,8]
</code></pre>

    <br/>
    <ul>
        <li>It applies a function elementwise to two lists.</li>
    </ul>
    <br/><br/>


    <li><b>Higher-Order Patterns in Real Projects</b></li>
    <br/>
    <ul>
        <li>Real Haskell code frequently uses higher-order functions for:</li>
        <ul>
            <li>callbacks,</li>
            <li>data transformation pipelines,</li>
            <li>domain-specific languages,</li>
            <li>parsers (<code>Parsec</code>/<code>Megaparsec</code> use HOFs everywhere),</li>
            <li>IO actions chaining,</li>
            <li>validation pipelines,</li>
            <li>business logic combinators.</li>
        </ul>
    </ul>
    <br/>
    <ul>
        <li>Example: Using HOFs to build reusable validation logic:</li>
    </ul>

<pre><code class="language-haskell line-numbers">validate :: (a -&gt; Bool) -&gt; String -&gt; a -&gt; Either String a
validate p msg x =
    if p x then Right x else Left msg

isPositive = validate (&gt; 0) "not positive"
isEven     = validate even  "not even"

isEven 4       -- Right 4
isPositive (-1) -- Left "not positive"
</code></pre>

    <br/><br/>


    <li><b>Using HOFs to Create Pipelines</b></li>
    <br/>
    <ul>
        <li>Chaining functions is a core functional technique:</li>
    </ul>

<pre><code class="language-haskell line-numbers">processNumbers =
      map (*2)
    . filter odd
    . map (+1)
</code></pre>

    <br/>
    <ul>
        <li>Now <code>processNumbers</code> is itself a function:</li>
    </ul>

<pre><code class="language-haskell line-numbers">processNumbers [1,2,3,4]  -- [4,8]
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-lambdas">Lambda Expressions (Anonymous Functions) in Haskell</h3>
<ol>
    <li><b>What Are Lambda Expressions?</b></li>
    <br/>
    <ul>
        <li>A <b>lambda expression</b> (also called an <b>anonymous function</b>) is a function defined without a name.</li>
        <br/>
        <li>In Haskell, lambdas use a special syntax based on mathematical lambda calculus:</li>
<pre><code class="language-haskell line-numbers">\x -&gt; expression
</code></pre>

    <br/>
        <li>The backslash <code>\</code> represents λ (lambda).</li>
        <br/>
        <li>Lambdas are used when:
            <ul>
                <li>you need a function <b>only once</b>,</li>
                <li>you want to pass inline behavior into another function,</li>
                <li>you want to avoid naming trivial helper functions.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Basic Syntax</b></li>
    <br/>
    <ul>
        <li>The simplest lambda:</li>
    </ul>

<pre><code class="language-haskell line-numbers">\x -&gt; x + 1
</code></pre>

    <br/>
    <ul>
        <li>Equivalent named version:</li>
    </ul>

<pre><code class="language-haskell line-numbers">addOne x = x + 1
</code></pre>

    <br/>
    <ul>
        <li>A lambda is just another ordinary function.</li>
    </ul>

<pre><code class="language-haskell line-numbers">(\x -&gt; x + 1) 5   -- 6
</code></pre>

    <br/><br/>


    <li><b>Multiple Arguments</b></li>
    <br/>
    <ul>
        <li>Lambdas can have multiple parameters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">\x y -&gt; x + y
</code></pre>

    <br/>
    <ul>
        <li>Equivalent to:</li>
    </ul>

<pre><code class="language-haskell line-numbers">add x y = x + y
</code></pre>

    <br/>
    <ul>
        <li>And because Haskell is curried:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(\x -&gt; \y -&gt; x + y)
</code></pre>

    <br/><br/>


    <li><b>Lambdas Inside Higher-Order Functions</b></li>
    <br/>
    <ul>
        <li>Lambdas shine when passed to higher-order functions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">map (\x -&gt; x * 2) [1,2,3]
-- [2,4,6]

filter (\x -&gt; x &gt; 5) [3,4,5,6,7]
-- [6,7]
</code></pre>

    <br/>
    <ul>
        <li>Using a lambda avoids having to name trivial helpers:</li>
    </ul>

<pre><code class="language-haskell line-numbers">map (\c -&gt; toUpper c) "lambda"
-- "LAMBDA"
</code></pre>

    <br/><br/>


    <li><b>Lambdas with Pattern Matching</b></li>
    <br/>
    <ul>
        <li>You can pattern match directly in a lambda:</li>
    </ul>

<pre><code class="language-haskell line-numbers">\ (x, y) -&gt; x + y
</code></pre>

    <br/>
    <ul>
        <li>Example with tuple destructuring:</li>
    </ul>

<pre><code class="language-haskell line-numbers">map (\(x,y) -&gt; x * y) [(2,3), (4,5)]
-- [6,20]
</code></pre>

    <br/>
    <ul>
        <li>Or matching list patterns:</li>
    </ul>

<pre><code class="language-haskell line-numbers">\ (x:_) -&gt; x
</code></pre>

    <br/>
    <ul>
        <li>Pattern failures inside lambdas cause runtime errors, so they should be used carefully.</li>
    </ul>
    <br/><br/>


    <li><b>Lambdas in Let and Where Bindings</b></li>
    <br/>
    <ul>
        <li>Lambdas can appear in <code>let</code> or <code>where</code>:</li>

<pre><code class="language-haskell line-numbers">let f = \x -&gt; x * 2
in f 10
</code></pre>

    <br/>
        <li>Equivalent to:</li>

<pre><code class="language-haskell line-numbers">let f x = x * 2 in f 10
</code></pre>
    </ul>

    <br/><br/>


    <li><b>Lambda Case</b> (<code>\case</code>)</li>
    <br/>
    <ul>
        <li>Using the <code>LambdaCase</code> extension, you can write pattern-matching lambdas without naming the argument.</li>
        <br/>
        <li>Enable the extension:</li>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE LambdaCase #-}
</code></pre>

    <br/>
        <li>Then write:</li>

<pre><code class="language-haskell line-numbers">\case
    Just x  -&gt; x * 2
    Nothing -&gt; 0
</code></pre>

    <br/>
        <li>Equivalent to:</li>

<pre><code class="language-haskell line-numbers">\m -&gt; case m of
    Just x  -&gt; x * 2
    Nothing -&gt; 0
</code></pre>
    </ul>

    <br/><br/>


    <li><b>Lambda Patterns with <code>\\</code> Syntax (Multi-Clause Lambdas)</b></li>
    <br/>
    <ul>
        <li>With the <code>LambdaCase</code> or <code>MultiWayIf</code> extension, lambdas can have multiple pattern branches.</li>
        <li>Using <code>\\</code> (double-backslash):</li>
    </ul>

<pre><code class="language-haskell line-numbers">\case
    (x,y) -&gt; x
    _     -&gt; 0
</code></pre>

    <br/>
    <ul>
        <li>This is cleaner than wrapping everything in <code>case ... of</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Common Lambda Shorthands</b></li>
    <br/>
    <ul>
        <li>Lambdas can be simplified using operators or partial application:</li>
    </ul>

<pre><code class="language-haskell line-numbers">\x -&gt; x + 1      ==  (+1)
\x -&gt; 1 + x      ==  (1+)
\x -&gt; x * y      ==  (*y)
\x -&gt; f (g x)    ==  (f . g)
</code></pre>

    <br/>
    <ul>
        <li>Many lambdas can be rewritten more concisely using sectioning or composition.</li>
    </ul>
    <br/><br/>


    <li><b>Examples of Real-World Lambda Usage</b></li>
    <br/>
    <ul>
        <li><b>Sorting with custom comparators:</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List (sortBy)

sortBy (\a b -&gt; compare (length a) (length b)) ["hi", "hello", "a"]
-- ["a","hi","hello"]
</code></pre>

    <br/>
    <ul>
        <li><b>Parsing transforms:</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">map (\x -&gt; read x :: Int) ["1","2","3"]
-- [1,2,3]
</code></pre>

    <br/>
    <ul>
        <li><b>Functional pipelines:</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">let pipeline = filter (\x -&gt; x &gt; 3) . map (\x -&gt; x * 2)
pipeline [1,2,3,4]
-- [8]
</code></pre>

    <br/><br/>


    <li><b>Do Lambdas Have Types?</b></li>
    <br/>
    <ul>
        <li>Yes — every lambda has a type just like any function.</li>
    </ul>

<pre><code class="language-haskell line-numbers">:t \x -&gt; x + 1
-- :: Num a =&gt; a -&gt; a
</code></pre>

    <br/>
    <ul>
        <li>Types can also be added explicitly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(\x -&gt; x + 1) :: Int -&gt; Int
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-modules">Modules in Haskell</h3>
<ol>
    <li><b>What Are Modules in Haskell?</b></li>
    <br/>
    <ul>
        <li>A <code>module</code> is Haskell’s fundamental unit of code organization.</li>
        <br/>
        <li>Every Haskell file defines exactly one module.</li>
        <br/>
        <li>Modules:
            <ul>
                <li>group related functions, types, and typeclasses,</li>
                <li>control what is <u>visible</u> to other modules,</li>
                <li>enable namespace management,</li>
                <li>improve maintainability and structure.</li>
            </ul>
        </li>
        <br/>
        <li>Modules correspond to files, and hierarchical module names correspond to folder structure.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Module Declaration</b></li>
    <br/>
    <ul>
        <li>Each file begins with a <code>module</code> declaration:</li>
    </ul>

<pre><code class="language-haskell line-numbers">module MyModule where

x = 42
</code></pre>

    <br/>
    <ul>
        <li>If no module is declared, the file is assumed to be <code>Main</code>.</li>
        <li>File name must match the module name and folder hierarchy:
            <ul>
                <li><code>MyModule.hs</code> defines module <code>MyModule</code></li>
                <li><code>Data/ListUtils.hs</code> defines module <code>Data.ListUtils</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Export Lists</b></li>
    <br/>
    <ul>
        <li>A module can selectively expose names using an <u>export list</u>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">module Math.Utils (square, cube) where

square x = x * x
cube x   = x * x * x
secret   = 123   -- not exported
</code></pre>
    <ul>
        <li>Anything not listed in the export list is <u>private</u>.</li>
        <br/>
        <li>To export everything, omit the export list.</li>
    </ul>

<pre><code class="language-haskell line-numbers">module Math.Utils where
</code></pre>

    <br/><br/>


    <li><b>Exporting Types and Constructors</b></li>
    <br/>
    <ul>
        <li>You may export:
            <ul>
                <li>just the type name,</li>
                <li>the type with all constructors,</li>
                <li>or specific constructors.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">module Shapes
    ( Shape(Circle, Rectangle)
    , area
    ) where

data Shape = Circle Double | Rectangle Double Double
area (Circle r)       = pi * r * r
area (Rectangle w h)  = w * h
</code></pre>

    <br/>
    <ul>
        <li>Exporting all constructors:</li>
    </ul>

<pre><code class="language-haskell line-numbers">module Shapes (Shape(..)) where
</code></pre>

    <br/><br/>


    <li><b>Importing Modules</b> (Short Summary)</li>
    <br/>
    <ul>
        <li>Imported using <code>import Module.Name</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.List (sort, nub)
import qualified Data.Map as M
</code></pre>

    <br/>
    <ul>
        <li>For full rules of importing, see your previous “Haskell import” chapter.</li>
    </ul>
    <br/><br/>


    <li><b>Hierarchical Modules</b></li>
    <br/>
    <ul>
        <li>Modules support hierarchical naming using dots.</li>
        <li>For example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">module MyApp.Utils.Math where
</code></pre>

    <br/>
    <ul>
        <li>File structure must mirror the hierarchy:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">MyApp/
 └─ Utils/
     └─ Math.hs
</code></pre>

    <br/>
    <ul>
        <li>This improves organization in large codebases.</li>
    </ul>
    <br/><br/>


    <li><b>The Prelude Module</b></li>
    <br/>
    <ul>
        <li><code>Prelude</code> is automatically imported into every module:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Prelude
</code></pre>

    <br/>
    <ul>
        <li>It provides:
            <ul>
                <li>basic types (<code>Int</code>, <code>Bool</code>, <code>Maybe</code>, <code>[]</code>, <code>Either</code>, ...),</li>
                <li>basic functions (<code>map</code>, <code>foldr</code>, <code>not</code>, <code>(++)</code>).</li>
            </ul>
        </li>
        <li>You can disable it:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE NoImplicitPrelude #-}
module Main where
</code></pre>

    <br/>
    <ul>
        <li>Useful for custom preludes (e.g. CodeWorld, Yesod, commercial codebases).</li>
    </ul>
    <br/><br/>


    <li><b>Re-exporting from Modules</b></li>
    <br/>
    <ul>
        <li>A module can <b>re-export</b> items from another module.</li>
        <li>This is used to create module “bundles”.</li>
    </ul>

<pre><code class="language-haskell line-numbers">module MyPrelude
    ( module Data.List
    , module Data.Maybe
    ) where

import Data.List
import Data.Maybe
</code></pre>

    <br/>
    <ul>
        <li>User code can now just do:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import MyPrelude
</code></pre>

    <br/>
    <ul>
        <li>Large frameworks like Yesod and Servant heavily use this technique.</li>
    </ul>
    <br/><br/>


    <li><b>Qualified Re-exports</b></li>
    <br/>
    <ul>
        <li>Sometimes a module re-exports symbolic operators to avoid conflicts.</li>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">module Operators (module M) where
import qualified MyApp.Operators as M
</code></pre>

    <br/><br/>


    <li><b>Internal Modules</b></li>
    <br/>
    <ul>
        <li>A common convention in Haskell projects is “public vs internal modules”.</li>
        <li>Example layout:</li>
    </ul>

<pre><code class="language-plaintext line-numbers">src/
 ├─ MyLib.hs
 ├─ MyLib/
 │   ├─ Core.hs
 │   ├─ Utils.hs
 │   └─ Internal/
 │       └─ Helpers.hs
</code></pre>

    <br/>
    <ul>
        <li>Modules inside <code>Internal</code>:
            <ul>
                <li>are <b>not</b> exported publicly,</li>
                <li>may change without warning,</li>
                <li>are implementation details.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Module Initialization and Side Effects</b></li>
    <br/>
    <ul>
        <li>Modules do <b>not</b> have “init blocks” like Python or Java.</li>
        <li>No code runs at module load time except:
            <ul>
                <li>top-level CAFs (constants) are lazy,</li>
                <li>IO actions <b>cannot</b> appear at the top-level, except inside <code>main</code>.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = putStrLn "Program started"
</code></pre>

    <br/><br/>


    <li><b>Modules and Name Resolution</b></li>
    <br/>
    <ul>
        <li>To avoid collisions, Haskell prefers <b>qualified imports</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import qualified Data.Map as M

M.lookup "a" (M.fromList [("a",1)])
</code></pre>

    <br/>
    <ul>
        <li>Haskell supports:
            <ul>
                <li>unqualified imports,</li>
                <li>qualified imports (<code>qualified</code>),</li>
                <li>import lists (<code>(x,y,z)</code>),</li>
                <li>hiding lists (<code>hiding (a,b)</code>).</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Modules for Namespacing</b></li>
    <br/>
    <ul>
        <li>Names inside modules cannot conflict across modules:</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- In File A:
module Foo where
x = 10

-- In File B:
module Bar where
x = 20
</code></pre>

    <br/>
    <ul>
        <li>To refer explicitly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import qualified Foo
import qualified Bar

Foo.x    -- 10
Bar.x    -- 20
</code></pre>

    <br/><br/>


    <li><b>Modules and Cabal/Stack Projects</b></li>
    <br/>
    <ul>
        <li>In Cabal and Stack, the <b>exposed-modules</b> field determines:
            <ul>
                <li>which modules form the public API of a library,</li>
                <li>which ones are hidden internally.</li>
            </ul>
        </li>
        <li>Example <code>package.yaml</code> or <code>.cabal</code> entry:</li>
    </ul>

<pre><code class="language-haskell line-numbers">exposed-modules:
    MyLib
    MyLib.Core
other-modules:
    MyLib.Internal.Helpers
</code></pre>

    <br/><br/>


    <li><b>Creating Your Own Module</b></li>
    <br/>
    <ul>
        <li>Example: <code>src/Utils/StringTools.hs</code></li>
    </ul>

<pre><code class="language-haskell line-numbers">module Utils.StringTools
    ( capitalize
    , reverseWords
    ) where

import Data.Char (toUpper)

capitalize :: String -&gt; String
capitalize [] = []
capitalize (x:xs) = toUpper x : xs

reverseWords :: String -&gt; String
reverseWords = unwords . reverse . words
</code></pre>

    <br/>
    <ul>
        <li>Use it in <code>Main.hs</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">module Main where

import Utils.StringTools

main = putStrLn (capitalize "hello world")
</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-deriving">Deriving Instances in Haskell</h3>
<ol>
    <li><b>What Does &quot;Deriving&quot; Mean in Haskell?</b></li>
    <br/>
    <ul>
        <li>In Haskell, many behaviors are expressed via <b>typeclasses</b> (e.g. <code>Eq</code>, <code>Show</code>, <code>Ord</code>).</li>
        <br/>
        <li>An <b>instance</b> tells the compiler how a specific type supports a given typeclass.</li>
        <br/>
        <li><b>Deriving</b> allows the compiler to automatically generate <b>standard</b> instance implementations for many common typeclasses.</li>
        <br/>
        <li>Instead of writing:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue

instance Eq Color where
    Red   == Red   = True
    Green == Green = True
    Blue  == Blue  = True
    _     == _     = False

instance Show Color where
    show Red   = &quot;Red&quot;
    show Green = &quot;Green&quot;
    show Blue  = &quot;Blue&quot;
</code></pre>

    <br/>
    <ul>
        <li>you can simply write:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue
    deriving (Eq, Show)
</code></pre>

    <br/>
    <ul>
        <li>The compiler generates the &quot;obvious&quot; instances for you, based on the data declaration.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Deriving Syntax</b></li>
    <br/>
    <ul>
        <li>The simplest form is attached directly to a <code>data</code> or <code>newtype</code> definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Point = Point Int Int
    deriving (Eq, Show)
</code></pre>

    <br/>
    <ul>
        <li>This creates:
            <ul>
                <li><code>Eq Point</code> instance: two <code>Point</code>s are equal if both coordinates are equal.</li>
                <li><code>Show Point</code> instance: <code>show (Point 1 2)</code> produces something like <code>&quot;Point 1 2&quot;</code>.</li>
            </ul>
        </li>
        <li>You can derive multiple classes at once by listing them in parentheses separated by commas.</li>
    </ul>
    <br/><br/>



    <li><b>Example: Deriving Eq and Show for an ADT</b></li>
    <br/>
    <ul>
        <li>Consider an expression tree:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Expr
    = Lit Int
    | Add Expr Expr
    | Mul Expr Expr
    deriving (Eq, Show)
</code></pre>

    <br/>
    <ul>
        <li>Now you can:</li>
    </ul>

<pre><code class="language-haskell line-numbers">e1 :: Expr
e1 = Add (Lit 1) (Mul (Lit 2) (Lit 3))

e2 :: Expr
e2 = Add (Lit 1) (Mul (Lit 2) (Lit 3))

e3 :: Expr
e3 = Add (Lit 1) (Lit 2)

e1 == e2       -- True
e1 == e3       -- False
show e1        -- &quot;Add (Lit 1) (Mul (Lit 2) (Lit 3))&quot;
</code></pre>

    <br/>
    <ul>
        <li>No manual <code>Eq</code> or <code>Show</code> instance required.</li>
    </ul>
    <br/><br/>


    <li><b>Deriving Enum and Bounded</b></li>
    <br/>
    <ul>
        <li>For simple enumerations, deriving <code>Enum</code> and <code>Bounded</code> is very convenient:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Color = Red | Green | Blue
    deriving (Eq, Ord, Show, Enum, Bounded)

allColors :: [Color]
allColors = [minBound .. maxBound]
-- [Red,Green,Blue]

succ Red    -- Green
pred Blue   -- Green
fromEnum Red   -- 0
fromEnum Blue  -- 2
</code></pre>

    <br/>
    <ul>
        <li>The order is the declaration order: <code>Red &lt; Green &lt; Blue</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Deriving for Parameterized Types</b></li>
    <br/>
    <ul>
        <li>You can derive instances for types with type parameters too:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Pair a = Pair a a
    deriving (Eq, Ord, Show, Functor)
</code></pre>

    <br/>
    <ul>
        <li>Some classes (like <code>Functor</code>) require GHC extensions (<code>DeriveFunctor</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE DeriveFunctor #-}

data Tree a
    = Leaf a
    | Node (Tree a) (Tree a)
    deriving (Eq, Show, Functor)
</code></pre>

    <br/>
    <ul>
        <li>Now you can <code>fmap</code> over trees:</li>
    </ul>

<pre><code class="language-haskell line-numbers">fmap (+1) (Leaf 3)     -- Leaf 4
</code></pre>

    <br/><br/>


    <li><b>Deriving for Newtypes</b></li>
    <br/>
    <ul>
        <li><code>newtype</code> defines a type with exactly one constructor and one field, with <b>no runtime overhead</b>.</li>
        <li>You can often derive instances for a <code>newtype</code> based on the underlying type.</li>
    </ul>

<pre><code class="language-haskell line-numbers">newtype UserId = UserId Int
    deriving (Eq, Ord, Show)
</code></pre>

    <br/>
    <ul>
        <li>This works because <code>UserId</code> has the same runtime representation as <code>Int</code>.</li>
        <li>You can also use more advanced newtype-deriving via extensions (see below).</li>
    </ul>
    <br/><br/>


    <li><b>Standalone Deriving</b></li>
    <br/>
    <ul>
        <li>With the <code>StandaloneDeriving</code> extension, you can write <b>deriving declarations separate</b> from the type definition.</li>
        <li>Enable the extension:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE StandaloneDeriving #-}
</code></pre>

    <br/>
    <ul>
        <li>Then:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Foo a = Foo a

-- later in the file, or even another module (with some restrictions):
deriving instance Eq a =&gt; Eq (Foo a)
deriving instance Show a =&gt; Show (Foo a)
</code></pre>

    <br/>
    <ul>
        <li>Useful when:
            <ul>
                <li>you cannot or do not want to modify the original type definition,</li>
                <li>you want instances in a different module,</li>
                <li>you have conditional instances depending on constraints.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Deriving Strategies: stock, newtype, anyclass, via</b></li>
    <br/>
    <ul>
        <li>GHC supports multiple <b>deriving strategies</b> (with <code>DerivingStrategies</code> extension):</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE DerivingStrategies #-}
</code></pre>

    <br/>
    <ul>
        <li>Then you can annotate each deriving clause:</li>
    </ul>

<pre><code class="language-haskell line-numbers">newtype Age = Age Int
    deriving stock    (Eq, Show)
    deriving newtype  (Ord, Num)
</code></pre>

    <br/>
    <ul>
        <li><b>stock</b>:
            <ul>
                <li>Use the compiler’s built-in deriving mechanism (for types like <code>Eq</code>, <code>Ord</code>, <code>Show</code>, <code>Enum</code>, etc.).</li>
            </ul>
        </li>
        <li><b>newtype</b>:
            <ul>
                <li>Derive an instance by reusing the instance of the underlying type.</li>
            </ul>
        </li>
        <li><b>anyclass</b>:
            <ul>
                <li>Provide a default instance for any class that has default methods.</li>
                <li>Often used in combination with generic programming.</li>
            </ul>
        </li>
        <li><b>via</b> (with <code>DerivingVia</code> extension):
            <ul>
                <li>Derive via another &quot;helper&quot; type that already has the desired instance.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Example: Newtype Deriving for Numeric Behavior</b></li>
    <br/>
    <ul>
        <li>Suppose you have a type representing a quantity that should behave like a number:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE GeneralizedNewtypeDeriving #-}

newtype Distance = Distance Double
    deriving (Eq, Ord, Show, Num, Fractional)
</code></pre>

    <br/>
    <ul>
        <li>Now you can use numeric operations directly:</li>
    </ul>

<pre><code class="language-haskell line-numbers">d1 :: Distance
d1 = 10

d2 :: Distance
d2 = 2.5

d1 + d2         -- Distance 12.5
d1 * 2          -- Distance 20.0
</code></pre>

    <br/>
    <ul>
        <li>This uses <b>newtype deriving</b> to reuse <code>Double</code>&apos;s instances.</li>
    </ul>
    <br/><br/>


    <li><b>Deriving Generic / Generic1</b></li>
    <br/>
    <ul>
        <li>With <code>DeriveGeneric</code>, you can derive <code>Generic</code> and <code>Generic1</code> to support generic programming and libraries like Aeson (JSON).</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE DeriveGeneric #-}

import GHC.Generics (Generic)

data User = User
    { name :: String
    , age  :: Int
    } deriving (Show, Generic)
</code></pre>

    <br/>
    <ul>
        <li>Then libraries can auto-derive things like JSON encoders/decoders using the <code>Generic</code> representation.</li>
    </ul>
    <br/><br/>


    <li><b>Deriving Anyclass</b></li>
    <br/>
    <ul>
        <li>With <code>DeriveAnyClass</code>, you can derive instances for custom typeclasses that provide default method implementations.</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric  #-}

import GHC.Generics (Generic)

class MyClass a where
    describe :: a -&gt; String
    describe _ = &quot;default&quot;

data Foo = Foo Int
    deriving (Generic, MyClass)
</code></pre>

    <br/>
    <ul>
        <li>Here the <code>MyClass</code> instance for <code>Foo</code> uses the default <code>describe</code> implementation.</li>
        <li>Often combined with <code>Generic</code> to write generic default definitions.</li>
    </ul>
    <br/><br/>


    <li><b>Deriving Via (Advanced)</b></li>
    <br/>
    <ul>
        <li><code>DerivingVia</code> lets you derive an instance &quot;via&quot; another type that already has the right behavior.</li>
        <li>You need the <code>DerivingVia</code> extension and a helper newtype.</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

import Data.Monoid (Sum(..))

newtype Score = Score Int
    deriving (Eq, Show)
    deriving (Semigroup, Monoid) via (Sum Int)
</code></pre>

    <br/>
    <ul>
        <li>Now <code>Score</code> has <code>Semigroup</code> and <code>Monoid</code> instances that behave like <code>Sum Int</code>, without writing any instance code.</li>
    </ul>
    <br/><br/>


</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-constraint-arrow">The <code>=&gt;</code> Operator (Constraint Arrow) in Haskell</h3>
<ol>
    <li><b>What Is the</b> <code>=&gt;</code> <b>Operator?</b></li>
    <br/>
    <ul>
        <li>The <code>=&gt;</code> operator in Haskell is called the <b>constraint arrow</b>.</li>
        <br/>
        <li>It appears in type signatures and separates:
            <ul>
                <li>a list of <b>typeclass constraints</b>, and</li>
                <li>the <b>actual type</b> of the function.</li>
            </ul>
        </li>
        <br/>
        <li>General shape:</li>
<pre><code class="language-haskell line-numbers">constraint1, constraint2, ... =&gt; type
</code></pre>
    </ul>

    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-haskell line-numbers">show :: Show a =&gt; a -&gt; String
</code></pre>
    </ul>
    <br/><br/>


    <li><b>Constraints Are Typeclass Requirements</b></li>
    <br/>
    <ul>
        <li>A constraint has the form:</li>
    </ul>

<pre><code class="language-haskell line-numbers">ClassName typeVariable
</code></pre>

    <br/>
    <ul>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Eq a        -- a supports equality
Ord a       -- a supports ordering
Num a       -- a acts like a number
Monad m     -- m is a monad
Functor f   -- f is a functor
</code></pre>

    <br/>
    <ul>
        <li>In the type signature:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Eq a =&gt; a -&gt; a -&gt; Bool
</code></pre>

    <br/>
    <ul>
        <li>This means the function:
            <ul>
                <li>takes two values of type <code>a</code>,</li>
                <li>requires that <code>a</code> belongs to <code>Eq</code>,</li>
                <li>returns a <code>Bool</code>.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Multiple Constraints Using a Tuple</b></li>
    <br/>
    <ul>
        <li>Multiple constraints appear inside parentheses and separated by commas:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(Eq a, Show a) =&gt; a -&gt; String
</code></pre>

    <br/>
    <ul>
        <li>This means:
            <ul>
                <li><code>a</code> must support both <code>Eq</code> and <code>Show</code>.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>How GHC Interprets the Constraint Arrow</b></li>
    <br/>
    <ul>
        <li>Conceptually, the type:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Eq a =&gt; a -&gt; a -&gt; Bool
</code></pre>

    <br/>
    <ul>
        <li>means “for all types <code>a</code> that satisfy <code>Eq a</code>”.</li>
        <li>Behind the scenes, GHC passes dictionaries containing the functions of the typeclass instance.</li>
        <li>For example:
            <ul>
                <li><code>Eq a</code> provides <code>(==)</code> and <code>(/=)</code>.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Example: Using a Constraint in a Function</b></li>
    <br/>
    <ul>
        <li>Here is a function using the <code>Eq</code> constraint:</li>
    </ul>

<pre><code class="language-haskell line-numbers">isIn :: Eq a =&gt; a -&gt; [a] -&gt; Bool
isIn x xs = any (== x) xs
</code></pre>

    <br/>
    <ul>
        <li>Why do we need the constraint?</li>
        <li>Because <code>(==)</code> is only defined for types in <code>Eq</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Constraint Arrow with Polymorphic Functions</b></li>
    <br/>
    <ul>
        <li>Functions may require multiple constraints to use multiple typeclass methods:</li>
    </ul>

<pre><code class="language-haskell line-numbers">compareAndShow :: (Ord a, Show a) =&gt; a -&gt; a -&gt; String
compareAndShow x y =
    if x &gt; y
    then show x ++ " &gt; " ++ show y
    else if x == y
    then show x ++ " == " ++ show y
    else show x ++ " &lt; " ++ show y
</code></pre>

    <br/><br/>


    <li><b><code>=&gt;</code> vs <code>-&gt;</code></b></li>
    <br/>
    <ul>
        <li>These look similar but have completely different meanings.</li>
    </ul>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Meaning</th>
        </tr>
        <tr>
            <td><code>-&gt;</code></td>
            <td>Function arrow: maps inputs to outputs.</td>
        </tr>
        <tr>
            <td><code>=&gt;</code></td>
            <td>Constraint arrow: says that certain typeclasses must be satisfied.</td>
        </tr>
    </table>

    <br/>
    <ul>
        <li>Example of both in one signature:</li>
    </ul>

<pre><code class="language-haskell line-numbers">foo :: (Eq a, Show a) =&gt; a -&gt; a -&gt; String
</code></pre>

    <br/><br/>


    <li><b>Constraint Arrow in Typeclass Definitions</b></li>
    <br/>
    <ul>
        <li>Typeclasses themselves may impose constraints on their parameters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class (Eq a, Show a) =&gt; MyClass a where
    foo :: a -&gt; String
</code></pre>

    <br/>
    <ul>
        <li>This means any instance of <code>MyClass</code> must also be an instance of <code>Eq</code> and <code>Show</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Constraint Arrow in Instance Declarations</b></li>
    <br/>
    <ul>
        <li>Instance declarations can also have constraints:</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance (Eq a, Show a) =&gt; Show (Pair a) where
    show (Pair x y) = "(" ++ show x ++ "," ++ show y ++ ")"
</code></pre>

    <br/>
    <ul>
        <li>Here, <code>Pair a</code> has a <code>Show</code> instance as long as <code>a</code> has both <code>Eq</code> and <code>Show</code> instances.</li>
    </ul>

    <br/><br/>


    <li><b>Constraint Arrow Inside Type Synonyms</b> (Using <code>ConstraintKinds</code>)</li>
    <br/>
    <ul>
        <li>With the <code>ConstraintKinds</code> extension, constraints themselves become first-class:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE ConstraintKinds #-}

type Number a = (Num a, Ord a)
</code></pre>

    <br/>
    <ul>
        <li>Use it like this:</li>
    </ul>

<pre><code class="language-haskell line-numbers">foo :: Number a =&gt; a -&gt; a -&gt; a
foo x y = if x &gt; y then x else y
</code></pre>

    <br/><br/>


    <li><b>Constraint Arrow in Higher-Kinded Types</b></li>
    <br/>
    <ul>
        <li>Some typeclasses operate on type constructors, requiring constraints on type parameters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Functor f =&gt; Applicative f where
    pure  :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

    <br/>
    <ul>
        <li>The constraint <code>Functor f =&gt;</code> ensures that every <code>Applicative</code> is also a <code>Functor</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Constraint Arrow with Forall Quantifiers</b> (Advanced)</li>
    <br/>
    <ul>
        <li>Using extensions like <code>RankNTypes</code>, constraints can appear in polymorphic types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE RankNTypes #-}

bar :: (forall a. Show a =&gt; a -&gt; String) -&gt; (String, String)
bar f = (f 3, f "hi")
</code></pre>

    <br/>
    <ul>
        <li>Here <code>Show a =&gt;</code> applies inside a universal quantifier.</li>
    </ul>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-kinds-star">Kinds <code>*</code> and <code>* -&gt; *</code> in Haskell</h3>
<ol>
    <li><b>What Are Kinds?</b></li>
    <br/>
    <ul>
        <li>In Haskell, <b>types</b> classify <b>values</b>, and <b>kinds</b> classify <b>types</b>.</li>
        <br/>
        <li>You can think of kinds as "types of types".</li>
        <br/>
        <li>The most common kind is <code>*</code>, pronounced &quot;star&quot; or &quot;Type&quot;.</li>
        <br/>
        <li>Historically and in GHCi, you will often see <code>*</code>, more modern notation uses <code>Type</code> (from <code>Data.Kind</code>), but the idea is the same.</li>
    </ul>

<pre><code class="language-haskell line-numbers">-- Value has a type:
42       :: Int

-- Type has a kind:
Int      :: *
Maybe    :: * -&gt; *
Either   :: * -&gt; * -&gt; *
</code></pre>

    <br/>
    <ul>
        <li>You can inspect kinds in GHCi with <code>:k</code> or <code>:kind</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Kind <code>*</code>: Concrete (Fully Applied) Types</b></li>
    <br/>
    <ul>
        <li>A type of kind <code>*</code> is a <b>concrete type</b> that can have <b>values</b>.</li>
        <li>Examples of types of kind <code>*</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Int       :: *
Bool      :: *
Char      :: *
[Int]     :: *
Maybe Int :: *
Either String Int :: *
</code></pre>

    <br/>
    <ul>
        <li>All of these can appear as the type of a value or function parameter/result:</li>
    </ul>

<pre><code class="language-haskell line-numbers">x :: Int
x = 42

name :: String
name = "haskell"

maybeNum :: Maybe Int
maybeNum = Just 10
</code></pre>

    <br/>
    <ul>
        <li>Key point: <b>only types of kind <code>*</code> classify actual runtime values</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Kind <code>* -&gt; *</code>: Type Constructors</b></li>
    <br/>
    <ul>
        <li>A type of kind <code>* -&gt; *</code> is a <b>type constructor</b> that takes a concrete type and returns a concrete type.</li>
        <li>It is &quot;waiting for one type argument&quot;.</li>
        <li>Examples:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Maybe :: * -&gt; *
[]    :: * -&gt; *
IO    :: * -&gt; *
</code></pre>

    <br/>
    <ul>
        <li>When you apply them to a type of kind <code>*</code>, you get a new type of kind <code>*</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Maybe Int  :: *
Maybe Bool :: *

[Char]   :: *
IO Int   :: *
</code></pre>

    <br/>
    <ul>
        <li>Think of <code>Maybe</code> as a function at the type level:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Maybe   :: * -&gt; *
Maybe a :: *   -- when a :: *
</code></pre>

    <br/><br/>


    <li><b>Higher-Kinded Types: <code>* -&gt; * -&gt; *</code> and Beyond</b></li>
    <br/>
    <ul>
        <li>Some type constructors take <b>two</b> or more type parameters:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Either :: * -&gt; * -&gt; *
(,)    :: * -&gt; * -&gt; *
</code></pre>

    <br/>
    <ul>
        <li><code>Either</code> takes two <code>*</code> types:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Either String Int :: *

Either String  :: * -&gt; *   -- partially applied
Either         :: * -&gt; * -&gt; *
</code></pre>

    <br/>
    <ul>
        <li>You can partially apply type constructors, just like functions.</li>
        <li>Higher kinds (like <code>(* -&gt; *) -&gt; *</code>, etc.) appear with more advanced type-level programming, but the core idea stays the same.</li>
    </ul>
    <br/><br/>


    <li><b>Why <code>* -&gt; *</code> Matters: Typeclasses Like Functor and Monad</b></li>
    <br/>
    <ul>
        <li>Many important typeclasses (like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>) work on <b>type constructors</b> of kind <code>* -&gt; *</code>, not on concrete types.</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

    <br/>
    <ul>
        <li>Here <code>f</code> must have kind <code>* -&gt; *</code>, because we use <code>f a</code> and <code>f b</code> where <code>a</code> and <code>b</code> are concrete types (<code>*</code>).</li>
        <li>Examples of valid <code>Functor</code> instances:</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance Functor Maybe where ...
instance Functor [] where ...
instance Functor IO where ...
instance Functor (Either e) where ...
</code></pre>

    <br/>
    <ul>
        <li>Notice <code>Either</code> has kind <code>* -&gt; * -&gt; *</code>, but we turn it into a <code>* -&gt; *</code> by fixing the first argument: <code>(Either e)</code>.</li>
        <li>You <b>cannot</b> write <code>instance Functor Int where ...</code>, because <code>Int :: *</code>, not <code>* -&gt; *</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Using</b> <code>:kind</code> <b>in GHCi</b></li>
    <br/>
    <ul>
        <li>GHCi lets you inspect kinds with <code>:k</code> (or <code>:kind</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">Prelude&gt; :k Int
Int :: *

Prelude&gt; :k Maybe
Maybe :: * -&gt; *

Prelude&gt; :k Maybe Int
Maybe Int :: *

Prelude&gt; :k Either
Either :: * -&gt; * -&gt; *

Prelude&gt; :k Either String
Either String :: * -&gt; *
</code></pre>

    <br/>
    <ul>
        <li>This is extremely helpful for understanding whether something is a concrete type or a type constructor.</li>
    </ul>
    <br/><br/>


    <li><b><code>*</code> vs <code>Type</code></b></li>
    <br/>
    <ul>
        <li>Modern GHC internally uses <code>Type</code> (from <code>Data.Kind</code>) instead of <code>*</code>, but conceptually they are equivalent.</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Kind (Type)

-- These are conceptually the same:
Int   :: Type
Maybe :: Type -&gt; Type
</code></pre>

    <br/>
    <ul>
        <li>You will still often see <code>*</code> in documentation and GHCi output, especially in older code; just read <code>*</code> as &quot;Type&quot;.</li>
    </ul>
    <br/><br/>


    <li><b>Advanced: Beyond <code>*</code> (Other Kinds)</b></li>
    <br/>
    <ul>
        <li>With extensions like <code>DataKinds</code>, kinds become richer:</li>
    </ul>

<pre><code class="language-haskell line-numbers">{-# LANGUAGE DataKinds #-}

-- Promoted values become types, and types get more specific kinds
data Color = Red | Green | Blue
-- Kinds: Color, not just *
</code></pre>

    <br/>
    <ul>
        <li>But for a large amount of everyday Haskell, focusing on <code>*</code> and <code>* -&gt; *</code> is enough.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-io">Input and Output in Haskell</h3>
<ol>
    <li><b>Why Is IO Special in Haskell?</b></li>
    <br/>
    <ul>
        <li>Haskell is a <b>pure functional language</b>:
            <ul>
                <li>Functions cannot have side effects (e.g., printing, reading files, randomness) unless explicitly marked.</li>
                <li>Every pure function must always produce the same output for the same input.</li>
            </ul>
        </li>
        <br/>
        <li>But real programs must interact with the world.</li>
        <br/>
        <li>Haskell solves this using the <b>IO type</b> and the <b>IO Monad</b>.</li>
        <br/>
        <li>Key idea:
            <ul>
                <li>IO values describe actions.</li>
                <li>The runtime <b>executes</b> them only inside <code>main</code>.</li>
            </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = putStrLn "Hello!"
</code></pre>
        </li>
    </ul>

    <br/>
    <ul>
        <li><code>putStrLn "Hello!"</code> has type <code>IO ()</code> meaning:
            <ul>
                <li>an IO action that outputs a string,</li>
                <li>with no useful return value (<code>()</code>).</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>The IO Type</b></li>
    <br/>
    <ul>
        <li>IO is a <b>type constructor</b> with kind <code>* -&gt; *</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">IO :: * -&gt; *
</code></pre>

    <br/>
    <ul>
        <li>This means IO wraps a “normal type” to represent an action returning that type:</li>
    </ul>

<pre><code class="language-haskell line-numbers">IO Int       -- an action that returns an Int
IO String    -- an action that returns a String
IO ()        -- an action with no meaningful result
</code></pre>

    <br/>
    <ul>
        <li>You do NOT execute IO actions yourself, Haskell's runtime does.</li>
    </ul>
    <br/><br/>


    <li><b>Do-notation: Sequencing IO</b></li>
    <br/>
    <ul>
        <li>IO actions are sequenced with <code>do</code>-notation:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    putStrLn "Enter your name:"
    name &lt;- getLine
    putStrLn ("Hello, " ++ name ++ "!")
</code></pre>

    <br/>
    <ul>
        <li>Facts about do-notation:</li>
        <ul>
            <li>LHS of <code>&lt;-</code> extracts the <b>pure value</b> from an IO action.</li>
            <li>You may only use <code>&lt;-</code> with IO actions.</li>
            <li>Last expression in a <code>do</code>-block must be an IO action.</li>
        </ul>
    </ul>

<pre><code class="language-haskell line-numbers">x &lt;- 3           -- ❌ illegal, 3 is not an IO action
y &lt;- getLine     -- ✔️ OK
</code></pre>
    <br/><br/>


    <li><b>Basic IO Operations</b></li>
    <br/>
    <ul>
        <li><b>Printing</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">putStr    :: String -&gt; IO ()
putStrLn  :: String -&gt; IO ()
print     :: Show a =&gt; a -&gt; IO ()
</code></pre>

    <ul>
        <li><code>print</code> is equivalent to <code>putStrLn . show</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">print 123         -- outputs "123"
putStr "hi"       -- outputs hi
putStrLn "hi"     -- outputs hi\n
</code></pre>

    <br/>
    <ul>
        <li><b>Input</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">getLine :: IO String
getChar :: IO Char
getContents :: IO String   -- lazy input until EOF
</code></pre>

    <br/><br/>


    <li><b>Reading and parsing input</b></li>
    <br/>
    <ul>
        <li>Use <code>read</code> when input should be parsed:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    putStrLn "Enter a number:"
    s &lt;- getLine
    let n = read s :: Int
    print (n + 10)
</code></pre>

    <br/>
    <ul>
        <li>Use <code>readMaybe</code> (from <code>Text.Read</code>) for safe parsing.</li>
    </ul>
    <br/><br/>


    <li><b>Lazy IO vs Strict IO</b></li>
    <br/>
    <ul>
        <li><b>Lazy IO</b> (e.g., <code>getContents</code>):
            <ul>
                <li>reads input lazily on demand,</li>
                <li>may keep file handles open longer,</li>
                <li>can cause unexpected side effects or resource leaks.</li>
            </ul>
        </li>
        <li><b>Strict IO</b> using <code>hGetContents'</code> or <code>ByteString</code> usually preferred.</li>
    </ul>
    <br/><br/>


    <li><b>IO as a Monad</b></li>
    <br/>
    <ul>
        <li><code>IO</code> implements <b>Functor</b>, <b>Applicative</b>, and <b>Monad</b>.</li>
        <li>You can use:
            <ul>
                <li><code>&lt;$&gt;</code> / <code>fmap</code></li>
                <li><code>&lt;*&gt;</code></li>
                <li><code>&gt;&gt;=</code> (bind)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">main =
    getLine &gt;&gt;= \name -&gt;
    putStrLn ("Hello " ++ name)
</code></pre>

    <br/>
    <ul>
        <li>This is exactly equivalent to:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    name &lt;- getLine
    putStrLn ("Hello " ++ name)
</code></pre>

    <br/><br/>


    <li><b>Chaining IO Actions Without Extracting Values</b></li>
    <br/>
    <ul>
        <li>When no value is needed, use <code>&gt;&gt;</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">putStrLn "A"
    &gt;&gt; putStrLn "B"
    &gt;&gt; putStrLn "C"
</code></pre>

    <br/>
    <ul>
        <li>Or inside a <code>do</code>-block:</li>
    </ul>

<pre><code class="language-haskell line-numbers">do
    putStrLn "A"
    putStrLn "B"
    putStrLn "C"
</code></pre>
    <br/><br/>


    <li><b>Working with Files</b></li>
    <br/>
    <ul>
        <li>Useful functions (from <code>System.IO</code>):</li>
    </ul>

<pre><code class="language-haskell line-numbers">readFile  :: FilePath -&gt; IO String
writeFile :: FilePath -&gt; String -&gt; IO ()
appendFile :: FilePath -&gt; String -&gt; IO ()

openFile  :: FilePath -&gt; IOMode -&gt; IO Handle
hGetLine  :: Handle -&gt; IO String
hPutStrLn :: Handle -&gt; String -&gt; IO ()
hClose    :: Handle -&gt; IO ()
</code></pre>

    <br/>
    <ul>
        <li>Example of file reading:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    content &lt;- readFile "data.txt"
    putStrLn "File contents:"
    putStrLn content
</code></pre>

    <br/>
    <ul>
        <li>Example of manual handle management:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    h &lt;- openFile "log.txt" AppendMode
    hPutStrLn h "new log entry"
    hClose h
</code></pre>

    <br/><br/>


    <li><b>Exception Handling in IO</b></li>
    <br/>
    <ul>
        <li>Use <code>Control.Exception</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Control.Exception (catch, IOException)

main = do
    content &lt;- catch (readFile "xxx.txt")
                    (\e -&gt; do let _ = e :: IOException
                              putStrLn "File not found!"
                              return "")
    putStrLn content
</code></pre>

    <br/><br/>


    <li><b>IO with pure functions</b></li>
    <br/>
    <ul>
        <li>You cannot call IO inside pure code.</li>
        <li>But pure functions can be used *inside* IO for transformations:</li>
    </ul>

<pre><code class="language-haskell line-numbers">process :: String -&gt; Int
process = length

main = do
    s &lt;- getLine
    print (process s)
</code></pre>

    <br/>
    <ul>
        <li>Always separate <b>pure computation</b> from <b>IO orchestration</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Returning values from IO</b></li>
    <br/>
    <ul>
        <li>Use <code>return</code> (or <code>pure</code>) to inject a pure value into IO:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    let x = 10
    y &lt;- return (x * 2)
    print y
</code></pre>

    <br/>
    <ul>
        <li><code>return</code> does NOT exit a function; it wraps a value in <code>IO</code>.</li>
    </ul>

<pre><code class="language-haskell line-numbers">return x :: IO x
</code></pre>

    <br/><br/>


    <li><b>Infinite IO Loops</b></li>
    <br/>
    <ul>
        <li>Because IO is monadic, infinite loops are easy:</li>
    </ul>

<pre><code class="language-haskell line-numbers">forever :: IO a -&gt; IO b
</code></pre>

<pre><code class="language-haskell line-numbers">main = forever $ do
    putStrLn "Enter something:"
    s &lt;- getLine
    print (length s)
</code></pre>

    <br/><br/>


    <li><b>Sequencing a List of IO Actions</b></li>
    <br/>
    <ul>
        <li>Haskell provides:</li>
    </ul>

<pre><code class="language-haskell line-numbers">sequence  :: [IO a] -&gt; IO [a]
mapM      :: (a -&gt; IO b) -&gt; [a] -&gt; IO [b]
mapM_     :: (a -&gt; IO b) -&gt; [a] -&gt; IO ()
traverse  :: Applicative f =&gt; (a -&gt; f b) -&gt; [a] -&gt; f [b]
</code></pre>

<pre><code class="language-haskell line-numbers">main = do
    names &lt;- mapM (\_ -&gt; getLine) [1..3]
    print names
</code></pre>

    <br/><br/>
</ol>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-functor-applicative-monoid">Functors, Applicative Functors, and Monoids in Haskell</h3>
<ol>
    <li><b>Overview</b></li>
    <br/>
    <ul>
        <li>This chapter introduces three of the most important abstractions in Haskell’s typeclass hierarchy:</li>
        <ul>
            <li><b>Functor</b> — things you can map over</li>
            <li><b>Applicative</b> — functors with function application inside a context</li>
            <li><b>Monoid</b> — things that can be combined with an identity</li>
        </ul>
        <br/>
        <li>They are foundational for Haskell’s standard library, parsing libraries, IO sequencing, concurrent programming, and functional design.</li>
        <br/>
        <li>These abstractions come from category theory, but we will focus on the practical usage first.</li>
    </ul>
    <br/><br/>


    <li><b>Functors: Mapping Over a Structure</b></li>
    <br/>
    <ul>
        <li>A <b>Functor</b> allows you to apply a pure function to values <b>inside</b> a context (container-like structure).</li>
        <li>Definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

    <br/>
    <ul>
        <li><b>Key idea:</b> <code>fmap</code> applies a function to the values inside a structure without modifying its shape.</li>
        <li>Examples of functors:
            <ul>
                <li><code>[]</code> (lists)</li>
                <li><code>Maybe</code></li>
                <li><code>Either e</code></li>
                <li><code>IO</code></li>
                <li><code>Tree</code> (user-defined)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-haskell line-numbers">fmap (+1) [1,2,3]           -- [2,3,4]
fmap (*2) (Just 10)         -- Just 20
fmap (*2) Nothing           -- Nothing
fmap reverse (Right "xy")   -- Right "yx"
</code></pre>

    <br/>
    <ul>
        <li><b>Functor Laws</b> (must hold for lawful functors):
            <ul>
                <li>Identity: <code>fmap id x = x</code></li>
                <li>Composition: <code>fmap (f . g) x = fmap f (fmap g x)</code></li>
            </ul>
        </li>
        <li>These laws ensure predictable behavior and composability.</li>
    </ul>
    <br/><br/>


    <li><b>Applicative Functors: Combining Contextual Values</b></li>
    <br/>
    <ul>
        <li>An <b>applicative functor</b> extends Functor with the ability to apply functions wrapped in a context to wrapped values.</li>
        <li>Definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Functor f =&gt; Applicative f where
    pure  :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

    <br/>
    <ul>
        <li><code>pure</code>: injects a value into the context.</li>
        <li><code>&lt;*&gt;</code> (“apply”): applies a wrapped function to a wrapped value.</li>
    </ul>

<pre><code class="language-haskell line-numbers">pure (+1) &lt;*&gt; Just 10    -- Just 11
pure (+1) &lt;*&gt; Nothing    -- Nothing

[(+1), (*2)] &lt;*&gt; [10,20]   -- [11,21,12,22]
</code></pre>

    <br/>
    <ul>
        <li>Applicatives allow <b>multiple independent computations</b> to run in parallel (conceptually).</li>
        <li>Using applicatives is cleaner than monads when dependencies are not sequential.</li>
    </ul>

    <br/><br/>

    <li><b>Applicative with Syntactic Sugar: <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code></b></li>
    <br/>
    <ul>
        <li><code>fmap f x</code> is usually written as <code>f &lt;$&gt; x</code>.</li>
        <li>You can combine <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Just (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5   -- Just 8

(+) &lt;$&gt; Just 3 &lt;*&gt; Just 5        -- Just 8
</code></pre>

    <br/><br/>


    <li><b>Applicative Examples</b></li>
    <br/>

    <ul>
        <li><b>Example: Reading two inputs</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">pair :: IO (String, String)
pair = (,) &lt;$&gt; getLine &lt;*&gt; getLine
</code></pre>

    <ul>
        <li><code>(,) &lt;$&gt; getLine</code> creates a function inside <code>IO</code>.</li>
        <li><code>&lt;*&gt;</code> applies it to the second <code>getLine</code>.</li>
    </ul>

    <br/><br/>

    <ul>
        <li><b>Example: Validating multiple fields</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">User &lt;$&gt; validateName name
     &lt;*&gt; validateAge age
     &lt;*&gt; validateEmail email
</code></pre>

    <ul>
        <li>Each field is validated independently.</li>
        <li>If validations return <code>Maybe</code>, the whole result fails if any field fails.</li>
    </ul>

    <br/><br/>


    <li><b>Monoids: Combining Values</b></li>
    <br/>
    <ul>
        <li>A <b>Monoid</b> is a type with an associative binary operation and an identity element.</li>
        <li>Definition:</li>
    </ul>

<pre><code class="language-haskell line-numbers">class Monoid m where
    mempty  :: m
    mappend :: m -&gt; m -&gt; m       -- (deprecated in favor of &lt;&gt;)
    (&lt;&gt;)    :: m -&gt; m -&gt; m
</code></pre>

    <br/>
    <ul>
        <li><b>Laws:</b>
            <ul>
                <li>Left identity: <code>mempty &lt;&gt; x = x</code></li>
                <li>Right identity: <code>x &lt;&gt; mempty = x</code></li>
                <li>Associativity: <code>(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</code></li>
            </ul>
        </li>
        <li>Monoids are extremely common because “combine” is a universal concept.</li>
    </ul>

    <br/><br/>


    <li><b>Common Monoid Instances</b></li>
    <br/>
    <ul>
        <li><b>Lists</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">mempty  = []
a &lt;&gt; b  = a ++ b
</code></pre>

    <br/>

    <ul>
        <li><b>Numbers</b> (via wrappers)</li>
    </ul>

<pre><code class="language-haskell line-numbers">Sum Int:
    mempty = 0
    mappend = (+)

Product Int:
    mempty = 1
    mappend = (*)
</code></pre>

    <br/>

    <ul>
        <li><b>Maybe</b> (when the underlying type is Monoid)</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance Monoid a =&gt; Monoid (Maybe a) where
    mempty = Just mempty
    Just x  &lt;&gt; Just y  = Just (x &lt;&gt; y)
    _       &lt;&gt; _       = Nothing
</code></pre>

    <br/>

    <ul>
        <li><b>Text, ByteString, IO ()</b>, and many more types also form monoids.</li>
    </ul>

    <br/><br/>


    <li><b>Monoid in action: folding</b></li>
    <br/>
    <ul>
        <li><code>mconcat</code> combines a list of monoidal values:</li>
    </ul>

<pre><code class="language-haskell line-numbers">mconcat [[1,2], [3], [4,5]]    -- [1,2,3,4,5]
mconcat [Sum 1, Sum 2, Sum 10] -- Sum 13
</code></pre>

    <br/>
    <ul>
        <li>Folds such as <code>foldMap</code> depend heavily on Monoids.</li>
    </ul>

<pre><code class="language-haskell line-numbers">foldMap Sum [1,2,3,4]   -- Sum 10
foldMap (:[]) [1,2,3]   -- [1,2,3]
</code></pre>

    <br/><br/>


    <li><b>How Functor, Applicative, and Monoid Relate</b></li>
    <br/>
    <ul>
        <li>These abstractions form a natural hierarchy:</li>
        <ul>
            <li><b>Functor</b> → mapping with <code>fmap</code></li>
            <li><b>Applicative</b> → lifting function application into a context</li>
            <li><b>Monad</b> (not covered here) → sequencing dependent computations</li>
        </ul>
        <li>Monoid is orthogonal but often used with Applicative and Monad:
            <ul>
                <li>Error accumulation</li>
                <li>Logging</li>
                <li>Building data structures</li>
                <li>Combining validation results</li>
            </ul>
        </li>
        <li>Many Applicatives use Monoids internally for combination.</li>
    </ul>

    <br/><br/>


    <li><b>Example: Validation with Applicative and Monoid Errors</b></li>
    <br/>
    <ul>
        <li>Suppose we want to validate fields and accumulate multiple error messages:</li>
    </ul>

<pre><code class="language-haskell line-numbers">import Data.Monoid (Sum(..))

validate :: Int -&gt; Either [String] Int
validate n
    | n &lt; 0     = Left ["Negative"]
    | n &gt; 100   = Left ["Too large"]
    | otherwise = Right n

combine :: Either [String] (Int, Int)
combine =
    (,) &lt;$&gt; validate 5
        &lt;*&gt; validate (-2)
</code></pre>

    <br/>
    <ul>
        <li>Applicative + Monoid gives <b>parallel validation with error accumulation</b>.</li>
    </ul>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-type-constructors">What Exactly Does <code>f a</code> Mean? Understanding Type Constructors in Haskell</h3>
<ol>
    <li>In Haskell, the notation <code>f a</code> looks like a function call, but it is <b>not</b> a value-level function.</li>
    <br/>
    <li>This syntax belongs to the <u>type level</u>, where <code>f</code> is a <b>type constructor</b> and <code>a</code> is a <b>type</b> that <code>f</code> takes as an input.</li>
    <br/>
    <li>A type constructor is like a "function on types":
        <ul>
            <li>It receives one or more types</li>
            <li>It produces a new type</li>
            <li>But it only exists at compile time</li>
        </ul>
    </li>
    <br/><br/>


    <li><b>Type-Level Application</b></li>
<pre><code class="language-haskell line-numbers">Maybe Int   -- apply the constructor Maybe to Int
[Char]      -- apply the list constructor [] to Char
IO String   -- apply IO to String
Either Int Bool -- apply Either to two types</code></pre>
    <br/>
    <ul>
        <li>These are all examples of <u>type application</u>, not value application.</li>
        <li>Even though <code>f a</code> looks like calling <code>f</code> on <code>a</code>, it's happening entirely in the type system.</li>
    </ul>
    <br/><br/>


    <li><b>Type Constructors vs Value Functions</b></li>
<pre><code class="language-haskell line-numbers">f 3     -- value-level function call
f a     -- type-level constructor application</code></pre>
    <br/>
    <ul>
        <li>The similarity is only syntactic.</li>
        <li>Type constructors:
            <ul>
                <li>Never run at runtime</li>
                <li>Cannot be evaluated</li>
                <li>Only exist to build types</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Kinds: Why <code>f</code> Must Have the Form <code>* -&gt; *</code></b></li>
<pre><code class="language-haskell line-numbers">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
    <br/>
    <ul>
        <li><code>f</code> is required to have the kind <code>* -&gt; *</code>, meaning it takes one type and returns a new type.</li>
        <li>Examples of valid <code>f</code>:
            <ul>
                <li><code>Maybe</code></li>
                <li><code>[]</code> (the list type constructor)</li>
                <li><code>IO</code></li>
                <li><code>Either e</code> (partially applied)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Concrete Examples</b></li>

    <ul>
        <li><b>Example 1: Maybe</b></li>
    </ul>
<pre><code class="language-haskell line-numbers">f = Maybe
f a = Maybe a   -- a new type</code></pre>

    <ul>
        <li><b>Example 2: Lists</b></li>
    </ul>
<pre><code class="language-haskell line-numbers">f = []
f a = [a]</code></pre>

    <ul>
        <li><b>Example 3: IO</b></li>
    </ul>
<pre><code class="language-haskell line-numbers">f = IO
f a = IO a</code></pre>

    <br/>
    <ul>
        <li>All these match the shape <code>f a</code>, meaning they construct a new type from a type.</li>
    </ul>
    <br/><br/>


    <li><b>Partial Application of Type Constructors</b></li>
<pre><code class="language-haskell line-numbers">Either String Int  -- full application
Either String      -- partial: kind becomes * -&gt; *</code></pre>
    <br/>
    <ul>
        <li>You can apply only some arguments of a multi-parameter constructor.</li>
        <li>This is needed so <code>Either e</code> can be made into a <code>Functor</code>:
<pre><code class="language-haskell line-numbers">instance Functor (Either e) where
    fmap f (Right x) = Right (f x)
    fmap _ (Left e)  = Left e</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li><b>Why <code>f a</code> is NOT a Function</b></li>
    <br/>
    <ul>
        <li><code>f a</code> cannot be evaluated.</li>
        <li>It cannot be passed to functions.</li>
        <li>It has no runtime value.</li>
        <li>It only describes <u>types</u> of values, not values themselves.</li>
    </ul>
    <br/><br/>

        <li><b>Why Functor Requires a Type Constructor (<code>* -&gt; *</code>)</b></li>
    <br/>
    <ul>
        <li>A <code>Functor</code> instance must be defined for a <u>type constructor</u> <code>f</code> whose kind is <code>* -&gt; *</code>.</li>
        <br/>
        <li>This means <code>f</code> must accept a type argument and produce a <b>new type</b>. For example:
<pre><code class="language-haskell line-numbers">Maybe Int
[Bool]
IO String
Either String Char</code></pre>
        </li>
        <br/>
        <li>Because of this requirement, Functor <u>cannot</u> be defined for simple, fully-applied types such as:
            <ul>
                <li><code>Int</code></li>
                <li><code>Bool</code></li>
                <li><code>Float</code></li>
                <li><code>Char</code></li>
            </ul>
        </li>
        <br/>
        <li>These types have kind <code>*</code> and do not take any type parameters — therefore they have no internal structure to “map over”.</li>
        <br/>
        <li>Functor works only for <u>type constructors</u> such as:
            <ul>
                <li><code>Maybe</code></li>
                <li><code>[]</code> (the list constructor)</li>
                <li><code>IO</code></li>
                <li><code>Either e</code> (partially applied)</li>
                <li><code>Tree</code></li>
                <li><code>Vector</code></li>
                <li><code>(,) a</code> (pair constructor with the first argument fixed)</li>
            </ul>
        </li>
        <br/>
        <li>These all take a type argument (<code>a</code>) and form new types (<code>f a</code>), meaning they have a “container-like” structure into which <code>fmap</code> can apply a function.</li>
    </ul>
    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <ul>
        <li><code>f</code> is a <u>type constructor</u></li>
        <li><code>a</code> is a <u>type argument</u></li>
        <li><code>f a</code> is a <u>new type built from the constructor</u></li>
        <li><code>f a</code> resembles function application but occurs only in the type system</li>
        <li>Many important abstractions (Functor, Monad, Applicative) rely on this pattern</li>
    </ul>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-monads">Monads in Haskell</h3>
<ol>

    <li><b>What Is a Monad?</b></li>
    <br/>
    <ul>
        <li>A <b>Monad</b> is a design pattern that allows you to:
            <ul>
                <li>sequence computations,</li>
                <li>chain operations that depend on previous results,</li>
                <li>model effects (state, IO, exceptions, nondeterminism) in a pure functional way.</li>
            </ul>
        </li>
        <br/>
        <li>Monads are not about &quot;side effects&quot; — they are about <u>describing computations</u> in steps.</li>
        <br/>
        <li>Definition (simplified):</li>

<pre><code class="language-haskell line-numbers">class Applicative m =&gt; Monad m where
    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b
    return :: a -&gt; m a
</code></pre>
        <ul>
            <li><code>return</code>: wrap a pure value into the monadic context.</li>
            <li><b>(&gt;&gt;=)</b> (bind): chain computations where output of one step feeds the next.</li>
            <li>Every Monad is automatically a <code>Functor</code> and <code>Applicative</code>.</li>
        </ul>
    </ul>

    <br/><br/>


    <li><b>The Bind Operator</b> <code>(&gt;&gt;=)</code></li>
    <br/>
    <ul>
        <li>The heart of a Monad is <code>(&gt;&gt;=)</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>

    <br/>
    <ul>
        <li>Interpretation:
            <ul>
                <li>Take a computation of type <code>m a</code>,</li>
                <li>extract its original value <code>a</code>,</li>
                <li>pass it to a function that returns the next computation <code>m b</code>.</li>
            </ul>
        </li>
        <li><code>(&gt;&gt;=)</code> sequences operations where the next step <b>depends on the result</b> of the previous one.</li>
        <li>This is the key difference between <b>Monad</b> and <b>Applicative</b>.</li>
    </ul>
    <br/><br/>


    <li><b>The</b> <code>(&gt;&gt;)</code> <b>Operator</b></li>
    <br/>
    <ul>
        <li>A simplified sequencing operator:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(>>) :: m a -&gt; m b -&gt; m b
</code></pre>

    <br/>
    <ul>
        <li>It ignores the result of the first action, keeping only the second.</li>
        <li>Useful when sequencing but not depending on earlier values:</li>
    </ul>

<pre><code class="language-haskell line-numbers">putStrLn "A" >> putStrLn "B"
</code></pre>

    <br/><br/>


    <li><code>do</code><b>-notation: Syntactic Sugar for Monads</b></li>
    <br/>
    <ul>
        <li>Haskell provides <code>do</code>-notation to write monadic code more naturally:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    putStrLn "Enter a number:"
    s  &lt;- getLine
    let n = read s :: Int
    print (n * 2)
</code></pre>

    <br/>
    <ul>
        <li>This is just syntactic sugar for:</li>
    </ul>

<pre><code class="language-haskell line-numbers">main =
    putStrLn "Enter a number:" &gt;&gt;=
    \_ -&gt; getLine &gt;&gt;=
    \s -&gt; let n = read s in
          print (n * 2)
</code></pre>

    <br/>
    <ul>
        <li>Important:
            <ul>
                <li><code>x &lt;- m</code> extracts the pure value inside the monad.</li>
                <li>Last line in a <code>do</code>-block must be monadic.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Monad Laws</b> (A lawful monad must satisfy)</li>
    <br/>
    <ul>
        <li><b>Left identity</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">return a >>= f  ≡  f a
</code></pre>

    <ul>
        <li><b>Right identity</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">m >>= return  ≡  m
</code></pre>

    <ul>
        <li><b>Associativity</b></li>
    </ul>

<pre><code class="language-haskell line-numbers">(m >>= f) >>= g  ≡  m >>= (\x -&gt; f x >>= g)
</code></pre>

    <br/>
    <ul>
        <li>These guarantee predictable sequencing.</li>
    </ul>
    <br/><br/>


    <li><b>Common Monad Instances</b></li>
    <br/>
    <ul>
        <li><b>Maybe</b>: computations that may fail.</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance Monad Maybe where
    Nothing  >>= _ = Nothing
    Just x   >>= f = f x
</code></pre>

    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">safeDiv a b =
    if b == 0 then Nothing else Just (a `div` b)

calc = Just 10 >>= \x -&gt;
       Just 2  >>= \y -&gt;
       safeDiv x y
</code></pre>

    <br/>

    <ul>
        <li><b>Either e</b>: computations that can fail with an error.</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance Monad (Either e) where
    Left e  >>= _ = Left e
    Right x >>= f = f x
</code></pre>

    <br/>

    <ul>
        <li><b>List</b>: nondeterministic computations.</li>
    </ul>

<pre><code class="language-haskell line-numbers">instance Monad [] where
    xs >>= f = concat (map f xs)
</code></pre>

    <br/>

    <ul>
        <li><b>IO</b>: sequencing interaction with the real world.</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    name &lt;- getLine
    putStrLn ("Hello " ++ name)
</code></pre>

    <br/><br/>


    <li><b>Monads vs Applicatives vs Functors</b></li>
    <br/>
    <table>
        <tr>
            <th>Concept</th>
            <th>Capabilities</th>
            <th>Signature</th>
        </tr>
        <tr>
            <td><b>Functor</b></td>
            <td>map a pure function over a structure</td>
            <td><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></td>
        </tr>
        <tr>
            <td><b>Applicative</b></td>
            <td>apply wrapped functions to wrapped values</td>
            <td><code>(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code></td>
        </tr>
        <tr>
            <td><b>Monad</b></td>
            <td>perform computations where next step depends on previous results</td>
            <td><code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code></td>
        </tr>
    </table>

    <br/>
    <ul>
        <li>Hierarchy: <code>Functor &lt; Applicative &lt; Monad</code></li>
        <li>Every Monad is automatically an Applicative and a Functor.</li>
    </ul>
    <br/><br/>


    <li><b>Examples of Monad Use Cases</b></li>
    <br/>

    <ul>
        <li><b>Maybe Monad</b>: chaining computations that may fail.</li>
    </ul>

<pre><code class="language-haskell line-numbers">lookupUser id = ...
lookupAddress user = ...
lookupZip address = ...

getZip id =
    lookupUser id >>= lookupAddress >>= lookupZip
</code></pre>

    <br/>

    <ul>
        <li><b>List Monad</b>: generate combinations.</li>
    </ul>

<pre><code class="language-haskell line-numbers">pairs = do
    x &lt;- [1,2]
    y &lt;- ['a','b']
    return (x, y)
-- [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
</code></pre>

    <br/>

    <ul>
        <li><b>Either Monad</b>: chain computations that produce errors.</li>
    </ul>

<pre><code class="language-haskell line-numbers">parseInt s =
    if all isDigit s then Right (read s)
    else Left "not a number"

sumInts a b = do
    x &lt;- parseInt a
    y &lt;- parseInt b
    return (x + y)
</code></pre>

    <br/>

    <ul>
        <li><b>IO Monad</b>: real-world programs.</li>
    </ul>

<pre><code class="language-haskell line-numbers">main = do
    putStrLn "Enter a number:"
    s &lt;- getLine
    print (read s + 1)
</code></pre>

    <br/><br/>


    <li><b>Kleisli Composition</b></li>
    <br/>
    <ul>
        <li>The operator <code>(&gt;=&gt;)</code> composes monadic functions:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(>=>) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-haskell line-numbers">f >=> g >=> h
</code></pre>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-zippers">Zippers in Haskell</h3>
<ol>

    <li><b>What Is a Zipper?</b></li>
    <br/>
    <ul>
        <li>A <b>zipper</b> is a functional data structure that allows:
            <ul>
                <li><b>efficient navigation</b> through a data structure,</li>
                <li><b>local editing</b> of a focus element,</li>
                <li>while preserving the immutability of the original structure.</li>
            </ul>
        </li>
        <br/>
        <li>Originally introduced by Gérard Huet in 1997, zippers are widely used for:
            <ul>
                <li>navigating trees,</li>
                <li>writing editors or cursors,</li>
                <li>interpreters or evaluation machines,</li>
                <li>Undo/redo structures,</li>
                <li>data manipulation with context preservation.</li>
            </ul>
        </li>
        <br/>
        <li>A zipper stores the <u>current focus</u>, and the <u>context</u> needed to rebuild the entire structure.</li>
    </ul>
    <br/><br/>


    <li><b>An Intuitive Example: List Zipper</b></li>
    <br/>
    <ul>
        <li>We introduce zippers using lists:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data ListZipper a = ListZipper [a] a [a]
</code></pre>

    <ul>
        <li>This represents:</li>
        <ul>
            <li>the list of elements <u>to the left</u> of the focus, in reverse order,</li>
            <li>the <u>current element</u> in focus,</li>
            <li>the list of elements <u>to the right</u> of the focus.</li>
        </ul>
        <br/>
        <li>Example for the list <code>[1,2,3,4,5]</code> with focus on <code>3</code>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">ListZipper [2,1] 3 [4,5]
</code></pre>

    <br/>
    <ul>
        <li><b>Moving left and right</b> becomes efficient:</li>
    </ul>

<pre><code class="language-haskell line-numbers">goLeft (ListZipper (l:ls) x rs) = ListZipper ls l (x:rs)
goRight (ListZipper ls x (r:rs)) = ListZipper (x:ls) r rs
</code></pre>

    <br/>
    <ul>
        <li>We never reconstruct the entire list; we just update small pieces.</li>
    </ul>
    <br/><br/>


    <li><b>Zippers for Trees</b> (The classical application)</li>
    <br/>
    <ul>
        <li>Consider a binary tree:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Tree a
    = Empty
    | Node a (Tree a) (Tree a)
</code></pre>

    <br/>
    <ul>
        <li>A zipper for trees allows navigation like:</li>
        <ul>
            <li>go to left child</li>
            <li>go to right child</li>
            <li>go back to parent</li>
            <li>edit or replace any node</li>
        </ul>
    </ul>

    <br/>
    <ul>
        <li><b>Idea:</b> store the current subtree and the path (context) back to the root.</li>
    </ul>
    <br/><br/>


    <li><b>The Tree Zipper Context</b></li>
    <br/>
    <ul>
        <li>To move down a tree, you must remember:</li>
        <ul>
            <li>which child you came from,</li>
            <li>the value at the parent,</li>
            <li>the sibling subtree.</li>
        </ul>
        <li>Define a &quot;breadcrumb&quot; that stores this context:</li>
    </ul>

<pre><code class="language-haskell line-numbers">data Crumb a
    = LeftCrumb  a (Tree a)     -- went left, store value &amp; right subtree
    | RightCrumb a (Tree a)     -- went right, store value &amp; left subtree
</code></pre>

    <br/>
    <ul>
        <li>Zipper is then:</li>
    </ul>

<pre><code class="language-haskell line-numbers">type Breadcrumbs a = [Crumb a]
type Zipper a       = (Tree a, Breadcrumbs a)
</code></pre>

    <br/>
    <ul>
        <li>Now the zipper holds:
            <ul>
                <li><b>focused subtree</b></li>
                <li><b>breadcrumbs</b> describing the path back up</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Navigating the Tree</b></li>
    <br/>
    <ul>
        <li><b>Go left</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">goLeft :: Zipper a -&gt; Zipper a
goLeft (Node x l r, bs) = (l, LeftCrumb x r : bs)
</code></pre>

    <br/>
    <ul>
        <li><b>Go right</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">goRight :: Zipper a -&gt; Zipper a
goRight (Node x l r, bs) = (r, RightCrumb x l : bs)
</code></pre>

    <br/>
    <ul>
        <li><b>Go up</b> (using stored information):</li>
    </ul>

<pre><code class="language-haskell line-numbers">goUp :: Zipper a -&gt; Zipper a
goUp (t, LeftCrumb x r : bs)  = (Node x t r, bs)
goUp (t, RightCrumb x l : bs) = (Node x l t, bs)
</code></pre>

    <br/>
    <ul>
        <li>Each move requires <b>O(1)</b> time.</li>
    </ul>
    <br/><br/>


    <li><b>Editing with a Zipper</b></li>
    <br/>
    <ul>
        <li>Zippers make edits simple because you operate only on the focused node.</li>
        <li><b>Replace the focused value</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">modify :: (a -&gt; a) -&gt; Zipper a -&gt; Zipper a
modify f (Node x l r, bs) = (Node (f x) l r, bs)
</code></pre>

    <br/>
    <ul>
        <li><b>Replace the focused subtree entirely</b>:</li>
    </ul>

<pre><code class="language-haskell line-numbers">attach :: Tree a -&gt; Zipper a -&gt; Zipper a
attach t (_, bs) = (t, bs)
</code></pre>

    <br/>
    <ul>
        <li>You can modify deeply nested values without reconstructing the whole tree.</li>
    </ul>
    <br/><br/>


    <li><b>Building and Rebuilding the Entire Structure</b></li>
    <br/>
    <ul>
        <li>Once edits are done, return to the root:</li>
    </ul>

<pre><code class="language-haskell line-numbers">top :: Zipper a -&gt; Zipper a
top z@(_, []) = z
top z         = top (goUp z)
</code></pre>

    <br/>
    <ul>
        <li>Then extract the full updated tree:</li>
    </ul>

<pre><code class="language-haskell line-numbers">getTree :: Zipper a -&gt; Tree a
getTree = fst . top
</code></pre>

    <br/><br/>


    <li><b>Example: Walking and Editing</b></li>
    <br/>
    <ul>
        <li>Given the tree:</li>
    </ul>

<pre><code class="language-haskell line-numbers">myTree =
    Node 1
        (Node 2 Empty Empty)
        (Node 3 Empty Empty)
</code></pre>

    <br/>
    <ul>
        <li>Walk to node <code>2</code> and increment it:</li>
    </ul>

<pre><code class="language-haskell line-numbers">(tree1, ctx1) = goLeft (myTree, [])
(tree2, ctx2) = modify (+1) (tree1, ctx1)
resultTree    = getTree (tree2, ctx2)
</code></pre>

    <br/>
    <ul>
        <li>Resulting tree:</li>
    </ul>

<pre><code class="language-haskell line-numbers">Node 1 (Node 3 Empty Empty) (Node 3 Empty Empty)
</code></pre>

    <br/><br/>


    <li><b>Zippers Are Not Just for Trees</b></li>
    <br/>
    <ul>
        <li>Zippers can be built for any data structure that is:
            <ul>
                <li>recursive,</li>
                <li>traversable,</li>
                <li>built from sum + product type constructors.</li>
            </ul>
        </li>
        <li>They can represent:
            <ul>
                <li>file system directories,</li>
                <li>syntax trees,</li>
                <li>JSON objects,</li>
                <li>n-dimensional grids,</li>
                <li>buffers with cursors.</li>
            </ul>
        </li>
        <li>The general zipper machinery (with generics) appears in <code>Control.Lens</code> as <code>zipper</code> and <code>Top</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Zipper Intuition Explained</b></li>
    <br/>
    <ul>
        <li>Imagine navigating a tree like navigating folders on a computer:</li>
        <ul>
            <li><b>goLeft / goRight</b> = <i>enter subfolder</i></li>
            <li><b>goUp</b> = <i>go to parent directory</i></li>
            <li><b>breadcrumbs</b> = <i>list of what you visited and what remains</i></li>
        </ul>
        <li>This way, you never lose information about where you came from.</li>
    </ul>
    <br/><br/>


    <li><b>Performance</b></li>
    <br/>
    <ul>
        <li>All operations (navigate left/right/up, modify, attach) are <b>O(1)</b>.</li>
        <li>Reassembling the entire structure takes <b>O(depth)</b> where depth is usually small.</li>
        <li>Zippers preserve immutability, making them ideal for functional editors and interpreters.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-let-in">Haskell <code>let ... in</code> Expressions</h3>
<ol>
    <li><b>Intuition: What is <code>let ... in</code>?</b>
        <br/>
        <ul>
            <li><code>let ... in ...</code> is a way to introduce <b>local names</b> inside an expression.</li>
            <li>You can think of it as: “Give names to these sub-expressions, then use them in the body.”</li>
            <li>It is an <b>expression</b> (not a statement) and always has a value.</li>
        </ul>
        <br/>
<pre><code class="language-haskell line-numbers">answer :: Int
answer =
    let x = 20
        y = 22
    in x + y        -- answer == 42
</code></pre>
        <ul>
            <li><code>let x = 20; y = 22</code> introduces local bindings.</li>
            <li><code>in x + y</code> is the body that uses those names.</li>
            <li>The whole <code>let ... in ...</code> is just another expression that evaluates to an <code>Int</code>.</li>
        </ul>
    </li>

    <br/>

    <li><b>General Form and Scope</b>
        <br/>
        <ul>
            <li>General syntax (with layout/indentation):</li>
        </ul>
<pre><code class="language-haskell line-numbers">let
    name1 = expr1
    name2 = expr2
    ...
in bodyExpr
</code></pre>
        <ul>
            <li>All bindings after <code>let</code> are visible only in the <code>in bodyExpr</code> part.</li>
            <li>They are <b>not</b> visible before the <code>let</code> or outside of the expression.</li>
        </ul>
        <br/>
<pre><code class="language-haskell line-numbers">outside :: Int
outside =
    let a = 5
        b = 7
    in a * b

-- Here, a and b are NOT visible anymore.
-- outside == 35
</code></pre>
    </li>

    <br/>

    <li><b>Multiple Bindings and Layout (Indentation)</b>
        <br/>
        <ul>
            <li>You can define multiple names after one <code>let</code>.</li>
            <li>They must be aligned (same indentation) according to Haskell&rsquo;s Layout Rule.</li>
        </ul>
<pre><code class="language-haskell line-numbers">area :: Double
area =
    let radius   = 10
        piApprox = 3.14159
    in piApprox * radius * radius
</code></pre>
        <ul>
            <li><code>radius</code> and <code>piApprox</code> start in the same column → they belong to the same <code>let</code> block.</li>
            <li>The <code>in</code> is aligned with <code>let</code> (typical style, but not strictly required as long as layout is consistent).</li>
        </ul>
    </li>

    <br/>

    <li><b>Order of Bindings and Laziness</b>
        <br/>
        <ul>
            <li>Bindings inside <code>let</code> are essentially like simultaneous equations; order does not matter conceptually.</li>
            <li>Because of Haskell&rsquo;s laziness, you can refer to names defined <b>later</b>.</li>
        </ul>
<pre><code class="language-haskell line-numbers">weird :: (Int, Int)
weird =
    let x = y + 1    -- &quot;forward&quot; reference
        y = 10
    in (x, y)
-- weird == (11, 10)
</code></pre>
        <ul>
            <li>This works because values are not evaluated until needed.</li>
            <li>This also enables <b>recursive</b> definitions (a name referring to itself).</li>
        </ul>
        <br/>
<pre><code class="language-haskell line-numbers">ones :: [Int]
ones =
    let xs = 1 : xs   -- infinite list of 1s
    in xs
</code></pre>
    </li>

    <br/>

    <li><b><code>let ... in</code> vs. <code>where</code></b>
        <br/>
        <ul>
            <li>Both <code>let</code> and <code>where</code> introduce local bindings, but they differ in:
                <ul>
                    <li><b>position</b> (expression vs. declaration)</li>
                    <li><b>scope direction</b></li>
                </ul>
            </li>
        </ul>
        <br/>
        <ul>
            <li><b><code>let ... in</code></b>:
                <ul>
                    <li>Used <b>inside expressions</b>.</li>
                    <li>Bindings come <b>before</b> the expression that uses them.</li>
                </ul>
            </li>
        </ul>
<pre><code class="language-haskell line-numbers">hypotenuse :: Double -&gt; Double -&gt; Double
hypotenuse a b =
    let a2 = a * a
        b2 = b * b
    in sqrt (a2 + b2)
</code></pre>
        <br/>
        <ul>
            <li><b><code>where</code></b>:
                <ul>
                    <li>Attached to a definition (usually at top-level or in guards).</li>
                    <li>Bindings come <b>after</b> the main equation.</li>
                </ul>
            </li>
        </ul>
<pre><code class="language-haskell line-numbers">hypotenuse' :: Double -&gt; Double -&gt; Double
hypotenuse' a b = sqrt (a2 + b2)
  where
    a2 = a * a
    b2 = b * b
</code></pre>
        <ul>
            <li>Semantically similar, but:
                <ul>
                    <li>Use <code>let ... in</code> when you need a local block <b>inside an expression</b>.</li>
                    <li>Use <code>where</code> when defining helpers &ldquo;under&rdquo; a function clause.</li>
                </ul>
            </li>
        </ul>
    </li>

    <br/>

    <li><b><code>let</code> Inside <code>do</code>-notation (No <code>in</code>)</b>
        <br/>
        <ul>
            <li>Inside a <code>do</code>-block, <code>let</code> is slightly different:
                <ul>
                    <li>It still introduces local names.</li>
                    <li>But you <b>do not</b> write <code>in</code>.</li>
                    <li>The scope is the rest of the <code>do</code>-block below that <code>let</code>.</li>
                </ul>
            </li>
        </ul>
<pre><code class="language-haskell line-numbers">greet :: IO ()
greet = do
    let name = "Haskell"
        msg  = "Hello, " ++ name
    putStrLn msg
</code></pre>
        <ul>
            <li><code>let</code> here has type <b>pure bindings</b>, no effect by itself.</li>
            <li>It only introduces names for later lines in the <code>do</code>-block.</li>
        </ul>
        <br/>
<pre><code class="language-haskell line-numbers">example :: IO ()
example = do
    line &lt;- getLine
    let trimmed = reverse (dropWhile (== ' ') (reverse line))
    putStrLn trimmed
</code></pre>
        <ul>
            <li><code>line &lt;- getLine</code> is a monadic binding (runs an <code>IO</code> action).</li>
            <li><code>let trimmed = ...</code> is a pure local definition using <code>line</code>.</li>
        </ul>
    </li>

    <br/>

    <li><b>Pattern Bindings in <code>let</code></b>
        <br/>
        <ul>
            <li>You can use patterns on the left side of <code>=</code> in a <code>let</code>.</li>
        </ul>
<pre><code class="language-haskell line-numbers">norm2 :: (Double, Double) -&gt; Double
norm2 v =
    let (x, y) = v
    in sqrt (x * x + y * y)
</code></pre>
        <ul>
            <li><code>(x, y)</code> is a pattern that matches the input tuple.</li>
            <li>This saves you from writing something like <code>fst v</code> and <code>snd v</code>.</li>
        </ul>
        <br/>
        <ul>
            <li>Inside <code>do</code>, pattern-bindings work too:</li>
        </ul>
<pre><code class="language-haskell line-numbers">printPair :: IO ()
printPair = do
    let pair = (1, "one")
        (n, s) = pair
    putStrLn (show n ++ " - " ++ s)
</code></pre>
    </li>

    <br/>

    <li><b>Using <code>let</code> in List Comprehensions and Guards</b>
        <br/>
        <ul>
            <li><code>let</code> can appear inside list comprehensions to define helper names.</li>
        </ul>
<pre><code class="language-haskell line-numbers">pairs :: [(Int, Int)]
pairs =
    [ (x, y)
    | x &lt;- [1..5]
    , let y = x * x
    ]
-- pairs == [(1,1),(2,4),(3,9),(4,16),(5,25)]
</code></pre>
        <ul>
            <li><code>let y = x * x</code> defines <code>y</code> for each <code>x</code>, without filtering anything.</li>
        </ul>
        <br/>
        <ul>
            <li><code>let</code> can also be used in guards (with <code>MultiWayIf</code> or pattern guards), but that is more advanced.</li>
        </ul>
    </li>

    <br/>

    <li><b>Shadowing and Common Pitfalls</b>
        <br/>
        <ul>
            <li><b>Shadowing</b>: a <code>let</code>-binding can reuse an existing name and hide the outer one.</li>
        </ul>
<pre><code class="language-haskell line-numbers">shadow :: Int -&gt; Int
shadow x =
    let x = x + 1
    in x
</code></pre>
        <ul>
            <li>This can be confusing: the right-hand-side <code>x</code> refers to the <b>outer</b> function argument, the <code>x</code> on the left introduces a new inner binding.</li>
            <li>Many style guides recommend <b>avoiding</b> this kind of shadowing for clarity.</li>
        </ul>
        <br/>
        <ul>
            <li><b>Do not confuse</b>:
                <ul>
                    <li><code>let</code> vs. monadic <code>&lt;-</code></li>
                    <li><code>let</code> introduces pure bindings; <code>&lt;-</code> runs an action in a monad (like <code>IO</code>).</li>
                </ul>
            </li>
        </ul>
    </li>

    <br/>

    <li><b>Summary</b>
        <br/>
        <ul>
            <li><code>let ... in ...</code>:
                <ul>
                    <li>is an <b>expression</b> that introduces local names.</li>
                    <li>is useful to break down complex expressions into readable parts.</li>
                    <li>works nicely with Haskell&rsquo;s laziness (order of bindings is flexible, recursion is possible).</li>
                </ul>
            </li>
            <li>Inside <code>do</code>-notation:
                <ul>
                    <li>you write just <code>let</code> (no <code>in</code>),</li>
                    <li>and it introduces pure names for the rest of the block.</li>
                </ul>
            </li>
            <li>Compared to <code>where</code>:
                <ul>
                    <li>Use <code>let ... in</code> when you need a local expression-level block.</li>
                    <li>Use <code>where</code> when attaching helpers to a function equation.</li>
                </ul>
            </li>
        </ul>
        <br/>
        <ul>
            <li>If you keep in mind &ldquo;<b>give names to intermediate results inside an expression</b>&rdquo;, you’ll almost always use <code>let ... in</code> correctly.</li>
        </ul>
    </li>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="haskell-do-notation">Haskell <code>do</code>-Notation</h3>
<ol>
    <li><b>Intuition: What is <code>do</code>-notation?</b>
        <br/>
        <ul>
            <li><code>do</code>-notation is Haskell&rsquo;s readable syntax for sequencing <b>monadic actions</b>.</li>
            <li>It does <b>not</b> introduce new semantics; it is only syntactic sugar.</li>
            <li>Every <code>do</code>-block desugars into combinations of:
                <ul>
                    <li><code>&gt;&gt;=</code> (bind)</li>
                    <li><code>&gt;&gt;</code>  (then)</li>
                    <li><code>return</code> (pure)</li>
                </ul>
            </li>
            <li>This makes monadic code look imperative while still being purely functional.</li>
        </ul>
        <br/>
<pre><code class="language-haskell line-numbers">main :: IO ()
main = do
    line &lt;- getLine
    putStrLn ("You entered: " ++ line)
</code></pre>
        <ul>
            <li><code>line &lt;- getLine</code> runs the effect <code>getLine :: IO String</code> and extracts its result.</li>
            <li><code>putStrLn ...</code> runs after that.</li>
        </ul>
    </li>

    <br/>

    <li><b>What is a Monadic Bind (<code>&gt;&gt;=</code>)?</b>
        <br/>
        <ul>
            <li>The operator <code>&gt;&gt;=</code> means:
                <ul>
                    <li>&ldquo;Run the effect on the left, then pass its result to the function on the right.&rdquo;</li>
                </ul>
            </li>
        </ul>
<pre><code class="language-haskell line-numbers">(m &gt;&gt;= \x -&gt; f x)
</code></pre>
        <ul>
            <li>In a <code>do</code> block, this is exactly what happens when you write <code>x &lt;- m</code>.</li>
        </ul>
    </li>

    <br/>

    <li><b>Desugaring: How <code>do</code>-notation Expands</b>
        <br/>
        <ul>
            <li>Every <code>do</code>-block can be translated into pure monadic operations.</li>
        </ul>
        <br/>
        <ul>
            <li><b>Example 1:</b></li>
        </ul>
<pre><code class="language-haskell line-numbers">foo :: Maybe Int
foo = do
    x &lt;- Just 3
    y &lt;- Just 4
    return (x + y)
</code></pre>

        <ul>
            <li>Desugared version:</li>
        </ul>
<pre><code class="language-haskell line-numbers">foo :: Maybe Int
foo =
    Just 3 &gt;&gt;= \x -&gt;
    Just 4 &gt;&gt;= \y -&gt;
    return (x + y)
</code></pre>

        <ul>
            <li><b>Example 2: No binding</b></li>
        </ul>
<pre><code class="language-haskell line-numbers">main = do
    putStrLn "Hello"
    putStrLn "World"
</code></pre>

<pre><code class="language-haskell line-numbers">main =
    putStrLn "Hello" &gt;&gt;
    putStrLn "World"
</code></pre>
    </li>

    <br/>

    <li><b><code>&lt;-</code> Inside <code>do</code>-notation</b>
        <br/>
        <ul>
            <li>A line with <code>&lt;-</code> has the structure:</li>
        </ul>
<pre><code class="language-haskell line-numbers">name &lt;- action
</code></pre>
        <ul>
            <li>Meaning:
                <ul>
                    <li><code>action :: m a</code> is a monadic computation.</li>
                    <li>It runs, and its result is bound to <code>name</code>.</li>
                </ul>
            </li>
            <li>It corresponds directly to:
                <ul>
                    <li><code>action &gt;&gt;= \name -&gt; ...</code></li>
                </ul>
            </li>
        </ul>
        <br/>
        <ul>
            <li><b>Important rule:</b> the right-hand side of <code>&lt;-</code> must be a monadic value (e.g. <code>IO a</code>, <code>Maybe a</code>, etc.), not a pure expression.</li>
        </ul>
<pre><code class="language-haskell line-numbers">x &lt;- 3       -- ❌ wrong: 3 is not a monadic action
</code></pre>
    </li>

    <br/>

    <li><b>Pure Bindings in <code>do</code>: <code>let</code></b>
        <br/>
        <ul>
            <li>Pure local definitions are introduced with <code>let</code> (without <code>in</code>!).</li>
            <li>These are not monadic; they are just pure values.</li>
        </ul>

<pre><code class="language-haskell line-numbers">main = do
    let x = 10
        y = 20
    print (x + y)
</code></pre>

        <ul>
            <li>You use <code>let</code> when you want to define pure helpers inside a <code>do</code>-block.</li>
            <li>You cannot use <code>&lt;-</code> for pure bindings.</li>
        </ul>
    </li>

    <br/>

    <li><b>Pattern Matching Inside <code>do</code></b>
        <br/>
        <ul>
            <li>You can pattern-match on monadic results:</li>
        </ul>
<pre><code class="language-haskell line-numbers">printPair :: IO ()
printPair = do
    (x, y) &lt;- return (1, "one")
    putStrLn (show x ++ ": " ++ y)
</code></pre>

        <ul>
            <li>If the pattern fails, it triggers the monad&rsquo;s fail behavior.</li>
        </ul>
    </li>

    <br/>

    <li><b>Using <code>do</code>-notation with Other Monads (Not Just IO)</b>
        <br/>
        <ul>
            <li><code>do</code>-notation works for <b>any monad</b>, not only <code>IO</code>.</li>
            <li>Example: <code>Maybe</code> monad for computations that can fail.</li>
        </ul>
<pre><code class="language-haskell line-numbers">half :: Int -&gt; Maybe Int
half x =
    if even x then Just (x `div` 2) else Nothing

example :: Maybe Int
example = do
    a &lt;- half 20
    b &lt;- half a
    return b
-- example == Just 5
</code></pre>
        <ul>
            <li>If any <code>half</code> call returns <code>Nothing</code>, the whole block is <code>Nothing</code>.</li>
        </ul>
        <br/>
        <ul>
            <li>Works similarly for:
                <ul>
                    <li><code>Either e</code></li>
                    <li><code>[]</code> (list monad)</li>
                    <li>custom monads</li>
                    <li>transformer stacks like <code>ReaderT</code>, <code>StateT</code>, etc.</li>
                </ul>
            </li>
        </ul>
    </li>

    <br/>

    <li><b>Empty <code>do</code> Blocks and <code>return</code></b>
        <br/>
        <ul>
            <li>Every <code>do</code>-block must evaluate to a monadic value.</li>
            <li><code>return</code> injects a pure value into the monad.</li>
        </ul>

<pre><code class="language-haskell line-numbers">example = do
    return 42    -- :: Maybe Int, IO Int, etc.
</code></pre>

        <ul>
            <li><code>return</code> does <b>not</b> end the block (unlike other languages).</li>
            <li>It simply wraps a pure value inside the monad.</li>
        </ul>
    </li>

    <br/>

    <li><b>Sequencing Without Bind: <code>action1 &gt;&gt; action2</code></b>
        <br/>
        <ul>
            <li>If you don&rsquo;t care about the result of an action, you drop the <code>&lt;-</code>:</li>
        </ul>

<pre><code class="language-haskell line-numbers">main = do
    putStrLn "Hello"
    putStrLn "World"
</code></pre>

        <ul>
            <li>Desugars to:</li>
        </ul>
<pre><code class="language-haskell line-numbers">main =
    putStrLn "Hello" &gt;&gt;
    putStrLn "World"
</code></pre>
    </li>

    <br/>

    <li><b>Common Pitfalls</b>
        <br/>
        <ul>
            <li><b>1. Forgetting that <code>let</code> does not use <code>in</code> inside <code>do</code> blocks.</b></li>
        </ul>
<pre><code class="language-haskell line-numbers">let x = 10 in print x    -- ❌ not allowed inside do
</code></pre>

        <ul>
            <li><b>2. Using <code>&lt;-</code> on pure values.</b></li>
        </ul>
<pre><code class="language-haskell line-numbers">x &lt;- 5    -- ❌ Wrong: 5 is not monadic
let x = 5 -- ✔ Correct
</code></pre>

        <ul>
            <li><b>3. Mixing up <code>do</code> with imperative semantics.</b></li>
            <li>Under the hood, <code>do</code> is still purely functional.</li>
        </ul>
    </li>

    <br/>

    <li><b>Summary</b>
        <br/>
        <ul>
            <li><code>do</code>-notation is syntactic sugar for monadic operations.</li>
            <li><code>x &lt;- m</code> extracts the result of a monadic computation.</li>
            <li><code>let</code> defines pure local variables inside a <code>do</code>-block (no <code>in</code>).</li>
            <li><code>do</code> works with <b>all monads</b>, not just <code>IO</code>.</li>
            <li>Every <code>do</code>-block becomes a chain of <code>&gt;&gt;</code> and <code>&gt;&gt;=</code>.</li>
        </ul>
        <br/>
        <ul>
            <li>If you remember: <b>&ldquo;<code>do</code> = nicer syntax for monadic chains&rdquo;</b>, you understand exactly what it is.</li>
        </ul>
    </li>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
