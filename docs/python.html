<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>PY</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/python.png" alt="PY Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#python-args-kwargs">Python <code>*args</code> and <code>**kwargs</code></a></li>
        <li><a href="#python-match">The <code>match</code> Statement</a></li>
        <li><a href="#python-numbers">Numbers</a></li>
        <li><a href="#python-text">Text (Strings)</a></li>
        <li><a href="#python-lists">Lists</a></li>
        <li><a href="#python-type-annotations">Type Annotations</a></li>
        <li><a href="#python-protocol"><code>Protocol</code></a></li>
        <li><a href="#python-typeddict"><code>TypedDict</code></a></li>
        <li><a href="#python-type-checkers">Type Checkers: mypy, pyright, and ruff</a></li>
        <li><a href="#python-special-function-parameters">Special Parameters</a></li>
        <li><a href="#python-range"><code>range</code></a></li>
        <li><a href="#python-lambda">Lambda Expressions</a></li>
        <li><a href="#python-docstrings">Documentation Strings</a></li>
        <li><a href="#python-function-annotations">Function Annotations</a></li>
        <li><a href="#python-tuples-sequences">Tuples and Sequences</a></li>
        <li><a href="#python-del-statement">The <code>del</code> Statement</a></li>
        <li><a href="#python-sets">Sets</a></li>
        <li><a href="#python-dictionaries">Dictionaries</a></li>
        <li><a href="#python-modules-intro">Modules Introduction</a></li>
        <li><a href="#python-vs-python3">Python vs Python3</a></li>
        <li><a href="#python-pip">pip / pip3 - Python Package Manager</a></li>
        <li><a href="#python-packages">Packages</a></li>
        <li><a href="#python-virtual-environments">Python Virtual Environment</a></li>
        <li><a href="#python-conda-vs-anaconda">Conda vs Anaconda</a></li>
        <li><a href="#python-input">Input</a></li>
        <li><a href="#python-output">Output</a></li>
        <li><a href="#python-rw-files">R/W Files</a></li>
        <li><a href="#python-errors-exceptions">Errors and Exceptions</a></li>
        <li><a href="#python-custom-exceptions">Custom Exceptions</a></li>
        <li><a href="#python-classes">Classes</a></li>
        <li><a href="#python-dataclasses">Dataclasses</a></li>
        <li><a href="#python-class-inheritance">Class Inheritance</a></li>
        <li><a href="#python-private-variables">Private Variables</a></li>
        <li><a href="#python-iterators">Iterators</a></li>
        <li><a href="#python-generators">Generators</a></li>
        <li><a href="#python-brief-std-lib-tour">Brief Tour of the Python Standard Library</a></li>
        <li><a href="#python-wrappers">Wrappers</a></li>
        <li><a href="#python-decorators">Decorators</a></li>
        <li><a href="#python-async-intro">Introduction to Python Async Programming</a></li>
        <li><a href="#python-asyncio-run-vs-await">Understanding the Difference Between <code>asyncio.run()</code> and <code>await</code></a></li>
        <li><a href="#python-c-api-intro">Introduction to C API</a></li>
    </ul>
</nav>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-args-kwargs">Python <code>*args</code> and <code>**kwargs</code></h3>
<ol>
    <li>In Python, functions can accept a variable number of arguments using two special syntax forms:</li>
    <ul>
        <li><code>*args</code>: captures <u>positional</u> arguments</li>
        <li><code>**kwargs</code>: captures <u>keyword</u> arguments</li>
    </ul>
    <br/><br/>


    <li><b>Positional Variable Arguments: <code>*args</code></b></li>
    <br/>
    <ul>
        <li><code>*args</code> collects extra positional arguments into a tuple.</li>
    </ul>

<pre><code class="language-python line-numbers">def greet(*args):
    print(args)

greet("Hello", "World", 42)
</code></pre>

<pre><code class="language-text">('Hello', 'World', 42)
</code></pre>

    <br/>
    <ul>
        <li>You can loop through <code>args</code> easily:</li>
    </ul>

<pre><code class="language-python line-numbers">def add_all(*args):
    return sum(args)

print(add_all(1, 2, 3, 4))
</code></pre>
    <ul>
        <li>Use <code>*args</code> when you don‚Äôt know how many positional arguments you will receive.</li>
    </ul>
    <br/><br/>


    <li><b>Keyword Variable Arguments: <code>**kwargs</code></b></li>
    <br/>
    <ul>
        <li><code>**kwargs</code> collects extra keyword arguments into a dictionary.</li>
    </ul>

<pre><code class="language-python line-numbers">def show_info(**kwargs):
    print(kwargs)

show_info(name="Ammy", age=25, city="Berlin")
</code></pre>

<pre><code class="language-text">{'name': 'Ammy', 'age': 25, 'city': 'Berlin'}</code></pre>

    <br/>
    <ul>
        <li>You can iterate over the dictionary:</li>
    </ul>

<pre><code class="language-python line-numbers">def print_info(**kwargs):
    for key, value in kwargs.items():
        print(key, "=", value)
</code></pre>
    <br/><br/>


    <li><b>Combining Positional and Keyword Arguments</b></li>
    <br/>
    <ul>
        <li>You can combine both:</li>
    </ul>

<pre><code class="language-python line-numbers">def func(a, b, *args, **kwargs):
    print("a =", a)
    print("b =", b)
    print("args =", args)
    print("kwargs =", kwargs)

func(1, 2, 3, 4, x=10, y=20)
</code></pre>

<pre><code class="language-text">
a = 1
b = 2
args = (3, 4)
kwargs = {'x': 10, 'y': 20}
</code></pre>

    <br/>
    <ul>
        <li><u>Order matters</u> in function definitions:</li>
    </ul>

<pre><code class="language-text">1. normal positional parameters
2. *args
3. keyword-only parameters (optional)
4. **kwargs
</code></pre>

<pre><code class="language-python line-numbers">def example(a, *args, sep="-", **kwargs):
    pass
</code></pre>

    <br/><br/>


    <li><b>Argument Unpacking Using <code>*</code> and <code>**</code></b></li>
    <br/>
    <ul>
        <li>You can unpack lists and dictionaries when calling functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(add(*nums))
</code></pre>

<pre><code class="language-python line-numbers">def format_user(name, age, city):
    return f"{name}, {age}, from {city}"

info = {"name": "Bob", "age": 30, "city": "Hamburg"}
print(format_user(**info))
</code></pre>
    <br/><br/>


    <li><b>Real Use Case: Wrapping Functions (Forwarding Arguments)</b></li>
    <br/>
    <ul>
        <li><code>*args</code> and <code>**kwargs</code> make decorators and wrappers easy:</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(func):
    def wrapper(*args, **kwargs):
        print("Calling:", func.__name__)
        return func(*args, **kwargs)  # forward everything
    return wrapper

@debug
def multiply(x, y):
    return x * y

print(multiply(3, 4))
</code></pre>

    <br/>
    <ul>
        <li>This technique allows arbitrary functions to be wrapped without knowing their signature.</li>
    </ul>
    <br/><br/>


    <li><b>When to Use <code>*args</code> and <code>**kwargs</code>?</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use Case</th>
                <th><code>*args</code></th>
                <th><code>**kwargs</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Unknown number of positional arguments</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Unknown number of keyword arguments</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Forwarding arguments in decorators/wrappers</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Passing configuration options</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Building flexible API helpers</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Common Mistakes</b></li>
    <br/>
    <ul>
        <li><u>Wrong order</u> in function signature:</li>
    </ul>

<pre><code class="language-py line-numbers">def wrong(**kwargs, *args):  # ‚ùå invalid</code></pre>

    <br/>
    <ul>
        <li><b>Using args or kwargs without</b> <code>*</code>:</li>
    </ul>

<pre><code class="language-py line-numbers">def f(args):  # ‚ùå not the same as *args
    pass
</code></pre>

    <br/>
    <ul>
        <li>Forgetting to unpack:</li>
    </ul>

<pre><code class="language-python line-numbers">def f(a, b):
    return a + b

nums = (1, 2)
# f(nums) ‚ùå TypeError
f(*nums)   # ‚úî correct
</code></pre>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>*args</code></td>
                <td>Captures extra positional arguments into a tuple.</td>
            </tr>
            <tr>
                <td><code>**kwargs</code></td>
                <td>Captures extra keyword arguments into a dictionary.</td>
            </tr>
            <tr>
                <td>Unpacking</td>
                <td><code>*</code> unpacks lists/tuples, <code>**</code> unpacks dictionaries.</td>
            </tr>
            <tr>
                <td>Decorator usage</td>
                <td>Forward arguments to wrapped functions easily.</td>
            </tr>
            <tr>
                <td>Best practice</td>
                <td><code>a, *args, sep="-", **kwargs</code> follows correct ordering.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-match">Python <code>match</code> Statement (Structural Pattern Matching)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>match</code> statement was introduced in <u>Python 3.10</u>.</li>
        <br/>
        <li>Patterns can match:
            <ul>
                <li>values</li>
                <li>types</li>
                <li>structures (lists, dicts, tuples)</li>
                <li>classes</li>
                <li>guards (conditions)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Value Matching</b></li>
    <br/>

<pre><code class="language-python line-numbers">def check_status(code):
    match code:
        case 200:
            return "OK"
        case 404:
            return "Not Found"
        case 500:
            return "Server Error"
        case _:
            return "Unknown"
</code></pre>

    <br/>
    <ul>
        <li><code>_</code> is the wildcard catch-all.</li>
    </ul>
    <br/><br/>



    <li><b>Match Multiple Values in One Case</b></li>
    <br/>

<pre><code class="language-python line-numbers">match command:
    case "start" | "run":
        print("Starting...")
    case "stop" | "quit":
        print("Stopping...")
    case _:
        print("Unknown command")
</code></pre>

    <br/>
    <ul>
        <li>Use <code>|</code> (‚ÄúOR‚Äù) for multi-pattern matching.</li>
    </ul>
    <br/><br/>


    <li><b>Capturing Values</b></li>
    <br/>
    <ul>
        <li>
            With <code>match</code>, Python can look at a value (often coming from user input or a function)
            and check whether it fits a certain ‚Äúshape‚Äù.<br/>
            While doing that, it can also <b>capture parts of the value</b> into variables.
        </li>
    </ul>
<pre><code class="language-python line-numbers"># Example commands your program might receive
user_input = ("add", 10, 20)
# user_input = ("echo", "Hello")
# user_input = ("quit",)

match user_input:
    case ("add", x, y):
        # The tuple matches ("add", something, something)
        # The two values are captured as x and y
        print(x + y)

    case ("echo", message):
        # Matches a tuple with 2 elements: ("echo", some_text)
        # 'message' captures the second element
        print(message)

    case ("quit",):
        # Matches a single-element tuple
        print("Goodbye!")

    case _:
        # Anything else that doesn't fit the patterns
        print("Unknown command")
</code></pre>

    <br/>
    <ul>
        <li>
            Capturing lets you extract needed values directly inside the pattern.
            No manual unpacking or indexing is needed.
        </li>
    </ul>
    <br/><br/>



    <li><b>Sequence Pattern Matching</b></li>
    <br/>
<pre><code class="language-python line-numbers">match data:
    case [x, y]:
        print(f"Two elements: {x}, {y}")
    case [x, y, z]:
        print(f"Three elements: {x}, {y}, {z}")
    case [first, *rest]:
        print("First element:", first)
        print("Remaining:", rest)
</code></pre>

    <br/>
    <ul>
        <li><code>*rest</code> works like in argument unpacking.</li>
    </ul>
    <br/><br/>



    <li><b>Matching Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers">match config:
    case {"mode": "debug", "level": lvl}:
        print("Debug level:", lvl)
    case {"mode": "production"}:
        print("Running in prod mode")
    case _:
        print("Unknown config")
</code></pre>

    <br/>
    <ul>
        <li>Keys must match exactly; extra keys are allowed unless restricted.</li>
    </ul>
    <br/><br/>



    <li><b>Matching Classes (Object Patterns)</b></li>
    <br/>
<pre><code class="language-python line-numbers">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def describe(p):
    match p:
        case Point(x=0, y=0):
            return "Origin"
        case Point(x, y):
            return f"Point({x}, {y})"
</code></pre>

    <br/>
    <ul>
        <li>You can match attributes by name.</li>
    </ul>
    <br/><br/>



    <li><b>Using Guards (<code>if</code> conditions)</b></li>
    <br/>

<pre><code class="language-python line-numbers">match value:
    case x if x &gt; 0:
        print("Positive")
    case x if x &lt; 0:
        print("Negative")
    case 0:
        print("Zero")
</code></pre>
    <br/><br/>



    <li><b>Matching Enums</b></li>
    <br/>

<pre><code class="language-python line-numbers">from enum import Enum

class State(Enum):
    READY   = 1
    RUNNING = 2
    STOPPED = 3

match state:
    case State.READY:
        print("Ready")
    case State.RUNNING:
        print("Running")
    case State.STOPPED:
        print("Stopped")
</code></pre>
    <br/><br/>



    <li><b>Combining Patterns</b></li>
    <br/>

<pre><code class="language-python line-numbers">match event:
    case {"type": "click", "pos": (x, y)}:
        print("Clicked:", x, y)
    case {"type": "keypress", "key": k} if k.isalpha():
        print("Pressed a letter:", k)
    case {"type": "keypress", "key": k}:
        print("Pressed:", k)
    case _:
        print("Unknown event")
</code></pre>

    <br/><br/>


    <li><b>Common Mistakes</b></li>
    <br/>
    <ul>
        <li><b>Using <code>=</code> instead of <code>==</code> inside patterns</b></li>
    </ul>

<pre><code class="language-py line-numbers">case x = 10   # ‚ùå invalid
case 10       # ‚úî correct
</code></pre>

    <br/>

    <ul>
        <li><b>Misunderstanding variable binding</b>‚Äîpatterns like <code>case x</code> assign to <code>x</code>, they don‚Äôt compare.</li>
    </ul>

<pre><code class="language-python line-numbers">match value:
    case x:      # ALWAYS matches, captures value into x
        print("Matched:", x)
</code></pre>

    <br/>

    <ul>
        <li>To compare against variable <code>x</code>, prefix with <code>.</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">x = 10
match value:
    case .x:         # match literal value of x
        print("value is 10")
</code></pre>

    <br/><br/>



    <li><b>Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Value patterns</td>
                <td>Compare exact literals (200, "ok", etc.)</td>
            </tr>
            <tr>
                <td>OR-patterns</td>
                <td><code>"a" | "b"</code> matches either</td>
            </tr>
            <tr>
                <td>Sequence patterns</td>
                <td>Match lists/tuples, use <code>*rest</code></td>
            </tr>
            <tr>
                <td>Mapping patterns</td>
                <td>Match dictionaries by key</td>
            </tr>
            <tr>
                <td>Class patterns</td>
                <td>Match objects by attribute</td>
            </tr>
            <tr>
                <td>Guards</td>
                <td><code>case x if condition</code></td>
            </tr>
            <tr>
                <td>Wildcard</td>
                <td><code>_</code> matches anything</td>
            </tr>
            <tr>
                <td>Variable capture</td>
                <td>Patterns bind matched values to variables</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-numbers">Python Numbers</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python provides several built-in numeric types to represent and manipulate numbers.</li>
        <br/>
        <li>The three most common numeric types are:</li>
        <ul>
            <li><b>int</b>: integers of unlimited size</li>
            <li><b>float</b>: double-precision floating-point numbers</li>
            <li><b>complex</b>: numbers with real and imaginary parts</li>
        </ul>
        <br/>
        <li>Python also provides many built-in arithmetic operators, numeric functions, and modules like <code>math</code> and <code>decimal</code>.</li>
    </ul>
    <br/><br/>



    <li><b>Integers (<code>int</code>)</b></li>
    <br/>
    <ul>
        <li>Integers represent whole numbers and have <u>arbitrary precision</u> in Python.</li>
    </ul>

<pre><code class="language-python line-numbers">a = 123
b = -42
c = 10_000_000  # underscores allowed for readability
print(a, b, c)
</code></pre>

    <br/>
    <ul>
        <li>Python automatically grows integer size when needed:</li>
    </ul>

<pre><code class="language-python line-numbers">x = 10 ** 100
print(x)
</code></pre>

    <br/><br/>



    <li><b>Floating-Point Numbers (<code>float</code>)</b></li>
    <br/>
    <ul>
        <li>Python <code>float</code> represents 64-bit IEEE 754 ‚Äúdouble precision‚Äù.</li>
        <li>Floats support decimals, scientific notation, and infinite/NaN values.</li>
    </ul>

<pre><code class="language-python line-numbers">x = 3.14
y = 2.5e6      # scientific notation
z = float("-inf")
w = float("nan")

print(x, y, z, w)
</code></pre>

    <br/>
    <ul>
        <li><b>Be careful:</b> floats have rounding errors:</li>
    </ul>

<pre><code class="language-python line-numbers">print(0.1 + 0.2)   # 0.30000000000000004
</code></pre>

    <br/><br/>



    <li><b>Complex Numbers (<code>complex</code>)</b></li>
    <br/>
    <ul>
        <li>Python has native support for complex numbers using <code>j</code> for the imaginary part:</li>
    </ul>

<pre><code class="language-python line-numbers">c = 3 + 4j
print(c.real)
print(c.imag)
</code></pre>

    <br/>
    <ul>
        <li>Operations work naturally:</li>
    </ul>

<pre><code class="language-python line-numbers">z1 = 1 + 2j
z2 = 2 - 3j
print(z1 + z2)
print(z1 * z2)
</code></pre>

    <br/><br/>



    <li><b>Basic Arithmetic Operators</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = 10
b = 3
print(a + b)   # addition
print(a - b)   # subtraction
print(a * b)   # multiplication
print(a / b)   # float division
print(a // b)  # integer division
print(a % b)   # remainder
print(a ** b)  # exponentiation
</code></pre>

    <br/>
    <ul>
        <li><code>//</code> always returns a number rounded down.</li>
    </ul>

<pre><code class="language-python line-numbers">print(-7 // 3)  # -3, because floor(-7/3) = -3
</code></pre>

    <br/><br/>



    <li><b>Type Conversion</b></li>
    <br/>
    <ul>
        <li>Explicit conversions between types:</li>
    </ul>

<pre><code class="language-python line-numbers">int(3.99)       # 3
float(10)       # 10.0
complex(3)      # (3+0j)
</code></pre>

    <br/>
    <ul>
        <li>Strings can be converted if formatted correctly:</li>
    </ul>

<pre><code class="language-python line-numbers">int("42")
float("3.14")
complex("2+5j")
</code></pre>

    <br/><br/>



    <li><b>Built-in Numeric Functions</b></li>
<pre><code class="language-python line-numbers">abs(-5)         # 5
round(3.567, 2) # 3.57
pow(2, 5)       # 32
max(1, 4, 2)    # 4
min(1, 4, 2)    # 1
</code></pre>

    <br/><br/>



    <li><b>The <code>math</code> Module</b></li>
    <br/>
    <ul>
        <li><code>math</code> provides mathematical functions for floats.</li>
    </ul>

<pre><code class="language-python line-numbers">import math

print(math.sqrt(16))
print(math.sin(math.pi / 2))
print(math.factorial(5))
</code></pre>

    <br/>
    <ul>
        <li><code>math</code> has no support for complex numbers ‚Äî use <code>cmath</code> instead.</li>
    </ul>
    <br/><br/>



    <li><b>Decimals for High-Precision Calculations</b></li>
    <br/>
    <ul>
        <li>Use <code>decimal.Decimal</code> when you need accurate decimal arithmetic (e.g., finance).</li>
    </ul>

<pre><code class="language-python line-numbers">from decimal import Decimal

print(Decimal("0.1") + Decimal("0.2"))  # 0.3 exactly
</code></pre>

    <br/><br/>



    <li><b>Fractions for Rational Numbers</b></li>
    <br/>

<pre><code class="language-python line-numbers">from fractions import Fraction

x = Fraction(1, 3)
y = Fraction(1, 6)
print(x + y)   # 1/2
</code></pre>

    <br/><br/>



    <li><b>Checking Number Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">isinstance(10, int)
isinstance(3.14, float)
isinstance(2 + 3j, complex)
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Numeric Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>int</code></td>
                <td>Whole numbers with arbitrary precision</td>
            </tr>
            <tr>
                <td><code>float</code></td>
                <td>64-bit floating-point (may have rounding errors)</td>
            </tr>
            <tr>
                <td><code>complex</code></td>
                <td>Numbers with real and imaginary parts</td>
            </tr>
            <tr>
                <td><code>Decimal</code></td>
                <td>High-precision decimal arithmetic</td>
            </tr>
            <tr>
                <td><code>Fraction</code></td>
                <td>Exact rational numbers</td>
            </tr>
            <tr>
                <td><code>math</code></td>
                <td>Math functions for real numbers</td>
            </tr>
            <tr>
                <td><code>cmath</code></td>
                <td>Math functions for complex numbers</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-text">Python Text (Strings)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Python, text is represented with the <code>str</code> type.</li>
        <br/>
        <li>Strings in Python are:</li>
        <ul>
            <li><b>immutable</b> (cannot be changed after creation)</li>
            <li><b>Unicode-based</b> (support all languages and emoji)</li>
            <li><b>sequence types</b> (you can index, slice, iterate)</li>
        </ul>
        <br/>
        <li>Python treats text as human-readable Unicode, not raw bytes.</li>
    </ul>
    <br/><br/>



    <li><b>Creating Strings</b></li>
<pre><code class="language-python line-numbers">s1 = "Hello"
s2 = 'World'
s3 = "‰∏≠Êñá‰πüÂèØ‰ª•"
s4 = "Emoji üòä supported"
</code></pre>

    <br/>
    <ul>
        <li>Triple-quoted strings allow multiline text:</li>
    </ul>

<pre><code class="language-python line-numbers">multiline = """
This is
a multiline
string.
"""
</code></pre>

    <br/><br/>



    <li><b>String Immutability</b></li>
    <br/>
    <ul>
        <li>Strings cannot be modified in place:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "hello"
# s[0] = "H"  # ‚ùå error
</code></pre>

    <ul>
        <li>To ‚Äúmodify,‚Äù you must create a new string:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "hello"
s = "H" + s[1:]
print(s)  # Hello
</code></pre>

    <br/><br/>



    <li><b>Indexing and Slicing</b></li>
<pre><code class="language-python line-numbers">s = "Python"

print(s[0])     # P
print(s[-1])    # n
print(s[1:4])   # yth
print(s[:3])    # Pyt
print(s[3:])    # hon
print(s[::-1])  # reversed
</code></pre>

    <br/><br/>



    <li><b>Useful String Methods</b></li>
    <br/>
    <ul>
        <li>Case operations:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "hello WORLD"
print(s.lower())
print(s.upper())
print(s.title())
print(s.capitalize())
</code></pre>

    <br/>
    <ul>
        <li>Searching:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "Python Programming"
print(s.find("Pro"))   # 7
print(s.count("m"))    # 2
</code></pre>

    <br/>
    <ul>
        <li>Stripping whitespace:</li>
    </ul>

<pre><code class="language-python line-numbers">"  hello  ".strip()    # "hello"
"  hi  ".lstrip()      # "hi  "
"  hi  ".rstrip()      # "  hi"
</code></pre>

    <br/>
    <ul>
        <li>Replacing and splitting:</li>
    </ul>

<pre><code class="language-python line-numbers">"a-b-c".split("-")          # ['a', 'b', 'c']
"Hello World".replace("World", "Python")
</code></pre>

    <br/>
    <ul>
        <li>Joining:</li>
    </ul>

<pre><code class="language-python line-numbers">"-".join(["a", "b", "c"])  # "a-b-c"
</code></pre>

    <br/><br/>



    <li><b>String Formatting</b></li>
    <br/>

    <ul>
        <li><b>f-strings</b> (recommended):</li>
    </ul>

<pre><code class="language-python line-numbers">name = "Hwangfu"
age = 23
print(f"My name is {name} and I am {age} years old.")
</code></pre>

    <br/>
    <ul>
        <li><code>str.format()</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">print("Hello, {}!".format("World"))
print("{name} is {age}".format(name="Ammy", age=30))
</code></pre>

    <br/>
    <ul>
        <li>Old C-style formatting:</li>
    </ul>

<pre><code class="language-python line-numbers">print("%s scored %d points" % ("Ammy", 95))
</code></pre>

    <br/><br/>



    <li><b>Escape Sequences</b></li>
    <br/>

<pre><code class="language-python line-numbers">print("Line1\nLine2")
print("Tab\tSeparated")
print("Quote: \"Hello\"")
</code></pre>

    <br/>
    <ul>
        <li><b>Raw strings</b> avoid escapes (useful for regex):</li>
    </ul>

<pre><code class="language-python line-numbers">r"C:\Users\Name"
r"\n is not a newline"
</code></pre>

    <br/><br/>



    <li><b>Unicode Support</b></li>
    <br/>
    <ul>
        <li>Python stores strings in Unicode:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "‰Ω†Â•Ω üòä ŒìŒµŒπŒ¨ œÉŒøœÖ"
print(len(s)) # 13
</code></pre>

    <br/>
    <ul>
        <li>Inspecting code points:</li>
    </ul>

<pre><code class="language-python line-numbers">ord("‰Ω†")     # Unicode code point
chr(20320)    # Convert code point to char
</code></pre>

    <br/><br/>



    <li><b>Bytes vs Strings</b></li>
    <br/>
    <ul>
        <li><code>str</code> = Unicode text</li>
        <li><code>bytes</code> = raw 8-bit values</li>
    </ul>

<pre><code class="language-python line-numbers">b = b"hello"
print(b[0])         # 104
</code></pre>

    <br/>
    <ul>
        <li>You must encode/decode explicitly:</li>
    </ul>

<pre><code class="language-python line-numbers">text = "hello"
data = text.encode("utf-8")   # bytes
back = data.decode("utf-8")   # str
</code></pre>

    <br/><br/>



    <li><b>Substring Testing</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = "hello world"

print("world" in s)     # True
print(s.startswith("he"))
print(s.endswith("ld"))
</code></pre>

    <br/><br/>



    <li><b>Iterating Through a String</b></li>
    <br/>

<pre><code class="language-python line-numbers">for ch in "Python":
    print(ch)
</code></pre>

    <br/><br/>



    <li><b>String Concatenation</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = "Py" + "thon"
print(s)
</code></pre>

    <br/>
    <ul>
        <li>For repeated concatenation, use <code>join</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">result = "".join(["a"] * 5)
print(result)   # "aaaaa"
</code></pre>

    <br/><br/>



    <li><b>Whitespace and Character Classification</b></li>
    <br/>
<pre><code class="language-python line-numbers">s = "abc123"

print(s.isalpha())    # False
print(s.isdigit())    # False
print(s.isalnum())    # True
print(" ".isspace())  # True
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>str</code></td>
                <td>Unicode text, immutable</td>
            </tr>
            <tr>
                <td>Indexing / slicing</td>
                <td>Extract individual characters or substrings</td>
            </tr>
            <tr>
                <td>String methods</td>
                <td>Case changes, searching, replacing, splitting, joining</td>
            </tr>
            <tr>
                <td>Formatting</td>
                <td>Use f-strings, <code>format()</code>, or <code>%</code></td>
            </tr>
            <tr>
                <td>Unicode support</td>
                <td>Strings store Unicode code points</td>
            </tr>
            <tr>
                <td>Bytes vs str</td>
                <td>Use <code>.encode()</code> and <code>.decode()</code> to convert</td>
            </tr>
            <tr>
                <td>Escape sequences</td>
                <td><code>\n</code>, <code>\t</code>, <code>\"</code>, and raw strings</td>
            </tr>
            <tr>
                <td>Immutability</td>
                <td>Strings cannot be modified in place</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-lists">Python Lists</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>list</code> in Python is a dynamic, ordered, and mutable collection of items.</li>
        <br/>
        <li>Lists can store <b>any type of object</b>, even mixed types.</li>
        <br/>
    </ul>
    <br/><br/>



    <li><b>Creating Lists</b></li>
    <br/>
<pre><code class="language-python line-numbers">nums   = [1, 2, 3]
mixed  = [1, "two", 3.0, True]
nested = [[1, 2], [3, 4]]
empty  = []
</code></pre>
    <ul>
        <li>Using <code>list()</code> constructor:</li>
    </ul>

<pre><code class="language-python line-numbers">chars = list("hello")  # ['h', 'e', 'l', 'l', 'o']
</code></pre>

    <br/><br/>



    <li><b>List Indexing and Slicing</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [10, 20, 30, 40, 50]

print(a[0])       # 10
print(a[-1])      # 50
print(a[1:4])     # [20, 30, 40]
print(a[:3])      # [10, 20, 30]
print(a[3:])      # [40, 50]
print(a[::-1])    # reversed list
</code></pre>

    <br/><br/>


    <li><b>List Mutability</b></li>
    <br/>
    <ul>
        <li>Lists are <b>mutable</b>, elements can be changed in place.</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3]
a[0] = 100
print(a)          # [100, 2, 3]
</code></pre>

    <br/>
    <ul>
        <li>You can modify slices too:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3, 4]
a[1:3] = [20, 30, 40]
print(a)          # [1, 20, 30, 40, 4]
</code></pre>

    <br/><br/>



    <li><b>Adding Elements</b></li>
    <br/>

    <ul>
        <li><code>append()</code> ‚Äî add item to end:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3]
a.append(4)
print(a)    # [1, 2, 3, 4]
</code></pre>

    <br/>
    <ul>
        <li><code>insert()</code> ‚Äî add at position:</li>
    </ul>

<pre><code class="language-python line-numbers">a.insert(1, "X")
print(a)   # [1, 'X', 2, 3, 4]
</code></pre>

    <br/>
    <ul>
        <li><code>extend()</code> ‚Äî add multiple items at end:</li>
    </ul>

<pre><code class="language-python line-numbers">a.extend([5, 6])
print(a)    # [1, 'X', 2, 3, 4, 5, 6]
</code></pre>

    <br/><br/>



    <li><b>Removing Elements</b></li>
    <br/>

    <ul>
        <li><code>remove()</code> ‚Äî remove first matching value:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3, 2]
a.remove(2)
print(a)   # [1, 3, 2]
</code></pre>

    <br/>
    <ul>
        <li><code>pop()</code> ‚Äî remove by index (returns the element):</li>
    </ul>

<pre><code class="language-python line-numbers">x = a.pop(1)
print(x)    # removed value
print(a)    # [1, 2]
</code></pre>

    <br/>
    <ul>
        <li><code>clear()</code> ‚Äî empty the list:</li>
    </ul>

<pre><code class="language-python line-numbers">a.clear()
print(a)   # []
</code></pre>

    <br/><br/>



    <li><b>Searching and Counting</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [10, 20, 30, 20]

print(a.index(20))   # 1
print(a.count(20))   # 2
</code></pre>

    <br/><br/>



    <li><b>Sorting and Reversing</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [3, 1, 4, 1, 5]

a.sort()
print(a)    # [1, 1, 3, 4, 5]

a.sort(reverse=True)
print(a)    # [5, 4, 3, 1, 1]
</code></pre>

    <br/>
    <ul>
        <li><code>sorted()</code> returns a new list:</li>
    </ul>

<pre><code class="language-python line-numbers">b = sorted(a)
</code></pre>

    <br/>
    <ul>
        <li>Reverse order inside a list:</li>
    </ul>

<pre><code class="language-python line-numbers">a.reverse()
</code></pre>

    <br/><br/>



    <li><b>Iterating Over a List</b></li>
    <br/>

<pre><code class="language-python line-numbers">for x in [10, 20, 30]:
    print(x)
</code></pre>

    <br/>
    <ul>
        <li>Getting index and value:</li>
    </ul>

<pre><code class="language-python line-numbers">for i, val in enumerate(["a", "b", "c"]):
    print(i, val)
</code></pre>

    <br/><br/>



    <li><b>Membership Testing</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [1, 2, 3]

print(2 in a)      # True
print(10 not in a) # True
</code></pre>

    <br/><br/>



    <li><b>List Comprehensions</b></li>
    <br/>
    <ul>
        <li>Compact syntax for generating lists:</li>
    </ul>

<pre><code class="language-python line-numbers">squares = [x * x for x in range(5)]
evens = [x for x in range(20) if x % 2 == 0]

print(squares)
print(evens)
</code></pre>

    <br/>
    <ul>
        <li>Nested list comprehension:</li>
    </ul>

<pre><code class="language-python line-numbers">matrix = [[i * j for j in range(3)] for i in range(3)]
print(matrix)
</code></pre>

    <br/><br/>



    <li><b>Copying Lists</b></li>
    <br/>
    <ul>
        <li><b>Shallow copy</b>: elements are shared:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3]
b = a[:]        # shallow copy
c = list(a)     # shallow copy
</code></pre>

    <br/>
    <ul>
        <li><b>Deep copy</b>: nested lists duplicated:</li>
    </ul>

<pre><code class="language-python line-numbers">import copy

nested = [[1], [2]]
d = copy.deepcopy(nested)
</code></pre>

    <br/><br/>



    <li><b>Common List Pitfall: Shared References</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [[0] * 3] * 3
print(a)
a[0][0] = 99
print(a)  # all rows changed!
</code></pre>

    <br/>
    <ul>
        <li>Correct way:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [[0 for _ in range(3)] for _ in range(3)]
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ordered</td>
                <td>List elements maintain insertion order</td>
            </tr>
            <tr>
                <td>Mutable</td>
                <td>Elements and slices can be changed in place</td>
            </tr>
            <tr>
                <td>Heterogeneous</td>
                <td>Can contain mixed types</td>
            </tr>
            <tr>
                <td>Dynamic</td>
                <td>Lists grow and shrink automatically</td>
            </tr>
            <tr>
                <td>List methods</td>
                <td>append, insert, extend, remove, pop, clear, sort, reverse</td>
            </tr>
            <tr>
                <td>Comprehensions</td>
                <td>Powerful syntax for generating lists</td>
            </tr>
            <tr>
                <td>Copying</td>
                <td>Use slice or <code>copy()</code> for shallow; <code>deepcopy()</code> for deep</td>
            </tr>
            <tr>
                <td>Common pitfall</td>
                <td><code>[[0] * n] * m</code> duplicates references</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-type-annotations">Python Type Annotations</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Type annotations were introduced in Python 3.5 and expanded significantly in later versions (3.7+, 3.9+, 3.10+, 3.12+).</li>
        <br/>
        <li>They allow you to <b>declare the expected type</b> of variables, function parameters, return values, classes, and more.</li>
        <br/>
        <li>Annotations are checked by external tools (e.g., <code>mypy</code>, <code>pyright</code>, <code>ruff</code>), not by Python itself.</li>
        <br/>
        <li>At runtime, annotations do nothing unless explicitly used.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Function Annotations</b></li>
    <br/>

<pre><code class="language-python line-numbers">def add(x: int, y: int) -&gt; int:
    return x + y
</code></pre>

    <ul>
        <li><code>x: int</code> ‚Äî parameter annotation</li>
        <li><code>-&gt; int</code> ‚Äî return annotation</li>
    </ul>

    <br/>
    <ul>
        <li>Multiple arguments:</li>
    </ul>

<pre><code class="language-python line-numbers">def greet(name: str, age: int) -&gt; str:
    return f"{name} is {age} years old"
</code></pre>

    <br/><br/>



    <li><b>Annotating Variables</b></li>
    <br/>

<pre><code class="language-python line-numbers">age: int = 25
name: str = "Hwangfu"
height: float = 1.80
</code></pre>

    <br/>
    <ul>
        <li>Without assigning a value (type-only variable):</li>
    </ul>

<pre><code class="language-python line-numbers">count: int
</code></pre>

    <br/><br/>



    <li><b>Common Built-in Types</b></li>
    <br/>
    <ul>
        <li>Use these directly in Python 3.9+</li>
    </ul>

<pre><code class="language-python line-numbers">n: int = 10
flag: bool = True
ratio: float = 0.75
text: str = "Hello"
</code></pre>

    <br/><br/>



    <li><b>Containers and Generics</b></li>
    <br/>
    <ul>
        <li>Use built-in generic types (Python 3.9+):</li>
    </ul>

<pre><code class="language-python line-numbers">nums: list[int] = [1, 2, 3]
names: set[str] = {"a", "b"}
mapping: dict[str, int] = {"a": 1}
matrix: list[list[int]] = [[1, 2], [3, 4]]
</code></pre>

    <br/>
    <ul>
        <li>For compatibility with older versions, use <code>typing.List</code>, <code>typing.Dict</code>, etc.</li>
    </ul>
    <br/><br/>



    <li><b>Optional Types</b></li>
    <br/>
    <ul>
        <li>A value that may be <code>None</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Optional

age: Optional[int] = None
</code></pre>

    <br/>
    <ul>
        <li>Python 3.10+ (PEP 604):</li>
    </ul>

<pre><code class="language-python line-numbers">age: int | None = None
</code></pre>

    <br/><br/>



    <li><b>Union Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Union

value: Union[int, str] = 10
</code></pre>

    <br/>
    <ul>
        <li>Python 3.10+:</li>
    </ul>

<pre><code class="language-python line-numbers">value: int | str = 10
</code></pre>

    <br/><br/>



    <li><b>Any Type</b></li>
    <br/>
    <ul>
        <li><code>Any</code> disables type checking.</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Any

data: Any = "hello"
data = 123         # allowed
</code></pre>

    <br/><br/>



    <li><b>Literal Types</b></li>
    <br/>
    <ul>
        <li>Restrict allowed values:</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Literal

mode: Literal["debug", "prod", "test"] = "debug"
</code></pre>

    <br/><br/>



    <li><b>Callable / Function Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Callable

def apply(f: Callable[[int, int], int], x: int, y: int) -&gt; int:
    return f(x, y)
</code></pre>

    <br/><br/>



    <li><b>Tuple Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">coords: tuple[int, int] = (10, 20)
point: tuple[int, str, float] = (1, "a", 1.5)
</code></pre>

    <br/>
    <ul>
        <li>Variable-length tuples:</li>
    </ul>

<pre><code class="language-python line-numbers">nums: tuple[int, ...] = (1, 2, 3)
</code></pre>

    <br/><br/>



    <li><b>Self Type (Methods returning instance)</b></li>
    <br/>
    <ul>
        <li>Python 3.11 introduced <code>typing.Self</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Self

class Vector:
    def scale(self, x: float) -&gt; Self:
        self.x *= x
        self.y *= x
        return self
</code></pre>

    <br/><br/>



    <li><b>TypedDict (for dicts with fixed structure)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypedDict

class User(TypedDict):
    id: int
    name: str
    email: str

u: User = {"id": 1, "name": "Ammy", "email": "a@example.com"}
</code></pre>

    <br/><br/>



    <li><b>Protocol (Duck Typing Interfaces)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Protocol

class Drawable(Protocol):
    def draw(self) -&gt; None:
        ...

def render(obj: Drawable) -&gt; None:
    obj.draw()
</code></pre>

    <br/>
    <ul>
        <li>No inheritance required: if a class has <code>draw()</code>, it matches the protocol.</li>
    </ul>
    <br/><br/>



    <li><b>Final</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Final

PI: Final = 3.14159
</code></pre>

    <ul>
        <li>Type checkers warn if you try to reassign.</li>
    </ul>

    <br/><br/>



    <li><b>Class and Instance Attributes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Person:
    name: str          # instance attribute annotation
    count: int = 0     # class variable annotation
</code></pre>

    <br/><br/>



    <li><b>Forward References</b></li>
    <br/>
    <ul>
        <li>When a type is not yet defined, quote it:</li>
    </ul>

<pre><code class="language-python line-numbers">class Node:
    next: "Node" | None
</code></pre>

    <br/><br/>



    <li><b>Union Return Patterns with <code>match</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">def parse(data: str) -&gt; int | float | None:
    match data:
        case "none":
            return None
        case _ if data.isdigit():
            return int(data)
        case _:
            return float(data)
</code></pre>

    <br/><br/>



    <li><b>ParamSpec and TypeVar (Advanced Generics)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypeVar, ParamSpec, Callable

P = ParamSpec("P")
R = TypeVar("R")

def wrapper(f: Callable[P, R]) -&gt; Callable[P, R]:
    def inner(*args: P.args, **kwargs: P.kwargs) -&gt; R:
        return f(*args, **kwargs)
    return inner
</code></pre>

    <br/><br/>



    <li><b>Annotated (Metadata for Types)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Annotated

x: Annotated[int, "must be positive"] = 5
</code></pre>

    <br/><br/>



    <li><b>Type Aliases</b></li>
    <br/>

<pre><code class="language-python line-numbers">UserId = int
Vector = list[float]

def scale(v: Vector) -&gt; Vector:
    return [x * 10 for x in v]
</code></pre>

    <br/><br/>



    <li><b>Runtime Access to Annotations</b></li>
    <br/>
    <ul>
        <li>Annotations are stored in <code>__annotations__</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def f(x: int, y: str) -&gt; bool:
    return True

print(f.__annotations__)
</code></pre>

    <br/><br/>



    <li><b>Summary of Major Annotation Features</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic types</td>
                <td><code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code></td>
            </tr>
            <tr>
                <td>Generics</td>
                <td><code>list[int]</code>, <code>dict[str, int]</code></td>
            </tr>
            <tr>
                <td>Optional</td>
                <td><code>int | None</code></td>
            </tr>
            <tr>
                <td>Union</td>
                <td><code>int | str</code></td>
            </tr>
            <tr>
                <td>Any</td>
                <td>Disable type checking</td>
            </tr>
            <tr>
                <td>Literal</td>
                <td>Restrict to specific values</td>
            </tr>
            <tr>
                <td>Callable</td>
                <td>Describe function signatures</td>
            </tr>
            <tr>
                <td>TypedDict</td>
                <td>Dicts with fixed field types</td>
            </tr>
            <tr>
                <td>Protocol</td>
                <td>Duck-typing interfaces</td>
            </tr>
            <tr>
                <td>Final</td>
                <td>Constant-like values</td>
            </tr>
            <tr>
                <td>Self</td>
                <td>Methods returning class instance</td>
            </tr>
            <tr>
                <td>ParamSpec / TypeVar</td>
                <td>Advanced generic functions</td>
            </tr>
            <tr>
                <td>Annotated</td>
                <td>Add metadata to types</td>
            </tr>
            <tr>
                <td>Type Aliases</td>
                <td>Give names to complex types</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-protocol">Python Protocols</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>Protocol</code> in Python (introduced in <b>PEP 544</b>) is a way to define <b>structural typing</b> (also called <b>duck typing</b>) for static type checkers such as <code>mypy</code>, <code>pyright</code>, and <code>ruff</code>.</li>
        <br/>
        <li>Structural typing means:
            <b>"If an object has the required methods/attributes, it is accepted ‚Äî regardless of its class."</b>
        </li>
        <br/>
        <li>This is different from nominal typing where the type depends on inheritance.</li>
        <br/>
        <li>Protocols allow you to define interfaces <b>without forcing inheritance</b>.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Protocol Example</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Protocol

class Greeter(Protocol):
    def greet(self) -&gt; str:
        ...
</code></pre>

    <ul>
        <li>Any class with a <code>greet()</code> method returning a <code>str</code> matches this protocol:</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    def greet(self) -&gt; str:
        return "Hello!"

class Robot:
    def greet(self) -&gt; str:
        return "Beep bop"
</code></pre>

    <br/>
    <ul>
        <li>Both classes satisfy <code>Greeter</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def welcome(g: Greeter) -&gt; None:
    print(g.greet())

welcome(Person())   # OK
welcome(Robot())    # OK
</code></pre>

    <br/><br/>



    <li><b>No Need to Inherit</b></li>
    <br/>
    <ul>
        <li>The following also works, because Protocols check structure, not inheritance:</li>
    </ul>

<pre><code class="language-python line-numbers">class Cat:
    def greet(self) -&gt; str:
        return "Meow"
</code></pre>

<pre><code class="language-python line-numbers">welcome(Cat())   # Also OK
</code></pre>

    <br/>
    <ul>
        <li><code>Cat</code> does NOT inherit from <code>Greeter</code>, but matches the required structure.</li>
    </ul>

    <br/><br/>



    <li><b>Protocols with Attributes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User(Protocol):
    name: str
    age: int

def print_user(u: User) -&gt; None:
    print(u.name, u.age)
</code></pre>

    <ul>
        <li>Any object with <code>name</code> and <code>age</code> attributes matches:</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name: str, age: int) -&gt; None:
        self.name = name
        self.age = age

print_user(Person("Hwangfu", 23))
</code></pre>

    <br/><br/>



    <li><b>Protocols with Multiple Methods</b></li>
    <br/>

<pre><code class="language-python line-numbers">class FileLike(Protocol):
    def read(self) -&gt; str:
        ...
    def write(self, s: str) -&gt; int:
        ...
</code></pre>

    <ul>
        <li>Any class with <code>read()</code> and <code>write()</code> methods is considered file-like.</li>
    </ul>

    <br/><br/>



    <li><b>Extending Protocols</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Shape(Protocol):
    def area(self) -&gt; float:
        ...

class DrawableShape(Shape, Protocol):
    def draw(self) -&gt; None:
        ...
</code></pre>

    <br/><br/>



    <li><b>Optional Protocol Features</b></li>
    <br/>

    <ul>
        <li><b>@runtime_checkable</b> allows <code>isinstance()</code> checks at runtime:</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import runtime_checkable

@runtime_checkable
class Greeter(Protocol):
    def greet(self) -&gt; str:
        ...
</code></pre>

    <br/>
    <ul>
        <li>Now you can do:</li>
    </ul>

<pre><code class="language-python line-numbers">print(isinstance(Person(), Greeter))   # True
print(isinstance(42, Greeter))         # False
</code></pre>

    <br/><br/>



    <li><b>Protocols vs Abstract Base Classes (ABC)</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Protocol</th>
                <th>ABC (Abstract Base Class)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Typing style</td>
                <td>Structural (duck typing)</td>
                <td>Nominal (inherits from ABC)</td>
            </tr>
            <tr>
                <td>Requires inheritance?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Runtime enforcement</td>
                <td>No (unless using <code>@runtime_checkable</code>)</td>
                <td>Yes (raises error if abstract methods not implemented)</td>
            </tr>
            <tr>
                <td>Common usage</td>
                <td>Flexible APIs, plugin systems, duck typing</td>
                <td>Strict class hierarchies</td>
            </tr>
            <tr>
                <td>Better for static type checking?</td>
                <td>Yes</td>
                <td>Partly</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Protocol with Generics</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Protocol, TypeVar

T = TypeVar("T")

class Container(Protocol[T]):
    def add(self, item: T) -&gt; None:
        ...
</code></pre>

    <br/><br/>



    <li><b>Using Protocols to Define Function Signatures</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Comparator(Protocol):
    def __call__(self, a: int, b: int) -&gt; bool:
        ...

def sort_with(nums: list[int], comp: Comparator) -&gt; None:
    nums.sort(key=lambda x: x, reverse=comp(1, 0))
</code></pre>

    <br/><br/>



    <li><b>Protocols with Properties</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Sized(Protocol):
    @property
    def size(self) -&gt; int:
        ...
</code></pre>

<pre><code class="language-python line-numbers">class Box:
    def __init__(self, size: int) -&gt; None:
        self._size = size

    @property
    def size(self) -&gt; int:
        return self._size
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Protocol</td>
                <td>Defines a structural-typing interface</td>
            </tr>
            <tr>
                <td>No inheritance required</td>
                <td>Matches by methods/attributes present</td>
            </tr>
            <tr>
                <td>@runtime_checkable</td>
                <td>Allows <code>isinstance()</code> with Protocol</td>
            </tr>
            <tr>
                <td>Attributes & Methods</td>
                <td>Protocols can specify both</td>
            </tr>
            <tr>
                <td>Generics support</td>
                <td>Protocols can accept type parameters</td>
            </tr>
            <tr>
                <td>Use cases</td>
                <td>Flexible interfaces, APIs, plugin architectures</td>
            </tr>
            <tr>
                <td>Difference from ABC</td>
                <td>Structural vs. nominal typing</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-typeddict">Python <code>TypedDict</code></h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>TypedDict</code> (introduced in PEP 589) allows you to define <b>dictionaries with a fixed structure</b> ‚Äî specific keys and specific value types.</li>
        <br/>
        <li>It is extremely useful when you want dict-like objects but with the type safety of data classes.</li>
        <br/>
        <li>Unlike <code>dataclasses</code>, <code>TypedDict</code> remains a regular <b>dict at runtime</b> and does not enforce types ‚Äî checkers like <code>mypy</code>, <code>pyright</code>, and <code>ruff</code> enforce it statically.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Usage</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypedDict

class User(TypedDict):
    id: int
    name: str
    email: str
</code></pre>

    <br/>
    <ul>
        <li>Create instances like normal dicts:</li>
    </ul>

<pre><code class="language-python line-numbers">u: User = {
    "id": 1,
    "name": "Ammy",
    "email": "alice@example.com"
}
</code></pre>

    <br/><br/>



    <li><b>TypedDict Enforces Key Presence</b></li>
    <br/>
    <ul>
        <li>Missing required keys ‚Üí static type error:</li>
    </ul>

<pre><code class="language-python line-numbers">bad_user: User = {
    "id": 1,
    "name": "Ammy"
}   # ‚ùå error: missing key "email"
</code></pre>

    <br/>
    <ul>
        <li>Extra keys ‚Üí static type error:</li>
    </ul>

<pre><code class="language-python line-numbers">wrong: User = {
    "id": 1,
    "name": "Ammy",
    "email": "a@x.com",
    "age": 23
}   # ‚ùå error: extra key "age"
</code></pre>

    <br/><br/>



    <li><b>Optional Keys</b></li>
    <br/>
    <ul>
        <li>Option 1: Annotate key as optional value:</li>
    </ul>

<pre><code class="language-python line-numbers">class User(TypedDict):
    id: int
    name: str
    email: str | None   # value may be None
</code></pre>

    <br/>
    <ul>
        <li>Option 2: Mark the entire key as optional using <code>total=False</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">class PartialUser(TypedDict, total=False):
    id: int
    name: str
    email: str
</code></pre>

    <br/>
    <ul>
        <li>Now all keys are optional.</li>
    </ul>

<pre><code class="language-python line-numbers">p: PartialUser = {}
</code></pre>

    <br/><br/>



    <li><b>Mixing Required and Optional Keys</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User(TypedDict):
    id: int
    name: str

class UserExtra(TypedDict, total=False):
    email: str
    age: int
</code></pre>

    <ul>
        <li>You can also combine required and optional keys inside one definition (Python 3.11+ style):</li>
    </ul>

<pre><code class="language-python line-numbers">class User(TypedDict):
    id: int
    name: str
    email: str | None   # optional value, key still required
</code></pre>

    <br/><br/>



    <li><b>Readonly Keys (Python 3.12+)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypedDict, NotRequired, ReadOnly

class Config(TypedDict):
    version: ReadOnly[int]
    debug: NotRequired[bool]
</code></pre>
    <br/>
    <ul>
        <li><code>version</code> is readonly for static checking.</li>
    </ul>
    <br/><br/><br/>



    <li><b>TypedDict with Inheritance</b></li>
    <br/>

<pre><code class="language-python line-numbers">class BaseUser(TypedDict):
    id: int
    name: str

class FullUser(BaseUser):
    email: str
    age: int
</code></pre>
    <br/>
    <ul>
        <li><code>FullUser</code> now includes all keys of <code>BaseUser</code>.</li>
    </ul>
    <br/><br/><br/>



    <li><b>TypedDict vs Dataclass</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>TypedDict</th>
                <th>Dataclass</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Runtime type</td>
                <td>Just a dict</td>
                <td>Custom class</td>
            </tr>
            <tr>
                <td>Allows missing keys?</td>
                <td>No (unless <code>total=False</code>)</td>
                <td>Yes (default values)</td>
            </tr>
            <tr>
                <td>Fast creation?</td>
                <td>Yes (dict)</td>
                <td>Slower (object)</td>
            </tr>
            <tr>
                <td>Attribute access</td>
                <td>Key-based (<code>d["key"]</code>)</td>
                <td>Dot-access (<code>d.key</code>)</td>
            </tr>
            <tr>
                <td>Static type checking</td>
                <td>Strong</td>
                <td>Strong</td>
            </tr>
            <tr>
                <td>Serialization (JSON)</td>
                <td>Easy</td>
                <td>Requires conversion</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>TypedDict with Functions</b></li>
    <br/>

<pre><code class="language-python line-numbers">def process_user(user: User) -&gt; None:
    print(user["id"], user["name"])
</code></pre>

    <br/><br/>



    <li><b>TypedDict for API Responses</b></li>
    <br/>

<pre><code class="language-python line-numbers">class ApiResponse(TypedDict):
    status: int
    data: dict[str, str]
</code></pre>

<pre><code class="language-python line-numbers">response: ApiResponse = {
    "status": 200,
    "data": {"id": "123"}
}
</code></pre>

    <br/><br/>



    <li><b>Nesting TypedDicts</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Profile(TypedDict):
    bio: str
    github: str

class User(TypedDict):
    id: int
    profile: Profile
</code></pre>

    <br/><br/>



    <li><b>TypedDict with Literal Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Literal

class Event(TypedDict):
    type: Literal["click", "keypress"]
    payload: dict[str, str]
</code></pre>

    <br/><br/>



    <li><b>Total=False Default Behavior</b></li>
    <br/>
    <ul>
        <li>You can flip the default ‚Äî make keys optional unless stated otherwise:</li>
    </ul>

<pre><code class="language-python line-numbers">class Partial(TypedDict, total=False):
    required: int
    # everything here is optional
</code></pre>

    <br/><br/>



    <li><b>Using TypedDict with <code>**kwargs</code></b></li>
    <br/>
<pre><code class="language-python line-numbers">def create_user(**kwargs: User) -&gt; User:
    return kwargs
</code></pre>

    <br/><br/>



    <li><b>Runtime Representation</b></li>
    <br/>
    <ul>
        <li><code>TypedDict</code> is still a normal dictionary:</li>
    </ul>

<pre><code class="language-python line-numbers">u: User = {"id": 1, "name": "Ammy", "email": "a@x.com"}

print(type(u))    # &lt;class 'dict'&gt;
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>TypedDict</code></td>
                <td>Dictionary with predefined keys and value types</td>
            </tr>
            <tr>
                <td>Required keys</td>
                <td>All keys required unless <code>total=False</code></td>
            </tr>
            <tr>
                <td>Optional keys</td>
                <td>Via <code>total=False</code> or optional values</td>
            </tr>
            <tr>
                <td>Runtime representation</td>
                <td>Still a plain dict, only static checks apply</td>
            </tr>
            <tr>
                <td>Supports inheritance</td>
                <td>Extend dictionary definitions</td>
            </tr>
            <tr>
                <td>Common use cases</td>
                <td>API schemas, config objects, JSON-like data</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-type-checkers">Python Type Checkers: mypy, pyright, and ruff</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python is dynamically typed, but modern tools allow <b>static type checking</b> based on type hints.</li>
        <br/>
        <li>The three major tools are:</li>
        <ul>
            <li><code>mypy</code>: classic, strict, feature-rich</li>
            <li><code>pyright</code>: fast, modern, excellent IDE integration</li>
            <li><code>ruff</code>: fast linter with partial type checks</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>What Static Type Checking Does</b></li>
    <br/>
    <ul>
        <li>Type checkers analyze your code <b>without running it</b>.</li>
        <br/>
        <li>They detect errors such as:</li>
        <ul>
            <li>wrong argument types</li>
            <li>incorrect return types</li>
            <li>invalid attribute access</li>
            <li>mistyped <code>TypedDict</code> keys</li>
            <li>mismatched <code>Protocol</code> implementations</li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">def add(a: int, b: int) -&gt; int:
    return a + b

add("hi", 3)  # ‚ùå static type error
</code></pre>

    <br/><br/>



    <li><b>mypy</b></li>
    <br/>
    <ul>
        <li><code>mypy</code> is the most widely adopted and feature-complete type checker.</li>
        <br/>
        <li>Strong support for:</li>
        <ul>
            <li><code>TypedDict</code></li>
            <li><code>Protocol</code></li>
            <li>Generics</li>
            <li><code>Literal</code> types</li>
            <li><code>@overload</code></li>
            <li>Strict mode settings</li>
        </ul>
        <br/>
        <li>Installation:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install mypy
</code></pre>

    <br/>
    <ul>
        <li>Running mypy:</li>
    </ul>

<pre><code class="language-bash line-numbers">mypy app.py
</code></pre>

    <br/>
    <ul>
        <li>Example configuration (<code>mypy.ini</code>):</li>
    </ul>

<pre><code class="language-ini line-numbers">[mypy]
strict = True
disallow_untyped_defs = True
warn_unused_ignores = True
</code></pre>

    <br/><br/>



    <li><b>pyright</b></li>
    <br/>
    <ul>
        <li><code>pyright</code> is a fast type checker created by Microsoft.</li>
        <br/>
        <li>Main advantages:</li>
        <ul>
            <li>extremely fast</li>
            <li>excellent VSCode integration</li>
            <li>advanced type inference and narrow typing</li>
            <li>good for large projects</li>
        </ul>
        <br/>
        <li>Installation:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm install -g pyright
</code></pre>

    <br/>
    <ul><li>Run pyright:</li></ul>

<pre><code class="language-bash line-numbers">pyright
</code></pre>

    <br/>
    <ul><li>Configuration (<code>pyrightconfig.json</code>):</li></ul>

<pre><code class="language-json line-numbers">{
  "include": ["src"],
  "strict": true
}
</code></pre>

    <br/><br/>



    <li><b>ruff</b></li>
    <br/>
    <ul>
        <li><code>ruff</code> is an ultra-fast linter written in Rust.</li>
        <br/>
        <li>It is not a full type checker, but supports:</li>
        <ul>
            <li>lightweight type-checking rules</li>
            <li>unused code analysis</li>
            <li>import sorting</li>
            <li>formatting</li>
        </ul>
        <br/>
        <li>Installation:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install ruff
</code></pre>

    <br/>
    <ul><li>Run:</li></ul>

<pre><code class="language-bash line-numbers">ruff check .
</code></pre>

    <br/>
    <ul><li>Enable type-checking rules:</li></ul>

<pre><code class="language-toml line-numbers">[tool.ruff]
select = ["E", "F", "I", "TCH"]
</code></pre>

    <br/><br/>



    <li><b>Comparison Table</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>mypy</th>
                <th>pyright</th>
                <th>ruff</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Checking depth</td>
                <td>Very deep</td>
                <td>Very deep</td>
                <td>Shallow</td>
            </tr>
            <tr>
                <td>Speed</td>
                <td>Medium</td>
                <td>Very fast</td>
                <td>Extremely fast</td>
            </tr>
            <tr>
                <td>Best use case</td>
                <td>Strict typing, CI validation</td>
                <td>Daily development, IDE</td>
                <td>Linting + basic type checks</td>
            </tr>
            <tr>
                <td>Protocol support</td>
                <td>Excellent</td>
                <td>Excellent</td>
                <td>Minimal</td>
            </tr>
            <tr>
                <td>TypedDict analysis</td>
                <td>Strong</td>
                <td>Strong</td>
                <td>Partial</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>mypy</code></td>
                <td>Classic strict type checker with full feature support</td>
            </tr>
            <tr>
                <td><code>pyright</code></td>
                <td>Fast, modern, editor-focused type checker</td>
            </tr>
            <tr>
                <td><code>ruff</code></td>
                <td>Ultra-fast linter with optional lightweight type warnings</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-special-function-parameters">Special Parameters in Python Functions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python function definitions support several <b>special parameter forms</b> that control how arguments can be passed.</li>
        <br/>
        <li>These special markers allow you to restrict, organize, or structure function parameters:</li>
        <ul>
            <li><code>/</code> ‚Äî positional-only parameters</li>
            <li><code>*</code> ‚Äî keyword-only parameters</li>
            <li><code>*args</code> ‚Äî variable positional arguments</li>
            <li><code>**kwargs</code> ‚Äî variable keyword arguments</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Positional-Only Parameters (<code>/</code>)</b></li>
    <br/>
    <ul>
        <li>A parameter placed before <code>/</code> can <b>ONLY</b> be passed positionally (Python 3.8+).</li>
        <br/>
        <li>Motivation:</li>
        <ul>
            <li>prevent callers from depending on parameter names</li>
            <li>make APIs easier to change later</li>
            <li>match CPython built-ins like <code>len(obj)</code></li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b, /):
    return a + b

add(3, 4)        # OK
add(a=3, b=4)    # ‚ùå error: cannot use keyword args
</code></pre>

    <br/>
    <ul><li>Everything before <code>/</code> must be passed positionally.</li></ul>

    <br/><br/>



    <li><b>Keyword-Only Parameters (<code>*</code>)</b></li>
    <br/>
    <ul>
        <li>Parameters placed after <code>*</code> must be passed by keyword.</li>
    </ul>

<pre><code class="language-python line-numbers">def configure(*, debug=False, verbose=False):
    print(debug, verbose)

configure(debug=True)     # OK
configure(True, True)     # ‚ùå error
</code></pre>

    <br/>
    <ul><li>Everything after <code>*</code> must be named explicitly.</li></ul>

    <br/><br/>



    <li><b>Combining Positional-Only and Keyword-Only</b></li>
    <br/>

<pre><code class="language-python line-numbers">def func(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>

    <ul>
        <li><b>Rules:</b></li>
        <ul>
            <li><code>a</code>, <code>b</code> ‚Üí positional-only</li>
            <li><code>c</code>, <code>d</code> ‚Üí can be positional or keyword</li>
            <li><code>e</code>, <code>f</code> ‚Üí keyword-only</li>
        </ul>
    </ul>

    <br/><br/>



    <li><b>Variable Positional Arguments (<code>*args</code>)</b></li>
    <br/>
    <ul>
        <li><code>*args</code> captures an arbitrary number of positional arguments into a tuple.</li>
        <br/>
        <li>Use when your function accepts a flexible amount of inputs.</li>
    </ul>

<pre><code class="language-python line-numbers">def total(*numbers):
    print(numbers)

total(1, 2, 3)      # (1, 2, 3)
total()             # ()
</code></pre>

    <br/><br/>



    <li><b>Variable Keyword Arguments (<code>**kwargs</code>)</b></li>
    <br/>
    <ul>
        <li><code>**kwargs</code> collects keyword arguments into a dictionary.</li>
        <br/>
        <li>This is useful for flexible configuration or passing options through layers of functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(**options):
    print(options)

debug(level=3, verbose=True)
# {'level': 3, 'verbose': True}
</code></pre>

    <br/><br/>



    <li><b>Using <code>*args</code> and <code>**kwargs</code> Together</b></li>
    <br/>

<pre><code class="language-python line-numbers">def func(a, *args, **kwargs):
    print(a, args, kwargs)

func(1, 2, 3, x=10, y=20)
</code></pre>

    <br/>
    <ul>
        <li>Produces:</li>
    </ul>

<pre><code class="language-python">1 (2, 3) {'x': 10, 'y': 20}
</code></pre>

    <br/><br/>



    <li><b>Enforcing Only <code>**kwargs</code> Arguments</b></li>
    <br/>
    <ul>
        <li>A common pattern in APIs is to force callers to use keywords:</li>
    </ul>

<pre><code class="language-python line-numbers">def build_model(*, layers, activation):
    ...
</code></pre>

    <br/>
    <ul>
        <li>Prevents:</li>
    </ul>

<pre><code class="language-python">build_model(3, "relu")   # ‚ùå
</code></pre>

    <br/><br/>



    <li><b>Using <code>/</code> with <code>*args</code> and <code>**kwargs</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">def f(a, b, /, c, *args, d, e=0, **kwargs):
    print(a, b, c, args, d, e, kwargs)
</code></pre>

    <br/>
    <ul>
        <li>This allows extremely precise function signatures.</li>
    </ul>

    <br/><br/>



    <li><b>Real Example: Built-in <code>pow</code></b></li>
    <br/>
    <ul>
        <li>Python built-in functions often use positional-only parameters:</li>
    </ul>

<pre><code class="language-python line-numbers">pow(base, exp, mod=None, /)
</code></pre>

    <br/>
    <ul>
        <li>Meaning:</li>
        <ul>
            <li><code>base</code>, <code>exp</code>, <code>mod</code> must be positional</li>
            <li>Cannot call: <code>pow(base=2, exp=3)</code></li>
        </ul>
    </ul>

    <br/><br/>



    <li><b>Common Uses in Real Codebases</b></li>
    <br/>
    <ul>
        <li><b>Library APIs</b> (Positional-only)</li>
        <ul><li>Protects parameter names from becoming part of public API.</li></ul>
        <br/>
        <li><b>Configuration functions</b> (Keyword-only)</li>
        <ul><li>Force clarity: <code>send(email, *, retries=3, timeout=1000)</code></li></ul>
        <br/>
        <li><b>Decorators</b> (args + kwargs)</li>
        <ul><li>Capture any function signatures flexibly.</li></ul>
        <br/>
        <li><b>Wrappers & Forwarding</b></li>
        <ul><li>Useful when passing options through layers of functions.</li></ul>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Syntax</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>/</code></td>
                <td>Positional-only parameters</td>
            </tr>
            <tr>
                <td><code>*</code></td>
                <td>Keyword-only parameters</td>
            </tr>
            <tr>
                <td><code>*args</code></td>
                <td>Captures extra positional arguments</td>
            </tr>
            <tr>
                <td><code>**kwargs</code></td>
                <td>Captures extra keyword arguments</td>
            </tr>
            <tr>
                <td><code>*args, **kwargs</code></td>
                <td>Flexible wrappers for arbitrary signatures</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-range">Python <code>range</code></h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>range</code> is a built-in Python type used to generate arithmetic sequences of integers.</li>
        <br/>
        <li>It is commonly used in loops, iterations, indexing, and algorithmic logic.</li>
        <br/>
        <li><code>range</code> objects are:</li>
        <ul>
            <li><b>immutable</b></li>
            <li><b>lazy</b> (values are produced on demand)</li>
            <li><b>memory efficient</b> even for large sequences</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Basic Forms of <code>range</code></b></li>
    <br/>
    <ul>
        <li><code>range(stop)</code></li>
        <li><code>range(start, stop)</code></li>
        <li><code>range(start, stop, step)</code></li>
    </ul>

<pre><code class="language-python line-numbers">range(5)            # 0, 1, 2, 3, 4
range(2, 7)         # 2, 3, 4, 5, 6
range(1, 10, 2)     # 1, 3, 5, 7, 9
</code></pre>

    <br/><br/>



    <li><b>Range Objects Don‚Äôt Produce Lists</b></li>
    <br/>
    <ul>
        <li><code>range</code> itself does not store all values.</li>
        <li>To see the actual numbers, convert it:</li>
    </ul>

<pre><code class="language-python line-numbers">list(range(5))
# [0, 1, 2, 3, 4]
</code></pre>

    <br/><br/>



    <li><b>Default Behavior</b></li>
    <br/>
    <ul>
        <li><b>start</b> defaults to 0</li>
        <li><b>step</b> defaults to +1</li>
        <li>The <code>stop</code> value is <b>exclusive</b></li>
    </ul>

<pre><code class="language-python line-numbers">range(4)     # 0, 1, 2, 3  (never reaches 4)
</code></pre>

    <br/><br/>



    <li><b>Using <code>range</code> in Loops</b></li>
    <br/>

<pre><code class="language-python line-numbers">for i in range(3):
    print(i)
</code></pre>
    <ul><li>Output:</li></ul>

<pre><code class="language-python">0
1
2
</code></pre>

    <br/><br/>



    <li><b>Using <code>range</code> with <code>start</code> and <code>stop</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">for i in range(5, 10):
    print(i)
</code></pre>

    <br/><br/>



    <li><b>Using <code>step</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">range(0, 10, 2)   # even numbers: 0,2,4,6,8
range(1, 10, 2)   # odd numbers: 1,3,5,7,9
</code></pre>

    <br/><br/>



    <li><b>Negative Step (Counting Backward)</b></li>
    <br/>

<pre><code class="language-python line-numbers">range(10, 0, -1)     # 10, 9, 8, ..., 1
range(5, -6, -2)     # 5, 3, 1, -1, -3, -5
</code></pre>

    <br/>
    <ul>
        <li>When using a negative step, <code>stop</code> must be <b>less than</b> <code>start</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Ranges with Zero or Invalid Steps</b></li>
    <br/>

<pre><code class="language-python line-numbers">range(0, 10, 0)    # ‚ùå error: step cannot be zero
</code></pre>

    <ul><li>Step must be non-zero ‚Äî either positive or negative.</li></ul>

    <br/><br/>



    <li><b>Range is Lazy and Efficient</b></li>
    <br/>
    <ul>
        <li><code>range(1_000_000_000)</code> uses the same memory as <code>range(5)</code>.</li>
        <li>No list of numbers is stored ‚Äî values are computed when needed.</li>
    </ul>

<pre><code class="language-python line-numbers">r = range(1_000_000_000)
print(len(r))      # works instantly!
</code></pre>

    <br/><br/>



    <li><b>Membership Testing (<code>in</code>)</b></li>
    <br/>
    <ul>
        <li><code>range</code> supports fast membership tests:</li>
    </ul>

<pre><code class="language-python line-numbers">5 in range(10)         # True
9 in range(1, 10, 2)   # False
</code></pre>

    <ul>
        <li>It does this mathematically, without iterating.</li>
    </ul>

    <br/><br/>



    <li><b>Indexing and Slicing</b></li>
    <br/>
    <ul>
        <li>Range objects support indexing:</li>
    </ul>

<pre><code class="language-python line-numbers">r = range(10, 20)
print(r[0])    # 10
print(r[5])    # 15
print(r[-1])   # 19
</code></pre>

    <br/>
    <ul><li>Ranges can also be sliced, resulting in another <code>range</code>:</li></ul>

<pre><code class="language-python line-numbers">r = range(0, 20, 2)  # 0,2,4,...18
print(r[2:6])         # range(4, 12, 2)
</code></pre>

    <br/><br/>



    <li><b>Common Patterns with <code>range</code></b></li>
    <br/>
    <ul>
        <li><b>Looping N times</b></li>
    </ul>

<pre><code class="language-python line-numbers">for _ in range(3):
    print("hi")
</code></pre>

    <br/>

    <ul><li><b>Indexing lists</b></li></ul>

<pre><code class="language-python line-numbers">names = ["Anna", "Ben", "Carl"]
for i in range(len(names)):
    print(i, names[i])
</code></pre>

    <br/>

    <ul><li><b>Reversed loops</b></li></ul>

<pre><code class="language-python line-numbers">for i in range(10, -1, -1):
    print(i)
</code></pre>

    <br/>

    <ul><li><b>Generating arithmetic sequences</b></li></ul>

<pre><code class="language-python line-numbers">evens = list(range(0, 21, 2))
</code></pre>

    <br/><br/>



    <li><b>Comparison of List vs Range</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>list(range)</th>
                <th>range</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Memory usage</td>
                <td>Large (stores all values)</td>
                <td>Tiny (three integers only)</td>
            </tr>
            <tr>
                <td>Speed of iteration</td>
                <td>Fast</td>
                <td>Fast</td>
            </tr>
            <tr>
                <td>Supports slicing</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Supports membership test</td>
                <td>Linear search</td>
                <td>Constant-time math</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lazy</td>
                <td>No list stored; values computed when needed</td>
            </tr>
            <tr>
                <td>Efficient</td>
                <td>Constant memory usage</td>
            </tr>
            <tr>
                <td>Exclusive stop</td>
                <td>Sequence stops before the stop value</td>
            </tr>
            <tr>
                <td>Step</td>
                <td>Can count upward or downward</td>
            </tr>
            <tr>
                <td>Supports slicing</td>
                <td>Slicing returns a new range</td>
            </tr>
            <tr>
                <td>Constant-time membership</td>
                <td>Efficient mathematical check</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-lambda">Python Lambda Expressions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>lambda</code> expression in Python creates a small, anonymous function.</li>
        <br/>
        <li>Lambdas are useful when you need a short function for a brief moment and do not want to define a full <code>def</code> block.</li>
        <br/>
        <li>However, they are intentionally limited: a lambda can contain only <b>one expression</b> (no statements).</li>
    </ul>
    <br/><br/>



    <li><b>Basic Syntax</b></li>
    <br/>

<pre><code class="language-python line-numbers">lambda arguments: expression
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-python line-numbers">add = lambda a, b: a + b
print(add(3, 4))   # 7
</code></pre>

    <br/>
    <ul>
        <li>This is equivalent to:</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    return a + b
</code></pre>

    <br/><br/>



    <li><b>Single Expression Only</b></li>
    <br/>
    <ul>
        <li>The body must be a single expression ‚Äî not statements, loops, assignments, or annotations.</li>
    </ul>

<pre><code class="language-python line-numbers">lambda x: x * 2           # OK
lambda x: print(x)        # OK (print is an expression here)

lambda x: y = x + 1       # ‚ùå error (assignment is not allowed)
lambda x: for i in ...    # ‚ùå cannot contain loops
</code></pre>

    <br/><br/>



    <li><b>Zero-Argument Lambdas</b></li>
    <br/>

<pre><code class="language-python line-numbers">noop = lambda: None
noop()
</code></pre>

    <br/><br/>



    <li><b>Lambdas with Default Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">f = lambda x=10, y=20: x + y
print(f())       # 30
print(f(5))      # 25
</code></pre>

    <br/><br/>



    <li><b>Lambdas Returning Other Lambdas</b></li>
    <br/>

<pre><code class="language-python line-numbers">make_multiplier = lambda n: (lambda x: x * n)
times3 = make_multiplier(3)
print(times3(10))   # 30
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>sorted()</code></b></li>
    <br/>
    <ul>
        <li>A common use case is providing a custom sorting key.</li>
    </ul>

<pre><code class="language-python line-numbers">names = ["alice", "Bob", "carol"]
sorted_names = sorted(names, key=lambda s: s.lower())
print(sorted_names)
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>map()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [1, 2, 3]
doubled = list(map(lambda n: n * 2, nums))
print(doubled)   # [2, 4, 6]
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>filter()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [1, 2, 3, 4, 5]
evens = list(filter(lambda n: n % 2 == 0, nums))
print(evens)     # [2, 4]
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>reduce()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">from functools import reduce

nums = [1, 2, 3, 4]
total = reduce(lambda a, b: a + b, nums)
print(total)     # 10
</code></pre>

    <br/><br/>



    <li><b>Lambdas in Dictionary Structures</b></li>
    <br/>
    <ul>
        <li>Useful for defining small callback tables or dispatch maps:</li>
    </ul>

<pre><code class="language-python line-numbers">actions = {
    "square": lambda x: x * x,
    "cube": lambda x: x * x * x,
}

print(actions)   # 27
</code></pre>

    <br/><br/>



    <li><b>Using Lambdas in UI / Callback Code</b></li>
    <br/>

<pre><code class="language-python line-numbers">def on_click(callback):
    callback()

on_click(lambda: print("Clicked!"))
</code></pre>

    <br/><br/>



    <li><b>Using Lambdas with Closures</b></li>
    <br/>
    <ul><li>Lambdas capture variables from the surrounding scope.</li></ul>

<pre><code class="language-python line-numbers">def make_add(n):
    return lambda x: x + n

add5 = make_add(5)
print(add5(10))   # 15
</code></pre>

    <br/><br/>


    <li><b>Lambdas vs Named Functions</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>lambda</th>
                <th>def function</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Has a name?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Multiple statements?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Main usage</td>
                <td>Short, throwaway functions</td>
                <td>Larger or reusable logic</td>
            </tr>
            <tr>
                <td>Debug readability</td>
                <td>Poor</td>
                <td>Good</td>
            </tr>
            <tr>
                <td>Syntax</td>
                <td>Single expression</td>
                <td>Block with <code>return</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Anonymous</td>
                <td><code>lambda</code> defines short unnamed functions</td>
            </tr>
            <tr>
                <td>Single expression</td>
                <td>No blocks, no loops, no assignments</td>
            </tr>
            <tr>
                <td>Common uses</td>
                <td><code>sorted</code>, <code>map</code>, <code>filter</code>, callbacks</td>
            </tr>
            <tr>
                <td>Readability</td>
                <td>Good for small tasks, bad for complex logic</td>
            </tr>
            <tr>
                <td>Alternatives</td>
                <td>Use <code>def</code> for named, clearer functions</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-docstrings">Python Documentation Strings (Docstrings)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>docstring</b> in Python is a string literal placed at the beginning of a module, class, method, or function.</li>
        <br/>
        <li>Docstrings provide built-in documentation and can be retrieved programmatically using <code>help()</code>, <code>.__doc__</code>, and tooling such as IDEs and Sphinx.</li>
        <br/>
        <li>Docstrings are intended for humans, but are stored and accessible at runtime.</li>
        <br/>
        <li>The standard format is a triple-quoted string:</li>
    </ul>

<pre><code class="language-python line-numbers">"""This is a docstring."""</code></pre>

    <br/><br/>



    <li><b>Where Docstrings Can Be Placed</b></li>
    <br/>
    <ul>
        <li>Module-level</li>
        <li>Class-level</li>
        <li>Function / Method-level</li>
    </ul>

<pre><code class="language-python line-numbers">"""
This module handles user authentication logic.
"""


def login(user, password):
    """Authenticate a user by password."""
    ...
</code></pre>

    <br/><br/>



    <li><b>Accessing Docstrings</b></li>
    <br/>

<pre><code class="language-python line-numbers">print(login.__doc__)
help(login)
</code></pre>

    <br/>
    <ul>
        <li><code>help()</code> uses docstrings to display formatted documentation.</li>
    </ul>

    <br/><br/>



    <li><b>One-Line Docstrings</b></li>
    <br/>
    <ul>
        <li>Used for simple, self-explanatory functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    """Return the sum of a and b."""
    return a + b
</code></pre>

    <br/><br/>



    <li><b>Multi-Line Docstrings</b></li>
    <br/>
    <ul>
        <li>Follow PEP 257 conventions:</li>
        <ul>
            <li>First line: short summary</li>
            <li>Blank line</li>
            <li>Detailed explanation (optional)</li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">def connect(url, timeout=10):
    """
    Connect to a remote server.

    This function establishes a TCP connection to the given URL.
    The connection will fail if the timeout is exceeded.
    """
    ...
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Classes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User:
    """
    Represents a system user with username and email.
    """

    def __init__(self, username, email):
        """Initialize a new User object."""
        self.username = username
        self.email = email
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Methods</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Circle:
    """Circle with radius and area calculation."""

    def area(self):
        """Return the area of the circle."""
        import math
        return math.pi * self.r * self.r
</code></pre>

    <br/><br/>



    <li><b>Documenting Parameters</b></li>
    <br/>
    <ul>
        <li>Python has no official format, but common standards are:</li>
        <ul>
            <li>Google style</li>
            <li>NumPy style</li>
            <li>reStructuredText / Sphinx style</li>
        </ul>
    </ul>

    <br/><br/>


    <li><b>Google Style Example</b></li>

<pre><code class="language-python line-numbers">def add(a, b):
    """
    Add two numbers.

    Args:
        a (int): First number.
        b (int): Second number.

    Returns:
        int: Sum of a and b.
    """
    return a + b
</code></pre>

    <br/><br/>



    <li><b>NumPy Style</b></li>
    <br/>

<pre><code class="language-python line-numbers">def scale(values, factor):
    """
    Scale an array by a factor.

    Parameters
    ----------
    values : list[int]
        Sequence of numbers.
    factor : int or float
        Multiplier.

    Returns
    -------
    list[int]
        Scaled numbers.
    """
    return [v * factor for v in values]
</code></pre>

    <br/><br/>



    <li><b>Sphinx / reStructuredText (RST) Style</b></li>
    <br/>

<pre><code class="language-python line-numbers">def greet(name):
    """
    Greet a user.

    :param name: User's name.
    :type name: str
    :return: Greeting message.
    :rtype: str
    """
    return f"Hello, {name}!"
</code></pre>

    <br/><br/>



    <li><b>Documenting Return Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">def compute(x):
    """
    Compute something useful.

    Returns:
        float: The computed value.
    """
    return x * 2.5
</code></pre>

    <br/><br/>



    <li><b>Documenting Exceptions</b></li>
    <br/>

<pre><code class="language-python line-numbers">def read_file(path):
    """
    Read a file.

    Args:
        path (str): File path.

    Raises:
        FileNotFoundError: If the file does not exist.
    """
    with open(path) as f:
        return f.read()
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Modules</b></li>
    <br/>

<pre><code class="language-python line-numbers">"""
utility.py - helper functions for math and statistics.
"""
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Packages</b></li>
    <br/>
    <ul><li>Place a docstring inside <code>__init__.py</code>:</li></ul>

<pre><code class="language-python line-numbers">"""
This package contains utilities for data analysis.
"""
</code></pre>

    <br/><br/>



    <li><b>Automated Tools That Use Docstrings</b></li>
    <br/>
    <ul>
        <li><code>help()</code> ‚Äî built-in interactive documentation</li>
        <li>IDEs (VSCode, PyCharm, etc.) show docstring hints</li>
        <li><code>pydoc</code> ‚Äî documentation generator</li>
        <li>Sphinx ‚Äî advanced documentation tool</li>
        <li>Type checkers use docstrings for descriptions but not for typing</li>
    </ul>

    <br/><br/>



    <li><b>PEP 257 Docstring Conventions</b></li>
    <br/>
    <ul>
        <li>Triple quotes should be used.</li>
        <li>First line should be a short summary.</li>
        <li>Add a blank line before detailed descriptions.</li>
        <li>Use consistent indentation.</li>
        <li>Closing quotes should be on their own line if multi-line.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Definition</td>
                <td>String literal used to document modules, classes, and functions</td>
            </tr>
            <tr>
                <td>Supported By</td>
                <td>help(), IDEs, Sphinx, pydoc</td>
            </tr>
            <tr>
                <td>Styles</td>
                <td>Google, NumPy, Sphinx/RST</td>
            </tr>
            <tr>
                <td>Retrieval</td>
                <td><code>object.__doc__</code> or <code>help()</code></td>
            </tr>
            <tr>
                <td>Purpose</td>
                <td>Provide human-readable API documentation</td>
            </tr>
            <tr>
                <td>Best Practices</td>
                <td>Short summary + details, parameter docs, return/exception docs</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-function-annotations">Python Function Annotations</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><b>Function annotations</b> allow you to attach arbitrary metadata to function parameters and return values.</li>
        <br/>
        <li>They were introduced in PEP 3107 and are most commonly used for <b>type hints</b> in modern Python.</li>
        <br/>
        <li>Annotations do not enforce types at runtime. They are:</li>
        <ul>
            <li>for humans</li>
            <li>for tooling (mypy, pyright, IDEs)</li>
            <li>accessible at runtime via <code>.__annotations__</code></li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Basic Syntax</b></li>
    <br/>

<pre><code class="language-python line-numbers">def add(a: int, b: int) -> int:
    return a + b
</code></pre>

    <br/>
    <ul>
        <li>The <code>a: int</code> and <code>b: int</code> parts are <b>parameter annotations</b>.</li>
        <li>The <code>-> int</code> after the parentheses is the <b>return annotation</b>.</li>
    </ul>
    <br/><br/>



    <li><b>Accessing Annotations at Runtime</b></li>
    <br/>

<pre><code class="language-python line-numbers">print(add.__annotations__)
</code></pre>

<pre><code class="language-python">{
    'a': int,
    'b': int,
    'return': int
}
</code></pre>

    <br/><br/>



    <li><b>Annotations Are Not Enforced</b></li>
    <br/>
    <ul>
        <li>Python does not check annotated types automatically.</li>
    </ul>

<pre><code class="language-python line-numbers">add("hello", "world")   # Works (but might not be meaningful)
</code></pre>

    <br/>
    <ul>
        <li>Type checking is done by external tools such as mypy or pyright.</li>
    </ul>

    <br/><br/>



    <li><b>Annotating Optional and Default Arguments</b></li>
    <br/>

<pre><code class="language-python line-numbers">def greet(name: str = "World") -> str:
    return f"Hello, {name}!"
</code></pre>

    <br/>
    <ul>
        <li>Annotations and default values coexist naturally.</li>
    </ul>

    <br/><br/>



    <li><b>Annotating *args and **kwargs</b></li>
    <br/>

<pre><code class="language-python line-numbers">def func(*args: int, **kwargs: str) -> None:
    pass
</code></pre>

    <br/>
    <ul>
        <li>This means: each positional arg should be <code>int</code>, each keyword arg should be <code>str</code>.</li>
        <li>However, Python does not enforce this automatically.</li>
    </ul>

    <br/><br/>



    <li><b>Forward References</b></li>
    <br/>
    <ul>
        <li>Sometimes you must reference a type that has not been defined yet (e.g., class below).</li>
        <li>Use a string literal for the annotation:</li>
    </ul>

<pre><code class="language-python line-numbers">def parse(user: "User") -> "Result":
    ...
</code></pre>

    <br/>
    <ul>
        <li>PEP 563 allows delayed evaluation; Python 3.11+ enables it by default using <code>from __future__ import annotations</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Using Annotations Beyond Types</b></li>
    <br/>
    <ul>
        <li>Annotations can hold <b>any Python object</b>: values, classes, custom markers.</li>
    </ul>

<pre><code class="language-python line-numbers">def process(x: "database_id", y: list) -> "status":
    pass
</code></pre>

    <br/>
    <ul>
        <li>Frameworks sometimes overload annotations for validation or routing (e.g. FastAPI).</li>
    </ul>

    <br/><br/>



    <li><b>Annotating Collections</b></li>
    <br/>
    <ul>
        <li>Use <code>list[int]</code>, <code>dict[str, int]</code>, etc. in Python 3.9+</li>
    </ul>

<pre><code class="language-python line-numbers">def average(nums: list[float]) -> float:
    return sum(nums) / len(nums)
</code></pre>

    <br/><br/>



    <li><b>Union Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">def load(config: str | None) -> str:
    return config or "default"
</code></pre>

    <br/>
    <ul>
        <li><code>|</code> is preferred over <code>typing.Union</code> since Python 3.10.</li>
    </ul>

    <br/><br/>



    <li><b>Callable Annotations</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Callable

def apply(f: Callable[[int, int], int], x: int, y: int) -> int:
    return f(x, y)
</code></pre>

    <br/><br/>



    <li><b>Using <code>Annotated</code> for Metadata</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Annotated

def scale(x: Annotated[int, "positive"]) -> int:
    return x
</code></pre>

    <br/>
    <ul>
        <li>Allows attaching hints beyond type information.</li>
    </ul>

    <br/><br/>



    <li><b>Return Type of <code>None</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">def log(msg: str) -> None:
    print(msg)
</code></pre>

    <br/><br/>



    <li><b>Typical Misunderstandings</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Misunderstanding</th>
                <th>Explanation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>"Annotations enforce types"</td>
                <td>They do not ‚Äî Python ignores them at runtime unless tools check them.</td>
            </tr>
            <tr>
                <td>"Annotations must be types"</td>
                <td>No ‚Äî any object is allowed.</td>
            </tr>
            <tr>
                <td>"Annotations slow down code"</td>
                <td>No ‚Äî they are just stored metadata.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Syntax</td>
                <td><code>param: type</code> and <code>-> return_type</code></td>
            </tr>
            <tr>
                <td>Runtime access</td>
                <td><code>func.__annotations__</code></td>
            </tr>
            <tr>
                <td>Enforcement</td>
                <td>None by Python itself</td>
            </tr>
            <tr>
                <td>Purpose</td>
                <td>Documentation, type checking, IDE support</td>
            </tr>
            <tr>
                <td>Advanced tools</td>
                <td>mypy, pyright, runtime frameworks</td>
            </tr>
            <tr>
                <td>Supported types</td>
                <td>Any object ‚Äî not just types</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-tuples-sequences">Python Tuples and Sequences</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python provides several built-in <b>sequence types</b>: <code>list</code>, <code>tuple</code>, <code>range</code>, <code>str</code>, as well as specialized ones like <code>bytes</code> and <code>bytearray</code>.</li>
        <br/>
        <li>A <b>sequence</b> is an ordered collection of items with indexing, slicing, iteration, and length operations.</li>
        <br/>
        <li>This chapter focuses mainly on <b>tuples</b> but also covers general sequence behavior shared across all sequence types.</li>
    </ul>
    <br/><br/>



    <li><b>What Is a Tuple?</b></li>
    <br/>
    <ul>
        <li>A <b>tuple</b> is an <b>immutable</b> ordered collection of items.</li>
        <li>You cannot modify, add, or remove items once created.</li>
        <li>They are often used to represent fixed-size records or return multiple values from functions.</li>
    </ul>

<pre><code class="language-python line-numbers">t = (1, 2, 3)
</code></pre>

    <br/><br/>



    <li><b>Creating Tuples</b></li>
    <br/>

<pre><code class="language-python line-numbers"># Parentheses (typical)
t1 = (1, 2, 3)

# Without parentheses (tuple packing)
t2 = 4, 5, 6

# Empty tuple
t3 = ()

# Single-element tuple (comma is required!)
single = (42,)
</code></pre>

    <br/>
    <ul>
        <li>Python automatically creates tuples when using comma-separated values. Parentheses are optional but encouraged for clarity.</li>
    </ul>

    <br/><br/>



    <li><b>Tuple Indexing and Slicing</b></li>
    <br/>

<pre><code class="language-python line-numbers">t = (10, 20, 30, 40)

print(t[0])   # 10
print(t[-1])  # 40

print(t[1:3]) # (20, 30)
</code></pre>

    <br/><br/>



    <li><b>Immutability</b></li>
    <br/>
    <ul>
        <li>You cannot change tuple elements after creation:</li>
    </ul>

<pre><code class="language-python line-numbers">t = (1, 2, 3)
t[1] = 99     # ‚ùå TypeError
</code></pre>

    <br/>
    <ul>
        <li>But tuples can contain mutable objects, which <i>can</i> be changed inside:</li>
    </ul>

<pre><code class="language-python line-numbers">t = ([1, 2], 3)
t[0].append(99)
print(t)      # ([1, 2, 99], 3)
</code></pre>

    <br/><br/>



    <li><b>Tuple Unpacking</b></li>
    <br/>

<pre><code class="language-python line-numbers">x, y, z = (10, 20, 30)

print(x)  # 10
print(y)  # 20
print(z)  # 30
</code></pre>

    <br/><br/>



    <li><b>Extended Unpacking (PEP 3132)</b></li>
    <br/>

<pre><code class="language-python line-numbers">a, *b = (1, 2, 3, 4)
print(a)  # 1
print(b)  # [2, 3, 4]

*a, b = (1, 2, 3, 4)
print(a)  # [1, 2, 3]
print(b)  # 4
</code></pre>

    <br/><br/>



    <li><b>Tuples as Return Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">def stats():
    return (10, 20, 30)

x, y, z = stats()
</code></pre>

    <br/>
    <ul>
        <li>Functions frequently return multiple values using tuples.</li>
    </ul>

    <br/><br/>



    <li><b>Why Use Tuples Instead of Lists?</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Reason</th>
                <th>Explanation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Immutability</td>
                <td>Protects data from accidental changes</td>
            </tr>
            <tr>
                <td>Hashability</td>
                <td>Tuples can be used as dict keys (if elements are hashable)</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Slightly faster and smaller than lists</td>
            </tr>
            <tr>
                <td>Semantic meaning</td>
                <td>Represents a fixed structure, like a row or coordinate</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Tuple Methods</b></li>
    <br/>
    <ul>
        <li>Only two built-in methods:</li>
    </ul>

<pre><code class="language-python line-numbers">t.count(value)
t.index(value)
</code></pre>

    <br/><br/>



    <li><b>Nested and Structured Tuples</b></li>
    <br/>
    <ul>
        <li>Useful for representing structured information.</li>
    </ul>

<pre><code class="language-python line-numbers">point = (10, 20)
rect = (point, (30, 40))  # nested
</code></pre>

    <br/><br/>



    <li><b>Sequences: Common Operations</b></li>
    <br/>
    <ul>
        <li>All sequences support:</li>
        <ul>
            <li>Length: <code>len(seq)</code></li>
            <li>Indexing: <code>seq[i]</code></li>
            <li>Slicing: <code>seq[a:b]</code></li>
            <li>Iteration: <code>for x in seq</code></li>
            <li>Membership: <code>x in seq</code></li>
            <li>Concatenation: <code>seq1 + seq2</code></li>
            <li>Repetition: <code>seq * 3</code></li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">seq = (1, 2, 3)
print(len(seq))
print(2 in seq)
print(seq + (4, 5))
print(seq * 2)
</code></pre>

    <br/><br/>



    <li><b>Tuple vs Sequence vs Iterable</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Iterable</td>
                <td>Anything usable in a <code>for</code> loop</td>
            </tr>
            <tr>
                <td>Sequence</td>
                <td>Ordered iterable with indexing and slicing</td>
            </tr>
            <tr>
                <td>Tuple</td>
                <td>An immutable sequence</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Tuple Type Annotations</b></li>
    <br/>

<pre><code class="language-python line-numbers"># fixed size
point: tuple[int, int] = (10, 20)

# variable length
numbers: tuple[int, ...] = (1, 2, 3, 4)
</code></pre>

    <br/><br/>



    <li><b>Common Use Cases of Tuples</b></li>
    <br/>

    <ul>
        <li>Returning multiple values from functions</li>
        <li>Representing records (immutable data)</li>
        <li>Coordinates and geometric data</li>
        <li>Dictionary keys</li>
        <li>Unpacking assignments</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Tuple</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Mutability</td>
                <td>Immutable</td>
            </tr>
            <tr>
                <td>Ordering</td>
                <td>Preserved</td>
            </tr>
            <tr>
                <td>Indexing / slicing</td>
                <td>Supported</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Faster and smaller than lists</td>
            </tr>
            <tr>
                <td>Common use</td>
                <td>Fixed-size structures, multiple return values</td>
            </tr>
            <tr>
                <td>Hashable?</td>
                <td>Yes, if all elements are hashable</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-del-statement">The <code>del</code> Statement in Python</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>del</code> statement removes bindings between names and objects, or removes items from collections.</li>
        <br/>
        <li>It does <b>not</b> directly delete objects from memory ‚Äî Python deletes the object only when nothing references it anymore (via reference counting + garbage collection).</li>
    </ul>
    <br/><br/>



    <li><b>Deleting Variables (Name Bindings)</b></li>
    <br/>

<pre><code class="language-python line-numbers">x = 10
del x

print(x)   # NameError: name 'x' is not defined
</code></pre>

    <br/>
    <ul>
        <li><code>del x</code> removes the variable <code>x</code> from the current namespace.</li>
    </ul>

    <br/><br/>



    <li><b>Deleting Multiple Names</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = 1
b = 2
c = 3

del a, b, c
</code></pre>

    <br/><br/>



    <li><b>Deleting List Elements</b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [10, 20, 30, 40]
del nums[1]

print(nums)   # [10, 30, 40]
</code></pre>

    <br/>
    <ul>
        <li>This deletes the item at index <code>1</code>, not the whole list.</li>
    </ul>

    <br/><br/>



    <li><b>Deleting List Slices</b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [1, 2, 3, 4, 5]
del nums[1:4]

print(nums)   # [1, 5]
</code></pre>

    <br/>
    <ul>
        <li>Deletes the slice from index 1 to 3 (inclusive start, exclusive end).</li>
    </ul>

    <br/><br/>



    <li><b>Deleting Dictionary Keys</b></li>
    <br/>

<pre><code class="language-python line-numbers">person = {"name": "Ammy", "age": 30}
del person["age"]

print(person)   # {"name": "Ammy"}
</code></pre>

    <br/>
    <ul>
        <li>Deletes the key-value pair.</li>
        <li>If the key does not exist, a <code>KeyError</code> occurs.</li>
    </ul>

    <br/><br/>



    <li><b>Deleting Attributes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User:
    def __init__(self):
        self.name = "Ammy"
        self.age = 20

u = User()
del u.age

print(u.age)   # AttributeError
</code></pre>

    <br/>
    <ul>
        <li>Removes the attribute binding from the instance.</li>
    </ul>

    <br/><br/>



    <li><b>Deleting Items in Nested Structures</b></li>
    <br/>

<pre><code class="language-python line-numbers">data = {"users": ["alice", "bob", "carol"]}
del data["users"][1]

print(data)   # {"users": ["alice", "carol"]}
</code></pre>

    <br/><br/>



    <li><b>Using <code>del</code> to Reduce Memory Pressure</b></li>
    <br/>
    <ul>
        <li>Large objects can be deleted early so memory is freed sooner.</li>
    </ul>

<pre><code class="language-python line-numbers">import pandas as pd

df = pd.read_csv("big.csv")
# ... process ...

del df   # allow Python to free memory sooner
</code></pre>

    <br/><br/>



    <li><b><code>del</code> Does Not Force Immediate Garbage Collection</b></li>
    <br/>
    <ul>
        <li>Python may keep the object alive if other references still point to it:</li>
    </ul>

<pre><code class="language-python line-numbers">x = [1, 2, 3]
y = x
del x

print(y)   # [1, 2, 3] ‚Äî object still exists!
</code></pre>

    <br/><br/>



    <li><b>Using <code>del</code> in Loops</b></li>
    <br/>

<pre><code class="language-python line-numbers">items = [1, 2, 3, 4, 5]

for i in range(len(items)):
    del items[0]

print(items)  # []
</code></pre>

    <br/>
    <ul>
        <li>Removing elements inside loops must be done carefully.</li>
    </ul>

    <br/><br/>



    <li><b><code>del</code> vs <code>pop()</code> vs <code>remove()</code></b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Use Case</th>
                <th>Returns value?</th>
                <th>Errors?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>del seq[i]</code></td>
                <td>Delete by index</td>
                <td>No</td>
                <td>IndexError</td>
            </tr>
            <tr>
                <td><code>seq.pop(i)</code></td>
                <td>Delete by index</td>
                <td>Yes (returns value)</td>
                <td>IndexError</td>
            </tr>
            <tr>
                <td><code>seq.remove(x)</code></td>
                <td>Delete first matching value</td>
                <td>No</td>
                <td>ValueError</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>The <code>__del__()</code> Method (Destructor)</b></li>
    <br/>
    <ul>
        <li>Often confused with the <code>del</code> statement, but completely different.</li>
        <li><code>__del__()</code> is called when an object is about to be garbage-collected.</li>
    </ul>

<pre><code class="language-python line-numbers">class A:
    def __del__(self):
        print("Object destroyed")
</code></pre>

    <br/>
    <ul>
        <li><code>del obj</code> does NOT call <code>__del__()</code> automatically ‚Äî only when the object is garbage-collected.</li>
    </ul>

    <br/><br/>



    <li><b>Common Pitfalls</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Pitfall</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Deleting wrong slice</td>
                <td><code>del seq[a:b]</code> can remove more than intended</td>
            </tr>
            <tr>
                <td>Deleting inside loops</td>
                <td>Can change indices and cause skipped items</td>
            </tr>
            <tr>
                <td>Expecting memory to clear immediately</td>
                <td>Python may retain object until all references are gone</td>
            </tr>
            <tr>
                <td>Confusing <code>del</code> with destruction</td>
                <td><code>del</code> removes names, not objects</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Main Role</td>
                <td>Remove bindings between names and objects</td>
            </tr>
            <tr>
                <td>Can delete</td>
                <td>Variables, list items, dictionary keys, object attributes, slices</td>
            </tr>
            <tr>
                <td>Does not do</td>
                <td>Force garbage collection or memory cleanup</td>
            </tr>
            <tr>
                <td>Namespace effect</td>
                <td>After <code>del</code>, the name is gone</td>
            </tr>
            <tr>
                <td>Memory</td>
                <td>Object disappears only when no references remain</td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-sets">Python Sets</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>set</b> in Python is an unordered collection of <b>unique</b> and <b>hashable</b> elements.</li>
        <br/>
        <li>Sets are ideal when you need:
            <ul>
                <li>to eliminate duplicates</li>
                <li>fast membership checks (<code>x in set</code>)</li>
                <li>mathematical operations (union, intersection, difference)</li>
            </ul>
        </li>
        <br/>
        <li>Two built-in types exist:
            <ul>
                <li><code>set</code> ‚Äî mutable</li>
                <li><code>frozenset</code> ‚Äî immutable and hashable</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Creating Sets</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = {1, 2, 3}
empty = set()      # correct way
</code></pre>

    <br/>
    <ul>
        <li><code>{}</code> creates an empty dictionary ‚Äî not a set!</li>
    </ul>

<pre><code class="language-python line-numbers">not_set = {}   # this is a dict
</code></pre>

    <br/>

<pre><code class="language-python line-numbers"># Using constructor with any iterable
s = set([1, 2, 3, 3])   # duplicates removed
print(s)                # {1, 2, 3}
</code></pre>

    <br/><br/>



    <li><b>Basic Properties</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Property</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>No ordering</td>
                <td>Elements appear in arbitrary order</td>
            </tr>
            <tr>
                <td>No indexing</td>
                <td>You cannot do <code>s[0]</code></td>
            </tr>
            <tr>
                <td>Unique items</td>
                <td>Duplicates are removed automatically</td>
            </tr>
            <tr>
                <td>Fast membership</td>
                <td><code>in</code> runs in constant time on average</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Adding and Removing Elements</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = {1, 2, 3}

s.add(4)         # {1, 2, 3, 4}
s.remove(2)      # {1, 3, 4}
</code></pre>

    <br/>
    <ul>
        <li><code>remove()</code> raises <code>KeyError</code> if the element doesn‚Äôt exist.</li>
    </ul>

<pre><code class="language-python line-numbers">s.discard(10)    # safe: no error
</code></pre>

    <br/>
    <ul>
        <li><code>pop()</code> removes and returns an arbitrary element:</li>
    </ul>

<pre><code class="language-python line-numbers">x = s.pop()
print(x)        # unpredictable which element
</code></pre>

    <br/><br/>



    <li><b>Membership Testing</b></li>
    <br/>
    <ul><li>Membership is extremely fast thanks to hashing:</li></ul>

<pre><code class="language-python line-numbers">if 3 in s:
    print("Found!")
</code></pre>

    <br/><br/>



    <li><b>Eliminating Duplicates from a List</b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [1, 2, 2, 3, 3, 3]
unique = list(set(nums))
</code></pre>

    <br/><br/>



    <li><b>Mathematical Set Operations</b></li>
    <br/>

<pre><code class="language-python line-numbers">A = {1, 2, 3}
B = {3, 4, 5}
</code></pre>

    <br/>

    <ul><li><b>Union</b></li></ul>

<pre><code class="language-python line-numbers">A | B       # {1, 2, 3, 4, 5}
A.union(B)
</code></pre>

    <br/>

    <ul><li><b>Intersection</b></li></ul>

<pre><code class="language-python line-numbers">A &amp; B       # {3}
A.intersection(B)
</code></pre>

    <br/>

    <ul><li><b>Difference</b></li></ul>

<pre><code class="language-python line-numbers">A - B       # {1, 2}
A.difference(B)
</code></pre>

    <br/>

    <ul><li><b>Symmetric Difference</b></li></ul>

<pre><code class="language-python line-numbers">A ^ B       # {1, 2, 4, 5}
A.symmetric_difference(B)
</code></pre>

    <br/>

    <ul><li><b>Subset / Superset</b></li></ul>

<pre><code class="language-python line-numbers">A <= B     # subset?
A.issubset(B)

A >= B     # superset?
A.issuperset(B)
</code></pre>

    <br/><br/>



    <li><b>Mutable vs Immutable Sets</b></li>
    <br/>

<pre><code class="language-python line-numbers">fs = frozenset([1, 2, 3])
</code></pre>

    <br/>

    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Mutable?</th>
                <th>Hashable?</th>
                <th>Usable as dict key?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>set</code></td>
                <td>Yes</td>
                <td>No</td>
                <td>No</td>
            </tr>
            <tr>
                <td><code>frozenset</code></td>
                <td>No</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Iteration Over Sets</b></li>
    <br/>

<pre><code class="language-python line-numbers">for x in {1, 2, 3}:
    print(x)
</code></pre>

    <br/>
    <ul>
        <li>Order is arbitrary; do not rely on it.</li>
    </ul>

    <br/><br/>



    <li><b>Set Comprehensions</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = {x * 2 for x in range(5)}
print(s)     # {0, 2, 4, 6, 8}
</code></pre>

    <br/><br/>



    <li><b>Performance Characteristics</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Average Complexity</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>x in s</code></td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td><code>s.add(x)</code></td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td><code>s.remove(x)</code></td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Union / intersection</td>
                <td>O(n)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Restrictions</b></li>
    <br/>

    <ul>
        <li>All elements must be <b>hashable</b>:</li>
    </ul>

<pre><code class="language-python line-numbers">{[1, 2, 3]}   # ‚ùå TypeError (lists are not hashable)
</code></pre>

    <br/>

<pre><code class="language-python line-numbers">{(1, 2, 3)}   # ‚úî tuples are hashable (if contents are)
</code></pre>

    <br/><br/>



    <li><b>Common Use Cases</b></li>
    <br/>

    <ul>
        <li>Deduplication</li>
        <li>Fast membership checks</li>
        <li>Mathematical set operations</li>
        <li>Tracking visited items</li>
        <li>Removing duplicates while preserving no order</li>
        <li>Checking subset relations in algorithms</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Main characteristics</td>
                <td>Unordered, unique, hashable elements</td>
            </tr>
            <tr>
                <td>Mutable?</td>
                <td><code>set</code>: yes; <code>frozenset</code>: no</td>
            </tr>
            <tr>
                <td>Indexable?</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Fast lookup?</td>
                <td>Yes (O(1))</td>
            </tr>
            <tr>
                <td>Common operations</td>
                <td>Union, intersection, difference, membership</td>
            </tr>
            <tr>
                <td>Use cases</td>
                <td>Deduplication, analysis, membership test, algorithms</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-dictionaries">Python Dictionaries</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>dictionary</b> (or <b>dict</b>) in Python is a mutable, unordered collection of <b>key‚Äìvalue</b> pairs.</li>
        <br/>
        <li>Keys must be <b>unique</b> and <b>hashable</b> (e.g., strings, numbers, tuples of immutables).</li>
        <br/>
        <li>Dictionaries are Python‚Äôs most important data structure for representing structured, associative data.</li>
    </ul>
    <br/><br/>



    <li><b>Creating Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers"># Literal syntax
d = {"name": "Ammy", "age": 30}

# Using dict()
d = dict(name="Ammy", age=30)

# From sequence of pairs
d = dict([("name", "Ammy"), ("age", 30)])

# Empty dictionary
empty = {}
</code></pre>

    <br/><br/>



    <li><b>Dictionary Keys</b></li>
    <br/>
    <ul>
        <li>Keys must be <b>hashable</b> types:</li>
        <ul>
            <li>‚úî str, int, float</li>
            <li>‚úî tuple of hashable elements</li>
            <li>‚ùå list, dict, set (not hashable)</li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">{"a": 1}                # ok
{(1, 2): "point"}       # ok
{[1, 2]: "bad"}         # ‚ùå TypeError
</code></pre>

    <br/><br/>



    <li><b>Accessing and Modifying Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">person = {"name": "Ammy", "age": 30}

print(person["name"])     # "Ammy"

person["age"] = 31        # modify
person["city"] = "Berlin" # add new
</code></pre>

    <br/><br/>



    <li><b>Membership Testing</b></li>
    <br/>
    <ul>
        <li><code>in</code> checks keys, not values:</li>
    </ul>

<pre><code class="language-python line-numbers">"age" in person        # True
"Berlin" in person     # False
</code></pre>

    <br/><br/>



    <li><b>Safe Access with <code>get()</code></b></li>
    <br/>
    <ul>
        <li><code>dict.get()</code> avoids <code>KeyError</code> when the key is missing.</li>
    </ul>

<pre><code class="language-python line-numbers">person.get("age")          # 31
person.get("country")      # None
person.get("country", "?") # "?"
</code></pre>

    <br/><br/>



    <li><b>Removing Items</b></li>
    <br/>

<pre><code class="language-python line-numbers">person.pop("age")          # returns the value
person.pop("missing", "?") # default if key missing

del person["name"]         # raises KeyError if missing

person.clear()             # remove all items
</code></pre>

    <br/><br/>



    <li><b>Dictionary Views: keys(), values(), items()</b></li>
    <br/>

<pre><code class="language-python line-numbers">d = {"a": 1, "b": 2}

d.keys()    # dict_keys(['a', 'b'])
d.values()  # dict_values([1, 2])
d.items()   # dict_items([('a', 1), ('b', 2)])
</code></pre>

    <br/>
    <ul>
        <li>These are ‚Äúviews‚Äù, automatically updating when the dictionary changes.</li>
    </ul>

    <br/><br/>



    <li><b>Iterating Over Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers">for key in d:
    print(key)

for value in d.values():
    print(value)

for key, value in d.items():
    print(key, value)
</code></pre>

    <br/><br/>



    <li><b>Dictionary Comprehensions</b></li>
    <br/>

<pre><code class="language-python line-numbers">squares = {x: x * x for x in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>

    <br/><br/>



    <li><b>Merging Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = {"x": 1, "y": 2}
b = {"y": 3, "z": 4}

c = a | b
# {'x': 1, 'y': 3, 'z': 4}

d = {**a, **b}
</code></pre>

    <br/><br/>



    <li><b>Default Dictionary Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">counts = {}
counts.setdefault("apple", 0)
counts["apple"] += 1
</code></pre>

    <br/>
    <ul>
        <li>Using <code>setdefault()</code> helps initialize missing keys.</li>
    </ul>

    <br/><br/>



    <li><b>Using <code>collections.defaultdict</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">from collections import defaultdict

counts = defaultdict(int)

counts["apple"] += 1
counts["apple"] += 1
</code></pre>

    <br/>
    <ul>
        <li>Provides automatic default values for new keys.</li>
    </ul>

    <br/><br/>



    <li><b>Dictionaries Are Mutable</b></li>
    <br/>

<pre><code class="language-python line-numbers">d = {"a": 1}
e = d
e["a"] = 99

print(d)  # {"a": 99}
</code></pre>

    <br/>
    <ul><li>Assigning a dict does not copy it.</li></ul>

<pre><code class="language-python line-numbers">copy_d = d.copy()        # shallow copy
import copy
deep_d = copy.deepcopy(d)
</code></pre>

    <br/><br/>



    <li><b>Nested Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers">users = {
    "alice": {"age": 20, "active": True},
    "bob":   {"age": 30, "active": False},
}
</code></pre>

    <br/><br/>



    <li><b>Restrictions on Keys</b></li>
    <br/>

    <ul>
        <li>Keys must be:
            <ul>
                <li>immutable</li>
                <li>hashable</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers"># OK
{(1, 2): "point"}

# Error
{[1, 2]: "list"}     # TypeError
</code></pre>

    <br/><br/>



    <li><b>Dictionary Performance Overview</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Average Complexity</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lookup <code>d[k]</code></td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Insert / replace</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Delete</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Iteration</td>
                <td>O(n)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Common Use Cases</b></li>
    <br/>
    <ul>
        <li>Representing structured data</li>
        <li>Counting occurrences (with <code>defaultdict</code>)</li>
        <li>Configuration objects</li>
        <li>JSON-like data storage</li>
        <li>Routing tables, dispatch tables</li>
        <li>Fast lookup tables</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Type</td>
                <td>Mutable mapping of key‚Äìvalue pairs</td>
            </tr>
            <tr>
                <td>Key requirements</td>
                <td>Hashable, unique</td>
            </tr>
            <tr>
                <td>Value requirements</td>
                <td>Anything allowed</td>
            </tr>
            <tr>
                <td>Common operations</td>
                <td>Lookup, insertion, deletion, iteration</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>O(1) average lookup and insert</td>
            </tr>
            <tr>
                <td>Extensions</td>
                <td><code>defaultdict</code>, <code>OrderedDict</code>, <code>Counter</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-modules-intro">Python Modules: Introduction</h3>
<ol>
    <li><b>What Is a Module?</b></li>
    <br/>
    <ul>
        <li>A <b>module</b> in Python is simply a file containing Python code.</li>
        <br/>
        <li>Modules help you organize functions, classes, and variables into logical units.</li>
        <br/>
        <li>Any <code>.py</code> file is a module:
            <ul>
                <li><code>math.py</code></li>
                <li><code>utils.py</code></li>
                <li><code>mymodule.py</code></li>
            </ul>
        </li>
        <br/>
        <li>Modules can:
            <ul>
                <li>define functions</li>
                <li>define classes</li>
                <li>declare variables</li>
                <li>run code when imported (careful!)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Creating Your Own Module</b></li>
    <br/>
    <ul>
        <li>Create a file named <code>greetings.py</code>:</li>
    </ul>

<pre><code class="language-python line-numbers"># greetings.py
def hello(name):
    return f"Hello, {name}!"

PI = 3.14159
</code></pre>

    <br/>
    <ul>
        <li>Then import it into another script:</li>
    </ul>

<pre><code class="language-python line-numbers">import greetings

print(greetings.hello("Ammy"))
print(greetings.PI)
</code></pre>

    <br/><br/>



    <li><b>Importing Modules</b></li>
    <br/>
    <ul>
        <li>Using <code>import module</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">import math
print(math.sqrt(16))
</code></pre>

    <br/>

    <ul>
        <li>Using <code>from module import name</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">from math import sqrt
print(sqrt(25))
</code></pre>

    <br/>

    <ul>
        <li>Importing multiple names:</li>
    </ul>

<pre><code class="language-python line-numbers">from math import sin, cos, pi
</code></pre>

    <br/>

    <ul>
        <li>Importing all names (not recommended):</li>
    </ul>

<pre><code class="language-python line-numbers">from math import *
</code></pre>

    <br/><br/>



    <li><b>Module Aliases</b></li>
    <br/>

<pre><code class="language-python line-numbers">import math as m

print(m.pi)
</code></pre>

    <br/><br/>



    <li><b>Where Python Looks for Modules</b></li>
    <br/>
    <ul>
        <li>Python searches for modules in the following locations:
            <ul>
                <li>The current working directory</li>
                <li>System site-packages</li>
                <li>Virtual environment site-packages</li>
                <li>Directories listed in <code>sys.path</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers">import sys
print(sys.path)
</code></pre>

    <br/><br/>



    <li><b>The <code>__name__</code> Variable</b></li>
    <br/>
    <ul>
        <li>Every module has a special built-in variable <code>__name__</code>.</li>
        <br/>
        <li>When a module is executed directly:</li>
    </ul>

<pre><code class="language-python">python greetings.py
</code></pre>

    <br/>

<pre><code class="language-python line-numbers"># inside greetings.py
print(__name__)  # "__main__"
</code></pre>

    <br/>
    <ul>
        <li>When imported:</li>
    </ul>

<pre><code class="language-python line-numbers">import greetings
print(greetings.__name__)   # "greetings"
</code></pre>

    <br/><br/>



    <li><b>Running Code Only When Module Is Executed</b></li>
    <br/>
    <ul>
        <li>Use the common guard:</li>
    </ul>

<pre><code class="language-python line-numbers"># greetings.py

def hello(name):
    return f"Hello, {name}!"

if __name__ == "__main__":
    print(hello("Tester"))
</code></pre>

    <br/>
    <ul>
        <li>This ensures test code runs only when the module is executed directly, not when imported.</li>
    </ul>

    <br/><br/>



    <li><b>Standard Library Modules</b></li>
    <br/>
    <ul>
        <li>Python ships with a rich standard library:</li>
        <ul>
            <li><code>math</code> ‚Äî mathematical functions</li>
            <li><code>os</code> ‚Äî operating system interactions</li>
            <li><code>sys</code> ‚Äî interpreter internals</li>
            <li><code>random</code> ‚Äî random numbers</li>
            <li><code>json</code> ‚Äî JSON parsing</li>
            <li><code>datetime</code> ‚Äî dates and times</li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">import json
print(json.dumps({"a": 1}))
</code></pre>

    <br/><br/>



    <li><b>Third-Party Modules</b></li>
    <br/>
    <ul>
        <li>Install using pip:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install requests
</code></pre>

    <br/>

<pre><code class="language-python line-numbers">import requests
print(requests.get("https://example.com").status_code)
</code></pre>

    <br/><br/>



    <li><b>Packages vs Modules</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Term</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Module</td>
                <td>A single <code>.py</code> file</td>
            </tr>
            <tr>
                <td>Package</td>
                <td>A directory containing modules (with <code>__init__.py</code> inside)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Importing from Packages</b></li>
    <br/>

<pre><code class="language-python line-numbers"># project structure:
# utils/
#   __init__.py
#   math_tools.py

from utils.math_tools import add
</code></pre>

    <br/><br/>



    <li><b>Reloading Modules</b></li>
    <br/>

<pre><code class="language-python line-numbers">import importlib
importlib.reload(greetings)
</code></pre>

    <br/>
    <ul>
        <li>Useful in REPL sessions or Jupyter notebooks.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-vs-python3">Python vs Python3</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The terms <b>Python</b> and <b>Python 3</b> often confuse beginners.</li>
        <br/>
        <li>Historically:
            <ul>
                <li><b>Python</b> used to mean Python 2.x (2.7, etc.).</li>
                <li><b>Python 3</b> refers to the modern Python language (3.x).</li>
            </ul>
        </li>
        <br/>
        <li>Since Python 2 reached end-of-life in 2020, <b>Python = Python 3</b> in almost all modern contexts.</li>
        <br/>
        <li>However, some systems still have binaries named <code>python</code>, <code>python3</code>, <code>pip</code>, <code>pip3</code>, etc., which behave differently depending on OS and environment.</li>
    </ul>
    <br/><br/>



    <li><b>Command-Line Differences</b></li>
    <br/>

    <ul>
        <li>On older Linux/macOS systems:</li>
    </ul>

<pre><code class="language-bash line-numbers">python      # might run Python 2.7
python3     # runs Python 3.x
</code></pre>

    <br/>
    <ul>
        <li>On modern systems (Ubuntu 22+, macOS 12+, Windows):</li>
    </ul>

<pre><code class="language-bash line-numbers">python      # runs Python 3.x
python3     # also runs Python 3.x
</code></pre>

    <br/>
    <ul>
        <li>Similarly for pip:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip     # may point to pip2 or pip3 depending on system
pip3    # always pip for Python 3
</code></pre>

    <br/><br/>



    <li><b>Python2 vs Python3 Key Language Differences</b></li>
    <br/>
    <ul><li>Important differences between the languages themselves:</li></ul>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Python 2</th>
                <th>Python 3</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>print</code></td>
                <td>Statement: <code>print "hi"</code></td>
                <td>Function: <code>print("hi")</code></td>
            </tr>
            <tr>
                <td>Unicode</td>
                <td><code>str</code> = bytes</td>
                <td><code>str</code> = Unicode</td>
            </tr>
            <tr>
                <td><code>range</code></td>
                <td>Returns list</td>
                <td>Lazy object (efficient)</td>
            </tr>
            <tr>
                <td>Division</td>
                <td><code>5 / 2 == 2</code></td>
                <td><code>5 / 2 == 2.5</code></td>
            </tr>
            <tr>
                <td>Error handling</td>
                <td><code>except Exception, e</code></td>
                <td><code>except Exception as e</code></td>
            </tr>
            <tr>
                <td>Iterators</td>
                <td>Many return lists</td>
                <td>Return lightweight iterators</td>
            </tr>
            <tr>
                <td>f-strings</td>
                <td>‚ùå Not available</td>
                <td>‚úî Available</td>
            </tr>
            <tr>
                <td>Type hints</td>
                <td>‚ùå Not supported</td>
                <td>‚úî Fully supported</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Why Python 3 Was Introduced</b></li>
    <br/>
    <ul>
        <li>Python 2 had design limitations:
            <ul>
                <li>Unicode handling was broken</li>
                <li>Inconsistent standard library</li>
                <li>Old syntax (print, exceptions)</li>
                <li>Need for backward-incompatible cleanup</li>
            </ul>
        </li>
        <br/>
        <li>Python 3 fixed these issues but required breaking backward compatibility.</li>
    </ul>

    <br/><br/>



    <li><b>Python2 End-of-Life</b></li>
    <br/>
    <ul>
        <li>Python 2 reached official end-of-life on <b>January 1, 2020</b>.</li>
        <li>No more security updates.</li>
        <li>No new libraries support Python 2.</li>
        <li>All modern Python code should be Python 3.</li>
    </ul>

    <br/><br/>



    <li><b>Should You Ever Use Python 2?</b></li>
    <br/>
    <ul>
        <li>No ‚Äî except if maintaining an extremely old legacy system.</li>
        <li>All new projects must use Python 3.</li>
    </ul>

    <br/><br/>



    <li><b>Checking Your System‚Äôs Python Version</b></li>
    <br/>

<pre><code class="language-bash line-numbers">python --version
python3 --version
</code></pre>

    <br/>

<pre><code class="language-python line-numbers">import sys
print(sys.version)
</code></pre>

    <br/><br/>



    <li><b>Modern Recommendation (Most Important)</b></li>
    <br/>
    <ul>
        <li>Always run:</li>
    </ul>

<pre><code class="language-bash line-numbers">python3
pip3
</code></pre>

    <br/>
    <ul>
        <li>Or even better: explicitly use the Python interpreter inside your virtual environment:</li>
    </ul>

<pre><code class="language-bash line-numbers">.venv/bin/python
.venv/bin/pip
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Python</th>
                <th>Python 3</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Meaning today</td>
                <td>Usually Python 3, but may be Python 2 on old systems</td>
                <td>Always Python 3</td>
            </tr>
            <tr>
                <td>Status</td>
                <td>Python 2: EOL (dead)</td>
                <td>Actively maintained</td>
            </tr>
            <tr>
                <td>Unicode</td>
                <td>Broken model</td>
                <td>First-class Unicode</td>
            </tr>
            <tr>
                <td>Syntax</td>
                <td>Old syntax (<code>print</code>, exception syntax)</td>
                <td>Modern syntax: <code>print()</code>, exception chaining</td>
            </tr>
            <tr>
                <td>Tooling</td>
                <td>Very limited</td>
                <td>Type hints, virtualenvs, modern libraries</td>
            </tr>
            <tr>
                <td>Recommendation</td>
                <td>Do not use</td>
                <td>Use for all projects</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-pip">pip / pip3 ‚Äì Python Package Manager</h3>
<ol>
    <li><b>What Is pip?</b></li>
    <br/>
    <ul>
        <li><code>pip</code> is the standard package manager for Python.</li>
        <br/>
        <li>It installs packages from the Python Package Index (PyPI) and other indices.</li>
        <br/>
        <li>You use <code>pip</code> to:</li>
        <ul>
            <li>install third-party libraries (e.g. <code>requests</code>, <code>numpy</code>)</li>
            <li>upgrade or remove packages</li>
            <li>manage dependencies in virtual environments</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>pip vs pip3</b></li>
    <br/>
    <ul>
        <li>Historically:
            <ul>
                <li><code>pip</code> often pointed to Python 2.x</li>
                <li><code>pip3</code> pointed to Python 3.x</li>
            </ul>
        </li>
        <br/>
        <li>On modern systems, both usually point to Python 3, but this can vary.</li>
        <br/>
        <li><b>Safe rule:</b> tie pip to the interpreter explicitly:</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip install requests
python3 -m pip install requests
</code></pre>

    <br/>
    <ul>
        <li>Inside a virtual environment, <code>python -m pip</code> always uses that environment&rsquo;s pip.</li>
    </ul>
    <br/><br/>



    <li><b>Checking pip Installation and Version</b></li>
    <br/>

<pre><code class="language-bash line-numbers">pip --version
pip3 --version
python -m pip --version
</code></pre>

    <br/>
    <ul>
        <li>Shows which Python interpreter pip is attached to and its installation path.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Installation Commands</b></li>
    <br/>

<pre><code class="language-bash line-numbers"># install latest version of a package
python -m pip install requests

# install a specific version
python -m pip install "requests==2.31.0"

# install at least version X
python -m pip install "requests&gt;=2.31.0"

# install from a local file
python -m pip install ./my_package-0.1.0-py3-none-any.whl
</code></pre>

    <br/><br/>



    <li><b>Upgrading and Uninstalling Packages</b></li>
    <br/>

<pre><code class="language-bash line-numbers"># upgrade a package
python -m pip install --upgrade requests

# uninstall a package
python -m pip uninstall requests
</code></pre>

    <br/>
    <ul>
        <li><code>--upgrade</code> installs the newest available version.</li>
    </ul>

    <br/><br/>



    <li><b>Listing and Inspecting Installed Packages</b></li>
    <br/>

<pre><code class="language-bash line-numbers"># list all installed packages
python -m pip list

# show detailed information about a package
python -m pip show requests
</code></pre>

    <br/>
    <ul>
        <li><code>pip show</code> displays version, location, dependencies, etc.</li>
    </ul>

    <br/><br/>



    <li><b>Using Requirements Files</b></li>
    <br/>
    <ul>
        <li>A <code>requirements.txt</code> file lists all dependencies for a project.</li>
        <li>Typical format:</li>
    </ul>

<pre><code class="language-text line-numbers">requests==2.31.0
flask&gt;=2.3
numpy~=1.26
</code></pre>

    <br/>
    <ul>
        <li>Install everything from a requirements file:</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip install -r requirements.txt
</code></pre>

    <br/>
    <ul>
        <li>Freeze current environment into a requirements file:</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip freeze &gt; requirements.txt
</code></pre>

    <br/><br/>



    <li><b>pip and Virtual Environments</b></li>
    <br/>
    <ul>
        <li>Always prefer using pip inside a <b>virtual environment</b> to avoid polluting system Python.</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m venv .venv
source .venv/bin/activate    # Linux/macOS
# .venv\Scripts\activate     # Windows (PowerShell/CMD)

python -m pip install requests
</code></pre>
    <ul>
        <li>Packages are installed only into the activated environment.</li>
    </ul>

    <br/><br/>



    <li><b>Installing Your Own Project with pip</b></li>
    <br/>
    <ul>
        <li>If your project contains <code>pyproject.toml</code> or <code>setup.py</code>, you can install it:</li>
    </ul>

<pre><code class="language-bash line-numbers"># from project root directory
python -m pip install .
</code></pre>

    <br/>
    <ul>
        <li>Editable (development) install:</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip install -e .
</code></pre>

    <br/>
    <ul>
        <li>This links the installed package to your source directory, so changes in code are immediately visible when importing.</li>
    </ul>

    <br/><br/>



    <li><b>Useful Options</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Option</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>--upgrade</code></td>
                <td>Upgrade package to latest version</td>
            </tr>
            <tr>
                <td><code>--force-reinstall</code></td>
                <td>Reinstall even if version is already installed</td>
            </tr>
            <tr>
                <td><code>--no-deps</code></td>
                <td>Do not install dependencies automatically</td>
            </tr>
            <tr>
                <td><code>--user</code></td>
                <td>Install into user&rsquo;s home directory (no root needed)</td>
            </tr>
            <tr>
                <td><code>--pre</code></td>
                <td>Allow pre-release and beta versions</td>
            </tr>
            <tr>
                <td><code>-r file.txt</code></td>
                <td>Install from requirements file</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Upgrading pip Itself</b></li>
    <br/>

<pre><code class="language-bash line-numbers">python -m pip install --upgrade pip
</code></pre>

    <br/>
    <ul>
        <li>Run this inside each virtual environment to keep pip up to date there.</li>
    </ul>

    <br/><br/>



    <li><b>pip Cache and Offline Installs (Short Overview)</b></li>
    <br/>
    <ul>
        <li>pip uses a local cache for downloaded packages.</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip cache dir      # show cache location
python -m pip cache list     # list cached packages
</code></pre>

    <br/>
    <ul>
        <li>You can download wheels on one machine and install them offline on another using <code>--no-index</code> and <code>--find-links</code>, but that is a more advanced topic.</li>
    </ul>

    <br/><br/>



    <li><b>Common Pitfalls</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Issue</th>
                <th>Explanation / Fix</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Using wrong pip</td>
                <td>Use <code>python -m pip</code> to ensure the correct interpreter</td>
            </tr>
            <tr>
                <td>Installing globally as root</td>
                <td>Better: use virtual environments or <code>--user</code></td>
            </tr>
            <tr>
                <td>Conflicting versions</td>
                <td>Use separate venvs per project to isolate dependencies</td>
            </tr>
            <tr>
                <td>Missing packages in IDE</td>
                <td>Ensure IDE uses the same interpreter / venv where you installed packages</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Key Idea</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>pip</code> / <code>pip3</code></td>
                <td>Python&rsquo;s package manager</td>
            </tr>
            <tr>
                <td>Best practice</td>
                <td>Use <code>python -m pip</code> inside a virtual environment</td>
            </tr>
            <tr>
                <td>Dependencies</td>
                <td>Manage via <code>requirements.txt</code> and <code>pip freeze</code></td>
            </tr>
            <tr>
                <td>Installs</td>
                <td><code>install</code>, <code>uninstall</code>, <code>list</code>, <code>show</code></td>
            </tr>
            <tr>
                <td>Local projects</td>
                <td><code>pip install .</code> and <code>pip install -e .</code></td>
            </tr>
            <tr>
                <td>Safety</td>
                <td>Avoid global installs; prefer venvs</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-packages">Python Packages</h3>
<ol>
    <li><b>What Is a Package?</b></li>
    <br/>
    <ul>
        <li>A <b>package</b> in Python is a <b>directory</b> containing <b>modules</b>.</li>
        <br/>
        <li>The directory becomes a <b>package</b> when it contains a file named <code>__init__.py</code> (even if empty).</li>
        <br/>
        <li>Packages allow you to structure code into logical groups:
            <ul>
                <li><b>modules</b>: single .py files</li>
                <li><b>packages</b>: directories of modules</li>
                <li><b>subpackages</b>: nested package folders</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Package Structure</b></li>
    <br/>

<pre><code class="language-text line-numbers">myproject/
    mypackage/
        __init__.py
        math_utils.py
        string_utils.py
    main.py
</code></pre>

    <br/>
    <ul>
        <li><code>mypackage</code> is now importable because it contains <code>__init__.py</code>.</li>
        <li>You can access modules inside it through standard import syntax.</li>
    </ul>
    <br/><br/>



    <li><b>Importing from Packages</b></li>
    <br/>
    <ul>
        <li>Import the entire package:</li>
    </ul>

<pre><code class="language-python line-numbers">import mypackage
</code></pre>

    <br/>
    <ul>
        <li>Import a module inside a package:</li>
    </ul>

<pre><code class="language-python line-numbers">from mypackage import math_utils
</code></pre>

    <br/>
    <ul>
        <li>Import specific functions or classes:</li>
    </ul>

<pre><code class="language-python line-numbers">from mypackage.math_utils import add, multiply
</code></pre>

    <br/>
    <ul>
        <li>Import with alias:</li>
    </ul>

<pre><code class="language-python line-numbers">import mypackage.string_utils as su
</code></pre>

    <br/><br/>



    <li><b>The <code>__init__.py</code> File</b></li>
    <br/>
    <ul>
        <li>This file is executed when the package is imported.</li>
        <li>Purposes:</li>
        <ul>
            <li>Indicate that the directory is a package</li>
            <li>Define package-level variables</li>
            <li>Expose selected members for import</li>
            <li>Run initialization logic (not common)</li>
        </ul>
    </ul>
    <br/>

<pre><code class="language-python line-numbers"># mypackage/__init__.py

from .math_utils import add
from .string_utils import to_upper

VERSION = "1.0.0"
</code></pre>

    <br/>
    <ul>
        <li>This allows:</li>
    </ul>

<pre><code class="language-python line-numbers">from mypackage import add, to_upper
</code></pre>

    <br/><br/>



    <li><b>Package Search Path</b></li>
    <br/>
    <ul>
        <li>When you import a package, Python searches for it in:</li>
        <ul>
            <li>The current directory</li>
            <li>Virtual environment packages</li>
            <li>System site-packages</li>
            <li>Directories listed in <code>sys.path</code></li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">import sys
print(sys.path)
</code></pre>

    <br/><br/>



    <li><b>Subpackages</b></li>
    <br/>

    <ul>
        <li>You can create deeper hierarchies:</li>
    </ul>

<pre><code class="language-text line-numbers">mypackage/
    __init__.py
    data/
        __init__.py
        loader.py
    utils/
        __init__.py
        file.py
        debug.py
</code></pre>

    <br/>
    <ul>
        <li>Importing from subpackages:</li>
    </ul>

<pre><code class="language-python line-numbers">from mypackage.data.loader import load_csv
from mypackage.utils.debug import log
</code></pre>

    <br/><br/>



    <li><b>Absolute vs Relative Imports</b></li>
    <br/>
    <ul><b>Absolute imports:</b></ul>

<pre><code class="language-python line-numbers">from mypackage.utils.file import read_file
</code></pre>

    <br/>

    <ul><b>Relative imports:</b></ul>

<pre><code class="language-python line-numbers">from .utils.file import read_file           # same package
from ..core.helpers import validate_input   # parent package
</code></pre>

    <br/>
    <ul>
        <li>Relative imports work only inside packages, not in top-level scripts.</li>
    </ul>

    <br/><br/>



    <li><b>Installing Your Package Locally</b></li>
    <br/>
    <ul>
        <li>Modern Python packaging uses <code>pyproject.toml</code>.</li>
        <li>Install your package into a virtual environment:</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip install .
</code></pre>

    <br/>
    <ul>
        <li>Editable mode (for development):</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip install -e .
</code></pre>

    <br/>
    <ul>
        <li>This means changes in source files update immediately without reinstalling.</li>
    </ul>

    <br/><br/>



    <li><b>Packaging for Distribution</b></li>
    <br/>
    <ul>
        <li>Typical project layout:</li>
    </ul>

<pre><code class="language-text line-numbers">yourpackage/
    __init__.py
    module_a.py
    module_b.py
pyproject.toml
README.md
LICENSE
</code></pre>

    <br/>
    <ul>
        <li>Build with:</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m build
</code></pre>

    <br/>
    <ul>
        <li>This generates wheels and sdist files suitable for PyPI.</li>
    </ul>

    <br/><br/>



    <li><b>Namespace Packages (Advanced)</b></li>
    <br/>
    <ul>
        <li>A package <b>without</b> <code>__init__.py</code> is a <b>namespace package</b>.</li>
        <br/>
        <li>Namespace packages allow:</li>
        <ul>
            <li>splitting a package across multiple directories</li>
            <li>large plugin systems</li>
        </ul>
        <br/>
        <li>Examples: <code>google.cloud.*</code>, <code>zope.*</code></li>
    </ul>

<pre><code class="language-text line-numbers">analytics/
    models/
        user.py
    transformations/
        filter.py
</code></pre>

    <br/>
    <ul>
        <li>If both folders are namespace packages, they combine automatically under <code>analytics</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Module</td>
                <td>Single <code>.py</code> file</td>
            </tr>
            <tr>
                <td>Package</td>
                <td>Directory containing <code>__init__.py</code> and modules</td>
            </tr>
            <tr>
                <td>Subpackage</td>
                <td>Package inside another package</td>
            </tr>
            <tr>
                <td>Absolute import</td>
                <td><code>from package.module import x</code></td>
            </tr>
            <tr>
                <td>Relative import</td>
                <td><code>from .module import x</code></td>
            </tr>
            <tr>
                <td>Editable install</td>
                <td><code>pip install -e .</code></td>
            </tr>
            <tr>
                <td>Namespace package</td>
                <td>Package without <code>__init__.py</code>, can span multiple dirs</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-virtual-environments">Python Virtual Environments</h3>
<ol>
    <li><b>What Is a Virtual Environment?</b></li>
    <br/>
    <ul>
        <li>A <b>virtual environment</b> (venv) is an isolated Python environment.</li>
        <br/>
        <li>It allows each project to have its own:
            <ul>
                <li>Python interpreter version</li>
                <li>Installed packages</li>
                <li>Dependencies and dependency versions</li>
            </ul>
        </li>
        <br/>
        <li>This prevents conflicts between projects.</li>
        <br/>
        <li>Example:
            <ul>
                <li>Project A needs <code>django==3.2</code></li>
                <li>Project B needs <code>django==5.0</code></li>
            </ul>
            Virtual environments make this possible on the same machine.
        </li>
        <br/>
        <li>Other languages usually avoid this by:
            <ul>
                <li>embedding dependencies in the project folder (Node.js)</li>
                <li>compiling static binaries (Go, Rust)</li>
                <li>system-level package managers (C/C++)</li>
            </ul>
            Python instead isolates entire environments.
        </li>
    </ul>
    <br/><br/>



    <li><b>Why Virtual Environments Are Needed</b></li>
    <br/>
    <ul>
        <li>Python packages are installed globally unless isolated.</li>
        <br/>
        <li>Global installs can cause:
            <ul>
                <li>version conflicts</li>
                <li>security issues</li>
                <li>inconsistent environments</li>
                <li>projects breaking each other</li>
            </ul>
        </li>
        <br/>
        <li>A project developed in one environment may fail to run on another if package versions differ.</li>
        <br/>
        <li>Virtual environments ensure reproducibility.</li>
    </ul>
    <br/><br/>



    <li><b>Creating a Virtual Environment</b></li>
    <br/>

<pre><code class="language-bash line-numbers">python -m venv .venv</code></pre>

    <br/>
    <ul>
        <li>This creates a folder <code>.venv/</code> containing:</li>
        <ul>
            <li>a dedicated Python interpreter</li>
            <li>a local pip</li>
            <li>its own site-packages directory</li>
        </ul>
    </ul>

<pre><code class="language-text line-numbers">.venv/
    bin/ or Scripts/
    lib/
    pyvenv.cfg
</code></pre>

    <br/><br/>



    <li><b>Activating a Virtual Environment</b></li>
    <br/>

    <ul><li>macOS / Linux:</li></ul>

<pre><code class="language-bash line-numbers">source .venv/bin/activate</code></pre>

    <br/>

    <ul><li>Windows (PowerShell):</li></ul>

<pre><code class="language-bash line-numbers">.\.venv\Scripts\Activate.ps1</code></pre>

    <br/>

    <ul>
        <li>After activation, your terminal prompt usually changes:</li>
    </ul>

<pre><code class="language-bash">(.venv) $</code></pre>

    <br/>
    <ul>
        <li>All <code>python</code> and <code>pip</code> commands now use this environment.</li>
    </ul>
    <br/><br/>



    <li><b>Installing Packages Inside the Environment</b></li>
    <br/>

<pre><code class="language-bash line-numbers">pip install requests</code></pre>

    <br/>
    <ul>
        <li>This installs <code>requests</code> only into <code>.venv/</code>, not globally.</li>
    </ul>

<pre><code class="language-bash line-numbers">pip list</code></pre>

    <br/>
    <ul>
        <li>Shows only packages for this virtual environment.</li>
    </ul>
    <br/><br/>



    <li><b>Deactivating</b></li>
    <br/>

<pre><code class="language-bash line-numbers">deactivate</code></pre>

    <br/>
    <ul>
        <li>This returns you to the system-wide Python.</li>
    </ul>
    <br/><br/>



    <li><b>Why <code>python -m pip</code> Is Better</b></li>
    <br/>
    <ul>
        <li><code>pip</code> might point to the wrong interpreter ‚Üí wrong install location.</li>
        <br/>
        <li><code>python -m pip</code> always uses pip from the current environment.</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip install flask</code></pre>

    <br/><br/>



    <li><b>How Virtual Environments Work Internally</b></li>
    <br/>
    <ul>
        <li>The virtual environment copies or symlinks the Python interpreter.</li>
        <br/>
        <li>It creates a small configuration file:</li>
    </ul>

<pre><code class="language-text line-numbers">pyvenv.cfg
home = /usr/bin/python3.10
include-system-site-packages = false
</code></pre>

    <br/>
    <ul>
        <li>The import system now loads packages from:</li>
        <ul>
            <li><code>.venv/lib/pythonX.Y/site-packages</code></li>
            <li>instead of global site-packages</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Virtual Environment Best Practices</b></li>
    <br/>
    <ul>
        <li>Create a venv for every project.</li>
        <li>Never install global packages unless absolutely required.</li>
        <li>Use <code>.venv/</code> or <code>venv/</code> as the folder name (common convention).</li>
        <li>Add the venv to <code>.gitignore</code>:</li>
    </ul>

<pre><code class="language-text line-numbers">.venv/</code></pre>

    <br/>
    <ul>
        <li>Use <code>requirements.txt</code> or <code>pyproject.toml</code> to track dependencies.</li>
    </ul>

<pre><code class="language-bash line-numbers">python -m pip freeze > requirements.txt</code></pre>

    <br/><br/>



    <li><b>Virtual Environments vs Other Languages</b></li>
    <br/>
    <ul>
        <li>Many languages avoid this concept by:</li>
        <ul>
            <li><b>Node.js</b>: packages stored in <code>node_modules</code></li>
            <li><b>Go</b>: static binaries + Go modules</li>
            <li><b>Java</b>: jar dependency management</li>
            <li><b>Rust</b>: per-project cargo registry + isolated builds</li>
        </ul>
        <br/>
        <li>Python instead isolates:
            <ul>
                <li>its interpreter</li>
                <li>its package directory</li>
                <li>its module search path</li>
            </ul>
        </li>
        <br/>
        <li>This solves global-interpreter dependency issues unique to Python&rsquo;s runtime model.</li>
    </ul>

    <br/><br/>



    <li><b>Alternatives to venv (Advanced Tools)</b></li>
    <br/>
    <ul>
        <li>Other tools build on top of virtual environments:</li>
        <ul>
            <li><b>virtualenv</b> ‚Äì older, faster version of venv</li>
            <li><b>pipenv</b> ‚Äì environment + dependency management</li>
            <li><b>poetry</b> ‚Äì modern dependency and packaging tool</li>
            <li><b>conda</b> ‚Äì environment manager for Python + native libraries</li>
        </ul>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Virtual environment</td>
                <td>Isolated Python interpreter + packages</td>
            </tr>
            <tr>
                <td>Purpose</td>
                <td>Avoid conflicts between project dependencies</td>
            </tr>
            <tr>
                <td>Creation</td>
                <td><code>python -m venv .venv</code></td>
            </tr>
            <tr>
                <td>Activation</td>
                <td>Use <code>source .venv/bin/activate</code> or Windows <code>Activate.ps1</code></td>
            </tr>
            <tr>
                <td>Install packages</td>
                <td>Into the venv using <code>python -m pip install</code></td>
            </tr>
            <tr>
                <td>Deactivation</td>
                <td><code>deactivate</code></td>
            </tr>
            <tr>
                <td>Comparison with other languages</td>
                <td>Python isolates entire interpreter, not just dependencies</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-conda-vs-anaconda">Conda vs Anaconda</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><b>Conda</b> and <b>Anaconda</b> are related but not the same.</li>
        <br/>
        <li>Many beginners confuse these terms, but they refer to different things:
            <ul>
                <li><b>Conda</b> ‚Üí a package manager + environment manager</li>
                <li><b>Anaconda</b> ‚Üí a large Python distribution that includes conda</li>
            </ul>
        </li>
        <br/>
        <li>In simple words:
            <ul>
                <li><b>Conda is the tool</b></li>
                <li><b>Anaconda is a distribution that ships with the tool and many preinstalled libraries</b></li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>What Is Conda?</b></li>
    <br/>
    <ul>
        <li><b>Conda</b> is a:
            <ul>
                <li>cross-platform package manager</li>
                <li>environment manager</li>
            </ul>
        </li>
        <br/>
        <li>It can install:
            <ul>
                <li>Python versions</li>
                <li>Python packages</li>
                <li>Non-Python packages (C libraries, compilers, CUDA libraries)</li>
            </ul>
        </li>
        <br/>
        <li>Conda environments are similar to <code>venv</code>, but more powerful:
            <ul>
                <li>You can create an environment with any Python version</li>
                <li>You can install system-level dependencies not available via pip</li>
                <li>Conda resolves dependency conflicts better than pip</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers"># create environment with a specific python version
conda create -n myenv python=3.11

# activate environment
conda activate myenv

# install packages
conda install numpy</code></pre>

    <br/><br/>



    <li><b>What Is Anaconda?</b></li>
    <br/>
    <ul>
        <li><b>Anaconda</b> is a <b>Python distribution</b> designed for:
            <ul>
                <li>data science</li>
                <li>machine learning</li>
                <li>scientific computing</li>
            </ul>
        </li>
        <br/>
        <li>It includes:
            <ul>
                <li>the conda tool</li>
                <li>Python and R</li>
                <li>hundreds of pre-installed scientific packages:
                    <ul>
                        <li>numpy</li>
                        <li>pandas</li>
                        <li>scipy</li>
                        <li>matplotlib</li>
                        <li>jupyter</li>
                        <li>scikit-learn</li>
                        <li>tensorflow (optional channels)</li>
                    </ul>
                </li>
                <li>Anaconda Navigator (GUI app)</li>
            </ul>
        </li>
        <br/>
        <li><b>It is huge (3‚Äì5 GB).</b></li>
    </ul>
<pre><code class="language-text">Anaconda = Python + Conda + Hundreds of pre-installed data-science packages</code></pre>

    <br/><br/>



    <li><b>What Is Miniconda?</b></li>
    <br/>
    <ul>
        <li><b>Miniconda</b> is a <b>small version</b> of Anaconda that includes:
            <ul>
                <li>Python</li>
                <li>Conda</li>
                <li>No preinstalled packages</li>
            </ul>
        </li>
        <br/>
        <li>Size: ~50‚Äì100 MB instead of multiple GB.</li>
        <br/>
        <li>You install only what you need.</li>
    </ul>

<pre><code class="language-text">Miniconda = Python + Conda (minimal)</code></pre>

    <br/><br/>



    <li><b>Conda vs pip</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>pip</th>
                <th>conda</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Main purpose</td>
                <td>Install Python packages from PyPI</td>
                <td>Install any package (Python & non-Python)</td>
            </tr>
            <tr>
                <td>Manages Python versions?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Environments</td>
                <td>via <code>venv</code></td>
                <td>built-in environment manager</td>
            </tr>
            <tr>
                <td>Works offline?</td>
                <td>No</td>
                <td>Yes (with local channels)</td>
            </tr>
            <tr>
                <td>Speed</td>
                <td>Fast for pure Python packages</td>
                <td>Optimized for scientific stack</td>
            </tr>
            <tr>
                <td>Binary dependencies</td>
                <td>Hard to install</td>
                <td>Easy (bundled with C libraries)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When Should You Use Conda?</b></li>
    <br/>
    <ul>
        <li>Best for:
            <ul>
                <li>data science</li>
                <li>machine learning</li>
                <li>scientific computing</li>
                <li>working with NumPy/SciPy/TensorFlow/PyTorch</li>
            </ul>
        </li>
        <br/>
        <li>Why?
            <ul>
                <li>These libraries depend on heavy C/C++/Fortran code.</li>
                <li>Conda provides precompiled binaries ‚Üí painless installation.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>When Should You Use pip + venv?</b></li>
    <br/>
    <ul>
        <li>Best for:
            <ul>
                <li>general Python development</li>
                <li>web applications</li>
                <li>scripting</li>
                <li>lightweight environments</li>
            </ul>
        </li>
        <br/>
        <li>Advantages:
            <ul>
                <li>lighter and faster</li>
                <li>standard for typical Python projects</li>
                <li>compatible with modern tools (Poetry, PDM, pipx)</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Summary: Conda vs Anaconda</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Conda</td>
                <td>A package manager and environment manager.</td>
            </tr>
            <tr>
                <td>Anaconda</td>
                <td>A full scientific Python distribution that includes conda and hundreds of packages.</td>
            </tr>
            <tr>
                <td>Miniconda</td>
                <td>A minimal installer for conda without preinstalled packages.</td>
            </tr>
            <tr>
                <td>pip</td>
                <td>Python‚Äôs standard package manager; installs from PyPI only.</td>
            </tr>
            <tr>
                <td>Which one to choose?</td>
                <td><b>Conda for data science</b>; <b>pip+venv for general development</b>.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-input">Python Input</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python provides the built-in <code>input()</code> function to read user input from the keyboard.</li>
        <br/>
        <li><code>input()</code> always returns a <b>string</b>, regardless of what the user types.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Usage of <code>input()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">name = input("Enter your name: ")
print("Hello,", name)</code></pre>
    <ul>
        <li>If you pass a string to <code>input()</code>, it is printed as a prompt.</li>
        <li>You can also omit it:</li>
    </ul>
<pre><code class="language-python line-numbers">x = input()
</code></pre>

    <br/><br/>



    <li><b><code>input()</code> Always Returns a String</b></li>
    <br/>
    <ul>
        <li>Even if you type numbers, the result is still a string:</li>
    </ul>

<pre><code class="language-python line-numbers">value = input("Enter a number: ")
print(type(value))   # &lt;class 'str'&gt;
</code></pre>

    <br/>
    <ul>
        <li>To convert, you must cast explicitly:</li>
    </ul>

<pre><code class="language-python line-numbers">age = int(input("Enter your age: "))
pi  = float(input("Enter a float: "))
</code></pre>

    <br/><br/>



    <li><b>Common Conversion Patterns</b></li>
    <br/>

    <ul><li><b>Integer input</b></li></ul>
<pre><code class="language-python line-numbers">n = int(input("n = "))
</code></pre>

    <ul><li><b>Float input</b></li></ul>
<pre><code class="language-python line-numbers">x = float(input("x = "))
</code></pre>

    <ul><li><b>Boolean (manual conversion)</b></li></ul>
<pre><code class="language-python line-numbers">flag = input("True/False? ").lower() == "true"
</code></pre>

    <ul><li><b>Reading multiple values</b></li></ul>
<pre><code class="language-python line-numbers">a, b = input("Enter two numbers: ").split()
a = int(a)
b = int(b)
</code></pre>

    <ul><li><b>Reading many integers at once</b></li></ul>
<pre><code class="language-python line-numbers">nums = list(map(int, input("Numbers: ").split()))
</code></pre>

    <br/><br/>



    <li><b>Using <code>split()</code> for Multi-Value Input</b></li>
    <br/>
    <ul>
        <li><code>split()</code> divides input by whitespace:</li>
    </ul>

<pre><code class="language-python line-numbers">text = "apple banana orange"
items = text.split()
# ["apple", "banana", "orange"]
</code></pre>

    <br/>

<pre><code class="language-python line-numbers">values = input("a b c: ").split()
</code></pre>

    <br/>
    <ul>
        <li>Works well for competitive programming patterns:</li>
    </ul>

<pre><code class="language-python line-numbers">a, b, c = map(int, input().split())
</code></pre>

    <br/><br/>



    <li><b>Stripping Input Automatically</b></li>
    <br/>
    <ul>
        <li><code>input()</code> includes no trailing newline, but may include spaces.</li>
        <li>Use <code>.strip()</code> to clean:</li>
    </ul>

<pre><code class="language-python line-numbers">cmd = input("Command: ").strip()
</code></pre>

    <br/>
    <ul>
        <li>.strip() removes leading and trailing whitespace.</li>
    </ul>

    <br/><br/>



    <li><b>Error Handling for Invalid Input</b></li>
    <br/>
    <ul>
        <li>Converting invalid input raises <code>ValueError</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">try:
    n = int(input("Enter number: "))
except ValueError:
    print("Not a valid integer!")
</code></pre>

    <br/>
    <ul>
        <li>Useful for user-friendly CLI programs.</li>
    </ul>

    <br/><br/>



    <li><b>Reading Input Until a Condition</b></li>
    <br/>
    <ul><li><b>Looping until valid input</b></li></ul>

<pre><code class="language-python line-numbers">while True:
    x = input("Enter int: ")
    if x.isdigit():
        x = int(x)
        break
    print("Try again.")
</code></pre>

    <br/><br/>



    <li><b>Reading Multiple Lines (Advanced)</b></li>
    <br/>
    <ul><li><b>Using a loop</b></li></ul>

<pre><code class="language-python line-numbers">lines = []
while True:
    line = input()
    if line == "":
        break
    lines.append(line)
</code></pre>

    <br/>
    <ul><li><b>Using sys.stdin</b> (more efficient)</li></ul>

<pre><code class="language-python line-numbers">import sys

for line in sys.stdin:
    print("You entered:", line.strip())
</code></pre>

    <br/><br/>


    <li><b>Advanced: <code>ast.literal_eval</code> for Safe Parsing</b></li>
    <br/>
    <ul>
        <li><code>literal_eval</code> can safely parse Python literals:</li>
    </ul>

<pre><code class="language-python line-numbers">import ast

val = ast.literal_eval(input("Enter a list or number: "))
print(type(val), val)
</code></pre>

    <br/>
    <ul>
        <li>This can parse:</li>
        <ul>
            <li><code>5</code></li>
            <li><code>[1, 2, 3]</code></li>
            <li><code>{"a": 1}</code></li>
        </ul>
        <li>But cannot run arbitrary code (safer than <code>eval</code>).</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>input()</code></td>
                <td>Reads a line from the user, returns a string</td>
            </tr>
            <tr>
                <td>Always string</td>
                <td>You must convert to int/float manually</td>
            </tr>
            <tr>
                <td>Multiple values</td>
                <td>Use <code>.split()</code> and <code>map()</code></td>
            </tr>
            <tr>
                <td>Error handling</td>
                <td>Use <code>try/except</code> when converting</td>
            </tr>
            <tr>
                <td>Reading many lines</td>
                <td>Use loops or <code>sys.stdin</code></td>
            </tr>
            <tr>
                <td>Trimming whitespace</td>
                <td><code>.strip()</code> removes leading/trailing spaces</td>
            </tr>
            <tr>
                <td>Safe literal parsing</td>
                <td><code>ast.literal_eval()</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-output">Python Output</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Python, the primary way to produce output is the <code>print()</code> function.</li>
        <br/>
        <li><code>print()</code> sends text to the program‚Äôs <b>standard output</b> (usually the terminal).</li>
        <br/>
        <li>It can print:
            <ul>
                <li>strings</li>
                <li>numbers</li>
                <li>variables</li>
                <li>expressions</li>
                <li>objects (via <code>str()</code> or <code>repr()</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Usage of <code>print()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">print("Hello, world!")
a = 10
print(a)
print(a + 5)
</code></pre>

    <br/>
    <ul>
        <li>Each <code>print()</code> call ends with a newline by default.</li>
    </ul>

    <br/><br/>



    <li><b>Printing Multiple Values</b></li>
    <br/>
    <ul>
        <li><code>print()</code> accepts any number of arguments:</li>
    </ul>

<pre><code class="language-python line-numbers">print("Sum:", 3 + 5)
print("Coordinates:", x, y, z)
</code></pre>

    <br/>
    <ul>
        <li>Arguments are separated by spaces unless changed (see <code>sep</code> parameter below).</li>
    </ul>

    <br/><br/>



    <li><b>Important Parameters: <code>sep</code> and <code>end</code></b></li>
    <br/>
    <ul><li><b><code>sep</code></b>: separator between items</li></ul>

<pre><code class="language-python line-numbers">print("a", "b", "c", sep="-")
# a-b-c
</code></pre>

    <br/>

    <ul><li><b><code>end</code></b>: what to print at the end</li></ul>

<pre><code class="language-python line-numbers">print("Hello", end="...")
print("World")
# Output: Hello...World
</code></pre>

    <br/><br/>



    <li><b>Printing Without Newline</b></li>
    <br/>
    <ul>
        <li>Set <code>end=""</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">print("Loading", end="")
print(".", end="")
print(".", end="")
print(".", end="")
</code></pre>

    <br/><br/>



    <li><b>Formatted Output (f-strings)</b></li>
    <br/>
    <ul>
        <li>Python's modern formatting uses f-strings:</li>
    </ul>

<pre><code class="language-python line-numbers">name = "Ammy"
age = 25
print(f"{name} is {age} years old.")
</code></pre>

    <br/>
    <ul>
        <li>Format expressions inside <code>{}</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">print(f"2 + 2 = {2 + 2}")
</code></pre>

    <br/><br/>



    <li><b>Advanced f-string Formatting</b></li>
    <br/>

    <ul><li><b>Formatting numbers</b></li></ul>

<pre><code class="language-python line-numbers">pi = 3.1415926535
print(f"{pi:.2f}")     # 3.14
print(f"{pi:10.4f}")   # padded
</code></pre>

    <ul><li><b>Alignment</b></li></ul>

<pre><code class="language-python line-numbers">print(f"|{42:&gt;5}|")    # right-aligned
print(f"|{42:&lt;5}|")    # left-aligned
print(f"|{42:^5}|")    # centered
</code></pre>

    <br/><br/>



    <li><b>Old-Style Formatting (Not Recommended)</b></li>
    <br/>

<pre><code class="language-python line-numbers">print("%s is %d years old" % ("Bob", 30))
</code></pre>

    <br/>

<pre><code class="language-python line-numbers">print("Name: {}, Age: {}".format("Bob", 30))
</code></pre>

    <br/>
    <ul>
        <li>Kept for legacy compatibility; f-strings are preferred.</li>
    </ul>

    <br/><br/>



    <li><b>Printing Objects</b></li>
    <br/>
    <ul><li><b><code>print()</code> calls <code>str()</code></b> on objects:</li></ul>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name):
        self.name = name

p = Person("Ammy")
print(p)   # default: &lt;__main__.Person object at ...&gt;
</code></pre>

    <br/>
    <ul><li>Define <code>__str__()</code> for nicer output:</li></ul>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"Person({self.name})"

p = Person("Ammy")
print(p)
</code></pre>

    <br/><br/>



    <li><b>Printing Debug Information</b></li>
    <br/>

<pre><code class="language-python line-numbers">value = 123
print(f"{value = }")
# value = 123
</code></pre>

    <br/>
    <ul>
        <li>This shorthand prints both the variable name and its value.</li>
    </ul>

    <br/><br/>



    <li><b>Redirecting Output</b></li>
    <br/>
    <ul><li><b>To a file</b></li></ul>

<pre><code class="language-python line-numbers">with open("output.txt", "w") as f:
    print("Hello file!", file=f)
</code></pre>

    <br/>
    <ul><li><b>To a custom stream</b></li></ul>

<pre><code class="language-python line-numbers">import sys
print("Error!", file=sys.stderr)
</code></pre>

    <br/><br/>



    <li><b>Printing Complex Data Structures</b></li>
    <br/>

<pre><code class="language-python line-numbers">users = [{"id": 1}, {"id": 2}]
print(users)
</code></pre>

    <br/>
    <ul><li>Pretty-printing (beautiful formatted output):</li></ul>

<pre><code class="language-python line-numbers">import pprint
pprint.pprint(users)
</code></pre>

    <br/><br/>



    <li><b>Flushing Output</b></li>
    <br/>
    <ul>
        <li>Use <code>flush=True</code> to force immediate output:</li>
    </ul>

<pre><code class="language-python line-numbers">print("Processing...", flush=True)
</code></pre>

    <br/>
    <ul>
        <li>Useful for long-running scripts or real-time logs.</li>
    </ul>

    <br/><br/>



    <li><b>Printing Without Spaces Between Arguments</b></li>
    <br/>

<pre><code class="language-python line-numbers">print("A", "B", "C", sep="")
# ABC
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>print()</code></td>
                <td>Main function for output in Python</td>
            </tr>
            <tr>
                <td>sep</td>
                <td>Separator between items</td>
            </tr>
            <tr>
                <td>end</td>
                <td>What to print after line (default newline)</td>
            </tr>
            <tr>
                <td>f-strings</td>
                <td>Modern and recommended formatting style</td>
            </tr>
            <tr>
                <td>Redirecting output</td>
                <td>Use <code>file=</code> to print to files or stderr</td>
            </tr>
            <tr>
                <td>Pretty printing</td>
                <td><code>pprint</code> prints complex nested structures cleanly</td>
            </tr>
            <tr>
                <td>flush</td>
                <td>Force immediate printing</td>
            </tr>
            <tr>
                <td>Debug printing</td>
                <td>Use <code>{var = }</code> in f-strings</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-rw-files">Reading and Writing Files in Python</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python provides built-in tools for reading and writing files using the <code>open()</code> function.</li>
        <br/>
        <li>Working with files involves:
            <ul>
                <li>opening a file</li>
                <li>reading or writing</li>
                <li>closing the file (automatically handled using <code>with</code>)</li>
            </ul>
        </li>
        <br/>
        <li>Python supports text files, binary files, and different file modes.</li>
    </ul>
    <br/><br/>



    <li><b>The <code>open()</code> Function</b></li>
    <br/>

<pre><code class="language-python line-numbers">f = open("data.txt", "r")   # r = read mode
</code></pre>

    <br/>
    <ul>
        <li><code>open()</code> returns a file object.</li>
        <li>Always specify a mode to avoid confusion.</li>
    </ul>

    <br/>
    <table>
        <thead>
            <tr>
                <th>Mode</th>
                <th>Meaning</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>r</code></td>
                <td>Read</td>
                <td>File must exist</td>
            </tr>
            <tr>
                <td><code>w</code></td>
                <td>Write</td>
                <td>Overwrite or create new file</td>
            </tr>
            <tr>
                <td><code>a</code></td>
                <td>Append</td>
                <td>Add to the end of file</td>
            </tr>
            <tr>
                <td><code>r+</code></td>
                <td>Read/Write</td>
                <td>File must exist</td>
            </tr>
            <tr>
                <td><code>b</code></td>
                <td>Binary</td>
                <td>Combine with other modes: <code>rb</code>, <code>wb</code></td>
            </tr>
            <tr>
                <td><code>t</code></td>
                <td>Text</td>
                <td>Default mode</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Using <code>with</code> for Safe File Handling</b></li>
    <br/>
    <ul>
        <li>The recommended way to manage files:</li>
    </ul>

<pre><code class="language-python line-numbers">with open("data.txt", "r") as f:
    content = f.read()
</code></pre>
    <ul>
        <li><code>with</code> automatically closes the file, even if an error occurs.</li>
    </ul>

    <br/><br/>



    <li><b>Reading Files</b></li>
    <br/>

    <ul><li><b>Read entire file</b></li></ul>

<pre><code class="language-python line-numbers">with open("data.txt", "r") as f:
    text = f.read()
</code></pre>

    <br/>

    <ul><li><b>Read line-by-line</b></li></ul>

<pre><code class="language-python line-numbers">with open("data.txt") as f:
    for line in f:
        print(line.strip())
</code></pre>

    <br/>

    <ul><li><b>Read all lines into a list</b></li></ul>

<pre><code class="language-python line-numbers">with open("data.txt") as f:
    lines = f.readlines()
</code></pre>

    <br/>

    <ul><li><b>Read a fixed number of characters</b></li></ul>

<pre><code class="language-python line-numbers">with open("data.txt") as f:
    partial = f.read(10)   # read first 10 chars
</code></pre>

    <br/><br/>



    <li><b>Writing Files</b></li>
    <br/>

    <ul><li><b>Overwrite file (write mode)</b></li></ul>

<pre><code class="language-python line-numbers">with open("output.txt", "w") as f:
    f.write("Hello world\n")
</code></pre>

    <br/>

    <ul><li><b>Append to file</b></li></ul>

<pre><code class="language-python line-numbers">with open("output.txt", "a") as f:
    f.write("Another line\n")
</code></pre>

    <br/>

    <ul><li><b>Writing multiple lines</b></li></ul>

<pre><code class="language-python line-numbers">lines = ["a\n", "b\n", "c\n"]

with open("letters.txt", "w") as f:
    f.writelines(lines)
</code></pre>

    <br/><br/>



    <li><b>Binary Files</b></li>
    <br/>
    <ul>
        <li>Used for images, ZIP files, PDFs, etc.</li>
    </ul>

<pre><code class="language-python line-numbers">with open("image.png", "rb") as f:
    data = f.read()
</code></pre>

<pre><code class="language-python line-numbers">with open("copy.png", "wb") as f:
    f.write(data)
</code></pre>

    <br/><br/>



    <li><b>File Paths</b></li>
    <br/>
    <ul>
        <li>You can use relative or absolute paths:</li>
    </ul>

<pre><code class="language-python line-numbers">open("subfolder/data.txt")
open("/home/user/file.txt")
open("C:\\Users\\John\\file.txt")
</code></pre>

    <br/>
    <ul>
        <li>Use raw strings for Windows paths:</li>
    </ul>

<pre><code class="language-python line-numbers">open(r"C:\folder\file.txt")
</code></pre>

    <br/><br/>


    <li><b>Checking File Existence</b></li>
    <br/>

<pre><code class="language-python line-numbers">from pathlib import Path

p = Path("data.txt")
if p.exists():
    print("File exists!")
</code></pre>

    <br/><br/>



    <li><b>Error Handling for File Operations</b></li>
    <br/>

<pre><code class="language-python line-numbers">try:
    with open("no_such_file.txt") as f:
        data = f.read()
except FileNotFoundError:
    print("File does not exist")
</code></pre>

    <br/>

<pre><code class="language-python line-numbers">except PermissionError:
    print("Permission denied")
</code></pre>

    <br/><br/>



    <li><b>Reading and Writing JSON Files</b></li>
    <br/>

<pre><code class="language-python line-numbers">import json

with open("config.json") as f:
    data = json.load(f)
</code></pre>

<pre><code class="language-python line-numbers">with open("output.json", "w") as f:
    json.dump(data, f, indent=2)
</code></pre>

    <br/><br/>



    <li><b>Reading and Writing CSV Files</b></li>
    <br/>

<pre><code class="language-python line-numbers">import csv

with open("data.csv") as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
</code></pre>

<pre><code class="language-python line-numbers">import csv

rows = [["id", "name"], [1, "Ammy"]]
with open("out.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(rows)
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Task</th>
                <th>Method</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Open a file</td>
                <td><code>open(path, mode)</code></td>
            </tr>
            <tr>
                <td>Safe open</td>
                <td><code>with open(...)</code></td>
            </tr>
            <tr>
                <td>Read all</td>
                <td><code>f.read()</code></td>
            </tr>
            <tr>
                <td>Read line-by-line</td>
                <td>Iterate file object</td>
            </tr>
            <tr>
                <td>Write to file</td>
                <td><code>f.write()</code></td>
            </tr>
            <tr>
                <td>Binary mode</td>
                <td><code>"rb"</code>, <code>"wb"</code></td>
            </tr>
            <tr>
                <td>Modern paths</td>
                <td><code>pathlib.Path</code></td>
            </tr>
            <tr>
                <td>Error handling</td>
                <td>Use <code>try/except</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-errors-exceptions">Errors and Exceptions in Python</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Errors happen when something goes wrong during program execution.</li>
        <li>Python uses a system called <u>exceptions</u> to report and handle these problems.</li>
        <li>If an exception is not handled, the program will stop and display a traceback.</li>
    </ul>
    <br/><br/>



    <li><b>Two Main Types of Errors</b></li>
    <br/>
    <ul>
        <li><b>Syntax Errors</b>: mistakes in the code structure</li>
        <li><b>Exceptions</b>: errors that occur during execution</li>
    </ul>
    <br/>

<pre><code class="language-python line-numbers"># Syntax error example
if True
    print("hello")</code></pre>

<pre><code class="language-python line-numbers"># Runtime exception example
x = 10 / 0
</code></pre>

    <br/><br/>



    <li><b>Common Built-in Exceptions</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Exception</th>
                <th>When It Happens</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>SyntaxError</code></td>
                <td>Invalid Python code</td>
            </tr>
            <tr>
                <td><code>NameError</code></td>
                <td>Variable or name not found</td>
            </tr>
            <tr>
                <td><code>TypeError</code></td>
                <td>Wrong type used in an operation</td>
            </tr>
            <tr>
                <td><code>ValueError</code></td>
                <td>Correct type, but invalid value</td>
            </tr>
            <tr>
                <td><code>ZeroDivisionError</code></td>
                <td>Division by zero</td>
            </tr>
            <tr>
                <td><code>IndexError</code></td>
                <td>Out-of-bound list or tuple index</td>
            </tr>
            <tr>
                <td><code>KeyError</code></td>
                <td>Missing key in dictionary</td>
            </tr>
            <tr>
                <td><code>FileNotFoundError</code></td>
                <td>File does not exist</td>
            </tr>
            <tr>
                <td><code>PermissionError</code></td>
                <td>No permission to access resource</td>
            </tr>
            <tr>
                <td><code>ImportError</code></td>
                <td>Module cannot be imported</td>
            </tr>
            <tr>
                <td><code>AssertionError</code></td>
                <td>Assertion fails</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Handling Exceptions with <code>try/except</code></b></li>
<pre><code class="language-python line-numbers">try:
    x = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")
</code></pre>
    <ul>
        <li>The program continues running normally after the except block.</li>
    </ul>

    <br/><br/>



    <li><b>Handling Multiple Different Exceptions</b></li>
<pre><code class="language-python line-numbers">try:
    n = int(input("Enter a number: "))
    result = 10 / n
except ValueError:
    print("You did not enter a valid integer.")
except ZeroDivisionError:
    print("Cannot divide by zero.")
</code></pre>

    <br/><br/>



    <li><b>Catching Multiple Exceptions in One Block</b></li>
<pre><code class="language-python line-numbers">try:
    x = int("abc")
except (ValueError, TypeError):
    print("Something is wrong with the input.")
</code></pre>

    <br/><br/>



    <li><b>Using <code>else</code> in Exception Handling</b></li>
    <br/>
    <ul>
        <li>The <code>else</code> block runs only if no exception occurs.</li>
    </ul>

<pre><code class="language-python line-numbers">try:
    f = open("data.txt")
except FileNotFoundError:
    print("File not found.")
else:
    print("File opened successfully!")
    f.close()
</code></pre>

    <br/><br/>



    <li><b>The <code>finally</code> Block</b></li>
    <br/>
    <ul>
        <li>Always executes, no matter what happens.</li>
        <li>Often used for cleanup: closing files, releasing resources, unlocking locks.</li>
    </ul>

<pre><code class="language-python line-numbers">try:
    f = open("data.txt")
    data = f.read()
except FileNotFoundError:
    print("Missing file.")
finally:
    print("Closing file.")
    f.close()
</code></pre>

    <br/><br/>



    <li><b>Raising Exceptions Yourself</b></li>
<pre><code class="language-python line-numbers">raise ValueError("Invalid data format")</code></pre>

    <br/>
    <ul>
        <li>You can raise exceptions to signal errors in your program.</li>
    </ul>

    <br/><br/>



    <li><b>Creating Custom Exceptions</b></li>
<pre><code class="language-python line-numbers">class NegativeNumberError(Exception):
    pass

def check(n):
    if n &lt; 0:
        raise NegativeNumberError("No negative numbers allowed!")

check(-5)
</code></pre>

    <br/>
    <ul>
        <li>Custom exceptions inherit from <code>Exception</code>.</li>
        <li>Useful in large programs, libraries, or frameworks.</li>
    </ul>

    <br/><br/>



    <li><b>Accessing Exception Details</b></li>
<pre><code class="language-python line-numbers">try:
    1 / 0
except Exception as e:
    print(type(e))
    print(e)
</code></pre>
    <ul>
        <li><code>e</code> contains the error message and type.</li>
    </ul>

    <br/><br/>



    <li><b>Ignoring Exceptions (Not Recommended)</b></li>
<pre><code class="language-python line-numbers">try:
    risky_action()
except:
    pass
</code></pre>
    <ul>
        <li>This silently hides errors ‚Üí debugging becomes difficult.</li>
        <li>At minimum, catch specific exceptions.</li>
    </ul>
    <br/><br/>



    <li><b>Exception Hierarchy (Simplified)</b></li>
    <br/>

<pre><code class="language-python">
BaseException
 ‚îú‚îÄ‚îÄ SystemExit
 ‚îú‚îÄ‚îÄ KeyboardInterrupt
 ‚îî‚îÄ‚îÄ Exception
      ‚îú‚îÄ‚îÄ ValueError
      ‚îú‚îÄ‚îÄ TypeError
      ‚îú‚îÄ‚îÄ RuntimeError
      ‚îú‚îÄ‚îÄ OSError
      ‚îî‚îÄ‚îÄ ...
</code></pre>

    <br/>
    <ul>
        <li><b>Never</b> catch <code>BaseException</code> or <code>Exception</code> unless necessary.</li>
        <li>They catch almost everything, including system signals.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>SyntaxError</td>
                <td>Code structure error caught before execution</td>
            </tr>
            <tr>
                <td>Exception</td>
                <td>Runtime error during program execution</td>
            </tr>
            <tr>
                <td>try/except</td>
                <td>Catch and handle exceptions</td>
            </tr>
            <tr>
                <td>else</td>
                <td>Runs only if no exception occurs</td>
            </tr>
            <tr>
                <td>finally</td>
                <td>Always runs (cleanup)</td>
            </tr>
            <tr>
                <td>raise</td>
                <td>Manually trigger exceptions</td>
            </tr>
            <tr>
                <td>Custom exceptions</td>
                <td>Define your own error types</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-custom-exceptions">Custom Exceptions in Python</h3>
<ol>
    <li><b>Why Define Custom Exceptions?</b></li>
    <br/>
    <ul>
        <li>Built-in exceptions like <code>ValueError</code>, <code>TypeError</code>, <code>FileNotFoundError</code> are generic.</li>
        <br/>
        <li>In non-trivial programs, you often want to distinguish:
            <ul>
                <li><code>InvalidUserInputError</code></li>
                <li><code>ConfigNotFoundError</code></li>
                <li><code>PaymentFailedError</code></li>
                <li><code>RateLimitExceededError</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Custom Exception</b></li>
    <br/>
    <ul>
        <li>All user-defined exceptions should ultimately inherit from <code>Exception</code> (not from <code>BaseException</code>).</li>
    </ul>

<pre><code class="language-python line-numbers">class MyError(Exception):
    pass

def do_stuff():
    raise MyError("Something went wrong!")

try:
    do_stuff()
except MyError as e:
    print("Caught MyError:", e)
</code></pre>

    <br/>
    <ul>
        <li><code>pass</code> is enough if you do not need extra attributes.</li>
        <li>The message is passed to the base <code>Exception</code> class.</li>
    </ul>
    <br/><br/>



    <li><b>Adding Custom Information</b></li>
    <br/>
    <ul>
        <li>You can store extra context on the exception object:</li>
    </ul>

<pre><code class="language-python line-numbers">class ConfigError(Exception):
    def __init__(self, key: str, message: str):
        self.key = key
        self.message = message
        super().__init__(f"[{key}] {message}")

def load_config(key: str) -&gt; str:
    # imagine it fails
    raise ConfigError(key, "Missing configuration value")

try:
    load_config("DB_HOST")
except ConfigError as e:
    print("Config error for key:", e.key)
    print("Details:", e.message)
</code></pre>

    <br/>
    <ul>
        <li>Pattern:
            <ul>
                <li>Store raw data in attributes (<code>key</code>, <code>code</code>, etc.)</li>
                <li>Pass a human-readable message to <code>super().__init__</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Exception Hierarchies for a Project</b></li>
    <br/>
    <ul>
        <li>For a bigger project or library, define a base exception and derive others from it:</li>
    </ul>

<pre><code class="language-python line-numbers">class AppError(Exception):
    """Base class for all application-specific errors."""
    pass

class DatabaseError(AppError):
    pass

class NotFoundError(AppError):
    pass

class PermissionDeniedError(AppError):
    pass
</code></pre>

    <br/>
    <ul>
        <li>This allows:
            <ul>
                <li>catching a specific error &rarr; <code>DatabaseError</code></li>
                <li>catching all app errors &rarr; <code>AppError</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers">try:
    ...
except NotFoundError:
    print("Item not found, show 404")

except AppError:
    print("Some other app-level error")</code></pre>

    <br/><br/>



    <li><b>Choosing Good Exception Names</b></li>
    <br/>
    <ul>
        <li>Use clear, descriptive names ending with <code>Error</code>:
            <ul>
                <li><code>InvalidStateError</code></li>
                <li><code>AuthenticationError</code></li>
                <li><code>RateLimitError</code></li>
                <li><code>TimeoutError</code> (already exists in stdlib)</li>
            </ul>
        </li>
        <br/>
        <li>Make it obvious what went wrong just from the class name.</li>
    </ul>
    <br/><br/>



    <li><b>Wrapping Lower-Level Exceptions</b></li>
    <br/>
    <ul>
        <li>Often you want to convert low-level exceptions (e.g. <code>OSError</code>) into your own domain exceptions.</li>
    </ul>

<pre><code class="language-python line-numbers">class StorageError(Exception):
    pass

def read_user_file(path: str) -&gt; str:
    try:
        with open(path) as f:
            return f.read()
    except OSError as e:
        # wrap OS error in a domain-specific one
        raise StorageError(f"Could not read {path}") from e
</code></pre>

    <br/>
    <ul>
        <li>Using <code>raise ... from e</code>:
            <ul>
                <li>preserves the original traceback as the <b>cause</b></li>
                <li>shows both high-level and low-level errors in logs</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Custom Exceptions and <code>__str__</code> / <code>__repr__</code></b></li>
    <br/>
    <ul>
        <li>You can override <code>__str__</code> to control how the error is displayed:</li>
    </ul>

<pre><code class="language-python line-numbers">class ApiError(Exception):
    def __init__(self, status: int, message: str):
        self.status = status
        self.message = message
        super().__init__(message)

    def __str__(self) -&gt; str:
        return f"API error {self.status}: {self.message}"

raise ApiError(404, "Resource not found")
</code></pre>

    <br/>
    <ul>
        <li>Now <code>print(e)</code> shows a friendly message.</li>
    </ul>
    <br/><br/>



    <li><b>Custom Exceptions with Extra Context</b></li>
    <br/>
    <ul>
        <li>You can attach more structured information, not only text:</li>
    </ul>

<pre><code class="language-python line-numbers">class ValidationError(Exception):
    def __init__(self, field: str, errors: list[str]):
        self.field = field
        self.errors = errors
        message = f"Validation failed for '{field}': {', '.join(errors)}"
        super().__init__(message)

try:
    raise ValidationError("email", ["missing '@'", "too short"])
except ValidationError as e:
    print(e.field)      # email
    print(e.errors)     # ["missing '@'", "too short"]
</code></pre>

    <br/>
    <ul>
        <li>This is useful when your caller needs to inspect error details programmatically (e.g., web API validation).</li>
    </ul>
    <br/><br/>



    <li><b>Where to Put Custom Exceptions in a Project</b></li>
    <br/>
    <ul>
        <li>In small scripts: define them near where they are used.</li>
        <br/>
        <li>In larger projects or libraries:
            <ul>
                <li>put them in a dedicated module like <code>errors.py</code> or <code>exceptions.py</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-text line-numbers">myapp/
    __init__.py
    exceptions.py   # all custom exception classes
    models.py
    services.py
</code></pre>

<pre><code class="language-python line-numbers"># exceptions.py
class MyAppError(Exception):
    pass

class AuthError(MyAppError):
    pass

# services.py
from .exceptions import AuthError

def login(user, password):
    if not valid(user, password):
        raise AuthError("Invalid credentials")
</code></pre>

    <br/><br/>



    <li><b>Best Practices</b></li>
    <br/>
    <ul>
        <li><b>Always</b> inherit from <code>Exception</code> (or a subclass), not from <code>BaseException</code>.</li>
        <br/>
        <li>Use a <b>base exception</b> for your package or app:
            <ul>
                <li><code>MyLibError</code>, <code>MyAppError</code>, etc.</li>
            </ul>
        </li>
        <br/>
        <li>Do not overuse custom exceptions:
            <ul>
                <li>Sometimes <code>ValueError</code> or <code>TypeError</code> is enough.</li>
                <li>Create a custom class when:
                    <ul>
                        <li>you need to distinguish it from standard errors</li>
                        <li>it encodes a specific domain concept</li>
                    </ul>
                </li>
            </ul>
        </li>
        <br/>
        <li>Use <code>raise ... from e</code> when wrapping other exceptions.</li>
        <br/>
        <li>Give meaningful messages and store raw data as attributes.</li>
    </ul>
    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Recommendation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Base class</td>
                <td>Inherit from <code>Exception</code> (or a library-specific base error)</td>
            </tr>
            <tr>
                <td>Naming</td>
                <td>End with <code>Error</code>, be descriptive (e.g. <code>ConfigError</code>)</td>
            </tr>
            <tr>
                <td>Hierarchy</td>
                <td>Create a root <code>AppError</code> / <code>MyLibError</code> and derive others</td>
            </tr>
            <tr>
                <td>Extra data</td>
                <td>Store extra fields in attributes; pass a friendly message to <code>super().__init__</code></td>
            </tr>
            <tr>
                <td>Wrapping</td>
                <td>Use <code>raise NewError(...) from e</code> to keep original cause</td>
            </tr>
            <tr>
                <td>Location</td>
                <td>Large projects: put them in <code>exceptions.py</code> / <code>errors.py</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-classes">Python Classes</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Classes are the foundation of object-oriented programming (OOP) in Python.</li>
        <br/>
        <li>A class defines:
            <ul>
                <li>what data an object has (attributes)</li>
                <li>what an object can do (methods)</li>
            </ul>
        </li>
        <br/>
        <li>A class is like a blueprint, an object (instance) is a specific realization of that blueprint.</li>
    </ul>
    <br/><br/>



    <li><b>Creating a Class</b></li>
<pre><code class="language-python line-numbers">class Person:
    pass
</code></pre>
    <ul>
        <li>This defines a class called <code>Person</code> but with no attributes or methods yet.</li>
    </ul>

    <br/><br/>



    <li><b>Instantiating (Creating Objects)</b></li>
<pre><code class="language-python line-numbers">p = Person()
print(p)</code></pre>
    <ul>
        <li>Calling the class creates a new instance.</li>
    </ul>

    <br/><br/>



    <li><b>The <code>__init__</code> Method (Constructor)</b></li>
    <br/>
    <ul>
        <li>The constructor initializes new objects.</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name, age):
        self.name = name    # instance attribute
        self.age = age

p = Person("Alice", 25)
print(p.name)
print(p.age)
</code></pre>

    <br/>
    <ul>
        <li><code>self</code> refers to the instance being created.</li>
        <li>Attributes like <code>self.name</code> belong to each object separately.</li>
    </ul>

    <br/><br/>



    <li><b>Instance Attributes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

p1 = Point(1, 2)
p2 = Point(10, 20)

print(p1.x, p2.x)
</code></pre>
    <ul>
        <li>Each object has its own independent attributes.</li>
    </ul>

    <br/><br/>



    <li><b>Instance Methods</b></li>
    <br/>
    <ul>
        <li>Methods are functions that belong to a class.</li>
        <li>They always take <code>self</code> as the first argument.</li>
    </ul>

<pre><code class="language-python line-numbers">class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

c = Circle(5)
print(c.area())
</code></pre>

    <br/><br/>



    <li><b>Class Attributes</b></li>
    <br/>
    <ul>
        <li>Class attributes are shared by all instances.</li>
    </ul>

<pre><code class="language-python line-numbers">class Dog:
    species = "Canis lupus familiaris"   # class attribute

    def __init__(self, name):
        self.name = name     # instance attribute

d1 = Dog("Buddy")
d2 = Dog("Charlie")

print(d1.species, d2.species, Dog.species)
</code></pre>
    <ul>
        <li>Instance attributes override class attributes with the same name.</li>
    </ul>

    <br/><br/>



    <li><b>Methods vs Attributes (Key Concept)</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Stored Where?</th>
                <th>Shared?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Instance Attributes</td>
                <td>Inside each object</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Class Attributes</td>
                <td>On the class itself</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Methods</td>
                <td>On the class (as functions)</td>
                <td>Shared by all instances</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Special Methods (Dunder Methods)</b></li>
    <br/>
    <ul>
        <li>Python classes can override special methods to control built-in behavior.</li>
        <li>Some common examples:</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"Person({self.name})"

    def __repr__(self):
        return f"Person(name={self.name!r})"

p = Person("Alice")
print(p)        # calls __str__
print([p])      # calls __repr__
</code></pre>

    <br/>

        <li><b>Other useful dunders:</b></li>
    <ul>
        <li><code>__len__</code>: length() behavior</li>
        <li><code>__eq__</code>: == operator</li>
        <li><code>__lt__</code>, <code>__gt__</code>: ordering</li>
        <li><code>__add__</code>, <code>__mul__</code>: operator overloading</li>
        <li><code>__enter__</code>, <code>__exit__</code>: context managers</li>
    </ul>

    <br/><br/>



    <li><b>Class Methods</b></li>
    <br/>
    <ul>
        <li>Defined with <code>@classmethod</code>.</li>
        <li>Receive the class (<code>cls</code>) instead of an object (<code>self</code>).</li>
    </ul>

<pre><code class="language-python line-numbers">class User:
    count = 0

    def __init__(self):
        User.count += 1

    @classmethod
    def how_many(cls):
        return cls.count

print(User.how_many())</code></pre>

    <br/><br/>



    <li><b>Static Methods</b></li>
    <br/>
    <ul>
        <li>Defined with <code>@staticmethod</code>.</li>
        <li>No <code>self</code> and no <code>cls</code>.</li>
        <li>Just a function living inside a class namespace.</li>
    </ul>

<pre><code class="language-python line-numbers">class Math:
    @staticmethod
    def add(a, b):
        return a + b

print(Math.add(2, 3))
</code></pre>

    <br/><br/>



    <li><b>Inheritance</b></li>
    <br/>
    <ul>
        <li>One class can inherit from another to reuse behavior.</li>
    </ul>

<pre><code class="language-python line-numbers">class Animal:
    def speak(self):
        return "..."

class Dog(Animal):
    def speak(self):
        return "Woof!"

d = Dog()
print(d.speak())</code></pre>

    <br/><br/>



    <li><b>Calling the Parent Class</b></li>
<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name):
        self.name = name

class Employee(Person):
    def __init__(self, name, salary):
        super().__init__(name)    # calls Person.__init__
        self.salary = salary
</code></pre>

    <br/><br/>



    <li><b>Multiple Inheritance</b></li>
    <br/>
    <ul>
        <li>Python supports it, but use with caution.</li>
    </ul>

<pre><code class="language-python line-numbers">class A: pass
class B: pass
class C(A, B): pass
</code></pre>

    <br/>
    <ul>
        <li>Method resolution order (MRO) decides lookup order.</li>
    </ul>

    <br/><br/>



    <li><b>Encapsulation / Access Control</b></li>
    <br/>

    <ul><li><b>Public attribute</b> ‚Äî free access</li></ul>

<pre><code class="language-python line-numbers">self.name</code></pre>

    <ul><li><b>Protected attribute</b> ‚Äî convention only</li></ul>

<pre><code class="language-python line-numbers">self._internal_value</code></pre>

    <ul><li><b>Private attribute</b> ‚Äî name-mangled</li></ul>

<pre><code class="language-python line-numbers">self.__secret</code></pre>

    <br/>
    <ul>
        <li>Private attributes become <code>_ClassName__secret</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Properties (Getters/Setters in Pythonic Way)</b></li>
<pre><code class="language-python line-numbers">class Person:
    def __init__(self, age):
        self._age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value &lt; 0:
            raise ValueError("Age cannot be negative")
        self._age = value



p = Person(20)

print(p.age)      # uses the @property -&gt; calls age(self)
# 20

p.age = 25        # uses @age.setter -&gt; calls age(self, 25)
print(p.age)
# 25

p.age = -5        # also calls the setter
# ValueError: Age cannot be negative
</code></pre>

    <br/>
    <ul>
        <li><code>@property</code> is the Pythonic alternative to Java-style getters/setters.</li>
    </ul>

    <br/><br/>



    <li><b>Dataclasses (Python 3.7+ Convenience)</b></li>
<pre><code class="language-python line-numbers">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

p = Point(4, 5)
print(p)
</code></pre>

    <br/>
    <ul>
        <li>Automatically adds:
            <ul>
                <li><code>__init__</code></li>
                <li><code>__repr__</code></li>
                <li><code>__eq__</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Instance attribute</td>
                <td>Per-object data, stored on each instance</td>
            </tr>
            <tr>
                <td>Class attribute</td>
                <td>Shared across all instances</td>
            </tr>
            <tr>
                <td>Instance method</td>
                <td>Methods that operate on object state (<code>self</code>)</td>
            </tr>
            <tr>
                <td>Class method</td>
                <td>Receives <code>cls</code>; often constructors or class utilities</td>
            </tr>
            <tr>
                <td>Static method</td>
                <td>Namespace-only function inside class</td>
            </tr>
            <tr>
                <td>Dunder methods</td>
                <td>Customize behavior (printing, math, comparisons, etc.)</td>
            </tr>
            <tr>
                <td>Inheritance</td>
                <td>Reuse and extend behavior of other classes</td>
            </tr>
            <tr>
                <td>Dataclasses</td>
                <td>Auto-generated methods for simple data containers</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-dataclasses">Python Dataclasses</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>dataclass</code> is a Python feature (introduced in Python 3.7) that automatically generates common boilerplate code for classes.</li>
        <br/>
        <li>Without it, you would manually write:
            <ul>
                <li><code>__init__</code></li>
                <li><code>__repr__</code></li>
                <li><code>__eq__</code></li>
                <li>optionally, <code>__lt__</code>, <code>__hash__</code>, etc.</li>
            </ul>
        </li>
        <br/>
        <li>Dataclasses generate these methods automatically, reducing boilerplate and improving readability.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Dataclass</b></li>
    <br/>

<pre><code class="language-python line-numbers">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

p = Point(1, 2)
print(p)          # Point(x=1, y=2)
</code></pre>

    <br/>
    <ul>
        <li>Automatically created:
            <ul>
                <li><code>__init__(self, x, y)</code></li>
                <li><code>__repr__</code></li>
                <li><code>__eq__</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Type Annotations Are Required</b></li>
    <br/>
    <ul>
        <li>Dataclasses use type annotations to define fields.</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass
class Item:
    name: str
    price: float
</code></pre>
    <ul>
        <li>Without a type annotation, the dataclass will not treat it as a field.</li>
    </ul>

    <br/><br/>



    <li><b>Default Values</b></li>
<pre><code class="language-python line-numbers">@dataclass
class User:
    name: str
    active: bool = True

u = User("Alice")
print(u.active)   # True
</code></pre>
    <ul>
        <li>Fields with defaults must come after non-default fields, same as normal Python classes.</li>
    </ul>

    <br/><br/>



    <li><b>Default Factory for Mutable Values</b></li>
    <br/>
    <ul>
        <li><b>Never</b> use a mutable default directly (e.g., <code>[]</code>, <code>{}</code>).</li>
        <li>Use <code>field(default_factory=...)</code> to generate a fresh object each time.</li>
    </ul>

<pre><code class="language-python line-numbers">from dataclasses import dataclass, field

@dataclass
class Bag:
    items: list[str] = field(default_factory=list)

b1 = Bag()
b2 = Bag()
b1.items.append("apple")
print(b2.items)   # []  (correct!)
</code></pre>

    <br/><br/>



    <li><b>Immutability with <code>frozen=True</code></b></li>
    <br/>
    <ul>
        <li>Frozen dataclasses create immutable objects (like namedtuples).</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass(frozen=True)
class Color:
    r: int
    g: int
    b: int

c = Color(10, 20, 30)
# c.r = 99  # error: cannot modify frozen dataclass
</code></pre>

    <br/>
    <ul>
        <li>Useful for safe value objects, configuration, caching, and dictionary keys.</li>
    </ul>

    <br/><br/>



    <li><b>Comparison Methods</b></li>
    <br/>
    <ul>
        <li>Dataclasses implement comparisons based on fields:</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass(order=True)
class Score:
    value: int

print(Score(5) &lt; Score(10))  # True
</code></pre>

    <br/>
    <ul>
        <li>To disable comparisons:</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass(eq=False)
class Node:
    id: int
</code></pre>

    <br/><br/>



    <li><b>Post-Initialization with <code>__post_init__</code></b></li>
    <br/>
    <ul>
        <li>This method runs right after <code>__init__</code> finishes.</li>
        <li>Useful for validation or computed fields.</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass
class Product:
    name: str
    price: float

    def __post_init__(self):
        if self.price &lt; 0:
            raise ValueError("Price cannot be negative")

Product("Book", 20)    # OK
Product("Free", -5)    # error!
</code></pre>

    <br/><br/>



    <li><b>Excluding Fields from Dataclasses</b></li>
    <br/>
    <ul>
        <li>Fields that should not appear in <code>__init__</code>, <code>__repr__</code>, etc. can be customized:</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass
class Cache:
    url: str
    data: bytes = field(repr=False)     # hide from repr
    expires: int = field(init=False)    # not passed to __init__

    def __post_init__(self):
        self.expires = 3600</code></pre>

    <br/><br/>



    <li><b>Make Dataclass Hashable</b></li>
    <br/>

<pre><code class="language-python line-numbers">@dataclass(frozen=True)
class Coordinate:
    x: int
    y: int

s = {Coordinate(1, 2)}
</code></pre>

    <br/>
    <ul>
        <li>Frozen dataclasses are automatically hashable.</li>
        <li>Non-frozen ones are not, unless you explicitly set <code>unsafe_hash=True</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Customizing Field Ordering</b></li>
    <br/>
    <ul>
        <li>You can exclude specific fields from comparisons:</li>
    </ul>

<pre><code class="language-python line-numbers">@dataclass(order=True)
class Item:
    sort_index: int = field(init=False, repr=False)
    name: str
    price: float

    def __post_init__(self):
        self.sort_index = self.price</code></pre>

    <br/><br/>



    <li><b>Inheritance with Dataclasses</b></li>
    <br/>

<pre><code class="language-python line-numbers">@dataclass
class Animal:
    name: str

@dataclass
class Dog(Animal):
    breed: str

d = Dog("Snoopy", "Beagle")
print(d)
</code></pre>

    <br/>
    <ul>
        <li>Parent fields come first in generated <code>__init__</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Asdict and Astuple Conversion</b></li>
    <br/>

<pre><code class="language-python line-numbers">from dataclasses import asdict, astuple

p = Point(3, 4)

print(asdict(p))   # {'x': 3, 'y': 4}
print(astuple(p))  # (3, 4)
</code></pre>

    <br/>
    <ul>
        <li>Very useful for JSON serialization, logging, exporting, etc.</li>
    </ul>

    <br/><br/>



    <li><b>Dataclass vs. NamedTuple vs. TypedDict</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Dataclass</th>
                <th>NamedTuple</th>
                <th>TypedDict</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Mutability</td>
                <td>Mutable (unless frozen)</td>
                <td>Immutable</td>
                <td>Mutable</td>
            </tr>
            <tr>
                <td>Methods</td>
                <td>Allows custom methods</td>
                <td>Methods possible, but inconvenient</td>
                <td>No methods</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Good</td>
                <td>Very high</td>
                <td>Good</td>
            </tr>
            <tr>
                <td>Primary Use</td>
                <td>General data modeling</td>
                <td>Lightweight records</td>
                <td>JSON-like dict structures with types</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Automatic methods</td>
                <td>Creates <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code> automatically</td>
            </tr>
            <tr>
                <td>Default factory</td>
                <td>Safely create mutable defaults</td>
            </tr>
            <tr>
                <td>Frozen</td>
                <td>Immutability support (hashable)</td>
            </tr>
            <tr>
                <td>Order</td>
                <td>Enable comparison operators</td>
            </tr>
            <tr>
                <td>Post-init</td>
                <td>Custom setup via <code>__post_init__</code></td>
            </tr>
            <tr>
                <td>Field customization</td>
                <td>Full control with <code>field()</code></td>
            </tr>
            <tr>
                <td>asdict / astuple</td>
                <td>Convert to dict / tuple</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-class-inheritance">Python Class Inheritance</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Inheritance allows a class to reuse, extend, or modify the behavior of another class.</li>
        <li>The existing class is the <b>base class</b> (or parent class).</li>
        <li>The new class is the <b>derived class</b> (or child class).</li>
        <br/>
        <li>Inheritance reduces code duplication and expresses logical relationships like:
            <ul>
                <li><code>Dog</code> is an <code>Animal</code></li>
                <li><code>ElectricCar</code> is a <code>Car</code></li>
                <li><code>AdminUser</code> is a <code>User</code></li>
            </ul>
        </li>
        <br/>
        <li>Python supports:
            <ul>
                <li>single inheritance</li>
                <li>multiple inheritance</li>
                <li>method overriding</li>
                <li>super() calls</li>
                <li>MRO (method resolution order)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Inheritance</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Animal:
    def speak(self):
        return "..."

class Dog(Animal):
    def speak(self):
        return "Woof!"

d = Dog()
print(d.speak())     # "Woof!"
</code></pre>

    <br/>
    <ul>
        <li><code>Dog</code> inherits from <code>Animal</code>.</li>
        <li><code>Dog</code> overrides the <code>speak()</code> method.</li>
    </ul>

    <br/><br/>



    <li><b>Using <code>super()</code> to Call Parent Methods</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name):
        self.name = name

class Employee(Person):
    def __init__(self, name, salary):
        super().__init__(name)      # calls Person.__init__
        self.salary = salary

e = Employee("Alice", 5000)
print(e.name, e.salary)
</code></pre>

    <br/>
    <ul>
        <li><code>super()</code> ensures proper method resolution order, especially in multiple inheritance.</li>
    </ul>

    <br/><br/>



    <li><b>Extending Methods Instead of Replacing</b></li>
<pre><code class="language-python line-numbers">class Logger:
    def log(self, msg):
        print("Log:", msg)

class TimestampLogger(Logger):
    def log(self, msg):
        from datetime import datetime
        ts = datetime.now().isoformat()
        super().log(f"[{ts}] {msg}")
</code></pre>
    <ul>
        <li>Child class method extends parent behavior.</li>
    </ul>

    <br/><br/>



    <li><b>Inheritance of Attributes and Methods</b></li>
    <br/>
    <ul>
        <li>Child classes inherit:
            <ul>
                <li>instance methods</li>
                <li>class methods</li>
                <li>static methods</li>
                <li>class attributes</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers">class Vehicle:
    wheels = 4

class Car(Vehicle):
    pass

print(Car.wheels)   # 4
</code></pre>

    <br/><br/>



    <li><b>Overriding Attributes</b></li>
<pre><code class="language-python line-numbers">class Vehicle:
    wheels = 4

class Motorcycle(Vehicle):
    wheels = 2

print(Motorcycle.wheels)   # 2
</code></pre>

    <br/><br/>



    <li><b>Checking Inheritance Relationships</b></li>
<pre><code class="language-python line-numbers">issubclass(Dog, Animal)     # True
isinstance(Dog(), Animal)   # True
</code></pre>

    <br/>
    <ul>
        <li><code>issubclass()</code> checks class-level relationships.</li>
        <li><code>isinstance()</code> checks object-level relationships.</li>
    </ul>

    <br/><br/>



    <li><b>Multiple Inheritance</b></li>
    <br/>
    <ul>
        <li>Python allows a class to inherit from multiple classes.</li>
        <li>Useful but must be used carefully.</li>
    </ul>

<pre><code class="language-python line-numbers">class Flyer:
    def action(self):
        return "flying"

class Swimmer:
    def action(self):
        return "swimming"

class Duck(Flyer, Swimmer):
    pass

d = Duck()
print(d.action())     # "flying"  (Flyer is first)
</code></pre>

    <br/>
    <ul>
        <li>Python resolves method calls using <b>MRO</b> (Method Resolution Order).</li>
        <li>Here, <code>Flyer</code> is checked before <code>Swimmer</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Method Resolution Order (MRO)</b></li>
    <br/>
    <ul>
        <li>Determines which class Python looks in first when finding an attribute or method.</li>
        <li>Use <code>.mro()</code> to inspect it:</li>
    </ul>

<pre><code class="language-python line-numbers">print(Duck.mro())
</code></pre>

    <br/>
    <ul>
        <li>MRO uses the <b>C3 linearization algorithm</b> ensuring:
            <ul>
                <li>consistent order</li>
                <li>left-to-right priority</li>
                <li>parents before grandparents</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Using <code>super()</code> with Multiple Inheritance</b></li>
    <br/>
    <ul>
        <li>Because of MRO, <code>super()</code> works across multiple inheritance trees.</li>
    </ul>

<pre><code class="language-python line-numbers">class A:
    def go(self):
        print("A.go")

class B(A):
    def go(self):
        super().go()
        print("B.go")

class C(A):
    def go(self):
        super().go()
        print("C.go")

class D(B, C):
    pass

D().go()
</code></pre>

Output:

<pre><code class="language-text">A.go
C.go
B.go
</code></pre>

    <br/>
    <ul>
        <li>Order follows <code>D.mro()</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Abstract Base Classes (ABC)</b></li>
    <br/>
    <ul>
        <li>Used to force child classes to implement specific methods.</li>
    </ul>

<pre><code class="language-python line-numbers">from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side * self.side
</code></pre>

    <br/>
    <ul>
        <li>You cannot instantiate <code>Shape</code> directly.</li>
    </ul>

    <br/><br/>



    <li><b>Preventing Inheritance</b></li>
    <br/>
    <ul>
        <li>Python has no direct <code>final</code> keyword like Java.</li>
        <li>But you can use conventions, metaclasses, or raise errors inside <code>__init_subclass__</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">class FinalClass:
    def __init_subclass__(cls):
        raise TypeError("This class cannot be inherited from")
</code></pre>

    <br/><br/>



    <li><b>Common Inheritance Patterns</b></li>
    <br/>
    <ul>
        <li><b>"Is-a" relationship</b> (proper use):
            <ul>
                <li><code>Dog</code> is an <code>Animal</code></li>
                <li><code>Car</code> is a <code>Vehicle</code></li>
            </ul>
        </li>
        <br/>
        <li><b>"Has-a" relationship</b> ‚Üí use composition instead of inheritance:
            <ul>
                <li><code>Car</code> has an <code>Engine</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Inheritance</td>
                <td>Child class extends/overrides parent class</td>
            </tr>
            <tr>
                <td>super()</td>
                <td>Call parent method following MRO</td>
            </tr>
            <tr>
                <td>Multiple inheritance</td>
                <td>Class inherits from multiple parents</td>
            </tr>
            <tr>
                <td>MRO</td>
                <td>Defines attribute/method lookup order</td>
            </tr>
            <tr>
                <td>Overriding</td>
                <td>Child redefines parent method</td>
            </tr>
            <tr>
                <td>ABC</td>
                <td>Define abstract methods to enforce implementation</td>
            </tr>
            <tr>
                <td>Best practice</td>
                <td>Use inheritance for ‚Äúis-a‚Äù relationships; use composition for ‚Äúhas-a‚Äù</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-private-variables">Private Variables in Python</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python does <b>not</b> have true private variables like Java or C++.</li>
        <br/>
        <li>However, Python uses <b>conventions</b> and <b>name-mangling</b> to protect internal attributes.</li>
        <br/>
        <li>Three common visibility conventions:
            <ul>
                <li><b>public</b>: <code>var</code></li>
                <li><b>protected (by convention)</b>: <code>_var</code></li>
                <li><b>private (name-mangled)</b>: <code>__var</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Public Attributes</b></li>
    <br/>
    <ul>
        <li>Accessible from anywhere.</li>
        <li>Default visibility in Python.</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    name = "Alice"

p = Person()
print(p.name)   # accessible
</code></pre>

    <br/><br/>



    <li><b>Protected Attributes (Single Underscore)</b></li>
    <br/>
    <ul>
        <li>Convention: <code>_var</code> means "for internal use only".</li>
        <li>Not enforced by Python. Developers are expected not to access it directly.</li>
    </ul>

<pre><code class="language-python line-numbers">class User:
    def __init__(self):
        self._password = "1234"   # internal

u = User()
print(u._password)   # works, but not recommended
</code></pre>

    <br/>
    <ul>
        <li>Used mainly to indicate intent, not to block access.</li>
    </ul>

    <br/><br/>



    <li><b>Private Attributes (Double Underscore)</b></li>
    <br/>
    <ul>
        <li>Using <code>__var</code> triggers <b>name mangling</b>.</li>
        <li>Python changes the internal name to prevent accidental overrides from subclasses.</li>
    </ul>

<pre><code class="language-python line-numbers">class BankAccount:
    def __init__(self, balance):
        self.__balance = balance

acc = BankAccount(500)
print(acc.__balance)     # AttributeError
</code></pre>

    <br/>
    <ul>
        <li>Internally becomes <code>_BankAccount__balance</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">print(acc._BankAccount__balance)   # 500 (works but not intended!)
</code></pre>

    <br/>
    <ul>
        <li>This is not true security ‚Äî just name obfuscation to avoid conflicts.</li>
    </ul>

    <br/><br/>



    <li><b>Why Name-Mangling Exists</b></li>
    <br/>
    <ul>
        <li>Main purpose: prevent accidentally overriding internal attributes in subclasses.</li>
    </ul>

<pre><code class="language-python line-numbers">class A:
    def __init__(self):
        self.__x = 1   # becomes _A__x

class B(A):
    def __init__(self):
        super().__init__()
        self.__x = 2   # becomes _B__x (not overriding A's)
</code></pre>

    <br/>
    <ul>
        <li>Each class gets its own safely isolated name.</li>
    </ul>

    <br/><br/>



    <li><b>Accessing Private Values via Methods</b></li>
    <br/>
    <ul>
        <li>Private attributes are usually accessed via getters and setters (Pythonic approach uses properties).</li>
    </ul>

<pre><code class="language-python line-numbers">class Counter:
    def __init__(self):
        self.__count = 0

    @property
    def count(self):
        return self.__count

    def increment(self):
        self.__count += 1
</code></pre>

    <br/><br/>



    <li><b>Private Methods</b></li>
    <br/>
    <ul>
        <li>Double underscores also work for methods.</li>
    </ul>

<pre><code class="language-python line-numbers">class Server:
    def __connect(self):
        print("Connecting...")

    def start(self):
        self.__connect()
</code></pre>

    <br/>
    <ul>
        <li>Internally named <code>_Server__connect</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Private Attributes and Inheritance</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Base:
    def __init__(self):
        self.__value = 10

class Child(Base):
    def show(self):
        # print(self.__value)  # error
        print(self._Base__value)  # works
</code></pre>

    <br/>
    <ul>
        <li>Child classes cannot directly access the parent‚Äôs private variable.</li>
    </ul>

    <br/><br/>



    <li><b>When to Use What?</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Notation</th>
                <th>Meaning</th>
                <th>Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>var</code></td>
                <td>Public</td>
                <td>Visible everywhere</td>
            </tr>
            <tr>
                <td><code>_var</code></td>
                <td>Protected by convention</td>
                <td>Internal detail, subclass-friendly</td>
            </tr>
            <tr>
                <td><code>__var</code></td>
                <td>Private (name-mangled)</td>
                <td>Avoid accidental overrides; ‚Äúinternal-only‚Äù</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Why Python Uses Conventions Instead of Real Privacy</b></li>
    <br/>
    <ul>
        <li>Python philosophy:
            <ul>
                <li>‚ÄúWe are all consenting adults here.‚Äù</li>
                <li>No need for strict enforcement when cooperation is assumed.</li>
            </ul>
        </li>
        <br/>
        <li>Privacy exists mostly for safety and avoiding errors, not for hiding secrets.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Public attributes</td>
                <td>Accessible everywhere</td>
            </tr>
            <tr>
                <td>Protected attributes</td>
                <td>Marked with <code>_var</code>, convention only</td>
            </tr>
            <tr>
                <td>Private attributes</td>
                <td>Double underscore; name-mangled</td>
            </tr>
            <tr>
                <td>Name mangling</td>
                <td>Prevents accidental name collisions in subclasses</td>
            </tr>
            <tr>
                <td>Private methods</td>
                <td>Same rules as private variables</td>
            </tr>
            <tr>
                <td>Properties</td>
                <td>Pythonic way to expose private fields safely</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-iterators">Python Iterators</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>An <b>iterator</b> is an object that allows you to traverse a sequence of values one at a time.</li>
        <br/>
        <li>Python implements the iterator protocol with two methods:
            <ul>
                <li><code>__iter__()</code>: returns the iterator object itself</li>
                <li><code>__next__()</code>: returns the next item, or raises <code>StopIteration</code> when done</li>
            </ul>
        </li>
        <br/>
        <li>Iterators power:
            <ul>
                <li><code>for</code> loops</li>
                <li>generators</li>
                <li>comprehensions</li>
                <li>file reading</li>
                <li>lazy evaluation</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Everything Iterable in Python Produces an Iterator</b></li>
    <br/>
    <ul>
        <li>Examples of iterable objects:
            <ul>
                <li>lists</li>
                <li>tuples</li>
                <li>strings</li>
                <li>dictionaries</li>
                <li>sets</li>
                <li>file objects</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers">nums = [1, 2, 3]
it = iter(nums)

print(next(it))   # 1
print(next(it))   # 2
print(next(it))   # 3
# next(it) would raise StopIteration
</code></pre>

    <br/><br/>



    <li><b>The Iterator Protocol</b></li>
    <br/>
    <ul>
        <li>To create a custom iterator, implement:
            <ul>
                <li><code>__iter__()</code></li>
                <li><code>__next__()</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers">class CountTo:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current &gt;= self.limit:
            raise StopIteration
        value = self.current
        self.current += 1
        return value

for n in CountTo(3):
    print(n)
</code></pre>

Output:

<pre><code class="language-text">0
1
2
</code></pre>

    <br/><br/>



    <li><b>Iterators Are State Machines</b></li>
    <br/>
    <ul>
        <li>They remember their current position.</li>
        <li>Once consumed, they cannot be restarted unless recreated.</li>
    </ul>

<pre><code class="language-python line-numbers">it = iter([10, 20, 30])
for i in it:
    print(i)

for i in it:
    print(i)   # prints nothing (iterator exhausted)
</code></pre>

    <br/><br/>



    <li><b>Iterators vs Iterables</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Iterable</td>
                <td>Object that can return an iterator with <code>iter()</code></td>
            </tr>
            <tr>
                <td>Iterator</td>
                <td>Object that produces values via <code>next()</code> and remembers state</td>
            </tr>
            <tr>
                <td>Iterator Protocol</td>
                <td>Requires <code>__iter__()</code> and <code>__next__()</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Using Iterators in For-Loops</b></li>
    <br/>
    <ul>
        <li><code>for</code> automatically calls <code>iter()</code> and repeatedly <code>next()</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">for ch in "abc":
    print(ch)
</code></pre>

    <br/><br/>



    <li><b>Files Are Iterators</b></li>
    <br/>
    <ul>
        <li>File objects produce one line at a time.</li>
    </ul>

<pre><code class="language-python line-numbers">with open("data.txt") as f:
    for line in f:
        print(line.strip())
</code></pre>
    <ul>
        <li>This is memory-efficient (reads lazily).</li>
    </ul>

    <br/><br/>



    <li><b>Generators: The Most Common Way to Build Iterators</b></li>
<pre><code class="language-python line-numbers">def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

for x in countdown(3):
    print(x)
</code></pre>
    <ul>
        <li>Generators automatically implement the iterator protocol.</li>
        <li><code>yield</code> produces one value at a time.</li>
    </ul>

    <br/><br/>



    <li><b>Generator Expressions</b></li>
<pre><code class="language-python line-numbers">squares = (x*x for x in range(5))
print(next(squares))   # 0
print(next(squares))   # 1
</code></pre>
    <ul>
        <li>Generator expressions create lightweight iterators.</li>
    </ul>

    <br/><br/>



    <li><b>Itertools: Tools for Advanced Iteration</b></li>
<pre><code class="language-python line-numbers">import itertools

for x in itertools.count(5, 2):
    print(x)
    if x &gt; 12:
        break
</code></pre>
    <ul>
        <li>Common functions:
            <ul>
                <li><code>count()</code>: infinite counting</li>
                <li><code>cycle()</code>: repeat items endlessly</li>
                <li><code>repeat()</code>: repeat a value</li>
                <li><code>chain()</code>: combine iterables</li>
                <li><code>islice()</code>: slice an iterator</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Iterator Exhaustion</b></li>
    <br/>
    <ul>
        <li>Once an iterator is exhausted, calling <code>next()</code> raises <code>StopIteration</code>.</li>
        <li>Must recreate a new iterator to iterate again.</li>
    </ul>

<pre><code class="language-python line-numbers">lst = [1, 2, 3]
it = iter(lst)

for i in it:
    print(i)

for i in it:
    print(i)   # nothing printed
</code></pre>

    <br/><br/>



    <li><b>Reiterable Objects</b></li>
    <br/>
    <ul>
        <li>Lists, strings, tuples return a <b>new</b> iterator each time:</li>
    </ul>

<pre><code class="language-python line-numbers">nums = [1, 2, 3]
for x in nums:
    print(x)

for x in nums:
    print(x)   # works again
</code></pre>
    <ul>
        <li>This makes them "reiterable".</li>
    </ul>

    <br/><br/>



    <li><b>Building Your Own Iterable + Iterator Pair</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Reverse:
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        return ReverseIterator(self.data)

class ReverseIterator:
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index -= 1
        return self.data[self.index]

words = Reverse("abc")
for w in words:
    print(w)
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Iterator</td>
                <td>Object with <code>__iter__</code> and <code>__next__</code></td>
            </tr>
            <tr>
                <td>Iterable</td>
                <td>Object that produces an iterator via <code>iter()</code></td>
            </tr>
            <tr>
                <td>StopIteration</td>
                <td>Signals end of iteration</td>
            </tr>
            <tr>
                <td>Generators</td>
                <td>Simplest way to create iterators</td>
            </tr>
            <tr>
                <td>Iterator exhaustion</td>
                <td>Iterators cannot be reused; create another</td>
            </tr>
            <tr>
                <td>Itertools</td>
                <td>Advanced iterator utilities</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-generators">Python Generators</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>generator</b> is a special kind of iterator that produces values lazily ‚Äî one at a time ‚Äî using the <code>yield</code> keyword.</li>
        <br/>
        <li>Generators allow you to write iterable sequences without creating full containers in memory.</li>
        <br/>
        <li>Generators are ideal for:
            <ul>
                <li>large data processing</li>
                <li>streaming / pipelines</li>
                <li>infinite sequences</li>
                <li>efficient iteration</li>
            </ul>
        </li>
        <br/>
        <li>Generators automatically implement the <b>iterator protocol</b>:
            <ul>
                <li><code>__iter__()</code></li>
                <li><code>__next__()</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Generator Function</b></li>
    <br/>
    <ul>
        <li>A generator function contains one or more <code>yield</code> statements.</li>
    </ul>

<pre><code class="language-python line-numbers">def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

for x in countdown(3):
    print(x)
</code></pre>

Output:

<pre><code class="language-text">3
2
1
</code></pre>

    <br/>
    <ul>
        <li>Each call to <code>yield</code> produces the next value.</li>
        <li>Execution pauses at <code>yield</code> and resumes on the next <code>next()</code> call.</li>
    </ul>

    <br/><br/>



    <li><b>Generator Execution Model</b></li>
    <br/>
    <ul>
        <li>Generators maintain their internal state between yields.</li>
        <li>Unlike normal functions, they do not restart from the top each time.</li>
    </ul>

<pre><code class="language-python line-numbers">g = countdown(3)
print(next(g))   # 3
print(next(g))   # 2
print(next(g))   # 1
# next(g) -&gt; StopIteration
</code></pre>

    <br/><br/>



    <li><b>Difference Between Return and Yield</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Keyword</th>
                <th>Effect</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>return</code></td>
                <td>Ends function, returns a value once</td>
            </tr>
            <tr>
                <td><code>yield</code></td>
                <td>Pauses execution, returns multiple values one at a time</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Generators Are Memory-Efficient</b></li>
    <br/>
    <ul>
        <li>A list with 1 million numbers:</li>
    </ul>

<pre><code class="language-python line-numbers">nums = [x*x for x in range(1_000_000)]
</code></pre>

    <br/>
    <ul>
        <li>A generator version:</li>
    </ul>

<pre><code class="language-python line-numbers">nums = (x*x for x in range(1_000_000))
</code></pre>
    <ul>
        <li>The generator uses <b>constant memory</b>, because it computes values only when needed.</li>
    </ul>

    <br/><br/>



    <li><b>Generator Expressions</b></li>
    <br/>
    <ul>
        <li>Like list comprehensions but lazy.</li>
    </ul>

<pre><code class="language-python line-numbers">squares = (n*n for n in range(5))
print(next(squares))   # 0
print(next(squares))   # 1
</code></pre>

    <br/><br/>



    <li><b>Generators with Multiple Yields</b></li>
    <br/>

<pre><code class="language-python line-numbers">def steps():
    yield "start"
    yield "loading"
    yield "finish"
</code></pre>

    <br/><br/>



    <li><b>Using Generators to Build Pipelines</b></li>
    <br/>
    <ul>
        <li>Generators are great for streaming transformations.</li>
    </ul>

<pre><code class="language-python line-numbers">def read_numbers():
    for i in range(10):
        yield i

def even_numbers(numbers):
    for n in numbers:
        if n % 2 == 0:
            yield n

def squared(numbers):
    for n in numbers:
        yield n * n

pipeline = squared(even_numbers(read_numbers()))
for x in pipeline:
    print(x)
</code></pre>

    <br/>
    <ul>
        <li>This pipeline:
            <ul>
                <li>reads numbers</li>
                <li>filters even ones</li>
                <li>squares the result</li>
                <li>all lazily</li>
            </ul>
        </li>
    </ul>

    <br/><br/>

    <li><b>Sending Data into a Generator</b></li>
    <br/>
    <ul>
        <li>Generators are not only one-way producers of values.</li>
        <br/>
        <li>Using <code>generator.send(value)</code>, you can send data <b>into</b> a paused generator.</li>
        <br/>
        <li>This turns generators into <b>coroutines</b> ‚Äî a powerful technique for cooperative multitasking, data pipelines, and stateful processing.</li>
    </ul>
    <br/>

<pre><code class="language-python line-numbers">def greeter():
    name = yield "Your name?"
    yield f"Hello, {name}!"

g = greeter()
print(next(g))           # "Your name?"
print(g.send("Alice"))   # "Hello, Alice!"
</code></pre>

    <br/>
    <ul>
        <li>The first <code>next()</code> call starts the generator until the first <code>yield</code>.</li>
        <li>The next <code>send()</code> call provides a value that becomes the result of the suspended <code>yield</code> expression.</li>
    </ul>
    <br/><br/>



    <li><b>How <code>send()</code> Works Internally</b></li>
    <br/>
    <ul>
        <li>When a generator is paused at this line:</li>
    </ul>

<pre><code class="language-python line-numbers">name = yield "Your name?"
</code></pre>

    <br/>
    <ul>
        <li>The expression <code>yield "Your name?"</code> acts like:
            <ul>
                <li>output: <code>"Your name?"</code></li>
                <li>input: value provided later via <code>send()</code></li>
            </ul>
        </li>
        <br/>
        <li>When we call <code>g.send("Alice")</code>:</li>
        <ul>
            <li>the <code>yield</code> returns the value <code>"Alice"</code></li>
            <li>so <code>name</code> becomes <code>"Alice"</code></li>
            <li>execution continues until the next <code>yield</code></li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>The First <code>send()</code> Must Be <code>None</code></b></li>
    <br/>
    <ul>
        <li>You cannot send a non-None value into a generator before it reaches the first <code>yield</code>.</li>
        <li>Therefore, the first interaction usually uses <code>next()</code> (or <code>send(None)</code>).</li>
    </ul>

<pre><code class="language-python line-numbers">g = greeter()
g.send("Alice")  # ERROR! Generator not started yet
</code></pre>

    <br/>
    <ul>
        <li>Correct way:</li>
    </ul>

<pre><code class="language-python line-numbers">g = greeter()
next(g)           # or g.send(None)
g.send("Alice")
</code></pre>

    <br/><br/>



    <li><b>Using Generators as Simple Coroutines</b></li>
    <br/>
    <ul>
        <li>A generator can behave like a coroutine that receives many values over time.</li>
    </ul>

<pre><code class="language-python line-numbers">def accumulator():
    total = 0
    while True:
        value = yield total
        total += value

acc = accumulator()
print(next(acc))        # 0
print(acc.send(5))      # 5
print(acc.send(10))     # 15
print(acc.send(3))      # 18
</code></pre>

    <br/>
    <ul>
        <li>This generator:
            <ul>
                <li>starts with a total of 0</li>
                <li>each <code>send()</code> adds the value to the total</li>
                <li>yields the updated total each time</li>
            </ul>
        </li>
        <li>This is a miniature coroutine.</li>
    </ul>

    <br/><br/>



    <li><b>Stopping a Coroutine with a Sentinel Value</b></li>
    <br/>
    <ul>
        <li>Generators can be designed to terminate on a special input, such as <code>None</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def summer():
    total = 0
    while True:
        item = yield total
        if item is None:      # sentinel value
            return total
        total += item

g = summer()
next(g)
print(g.send(5))   # 5
print(g.send(7))   # 12

try:
    g.send(None)   # stops the generator
except StopIteration as e:
    print("Final total:", e.value)
</code></pre>

    <br/>
    <ul>
        <li>When a generator returns, the return value is contained inside a <code>StopIteration</code> exception.</li>
        <li>This is how Python‚Äôs async framework originally worked before <code>async</code>/<code>await</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Sending Exceptions into a Generator</b></li>
    <br/>
    <ul>
        <li>You can use <code>throw()</code> to inject an exception inside a paused generator.</li>
    </ul>

<pre><code class="language-python line-numbers">def worker():
    try:
        while True:
            task = yield
            print("Processing", task)
    except ValueError:
        print("ValueError inside generator!")
    yield "done"

g = worker()
next(g)
g.send("Job 1")
g.throw(ValueError)
print(next(g))   # "done"
</code></pre>

    <br/>
    <ul>
        <li>This technique is used in advanced coroutine schedulers.</li>
    </ul>

    <br/><br/>



    <li><b>Difference Between <code>next()</code> and <code>send()</code></b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Purpose</th>
                <th>Value Passed to Generator</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>next(gen)</code></td>
                <td>Resume generator</td>
                <td><code>None</code></td>
            </tr>
            <tr>
                <td><code>gen.send(value)</code></td>
                <td>Resume generator and pass <code>value</code></td>
                <td><code>value</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Practical Use Cases</b></li>
    <br/>
    <ul>
        <li>Stateful streaming transformations</li>
        <li>Creating coroutine pipelines</li>
        <li>Simple message-passing systems</li>
        <li>Implementing cooperative multitasking (pre-async/await)</li>
        <li>Controlling behavior based on incoming data</li>
        <li>Simplifying actor-model concurrency</li>
    </ul>

    <br/><br/>


    <li><b>Closing a Generator</b></li>
<pre><code class="language-python line-numbers">g = countdown(3)
g.close()
</code></pre>
    <ul>
        <li>After <code>close()</code>, further <code>next()</code> calls raise <code>StopIteration</code> immediately.</li>
    </ul>

    <br/><br/>



    <li><b>Throwing Exceptions into Generators</b></li>
    <br/>
    <ul>
        <li>You can inject exceptions:</li>
    </ul>

<pre><code class="language-python line-numbers">def test():
    try:
        yield 1
    except ValueError:
        yield "error handled"
    yield 2

g = test()
print(next(g))              # 1
print(g.throw(ValueError))  # "error handled"
print(next(g))              # 2
</code></pre>

    <br/><br/>



    <li><b>Returning from a Generator</b></li>
    <br/>
    <ul>
        <li>A generator may use <code>return</code>, but this signals the end of iteration.</li>
        <li>The returned value is stored in the <code>StopIteration</code> exception.</li>
    </ul>

<pre><code class="language-python line-numbers">def total():
    s = 0
    while True:
        n = yield
        if n is None:
            break
        s += n
    return s
</code></pre>

    <br/><br/>



    <li><b>Infinite Generators</b></li>
    <br/>
    <ul>
        <li>Generators can represent unbounded sequences.</li>
    </ul>

<pre><code class="language-python line-numbers">def naturals():
    n = 0
    while True:
        yield n
        n += 1
</code></pre>

    <br/><br/>



    <li><b>Generators vs Regular Functions</b></li>

    <table>
        <thead>
            <tr>
                <th>Regular Function</th>
                <th>Generator</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Returns once</td>
                <td>Yields many times</td>
            </tr>
            <tr>
                <td>Does not preserve state</td>
                <td>Resumes from last yield</td>
            </tr>
            <tr>
                <td>Eager evaluation</td>
                <td>Lazy evaluation</td>
            </tr>
            <tr>
                <td>Returns ordinary values</td>
                <td>Returns an iterator</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>yield</code></td>
                <td>Produces values lazily</td>
            </tr>
            <tr>
                <td>Stateful execution</td>
                <td>Generator pauses and resumes</td>
            </tr>
            <tr>
                <td>Memory efficient</td>
                <td>Only one value stored at a time</td>
            </tr>
            <tr>
                <td>Generator expressions</td>
                <td>Lightweight inline generators</td>
            </tr>
            <tr>
                <td>send() / throw()</td>
                <td>Two-way communication with generator</td>
            </tr>
            <tr>
                <td>Pipelines</td>
                <td>Ideal for streaming data processing</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-brief-std-lib-tour">Brief Tour of the Python Standard Library</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The Python Standard Library is a powerful collection of modules that come bundled with Python, no installation required.</li>
        <br/>
        <li>It includes tools for:
            <ul>
                <li>system interaction</li>
                <li>file handling</li>
                <li>data formats</li>
                <li>networking</li>
                <li>math and statistics</li>
                <li>dates and times</li>
                <li>compression</li>
                <li>debugging and testing</li>
            </ul>
        </li>
        <br/>
        <li>This chapter provides a practical overview of the most important modules you‚Äôll frequently use.</li>
    </ul>
    <br/><br/>



    <li><b>Operating System Interfaces: <code>os</code> and <code>sys</code></b></li>
    <br/>
    <ul>
        <li><code>os</code> lets you interact with the underlying operating system.</li>
        <li><code>sys</code> provides access to interpreter-level features.</li>
    </ul>

<pre><code class="language-python line-numbers">import os, sys

print(os.getcwd())          # current working directory
print(os.listdir("."))      # list files
print(sys.version)          # python version
print(sys.argv)             # command-line arguments
</code></pre>

    <br/><br/>



    <li><b>File and Path Handling: <code>pathlib</code></b></li>
    <br/>
    <ul>
        <li>The modern and recommended way to work with filesystem paths.</li>
    </ul>

<pre><code class="language-python line-numbers">from pathlib import Path

p = Path("notes.txt")
print(p.exists())
print(p.read_text())
</code></pre>

    <br/><br/>



    <li><b>Mathematics: <code>math</code>, <code>statistics</code>, <code>random</code></b></li>
    <br/>
    <ul>
        <li>The <code>math</code> module provides fast mathematical functions.</li>
        <li><code>statistics</code> handles averages, medians, variance, etc.</li>
        <li><code>random</code> produces random numbers.</li>
    </ul>

<pre><code class="language-python line-numbers">import math, statistics, random

print(math.sqrt(9))
print(statistics.mean([1,2,3,4]))
print(random.randint(1, 10))
</code></pre>

    <br/><br/>



    <li><b>Dates and Times: <code>datetime</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">from datetime import datetime, timedelta

now = datetime.now()
print(now)
print(now + timedelta(days=3))
</code></pre>

    <br/><br/>



    <li><b>Collections: <code>collections</code></b></li>
    <br/>
    <ul>
        <li>Provides powerful data structures beyond built-in lists/dicts.</li>
    </ul>

<pre><code class="language-python line-numbers">from collections import Counter, defaultdict, deque

c = Counter("banana")
print(c)                      # character frequencies

d = defaultdict(int)
d["a"] += 1                   # no KeyError

queue = deque([1,2,3])
queue.appendleft(0)
print(queue)
</code></pre>

    <br/><br/>



    <li><b>Working with JSON: <code>json</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import json

data = {"name": "Alice", "age": 25}
text = json.dumps(data)
print(text)

loaded = json.loads(text)
print(loaded)
</code></pre>

    <br/><br/>



    <li><b>Regular Expressions: <code>re</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import re

pattern = r"\d+"
print(re.findall(pattern, "The year is 2025"))
</code></pre>

    <br/><br/>



    <li><b>Working with the Internet: <code>urllib.request</code>, <code>http.client</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">from urllib import request

with request.urlopen("https://example.com") as f:
    html = f.read()
    print(len(html))
</code></pre>

    <br/><br/>



    <li><b>Command-Line Argument Parsing: <code>argparse</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--name")
args = parser.parse_args()

print(f"Hello {args.name}")
</code></pre>

    <br/><br/>



    <li><b>Data Compression: <code>gzip</code>, <code>zipfile</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import gzip

with gzip.open("data.gz", "wt") as f:
    f.write("Hello")
</code></pre>

    <br/><br/>



    <li><b>Debugging and Profiling: <code>pdb</code>, <code>timeit</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import timeit

print(timeit.timeit("sum(range(1000))", number=1000))
</code></pre>

    <br/><br/>



    <li><b>Temporary Files: <code>tempfile</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import tempfile

with tempfile.TemporaryFile() as f:
    f.write(b"Hello")
    f.seek(0)
    print(f.read())
</code></pre>

    <br/><br/>



    <li><b>Binary Data: <code>struct</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import struct

packed = struct.pack("!I", 12345)
unpacked = struct.unpack("!I", packed)
print(unpacked)
</code></pre>

    <br/><br/>



    <li><b>File Formats: <code>csv</code>, <code>xml.etree.ElementTree</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import csv

with open("data.csv") as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
</code></pre>

    <br/><br/>



    <li><b>Threading and Concurrency: <code>threading</code>, <code>multiprocessing</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">import threading

def worker():
    print("working")

t = threading.Thread(target=worker)
t.start()
t.join()
</code></pre>

    <br/><br/>



    <li><b>Popular General-Purpose Modules</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Module</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>shutil</code></td>
                <td>File operations (copy, move, delete)</td>
            </tr>
            <tr>
                <td><code>subprocess</code></td>
                <td>Run external commands</td>
            </tr>
            <tr>
                <td><code>logging</code></td>
                <td>Configurable logging system</td>
            </tr>
            <tr>
                <td><code>functools</code></td>
                <td>Higher-order functions, caching</td>
            </tr>
            <tr>
                <td><code>itertools</code></td>
                <td>Fast iterator tools (infinite sequences, combinations)</td>
            </tr>
            <tr>
                <td><code>hashlib</code></td>
                <td>Cryptographic hashes (MD5, SHA256)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Important Modules</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>System interaction</td>
                <td><code>os</code>, <code>sys</code>, <code>shutil</code></td>
            </tr>
            <tr>
                <td>Paths &amp; Files</td>
                <td><code>pathlib</code>, <code>csv</code>, <code>tempfile</code></td>
            </tr>
            <tr>
                <td>Data formats</td>
                <td><code>json</code>, <code>xml</code>, <code>csv</code></td>
            </tr>
            <tr>
                <td>Math &amp; Stats</td>
                <td><code>math</code>, <code>statistics</code>, <code>random</code></td>
            </tr>
            <tr>
                <td>Networking</td>
                <td><code>urllib</code>, <code>http.client</code></td>
            </tr>
            <tr>
                <td>Utilities</td>
                <td><code>timeit</code>, <code>functools</code>, <code>itertools</code></td>
            </tr>
            <tr>
                <td>Compression</td>
                <td><code>gzip</code>, <code>zipfile</code></td>
            </tr>
            <tr>
                <td>Concurrency</td>
                <td><code>threading</code>, <code>multiprocessing</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-wrappers">Python Wrappers</h3>
<ol>
    <li><b>What Is a Wrapper in Python?</b></li>
    <br/>
    <ul>
        <li>In Python, a <b>wrapper</b> is a function (or object) that ‚Äúwraps around‚Äù another function to extend or modify its behavior.</li>
        <br/>
        <li>Wrappers are used when you want to:
            <ul>
                <li>run extra code before or after a function</li>
                <li>log function calls</li>
                <li>measure performance</li>
                <li>validate arguments</li>
                <li>modify return values</li>
                <li>add permissions / authentication</li>
            </ul>
        </li>
        <br/>
        <li>Wrappers are the foundation of <b>decorators</b>, but decorators come later ‚Äî first we must understand the wrapper concept itself.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Wrapper Structure</b></li>
    <br/>
    <ul>
        <li>A wrapper function takes another function and returns a modified version of it.</li>
    </ul>

<pre><code class="language-python line-numbers">def wrapper(func):
    def inner():
        print("Before")
        result = func()
        print("After")
        return result
    return inner

def say_hello():
    print("Hello")

wrapped = wrapper(say_hello)
wrapped()
</code></pre>

    <br/>
    <ul>
        <li>Output:</li>
    </ul>

<pre><code class="language-text line-numbers">Before
Hello
After
</code></pre>

    <br/><br/>



    <li><b>Why Do We Need a Wrapper?</b></li>
    <br/>
    <ul>
        <li>You may want to:
            <ul>
                <li>add logging</li>
                <li>check user permissions</li>
                <li>retry failed operations</li>
                <li>limit rate of function calls</li>
                <li>cache results</li>
            </ul>
        </li>
        <br/>
        <li>Instead of modifying the original function, you wrap it.</li>
    </ul>

    <br/><br/>



    <li><b>Wrappers With Arguments</b></li>
    <br/>
    <ul>
        <li>To support functions with any number of arguments, wrappers use <code>*args</code> and <code>**kwargs</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def wrapper(func):
    def inner(*args, **kwargs):
        print("Calling:", func.__name__)
        return func(*args, **kwargs)
    return inner

def add(a, b):
    return a + b

wrapped_add = wrapper(add)
print(wrapped_add(3, 5))
</code></pre>

    <br/><br/>



    <li><b>Preserving Function Metadata</b></li>
    <br/>
    <ul>
        <li>Wrapping a function normally destroys the original function‚Äôs name, docstring, and annotations.</li>
        <br/>
        <li>Python provides <code>functools.wraps</code> to preserve them.</li>
    </ul>

<pre><code class="language-python line-numbers">import functools

def wrapper(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        return func(*args, **kwargs)
    return inner
</code></pre>

    <br/><br/>



    <li><b>Wrapper Example: Logging Function Calls</b></li>
    <br/>

<pre><code class="language-python line-numbers">import functools

def log_calls(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        print(f"Calling {func.__name__} with {args=} {kwargs=}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return inner

@log_calls
def multiply(x, y):
    return x * y

multiply(3, 4)
</code></pre>

    <br/><br/>



    <li><b>Wrapper Example: Timing Functions</b></li>
    <br/>

<pre><code class="language-python line-numbers">import time
import functools

def timer(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        end = time.perf_counter()
        print(f"{func.__name__} took {end - start:.6f} seconds")
        return result
    return inner

@timer
def slow():
    time.sleep(1)

slow()
</code></pre>

    <br/><br/>



    <li><b>Wrapper Example: Checking Permissions</b></li>
    <br/>

<pre><code class="language-python line-numbers">def require_admin(func):
    @functools.wraps(func)
    def inner(user, *args, **kwargs):
        if user != "admin":
            raise PermissionError("Access denied")
        return func(user, *args, **kwargs)
    return inner

@require_admin
def delete_database(user):
    return "Database deleted!"

delete_database("admin")    # OK
delete_database("guest")    # PermissionError
</code></pre>

    <br/><br/>



    <li><b>Wrapper Example: Caching (Memoization)</b></li>
    <br/>

<pre><code class="language-python line-numbers">def cache(func):
    stored = {}

    @functools.wraps(func)
    def inner(x):
        if x not in stored:
            stored[x] = func(x)
        return stored[x]
    return inner

@cache
def square(n):
    print("Computing...")
    return n * n

print(square(5))   # computed
print(square(5))   # from cache
</code></pre>

    <br/><br/>



    <li><b>Wrappers vs Decorators</b></li>
    <br/>
    <ul>
        <li>A decorator is simply a <b>shortcut</b> for applying a wrapper.</li>
    </ul>

<pre><code class="language-text">
Without decorator:
    wrapped = wrapper(func)

With decorator:
    @wrapper
    def func(): ...
</code></pre>

    <br/>
    <ul>
        <li>Thus: <b>All decorators use wrappers, but not all wrappers need decorators.</b></li>
    </ul>

    <br/><br/>



    <li><b>Using Wrappers With Methods (Classes)</b></li>
    <br/>
    <ul>
        <li>Wrappers also work on methods, but remember: the first argument is <code>self</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(func):
    @functools.wraps(func)
    def inner(self, *args, **kwargs):
        print(f"Method {func.__name__} called")
        return func(self, *args, **kwargs)
    return inner

class A:
    @debug
    def hello(self):
        print("Hello from A")

A().hello()
</code></pre>

    <br/><br/>



    <li><b>Advanced: Wrapping Async Functions</b></li>
    <br/>
    <ul>
        <li>Wrappers can also handle <code>async</code> functions.</li>
    </ul>

<pre><code class="language-python line-numbers">import functools
import asyncio

def async_wrapper(func):
    @functools.wraps(func)
    async def inner(*args, **kwargs):
        print("Before async call")
        result = await func(*args, **kwargs)
        print("After async call")
        return result
    return inner

@async_wrapper
async def hello():
    await asyncio.sleep(1)
    return "Done"

asyncio.run(hello())
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Wrapper</td>
                <td>A function that adds behavior around another function</td>
            </tr>
            <tr>
                <td><code>*args</code> / <code>**kwargs</code></td>
                <td>Allow wrappers to handle any function signature</td>
            </tr>
            <tr>
                <td><code>functools.wraps</code></td>
                <td>Preserves function metadata (name, docstring)</td>
            </tr>
            <tr>
                <td>Without decorator</td>
                <td><code>wrapped = wrapper(func)</code></td>
            </tr>
            <tr>
                <td>With decorator</td>
                <td><code>@wrapper</code> above the function</td>
            </tr>
            <tr>
                <td>Common uses</td>
                <td>logging, timing, caching, permissions, validation, retries</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-decorators">Python Decorators</h3>
<ol>
    <li><b>What Is a Decorator?</b></li>
    <br/>
    <ul>
        <li>A <b>decorator</b> is a Python feature that lets you <b>modify or enhance functions (or methods)</b> without changing their actual code.</li>
        <br/>
        <li>A decorator takes a function as input, wraps it inside another function (a <b>wrapper</b>), and returns a new function.</li>
        <br/>
        <li>You apply a decorator using the <code>@decorator_name</code> syntax above a function definition.</li>
    </ul>

<pre><code class="language-python line-numbers">@decorator
def function():
    ...
</code></pre>
    <ul>
        <li>Python transforms this into:</li>
    </ul>

<pre><code class="language-text line-numbers">function = decorator(function)</code></pre>

    <br/><br/>



    <li><b>Why Decorators Are Important</b></li>
    <br/>
    <ul>
        <li>Decorators are used everywhere in Python:
            <ul>
                <li>logging</li>
                <li>authentication / access control</li>
                <li>caching results</li>
                <li>performance measurement</li>
                <li>frameworks (Flask, FastAPI, Django)</li>
                <li>retry logic</li>
                <li>validating function arguments</li>
                <li>registering plugins</li>
            </ul>
        </li>
        <br/>
        <li>Decorators allow you to apply reusable patterns to many functions with clean syntax.</li>
    </ul>

    <br/><br/>



    <li><b>How Decorators Work (Fundamentals)</b></li>
    <br/>
    <ul>
        <li>A decorator is just a function that returns another function.</li>
    </ul>

<pre><code class="language-python line-numbers">def my_decorator(func):
    def wrapper():
        print("Before call")
        func()
        print("After call")
    return wrapper

@my_decorator
def hello():
    print("Hello!")

hello()
</code></pre>

    <br/>
    <ul>
        <li>Output:</li>
    </ul>

<pre><code class="language-text line-numbers">Before call
Hello!
After call
</code></pre>

    <br/><br/>



    <li><b>Decorators With Arguments</b></li>
    <br/>
    <ul>
        <li>Your wrapper must accept any possible function arguments:</li>
    </ul>

<pre><code class="language-python line-numbers">def decorator(func):
    def wrapper(*args, **kwargs):
        print("Calling:", func.__name__)
        return func(*args, **kwargs)
    return wrapper

@decorator
def add(a, b):
    return a + b

print(add(3, 5))
</code></pre>

    <br/><br/>



    <li><b>Preserving Metadata Using functools.wraps</b></li>
    <br/>
    <ul>
        <li>Without <code>wraps</code>, the decorated function loses its original name, docstring, and type annotations.</li>
    </ul>

<pre><code class="language-python line-numbers">import functools

def decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
</code></pre>

    <br/>
    <ul>
        <li><b>Always</b> use <code>@wraps</code> for clean and correct behavior.</li>
    </ul>

    <br/><br/>



    <li><b>Decorators With Parameters</b></li>
    <br/>
    <ul>
        <li>Sometimes you want the decorator itself to accept arguments.</li>
        <li>This requires *three* layers of functions:</li>
    </ul>

<pre><code class="language-python line-numbers">def repeat(n):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def hello():
    print("Hello")

hello()
</code></pre>

    <br/>
    <ul>
        <li>Result prints ‚ÄúHello‚Äù three times.</li>
    </ul>

    <br/><br/>



    <li><b>Class-Based Decorators</b></li>
    <br/>
    <ul>
        <li>Any object with <code>__call__</code> can be a decorator.</li>
    </ul>

<pre><code class="language-python line-numbers">class Decorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print("Before")
        value = self.func(*args, **kwargs)
        print("After")
        return value

@Decorator
def greet():
    print("Hi!")

greet()
</code></pre>

    <br/><br/>



    <li><b>Decorators for Methods</b></li>
    <br/>
    <ul>
        <li>Methods automatically receive <code>self</code>, and wrappers must accept it.</li>
    </ul>

<pre><code class="language-python line-numbers">def log_method(func):
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        print(f"Method {func.__name__} called")
        return func(self, *args, **kwargs)
    return wrapper

class A:
    @log_method
    def hello(self):
        print("Hello")
</code></pre>

    <br/><br/>



    <li><b>Decorating Class Methods (classmethod, staticmethod)</b></li>
    <br/>
    <ul>
        <li>Order matters: the decorator is applied to the <b>result</b> of <code>@classmethod</code> or <code>@staticmethod</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("Debug:", func.__name__)
        return func(*args, **kwargs)
    return wrapper

class C:
    @debug
    @classmethod
    def foo(cls):
        print("Class method")
</code></pre>

    <br/><br/>



    <li><b>Real-World Decorator Examples</b></li>
    <br/>

    <li><b>1. Logging</b></li>

<pre><code class="language-python line-numbers">def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"{func.__name__} called")
        return func(*args, **kwargs)
    return wrapper

@log
def work():
    print("Working...")
</code></pre>

    <br/><br/>



    <li><b>2. Timing</b></li>

<pre><code class="language-python line-numbers">import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        value = func(*args, **kwargs)
        end = time.perf_counter()
        print(f"{func.__name__} took {end-start:.5f}s")
        return value
    return wrapper
</code></pre>

    <br/><br/>



    <li><b>3. Memoization / Caching</b></li>

<pre><code class="language-python line-numbers">def cache(func):
    stored = {}
    @functools.wraps(func)
    def wrapper(x):
        if x not in stored:
            stored[x] = func(x)
        return stored[x]
    return wrapper
</code></pre>

    <br/><br/>



    <li><b>4. Authorization (permissions)</b></li>

<pre><code class="language-python line-numbers">def require_admin(func):
    @functools.wraps(func)
    def wrapper(user, *args, **kwargs):
        if user != "admin":
            raise PermissionError("Not allowed")
        return func(user, *args, **kwargs)
    return wrapper
</code></pre>

    <br/><br/>



    <li><b>5. Retry Decorator</b></li>

<pre><code class="language-python line-numbers">import time

def retry(n):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for i in range(n):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"Retry {i+1}/{n}: {e}")
                    time.sleep(1)
            raise RuntimeError("Failed after retries")
        return wrapper
    return decorator
</code></pre>

    <br/><br/>



    <li><b>Decorators for Asynchronous Functions</b></li>
    <br/>

<pre><code class="language-python line-numbers">def async_decorator(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        print("Before await")
        result = await func(*args, **kwargs)
        print("After await")
        return result
    return wrapper
</code></pre>

    <br/><br/>



    <li><b>Stacking Multiple Decorators</b></li>
    <br/>

<pre><code class="language-python line-numbers">@log
@timer
def compute():
    return sum(range(1_000_000))
</code></pre>

    <br/>
    <ul>
        <li>Equivalent to:</li>
    </ul>

<pre><code class="language-text line-numbers">
compute = log(timer(compute))
</code></pre>

    <br/><br/>



    <li><b>Decorators on Classes</b></li>
    <br/>
    <ul>
        <li>You can decorate entire classes (not just methods).</li>
    </ul>

<pre><code class="language-python line-numbers">def make_all_methods_debugged(cls):
    for name, value in cls.__dict__.items():
        if callable(value):
            setattr(cls, name, debug(value))
    return cls

@make_all_methods_debugged
class A:
    def hello(self): print("Hello")
    def world(self): print("World")
</code></pre>

    <br/><br/>



    <li><b>Common Built-In Decorators</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Decorator</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>@staticmethod</code></td>
                <td>Method that has no <code>self</code></td>
            </tr>
            <tr>
                <td><code>@classmethod</code></td>
                <td>Method that receives <code>cls</code> instead of <code>self</code></td>
            </tr>
            <tr>
                <td><code>@property</code></td>
                <td>Turn methods into computed attributes</td>
            </tr>
            <tr>
                <td><code>@functools.lru_cache</code></td>
                <td>Built-in caching decorator</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Decorator</td>
                <td>Function that wraps another function to add behavior</td>
            </tr>
            <tr>
                <td>Wrapper</td>
                <td>Inner function that surrounds the original function</td>
            </tr>
            <tr>
                <td><code>@decorator</code></td>
                <td>Syntax sugar for <code>func = decorator(func)</code></td>
            </tr>
            <tr>
                <td><code>functools.wraps</code></td>
                <td>Keeps metadata (function name, docstring)</td>
            </tr>
            <tr>
                <td>Decorator arguments</td>
                <td>Requires 3-layer structure: <code>decorator(args) ‚Üí decorator ‚Üí wrapper</code></td>
            </tr>
            <tr>
                <td>Common uses</td>
                <td>logging, caching, timing, authentication, retries</td>
            </tr>
            <tr>
                <td>Advanced</td>
                <td>class decorators, async decorators, stacked decorators</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-async-intro">Introduction to Python Async Programming</h3>
<ol>

    <li><b>What Is Asynchronous Programming in Python?</b></li>
    <br/>
    <ul>
        <li><u>Asynchronous programming</u> allows Python to run many tasks "at the same time" without blocking the main thread.</li>
        <br/>
        <li>It is designed for tasks that involve:
            <ul>
                <li>I/O waiting</li>
                <li>network requests</li>
                <li>database operations</li>
                <li>file system operations</li>
                <li>sleep timers</li>
            </ul>
        </li>
        <br/>
        <li>The idea:
            <ul>
                <li>Instead of <u>waiting</u> for slow I/O, Python switches to another task.</li>
                <li>Your program becomes more efficient and responsive.</li>
            </ul>
        </li>
        <br/>
        <li>It uses a <u>single thread</u>, but manages multiple tasks cooperatively.</li>
        <br/>
        <li>This is different from multithreading or multiprocessing.</li>
    </ul>

    <br/><br/>


    <li><b>Key Terminology</b></li>
    <br/>
    <ul>
        <li><code>Event loop</code>:
            The core engine of async Python that schedules and runs tasks.</li>
        <li><code>Coroutine</code>:
            A special function that can <code>await</code> operations.</li>
        <li><code>Task</code>:
            A scheduled coroutine running on the event loop.</li>
        <li><code>Awaitable</code>:
            Anything you can use inside <code>await</code>.</li>
    </ul>

    <br/><br/>


    <li><b>How Async Differs From Sync Code</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Sync Code</th>
                <th>Async Code</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Runs line by line</td>
                <td>Pauses during slow I/O and resumes later</td>
            </tr>
            <tr>
                <td>Blocks until the operation finishes</td>
                <td>Yields control while waiting</td>
            </tr>
            <tr>
                <td>Great for CPU-heavy tasks</td>
                <td>Great for I/O-heavy tasks</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Basic Syntax:</b> <code>async</code> <b>and</b> <code>await</code></li>
    <br/>
    <ul>
        <li><code>async</code> declares a coroutine function.</li>
        <li><code>await</code> pauses until the awaited operation completes.</li>
    </ul>

<pre><code class="language-python line-numbers">import asyncio

async def greet():
    await asyncio.sleep(1)
    print("Hello async!")

asyncio.run(greet())
</code></pre>

    <ul>
        <li>This prints after 1 second, but without blocking the entire program.</li>
    </ul>

    <br/><br/>


    <li><b>Async Functions Return Coroutines</b></li>
    <br/>
    <ul>
        <li>Calling an async function does NOT execute it immediately:</li>
    </ul>

<pre><code class="language-python line-numbers">async def add(a, b):
    return a + b

result = add(1, 2)
print(result)    # &lt;coroutine object ...&gt;
</code></pre>

    <ul>
        <li>You must run it in the event loop:</li>
    </ul>

<pre><code class="language-python line-numbers">print(asyncio.run(add(1, 2)))    # 3
</code></pre>

    <br/><br/>


    <li><b>Running Multiple Tasks Concurrently</b></li>
    <br/>
    <ul>
        <li>Use <code>asyncio.gather()</code> to run coroutines in parallel.</li>
    </ul>

<pre><code class="language-python line-numbers">async def say(name):
    await asyncio.sleep(1)
    print(name)

async def main():
    await asyncio.gather(
        say("A"),
        say("B"),
        say("C"),
    )

asyncio.run(main())
</code></pre>

    <ul>
        <li>All tasks sleep simultaneously ‚Üí imported for I/O-heavy apps.</li>
    </ul>

    <br/><br/>


    <li><b>Turning Coroutines into Background Tasks</b></li>
    <br/>
    <ul>
        <li>You can schedule a coroutine without waiting for it immediately:</li>
    </ul>

<pre><code class="language-python line-numbers">async def worker():
    await asyncio.sleep(2)
    print("done!")

async def main():
    task = asyncio.create_task(worker())
    print("task started...")
    await task

asyncio.run(main())
</code></pre>

    <ul>
        <li><code>create_task()</code> lets the coroutine run in the background.</li>
    </ul>

    <br/><br/>


    <li><b>Async I/O (Network Example)</b></li>
    <br/>
    <ul>
        <li>Async is especially effective for network operations.</li>
    </ul>

<pre><code class="language-python line-numbers">import asyncio
import aiohttp   # third-party async HTTP client

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            return await resp.text()

async def main():
    content = await fetch("https://example.com")
    print(content[:50])

asyncio.run(main())
</code></pre>

    <ul>
        <li>Async HTTP operations do not block the main loop.</li>
    </ul>

    <br/><br/>


    <li><b>Async Context Managers & Iterators</b></li>
    <br/>
    <ul>
        <li>Some async libraries use special forms:</li>
    </ul>

<pre><code class="language-python line-numbers">async with session.get(url) as resp:
    ...
</code></pre>

<pre><code class="language-python line-numbers">async for msg in websocket:
    print(msg)
</code></pre>

    <ul>
        <li>Same concept as normal context managers but designed for async workflows.</li>
    </ul>

    <br/><br/>


    <li><b>Where Async Shines</b></li>
    <br/>
    <ul>
        <li>Async is ideal when handling many slow I/O tasks:
            <ul>
                <li>web scraping</li>
                <li>chat/notifications</li>
                <li>websocket servers</li>
                <li>microservices</li>
                <li>database queries (async drivers)</li>
                <li>network-bound APIs</li>
            </ul>
        </li>
        <li>Async does NOT speed up CPU-heavy tasks.</li>
    </ul>

    <br/><br/>


    <li><b>Where Async Fails</b></li>
    <br/>
    <ul>
        <li>Async is NOT suited for:
            <ul>
                <li>heavy computations</li>
                <li>data processing</li>
                <li>AI model training</li>
                <li>image/video rendering</li>
            </ul>
        </li>
        <li>In these cases, use:
            <ul>
                <li>multiprocessing</li>
                <li>threading</li>
                <li>NumPy (vectorized computation)</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Combining Async With Django</b></li>
    <br/>
    <ul>
        <li>Django 3.x+ supports async views and middleware.</li>
        <li>Examples:</li>
    </ul>

<pre><code class="language-python line-numbers">async def async_view(request):
    await asyncio.sleep(1)
    return HttpResponse("Async response")
</code></pre>

    <ul>
        <li>But note:
            <ul>
                <li>Django‚Äôs ORM is still mostly synchronous</li>
                <li>You must use async-safe wrappers</li>
                <li>Not all Django features are async-ready</li>
            </ul>
        </li>
    </ul>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-asyncio-run-vs-await">Understanding the Difference Between <code>asyncio.run()</code> and <code>await</code> in Python</h3>
<ol>

    <li><b>Big Picture: What Problem Are We Discussing?</b></li>
    <br/>
    <ul>
        <li>In async Python, you always have two layers:
            <ul>
                <li>Outside world (normal sync code, script entry point)</li>
                <li>Inside async world (coroutines, event loop, <code>await</code>)</li>
            </ul>
        </li>
        <br/>
        <li><code>asyncio.run()</code> is the bridge from the outside world into the async world.</li>
        <br/>
        <li><code>await</code> is how you move forward inside the async world.</li>
        <br/>
        <li>They are not competitors; they operate on different levels:
            <ul>
                <li><code>asyncio.run()</code> ‚Üí used in normal (synchronous) code to start async execution.</li>
                <li><code>await</code> ‚Üí used only inside <code>async def</code> functions to wait for another coroutine.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>What</b> <code>asyncio.run()</code> <b>Actually Does?</b></li>
    <br/>
    <ul>
        <li><code>asyncio.run(coro)</code>:
            <ul>
                <li>creates a brand new event loop</li>
                <li>runs the given coroutine to completion</li>
                <li>handles cancellation and errors</li>
                <li>closes the loop and releases resources</li>
                <li>returns the coroutine's final result (or raises its exception)</li>
            </ul>
        </li>
        <li>It is meant to be used at the <u>top level</u> of your program.</li>
<pre><code class="language-python line-numbers">import asyncio

async def main():
    print("Hello from async world!")
    return 42

result = asyncio.run(main())
print("Result:", result)
</code></pre>
    </ul>

    <ul>
        <li>Here, <code>asyncio.run(main())</code>:
            <ul>
                <li>creates loop</li>
                <li>runs <code>main()</code></li>
                <li>closes loop</li>
                <li>gives you <code>result</code> in normal sync code</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>What</b> <code>await</code> <b>Actually Does?</b></li>
    <br/>
    <ul>
        <li><code>await</code> is a keyword that:
            <ul>
                <li>can only be used inside <code>async def</code></li>
                <li>temporarily suspends the current coroutine</li>
                <li>lets other tasks run while you wait</li>
                <li>resumes when the awaited operation is complete</li>
            </ul>
        </li>
        <li>It does <u>not</u> create an event loop, and it does not enter or exit the async world. It only works when the event loop already exists.</li>
    </ul>

<pre><code class="language-python line-numbers">import asyncio

async def compute():
    print("Start compute")
    await asyncio.sleep(1)
    print("End compute")
    return 10

async def main():
    result = await compute()  # await another coroutine
    print("Result:", result)

asyncio.run(main())
</code></pre>

    <ul>
        <li>Inside <code>main()</code> the event loop is already running, so <code>await</code> is legal.</li>
    </ul>
    <br/><br/>


    <li><b>Key Difference: Where You Can Use Them</b></li>
    <br/>
    <ul>
        <li><code>asyncio.run()</code> can be called only from <u>normal synchronous code</u> (where no event loop is currently running):</li>
    </ul>

<pre><code class="language-python line-numbers"># OK ‚Äì top-level script
if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

    <ul>
        <li><code>await</code> can be used only:
            <ul>
                <li>inside <code>async def</code></li>
                <li>when an event loop is already running</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-python line-numbers"># This is NOT allowed:
result = await compute()  # SyntaxError outside async def
</code></pre>

    <ul>
        <li>In plain Python scripts, you never write <code>await</code> directly at top-level.</li>
    </ul>
    <br/><br/>


    <li><b>Example: Using Both Together Correctly</b></li>
<pre><code class="language-python line-numbers">import asyncio

async def fetch_data():
    print("Fetching...")
    await asyncio.sleep(1)
    print("Done!")
    return {"data": 123}

async def main():
    # We are already inside async world
    result = await fetch_data()
    print("Result from fetch:", result)

# Bridge from sync world to async world
if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

    <ul>
        <li>Flow:
            <ul>
                <li>Script starts in sync world.</li>
                <li><code>asyncio.run(main())</code> enters async world.</li>
                <li><code>await fetch_data()</code> stays inside async world, waiting for another coroutine.</li>
                <li>When done, <code>asyncio.run</code> exits async world and returns control.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>You Cannot Use</b> <code>asyncio.run()</code> <b>Inside a Running Event Loop</b></li>
    <br/>
    <ul>
        <li>If you try to call <code>asyncio.run()</code> from inside an async function (where an event loop is already running), you get an error:</li>
    </ul>

<pre><code class="language-python line-numbers">async def inner():
    # WRONG: this will raise
    asyncio.run(other_coroutine())  # RuntimeError: asyncio.run() cannot be called from a running event loop
</code></pre>

    <ul>
        <li>Inside async code, you must use <code>await</code>, not <code>asyncio.run()</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">async def inner():
    # CORRECT:
    await other_coroutine()
</code></pre>

    <br/><br/>


    <li><b>Summary in one phrase</b>: <code>asyncio.run(coro)</code> blcoks, but <code>await</code> yields.</li>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-c-api-intro">Introduction to the Python C API</h3>
<ol>

    <li><b>What Is the Python C API?</b></li>
    <br/>
    <ul>
        <li>The <u>Python C API</u> is a set of C functions and macros that let you:
            <ul>
                <li>extend Python by writing new modules in C</li>
                <li>embed Python inside a C program</li>
                <li>manipulate Python objects at the C level</li>
                <li>call Python code from C</li>
                <li>write extremely fast code using Python‚Äôs runtime</li>
            </ul>
        </li>
        <br/>
        <li>Many famous Python libraries are powered by the C API:
            <ul>
                <li><b>NumPy</b></li>
                <li><b>pandas</b></li>
                <li><b>uvloop</b></li>
                <li><b>CPython built-ins</b> themselves</li>
            </ul>
        </li>
        <br/>
        <li>It is part of <u>CPython</u>, the ‚Äúdefault‚Äù Python implementation.</li>
        <br/>
        <li>It exposes the same internals Python itself uses.</li>
    </ul>

    <br/><br/>


    <li><b>Basic Structure of a C Extension Module</b></li>
    <br/>
    <ul>
        <li>A typical module contains:
            <ul>
                <li>function implementations</li>
                <li>a table describing functions</li>
                <li>a module definition struct</li>
                <li>an initialization function</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-c line-numbers">#include &lt;Python.h&gt;

static PyObject * add(PyObject * self, PyObject * args) {
    int a, b;
    if (!PyArg_ParseTuple(args, "ii", &amp;a, &amp;b)) {
        return NULL;
    }

    return PyLong_FromLong(a + b);
}

static PyMethodDef MyMethods[] = {
    {"add", add, METH_VARARGS, "Add two numbers"},
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef mymodule = {
    PyModuleDef_HEAD_INIT,
    "mymodule",
    NULL,
    -1,
    MyMethods
};

PyMODINIT_FUNC PyInit_mymodule(void) {
    return PyModule_Create(&amp;mymodule);
}
</code></pre>

    <ul>
        <li>This creates a Python module callable from Python:</li>
    </ul>

<pre><code class="language-python line-numbers">import mymodule
print(mymodule.add(3, 4))   # 7
</code></pre>

    <br/><br/>


    <li><b>The Core Python Object Type:</b> <code>PyObject</code></li>
    <br/>
    <ul>
        <li>Everything in Python is a <code>PyObject*</code>.</li>
        <li>All Python objects share a common base:</li>
    </ul>

<pre><code class="language-c line-numbers">typedef struct _object {
    Py_ssize_t ob_refcnt;   // reference count
    PyTypeObject *ob_type;  // pointer to its type
} PyObject;
</code></pre>

    <ul>
        <li>Examples:
            <ul>
                <li><code>PyLongObject</code> ‚Üí Python int</li>
                <li><code>PyUnicodeObject</code> ‚Üí Python str</li>
                <li><code>PyListObject</code> ‚Üí Python list</li>
            </ul>
        </li>
        <li>The API gives functions to:
            <ul>
                <li>create objects</li>
                <li>inspect them</li>
                <li>modify them</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Reference Counting (IMPORTANT!)</b></li>
    <br/>
    <ul>
        <li>CPython uses <u>reference counting</u> for memory management.</li>
        <li>You must manage reference counts manually:</li>
    </ul>

<pre><code class="language-c line-numbers">Py_INCREF(obj);   // increase reference count
Py_DECREF(obj);   // decrease, free if goes to 0
</code></pre>

    <ul>
        <li>Failure to follow these rules leads to:
            <ul>
                <li><u>memory leaks</u> (forgetting <code>Py_DECREF</code>)</li>
                <li><u>crashes</u> (<code>Py_DECREF</code> too early ‚Üí use-after-free)</li>
            </ul>
        </li>
        <li>Golden rule: ‚ÄúOwn what you create, Py_DECREF when done.‚Äù</li>
    </ul>

    <br/><br/>


    <li><b>Converting Between Python and C Types</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Python</th>
                <th>C API creation</th>
                <th>C API extraction</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>int</td>
                <td><code>PyLong_FromLong</code></td>
                <td><code>PyLong_AsLong</code></td>
            </tr>
            <tr>
                <td>str</td>
                <td><code>PyUnicode_FromString</code></td>
                <td><code>PyUnicode_AsUTF8</code></td>
            </tr>
            <tr>
                <td>list</td>
                <td><code>PyList_New</code></td>
                <td><code>PyList_GetItem</code></td>
            </tr>
            <tr>
                <td>dict</td>
                <td><code>PyDict_New</code></td>
                <td><code>PyDict_GetItem</code></td>
            </tr>
        </tbody>
    </table>

    <br/>
    <ul>
        <li>Example: parsing Python arguments:</li>
    </ul>

<pre><code class="language-c line-numbers">int a, b;
PyArg_ParseTuple(args, "ii", &amp;a, &amp;b);
</code></pre>

    <br/>
    <br/>



    <li><b>Raising Python Exceptions from C</b></li>
    <br/>
    <ul>
        <li>To signal Python errors:</li>
    </ul>

<pre><code class="language-c line-numbers">PyErr_SetString(PyExc_ValueError, "Invalid value");
return NULL;
</code></pre>

    <ul>
        <li>Exceptions propagate up into Python normally.</li>
    </ul>

    <br/>
    <br/>


    <li><b>Embedding Python into a C Program</b></li>
    <br/>
    <ul>
        <li>You can run Python code inside a native C application:</li>
    </ul>

<pre><code class="language-c line-numbers">#include &lt;Python.h&gt;

int main() {
    Py_Initialize();
    PyRun_SimpleString("print('Hello from embedded Python!')");
    Py_Finalize();
    return 0;
}
</code></pre>

    <ul>
        <li>This is how:
            <ul>
                <li>games embed Python scripting</li>
                <li>scientific tools expose Python functionality</li>
                <li>applications allow Python plugin systems</li>
            </ul>
        </li>
    </ul>

    <br/><br/>


    <li><b>Working with Python Modules in C</b></li>
    <br/>
    <ul>
        <li>You can import Python modules from C:</li>
    </ul>

<pre><code class="language-c line-numbers">PyObject * mod    = PyImport_ImportModule("math");
PyObject * func   = PyObject_GetAttrString(mod, "sqrt");
PyObject * result = PyObject_CallFunction(func, "d", 9.0);
</code></pre>

    <ul>
        <li>This lets you call arbitrary Python code from C.</li>
    </ul>

    <br/><br/>


    <li><b>Defining New Python Types in C</b></li>
    <br/>
    <ul>
        <li>You can define new classes implemented in C:</li>
    </ul>

<pre><code class="language-c line-numbers">typedef struct {
    PyObject_HEAD
    double x;
} Point;
</code></pre>

    <ul>
        <li>Django‚Äôs ORM, NumPy arrays, CPython‚Äôs list/dict ‚Äî all use custom C-level types.</li>
    </ul>

    <br/><br/>


    <li><b>The GIL (Global Interpreter Lock)</b></li>
    <br/>
    <ul>
        <li>The C API must follow GIL rules:
            <ul>
                <li>you must hold the GIL when using Python objects</li>
                <li>long-running C code should release the GIL</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-c line-numbers">Py_BEGIN_ALLOW_THREADS
    // long CPU computation here
Py_END_ALLOW_THREADS
</code></pre>

    <ul>
        <li>This is essential for performance in multi-threaded programs.</li>
    </ul>

    <br/><br/>


    <li><b>Building a C Extension Module</b></li>
    <br/>
    <ul>
        <li>A typical <code>setup.py</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">from setuptools import setup, Extension

setup(
    name="mymodule",
    ext_modules=[
        Extension("mymodule", ["mymodule.c"])
    ]
)
</code></pre>

    <ul>
        <li>Build and install:</li>
    </ul>

<pre><code class="language-bash line-numbers">python3 setup.py build
python3 setup.py install
</code></pre>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
