<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>PY</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/python.png" alt="PY Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#python-args-kwargs">Python <code>*args</code> and <code>**kwargs</code></a></li>
        <li><a href="#python-match">Python <code>match</code> Statement</a></li>
        <li><a href="#python-numbers">Numbers in Python</a></li>
    </ul>
</nav>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-args-kwargs">Python <code>*args</code> and <code>**kwargs</code></h3>
<ol>
    <li>In Python, functions can accept a variable number of arguments using two special syntax forms:</li>
    <ul>
        <li><code>*args</code>: captures <u>positional</u> arguments</li>
        <li><code>**kwargs</code>: captures <u>keyword</u> arguments</li>
    </ul>
    <br/><br/>


    <li><b>Positional Variable Arguments: <code>*args</code></b></li>
    <br/>
    <ul>
        <li><code>*args</code> collects extra positional arguments into a tuple.</li>
    </ul>

<pre><code class="language-python line-numbers">def greet(*args):
    print(args)

greet("Hello", "World", 42)
</code></pre>

<pre><code class="language-text">('Hello', 'World', 42)
</code></pre>

    <br/>
    <ul>
        <li>You can loop through <code>args</code> easily:</li>
    </ul>

<pre><code class="language-python line-numbers">def add_all(*args):
    return sum(args)

print(add_all(1, 2, 3, 4))
</code></pre>
    <ul>
        <li>Use <code>*args</code> when you don’t know how many positional arguments you will receive.</li>
    </ul>
    <br/><br/>


    <li><b>Keyword Variable Arguments: <code>**kwargs</code></b></li>
    <br/>
    <ul>
        <li><code>**kwargs</code> collects extra keyword arguments into a dictionary.</li>
    </ul>

<pre><code class="language-python line-numbers">def show_info(**kwargs):
    print(kwargs)

show_info(name="Alice", age=25, city="Berlin")
</code></pre>

<pre><code class="language-text">{'name': 'Alice', 'age': 25, 'city': 'Berlin'}</code></pre>

    <br/>
    <ul>
        <li>You can iterate over the dictionary:</li>
    </ul>

<pre><code class="language-python line-numbers">def print_info(**kwargs):
    for key, value in kwargs.items():
        print(key, "=", value)
</code></pre>
    <br/><br/>


    <li><b>Combining Positional and Keyword Arguments</b></li>
    <br/>
    <ul>
        <li>You can combine both:</li>
    </ul>

<pre><code class="language-python line-numbers">def func(a, b, *args, **kwargs):
    print("a =", a)
    print("b =", b)
    print("args =", args)
    print("kwargs =", kwargs)

func(1, 2, 3, 4, x=10, y=20)
</code></pre>

<pre><code class="language-text">
a = 1
b = 2
args = (3, 4)
kwargs = {'x': 10, 'y': 20}
</code></pre>

    <br/>
    <ul>
        <li><u>Order matters</u> in function definitions:</li>
    </ul>

<pre><code class="language-text">1. normal positional parameters
2. *args
3. keyword-only parameters (optional)
4. **kwargs
</code></pre>

<pre><code class="language-python line-numbers">def example(a, *args, sep="-", **kwargs):
    pass
</code></pre>

    <br/><br/>


    <li><b>Argument Unpacking Using <code>*</code> and <code>**</code></b></li>
    <br/>
    <ul>
        <li>You can unpack lists and dictionaries when calling functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(add(*nums))
</code></pre>

<pre><code class="language-python line-numbers">def format_user(name, age, city):
    return f"{name}, {age}, from {city}"

info = {"name": "Bob", "age": 30, "city": "Hamburg"}
print(format_user(**info))
</code></pre>
    <br/><br/>


    <li><b>Real Use Case: Wrapping Functions (Forwarding Arguments)</b></li>
    <br/>
    <ul>
        <li><code>*args</code> and <code>**kwargs</code> make decorators and wrappers easy:</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(func):
    def wrapper(*args, **kwargs):
        print("Calling:", func.__name__)
        return func(*args, **kwargs)  # forward everything
    return wrapper

@debug
def multiply(x, y):
    return x * y

print(multiply(3, 4))
</code></pre>

    <br/>
    <ul>
        <li>This technique allows arbitrary functions to be wrapped without knowing their signature.</li>
    </ul>
    <br/><br/>


    <li><b>When to Use <code>*args</code> and <code>**kwargs</code>?</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use Case</th>
                <th><code>*args</code></th>
                <th><code>**kwargs</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Unknown number of positional arguments</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Unknown number of keyword arguments</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Forwarding arguments in decorators/wrappers</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Passing configuration options</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Building flexible API helpers</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Common Mistakes</b></li>
    <br/>
    <ul>
        <li><u>Wrong order</u> in function signature:</li>
    </ul>

<pre><code class="language-py line-numbers">def wrong(**kwargs, *args):  # ❌ invalid</code></pre>

    <br/>
    <ul>
        <li><b>Using args or kwargs without</b> <code>*</code>:</li>
    </ul>

<pre><code class="language-py line-numbers">def f(args):  # ❌ not the same as *args
    pass
</code></pre>

    <br/>
    <ul>
        <li>Forgetting to unpack:</li>
    </ul>

<pre><code class="language-python line-numbers">def f(a, b):
    return a + b

nums = (1, 2)
# f(nums) ❌ TypeError
f(*nums)   # ✔ correct
</code></pre>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>*args</code></td>
                <td>Captures extra positional arguments into a tuple.</td>
            </tr>
            <tr>
                <td><code>**kwargs</code></td>
                <td>Captures extra keyword arguments into a dictionary.</td>
            </tr>
            <tr>
                <td>Unpacking</td>
                <td><code>*</code> unpacks lists/tuples, <code>**</code> unpacks dictionaries.</td>
            </tr>
            <tr>
                <td>Decorator usage</td>
                <td>Forward arguments to wrapped functions easily.</td>
            </tr>
            <tr>
                <td>Best practice</td>
                <td><code>a, *args, sep="-", **kwargs</code> follows correct ordering.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-match">Python <code>match</code> Statement (Structural Pattern Matching)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>match</code> statement was introduced in <u>Python 3.10</u>.</li>
        <br/>
        <li>Patterns can match:
            <ul>
                <li>values</li>
                <li>types</li>
                <li>structures (lists, dicts, tuples)</li>
                <li>classes</li>
                <li>guards (conditions)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Value Matching</b></li>
    <br/>

<pre><code class="language-python line-numbers">def check_status(code):
    match code:
        case 200:
            return "OK"
        case 404:
            return "Not Found"
        case 500:
            return "Server Error"
        case _:
            return "Unknown"
</code></pre>

    <br/>
    <ul>
        <li><code>_</code> is the wildcard catch-all.</li>
    </ul>
    <br/><br/>



    <li><b>Match Multiple Values in One Case</b></li>
    <br/>

<pre><code class="language-python line-numbers">match command:
    case "start" | "run":
        print("Starting...")
    case "stop" | "quit":
        print("Stopping...")
    case _:
        print("Unknown command")
</code></pre>

    <br/>
    <ul>
        <li>Use <code>|</code> (“OR”) for multi-pattern matching.</li>
    </ul>
    <br/><br/>


    <li><b>Capturing Values</b></li>
    <br/>
    <ul>
        <li>
            With <code>match</code>, Python can look at a value (often coming from user input or a function)
            and check whether it fits a certain “shape”.<br/>
            While doing that, it can also <b>capture parts of the value</b> into variables.
        </li>
    </ul>
<pre><code class="language-python line-numbers"># Example commands your program might receive
user_input = ("add", 10, 20)
# user_input = ("echo", "Hello")
# user_input = ("quit",)

match user_input:
    case ("add", x, y):
        # The tuple matches ("add", something, something)
        # The two values are captured as x and y
        print(x + y)

    case ("echo", message):
        # Matches a tuple with 2 elements: ("echo", some_text)
        # 'message' captures the second element
        print(message)

    case ("quit",):
        # Matches a single-element tuple
        print("Goodbye!")

    case _:
        # Anything else that doesn't fit the patterns
        print("Unknown command")
</code></pre>

    <br/>
    <ul>
        <li>
            Capturing lets you extract needed values directly inside the pattern.
            No manual unpacking or indexing is needed.
        </li>
    </ul>
    <br/><br/>



    <li><b>Sequence Pattern Matching</b></li>
    <br/>
<pre><code class="language-python line-numbers">match data:
    case [x, y]:
        print(f"Two elements: {x}, {y}")
    case [x, y, z]:
        print(f"Three elements: {x}, {y}, {z}")
    case [first, *rest]:
        print("First element:", first)
        print("Remaining:", rest)
</code></pre>

    <br/>
    <ul>
        <li><code>*rest</code> works like in argument unpacking.</li>
    </ul>
    <br/><br/>



    <li><b>Matching Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers">match config:
    case {"mode": "debug", "level": lvl}:
        print("Debug level:", lvl)
    case {"mode": "production"}:
        print("Running in prod mode")
    case _:
        print("Unknown config")
</code></pre>

    <br/>
    <ul>
        <li>Keys must match exactly; extra keys are allowed unless restricted.</li>
    </ul>
    <br/><br/>



    <li><b>Matching Classes (Object Patterns)</b></li>
    <br/>
<pre><code class="language-python line-numbers">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def describe(p):
    match p:
        case Point(x=0, y=0):
            return "Origin"
        case Point(x, y):
            return f"Point({x}, {y})"
</code></pre>

    <br/>
    <ul>
        <li>You can match attributes by name.</li>
    </ul>
    <br/><br/>



    <li><b>Using Guards (<code>if</code> conditions)</b></li>
    <br/>

<pre><code class="language-python line-numbers">match value:
    case x if x &gt; 0:
        print("Positive")
    case x if x &lt; 0:
        print("Negative")
    case 0:
        print("Zero")
</code></pre>
    <br/><br/>



    <li><b>Matching Enums</b></li>
    <br/>

<pre><code class="language-python line-numbers">from enum import Enum

class State(Enum):
    READY   = 1
    RUNNING = 2
    STOPPED = 3

match state:
    case State.READY:
        print("Ready")
    case State.RUNNING:
        print("Running")
    case State.STOPPED:
        print("Stopped")
</code></pre>
    <br/><br/>



    <li><b>Combining Patterns</b></li>
    <br/>

<pre><code class="language-python line-numbers">match event:
    case {"type": "click", "pos": (x, y)}:
        print("Clicked:", x, y)
    case {"type": "keypress", "key": k} if k.isalpha():
        print("Pressed a letter:", k)
    case {"type": "keypress", "key": k}:
        print("Pressed:", k)
    case _:
        print("Unknown event")
</code></pre>

    <br/><br/>


    <li><b>Common Mistakes</b></li>
    <br/>
    <ul>
        <li><b>Using <code>=</code> instead of <code>==</code> inside patterns</b></li>
    </ul>

<pre><code class="language-py line-numbers">case x = 10   # ❌ invalid
case 10       # ✔ correct
</code></pre>

    <br/>

    <ul>
        <li><b>Misunderstanding variable binding</b>—patterns like <code>case x</code> assign to <code>x</code>, they don’t compare.</li>
    </ul>

<pre><code class="language-python line-numbers">match value:
    case x:      # ALWAYS matches, captures value into x
        print("Matched:", x)
</code></pre>

    <br/>

    <ul>
        <li>To compare against variable <code>x</code>, prefix with <code>.</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">x = 10
match value:
    case .x:         # match literal value of x
        print("value is 10")
</code></pre>

    <br/><br/>



    <li><b>Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Value patterns</td>
                <td>Compare exact literals (200, "ok", etc.)</td>
            </tr>
            <tr>
                <td>OR-patterns</td>
                <td><code>"a" | "b"</code> matches either</td>
            </tr>
            <tr>
                <td>Sequence patterns</td>
                <td>Match lists/tuples, use <code>*rest</code></td>
            </tr>
            <tr>
                <td>Mapping patterns</td>
                <td>Match dictionaries by key</td>
            </tr>
            <tr>
                <td>Class patterns</td>
                <td>Match objects by attribute</td>
            </tr>
            <tr>
                <td>Guards</td>
                <td><code>case x if condition</code></td>
            </tr>
            <tr>
                <td>Wildcard</td>
                <td><code>_</code> matches anything</td>
            </tr>
            <tr>
                <td>Variable capture</td>
                <td>Patterns bind matched values to variables</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-numbers">Python Numbers</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python provides several built-in numeric types to represent and manipulate numbers.</li>
        <br/>
        <li>The three most common numeric types are:</li>
        <ul>
            <li><b>int</b>: integers of unlimited size</li>
            <li><b>float</b>: double-precision floating-point numbers</li>
            <li><b>complex</b>: numbers with real and imaginary parts</li>
        </ul>
        <br/>
        <li>Python also provides many built-in arithmetic operators, numeric functions, and modules like <code>math</code> and <code>decimal</code>.</li>
    </ul>
    <br/><br/>



    <li><b>Integers (<code>int</code>)</b></li>
    <br/>
    <ul>
        <li>Integers represent whole numbers and have <u>arbitrary precision</u> in Python.</li>
    </ul>

<pre><code class="language-python line-numbers">a = 123
b = -42
c = 10_000_000  # underscores allowed for readability
print(a, b, c)
</code></pre>

    <br/>
    <ul>
        <li>Python automatically grows integer size when needed:</li>
    </ul>

<pre><code class="language-python line-numbers">x = 10 ** 100
print(x)
</code></pre>

    <br/><br/>



    <li><b>Floating-Point Numbers (<code>float</code>)</b></li>
    <br/>
    <ul>
        <li>Python <code>float</code> represents 64-bit IEEE 754 “double precision”.</li>
        <li>Floats support decimals, scientific notation, and infinite/NaN values.</li>
    </ul>

<pre><code class="language-python line-numbers">x = 3.14
y = 2.5e6      # scientific notation
z = float("inf")
w = float("nan")

print(x, y, z, w)
</code></pre>

    <br/>
    <ul>
        <li><b>Be careful:</b> floats have rounding errors:</li>
    </ul>

<pre><code class="language-python line-numbers">print(0.1 + 0.2)   # 0.30000000000000004
</code></pre>

    <br/><br/>



    <li><b>Complex Numbers (<code>complex</code>)</b></li>
    <br/>
    <ul>
        <li>Python has native support for complex numbers using <code>j</code> for the imaginary part:</li>
    </ul>

<pre><code class="language-python line-numbers">c = 3 + 4j
print(c.real)
print(c.imag)
</code></pre>

    <br/>
    <ul>
        <li>Operations work naturally:</li>
    </ul>

<pre><code class="language-python line-numbers">z1 = 1 + 2j
z2 = 2 - 3j
print(z1 + z2)
print(z1 * z2)
</code></pre>

    <br/><br/>



    <li><b>Basic Arithmetic Operators</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = 10
b = 3
print(a + b)   # addition
print(a - b)   # subtraction
print(a * b)   # multiplication
print(a / b)   # float division
print(a // b)  # integer division
print(a % b)   # remainder
print(a ** b)  # exponentiation
</code></pre>

    <br/>
    <ul>
        <li><code>//</code> always returns a number rounded down.</li>
    </ul>

<pre><code class="language-python line-numbers">print(-7 // 3)  # -3, because floor(-7/3) = -3
</code></pre>

    <br/><br/>



    <li><b>Type Conversion</b></li>
    <br/>
    <ul>
        <li>Explicit conversions between types:</li>
    </ul>

<pre><code class="language-python line-numbers">int(3.99)       # 3
float(10)       # 10.0
complex(3)      # (3+0j)
</code></pre>

    <br/>
    <ul>
        <li>Strings can be converted if formatted correctly:</li>
    </ul>

<pre><code class="language-python line-numbers">int("42")
float("3.14")
complex("2+5j")
</code></pre>

    <br/><br/>



    <li><b>Built-in Numeric Functions</b></li>
<pre><code class="language-python line-numbers">abs(-5)         # 5
round(3.567, 2) # 3.57
pow(2, 5)       # 32
max(1, 4, 2)    # 4
min(1, 4, 2)    # 1
</code></pre>

    <br/><br/>



    <li><b>The <code>math</code> Module</b></li>
    <br/>
    <ul>
        <li><code>math</code> provides mathematical functions for floats.</li>
    </ul>

<pre><code class="language-python line-numbers">import math

print(math.sqrt(16))
print(math.sin(math.pi / 2))
print(math.factorial(5))
</code></pre>

    <br/>
    <ul>
        <li><code>math</code> has no support for complex numbers — use <code>cmath</code> instead.</li>
    </ul>
    <br/><br/>



    <li><b>Decimals for High-Precision Calculations</b></li>
    <br/>
    <ul>
        <li>Use <code>decimal.Decimal</code> when you need accurate decimal arithmetic (e.g., finance).</li>
    </ul>

<pre><code class="language-python line-numbers">from decimal import Decimal

print(Decimal("0.1") + Decimal("0.2"))  # 0.3 exactly
</code></pre>

    <br/><br/>



    <li><b>Fractions for Rational Numbers</b></li>
    <br/>

<pre><code class="language-python line-numbers">from fractions import Fraction

x = Fraction(1, 3)
y = Fraction(1, 6)
print(x + y)   # 1/2
</code></pre>

    <br/><br/>



    <li><b>Checking Number Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">isinstance(10, int)
isinstance(3.14, float)
isinstance(2 + 3j, complex)
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Numeric Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>int</code></td>
                <td>Whole numbers with arbitrary precision</td>
            </tr>
            <tr>
                <td><code>float</code></td>
                <td>64-bit floating-point (may have rounding errors)</td>
            </tr>
            <tr>
                <td><code>complex</code></td>
                <td>Numbers with real and imaginary parts</td>
            </tr>
            <tr>
                <td><code>Decimal</code></td>
                <td>High-precision decimal arithmetic</td>
            </tr>
            <tr>
                <td><code>Fraction</code></td>
                <td>Exact rational numbers</td>
            </tr>
            <tr>
                <td><code>math</code></td>
                <td>Math functions for real numbers</td>
            </tr>
            <tr>
                <td><code>cmath</code></td>
                <td>Math functions for complex numbers</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
