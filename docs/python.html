<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>PY</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "Ê•∑‰Ωì", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/python.png" alt="PY Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#python-args-kwargs">Python <code>*args</code> and <code>**kwargs</code></a></li>
        <li><a href="#python-match">Python <code>match</code> Statement</a></li>
        <li><a href="#python-numbers">Python Numbers</a></li>
        <li><a href="#python-text">Python Text (Strings)</a></li>
        <li><a href="#python-lists">Python Lists</a></li>
        <li><a href="#python-type-annotations">Python Type Annotations</a></li>
        <li><a href="#python-protocol"><code>Protocol</code></a></li>
        <li><a href="#python-typeddict"><code>TypedDict</code></a></li>
        <li><a href="#python-type-checkers">Type Checkers: mypy, pyright, and ruff</a></li>
        <li><a href="#python-special-function-parameters">Special Parameters</a></li>
        <li><a href="#python-range"><code>range</code></a></li>
        <li><a href="#python-lambda">Lambda Expressions</a></li>
        <li><a href="#python-docstrings">Documentation Strings</a></li>
    </ul>
</nav>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-args-kwargs">Python <code>*args</code> and <code>**kwargs</code></h3>
<ol>
    <li>In Python, functions can accept a variable number of arguments using two special syntax forms:</li>
    <ul>
        <li><code>*args</code>: captures <u>positional</u> arguments</li>
        <li><code>**kwargs</code>: captures <u>keyword</u> arguments</li>
    </ul>
    <br/><br/>


    <li><b>Positional Variable Arguments: <code>*args</code></b></li>
    <br/>
    <ul>
        <li><code>*args</code> collects extra positional arguments into a tuple.</li>
    </ul>

<pre><code class="language-python line-numbers">def greet(*args):
    print(args)

greet("Hello", "World", 42)
</code></pre>

<pre><code class="language-text">('Hello', 'World', 42)
</code></pre>

    <br/>
    <ul>
        <li>You can loop through <code>args</code> easily:</li>
    </ul>

<pre><code class="language-python line-numbers">def add_all(*args):
    return sum(args)

print(add_all(1, 2, 3, 4))
</code></pre>
    <ul>
        <li>Use <code>*args</code> when you don‚Äôt know how many positional arguments you will receive.</li>
    </ul>
    <br/><br/>


    <li><b>Keyword Variable Arguments: <code>**kwargs</code></b></li>
    <br/>
    <ul>
        <li><code>**kwargs</code> collects extra keyword arguments into a dictionary.</li>
    </ul>

<pre><code class="language-python line-numbers">def show_info(**kwargs):
    print(kwargs)

show_info(name="Ammy", age=25, city="Berlin")
</code></pre>

<pre><code class="language-text">{'name': 'Ammy', 'age': 25, 'city': 'Berlin'}</code></pre>

    <br/>
    <ul>
        <li>You can iterate over the dictionary:</li>
    </ul>

<pre><code class="language-python line-numbers">def print_info(**kwargs):
    for key, value in kwargs.items():
        print(key, "=", value)
</code></pre>
    <br/><br/>


    <li><b>Combining Positional and Keyword Arguments</b></li>
    <br/>
    <ul>
        <li>You can combine both:</li>
    </ul>

<pre><code class="language-python line-numbers">def func(a, b, *args, **kwargs):
    print("a =", a)
    print("b =", b)
    print("args =", args)
    print("kwargs =", kwargs)

func(1, 2, 3, 4, x=10, y=20)
</code></pre>

<pre><code class="language-text">
a = 1
b = 2
args = (3, 4)
kwargs = {'x': 10, 'y': 20}
</code></pre>

    <br/>
    <ul>
        <li><u>Order matters</u> in function definitions:</li>
    </ul>

<pre><code class="language-text">1. normal positional parameters
2. *args
3. keyword-only parameters (optional)
4. **kwargs
</code></pre>

<pre><code class="language-python line-numbers">def example(a, *args, sep="-", **kwargs):
    pass
</code></pre>

    <br/><br/>


    <li><b>Argument Unpacking Using <code>*</code> and <code>**</code></b></li>
    <br/>
    <ul>
        <li>You can unpack lists and dictionaries when calling functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(add(*nums))
</code></pre>

<pre><code class="language-python line-numbers">def format_user(name, age, city):
    return f"{name}, {age}, from {city}"

info = {"name": "Bob", "age": 30, "city": "Hamburg"}
print(format_user(**info))
</code></pre>
    <br/><br/>


    <li><b>Real Use Case: Wrapping Functions (Forwarding Arguments)</b></li>
    <br/>
    <ul>
        <li><code>*args</code> and <code>**kwargs</code> make decorators and wrappers easy:</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(func):
    def wrapper(*args, **kwargs):
        print("Calling:", func.__name__)
        return func(*args, **kwargs)  # forward everything
    return wrapper

@debug
def multiply(x, y):
    return x * y

print(multiply(3, 4))
</code></pre>

    <br/>
    <ul>
        <li>This technique allows arbitrary functions to be wrapped without knowing their signature.</li>
    </ul>
    <br/><br/>


    <li><b>When to Use <code>*args</code> and <code>**kwargs</code>?</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Use Case</th>
                <th><code>*args</code></th>
                <th><code>**kwargs</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Unknown number of positional arguments</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Unknown number of keyword arguments</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Forwarding arguments in decorators/wrappers</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Passing configuration options</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Building flexible API helpers</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Common Mistakes</b></li>
    <br/>
    <ul>
        <li><u>Wrong order</u> in function signature:</li>
    </ul>

<pre><code class="language-py line-numbers">def wrong(**kwargs, *args):  # ‚ùå invalid</code></pre>

    <br/>
    <ul>
        <li><b>Using args or kwargs without</b> <code>*</code>:</li>
    </ul>

<pre><code class="language-py line-numbers">def f(args):  # ‚ùå not the same as *args
    pass
</code></pre>

    <br/>
    <ul>
        <li>Forgetting to unpack:</li>
    </ul>

<pre><code class="language-python line-numbers">def f(a, b):
    return a + b

nums = (1, 2)
# f(nums) ‚ùå TypeError
f(*nums)   # ‚úî correct
</code></pre>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>*args</code></td>
                <td>Captures extra positional arguments into a tuple.</td>
            </tr>
            <tr>
                <td><code>**kwargs</code></td>
                <td>Captures extra keyword arguments into a dictionary.</td>
            </tr>
            <tr>
                <td>Unpacking</td>
                <td><code>*</code> unpacks lists/tuples, <code>**</code> unpacks dictionaries.</td>
            </tr>
            <tr>
                <td>Decorator usage</td>
                <td>Forward arguments to wrapped functions easily.</td>
            </tr>
            <tr>
                <td>Best practice</td>
                <td><code>a, *args, sep="-", **kwargs</code> follows correct ordering.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-match">Python <code>match</code> Statement (Structural Pattern Matching)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>match</code> statement was introduced in <u>Python 3.10</u>.</li>
        <br/>
        <li>Patterns can match:
            <ul>
                <li>values</li>
                <li>types</li>
                <li>structures (lists, dicts, tuples)</li>
                <li>classes</li>
                <li>guards (conditions)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Basic Value Matching</b></li>
    <br/>

<pre><code class="language-python line-numbers">def check_status(code):
    match code:
        case 200:
            return "OK"
        case 404:
            return "Not Found"
        case 500:
            return "Server Error"
        case _:
            return "Unknown"
</code></pre>

    <br/>
    <ul>
        <li><code>_</code> is the wildcard catch-all.</li>
    </ul>
    <br/><br/>



    <li><b>Match Multiple Values in One Case</b></li>
    <br/>

<pre><code class="language-python line-numbers">match command:
    case "start" | "run":
        print("Starting...")
    case "stop" | "quit":
        print("Stopping...")
    case _:
        print("Unknown command")
</code></pre>

    <br/>
    <ul>
        <li>Use <code>|</code> (‚ÄúOR‚Äù) for multi-pattern matching.</li>
    </ul>
    <br/><br/>


    <li><b>Capturing Values</b></li>
    <br/>
    <ul>
        <li>
            With <code>match</code>, Python can look at a value (often coming from user input or a function)
            and check whether it fits a certain ‚Äúshape‚Äù.<br/>
            While doing that, it can also <b>capture parts of the value</b> into variables.
        </li>
    </ul>
<pre><code class="language-python line-numbers"># Example commands your program might receive
user_input = ("add", 10, 20)
# user_input = ("echo", "Hello")
# user_input = ("quit",)

match user_input:
    case ("add", x, y):
        # The tuple matches ("add", something, something)
        # The two values are captured as x and y
        print(x + y)

    case ("echo", message):
        # Matches a tuple with 2 elements: ("echo", some_text)
        # 'message' captures the second element
        print(message)

    case ("quit",):
        # Matches a single-element tuple
        print("Goodbye!")

    case _:
        # Anything else that doesn't fit the patterns
        print("Unknown command")
</code></pre>

    <br/>
    <ul>
        <li>
            Capturing lets you extract needed values directly inside the pattern.
            No manual unpacking or indexing is needed.
        </li>
    </ul>
    <br/><br/>



    <li><b>Sequence Pattern Matching</b></li>
    <br/>
<pre><code class="language-python line-numbers">match data:
    case [x, y]:
        print(f"Two elements: {x}, {y}")
    case [x, y, z]:
        print(f"Three elements: {x}, {y}, {z}")
    case [first, *rest]:
        print("First element:", first)
        print("Remaining:", rest)
</code></pre>

    <br/>
    <ul>
        <li><code>*rest</code> works like in argument unpacking.</li>
    </ul>
    <br/><br/>



    <li><b>Matching Dictionaries</b></li>
    <br/>

<pre><code class="language-python line-numbers">match config:
    case {"mode": "debug", "level": lvl}:
        print("Debug level:", lvl)
    case {"mode": "production"}:
        print("Running in prod mode")
    case _:
        print("Unknown config")
</code></pre>

    <br/>
    <ul>
        <li>Keys must match exactly; extra keys are allowed unless restricted.</li>
    </ul>
    <br/><br/>



    <li><b>Matching Classes (Object Patterns)</b></li>
    <br/>
<pre><code class="language-python line-numbers">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def describe(p):
    match p:
        case Point(x=0, y=0):
            return "Origin"
        case Point(x, y):
            return f"Point({x}, {y})"
</code></pre>

    <br/>
    <ul>
        <li>You can match attributes by name.</li>
    </ul>
    <br/><br/>



    <li><b>Using Guards (<code>if</code> conditions)</b></li>
    <br/>

<pre><code class="language-python line-numbers">match value:
    case x if x &gt; 0:
        print("Positive")
    case x if x &lt; 0:
        print("Negative")
    case 0:
        print("Zero")
</code></pre>
    <br/><br/>



    <li><b>Matching Enums</b></li>
    <br/>

<pre><code class="language-python line-numbers">from enum import Enum

class State(Enum):
    READY   = 1
    RUNNING = 2
    STOPPED = 3

match state:
    case State.READY:
        print("Ready")
    case State.RUNNING:
        print("Running")
    case State.STOPPED:
        print("Stopped")
</code></pre>
    <br/><br/>



    <li><b>Combining Patterns</b></li>
    <br/>

<pre><code class="language-python line-numbers">match event:
    case {"type": "click", "pos": (x, y)}:
        print("Clicked:", x, y)
    case {"type": "keypress", "key": k} if k.isalpha():
        print("Pressed a letter:", k)
    case {"type": "keypress", "key": k}:
        print("Pressed:", k)
    case _:
        print("Unknown event")
</code></pre>

    <br/><br/>


    <li><b>Common Mistakes</b></li>
    <br/>
    <ul>
        <li><b>Using <code>=</code> instead of <code>==</code> inside patterns</b></li>
    </ul>

<pre><code class="language-py line-numbers">case x = 10   # ‚ùå invalid
case 10       # ‚úî correct
</code></pre>

    <br/>

    <ul>
        <li><b>Misunderstanding variable binding</b>‚Äîpatterns like <code>case x</code> assign to <code>x</code>, they don‚Äôt compare.</li>
    </ul>

<pre><code class="language-python line-numbers">match value:
    case x:      # ALWAYS matches, captures value into x
        print("Matched:", x)
</code></pre>

    <br/>

    <ul>
        <li>To compare against variable <code>x</code>, prefix with <code>.</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">x = 10
match value:
    case .x:         # match literal value of x
        print("value is 10")
</code></pre>

    <br/><br/>



    <li><b>Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Value patterns</td>
                <td>Compare exact literals (200, "ok", etc.)</td>
            </tr>
            <tr>
                <td>OR-patterns</td>
                <td><code>"a" | "b"</code> matches either</td>
            </tr>
            <tr>
                <td>Sequence patterns</td>
                <td>Match lists/tuples, use <code>*rest</code></td>
            </tr>
            <tr>
                <td>Mapping patterns</td>
                <td>Match dictionaries by key</td>
            </tr>
            <tr>
                <td>Class patterns</td>
                <td>Match objects by attribute</td>
            </tr>
            <tr>
                <td>Guards</td>
                <td><code>case x if condition</code></td>
            </tr>
            <tr>
                <td>Wildcard</td>
                <td><code>_</code> matches anything</td>
            </tr>
            <tr>
                <td>Variable capture</td>
                <td>Patterns bind matched values to variables</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-numbers">Python Numbers</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python provides several built-in numeric types to represent and manipulate numbers.</li>
        <br/>
        <li>The three most common numeric types are:</li>
        <ul>
            <li><b>int</b>: integers of unlimited size</li>
            <li><b>float</b>: double-precision floating-point numbers</li>
            <li><b>complex</b>: numbers with real and imaginary parts</li>
        </ul>
        <br/>
        <li>Python also provides many built-in arithmetic operators, numeric functions, and modules like <code>math</code> and <code>decimal</code>.</li>
    </ul>
    <br/><br/>



    <li><b>Integers (<code>int</code>)</b></li>
    <br/>
    <ul>
        <li>Integers represent whole numbers and have <u>arbitrary precision</u> in Python.</li>
    </ul>

<pre><code class="language-python line-numbers">a = 123
b = -42
c = 10_000_000  # underscores allowed for readability
print(a, b, c)
</code></pre>

    <br/>
    <ul>
        <li>Python automatically grows integer size when needed:</li>
    </ul>

<pre><code class="language-python line-numbers">x = 10 ** 100
print(x)
</code></pre>

    <br/><br/>



    <li><b>Floating-Point Numbers (<code>float</code>)</b></li>
    <br/>
    <ul>
        <li>Python <code>float</code> represents 64-bit IEEE 754 ‚Äúdouble precision‚Äù.</li>
        <li>Floats support decimals, scientific notation, and infinite/NaN values.</li>
    </ul>

<pre><code class="language-python line-numbers">x = 3.14
y = 2.5e6      # scientific notation
z = float("-inf")
w = float("nan")

print(x, y, z, w)
</code></pre>

    <br/>
    <ul>
        <li><b>Be careful:</b> floats have rounding errors:</li>
    </ul>

<pre><code class="language-python line-numbers">print(0.1 + 0.2)   # 0.30000000000000004
</code></pre>

    <br/><br/>



    <li><b>Complex Numbers (<code>complex</code>)</b></li>
    <br/>
    <ul>
        <li>Python has native support for complex numbers using <code>j</code> for the imaginary part:</li>
    </ul>

<pre><code class="language-python line-numbers">c = 3 + 4j
print(c.real)
print(c.imag)
</code></pre>

    <br/>
    <ul>
        <li>Operations work naturally:</li>
    </ul>

<pre><code class="language-python line-numbers">z1 = 1 + 2j
z2 = 2 - 3j
print(z1 + z2)
print(z1 * z2)
</code></pre>

    <br/><br/>



    <li><b>Basic Arithmetic Operators</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = 10
b = 3
print(a + b)   # addition
print(a - b)   # subtraction
print(a * b)   # multiplication
print(a / b)   # float division
print(a // b)  # integer division
print(a % b)   # remainder
print(a ** b)  # exponentiation
</code></pre>

    <br/>
    <ul>
        <li><code>//</code> always returns a number rounded down.</li>
    </ul>

<pre><code class="language-python line-numbers">print(-7 // 3)  # -3, because floor(-7/3) = -3
</code></pre>

    <br/><br/>



    <li><b>Type Conversion</b></li>
    <br/>
    <ul>
        <li>Explicit conversions between types:</li>
    </ul>

<pre><code class="language-python line-numbers">int(3.99)       # 3
float(10)       # 10.0
complex(3)      # (3+0j)
</code></pre>

    <br/>
    <ul>
        <li>Strings can be converted if formatted correctly:</li>
    </ul>

<pre><code class="language-python line-numbers">int("42")
float("3.14")
complex("2+5j")
</code></pre>

    <br/><br/>



    <li><b>Built-in Numeric Functions</b></li>
<pre><code class="language-python line-numbers">abs(-5)         # 5
round(3.567, 2) # 3.57
pow(2, 5)       # 32
max(1, 4, 2)    # 4
min(1, 4, 2)    # 1
</code></pre>

    <br/><br/>



    <li><b>The <code>math</code> Module</b></li>
    <br/>
    <ul>
        <li><code>math</code> provides mathematical functions for floats.</li>
    </ul>

<pre><code class="language-python line-numbers">import math

print(math.sqrt(16))
print(math.sin(math.pi / 2))
print(math.factorial(5))
</code></pre>

    <br/>
    <ul>
        <li><code>math</code> has no support for complex numbers ‚Äî use <code>cmath</code> instead.</li>
    </ul>
    <br/><br/>



    <li><b>Decimals for High-Precision Calculations</b></li>
    <br/>
    <ul>
        <li>Use <code>decimal.Decimal</code> when you need accurate decimal arithmetic (e.g., finance).</li>
    </ul>

<pre><code class="language-python line-numbers">from decimal import Decimal

print(Decimal("0.1") + Decimal("0.2"))  # 0.3 exactly
</code></pre>

    <br/><br/>



    <li><b>Fractions for Rational Numbers</b></li>
    <br/>

<pre><code class="language-python line-numbers">from fractions import Fraction

x = Fraction(1, 3)
y = Fraction(1, 6)
print(x + y)   # 1/2
</code></pre>

    <br/><br/>



    <li><b>Checking Number Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">isinstance(10, int)
isinstance(3.14, float)
isinstance(2 + 3j, complex)
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Numeric Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>int</code></td>
                <td>Whole numbers with arbitrary precision</td>
            </tr>
            <tr>
                <td><code>float</code></td>
                <td>64-bit floating-point (may have rounding errors)</td>
            </tr>
            <tr>
                <td><code>complex</code></td>
                <td>Numbers with real and imaginary parts</td>
            </tr>
            <tr>
                <td><code>Decimal</code></td>
                <td>High-precision decimal arithmetic</td>
            </tr>
            <tr>
                <td><code>Fraction</code></td>
                <td>Exact rational numbers</td>
            </tr>
            <tr>
                <td><code>math</code></td>
                <td>Math functions for real numbers</td>
            </tr>
            <tr>
                <td><code>cmath</code></td>
                <td>Math functions for complex numbers</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-text">Python Text (Strings)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Python, text is represented with the <code>str</code> type.</li>
        <br/>
        <li>Strings in Python are:</li>
        <ul>
            <li><b>immutable</b> (cannot be changed after creation)</li>
            <li><b>Unicode-based</b> (support all languages and emoji)</li>
            <li><b>sequence types</b> (you can index, slice, iterate)</li>
        </ul>
        <br/>
        <li>Python treats text as human-readable Unicode, not raw bytes.</li>
    </ul>
    <br/><br/>



    <li><b>Creating Strings</b></li>
<pre><code class="language-python line-numbers">s1 = "Hello"
s2 = 'World'
s3 = "‰∏≠Êñá‰πüÂèØ‰ª•"
s4 = "Emoji üòä supported"
</code></pre>

    <br/>
    <ul>
        <li>Triple-quoted strings allow multiline text:</li>
    </ul>

<pre><code class="language-python line-numbers">multiline = """
This is
a multiline
string.
"""
</code></pre>

    <br/><br/>



    <li><b>String Immutability</b></li>
    <br/>
    <ul>
        <li>Strings cannot be modified in place:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "hello"
# s[0] = "H"  # ‚ùå error
</code></pre>

    <ul>
        <li>To ‚Äúmodify,‚Äù you must create a new string:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "hello"
s = "H" + s[1:]
print(s)  # Hello
</code></pre>

    <br/><br/>



    <li><b>Indexing and Slicing</b></li>
<pre><code class="language-python line-numbers">s = "Python"

print(s[0])     # P
print(s[-1])    # n
print(s[1:4])   # yth
print(s[:3])    # Pyt
print(s[3:])    # hon
print(s[::-1])  # reversed
</code></pre>

    <br/><br/>



    <li><b>Useful String Methods</b></li>
    <br/>
    <ul>
        <li>Case operations:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "hello WORLD"
print(s.lower())
print(s.upper())
print(s.title())
print(s.capitalize())
</code></pre>

    <br/>
    <ul>
        <li>Searching:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "Python Programming"
print(s.find("Pro"))   # 7
print(s.count("m"))    # 2
</code></pre>

    <br/>
    <ul>
        <li>Stripping whitespace:</li>
    </ul>

<pre><code class="language-python line-numbers">"  hello  ".strip()    # "hello"
"  hi  ".lstrip()      # "hi  "
"  hi  ".rstrip()      # "  hi"
</code></pre>

    <br/>
    <ul>
        <li>Replacing and splitting:</li>
    </ul>

<pre><code class="language-python line-numbers">"a-b-c".split("-")          # ['a', 'b', 'c']
"Hello World".replace("World", "Python")
</code></pre>

    <br/>
    <ul>
        <li>Joining:</li>
    </ul>

<pre><code class="language-python line-numbers">"-".join(["a", "b", "c"])  # "a-b-c"
</code></pre>

    <br/><br/>



    <li><b>String Formatting</b></li>
    <br/>

    <ul>
        <li><b>f-strings</b> (recommended):</li>
    </ul>

<pre><code class="language-python line-numbers">name = "Hwangfu"
age = 23
print(f"My name is {name} and I am {age} years old.")
</code></pre>

    <br/>
    <ul>
        <li><code>str.format()</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">print("Hello, {}!".format("World"))
print("{name} is {age}".format(name="Ammy", age=30))
</code></pre>

    <br/>
    <ul>
        <li>Old C-style formatting:</li>
    </ul>

<pre><code class="language-python line-numbers">print("%s scored %d points" % ("Ammy", 95))
</code></pre>

    <br/><br/>



    <li><b>Escape Sequences</b></li>
    <br/>

<pre><code class="language-python line-numbers">print("Line1\nLine2")
print("Tab\tSeparated")
print("Quote: \"Hello\"")
</code></pre>

    <br/>
    <ul>
        <li><b>Raw strings</b> avoid escapes (useful for regex):</li>
    </ul>

<pre><code class="language-python line-numbers">r"C:\Users\Name"
r"\n is not a newline"
</code></pre>

    <br/><br/>



    <li><b>Unicode Support</b></li>
    <br/>
    <ul>
        <li>Python stores strings in Unicode:</li>
    </ul>

<pre><code class="language-python line-numbers">s = "‰Ω†Â•Ω üòä ŒìŒµŒπŒ¨ œÉŒøœÖ"
print(len(s)) # 13
</code></pre>

    <br/>
    <ul>
        <li>Inspecting code points:</li>
    </ul>

<pre><code class="language-python line-numbers">ord("‰Ω†")     # Unicode code point
chr(20320)    # Convert code point to char
</code></pre>

    <br/><br/>



    <li><b>Bytes vs Strings</b></li>
    <br/>
    <ul>
        <li><code>str</code> = Unicode text</li>
        <li><code>bytes</code> = raw 8-bit values</li>
    </ul>

<pre><code class="language-python line-numbers">b = b"hello"
print(b[0])         # 104
</code></pre>

    <br/>
    <ul>
        <li>You must encode/decode explicitly:</li>
    </ul>

<pre><code class="language-python line-numbers">text = "hello"
data = text.encode("utf-8")   # bytes
back = data.decode("utf-8")   # str
</code></pre>

    <br/><br/>



    <li><b>Substring Testing</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = "hello world"

print("world" in s)     # True
print(s.startswith("he"))
print(s.endswith("ld"))
</code></pre>

    <br/><br/>



    <li><b>Iterating Through a String</b></li>
    <br/>

<pre><code class="language-python line-numbers">for ch in "Python":
    print(ch)
</code></pre>

    <br/><br/>



    <li><b>String Concatenation</b></li>
    <br/>

<pre><code class="language-python line-numbers">s = "Py" + "thon"
print(s)
</code></pre>

    <br/>
    <ul>
        <li>For repeated concatenation, use <code>join</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">result = "".join(["a"] * 5)
print(result)   # "aaaaa"
</code></pre>

    <br/><br/>



    <li><b>Whitespace and Character Classification</b></li>
    <br/>
<pre><code class="language-python line-numbers">s = "abc123"

print(s.isalpha())    # False
print(s.isdigit())    # False
print(s.isalnum())    # True
print(" ".isspace())  # True
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>str</code></td>
                <td>Unicode text, immutable</td>
            </tr>
            <tr>
                <td>Indexing / slicing</td>
                <td>Extract individual characters or substrings</td>
            </tr>
            <tr>
                <td>String methods</td>
                <td>Case changes, searching, replacing, splitting, joining</td>
            </tr>
            <tr>
                <td>Formatting</td>
                <td>Use f-strings, <code>format()</code>, or <code>%</code></td>
            </tr>
            <tr>
                <td>Unicode support</td>
                <td>Strings store Unicode code points</td>
            </tr>
            <tr>
                <td>Bytes vs str</td>
                <td>Use <code>.encode()</code> and <code>.decode()</code> to convert</td>
            </tr>
            <tr>
                <td>Escape sequences</td>
                <td><code>\n</code>, <code>\t</code>, <code>\"</code>, and raw strings</td>
            </tr>
            <tr>
                <td>Immutability</td>
                <td>Strings cannot be modified in place</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-lists">Python Lists</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>list</code> in Python is a dynamic, ordered, and mutable collection of items.</li>
        <br/>
        <li>Lists can store <b>any type of object</b>, even mixed types.</li>
        <br/>
    </ul>
    <br/><br/>



    <li><b>Creating Lists</b></li>
    <br/>
<pre><code class="language-python line-numbers">nums   = [1, 2, 3]
mixed  = [1, "two", 3.0, True]
nested = [[1, 2], [3, 4]]
empty  = []
</code></pre>
    <ul>
        <li>Using <code>list()</code> constructor:</li>
    </ul>

<pre><code class="language-python line-numbers">chars = list("hello")  # ['h', 'e', 'l', 'l', 'o']
</code></pre>

    <br/><br/>



    <li><b>List Indexing and Slicing</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [10, 20, 30, 40, 50]

print(a[0])       # 10
print(a[-1])      # 50
print(a[1:4])     # [20, 30, 40]
print(a[:3])      # [10, 20, 30]
print(a[3:])      # [40, 50]
print(a[::-1])    # reversed list
</code></pre>

    <br/><br/>


    <li><b>List Mutability</b></li>
    <br/>
    <ul>
        <li>Lists are <b>mutable</b>, elements can be changed in place.</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3]
a[0] = 100
print(a)          # [100, 2, 3]
</code></pre>

    <br/>
    <ul>
        <li>You can modify slices too:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3, 4]
a[1:3] = [20, 30, 40]
print(a)          # [1, 20, 30, 40, 4]
</code></pre>

    <br/><br/>



    <li><b>Adding Elements</b></li>
    <br/>

    <ul>
        <li><code>append()</code> ‚Äî add item to end:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3]
a.append(4)
print(a)    # [1, 2, 3, 4]
</code></pre>

    <br/>
    <ul>
        <li><code>insert()</code> ‚Äî add at position:</li>
    </ul>

<pre><code class="language-python line-numbers">a.insert(1, "X")
print(a)   # [1, 'X', 2, 3, 4]
</code></pre>

    <br/>
    <ul>
        <li><code>extend()</code> ‚Äî add multiple items at end:</li>
    </ul>

<pre><code class="language-python line-numbers">a.extend([5, 6])
print(a)    # [1, 'X', 2, 3, 4, 5, 6]
</code></pre>

    <br/><br/>



    <li><b>Removing Elements</b></li>
    <br/>

    <ul>
        <li><code>remove()</code> ‚Äî remove first matching value:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3, 2]
a.remove(2)
print(a)   # [1, 3, 2]
</code></pre>

    <br/>
    <ul>
        <li><code>pop()</code> ‚Äî remove by index (returns the element):</li>
    </ul>

<pre><code class="language-python line-numbers">x = a.pop(1)
print(x)    # removed value
print(a)    # [1, 2]
</code></pre>

    <br/>
    <ul>
        <li><code>clear()</code> ‚Äî empty the list:</li>
    </ul>

<pre><code class="language-python line-numbers">a.clear()
print(a)   # []
</code></pre>

    <br/><br/>



    <li><b>Searching and Counting</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [10, 20, 30, 20]

print(a.index(20))   # 1
print(a.count(20))   # 2
</code></pre>

    <br/><br/>



    <li><b>Sorting and Reversing</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [3, 1, 4, 1, 5]

a.sort()
print(a)    # [1, 1, 3, 4, 5]

a.sort(reverse=True)
print(a)    # [5, 4, 3, 1, 1]
</code></pre>

    <br/>
    <ul>
        <li><code>sorted()</code> returns a new list:</li>
    </ul>

<pre><code class="language-python line-numbers">b = sorted(a)
</code></pre>

    <br/>
    <ul>
        <li>Reverse order inside a list:</li>
    </ul>

<pre><code class="language-python line-numbers">a.reverse()
</code></pre>

    <br/><br/>



    <li><b>Iterating Over a List</b></li>
    <br/>

<pre><code class="language-python line-numbers">for x in [10, 20, 30]:
    print(x)
</code></pre>

    <br/>
    <ul>
        <li>Getting index and value:</li>
    </ul>

<pre><code class="language-python line-numbers">for i, val in enumerate(["a", "b", "c"]):
    print(i, val)
</code></pre>

    <br/><br/>



    <li><b>Membership Testing</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [1, 2, 3]

print(2 in a)      # True
print(10 not in a) # True
</code></pre>

    <br/><br/>



    <li><b>List Comprehensions</b></li>
    <br/>
    <ul>
        <li>Compact syntax for generating lists:</li>
    </ul>

<pre><code class="language-python line-numbers">squares = [x * x for x in range(5)]
evens = [x for x in range(20) if x % 2 == 0]

print(squares)
print(evens)
</code></pre>

    <br/>
    <ul>
        <li>Nested list comprehension:</li>
    </ul>

<pre><code class="language-python line-numbers">matrix = [[i * j for j in range(3)] for i in range(3)]
print(matrix)
</code></pre>

    <br/><br/>



    <li><b>Copying Lists</b></li>
    <br/>
    <ul>
        <li><b>Shallow copy</b>: elements are shared:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [1, 2, 3]
b = a[:]        # shallow copy
c = list(a)     # shallow copy
</code></pre>

    <br/>
    <ul>
        <li><b>Deep copy</b>: nested lists duplicated:</li>
    </ul>

<pre><code class="language-python line-numbers">import copy

nested = [[1], [2]]
d = copy.deepcopy(nested)
</code></pre>

    <br/><br/>



    <li><b>Common List Pitfall: Shared References</b></li>
    <br/>

<pre><code class="language-python line-numbers">a = [[0] * 3] * 3
print(a)
a[0][0] = 99
print(a)  # all rows changed!
</code></pre>

    <br/>
    <ul>
        <li>Correct way:</li>
    </ul>

<pre><code class="language-python line-numbers">a = [[0 for _ in range(3)] for _ in range(3)]
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ordered</td>
                <td>List elements maintain insertion order</td>
            </tr>
            <tr>
                <td>Mutable</td>
                <td>Elements and slices can be changed in place</td>
            </tr>
            <tr>
                <td>Heterogeneous</td>
                <td>Can contain mixed types</td>
            </tr>
            <tr>
                <td>Dynamic</td>
                <td>Lists grow and shrink automatically</td>
            </tr>
            <tr>
                <td>List methods</td>
                <td>append, insert, extend, remove, pop, clear, sort, reverse</td>
            </tr>
            <tr>
                <td>Comprehensions</td>
                <td>Powerful syntax for generating lists</td>
            </tr>
            <tr>
                <td>Copying</td>
                <td>Use slice or <code>copy()</code> for shallow; <code>deepcopy()</code> for deep</td>
            </tr>
            <tr>
                <td>Common pitfall</td>
                <td><code>[[0] * n] * m</code> duplicates references</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-type-annotations">Python Type Annotations</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Type annotations were introduced in Python 3.5 and expanded significantly in later versions (3.7+, 3.9+, 3.10+, 3.12+).</li>
        <br/>
        <li>They allow you to <b>declare the expected type</b> of variables, function parameters, return values, classes, and more.</li>
        <br/>
        <li>Annotations are checked by external tools (e.g., <code>mypy</code>, <code>pyright</code>, <code>ruff</code>), not by Python itself.</li>
        <br/>
        <li>At runtime, annotations do nothing unless explicitly used.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Function Annotations</b></li>
    <br/>

<pre><code class="language-python line-numbers">def add(x: int, y: int) -&gt; int:
    return x + y
</code></pre>

    <ul>
        <li><code>x: int</code> ‚Äî parameter annotation</li>
        <li><code>-&gt; int</code> ‚Äî return annotation</li>
    </ul>

    <br/>
    <ul>
        <li>Multiple arguments:</li>
    </ul>

<pre><code class="language-python line-numbers">def greet(name: str, age: int) -&gt; str:
    return f"{name} is {age} years old"
</code></pre>

    <br/><br/>



    <li><b>Annotating Variables</b></li>
    <br/>

<pre><code class="language-python line-numbers">age: int = 25
name: str = "Hwangfu"
height: float = 1.80
</code></pre>

    <br/>
    <ul>
        <li>Without assigning a value (type-only variable):</li>
    </ul>

<pre><code class="language-python line-numbers">count: int
</code></pre>

    <br/><br/>



    <li><b>Common Built-in Types</b></li>
    <br/>
    <ul>
        <li>Use these directly in Python 3.9+</li>
    </ul>

<pre><code class="language-python line-numbers">n: int = 10
flag: bool = True
ratio: float = 0.75
text: str = "Hello"
</code></pre>

    <br/><br/>



    <li><b>Containers and Generics</b></li>
    <br/>
    <ul>
        <li>Use built-in generic types (Python 3.9+):</li>
    </ul>

<pre><code class="language-python line-numbers">nums: list[int] = [1, 2, 3]
names: set[str] = {"a", "b"}
mapping: dict[str, int] = {"a": 1}
matrix: list[list[int]] = [[1, 2], [3, 4]]
</code></pre>

    <br/>
    <ul>
        <li>For compatibility with older versions, use <code>typing.List</code>, <code>typing.Dict</code>, etc.</li>
    </ul>
    <br/><br/>



    <li><b>Optional Types</b></li>
    <br/>
    <ul>
        <li>A value that may be <code>None</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Optional

age: Optional[int] = None
</code></pre>

    <br/>
    <ul>
        <li>Python 3.10+ (PEP 604):</li>
    </ul>

<pre><code class="language-python line-numbers">age: int | None = None
</code></pre>

    <br/><br/>



    <li><b>Union Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Union

value: Union[int, str] = 10
</code></pre>

    <br/>
    <ul>
        <li>Python 3.10+:</li>
    </ul>

<pre><code class="language-python line-numbers">value: int | str = 10
</code></pre>

    <br/><br/>



    <li><b>Any Type</b></li>
    <br/>
    <ul>
        <li><code>Any</code> disables type checking.</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Any

data: Any = "hello"
data = 123         # allowed
</code></pre>

    <br/><br/>



    <li><b>Literal Types</b></li>
    <br/>
    <ul>
        <li>Restrict allowed values:</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Literal

mode: Literal["debug", "prod", "test"] = "debug"
</code></pre>

    <br/><br/>



    <li><b>Callable / Function Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Callable

def apply(f: Callable[[int, int], int], x: int, y: int) -&gt; int:
    return f(x, y)
</code></pre>

    <br/><br/>



    <li><b>Tuple Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">coords: tuple[int, int] = (10, 20)
point: tuple[int, str, float] = (1, "a", 1.5)
</code></pre>

    <br/>
    <ul>
        <li>Variable-length tuples:</li>
    </ul>

<pre><code class="language-python line-numbers">nums: tuple[int, ...] = (1, 2, 3)
</code></pre>

    <br/><br/>



    <li><b>Self Type (Methods returning instance)</b></li>
    <br/>
    <ul>
        <li>Python 3.11 introduced <code>typing.Self</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import Self

class Vector:
    def scale(self, x: float) -&gt; Self:
        self.x *= x
        self.y *= x
        return self
</code></pre>

    <br/><br/>



    <li><b>TypedDict (for dicts with fixed structure)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypedDict

class User(TypedDict):
    id: int
    name: str
    email: str

u: User = {"id": 1, "name": "Ammy", "email": "a@example.com"}
</code></pre>

    <br/><br/>



    <li><b>Protocol (Duck Typing Interfaces)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Protocol

class Drawable(Protocol):
    def draw(self) -&gt; None:
        ...

def render(obj: Drawable) -&gt; None:
    obj.draw()
</code></pre>

    <br/>
    <ul>
        <li>No inheritance required: if a class has <code>draw()</code>, it matches the protocol.</li>
    </ul>
    <br/><br/>



    <li><b>Final</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Final

PI: Final = 3.14159
</code></pre>

    <ul>
        <li>Type checkers warn if you try to reassign.</li>
    </ul>

    <br/><br/>



    <li><b>Class and Instance Attributes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Person:
    name: str          # instance attribute annotation
    count: int = 0     # class variable annotation
</code></pre>

    <br/><br/>



    <li><b>Forward References</b></li>
    <br/>
    <ul>
        <li>When a type is not yet defined, quote it:</li>
    </ul>

<pre><code class="language-python line-numbers">class Node:
    next: "Node" | None
</code></pre>

    <br/><br/>



    <li><b>Union Return Patterns with <code>match</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">def parse(data: str) -&gt; int | float | None:
    match data:
        case "none":
            return None
        case _ if data.isdigit():
            return int(data)
        case _:
            return float(data)
</code></pre>

    <br/><br/>



    <li><b>ParamSpec and TypeVar (Advanced Generics)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypeVar, ParamSpec, Callable

P = ParamSpec("P")
R = TypeVar("R")

def wrapper(f: Callable[P, R]) -&gt; Callable[P, R]:
    def inner(*args: P.args, **kwargs: P.kwargs) -&gt; R:
        return f(*args, **kwargs)
    return inner
</code></pre>

    <br/><br/>



    <li><b>Annotated (Metadata for Types)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Annotated

x: Annotated[int, "must be positive"] = 5
</code></pre>

    <br/><br/>



    <li><b>Type Aliases</b></li>
    <br/>

<pre><code class="language-python line-numbers">UserId = int
Vector = list[float]

def scale(v: Vector) -&gt; Vector:
    return [x * 10 for x in v]
</code></pre>

    <br/><br/>



    <li><b>Runtime Access to Annotations</b></li>
    <br/>
    <ul>
        <li>Annotations are stored in <code>__annotations__</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def f(x: int, y: str) -&gt; bool:
    return True

print(f.__annotations__)
</code></pre>

    <br/><br/>



    <li><b>Summary of Major Annotation Features</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic types</td>
                <td><code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code></td>
            </tr>
            <tr>
                <td>Generics</td>
                <td><code>list[int]</code>, <code>dict[str, int]</code></td>
            </tr>
            <tr>
                <td>Optional</td>
                <td><code>int | None</code></td>
            </tr>
            <tr>
                <td>Union</td>
                <td><code>int | str</code></td>
            </tr>
            <tr>
                <td>Any</td>
                <td>Disable type checking</td>
            </tr>
            <tr>
                <td>Literal</td>
                <td>Restrict to specific values</td>
            </tr>
            <tr>
                <td>Callable</td>
                <td>Describe function signatures</td>
            </tr>
            <tr>
                <td>TypedDict</td>
                <td>Dicts with fixed field types</td>
            </tr>
            <tr>
                <td>Protocol</td>
                <td>Duck-typing interfaces</td>
            </tr>
            <tr>
                <td>Final</td>
                <td>Constant-like values</td>
            </tr>
            <tr>
                <td>Self</td>
                <td>Methods returning class instance</td>
            </tr>
            <tr>
                <td>ParamSpec / TypeVar</td>
                <td>Advanced generic functions</td>
            </tr>
            <tr>
                <td>Annotated</td>
                <td>Add metadata to types</td>
            </tr>
            <tr>
                <td>Type Aliases</td>
                <td>Give names to complex types</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-protocol">Python Protocols</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>Protocol</code> in Python (introduced in <b>PEP 544</b>) is a way to define <b>structural typing</b> (also called <b>duck typing</b>) for static type checkers such as <code>mypy</code>, <code>pyright</code>, and <code>ruff</code>.</li>
        <br/>
        <li>Structural typing means:
            <b>"If an object has the required methods/attributes, it is accepted ‚Äî regardless of its class."</b>
        </li>
        <br/>
        <li>This is different from nominal typing where the type depends on inheritance.</li>
        <br/>
        <li>Protocols allow you to define interfaces <b>without forcing inheritance</b>.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Protocol Example</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Protocol

class Greeter(Protocol):
    def greet(self) -&gt; str:
        ...
</code></pre>

    <ul>
        <li>Any class with a <code>greet()</code> method returning a <code>str</code> matches this protocol:</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    def greet(self) -&gt; str:
        return "Hello!"

class Robot:
    def greet(self) -&gt; str:
        return "Beep bop"
</code></pre>

    <br/>
    <ul>
        <li>Both classes satisfy <code>Greeter</code>.</li>
    </ul>

<pre><code class="language-python line-numbers">def welcome(g: Greeter) -&gt; None:
    print(g.greet())

welcome(Person())   # OK
welcome(Robot())    # OK
</code></pre>

    <br/><br/>



    <li><b>No Need to Inherit</b></li>
    <br/>
    <ul>
        <li>The following also works, because Protocols check structure, not inheritance:</li>
    </ul>

<pre><code class="language-python line-numbers">class Cat:
    def greet(self) -&gt; str:
        return "Meow"
</code></pre>

<pre><code class="language-python line-numbers">welcome(Cat())   # Also OK
</code></pre>

    <br/>
    <ul>
        <li><code>Cat</code> does NOT inherit from <code>Greeter</code>, but matches the required structure.</li>
    </ul>

    <br/><br/>



    <li><b>Protocols with Attributes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User(Protocol):
    name: str
    age: int

def print_user(u: User) -&gt; None:
    print(u.name, u.age)
</code></pre>

    <ul>
        <li>Any object with <code>name</code> and <code>age</code> attributes matches:</li>
    </ul>

<pre><code class="language-python line-numbers">class Person:
    def __init__(self, name: str, age: int) -&gt; None:
        self.name = name
        self.age = age

print_user(Person("Hwangfu", 23))
</code></pre>

    <br/><br/>



    <li><b>Protocols with Multiple Methods</b></li>
    <br/>

<pre><code class="language-python line-numbers">class FileLike(Protocol):
    def read(self) -&gt; str:
        ...
    def write(self, s: str) -&gt; int:
        ...
</code></pre>

    <ul>
        <li>Any class with <code>read()</code> and <code>write()</code> methods is considered file-like.</li>
    </ul>

    <br/><br/>



    <li><b>Extending Protocols</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Shape(Protocol):
    def area(self) -&gt; float:
        ...

class DrawableShape(Shape, Protocol):
    def draw(self) -&gt; None:
        ...
</code></pre>

    <br/><br/>



    <li><b>Optional Protocol Features</b></li>
    <br/>

    <ul>
        <li><b>@runtime_checkable</b> allows <code>isinstance()</code> checks at runtime:</li>
    </ul>

<pre><code class="language-python line-numbers">from typing import runtime_checkable

@runtime_checkable
class Greeter(Protocol):
    def greet(self) -&gt; str:
        ...
</code></pre>

    <br/>
    <ul>
        <li>Now you can do:</li>
    </ul>

<pre><code class="language-python line-numbers">print(isinstance(Person(), Greeter))   # True
print(isinstance(42, Greeter))         # False
</code></pre>

    <br/><br/>



    <li><b>Protocols vs Abstract Base Classes (ABC)</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Protocol</th>
                <th>ABC (Abstract Base Class)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Typing style</td>
                <td>Structural (duck typing)</td>
                <td>Nominal (inherits from ABC)</td>
            </tr>
            <tr>
                <td>Requires inheritance?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Runtime enforcement</td>
                <td>No (unless using <code>@runtime_checkable</code>)</td>
                <td>Yes (raises error if abstract methods not implemented)</td>
            </tr>
            <tr>
                <td>Common usage</td>
                <td>Flexible APIs, plugin systems, duck typing</td>
                <td>Strict class hierarchies</td>
            </tr>
            <tr>
                <td>Better for static type checking?</td>
                <td>Yes</td>
                <td>Partly</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Protocol with Generics</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Protocol, TypeVar

T = TypeVar("T")

class Container(Protocol[T]):
    def add(self, item: T) -&gt; None:
        ...
</code></pre>

    <br/><br/>



    <li><b>Using Protocols to Define Function Signatures</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Comparator(Protocol):
    def __call__(self, a: int, b: int) -&gt; bool:
        ...

def sort_with(nums: list[int], comp: Comparator) -&gt; None:
    nums.sort(key=lambda x: x, reverse=comp(1, 0))
</code></pre>

    <br/><br/>



    <li><b>Protocols with Properties</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Sized(Protocol):
    @property
    def size(self) -&gt; int:
        ...
</code></pre>

<pre><code class="language-python line-numbers">class Box:
    def __init__(self, size: int) -&gt; None:
        self._size = size

    @property
    def size(self) -&gt; int:
        return self._size
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Protocol</td>
                <td>Defines a structural-typing interface</td>
            </tr>
            <tr>
                <td>No inheritance required</td>
                <td>Matches by methods/attributes present</td>
            </tr>
            <tr>
                <td>@runtime_checkable</td>
                <td>Allows <code>isinstance()</code> with Protocol</td>
            </tr>
            <tr>
                <td>Attributes & Methods</td>
                <td>Protocols can specify both</td>
            </tr>
            <tr>
                <td>Generics support</td>
                <td>Protocols can accept type parameters</td>
            </tr>
            <tr>
                <td>Use cases</td>
                <td>Flexible interfaces, APIs, plugin architectures</td>
            </tr>
            <tr>
                <td>Difference from ABC</td>
                <td>Structural vs. nominal typing</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-typeddict">Python <code>TypedDict</code></h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>TypedDict</code> (introduced in PEP 589) allows you to define <b>dictionaries with a fixed structure</b> ‚Äî specific keys and specific value types.</li>
        <br/>
        <li>It is extremely useful when you want dict-like objects but with the type safety of data classes.</li>
        <br/>
        <li>Unlike <code>dataclasses</code>, <code>TypedDict</code> remains a regular <b>dict at runtime</b> and does not enforce types ‚Äî checkers like <code>mypy</code>, <code>pyright</code>, and <code>ruff</code> enforce it statically.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Usage</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypedDict

class User(TypedDict):
    id: int
    name: str
    email: str
</code></pre>

    <br/>
    <ul>
        <li>Create instances like normal dicts:</li>
    </ul>

<pre><code class="language-python line-numbers">u: User = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com"
}
</code></pre>

    <br/><br/>



    <li><b>TypedDict Enforces Key Presence</b></li>
    <br/>
    <ul>
        <li>Missing required keys ‚Üí static type error:</li>
    </ul>

<pre><code class="language-python line-numbers">bad_user: User = {
    "id": 1,
    "name": "Alice"
}   # ‚ùå error: missing key "email"
</code></pre>

    <br/>
    <ul>
        <li>Extra keys ‚Üí static type error:</li>
    </ul>

<pre><code class="language-python line-numbers">wrong: User = {
    "id": 1,
    "name": "Alice",
    "email": "a@x.com",
    "age": 23
}   # ‚ùå error: extra key "age"
</code></pre>

    <br/><br/>



    <li><b>Optional Keys</b></li>
    <br/>
    <ul>
        <li>Option 1: Annotate key as optional value:</li>
    </ul>

<pre><code class="language-python line-numbers">class User(TypedDict):
    id: int
    name: str
    email: str | None   # value may be None
</code></pre>

    <br/>
    <ul>
        <li>Option 2: Mark the entire key as optional using <code>total=False</code>:</li>
    </ul>

<pre><code class="language-python line-numbers">class PartialUser(TypedDict, total=False):
    id: int
    name: str
    email: str
</code></pre>

    <br/>
    <ul>
        <li>Now all keys are optional.</li>
    </ul>

<pre><code class="language-python line-numbers">p: PartialUser = {}
</code></pre>

    <br/><br/>



    <li><b>Mixing Required and Optional Keys</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User(TypedDict):
    id: int
    name: str

class UserExtra(TypedDict, total=False):
    email: str
    age: int
</code></pre>

    <ul>
        <li>You can also combine required and optional keys inside one definition (Python 3.11+ style):</li>
    </ul>

<pre><code class="language-python line-numbers">class User(TypedDict):
    id: int
    name: str
    email: str | None   # optional value, key still required
</code></pre>

    <br/><br/>



    <li><b>Readonly Keys (Python 3.12+)</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import TypedDict, NotRequired, ReadOnly

class Config(TypedDict):
    version: ReadOnly[int]
    debug: NotRequired[bool]
</code></pre>
    <br/>
    <ul>
        <li><code>version</code> is readonly for static checking.</li>
    </ul>
    <br/><br/><br/>



    <li><b>TypedDict with Inheritance</b></li>
    <br/>

<pre><code class="language-python line-numbers">class BaseUser(TypedDict):
    id: int
    name: str

class FullUser(BaseUser):
    email: str
    age: int
</code></pre>
    <br/>
    <ul>
        <li><code>FullUser</code> now includes all keys of <code>BaseUser</code>.</li>
    </ul>
    <br/><br/><br/>



    <li><b>TypedDict vs Dataclass</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>TypedDict</th>
                <th>Dataclass</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Runtime type</td>
                <td>Just a dict</td>
                <td>Custom class</td>
            </tr>
            <tr>
                <td>Allows missing keys?</td>
                <td>No (unless <code>total=False</code>)</td>
                <td>Yes (default values)</td>
            </tr>
            <tr>
                <td>Fast creation?</td>
                <td>Yes (dict)</td>
                <td>Slower (object)</td>
            </tr>
            <tr>
                <td>Attribute access</td>
                <td>Key-based (<code>d["key"]</code>)</td>
                <td>Dot-access (<code>d.key</code>)</td>
            </tr>
            <tr>
                <td>Static type checking</td>
                <td>Strong</td>
                <td>Strong</td>
            </tr>
            <tr>
                <td>Serialization (JSON)</td>
                <td>Easy</td>
                <td>Requires conversion</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>TypedDict with Functions</b></li>
    <br/>

<pre><code class="language-python line-numbers">def process_user(user: User) -&gt; None:
    print(user["id"], user["name"])
</code></pre>

    <br/><br/>



    <li><b>TypedDict for API Responses</b></li>
    <br/>

<pre><code class="language-python line-numbers">class ApiResponse(TypedDict):
    status: int
    data: dict[str, str]
</code></pre>

<pre><code class="language-python line-numbers">response: ApiResponse = {
    "status": 200,
    "data": {"id": "123"}
}
</code></pre>

    <br/><br/>



    <li><b>Nesting TypedDicts</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Profile(TypedDict):
    bio: str
    github: str

class User(TypedDict):
    id: int
    profile: Profile
</code></pre>

    <br/><br/>



    <li><b>TypedDict with Literal Types</b></li>
    <br/>

<pre><code class="language-python line-numbers">from typing import Literal

class Event(TypedDict):
    type: Literal["click", "keypress"]
    payload: dict[str, str]
</code></pre>

    <br/><br/>



    <li><b>Total=False Default Behavior</b></li>
    <br/>
    <ul>
        <li>You can flip the default ‚Äî make keys optional unless stated otherwise:</li>
    </ul>

<pre><code class="language-python line-numbers">class Partial(TypedDict, total=False):
    required: int
    # everything here is optional
</code></pre>

    <br/><br/>



    <li><b>Using TypedDict with <code>**kwargs</code></b></li>
    <br/>
<pre><code class="language-python line-numbers">def create_user(**kwargs: User) -&gt; User:
    return kwargs
</code></pre>

    <br/><br/>



    <li><b>Runtime Representation</b></li>
    <br/>
    <ul>
        <li><code>TypedDict</code> is still a normal dictionary:</li>
    </ul>

<pre><code class="language-python line-numbers">u: User = {"id": 1, "name": "Alice", "email": "a@x.com"}

print(type(u))    # &lt;class 'dict'&gt;
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>TypedDict</code></td>
                <td>Dictionary with predefined keys and value types</td>
            </tr>
            <tr>
                <td>Required keys</td>
                <td>All keys required unless <code>total=False</code></td>
            </tr>
            <tr>
                <td>Optional keys</td>
                <td>Via <code>total=False</code> or optional values</td>
            </tr>
            <tr>
                <td>Runtime representation</td>
                <td>Still a plain dict, only static checks apply</td>
            </tr>
            <tr>
                <td>Supports inheritance</td>
                <td>Extend dictionary definitions</td>
            </tr>
            <tr>
                <td>Common use cases</td>
                <td>API schemas, config objects, JSON-like data</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-type-checkers">Python Type Checkers: mypy, pyright, and ruff</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python is dynamically typed, but modern tools allow <b>static type checking</b> based on type hints.</li>
        <br/>
        <li>The three major tools are:</li>
        <ul>
            <li><code>mypy</code>: classic, strict, feature-rich</li>
            <li><code>pyright</code>: fast, modern, excellent IDE integration</li>
            <li><code>ruff</code>: fast linter with partial type checks</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>What Static Type Checking Does</b></li>
    <br/>
    <ul>
        <li>Type checkers analyze your code <b>without running it</b>.</li>
        <br/>
        <li>They detect errors such as:</li>
        <ul>
            <li>wrong argument types</li>
            <li>incorrect return types</li>
            <li>invalid attribute access</li>
            <li>mistyped <code>TypedDict</code> keys</li>
            <li>mismatched <code>Protocol</code> implementations</li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">def add(a: int, b: int) -&gt; int:
    return a + b

add("hi", 3)  # ‚ùå static type error
</code></pre>

    <br/><br/>



    <li><b>mypy</b></li>
    <br/>
    <ul>
        <li><code>mypy</code> is the most widely adopted and feature-complete type checker.</li>
        <br/>
        <li>Strong support for:</li>
        <ul>
            <li><code>TypedDict</code></li>
            <li><code>Protocol</code></li>
            <li>Generics</li>
            <li><code>Literal</code> types</li>
            <li><code>@overload</code></li>
            <li>Strict mode settings</li>
        </ul>
        <br/>
        <li>Installation:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install mypy
</code></pre>

    <br/>
    <ul>
        <li>Running mypy:</li>
    </ul>

<pre><code class="language-bash line-numbers">mypy app.py
</code></pre>

    <br/>
    <ul>
        <li>Example configuration (<code>mypy.ini</code>):</li>
    </ul>

<pre><code class="language-ini line-numbers">[mypy]
strict = True
disallow_untyped_defs = True
warn_unused_ignores = True
</code></pre>

    <br/><br/>



    <li><b>pyright</b></li>
    <br/>
    <ul>
        <li><code>pyright</code> is a fast type checker created by Microsoft.</li>
        <br/>
        <li>Main advantages:</li>
        <ul>
            <li>extremely fast</li>
            <li>excellent VSCode integration</li>
            <li>advanced type inference and narrow typing</li>
            <li>good for large projects</li>
        </ul>
        <br/>
        <li>Installation:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm install -g pyright
</code></pre>

    <br/>
    <ul><li>Run pyright:</li></ul>

<pre><code class="language-bash line-numbers">pyright
</code></pre>

    <br/>
    <ul><li>Configuration (<code>pyrightconfig.json</code>):</li></ul>

<pre><code class="language-json line-numbers">{
  "include": ["src"],
  "strict": true
}
</code></pre>

    <br/><br/>



    <li><b>ruff</b></li>
    <br/>
    <ul>
        <li><code>ruff</code> is an ultra-fast linter written in Rust.</li>
        <br/>
        <li>It is not a full type checker, but supports:</li>
        <ul>
            <li>lightweight type-checking rules</li>
            <li>unused code analysis</li>
            <li>import sorting</li>
            <li>formatting</li>
        </ul>
        <br/>
        <li>Installation:</li>
    </ul>

<pre><code class="language-bash line-numbers">pip install ruff
</code></pre>

    <br/>
    <ul><li>Run:</li></ul>

<pre><code class="language-bash line-numbers">ruff check .
</code></pre>

    <br/>
    <ul><li>Enable type-checking rules:</li></ul>

<pre><code class="language-toml line-numbers">[tool.ruff]
select = ["E", "F", "I", "TCH"]
</code></pre>

    <br/><br/>



    <li><b>Comparison Table</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>mypy</th>
                <th>pyright</th>
                <th>ruff</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Checking depth</td>
                <td>Very deep</td>
                <td>Very deep</td>
                <td>Shallow</td>
            </tr>
            <tr>
                <td>Speed</td>
                <td>Medium</td>
                <td>Very fast</td>
                <td>Extremely fast</td>
            </tr>
            <tr>
                <td>Best use case</td>
                <td>Strict typing, CI validation</td>
                <td>Daily development, IDE</td>
                <td>Linting + basic type checks</td>
            </tr>
            <tr>
                <td>Protocol support</td>
                <td>Excellent</td>
                <td>Excellent</td>
                <td>Minimal</td>
            </tr>
            <tr>
                <td>TypedDict analysis</td>
                <td>Strong</td>
                <td>Strong</td>
                <td>Partial</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>mypy</code></td>
                <td>Classic strict type checker with full feature support</td>
            </tr>
            <tr>
                <td><code>pyright</code></td>
                <td>Fast, modern, editor-focused type checker</td>
            </tr>
            <tr>
                <td><code>ruff</code></td>
                <td>Ultra-fast linter with optional lightweight type warnings</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-special-function-parameters">Special Parameters in Python Functions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Python function definitions support several <b>special parameter forms</b> that control how arguments can be passed.</li>
        <br/>
        <li>These special markers allow you to restrict, organize, or structure function parameters:</li>
        <ul>
            <li><code>/</code> ‚Äî positional-only parameters</li>
            <li><code>*</code> ‚Äî keyword-only parameters</li>
            <li><code>*args</code> ‚Äî variable positional arguments</li>
            <li><code>**kwargs</code> ‚Äî variable keyword arguments</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Positional-Only Parameters (<code>/</code>)</b></li>
    <br/>
    <ul>
        <li>A parameter placed before <code>/</code> can <b>ONLY</b> be passed positionally (Python 3.8+).</li>
        <br/>
        <li>Motivation:</li>
        <ul>
            <li>prevent callers from depending on parameter names</li>
            <li>make APIs easier to change later</li>
            <li>match CPython built-ins like <code>len(obj)</code></li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b, /):
    return a + b

add(3, 4)        # OK
add(a=3, b=4)    # ‚ùå error: cannot use keyword args
</code></pre>

    <br/>
    <ul><li>Everything before <code>/</code> must be passed positionally.</li></ul>

    <br/><br/>



    <li><b>Keyword-Only Parameters (<code>*</code>)</b></li>
    <br/>
    <ul>
        <li>Parameters placed after <code>*</code> must be passed by keyword.</li>
    </ul>

<pre><code class="language-python line-numbers">def configure(*, debug=False, verbose=False):
    print(debug, verbose)

configure(debug=True)     # OK
configure(True, True)     # ‚ùå error
</code></pre>

    <br/>
    <ul><li>Everything after <code>*</code> must be named explicitly.</li></ul>

    <br/><br/>



    <li><b>Combining Positional-Only and Keyword-Only</b></li>
    <br/>

<pre><code class="language-python line-numbers">def func(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>

    <ul>
        <li><b>Rules:</b></li>
        <ul>
            <li><code>a</code>, <code>b</code> ‚Üí positional-only</li>
            <li><code>c</code>, <code>d</code> ‚Üí can be positional or keyword</li>
            <li><code>e</code>, <code>f</code> ‚Üí keyword-only</li>
        </ul>
    </ul>

    <br/><br/>



    <li><b>Variable Positional Arguments (<code>*args</code>)</b></li>
    <br/>
    <ul>
        <li><code>*args</code> captures an arbitrary number of positional arguments into a tuple.</li>
        <br/>
        <li>Use when your function accepts a flexible amount of inputs.</li>
    </ul>

<pre><code class="language-python line-numbers">def total(*numbers):
    print(numbers)

total(1, 2, 3)      # (1, 2, 3)
total()             # ()
</code></pre>

    <br/><br/>



    <li><b>Variable Keyword Arguments (<code>**kwargs</code>)</b></li>
    <br/>
    <ul>
        <li><code>**kwargs</code> collects keyword arguments into a dictionary.</li>
        <br/>
        <li>This is useful for flexible configuration or passing options through layers of functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def debug(**options):
    print(options)

debug(level=3, verbose=True)
# {'level': 3, 'verbose': True}
</code></pre>

    <br/><br/>



    <li><b>Using <code>*args</code> and <code>**kwargs</code> Together</b></li>
    <br/>

<pre><code class="language-python line-numbers">def func(a, *args, **kwargs):
    print(a, args, kwargs)

func(1, 2, 3, x=10, y=20)
</code></pre>

    <br/>
    <ul>
        <li>Produces:</li>
    </ul>

<pre><code class="language-python">1 (2, 3) {'x': 10, 'y': 20}
</code></pre>

    <br/><br/>



    <li><b>Enforcing Only <code>**kwargs</code> Arguments</b></li>
    <br/>
    <ul>
        <li>A common pattern in APIs is to force callers to use keywords:</li>
    </ul>

<pre><code class="language-python line-numbers">def build_model(*, layers, activation):
    ...
</code></pre>

    <br/>
    <ul>
        <li>Prevents:</li>
    </ul>

<pre><code class="language-python">build_model(3, "relu")   # ‚ùå
</code></pre>

    <br/><br/>



    <li><b>Using <code>/</code> with <code>*args</code> and <code>**kwargs</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">def f(a, b, /, c, *args, d, e=0, **kwargs):
    print(a, b, c, args, d, e, kwargs)
</code></pre>

    <br/>
    <ul>
        <li>This allows extremely precise function signatures.</li>
    </ul>

    <br/><br/>



    <li><b>Real Example: Built-in <code>pow</code></b></li>
    <br/>
    <ul>
        <li>Python built-in functions often use positional-only parameters:</li>
    </ul>

<pre><code class="language-python line-numbers">pow(base, exp, mod=None, /)
</code></pre>

    <br/>
    <ul>
        <li>Meaning:</li>
        <ul>
            <li><code>base</code>, <code>exp</code>, <code>mod</code> must be positional</li>
            <li>Cannot call: <code>pow(base=2, exp=3)</code></li>
        </ul>
    </ul>

    <br/><br/>



    <li><b>Common Uses in Real Codebases</b></li>
    <br/>
    <ul>
        <li><b>Library APIs</b> (Positional-only)</li>
        <ul><li>Protects parameter names from becoming part of public API.</li></ul>
        <br/>
        <li><b>Configuration functions</b> (Keyword-only)</li>
        <ul><li>Force clarity: <code>send(email, *, retries=3, timeout=1000)</code></li></ul>
        <br/>
        <li><b>Decorators</b> (args + kwargs)</li>
        <ul><li>Capture any function signatures flexibly.</li></ul>
        <br/>
        <li><b>Wrappers & Forwarding</b></li>
        <ul><li>Useful when passing options through layers of functions.</li></ul>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Syntax</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>/</code></td>
                <td>Positional-only parameters</td>
            </tr>
            <tr>
                <td><code>*</code></td>
                <td>Keyword-only parameters</td>
            </tr>
            <tr>
                <td><code>*args</code></td>
                <td>Captures extra positional arguments</td>
            </tr>
            <tr>
                <td><code>**kwargs</code></td>
                <td>Captures extra keyword arguments</td>
            </tr>
            <tr>
                <td><code>*args, **kwargs</code></td>
                <td>Flexible wrappers for arbitrary signatures</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-range">Python <code>range</code></h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>range</code> is a built-in Python type used to generate arithmetic sequences of integers.</li>
        <br/>
        <li>It is commonly used in loops, iterations, indexing, and algorithmic logic.</li>
        <br/>
        <li><code>range</code> objects are:</li>
        <ul>
            <li><b>immutable</b></li>
            <li><b>lazy</b> (values are produced on demand)</li>
            <li><b>memory efficient</b> even for large sequences</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Basic Forms of <code>range</code></b></li>
    <br/>
    <ul>
        <li><code>range(stop)</code></li>
        <li><code>range(start, stop)</code></li>
        <li><code>range(start, stop, step)</code></li>
    </ul>

<pre><code class="language-python line-numbers">range(5)            # 0, 1, 2, 3, 4
range(2, 7)         # 2, 3, 4, 5, 6
range(1, 10, 2)     # 1, 3, 5, 7, 9
</code></pre>

    <br/><br/>



    <li><b>Range Objects Don‚Äôt Produce Lists</b></li>
    <br/>
    <ul>
        <li><code>range</code> itself does not store all values.</li>
        <li>To see the actual numbers, convert it:</li>
    </ul>

<pre><code class="language-python line-numbers">list(range(5))
# [0, 1, 2, 3, 4]
</code></pre>

    <br/><br/>



    <li><b>Default Behavior</b></li>
    <br/>
    <ul>
        <li><b>start</b> defaults to 0</li>
        <li><b>step</b> defaults to +1</li>
        <li>The <code>stop</code> value is <b>exclusive</b></li>
    </ul>

<pre><code class="language-python line-numbers">range(4)     # 0, 1, 2, 3  (never reaches 4)
</code></pre>

    <br/><br/>



    <li><b>Using <code>range</code> in Loops</b></li>
    <br/>

<pre><code class="language-python line-numbers">for i in range(3):
    print(i)
</code></pre>
    <ul><li>Output:</li></ul>

<pre><code class="language-python">0
1
2
</code></pre>

    <br/><br/>



    <li><b>Using <code>range</code> with <code>start</code> and <code>stop</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">for i in range(5, 10):
    print(i)
</code></pre>

    <br/><br/>



    <li><b>Using <code>step</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">range(0, 10, 2)   # even numbers: 0,2,4,6,8
range(1, 10, 2)   # odd numbers: 1,3,5,7,9
</code></pre>

    <br/><br/>



    <li><b>Negative Step (Counting Backward)</b></li>
    <br/>

<pre><code class="language-python line-numbers">range(10, 0, -1)     # 10, 9, 8, ..., 1
range(5, -6, -2)     # 5, 3, 1, -1, -3, -5
</code></pre>

    <br/>
    <ul>
        <li>When using a negative step, <code>stop</code> must be <b>less than</b> <code>start</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Ranges with Zero or Invalid Steps</b></li>
    <br/>

<pre><code class="language-python line-numbers">range(0, 10, 0)    # ‚ùå error: step cannot be zero
</code></pre>

    <ul><li>Step must be non-zero ‚Äî either positive or negative.</li></ul>

    <br/><br/>



    <li><b>Range is Lazy and Efficient</b></li>
    <br/>
    <ul>
        <li><code>range(1_000_000_000)</code> uses the same memory as <code>range(5)</code>.</li>
        <li>No list of numbers is stored ‚Äî values are computed when needed.</li>
    </ul>

<pre><code class="language-python line-numbers">r = range(1_000_000_000)
print(len(r))      # works instantly!
</code></pre>

    <br/><br/>



    <li><b>Membership Testing (<code>in</code>)</b></li>
    <br/>
    <ul>
        <li><code>range</code> supports fast membership tests:</li>
    </ul>

<pre><code class="language-python line-numbers">5 in range(10)         # True
9 in range(1, 10, 2)   # False
</code></pre>

    <ul>
        <li>It does this mathematically, without iterating.</li>
    </ul>

    <br/><br/>



    <li><b>Indexing and Slicing</b></li>
    <br/>
    <ul>
        <li>Range objects support indexing:</li>
    </ul>

<pre><code class="language-python line-numbers">r = range(10, 20)
print(r[0])    # 10
print(r[5])    # 15
print(r[-1])   # 19
</code></pre>

    <br/>
    <ul><li>Ranges can also be sliced, resulting in another <code>range</code>:</li></ul>

<pre><code class="language-python line-numbers">r = range(0, 20, 2)  # 0,2,4,...18
print(r[2:6])         # range(4, 12, 2)
</code></pre>

    <br/><br/>



    <li><b>Common Patterns with <code>range</code></b></li>
    <br/>
    <ul>
        <li><b>Looping N times</b></li>
    </ul>

<pre><code class="language-python line-numbers">for _ in range(3):
    print("hi")
</code></pre>

    <br/>

    <ul><li><b>Indexing lists</b></li></ul>

<pre><code class="language-python line-numbers">names = ["Anna", "Ben", "Carl"]
for i in range(len(names)):
    print(i, names[i])
</code></pre>

    <br/>

    <ul><li><b>Reversed loops</b></li></ul>

<pre><code class="language-python line-numbers">for i in range(10, -1, -1):
    print(i)
</code></pre>

    <br/>

    <ul><li><b>Generating arithmetic sequences</b></li></ul>

<pre><code class="language-python line-numbers">evens = list(range(0, 21, 2))
</code></pre>

    <br/><br/>



    <li><b>Comparison of List vs Range</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>list(range)</th>
                <th>range</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Memory usage</td>
                <td>Large (stores all values)</td>
                <td>Tiny (three integers only)</td>
            </tr>
            <tr>
                <td>Speed of iteration</td>
                <td>Fast</td>
                <td>Fast</td>
            </tr>
            <tr>
                <td>Supports slicing</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Supports membership test</td>
                <td>Linear search</td>
                <td>Constant-time math</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lazy</td>
                <td>No list stored; values computed when needed</td>
            </tr>
            <tr>
                <td>Efficient</td>
                <td>Constant memory usage</td>
            </tr>
            <tr>
                <td>Exclusive stop</td>
                <td>Sequence stops before the stop value</td>
            </tr>
            <tr>
                <td>Step</td>
                <td>Can count upward or downward</td>
            </tr>
            <tr>
                <td>Supports slicing</td>
                <td>Slicing returns a new range</td>
            </tr>
            <tr>
                <td>Constant-time membership</td>
                <td>Efficient mathematical check</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-lambda">Python Lambda Expressions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>lambda</code> expression in Python creates a small, anonymous function.</li>
        <br/>
        <li>Lambdas are useful when you need a short function for a brief moment and do not want to define a full <code>def</code> block.</li>
        <br/>
        <li>However, they are intentionally limited: a lambda can contain only <b>one expression</b> (no statements).</li>
    </ul>
    <br/><br/>



    <li><b>Basic Syntax</b></li>
    <br/>

<pre><code class="language-python line-numbers">lambda arguments: expression
</code></pre>

    <br/>
    <ul>
        <li>Example:</li>
    </ul>

<pre><code class="language-python line-numbers">add = lambda a, b: a + b
print(add(3, 4))   # 7
</code></pre>

    <br/>
    <ul>
        <li>This is equivalent to:</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    return a + b
</code></pre>

    <br/><br/>



    <li><b>Single Expression Only</b></li>
    <br/>
    <ul>
        <li>The body must be a single expression ‚Äî not statements, loops, assignments, or annotations.</li>
    </ul>

<pre><code class="language-python line-numbers">lambda x: x * 2           # OK
lambda x: print(x)        # OK (print is an expression here)

lambda x: y = x + 1       # ‚ùå error (assignment is not allowed)
lambda x: for i in ...    # ‚ùå cannot contain loops
</code></pre>

    <br/><br/>



    <li><b>Zero-Argument Lambdas</b></li>
    <br/>

<pre><code class="language-python line-numbers">noop = lambda: None
noop()
</code></pre>

    <br/><br/>



    <li><b>Lambdas with Default Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">f = lambda x=10, y=20: x + y
print(f())       # 30
print(f(5))      # 25
</code></pre>

    <br/><br/>



    <li><b>Lambdas Returning Other Lambdas</b></li>
    <br/>

<pre><code class="language-python line-numbers">make_multiplier = lambda n: (lambda x: x * n)
times3 = make_multiplier(3)
print(times3(10))   # 30
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>sorted()</code></b></li>
    <br/>
    <ul>
        <li>A common use case is providing a custom sorting key.</li>
    </ul>

<pre><code class="language-python line-numbers">names = ["alice", "Bob", "carol"]
sorted_names = sorted(names, key=lambda s: s.lower())
print(sorted_names)
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>map()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [1, 2, 3]
doubled = list(map(lambda n: n * 2, nums))
print(doubled)   # [2, 4, 6]
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>filter()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">nums = [1, 2, 3, 4, 5]
evens = list(filter(lambda n: n % 2 == 0, nums))
print(evens)     # [2, 4]
</code></pre>

    <br/><br/>



    <li><b>Lambdas in <code>reduce()</code></b></li>
    <br/>

<pre><code class="language-python line-numbers">from functools import reduce

nums = [1, 2, 3, 4]
total = reduce(lambda a, b: a + b, nums)
print(total)     # 10
</code></pre>

    <br/><br/>



    <li><b>Lambdas in Dictionary Structures</b></li>
    <br/>
    <ul>
        <li>Useful for defining small callback tables or dispatch maps:</li>
    </ul>

<pre><code class="language-python line-numbers">actions = {
    "square": lambda x: x * x,
    "cube": lambda x: x * x * x,
}

print(actions)   # 27
</code></pre>

    <br/><br/>



    <li><b>Using Lambdas in UI / Callback Code</b></li>
    <br/>

<pre><code class="language-python line-numbers">def on_click(callback):
    callback()

on_click(lambda: print("Clicked!"))
</code></pre>

    <br/><br/>



    <li><b>Using Lambdas with Closures</b></li>
    <br/>
    <ul><li>Lambdas capture variables from the surrounding scope.</li></ul>

<pre><code class="language-python line-numbers">def make_add(n):
    return lambda x: x + n

add5 = make_add(5)
print(add5(10))   # 15
</code></pre>

    <br/><br/>


    <li><b>Lambdas vs Named Functions</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>lambda</th>
                <th>def function</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Has a name?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Multiple statements?</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Main usage</td>
                <td>Short, throwaway functions</td>
                <td>Larger or reusable logic</td>
            </tr>
            <tr>
                <td>Debug readability</td>
                <td>Poor</td>
                <td>Good</td>
            </tr>
            <tr>
                <td>Syntax</td>
                <td>Single expression</td>
                <td>Block with <code>return</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Anonymous</td>
                <td><code>lambda</code> defines short unnamed functions</td>
            </tr>
            <tr>
                <td>Single expression</td>
                <td>No blocks, no loops, no assignments</td>
            </tr>
            <tr>
                <td>Common uses</td>
                <td><code>sorted</code>, <code>map</code>, <code>filter</code>, callbacks</td>
            </tr>
            <tr>
                <td>Readability</td>
                <td>Good for small tasks, bad for complex logic</td>
            </tr>
            <tr>
                <td>Alternatives</td>
                <td>Use <code>def</code> for named, clearer functions</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="python-docstrings">Python Documentation Strings (Docstrings)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>docstring</b> in Python is a string literal placed at the beginning of a module, class, method, or function.</li>
        <br/>
        <li>Docstrings provide built-in documentation and can be retrieved programmatically using <code>help()</code>, <code>.__doc__</code>, and tooling such as IDEs and Sphinx.</li>
        <br/>
        <li>Docstrings are intended for humans, but are stored and accessible at runtime.</li>
        <br/>
        <li>The standard format is a triple-quoted string:</li>
    </ul>

<pre><code class="language-python line-numbers">"""This is a docstring."""</code></pre>

    <br/><br/>



    <li><b>Where Docstrings Can Be Placed</b></li>
    <br/>
    <ul>
        <li>Module-level</li>
        <li>Class-level</li>
        <li>Function / Method-level</li>
    </ul>

<pre><code class="language-python line-numbers">"""
This module handles user authentication logic.
"""


def login(user, password):
    """Authenticate a user by password."""
    ...
</code></pre>

    <br/><br/>



    <li><b>Accessing Docstrings</b></li>
    <br/>

<pre><code class="language-python line-numbers">print(login.__doc__)
help(login)
</code></pre>

    <br/>
    <ul>
        <li><code>help()</code> uses docstrings to display formatted documentation.</li>
    </ul>

    <br/><br/>



    <li><b>One-Line Docstrings</b></li>
    <br/>
    <ul>
        <li>Used for simple, self-explanatory functions.</li>
    </ul>

<pre><code class="language-python line-numbers">def add(a, b):
    """Return the sum of a and b."""
    return a + b
</code></pre>

    <br/><br/>



    <li><b>Multi-Line Docstrings</b></li>
    <br/>
    <ul>
        <li>Follow PEP 257 conventions:</li>
        <ul>
            <li>First line: short summary</li>
            <li>Blank line</li>
            <li>Detailed explanation (optional)</li>
        </ul>
    </ul>

<pre><code class="language-python line-numbers">def connect(url, timeout=10):
    """
    Connect to a remote server.

    This function establishes a TCP connection to the given URL.
    The connection will fail if the timeout is exceeded.
    """
    ...
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Classes</b></li>
    <br/>

<pre><code class="language-python line-numbers">class User:
    """
    Represents a system user with username and email.
    """

    def __init__(self, username, email):
        """Initialize a new User object."""
        self.username = username
        self.email = email
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Methods</b></li>
    <br/>

<pre><code class="language-python line-numbers">class Circle:
    """Circle with radius and area calculation."""

    def area(self):
        """Return the area of the circle."""
        import math
        return math.pi * self.r * self.r
</code></pre>

    <br/><br/>



    <li><b>Documenting Parameters</b></li>
    <br/>
    <ul>
        <li>Python has no official format, but common standards are:</li>
        <ul>
            <li>Google style</li>
            <li>NumPy style</li>
            <li>reStructuredText / Sphinx style</li>
        </ul>
    </ul>

    <br/><br/>


    <li><b>Google Style Example</b></li>

<pre><code class="language-python line-numbers">def add(a, b):
    """
    Add two numbers.

    Args:
        a (int): First number.
        b (int): Second number.

    Returns:
        int: Sum of a and b.
    """
    return a + b
</code></pre>

    <br/><br/>



    <li><b>NumPy Style</b></li>
    <br/>

<pre><code class="language-python line-numbers">def scale(values, factor):
    """
    Scale an array by a factor.

    Parameters
    ----------
    values : list[int]
        Sequence of numbers.
    factor : int or float
        Multiplier.

    Returns
    -------
    list[int]
        Scaled numbers.
    """
    return [v * factor for v in values]
</code></pre>

    <br/><br/>



    <li><b>Sphinx / reStructuredText (RST) Style</b></li>
    <br/>

<pre><code class="language-python line-numbers">def greet(name):
    """
    Greet a user.

    :param name: User's name.
    :type name: str
    :return: Greeting message.
    :rtype: str
    """
    return f"Hello, {name}!"
</code></pre>

    <br/><br/>



    <li><b>Documenting Return Values</b></li>
    <br/>

<pre><code class="language-python line-numbers">def compute(x):
    """
    Compute something useful.

    Returns:
        float: The computed value.
    """
    return x * 2.5
</code></pre>

    <br/><br/>



    <li><b>Documenting Exceptions</b></li>
    <br/>

<pre><code class="language-python line-numbers">def read_file(path):
    """
    Read a file.

    Args:
        path (str): File path.

    Raises:
        FileNotFoundError: If the file does not exist.
    """
    with open(path) as f:
        return f.read()
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Modules</b></li>
    <br/>

<pre><code class="language-python line-numbers">"""
utility.py - helper functions for math and statistics.
"""
</code></pre>

    <br/><br/>



    <li><b>Docstrings for Packages</b></li>
    <br/>
    <ul><li>Place a docstring inside <code>__init__.py</code>:</li></ul>

<pre><code class="language-python line-numbers">"""
This package contains utilities for data analysis.
"""
</code></pre>

    <br/><br/>



    <li><b>Automated Tools That Use Docstrings</b></li>
    <br/>
    <ul>
        <li><code>help()</code> ‚Äî built-in interactive documentation</li>
        <li>IDEs (VSCode, PyCharm, etc.) show docstring hints</li>
        <li><code>pydoc</code> ‚Äî documentation generator</li>
        <li>Sphinx ‚Äî advanced documentation tool</li>
        <li>Type checkers use docstrings for descriptions but not for typing</li>
    </ul>

    <br/><br/>



    <li><b>PEP 257 Docstring Conventions</b></li>
    <br/>
    <ul>
        <li>Triple quotes should be used.</li>
        <li>First line should be a short summary.</li>
        <li>Add a blank line before detailed descriptions.</li>
        <li>Use consistent indentation.</li>
        <li>Closing quotes should be on their own line if multi-line.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Definition</td>
                <td>String literal used to document modules, classes, and functions</td>
            </tr>
            <tr>
                <td>Supported By</td>
                <td>help(), IDEs, Sphinx, pydoc</td>
            </tr>
            <tr>
                <td>Styles</td>
                <td>Google, NumPy, Sphinx/RST</td>
            </tr>
            <tr>
                <td>Retrieval</td>
                <td><code>object.__doc__</code> or <code>help()</code></td>
            </tr>
            <tr>
                <td>Purpose</td>
                <td>Provide human-readable API documentation</td>
            </tr>
            <tr>
                <td>Best Practices</td>
                <td>Short summary + details, parameter docs, return/exception docs</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
