<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>VUE</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;
        height: 18px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/vue.png" alt="VUE Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#vue-introduction">Introduction</a></li>
        <li><a href="#vue-options-vs-composition">Options API vs Composition API</a></li>
        <li><a href="#vue-composition-api">Composition API</a></li>
        <li><a href="#vue-reactive-value">Reactive Value</a></li>
        <li><a href="#vue-create-app">Creating a Vue Application</a></li>
        <li><a href="#vue-template-syntax">Template Syntax</a></li>
        <li><a href="#vue-watchers">Watchers</a></li>
        <li><a href="#vue-template-refs">Template Refs</a></li>
        <li><a href="#vue-typescript">Using Vue with TypeScript</a></li>
        <li><a href="#vue-components-basics">Components Basics</a></li>
        <li><a href="#vue-component-registration">Component Registration</a></li>
        <li><a href="#vue-props">Props</a></li>
        <li><a href="#vue-component-events">Component Events</a></li>
        <li><a href="#vue-component-v-model">Component v-model</a></li>
        <li><a href="#vue-fallthrough-attributes">Fallthrough Attributes</a></li>
        <li><a href="#vue-lifecycle-hooks">Lifecycle Hooks</a></li>
        <li><a href="#vue-slots">Slots</a></li>
        <li><a href="#vue-conditional-rendering">Conditional Rendering</a></li>
        <li><a href="#vue-list-rendering">List Rendering</a></li>
        <li><a href="#vue-event-handling">Event Handling</a></li>
        <li><a href="#vue-form-input-bindings">Form Input Bindings</a></li>
        <li><a href="#vue-scoped-slots">Scoped Slots</a></li>
        <li><a href="#vue-provide-inject">Provide / Inject</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-introduction">Introduction to Vue.js</h3>
<ol>
    <li><b>What Is Vue.js?</b></li>
    <br/>
    <ul>
        <li><b>Vue.js</b> (usually called just “Vue”) is a progressive, flexible, and beginner-friendly JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Vue focuses on the <u>view layer</u> (what the user sees) but can grow into a full application framework using official tools such as:
            <ul>
                <li><code>Vue Router</code>: for navigation</li>
                <li><code>Pinia</code>: for state management</li>
                <li><code>Vite</code>: for fast development tooling</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>How Vue Works</b></li>
    <br/>
    <ul>
        <li>Vue uses a <u>reactive data system</u>: when your data changes, the UI updates automatically.</li>
        <br/>
        <li>Your Vue app contains:
            <ul>
                <li>a JavaScript object storing data and logic</li>
                <li>a template that displays this data</li>
                <li>Vue automatically connects (binds) the two</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;div id="app"&gt;
    {{ message }}
&lt;/div&gt;

&lt;script&gt;
const app = Vue.createApp({
    data() {
        return {
            message: "Hello Vue!"
        }
    }
});
app.mount("#app");
&lt;/script&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{{ }}</code> automatically updates when <code>message</code> changes.</li>
    </ul>

    <br/><br/>



    <li><b>Getting Started (CDN Method)</b></li>
    <br/>
    <ul>
        <li>The easiest way to try Vue is by including it from a CDN:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
</code></pre>
    <ul>
        <li>This allows Vue to run directly in your HTML page.</li>
    </ul>

    <br/><br/>



    <li><b>Core Concepts of Vue</b></li>

    <br/>
    <ol>
    <li><b>Templates &amp; Data Binding</b></li>
    <br/>
    <ul>
        <li>Vue uses a clean declarative template syntax.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;div id="app"&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Counter: {{ count }}&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-js line-numbers">data() {
    return {
        title: "Welcome",
        count: 0
    }
}
</code></pre>

    <br/><br/>



    <li><b>Event Handling</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;button @click="count++"&gt;Increase&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>@click</code> is a shortcut for <code>v-on:click</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Two-Way Binding with <code>v-model</code></b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;input v-model="name"&gt;
&lt;p&gt;Hello {{ name }}&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>

    <br/><br/>



    <li><b>Conditionals and Loops</b></li>
<pre><code class="language-html line-numbers">&lt;p v-if="loggedIn"&gt;Welcome back!&lt;/p&gt;
&lt;p v-else&gt;Please log in.&lt;/p&gt;

&lt;ul&gt;
    &lt;li v-for="item in items"&gt;{{ item }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

    <br/><br/>



    <li><b>Computed Properties</b></li>
    <br/>
    <ul>
        <li>Vue recalculates these automatically when dependent data changes.</li>
    </ul>

<pre><code class="language-js line-numbers">computed: {
    reversed() {
        return this.message.split("").reverse().join("");
    }
}
</code></pre>

    <br/><br/>



    <li><b>Methods</b></li>
<pre><code class="language-js line-numbers">methods: {
    greet() {
        return "Hello " + this.name;
    }
}
</code></pre>
    </ol>

    <br/><br/>



    <li><b>Single File Components (SFC)</b></li>
    <br/>
    <ul>
        <li>For bigger apps, Vue uses <code>.vue</code> files, each containing:</li>
        <ul>
            <li><code>&lt;template&gt;</code> – HTML</li>
            <li><code>&lt;script&gt;</code> – JS</li>
            <li><code>&lt;style&gt;</code> – CSS</li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- MyComponent.vue --&gt;
&lt;template&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        return { title: "Hello SFC" }
    }
}
&lt;/script&gt;

&lt;style&gt;
h1 { color: blue; }
&lt;/style&gt;
</code></pre>

    <br/><br/>



    <li><b>Vue Tooling: Vite & Vue CLI</b></li>
    <br/>
    <ul>
        <li>For real applications, use a build tool:</li>
        <ul>
            <li><code>Vite</code>: modern, very fast</li>
            <li><code>Vue CLI</code>: older but still used</li>
        </ul>
    </ul>

<pre><code class="language-bash line-numbers">npm create vue@latest
cd myproject
npm install
npm run dev
</code></pre>

    <br/><br/>



    <li><b>Ecosystem Overview</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Vue Router</td>
                <td>Navigation for SPA apps</td>
            </tr>
            <tr>
                <td>Pinia</td>
                <td>State management</td>
            </tr>
            <tr>
                <td>Vite</td>
                <td>Development &amp; build tool</td>
            </tr>
            <tr>
                <td>DevTools</td>
                <td>Chrome/Firefox debugging extension</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Why Vue Is Great for Beginners</b></li>
    <br/>
    <ul>
        <li>Simple to understand – start with HTML and small scripts</li>
        <li>Powerful for large applications</li>
        <li>More lightweight and intuitive compared to React or Angular</li>
        <li>Very clean syntax (easy to read)</li>
        <li>Excellent documentation</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Reactivity</td>
                <td>UI updates automatically when data changes</td>
            </tr>
            <tr>
                <td>Declarative templates</td>
                <td>Use <code>{{ }}</code> to display data easily</td>
            </tr>
            <tr>
                <td>Directives</td>
                <td><code>v-if</code>, <code>v-for</code>, <code>v-model</code>, <code>v-on</code></td>
            </tr>
            <tr>
                <td>Components</td>
                <td>Reusable UI blocks, .vue files</td>
            </tr>
            <tr>
                <td>Tooling</td>
                <td>Vite, Vue Router, Pinia</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-options-vs-composition">Vue Options API vs Composition API (Introduction & Comparison)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue components can be written using two different styles:</li>
        <ul>
            <li><b>Options API</b> (Vue 2 style, still fully supported in Vue 3)</li>
            <li><b>Composition API</b> (new in Vue 3, more flexible)</li>
        </ul>
        <br/>
        <li>Both styles are valid, and you can mix them in one project.</li>
        <br/>
        <li>The difference is mainly in:
            <ul>
                <li>how you structure code</li>
                <li>how you define reactive data</li>
                <li>how logic is organized and reused</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Options API (Traditional Vue Style)</b></li>
    <br/>
    <ul>
        <li>The Options API organizes code into <u>sections</u> inside a component:</li>
        <ul>
            <li><code>data()</code></li>
            <li><code>methods</code></li>
            <li><code>computed</code></li>
            <li><code>watch</code></li>
            <li><code>props</code></li>
        </ul>
        <br/>
        <li>This style is easy for beginners because logic is grouped by <u>options</u>, not by <u>functionality</u>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    data() {
        return { count: 0 }
    },
    methods: {
        increment() {
            this.count++
        }
    },
    computed: {
        double() {
            return this.count * 2
        }
    }
}
</code></pre>
    <ul>
        <li>Good for small to medium components, beginners, simple logic.</li>
    </ul>

    <br/><br/>



    <li><b>Composition API (Modern Vue Style)</b></li>
    <br/>
    <ul>
        <li>Composition API moves logic into the <code>setup()</code> function.</li>
        <br/>
        <li>You create reactive variables using:</li>
        <ul>
            <li><code>ref()</code></li>
            <li><code>reactive()</code></li>
            <li><code>computed()</code></li>
            <li><code>watch()</code></li>
        </ul>
        <br/>
        <li>This style is more flexible, easier to scale, and ideal for complex apps.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

export default {
    setup() {
        const count = ref(0)
        const increment = () =&gt; count.value++
        const double = computed(() =&gt; count.value * 2)

        return { count, increment, double }
    }
}
</code></pre>
    <ul>
        <li>Good for large projects, reusable logic, TypeScript support.</li>
    </ul>

    <br/><br/>



    <li><b>Key Differences</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Code organization</td>
                <td>Grouped by <b>option</b> (data, methods, computed)</td>
                <td>Grouped by <b>logic</b> and feature</td>
            </tr>
            <tr>
                <td>Learning curve</td>
                <td>Easier for beginners</td>
                <td>Requires understanding of JS functions and reactivity</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Implicit (<code>this.count++</code>)</td>
                <td>Explicit (<code>ref</code>, <code>reactive</code>, <code>value</code>)</td>
            </tr>
            <tr>
                <td>Logic reuse</td>
                <td>Mixins (old, limited)</td>
                <td>Composable functions (modern, powerful)</td>
            </tr>
            <tr>
                <td>Scaling to large apps</td>
                <td>More difficult</td>
                <td>Much easier</td>
            </tr>
            <tr>
                <td>TypeScript support</td>
                <td>Limited</td>
                <td>Excellent</td>
            </tr>
            <tr>
                <td>IDE autocompletion</td>
                <td>Less precise (due to <code>this</code>)</td>
                <td>Very precise (explicit types &amp; refs)</td>
            </tr>
            <tr>
                <td>Recommended for Vue 3?</td>
                <td>Still supported &amp; fine</td>
                <td><b>Yes, the future direction</b></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When to Use Which?</b></li>
    <br/>
    <ul>
        <li><b>Use Options API if:</b>
            <ul>
                <li>you are a beginner</li>
                <li>your component is small</li>
                <li>your team prefers classic Vue</li>
            </ul>
        </li>
        <br/>
        <li><b>Use Composition API if:</b>
            <ul>
                <li>your application is large</li>
                <li>you want reusable logic</li>
                <li>you use TypeScript</li>
                <li>you need more flexibility</li>
                <li>you want better structure for complex features</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Example Comparison (Same Component in Both APIs)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
<pre><code class="language-js line-numbers">export default {
    data() {
        return { count: 0 }
    },
    methods: {
        increment() {
            this.count++
        }
    }
}
</code></pre>
                </td>
                <td>
<pre><code class="language-js line-numbers">import { ref } from "vue"

export default {
    setup() {
        const count = ref(0)
        const increment = () =&gt; count.value++
        return { count, increment }
    }
}
</code></pre>
                </td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ease of use</td>
                <td>Very easy</td>
                <td>Medium</td>
            </tr>
            <tr>
                <td>Flexibility</td>
                <td>Limited</td>
                <td>Very high</td>
            </tr>
            <tr>
                <td>Logic organization</td>
                <td>Separated by option</td>
                <td>Grouped by feature</td>
            </tr>
            <tr>
                <td>Preferred for new Vue 3 apps?</td>
                <td>Okay</td>
                <td><b>Yes</b></td>
            </tr>
            <tr>
                <td>TypeScript</td>
                <td>Not ideal</td>
                <td><b>Excellent</b></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-composition-api">Introduction to the Vue 3 Composition API (Thorough & Beginner-Friendly)</h3>
<ol>
    <li><b>Short Intro</b></li>
    <br/>
    <ul>
        <li>The <code>Composition API</code> is a modern way to write Vue components using plain JavaScript functions.</li>
        <br/>
        <li>It was introduced in Vue 3 and offers:
            <ul>
                <li>better logic organization</li>
                <li>cleaner code for complex components</li>
                <li>excellent TypeScript support</li>
                <li>more powerful code reuse</li>
            </ul>
        </li>
        <br/>
        <li>Instead of putting logic in separate blocks (<code>data</code>, <code>computed</code>, <code>methods</code>), everything lives together inside <code>setup()</code>.</li>
    </ul>
    <br/><br/>



    <li><b>The Setup Function</b></li>
    <br/>
    <ul>
        <li><code>setup()</code> is the entry point for the Composition API in a component.</li>
        <li>It runs before the component is created and returns what the template can use.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    setup() {
        return {
            // expose things to the template
        }
    }
}
</code></pre>
    <ul>
        <li>Everything used by the template must be returned from <code>setup()</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Creating Reactive State with ref()</b></li>
    <br/>
    <ul>
        <li><code>ref()</code> creates a reactive value.</li>
        <li>Use it for primitives (numbers, strings, booleans).</li>
        <li>The actual value lives in <code>.value</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref } from "vue"

export default {
    setup() {
        const count = ref(0)

        function increment() {
            count.value++
        }

        return { count, increment }
    }
}
</code></pre>
    <ul>
        <li><b>Important:</b> In templates, Vue automatically unwraps <code>ref</code>. No need to use <code>.value</code> inside HTML.</li>
    </ul>

    <br/><br/>



    <li><b>Reactive Objects with reactive()</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> creates a reactive object.</li>
        <li>Use it for collections or multiple related values.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive } from "vue"

export default {
    setup() {
        const state = reactive({
            name: "Hwangfu",
            age: 22
        })

        return { state }
    }
}
</code></pre>
    <ul>
        <li>Reactive objects behave like normal JS objects but trigger UI updates when mutated.</li>
    </ul>

    <br/><br/>



    <li><b>Computed Properties</b></li>
    <br/>
    <ul>
        <li><code>computed()</code> creates values that update automatically when dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

export default {
    setup() {
        const count = ref(5)
        const double = computed(() =&gt; count.value * 2)

        return { count, double }
    }
}
</code></pre>
    <ul>
        <li>Computed properties are cached and recomputed only when needed.</li>
    </ul>

    <br/><br/>



    <li><b>Watchers</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> runs a callback when reactive data changes.</li>
        <li>Good for asynchronous operations, API calls, or side effects.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

export default {
    setup() {
        const name = ref("")

        watch(name, (newVal, oldVal) =&gt; {
            console.log("Changed from", oldVal, "to", newVal)
        })

        return { name }
    }
}
</code></pre>

    <br/><br/>



    <li><b>watchEffect()</b> (Automatic Tracking)</li>
    <br/>
    <ul>
        <li><code>watchEffect()</code> tracks all reactive values inside it automatically.</li>
        <li>It re-runs itself whenever dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watchEffect } from "vue"

export default {
    setup() {
        const x = ref(1)

        watchEffect(() =&gt; {
            console.log("x is", x.value)
        })

        return { x }
    }
}
</code></pre>

    <br/><br/>



    <li><b>Methods in Composition API</b></li>
    <br/>
    <ul>
        <li>There is no <code>methods</code> section.</li>
        <li>You simply define functions inside <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">setup() {
    const count = ref(0)

    function increment() {
        count.value++
    }

    return { count, increment }
}
</code></pre>

    <br/><br/>



    <li><b>Lifecycles in Composition API</b></li>
    <br/>
    <ul>
        <li>Instead of Options API lifecycle hooks (<code>mounted</code>, <code>created</code>), Composition API uses importable functions.</li>
    </ul>

<pre><code class="language-js line-numbers">import { onMounted, onUnmounted } from "vue"

export default {
    setup() {
        onMounted(() =&gt; {
            console.log("Component mounted")
        })

        onUnmounted(() =&gt; {
            console.log("Component removed")
        })
    }
}
</code></pre>

    <br/>
    <ul>
        <li>Other hooks:
            <ul>
                <li><code>onMounted</code></li>
                <li><code>onUpdated</code></li>
                <li><code>onUnmounted</code></li>
                <li><code>onBeforeMount</code></li>
                <li><code>onBeforeUpdate</code></li>
                <li><code>onBeforeUnmount</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Props in Composition API</b></li>
    <br/>
    <ul>
        <li>Props are received as arguments to <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    props: {
        msg: String;
    },

    setup(props) {
        console.log(props.msg);
        return { };
    }
}
</code></pre>

    <br/><br/>



    <li><b>Emitting Events</b></li>
    <br/>
    <ul>
        <li>You receive <code>emit</code> as the second argument in <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    emits: ["update"],

    setup(props, { emit }) {
        function updateValue() {
            emit("update", 42)
        }

        return { updateValue }
    }
}
</code></pre>

    <br/><br/>



    <li><b>Extracting Logic Into Composables</b></li>
    <br/>
    <ul>
        <li>The Composition API allows you to reuse logic by creating <b>composable functions</b>.</li>
        <li>These are just plain JS functions that return reactive state.</li>
    </ul>

<pre><code class="language-js line-numbers">// useCounter.js
import { ref } from "vue"

export function useCounter() {
    const count = ref(0)
    const increment = () =&gt; count.value++
    return { count, increment }
}
</code></pre>

<pre><code class="language-js line-numbers">// Component.vue
import { useCounter } from "./useCounter"

export default {
    setup() {
        const { count, increment } = useCounter()
        return { count, increment }
    }
}
</code></pre>

    <br/><br/>



    <li><b>Why the Composition API Is Powerful</b></li>
    <br/>
    <ul>
        <li>Flexible code structure</li>
        <li>Easier for large teams</li>
        <li>Better logic reuse (composables)</li>
        <li>Works extremely well with TypeScript</li>
        <li>No complex mixins or inheritance needed</li>
        <li>Cleaner separation of features</li>
    </ul>

    <br/><br/>



    <li><b>Options API vs Composition API Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Organization</td>
                <td>By option type (data, methods, etc.)</td>
                <td>By logic/functionality</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Implicit <code>this</code></td>
                <td>Explicit <code>ref</code>, <code>reactive</code></td>
            </tr>
            <tr>
                <td>Logic reuse</td>
                <td>mixins</td>
                <td>composables</td>
            </tr>
            <tr>
                <td>TypeScript</td>
                <td>not ideal</td>
                <td>excellent</td>
            </tr>
            <tr>
                <td>Best for</td>
                <td>small/simple components</td>
                <td>medium/large apps, reusable logic</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-reactive-value">What Is a Reactive Value in Vue?</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>It allows the UI to update automatically whenever your data changes.</li>
        <br/>
        <li>A <u>reactive value</u> is any value that Vue tracks internally so it can update the DOM when the value changes.</li>
        <br/>
        <li>In Vue 3 (Composition API), reactivity is created using:</li>
        <ul>
            <li><code>ref()</code> — for reactive primitives</li>
            <li><code>reactive()</code> — for reactive objects</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Why Reactivity Matters</b></li>
    <br/>
    <ul>
        <li>In plain JavaScript, changing a variable does <u>not</u> update the UI automatically.<br/>
            You would have to manually modify the DOM:</li>
    </ul>

<pre><code class="language-js line-numbers">let count = 0
document.getElementById("counter").innerText = count
count++
document.getElementById("counter").innerText = count
</code></pre>
    <ul>
        <li>This is slow, repetitive, and error-prone.</li>
        <br/>
        <li>In Vue, you update the variable → UI updates automatically.</li>
    </ul>

<pre><code class="language-js line-numbers">const count = ref(0)
count.value++  // UI updates automatically
</code></pre>

    <br/><br/>



    <li><b>ref(): Reactive Primitive Values</b></li>
    <br/>
    <ul>
        <li><code>ref()</code> wraps a value inside an object with a single property: <code>value</code>.</li>
        <li>This wrapper is reactive.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref } from "vue"

const count = ref(0)
console.log(count.value)  // 0

count.value++
console.log(count.value)  // 1
</code></pre>
    <ul>
        <li>Why <code>.value</code>?</li>
        <ul>
            <li>Because JavaScript primitives (number, string, boolean) cannot be made reactive by themselves.</li>
            <li>Vue wraps them in an object to track changes.</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>reactive(): Reactive Objects (Deep Reactivity)</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> makes an entire object reactive.</li>
        <li>All nested properties also become reactive.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive } from "vue"

const user = reactive({
    name: "Hwangfu",
    age: 22
})

user.age++  // automatically updates UI
</code></pre>

    <br/>
    <ul>
        <li>This is called <u>deep reactivity</u>, where every property is tracked.</li>
    </ul>
    <br/><br/>



    <li><b>How Vue Detects Changes (The Proxy System)</b></li>
    <br/>
    <ul>
        <li>Vue 3 uses the <b>JavaScript Proxy API</b> to intercept operations on reactive values:</li>
        <ul>
            <li>reading</li>
            <li>writing</li>
            <li>deleting</li>
        </ul>
        <br/>
        <li>Whenever a reactive property is read, Vue records the dependency.</li>
        <br/>
        <li>Whenever it’s changed, Vue schedules a UI update.</li>
    </ul>
    <br/><br/>



    <li><b>Reactive Values in Templates</b></li>
    <br/>
    <ul>
        <li>In Vue templates, ref values are <u>auto-unwrapped</u>.</li>
        <li>This means you do NOT write <code>.value</code> in templates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>

    <br/>
    <ul>
        <li>Even though <code>count</code> is a <code>ref</code>, Vue unwraps <code>.value</code> for convenience.</li>
    </ul>

    <br/><br/>



    <li><b>Computed Properties Are Also Reactive</b></li>
    <br/>
    <ul>
        <li><code>computed()</code> returns a special read-only reactive value.</li>
        <li>It updates whenever its dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

const count = ref(5)
const double = computed(() =&gt; count.value * 2)

console.log(double.value) // 10
count.value++
console.log(double.value) // 12
</code></pre>

    <br/><br/>



    <li><b>Watchers React to Changes</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> listens for changes in reactive values.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(count, (newVal, oldVal) =&gt; {
    console.log("Count changed:", oldVal, "-&gt;", newVal)
})
</code></pre>

    <br/><br/>



    <li><b>How Reactivity Differs from Plain JavaScript</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Plain JavaScript</th>
                <th>Vue Reactive Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Variables don't update UI automatically</td>
                <td>UI updates instantly when reactive value changes</td>
            </tr>
            <tr>
                <td>No dependency tracking</td>
                <td>Automatic dependency tracking</td>
            </tr>
            <tr>
                <td>Manual DOM updates needed</td>
                <td>DOM updates handled by Vue</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>ref vs reactive (Quick Comparison)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>ref()</th>
                <th>reactive()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Main use-case</td>
                <td>single primitive</td>
                <td>objects, arrays, maps</td>
            </tr>
            <tr>
                <td>Access</td>
                <td><code>value</code> property</td>
                <td>direct property access</td>
            </tr>
            <tr>
                <td>Deep reactivity</td>
                <td>No (wrapping only)</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Template auto-unwrapping</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When Should You Use ref()?</b></li>
    <br/>
    <ul>
        <li>primitive values (number, string, boolean)</li>
        <li>single reactive state</li>
        <li>you need full control over reactivity</li>
    </ul>

<pre><code class="language-js line-numbers">const isVisible = ref(true)
const count = ref(0)
const message = ref("Hello")
</code></pre>

    <br/><br/>



    <li><b>When Should You Use reactive()?</b></li>
    <br/>
    <ul>
        <li>objects</li>
        <li>arrays</li>
        <li>complex state</li>
    </ul>

<pre><code class="language-js line-numbers">const form = reactive({
    email: "",
    password: "",
    remember: false
})
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-create-app">Creating a Vue Application</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Vue 3, a "Vue application" is created with <code>createApp()</code> and mounted onto a DOM element.</li>
        <br/>
        <li>We will assume the <code>Composition API</code> by default (with <code>setup()</code>, <code>ref()</code>, etc.).</li>
        <br/>
        <li>There are two common ways to start a Vue app:
            <ul>
                <li><b>Quick test</b>: use Vue from a <u>CDN script</u> in a single HTML file</li>
                <li><b>Real project</b>: use a <u>build tool</u> (e.g. Vite with <code>npm create vue@latest</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Quick Start with CDN (Single HTML File)</b></li>
    <br/>
    <ul>
        <li>This is the fastest way to experiment with Vue.</li>
        <li>No build step, no bundler – just an HTML file and a script tag.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Vue 3 App&lt;/title&gt;
    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;button @click="count++"&gt;Clicked {{ count }} times&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        const { createApp, ref } = Vue;

        const App = {
            setup() {
                const title = ref("Hello Vue 3");
                const count = ref(0);

                return { title, count };
            }
        };

        createApp(App).mount("#app");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <ul>
        <li>Key points:
            <ul>
                <li><code>createApp(App)</code> creates a Vue application instance.</li>
                <li><code>.mount("#app")</code> tells Vue to control the <code>&lt;div id="app"&gt;</code>.</li>
                <li>The component object <code>App</code> uses the <b>Composition API</b> via <code>setup()</code>.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Real Project Setup with Vite (Recommended)</b></li>
    <br/>
    <ul>
        <li>For real apps, use a modern build tool. The recommended way is Vite with the official Vue starter.</li>
    </ul>

<pre><code class="language-bash line-numbers"># 1. Create a new Vue 3 + Vite project
npm create vue@latest my-vue-app

# 2. Move into the folder
cd my-vue-app

# 3. Install dependencies
npm install

# 4. Start dev server
npm run dev
</code></pre>
    <ul>
        <li>Then open the URL shown in the terminal (usually <code>http://localhost:5173</code>).</li>
        <li>You will see a default Vue starter page.</li>
    </ul>
    <br/><br/>



    <li><b>Project Structure (Typical Vite + Vue App)</b></li>
    <br/>

<pre><code class="language-text line-numbers">my-vue-app/
  ├─ index.html
  ├─ package.json
  ├─ vite.config.js
  └─ src/
      ├─ main.js
      ├─ App.vue
      └─ components/
          └─ ...
</code></pre>
    <ul>
        <li><code>index.html</code>: main HTML entry file.</li>
        <li><code>src/main.js</code>: JS entry where the Vue app is created and mounted.</li>
        <li><code>src/App.vue</code>: root Vue component.</li>
        <li><code>src/components/</code>: other components you create.</li>
    </ul>
    <br/><br/>



    <li><b>main.js: Creating and Mounting the Application</b></li>
    <br/>
    <ul>
        <li>The <code>main.js</code> file usually looks like this:</li>
    </ul>

<pre><code class="language-js line-numbers">import { createApp } from "vue"
import App from "./App.vue"

const app = createApp(App)

// here you can also use plugins, router, store, etc.
// e.g. app.use(router)

app.mount("#app")
</code></pre>
    <ul>
        <li>Here you:
            <ul>
                <li>import the root component <code>App</code></li>
                <li>create the application instance with <code>createApp(App)</code></li>
                <li>mount it to the DOM element with id <code>app</code> (defined in <code>index.html</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>index.html: The Mount Point</b></li>
<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;My Vue App&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;!-- Vite will inject the compiled JS here --&gt;
        &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <ul>
        <li>The <code>&lt;div id="app"&gt;</code> is the “root” of your Vue application.</li>
        <li>Everything your Vue app renders will appear inside this element.</li>
    </ul>
    <br/><br/>



    <li><b>App.vue: Root Component with Composition API</b></li>
    <br/>
    <ul>
        <li><code>App.vue</code> is a Single File Component (SFC) with three main sections:</li>
        <ul>
            <li><code>&lt;template&gt;</code>: HTML markup</li>
            <li><code>&lt;script&gt;</code> (or <code>&lt;script setup&gt;</code>): logic</li>
            <li><code>&lt;style&gt;</code>: CSS</li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;main&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;button @click="count++"&gt;
            Clicked {{ count }} times
        &lt;/button&gt;
    &lt;/main&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("My First Vue App")
const count = ref(0)
&lt;/script&gt;

&lt;style&gt;
main {
    font-family: system-ui, sans-serif;
}
button {
    margin-top: 1rem;
}
&lt;/style&gt;
</code></pre>
    <ul>
        <li>Using <code>&lt;script setup&gt;</code> is the recommended Vue 3 style:
            <ul>
                <li>No need to explicitly write <code>export default</code>.</li>
                <li>All top-level variables are automatically exposed to the template.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Adding Another Component</b></li>
    <br/>
    <ul>
        <li>Create a component in <code>src/components/Counter.vue</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;Local count: {{ count }}&lt;/p&gt;
        &lt;button @click="count++"&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count = ref(0)
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Then import and use it in <code>App.vue</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;main&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;Counter /&gt;
    &lt;/main&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"
import Counter from "./components/Counter.vue"

const title = ref("My Vue App")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Development vs Production</b></li>
    <br/>
    <ul>
        <li>During development, you run a dev server:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm run dev
</code></pre>

    <br/>
    <ul>
        <li>For production, you build static files:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm run build
npm run preview   # optional: preview the production build locally
</code></pre>
    <ul>
        <li>The build output (usually in <code>dist/</code>) can be deployed to any static file server.</li>
    </ul>
    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Step</th>
                <th>What Happens</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Create project</td>
                <td>Use <code>npm create vue@latest</code> to scaffold a Vue 3 app</td>
            </tr>
            <tr>
                <td>Entry file</td>
                <td><code>main.js</code> imports <code>App.vue</code> and calls <code>createApp(App).mount("#app")</code></td>
            </tr>
            <tr>
                <td>Root component</td>
                <td><code>App.vue</code> defined using Composition API (<code>&lt;script setup&gt;</code>, <code>ref()</code>)</td>
            </tr>
            <tr>
                <td>DOM mount point</td>
                <td><code>&lt;div id="app"&gt;</code> in <code>index.html</code></td>
            </tr>
            <tr>
                <td>Components</td>
                <td>More components go into <code>src/components/</code> and are imported into <code>App.vue</code> or others</td>
            </tr>
            <tr>
                <td>Dev server</td>
                <td><code>npm run dev</code> for live reload while coding</td>
            </tr>
            <tr>
                <td>Production build</td>
                <td><code>npm run build</code> to create optimized static files</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-template-syntax">Template Syntax in Vue</h3>
<ol>
    <li><b>What Is the Template?</b></li>
    <br/>
    <ul>
        <li>In Vue, a <code>template</code> is the HTML-like part of your component that describes what should be rendered.</li>
        <br/>
        <li>With the Composition API, you usually write templates in <code>.vue</code> Single File Components:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("Hello from Vue")
const count = ref(0)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Everything you define in <code>&lt;script setup&gt;</code> is directly usable inside the template (no <code>this</code> keyword).</li>
    </ul>

    <br/><br/>



    <li><b>Text Interpolation with <code>{{ }}</code> (Just like in Angular)</b></li>
    <br/>
    <ul>
        <li>The most basic template feature is <u>interpolation</u> using double curly braces.</li>
        <li>It displays the value of a JavaScript expression as text.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("Welcome")
const name = ref("User")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You can only put one <u>expression</u> inside <code>{{ }}</code>, not full statements or <code>if</code> / <code>for</code> blocks.</li>
    </ul>

    <br/><br/>



    <li><b>Using Simple JavaScript Expressions</b></li>
    <br/>
    <ul>
        <li>You can use simple JS expressions inside <code>{{ }}</code>:</li>
        <ul>
            <li>arithmetic: <code>{{ count + 1 }}</code></li>
            <li>string operations: <code>{{ firstName + " " + lastName }}</code></li>
            <li>ternary: <code>{{ isAdmin ? "Admin" : "User" }}</code></li>
            <li>function calls: <code>{{ formatName(user) }}</code></li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p&gt;Next: {{ count + 1 }}&lt;/p&gt;
    &lt;p&gt;Full name: {{ firstName + " " + lastName }}&lt;/p&gt;
    &lt;p&gt;Role: {{ isAdmin ? "Admin" : "User" }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count     = ref(1)
const firstName = ref("Junzhe")
const lastName  = ref("Hwangfu")
const isAdmin   = ref(false)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Raw HTML with <code>v-html</code> (Be Careful)</b></li>
    <br/>
    <ul>
        <li>By default, <code>{{ }}</code> escapes HTML (e.g., <code>&gt;</code> automatically becomes <code>&amp;gt;</code>) for safety.</li>
        <li>If you really need to render HTML from a string, use <code>v-html</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p&gt;Normal: {{ rawHtml }}&lt;/p&gt;
    &lt;p v-html="rawHtml"&gt;&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
const rawHtml = "&lt;strong&gt;This is bold&lt;/strong&gt;"
&lt;/script&gt;
</code></pre>

    <ul>
        <li><b>WARN:</b> Never use <code>v-html</code> with untrusted user input. It can cause XSS security problems.</li>
    </ul>

    <br/><br/>



    <li><b>Attribute Binding with <code>v-bind:</code> / <code>:</code></b></li>
    <br/>
    <ul>
        <li>Use <code>v-bind:</code> to bind an attribute to a JS expression.</li>
        <li>Short form is a single colon (<code>:</code>).</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;a :href="profileUrl"&gt;Go to profile&lt;/a&gt;
    &lt;img :src="avatarUrl" :alt="username" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
const profileUrl = "https://example.com/user/hwangfu"
const avatarUrl  = "/images/avatar.png"
const username   = "Hwangfu"
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You can even bind to boolean attributes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;button :disabled="isLoading"&gt;
    {{ isLoading ? "Loading..." : "Submit" }}
&lt;/button&gt;
</code></pre>

    <br/><br/>


    <li><b>Binding <code>class</code> and <code>style</code></b></li>
    <br/>
    <ul>
        <li>Vue makes dynamic classes and styles very convenient.</li>
        <li>You can bind strings, objects, or arrays, but Vue always converts them into normal HTML.</li>
        <li>When using an object, the <u>keys</u> are class/style names and the <u>values</u> are booleans or expressions.</li>
        <li>Vue builds the final <code>class=""</code> or <code>style=""</code> string automatically.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;!-- Dynamic classes --
         Vue evaluates the object and produces a normal class string.
         With isActive=true and hasError=false, the final HTML becomes:
         &lt;p class="active"&gt;
    --&gt;
    &lt;p :class="{ active: isActive, error: hasError }"&gt;
        Status text
    &lt;/p&gt;

    &lt;!-- Dynamic inline styles --
         Vue converts the object to a real style attribute:
         style="color: blue; font-size: 18px;"
    --&gt;
    &lt;div :style="{ color: textColor, fontSize: size + 'px' }"&gt;
        Styled text
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const isActive  = ref(true)
const hasError  = ref(false)

const textColor = ref("blue")
const size      = ref(18)
&lt;/script&gt;
</code></pre>

    <br/><br/>




    <li><b>Conditional Rendering: <code>v-if</code>, <code>v-else-if</code>, <code>v-else</code>, <code>v-show</code></b></li>
    <br/>
    <ul>
        <li><code>v-if</code> actually adds/removes elements from the DOM.</li>
        <li><code>v-show</code> toggles the <code>display</code> CSS property (faster when toggling often).</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p v-if="loggedIn"&gt;Welcome back!&lt;/p&gt;
    &lt;p v-else&gt;Please log in.&lt;/p&gt;

    &lt;p v-show="showDetails"&gt;
        These details can be quickly shown/hidden.
    &lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const loggedIn    = ref(false)
const showDetails = ref(true)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>List Rendering with <code>v-for</code> and <code>key</code></b></li>
    <br/>
    <ul>
        <li><code>v-for</code> renders a list by iterating over arrays or objects.</li>
        <li>Always provide a unique <code>:key</code> for better performance and stable updates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="user in users" :key="user.id"&gt;
            {{ user.name }} ({{ user.age }})
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup&gt;
const users = [
    { id: 1, name: "Alice", age: 23 },
    { id: 2, name: "Bob", age: 31 },
    { id: 3, name: "Charlie", age: 27 }
]
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Event Handling with <code>v-on:</code> / <code>@</code></b></li>
    <br/>
    <ul>
        <li>Use <code>v-on:</code> (or <code>@</code>) to listen to DOM events.</li>
        <li>You can call methods or inline expressions.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;button @click="increment"&gt;
        Clicked {{ count }} times
    &lt;/button&gt;

    &lt;input
        type="text"
        placeholder="Type something"
        @input="onInput"
    /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count = ref(0)

function increment() {
    count.value++
}

function onInput(event) {
    console.log("You typed:", event.target.value)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Two-Way Binding with <code>v-model</code> (Quick Overview)</b></li>
    <br/>
    <ul>
        <li><code>v-model</code> connects a <b>form input</b> with a reactive value in both directions.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input v-model="name" placeholder="Your name" /&gt;
    &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const name = ref("")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Typing in the input updates <code>name</code>, and changing <code>name</code> in code updates the input.</li>
    </ul>

    <br/><br/>



    <li><b>Directive Shorthands (Cheat Sheet)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Full Form</th>
                <th>Shorthand</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>v-bind:href="url"</code></td>
                <td><code>:href="url"</code></td>
                <td>Bind an attribute to an expression</td>
            </tr>
            <tr>
                <td><code>v-on:click="doSomething"</code></td>
                <td><code>@click="doSomething"</code></td>
                <td>Listen to an event</td>
            </tr>
            <tr>
                <td><code>v-model="value"</code></td>
                <td>none</td>
                <td>Two-way binding</td>
            </tr>
            <tr>
                <td><code>v-if="condition"</code></td>
                <td>none</td>
                <td>Conditional rendering</td>
            </tr>
            <tr>
                <td><code>v-for="item in items"</code></td>
                <td>none</td>
                <td>List rendering</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-watchers">Watchers in Vue (Composition API)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>watcher</code> in Vue lets you run code in response to changes in reactive values.</li>
        <br/>
        <li>Watchers are useful when you need to perform <u>side effects</u> such as:
            <ul>
                <li>fetching data when a value changes</li>
                <li>saving values to localStorage</li>
                <li>debouncing expensive operations</li>
                <li>logging or debugging</li>
            </ul>
        </li>
        <br/>
        <li>In the Composition API, watchers are created using:
            <ul>
                <li><code>watch()</code></li>
                <li><code>watchEffect()</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>watch(): Watching Specific Reactive Sources</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> tracks one or more <u>explicit</u> reactive values and calls a callback when they change.</li>
        <li>It provides both the <code>new</code> and <code>old</code> values.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

const name = ref("")

watch(name, (newValue, oldValue) =&gt; {
    console.log("Changed:", oldValue, "--&gt;", newValue)
})
</code></pre>

    <ul>
        <li>The callback only runs when <code>name</code> changes.</li>
    </ul>

    <br/><br/>



    <li><b>Watching Multiple Sources</b></li>
    <br/>
    <ul>
        <li>You can watch several values by passing an array.</li>
    </ul>

<pre><code class="language-js line-numbers">const first = ref("")
const last  = ref("")

watch([first, last], ([newFirst, newLast], [oldFirst, oldLast]) =&gt; {
    console.log("First:", oldFirst, "--&gt;", newFirst)
    console.log("Last:", oldLast, "--&gt;", newLast)
})
</code></pre>

    <br/><br/>



    <li><b>Watching Reactive Objects</b></li>
    <br/>
    <ul>
        <li>When watching a <code>reactive()</code> object, Vue only tracks changes if you set <code>{ deep: true }</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive, watch } from "vue"

const user = reactive({
    name: "Alice",
    age: 25
})

watch(user, (newVal, oldVal) =&gt; {
    console.log("User changed!")
}, { deep: true })
</code></pre>

    <ul>
        <li><b>NOTE:</b> For objects, Vue <u>cannot</u> give meaningful <code>oldValue</code> because the object is mutated.</li>
    </ul>

    <br/><br/>



    <li><b>Watching a Getter Function</b></li>
    <br/>
    <ul>
        <li>Often you want to watch <u>one part</u> of a reactive object.</li>
        <li>You can pass a function that returns the value you want to track.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(
    () =&gt; user.age,
    (newAge, oldAge) =&gt; {
        console.log("Age changed:", oldAge, "--&gt;", newAge)
    }
)
</code></pre>

    <br/><br/>


    <li><b>Immediate Watchers</b></li>
    <br/>
    <ul>
        <li>Normally, a watcher runs only when the watched value <u>changes</u>.</li>
        <li><code>{ immediate: true }</code>
            tells Vue to run the watcher callback immediately once when the watcher is <u>created</u>,
            even before any changes happen, using the current value of the watched ref.
        </li>
        <li>After that first run, it continues watching as usual.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(
    count,
    (newVal, oldVal) =&gt; {
        console.log("Watcher triggered:", newVal)
    },
    {
        // Run once immediately with the current value
        immediate: true
    }
)
</code></pre>

    <br/><br/>




    <li><b>watchEffect(): Automatic Dependency Tracking</b></li>
    <br/>
    <ul>
        <li><code>watchEffect()</code> runs a function immediately and re-runs it whenever <u>any</u> reactive value inside it changes.</li>
        <li>You do NOT specify what to watch, Vue figures it out.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watchEffect } from "vue"

const count = ref(0)

watchEffect(() =&gt; {
    console.log("Count is", count.value)
})
</code></pre>

    <ul>
        <li>Great for debugging or when watching several related values.</li>
    </ul>

    <br/><br/>



    <li><b>watch vs watchEffect (Comparison)</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>watch()</th>
                <th>watchEffect()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Tracks values</td>
                <td>Explicitly listed values</td>
                <td>Automatically detects dependencies</td>
            </tr>
            <tr>
                <td>First run</td>
                <td>Only when changed (unless <code>immediate</code>)</td>
                <td>Runs immediately</td>
            </tr>
            <tr>
                <td>Best for</td>
                <td>side effects on specific values</td>
                <td>complex reactive logic, debugging</td>
            </tr>
            <tr>
                <td>Old value available?</td>
                <td>Yes (for refs)</td>
                <td>No</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Cleanup (Stopping Watchers)</b></li>
    <br/>
    <ul>
        <li>Both <code>watch()</code> and <code>watchEffect()</code> return a function that stops the watcher.</li>
    </ul>

<pre><code class="language-js line-numbers">const stop = watch(count, () =&gt; {
    console.log("count changed")
})

// Later:
stop()
</code></pre>

    <br/><br/>



    <li><b>Practical Example: Fetching from an API</b></li>
    <br/>
    <ul>
        <li>A very common real use-case is fetching data when a reactive value changes.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

const search = ref("")
const results = ref([])

watch(search, async (term) =&gt; {
    if (term.length &lt; 3) {
        results.value = []
        return
    }

    const res = await fetch(`/api/search?q=${term}`)
    results.value = await res.json()
})
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>watch()</code></td>
                <td>Tracks specific reactive values and gives access to old/new values</td>
            </tr>
            <tr>
                <td><code>watchEffect()</code></td>
                <td>Runs immediately and re-runs whenever any dependency changes</td>
            </tr>
            <tr>
                <td>Deep watch</td>
                <td>Needed to observe changes inside reactive objects</td>
            </tr>
            <tr>
                <td>Immediate</td>
                <td>Runs watcher callback right away on initialization</td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Side effects such as data fetching, logging, reacting to changes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-template-refs">Template Refs in Vue</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Template refs</u> allow you to directly access DOM elements or component instances from your JavaScript code.</li>
        <li>They are useful when:
            <ul>
                <li>you need to manually focus an input</li>
                <li>you must measure elements (height/width)</li>
                <li>you interact with a canvas or third-party library</li>
                <li>you need access to a child component's exposed API</li>
            </ul>
        </li>
        <br/>
        <li>Template refs work naturally with the <b>Composition API</b> using <code>ref()</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Example: Referencing a DOM Element</b></li>
    <br/>
    <ul>
        <li>Use <code>ref=""</code> inside the template to mark an element.</li>
        <li>Inside <code>&lt;script setup&gt;</code>, create a <code>ref()</code> with the same name.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input ref="inputEl" placeholder="Type here..." /&gt;
    &lt;button @click="focusInput"&gt;Focus input&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const inputEl = ref(null)

function focusInput() {
    inputEl.value.focus()
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>inputEl.value</code> becomes the actual DOM element after the component mounts.</li>
        <li>Before mount, <code>inputEl.value</code> is <code>null</code>.</li>
    </ul>

    <br/><br/>



    <li><b>When Is the Template Ref Available?</b></li>
    <br/>
    <ul>
        <li>Refs are only set after the component is mounted.</li>
        <li>To run code immediately after mounting, use <code>onMounted()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, onMounted } from "vue"

const box = ref(null)

onMounted(() =&gt; {
    console.log("Box height:", box.value.offsetHeight)
})
</code></pre>

    <br/><br/>



    <li><b>Template Refs with Components</b></li>
    <br/>
    <ul>
        <li>You can also reference child components, not just DOM elements.</li>
        <li>A child component must explicitly <u>expose</u> what it wants the parent to access.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Child ref="childComp" /&gt;
    &lt;button @click="childComp.increment"&gt;Call child method&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"
import Child from "./Child.vue"

const childComp = ref(null)
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;script setup&gt;
import { ref } from "vue"
import { defineExpose } from "vue"

const count = ref(0)
function increment() { count.value++ }

defineExpose({
    count,
    increment
})
&lt;/script&gt;

&lt;template&gt;
    &lt;p&gt;{{ count }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li><code>defineExpose()</code> is required to make component methods/state available via refs.</li>
        <li>Otherwise the parent cannot access them.</li>
    </ul>

    <br/><br/>



    <li><b>Binding Refs in <code>v-for</code></b></li>
    <br/>
    <ul>
        <li>A common use-case: getting references to multiple elements.</li>
        <li>Vue automatically gives you an array or an object depending on how you bind the ref.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;ul&gt;
        &lt;li
            v-for="(user, index) in users"
            :key="user.id"
            :ref="setItemRef"
        &gt;
            {{ user.name }}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
]

const itemRefs = ref([])

function setItemRef(el) {
    if (el) itemRefs.value.push(el)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Now <code>itemRefs.value</code> is an array of DOM elements.</li>
    </ul>

    <br/><br/>



    <li><b>Using <code>template ref</code> for Non-DOM Purposes</b></li>
    <br/>
    <ul>
        <li>You can store anything in a ref assigned via the template.</li>
        <li>Example: Registering canvas contexts, chart instances, editors, etc.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;canvas ref="canvas" width="200" height="200"&gt;&lt;/canvas&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from "vue"

const canvas = ref(null)

onMounted(() =&gt; {
    const ctx = canvas.value.getContext("2d")
    ctx.fillRect(10, 10, 100, 100)
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Template Ref Caveats</b></li>
    <br/>
    <ul>
        <li><b>Refs do not exist until after mount</b> → use <code>onMounted()</code>.</li>
        <li>Refs pointing to components only work if the child uses <code>defineExpose()</code>.</li>
        <li>Do not overuse refs: rely on Vue’s reactivity first.</li>
        <li>Refs are for when "declarative DOM binding" isn't enough.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>DOM refs</td>
                <td>Use <code>ref="..."</code> to access DOM elements directly</td>
            </tr>
            <tr>
                <td>Component refs</td>
                <td>Require <code>defineExpose()</code> in the child component</td>
            </tr>
            <tr>
                <td>When available</td>
                <td>After mount — use <code>onMounted()</code></td>
            </tr>
            <tr>
                <td>v-for refs</td>
                <td>Bind a function as <code>:ref</code> to collect multiple elements</td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Focus, measurements, canvas, third-party libraries</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-typescript">Using Vue with TypeScript (Vue 3 + Composition API)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue 3 has first-class TypeScript support, especially with the Composition API.</li>
        <br/>
        <li>Vue 3's <code>&lt;script setup lang="ts"&gt;</code> syntax is the recommended way to use TypeScript.</li>
    </ul>

    <br/><br/>



    <li><b>Enabling TypeScript in a Vue SFC</b></li>
    <br/>
    <ul>
        <li>To use TypeScript inside a component, simply add <code>lang="ts"</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const message = ref("Hello TypeScript")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Vue + Vite will automatically compile the TypeScript for you. No extra setup needed.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Refs</b></li>
    <br/>
    <ul>
        <li>By default, <code>ref()</code> infers the type from the initial value.</li>
    </ul>

<pre><code class="language-ts line-numbers">const count = ref(0)          // ref&lt;number&gt;
const username = ref("Alice") // ref&lt;string&gt;
</code></pre>

    <ul>
        <li>If you want to explicitly provide a type, pass a generic:</li>
    </ul>

<pre><code class="language-ts line-numbers">const age = ref&lt;number | null&gt;(null)
</code></pre>

    <br/><br/>



    <li><b>Typing Reactive Objects</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> works well with object types.</li>
    </ul>

<pre><code class="language-ts line-numbers">interface User {
    name: string
    age: number
}

const user = reactive&lt;User&gt;({
    name: "Hwangfu",
    age: 22
})
</code></pre>

    <ul>
        <li>All properties inside the reactive object have proper types.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Functions Inside Components</b></li>
    <br/>
    <ul>
        <li>Just use normal TypeScript syntax.</li>
    </ul>

<pre><code class="language-ts line-numbers">function greet(name: string): string {
    return "Hello, " + name
}
</code></pre>

    <br/><br/>



    <li><b>Typing Computed Properties</b></li>
    <br/>
    <ul>
        <li>Types are inferred automatically in most cases.</li>
    </ul>

<pre><code class="language-ts line-numbers">const count = ref(2)

const double = computed(() =&gt; count.value * 2)
// computed&lt;number&gt;
</code></pre>

    <br/>
    <ul>
        <li>You can force a type if needed:</li>
    </ul>

<pre><code class="language-ts line-numbers">const price = ref(10)

const withTax = computed&lt;number&gt;(() =&gt; price.value * 1.19)
</code></pre>

    <br/><br/>



    <li><b>Typing Props (with <code>&lt;script setup&gt;</code>)</b></li>
    <br/>
    <ul>
        <li>Props are typed using <code>defineProps&lt;&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
interface Props {
    title: string
    count?: number
}

const props = defineProps&lt;Props&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;h1&gt;{{ props.title }}&lt;/h1&gt;
    &lt;p&gt;Count: {{ props.count ?? 0 }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>Props now get full type-checking and IDE hints.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Emits</b></li>
    <br/>
    <ul>
        <li>Use <code>defineEmits&lt;&gt;</code> to type event signatures.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const emit = defineEmits&lt;{
    (event: "update", value: number): void
}&gt;()

emit("update", 42) // ✔️
emit("update")     // ❌ type error
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Template Refs</b></li>
    <br/>
    <ul>
        <li>You must annotate the type of the DOM element.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input ref="inputEl" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue"

const inputEl = ref&lt;HTMLInputElement | null&gt;(null)

onMounted(() =&gt; {
    inputEl.value?.focus()
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Composables</b></li>
    <br/>
    <ul>
        <li>When writing reusable functions, add proper types to arguments and returns.</li>
    </ul>

<pre><code class="language-ts line-numbers">// useCounter.ts
import { ref } from "vue"

export function useCounter(initial = 0) {
    const count = ref(initial)

    function increment(): void {
        count.value++
    }

    return { count, increment }
}
</code></pre>

    <ul>
        <li>Now all components using this composable will have typed reactive values.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Events in the Template</b></li>
    <br/>
    <ul>
        <li>Vue automatically infers the event type for DOM events.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input @input="onInput" /&gt;

&lt;script setup lang="ts"&gt;
function onInput(event: Event) {
    const target = event.target as HTMLInputElement
    console.log(target.value)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Type Safety with <code>defineModel()</code> (Vue 3.4+)</b></li>
    <br/>
    <ul>
        <li>For custom <code>v-model</code>, you can type the value:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const modelValue = defineModel&lt;string&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;input v-model="modelValue" /&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>Recommended Project Setup</b></li>
    <br/>
    <ul>
        <li>Use the official TS template:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm create vue@latest
# choose: Typescript + JSX support (optional)
</code></pre>

    <ul>
        <li>This sets up:
            <ul>
                <li><code>tsconfig.json</code></li>
                <li>full IDE support</li>
                <li>recommended type definitions</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>TypeScript Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Typing refs</td>
                <td><code>ref&lt;T&gt;(initial)</code></td>
            </tr>
            <tr>
                <td>Reactive objects</td>
                <td><code>reactive&lt;Interface&gt;({ ... })</code></td>
            </tr>
            <tr>
                <td>Props</td>
                <td><code>defineProps&lt;Props&gt;()</code></td>
            </tr>
            <tr>
                <td>Emits</td>
                <td><code>defineEmits&lt;Signatures&gt;()</code></td>
            </tr>
            <tr>
                <td>Template refs</td>
                <td><code>ref&lt;ElementType | null&gt;(null)</code></td>
            </tr>
            <tr>
                <td>Computed</td>
                <td>auto inferred or <code>computed&lt;T&gt;()</code></td>
            </tr>
            <tr>
                <td>Composables</td>
                <td>write typed functions returning reactive state</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-components-basics">Components Basics in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Components are the building blocks of every Vue application.</li>
        <br/>
        <li>Each component represents an independent, reusable piece of UI combined with logic.</li>
        <br/>
        <li>Every component typically contains:
            <ul>
                <li>a <code>template</code>: how the UI looks</li>
                <li>a <code>script</code>: data + logic</li>
                <li>(optional) <code>style</code> — CSS</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Your First Component</b></li>
    <br/>
    <ul>
        <li>A component lives in its own <code>.vue</code> file (Single-File Component).</li>
        <li>Below is a minimal, fully typed component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Hello.vue --&gt;
&lt;template&gt;
    &lt;h2&gt;Hello, {{ name }}!&lt;/h2&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { defineProps } from "vue";

const props = defineProps&lt;{
    name: string
}&gt;();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The <code>name</code> value is passed from the parent component.</li>
    </ul>

    <br/><br/>



    <li><b>Using a Component</b></li>
    <br/>
    <ul>
        <li>Import and register components simply by importing them in <code>&lt;script setup&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Hello name="Junzhe" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Hello from "./components/Hello.vue";
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You do not need <code>components: { ... }</code>. Importing is enough.</li>
    </ul>

    <br/><br/>



    <li><b>Props: Passing Data into Components</b></li>
    <br/>
    <ul>
        <li>Props are the primary way to pass data from parent to child.</li>
        <li>Props are fully type-checked using <code>defineProps&lt;T&gt;()</code>.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    title:  string;
    count?: number;     // optional
}&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;h3&gt;{{ title }}&lt;/h3&gt;
    &lt;p&gt;Count: {{ count ?? 0 }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>TypeScript ensures that the parent provides correct prop types.</li>
    </ul>

    <br/><br/>



    <li><b>Emits: Sending Data from Child to Parent</b></li>
    <br/>
    <ul>
        <li>Child components can send events upward using <code>defineEmits</code>.</li>
        <li>TypeScript ensures event names and payloads are correct.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.vue --&gt;
&lt;template&gt;
    &lt;button @click="increment"&gt;Count is {{ count }}&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, defineEmits } from "vue";

const emit = defineEmits&lt;{
    (e: "update:count", value: number): void;
}&gt;()

const count = ref(0);

function increment() {
    count.value++;
    emit("update:count", count.value);
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Counter @update:count="val =&gt; total = val" /&gt;
    &lt;p&gt;Latest count from child: {{ total }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue";
import Counter from "./Counter.vue";

const total = ref(0);
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Highly predictable, type-safe event communication.</li>
    </ul>

    <br/><br/>



    <li><b>Component Slots: Passing Content into Children</b></li>
    <br/>
    <ul>
        <li><b>Slots</b> let parents inject custom content into children.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Card.vue --&gt;
&lt;template&gt;
    &lt;div class="card"&gt;
        &lt;slot /&gt; &lt;!-- default slot --&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Card&gt;
        &lt;p&gt;This is inside the card!&lt;/p&gt;
    &lt;/Card&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Card from "./Card.vue";
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Slots allow components to remain flexible and reusable.</li>
    </ul>

    <br/><br/>



    <li><b>Named Slots</b></li>
    <br/>
    <ul>
        <li>Named slots allow placing content into specific regions.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Layout.vue --&gt;
&lt;template&gt;
    &lt;header&gt;
        &lt;slot name="header"/&gt;
    &lt;/header&gt;

    &lt;main&gt;
        &lt;slot/&gt;
    &lt;/main&gt;

    &lt;footer&gt;
        &lt;slot name="footer"/&gt;
    &lt;/footer&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Layout&gt;
        &lt;template #header&gt;Header content&lt;/template&gt;
        Main area content
        &lt;template #footer&gt;Footer content&lt;/template&gt;
    &lt;/Layout&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Layout from "./Layout.vue"
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Component Naming Conventions</b></li>
    <br/>
    <ul>
        <li>Best practices:
            <ul>
                <li>Use PascalCase for component filenames: <code>UserCard.vue</code></li>
                <li>Use PascalCase or kebab-case in templates:
                    <ul>
                        <li><code>&lt;UserCard /&gt;</code></li>
                        <li><code>&lt;user-card /&gt;</code></li>
                    </ul>
                </li>
                <li>Keep components small &amp; focused</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Reusable Component Pattern (Full Example)</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Button.vue --&gt;
&lt;template&gt;
    &lt;button :class="variant" @click="onClick"&gt;
        &lt;slot /&gt;
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    variant?: "primary" | "secondary"
}&gt;()

const emit = defineEmits&lt;{
    (e: "click"): void
}&gt;()

function onClick() {
    emit("click")
}
&lt;/script&gt;

&lt;style scoped&gt;
.primary { padding: 6px; background: #3b82f6; color: white; }
.secondary { padding: 6px; background: #e5e7eb; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Button variant="primary" @click="sayHi"&gt;Say Hi&lt;/Button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Button from "./components/Button.vue"

function sayHi() {
    alert("Hello from Vue!")
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Creating components</td>
                <td>Use <code>.vue</code> SFC files with <code>&lt;script setup lang="ts"&gt;</code></td>
            </tr>
            <tr>
                <td>Props</td>
                <td>Typed via <code>defineProps&lt;T&gt;()</code> for safe inputs</td>
            </tr>
            <tr>
                <td>Emits</td>
                <td>Typed events via <code>defineEmits&lt;Signature&gt;()</code></td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Components are imported and used directly in parent templates</td>
            </tr>
            <tr>
                <td>Slots</td>
                <td>Allow flexible insertion of content</td>
            </tr>
            <tr>
                <td>Composition API + TS</td>
                <td>Provides best developer experience &amp; type safety</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-component-registration">Component Registration in Vue (Global & Local)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Component registration determines <u>where</u> a component can be used inside your app.</li>
        <br/>
        <li>Vue 3 supports:
            <ul>
                <li><code>Local Registration</code>: component usable only in the importing component</li>
                <li><code>Global Registration</code>: component usable everywhere in the app</li>
            </ul>
        </li>
        <br/>
        <li>When using <code>&lt;script setup&gt;</code> and TypeScript, registration is very simple.</li>
        <br/>
        <li>Because of tree-shaking and clarity, <u>local registration</u> is recommended for most situations.</li>
    </ul>

    <br/><br/>



    <li><b>Local Registration (Recommended)</b></li>
    <br/>
    <ul>
        <li>In <code>&lt;script setup&gt;</code>, simply <b>import</b> a component and <b>use it directly</b> in your template.</li>
        <li>No need to manually add a <code>components: { ... }</code> section.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;UserCard name="Junzhe" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import UserCard from "./UserCard.vue"
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The imported component <code>UserCard</code> is automatically available in the template.</li>
        <li>This is the most common and cleanest pattern in Vue 3.</li>
    </ul>

    <br/><br/>



    <li><b>Local Registration in Old Syntax (Not Needed with &lt;script setup&gt;)</b></li>
    <br/>
    <ul>
        <li>You may see older Vue 2 / early Vue 3 syntax:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script lang="ts"&gt;
import { defineComponent } from "vue";
import UserCard from "./UserCard.vue";

export default defineComponent({
    components: {
        UserCard
    }
})
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You should only use this when not using <code>&lt;script setup&gt;</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Global Registration</b></li>
    <br/>
    <ul>
        <li>Global registration allows you to use a component in <b>any template</b> without importing it.</li>
        <li>This is useful for:
            <ul>
                <li>very common UI elements (Button, Card, Modal)</li>
                <li>global utilities (Icon component)</li>
                <li>documentation/markdown rendering tools</li>
            </ul>
        </li>
        <br/>
        <li>You register global components in your app entry file (<code>main.ts</code> or <code>main.js</code>).</li>
    </ul>

<pre><code class="language-ts line-numbers">import { createApp } from "vue";
import App from "./App.vue";

import BaseButton from "./components/BaseButton.vue";
import BaseCard   from "./components/BaseCard.vue"  ;

const app = createApp(App);

// global registration
app.component("BaseButton", BaseButton);
app.component("BaseCard", BaseCard);

app.mount("#app");
</code></pre>

    <ul>
        <li>Now <code>&lt;BaseButton&gt;</code> and <code>&lt;BaseCard&gt;</code> can be used anywhere in the project.</li>
    </ul>

    <br/><br/>


    <li><b>Automatic Global Registration (Optional)</b></li>
    <br/>
    <ul>
        <li>You can auto-load components using Vite's <code>import.meta.glob()</code> feature.</li>
        <li>This is a powerful trick for large UI libraries.</li>
    </ul>

<pre><code class="language-ts line-numbers">const components = import.meta.glob("./components/global/*.vue", { eager: true })

for (const path in components) {
    const comp = components[path]
    const name = path.split("/").pop()!.replace(".vue", "")
    app.component(name, (comp as any).default)
}
</code></pre>

    <ul>
        <li>Every <code>.vue</code> file inside <code>components/global/</code> is registered automatically.</li>
        <li>Frameworks like Nuxt internally use similar techniques.</li>
    </ul>

    <br/><br/>


    <li><b>Local vs Global Registration (Quick Comparison)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Local Registration</th>
                <th>Global Registration</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Scope</td>
                <td>Only usable inside the importing component</td>
                <td>Usable everywhere in the app</td>
            </tr>
            <tr>
                <td>Recommended?</td>
                <td><b>Yes</b> for most components</td>
                <td>Yes for common UI elements</td>
            </tr>
            <tr>
                <td>Tree-shaking</td>
                <td>Excellent</td>
                <td>Potentially worse (less dead-code elimination)</td>
            </tr>
            <tr>
                <td>Setup style</td>
                <td>Use <code>&lt;script setup&gt;</code> import</td>
                <td>Register in <code>main.ts</code></td>
            </tr>
            <tr>
                <td>Best use-case</td>
                <td>Pages, logic-specific components</td>
                <td>Buttons, form fields, layouts, icons</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Local registration</td>
                <td>Import in <code>&lt;script setup&gt;</code> → immediately available</td>
            </tr>
            <tr>
                <td>Global registration</td>
                <td>Register with <code>app.component()</code> in <code>main.ts</code></td>
            </tr>
            <tr>
                <td>Recommended pattern</td>
                <td>Use local registration for most components</td>
            </tr>
            <tr>
                <td>Global usage</td>
                <td>Use for shared UI primitives (buttons, cards, icons)</td>
            </tr>
            <tr>
                <td>Automatic loading</td>
                <td>Possible using <code>import.meta.glob()</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-props">Props in Vue (Typed Props Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Props are how a parent component passes data to a child component.</li>
        <li>Props are <u>read-only</u> inside the child — they cannot be mutated directly.</li>
        <li>You declare props using <code>defineProps&lt;T&gt;</code> and a TypeScript interface.</li>
    </ul>

    <br/><br/>



    <li><b>Defining Typed Props</b></li>
    <br/>
    <ul>
        <li>You define props using <code>defineProps</code> in <code>&lt;script setup lang="ts"&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- UserCard.vue --&gt;
&lt;template&gt;
    &lt;h2&gt;{{ name }}&lt;/h2&gt;
    &lt;p&gt;Age: {{ age }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
interface Props {
    name: string
    age: number
}

const props = defineProps&lt;Props&gt;()
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Props are fully type-checked.</li>
        <li>IDE autocompletion works automatically.</li>
    </ul>

    <br/><br/>



    <li><b>Passing Props from a Parent Component</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;!--
        Without `:` → the value is a plain string
        With    `:` → the value is a JavaScript expression
    --&gt;
    &lt;UserCard name="Junzhe" :age="22" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import UserCard from "./UserCard.vue"
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Optional Props</b></li>
    <br/>
    <ul>
        <li>Optional props are typed with <code>?</code>.</li>
    </ul>

<pre><code class="language-ts line-numbers">const props = defineProps&lt;{
    title: string
    subtitle?: string
}&gt;()
</code></pre>

    <ul>
        <li>Vue and TypeScript ensure the parent does not forget required props.</li>
    </ul>

    <br/><br/>



    <li><b>Props with Default Values</b></li>
    <br/>
    <ul>
        <li>To provide default values, use <code>withDefaults()</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
const props = withDefaults(
    defineProps&lt;{
        size?: "sm" | "md" | "lg"
        label: string
    }&gt;(),
    {
        size: "md"
    }
)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>TypeScript now treats <code>size</code> as always defined.</li>
    </ul>

    <br/><br/>



    <li><b>Union Types for Props</b></li>
    <br/>
    <ul>
        <li>Union types allow flexible but safe prop values.</li>
    </ul>

<pre><code class="language-ts line-numbers">const props = defineProps&lt;{
    status: "success" | "warning" | "error"
}&gt;()
</code></pre>

    <ul>
        <li>Parents must provide one of the allowed strings.</li>
    </ul>

    <br/><br/>



    <li><b>Props with Complex Types</b></li>
    <br/>
    <ul>
        <li>You can pass objects, arrays, or custom interfaces as props.</li>
    </ul>

<pre><code class="language-ts line-numbers">interface User {
    id: number
    name: string
    email: string
}

const props = defineProps&lt;{
    user: User
    tags: string[]
}&gt;()
</code></pre>

    <ul>
        <li>Vue handles reactivity automatically for these values.</li>
    </ul>

    <br/><br/>



    <li><b>Readonly Behavior of Props</b></li>
    <br/>
    <ul>
        <li>Props cannot be mutated directly.</li>
        <li>The following will throw a warning:</li>
    </ul>

<pre><code class="language-ts line-numbers">props.count++   // ❌ not allowed (props are readonly)
</code></pre>

    <ul>
        <li>Instead, use a local ref:</li>
    </ul>

<pre><code class="language-ts line-numbers">const localCount = ref(props.count)
</code></pre>

    <br/><br/>



    <li><b>Required Props</b></li>
    <br/>
    <ul>
        <li>Props without <code>?</code> are automatically required.</li>
    </ul>

<pre><code class="language-ts line-numbers">const props = defineProps&lt;{
    id: number      // required
    name?: string   // optional
}&gt;()
</code></pre>

    <br/><br/>



    <li><b>Prop Validation with TypeScript</b></li>
    <br/>
    <ul>
        <li>TypeScript replaces the old Vue runtime validators.</li>
        <li>The component will not compile if you pass invalid types.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ❌ Type error: age must be a number --&gt;
&lt;UserCard name="Alice" age="twenty" /&gt;
</code></pre>

    <br/><br/>



    <li><b>Destructuring Props (Safe Pattern)</b></li>
    <br/>
    <ul>
        <li>You should <u>avoid</u> direct destructuring, because it loses reactivity.</li>
        <li>Use <code>toRefs()</code> to safely destructure props.</li>
    </ul>

<pre><code class="language-ts line-numbers">import { toRefs } from "vue"

const props = defineProps&lt;{
    title: string
    count: number
}&gt;()

const { title, count } = toRefs(props)
</code></pre>

    <ul>
        <li>Now <code>title</code> and <code>count</code> remain reactive.</li>
    </ul>

    <br/><br/>



    <li><b>Props and Emits Together</b></li>
    <br/>
    <ul>
        <li>Combining props with emits enables two-way communication.</li>
        <li>This is the building block for custom <code>v-model</code> implementations.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Toggle.vue --&gt;
&lt;template&gt;
    &lt;button @click="toggle"&gt;{{ modelValue ? "On" : "Off" }}&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    modelValue: boolean
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:modelValue", value: boolean): void
}&gt;()

function toggle() {
    emit("update:modelValue", !props.modelValue)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Best Practices for Props</b></li>
    <br/>
    <ul>
        <li>Use <b>TypeScript</b> <code>interfaces</code> for clarity and reusability.</li>
        <li>Use <code>withDefaults()</code> instead of manual default handling.</li>
        <li>Do <u>not</u> mutate props, use local state instead.</li>
        <li>Use union types to restrict props to valid values.</li>
        <li>Use <code>toRefs(props)</code> when destructuring.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Define props</td>
                <td><code>defineProps&lt;T&gt;()</code> with TypeScript interfaces</td>
            </tr>
            <tr>
                <td>Optional props</td>
                <td>Use <code>?</code> in type definitions</td>
            </tr>
            <tr>
                <td>Default values</td>
                <td>Use <code>withDefaults()</code> around <code>defineProps</code></td>
            </tr>
            <tr>
                <td>Prop immutability</td>
                <td>Props are readonly — cannot mutate directly</td>
            </tr>
            <tr>
                <td>Complex props</td>
                <td>Pass objects, arrays, or interfaces</td>
            </tr>
            <tr>
                <td>Destructuring</td>
                <td>Use <code>toRefs()</code> to keep reactivity</td>
            </tr>
            <tr>
                <td>Type safety</td>
                <td>TypeScript enforces correct prop usage automatically</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-component-events">Component Events in Vue (Emits + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Component events allow child components to <b>send messages to their parents</b>.</li>
        <br/>
        <li>They are fundamental for communication when child components need to:
            <ul>
                <li>notify about user interactions</li>
                <li>update values in the parent</li>
                <li>trigger actions (submit, delete, save)</li>
                <li>implement custom <code>v-model</code></li>
            </ul>
        </li>
        <br/>
        <li>In Vue 3 with the Composition API, events are defined using <code>defineEmits&lt;T&gt;</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Defining Events with <code>defineEmits()</code></b></li>
    <br/>
    <ul>
        <li>The recommended way to define events is using function signatures.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;template&gt;
    &lt;button @click="sendMessage"&gt;Send&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const emit = defineEmits&lt;{
    (event: "hello", message: string): void
}&gt;()

function sendMessage() {
    emit("hello", "Hi from child!")
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The event type ensures the event name must be <code>"hello"</code> and the payload must be a <code>string</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Listening to Events in the Parent</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Child @hello="onHello" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Child from "./Child.vue"

function onHello(message: string) {
    console.log("Child said:", message)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The parent's callback receives a strongly typed payload.</li>
    </ul>

    <br/><br/>



    <li><b>Multiple Events</b></li>
    <br/>
    <ul>
        <li>You can define multiple events by adding more signatures.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const emit = defineEmits&lt;{
    (e: "increment"): void
    (e: "submit", value: string): void
    (e: "delete", id: number): void
}&gt;()
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Passing Multiple Arguments</b></li>
    <br/>

<pre><code class="language-ts line-numbers">emit("submit", title.value, description.value)
// Typed as: (e: "submit", title: string, desc: string)
</code></pre>

    <ul>
        <li>You can include as many values as needed.</li>
    </ul>

    <br/><br/>



    <li><b>Using Events for User Interaction</b></li>
    <br/>
    <ul>
        <li>Example: A like button that notifies the parent when clicked.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- LikeButton.vue --&gt;
&lt;template&gt;
    &lt;button @click="like"&gt;Like ({{ count }})&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const count = ref(0)

const emit = defineEmits&lt;{
    (e: "liked", newCount: number): void
}&gt;()

function like() {
    count.value++
    emit("liked", count.value)
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;LikeButton @liked="onLiked" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import LikeButton from "./LikeButton.vue"

function onLiked(total: number) {
    console.log("Likes:", total)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Events and Custom <code>v-model</code></b></li>
    <br/>
    <ul>
        <li>Vue uses events to power two-way binding with custom components.</li>
        <li>The event must follow the pattern: <code>"update:modelValue"</code></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Toggle.vue --&gt;
&lt;template&gt;
    &lt;button @click="toggle"&gt;
        {{ modelValue ? "On" : "Off" }}
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    modelValue: boolean
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:modelValue", value: boolean): void
}&gt;()

function toggle() {
    emit("update:modelValue", !props.modelValue)
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;!--
        &lt;Toggle
            :modelValue="enabled"
            @update:modelValue="enabled = $event"
        /&gt;
    --&gt;

    &lt;Toggle v-model="enabled" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import Toggle from "./Toggle.vue"

const enabled = ref(false)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Event Listeners in Parents</b></li>
    <br/>
    <ul>
        <li>When using TypeScript, listener functions also get type checking automatically:</li>
    </ul>

<pre><code class="language-ts line-numbers">function onSelect(id: number) {
    // id is guaranteed to be a number
}
</code></pre>

    <br/><br/>



    <li><b>Event Validation (Old Vue 2 API)</b></li>
    <br/>
    <ul>
        <li>In Vue 2, you could validate events using an <code>emits: {}</code> object.</li>
        <li>Vue 3 keeps it for compatibility, but <b>TypeScript + defineEmits</b> is preferred.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
defineEmits({
    submit(payload: string) {
        return payload.length &gt; 0
    }
})
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This pattern is now discouraged in TS-based Vue apps.</li>
    </ul>

    <br/><br/>



    <li><b>Best Practices for Component Events</b></li>
    <br/>
    <ul>
        <li>Use <code>defineEmits&lt;T&gt;</code> for full type safety.</li>
        <br/>
        <li>Use descriptive event names like <code>selected</code>, <code>saved</code>, <code>submitted</code>.</li>
        <br/>
        <li>Use <code>update:modelValue</code> for custom two-way binding.</li>
        <br/>
        <li>Avoid emitting complex objects if a simple ID or string works.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Defining events</td>
                <td><code>defineEmits&lt;Signatures&gt;()</code></td>
            </tr>
            <tr>
                <td>Triggering events</td>
                <td><code>emit("eventName", payload)</code></td>
            </tr>
            <tr>
                <td>Parent listening</td>
                <td><code>&lt;Child @eventName="handler" /&gt;</code></td>
            </tr>
            <tr>
                <td>Multiple events</td>
                <td>Use multiple overload signatures</td>
            </tr>
            <tr>
                <td>Custom v-model</td>
                <td>Event must be <code>update:modelValue</code></td>
            </tr>
            <tr>
                <td>Type safety</td>
                <td>All events strictly typed with TypeScript</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-component-v-model">Component v-model (Custom Two-Way Binding in Vue)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>v-model</code> is normally used with form elements (input, checkbox, select).</li>
        <br/>
        <li>But Vue also allows any <u>custom component</u> to support <code>v-model</code>.</li>
        <br/>
        <li>With the Composition API + TypeScript, custom v-model is implemented using:
            <ul>
                <li>a prop named <code>modelValue</code></li>
                <li>an event named <code>"update:modelValue"</code></li>
            </ul>
        </li>
        <br/>
        <li>This gives a clean two-way data flow between parent and child.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Example: A Simple Toggle Component</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Toggle.vue --&gt;
&lt;template&gt;
    &lt;button @click="toggle"&gt;
        {{ modelValue ? "ON" : "OFF" }}
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    modelValue: boolean
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:modelValue", value: boolean): void
}&gt;()

function toggle() {
    emit("update:modelValue", !props.modelValue)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This component can now be used with <code>v-model</code> like a normal input.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Toggle v-model="enabled" /&gt;
    &lt;p&gt;Enabled: {{ enabled }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import Toggle from "./Toggle.vue"

const enabled = ref(false)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The parent now receives updates automatically whenever the child emits.</li>
    </ul>

    <br/><br/>



    <li><b>Understanding the Pattern</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Part</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>modelValue</code></td>
                <td>The value provided by the parent (v-model)</td>
            </tr>
            <tr>
                <td><code>update:modelValue</code></td>
                <td>The event emitted when the child wants to update the parent</td>
            </tr>
            <tr>
                <td><code>v-model="x"</code></td>
                <td>Links <code>x</code> to <code>modelValue</code> and listens for updates</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>v-model with TypeScript Validation</b></li>
    <br/>

<pre><code class="language-ts line-numbers">const emit = defineEmits&lt;{
    (e: "update:modelValue", value: string): void
}&gt;()
</code></pre>

    <ul>
        <li>Any incorrect payload will be caught at compile time.</li>
    </ul>

    <br/><br/>



    <li><b>Multiple v-model Bindings</b></li>
    <br/>
    <ul>
        <li>Components can define multiple v-models using <u>arguments</u>.</li>
        <li>Each v-model gets its own prop + event pair.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- RangeInput.vue --&gt;
&lt;template&gt;
    &lt;input type="number" :value="min" @input="onMin($event)" /&gt;
    &lt;input type="number" :value="max" @input="onMax($event)" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    min: number
    max: number
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:min", value: number): void
    (e: "update:max", value: number): void
}&gt;()

function onMin(e: Event) {
    emit("update:min", Number((e.target as HTMLInputElement).value))
}

function onMax(e: Event) {
    emit("update:max", Number((e.target as HTMLInputElement).value))
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;RangeInput v-model:min="start" v-model:max="end" /&gt;
    &lt;p&gt;Range: {{ start }} - {{ end }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import RangeInput from "./RangeInput.vue"

const start = ref(1)
const end = ref(10)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This allows powerful multi-value component interactions.</li>
    </ul>

    <br/><br/>



    <li><b>Customizing v-model Name</b></li>
    <br/>
    <ul>
        <li>You can use a custom prop name instead of <code>modelValue</code>.</li>
        <li>Use the argument form of v-model.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchInput.vue --&gt;
&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{ query: string }&gt;()

const emit = defineEmits&lt;{
    (e: "update:query", value: string): void
}&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;input :value="query" @input="emit('update:query', $event.target.value)" /&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;SearchInput v-model:query="searchText" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import SearchInput from "./SearchInput.vue"

const searchText = ref("")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Broader control for naming custom binding patterns.</li>
    </ul>

    <br/><br/>



    <li><b>Using Local State + Props in v-model</b></li>
    <br/>
    <ul>
        <li>Sometimes a component should maintain local state instead of directly showing <code>modelValue</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { ref, watch } from "vue"

const props = defineProps&lt;{ modelValue: string }&gt;()
const emit = defineEmits&lt;{ (e: "update:modelValue", value: string): void }&gt;()

const internal = ref(props.modelValue)

// sync internal state to prop changes
watch(() =&gt; props.modelValue, (v) =&gt; internal.value = v)

function update(v: string) {
    internal.value = v
    emit("update:modelValue", v)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This is useful for text inputs, debounced inputs, sliders, etc.</li>
    </ul>

    <br/><br/>



    <li><b>Best Practices</b></li>
    <br/>
    <ul>
        <li>Always use <code>modelValue</code> + <code>update:modelValue</code> for the default v-model.</li>
        <br/>
        <li>Use <code>v-model:yourProp</code> for additional values.</li>
        <br/>
        <li>Return only new values, never mutate props directly.</li>
        <br/>
        <li>For complex inputs, use an internal state synchronized by watchers.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Default v-model</td>
                <td>Uses <code>modelValue</code> prop + <code>update:modelValue</code> event</td>
            </tr>
            <tr>
                <td>Multiple v-models</td>
                <td>Use <code>v-model:name</code> + <code>update:name</code></td>
            </tr>
            <tr>
                <td>Type safety</td>
                <td>All payloads validated by TypeScript</td>
            </tr>
            <tr>
                <td>Local state pattern</td>
                <td>Use <code>ref()</code> + <code>watch()</code> for more control</td>
            </tr>
            <tr>
                <td>Component usage</td>
                <td><code>&lt;CustomInput v-model="value" /&gt;</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-fallthrough-attributes">Fallthrough Attributes in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Fallthrough attributes are attributes that a parent component passes to a child component, but the child component does <u>not</u> explicitly define as props.</li>
        <br/>
        <li>Examples include:
            <ul>
                <li><code>class</code></li>
                <li><code>style</code></li>
                <li><code>id</code></li>
                <li><code>data-*</code> attributes</li>
                <li>ARIA attributes</li>
            </ul>
        </li>
        <br/>
        <li>By default, Vue automatically applies these attributes to the component’s <u>root element</u>.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Example of Fallthrough Attributes</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Button.vue --&gt;
&lt;template&gt;
    &lt;button&gt;
        &lt;slot /&gt;
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Button id="main-btn" class="primary" data-x="123"&gt;
        Click me
    &lt;/Button&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>The final rendered HTML becomes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;button id="main-btn" class="primary" data-x="123"&gt;
    Click me
&lt;/button&gt;
</code></pre>

    <br/><br/>



    <li><b>Accessing Fallthrough Attributes</b></li>
    <br/>
    <ul>
        <li>Inside a component, fallthrough attributes are available through:
            <ul>
                <li><code>$attrs</code> (template)</li>
                <li><code>useAttrs()</code> (Composition API)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { useAttrs } from "vue"

const attrs = useAttrs()

console.log(attrs)
// { id: "main-btn", class: "primary", "data-x": "123" }
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Manually Applying Fallthrough Attributes</b></li>
    <br/>
    <ul>
        <li>If you want to pass fallthrough attributes onto a specific element instead of the root, you must bind <code>v-bind="attrs"</code> manually.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- InputWrapper.vue --&gt;
&lt;template&gt;
    &lt;label&gt;
        {{ label }}
        &lt;input v-bind="attrs" /&gt;
    &lt;/label&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { defineProps, useAttrs } from "vue"

const props = defineProps&lt;{
    label: string
}&gt;()

const attrs = useAttrs()
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Now the attributes apply to the <code>&lt;input&gt;</code>, not the root <code>&lt;label&gt;</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Disabling Automatic Fallthrough</b></li>
    <br/>
    <ul>
        <li>You may want to <u>disable</u> fallthrough entirely for some components.</li>
        <br/>
        <li>This is done using: <code>inheritAttrs: false</code></li>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- CustomField.vue --&gt;
&lt;script setup lang="ts"&gt;
defineOptions({
    inheritAttrs: false
})
&lt;/script&gt;

&lt;template&gt;
    &lt;div&gt;
        &lt;!-- No automatic fallthrough onto this element --&gt;
        &lt;slot /&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>Now attributes like <code>id</code>, <code>class</code>, or <code>data-*</code> will not be applied automatically.</li>
        <li>Useful when you want full control of attribute handling.</li>
    </ul>

    <br/><br/>



    <li><b>Fallthrough and Multiple Root Elements</b></li>
    <br/>
    <ul>
        <li>If a component has more than one root element, Vue <u>cannot</u> decide where to apply fallthrough attributes and will warn you.</li>
        <li>You must manually bind <code>v-bind="$attrs"</code> to the element you choose.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Wrong: Multi-root component --&gt;
&lt;template&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
    &lt;p&gt;World&lt;/p&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Correct --&gt;
&lt;template&gt;
    &lt;div v-bind="$attrs"&gt;
        &lt;h1&gt;Hello&lt;/h1&gt;
        &lt;p&gt;World&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>Fallthrough Attributes with TypeScript</b></li>
    <br/>
    <ul>
        <li>TypeScript treats <code>$attrs</code> as <code>Record&lt;string, unknown&gt;</code>.</li>
        <li>You can narrow types for better safety:</li>
    </ul>

<pre><code class="language-ts line-numbers">const attrs = useAttrs() as Record&lt;string, string | number | boolean&gt;
</code></pre>

    <br/><br/>



    <li><b>Common Use Cases</b></li>
    <br/>
    <ul>
        <li>Reusable input components:</li>
            <ul><li>attributes like <code>placeholder</code>, <code>maxlength</code>, <code>id</code> fall through automatically</li></ul>
        <li>Accessibility:</li>
            <ul><li><code>aria-label</code>, <code>role</code> attributes passed automatically</li></ul>
        <li>Passing CSS classes:</li>
            <ul><li>parents can style the child by assigning <code>class</code></li></ul>
    </ul>

    <br/><br/>



    <li><b>Best Practices</b></li>
    <br/>
    <ul>
        <li>Use <code>useAttrs()</code> when you need to manually control attribute placement.</li>
        <li>Use <code>inheritAttrs: false</code> only when explicit control is needed.</li>
        <li>Design components so that:
            <ul>
                <li><code>class</code> merges naturally</li>
                <li><code>style</code> can override defaults</li>
                <li><code>data-*</code> attributes are passed through safely</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Fallthrough attributes</td>
                <td>Attributes not declared as props automatically applied to the component root</td>
            </tr>
            <tr>
                <td>$attrs / useAttrs()</td>
                <td>Access fallthrough attributes inside the component</td>
            </tr>
            <tr>
                <td>inheritAttrs: false</td>
                <td>Disables automatic fallthrough behavior</td>
            </tr>
            <tr>
                <td>Manual binding</td>
                <td><code>v-bind="$attrs"</code> applies attributes to chosen elements</td>
            </tr>
            <tr>
                <td>Multiple roots</td>
                <td>Require manual placement of fallthrough attributes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-lifecycle-hooks">Lifecycle Hooks in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Every Vue component goes through a series of lifecycle stages:
            <ul>
                <li>creation</li>
                <li>rendering</li>
                <li>updating</li>
                <li>unmounting</li>
            </ul>
        </li>
        <br/>
        <li>Vue lets you run code at specific moments in this lifecycle, called <code>lifecycle hooks</code>.</li>
        <br/>
        <li>Each hook runs automatically at the correct phase.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Example</b></li>
    <br/>
    <ul><li>Import the hook and write code inside it.</li></ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { onMounted, onUnmounted } from "vue"

onMounted(() =&gt; {
    console.log("Component mounted!")
})

onUnmounted(() =&gt; {
    console.log("Component removed!")
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Full List of Composition API Lifecycle Hooks</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Hook</th>
                <th>When It Runs</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>onBeforeMount</code></td>
                <td>Right before the component is mounted to the DOM</td>
            </tr>
            <tr>
                <td><code>onMounted</code></td>
                <td>After the component is mounted (DOM is available)</td>
            </tr>
            <tr>
                <td><code>onBeforeUpdate</code></td>
                <td>Before the component re-renders due to reactive changes</td>
            </tr>
            <tr>
                <td><code>onUpdated</code></td>
                <td>After the DOM is updated</td>
            </tr>
            <tr>
                <td><code>onBeforeUnmount</code></td>
                <td>Right before the component is removed</td>
            </tr>
            <tr>
                <td><code>onUnmounted</code></td>
                <td>After the component is removed from the DOM</td>
            </tr>
            <tr>
                <td><code>onErrorCaptured</code></td>
                <td>When an error occurs in a child component</td>
            </tr>
            <tr>
                <td><code>onRenderTracked</code></td>
                <td>Tracks reactive dependencies during render (debug only)</td>
            </tr>
            <tr>
                <td><code>onRenderTriggered</code></td>
                <td>Called when reactive dependencies cause re-render (debug only)</td>
            </tr>
            <tr>
                <td><code>onActivated</code></td>
                <td>When a component wrapped by &lt;KeepAlive&gt; becomes active</td>
            </tr>
            <tr>
                <td><code>onDeactivated</code></td>
                <td>When a kept-alive component is deactivated</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>onMounted()</b> — When DOM Is Available</li>
    <br/>
    <ul>
        <li>Most commonly used hook.</li>
        <li>Good for:
            <ul>
                <li>fetching API data</li>
                <li>direct DOM access</li>
                <li>starting timers</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">onMounted(() =&gt; {
    console.log("Component ready!")
})</code></pre>

    <br/><br/>



    <li><b>onBeforeMount()</b> — Before Mounting</li>
    <br/>
    <ul>
        <li>Runs right before component is added to the DOM.</li>
        <li>Usually not needed unless debugging.</li>
    </ul>

<pre><code class="language-ts line-numbers">onBeforeMount(() =&gt; {
    console.log("About to mount...")
})</code></pre>

    <br/><br/>



    <li><b>onUpdated()</b> and <b>onBeforeUpdate()</b></li>
    <br/>
    <ul>
        <li>Called when reactive data triggers a re-render.</li>
        <li>Useful when working with:
            <ul>
                <li>scroll positions</li>
                <li>DOM-based animations</li>
                <li>manual DOM manipulation</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">onBeforeUpdate(() =&gt; {
    console.log("DOM is about to update")
})

onUpdated(() =&gt; {
    console.log("DOM updated")
})
</code></pre>

    <br/><br/>



    <li><b>onUnmounted()</b> — Cleanup Logic</li>
    <br/>
    <ul>
        <li>Used for cleanup:
            <ul>
                <li>event listeners</li>
                <li>subscriptions</li>
                <li>intervals</li>
                <li>WebSocket connections</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">onUnmounted(() =&gt; {
    console.log("Component destroyed")
})</code></pre>

    <br/><br/>



    <li><b>Handling Errors with onErrorCaptured()</b></li>
    <br/>
    <ul>
        <li>This hook catches errors from child components.</li>
        <li>Useful for logging error messages or fallback UI.</li>
    </ul>

<pre><code class="language-ts line-numbers">onErrorCaptured((err, instance, info) =&gt; {
    console.error("Error:", err)
    return false   // prevents further propagation
})</code></pre>

    <br/><br/>



    <li><b>Debug Hooks: onRenderTracked() & onRenderTriggered()</b></li>
    <br/>
    <ul>
        <li>Only for debugging reactivity.</li>
        <li>Show which reactive values caused a re-render.</li>
    </ul>

<pre><code class="language-ts line-numbers">onRenderTracked((event) =&gt; {
    console.log("Tracked:", event)
})

onRenderTriggered((event) =&gt; {
    console.log("Triggered:", event)
})</code></pre>

    <br/><br/>



    <li><b>KeepAlive Hooks: onActivated() & onDeactivated()</b></li>
    <br/>
    <ul>
        <li>Used only when wrapping components in:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;KeepAlive&gt;
    &lt;MyComponent /&gt;
&lt;/KeepAlive&gt;</code></pre>

    <ul>
        <li><code>onActivated()</code>: component appears again</li>
        <li><code>onDeactivated()</code>: component is hidden but preserved</li>
    </ul>

<pre><code class="language-ts line-numbers">onActivated(() =&gt; console.log("Activated"))
onDeactivated(() =&gt; console.log("Deactivated"))</code></pre>

    <br/><br/>



    <li><b>Using Lifecycle Hooks with TypeScript</b></li>
    <br/>
    <ul>
        <li>Hooks automatically get full type safety.</li>
        <li>No special typing required.</li>
    </ul>

<pre><code class="language-ts line-numbers">onMounted((): void =&gt; {
    console.log("Typed hook example")
})</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Hook</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>onMounted</code></td>
                <td>Run code after initial render (DOM ready)</td>
            </tr>
            <tr>
                <td><code>onUnmounted</code></td>
                <td>Cleanup when component is removed</td>
            </tr>
            <tr>
                <td><code>onUpdated</code></td>
                <td>Run code after DOM updates</td>
            </tr>
            <tr>
                <td><code>onBeforeMount</code></td>
                <td>Before initial DOM insertion</td>
            </tr>
            <tr>
                <td><code>onBeforeUpdate</code></td>
                <td>Before DOM updates</td>
            </tr>
            <tr>
                <td><code>onErrorCaptured</code></td>
                <td>Error handling from descendants</td>
            </tr>
            <tr>
                <td><code>onActivated / onDeactivated</code></td>
                <td>Hooks for &lt;KeepAlive&gt; components</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-slots">Slots in Vue (Composition API + TypeScript)</h3>
<ol>
    <br/>
    <li><u>Slots</u> allow parent components to pass <u>template content</u> into child components.</li>
    <br/><br/>



    <li><b>Basic Slot</b></li>
    <br/>
    <ul>
        <li>Define a slot inside a child component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;template&gt;
    &lt;div class="box"&gt;
        &lt;slot&gt;Fallback content&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Use the component and pass content:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;Child&gt;
    &lt;p&gt;This is inserted into the slot!&lt;/p&gt;
&lt;/Child&gt;</code></pre>
    <ul>
        <li>If no content is provided, the fallback content is shown.</li>
    </ul>

    <br/><br/>



    <li><b>Named Slots</b></li>
    <br/>
    <ul>
        <li>Used when a component has multiple insertion points.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Card.vue --&gt;
&lt;template&gt;
    &lt;div class="card"&gt;
        &lt;header&gt;&lt;slot name="header" /&gt;&lt;/header&gt;
        &lt;main&gt;&lt;slot /&gt;&lt;/main&gt;
        &lt;footer&gt;&lt;slot name="footer" /&gt;&lt;/footer&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Parent uses named slots with <code>v-slot:&lt;name&gt;</code> or the shorthand <code>#&lt;name&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;Card&gt;
    &lt;template #header&gt;Header Content&lt;/template&gt;
    Body text goes here.
    &lt;template #footer&gt;Footer Content&lt;/template&gt;
&lt;/Card&gt;
</code></pre>

    <br/><br/>



    <li><b>Scoped Slots (Passing Data From Child to Parent)</b></li>
    <br/>
    <ul>
        <li>Scoped slots allow the child to expose data to parent-provided templates.</li>
        <li>This is extremely useful when the child has state but the parent controls rendering.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- UserList.vue --&gt;
&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="user in users" :key="user.id"&gt;
            &lt;slot :user="user"&gt;{{ user.name }}&lt;/slot&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
interface User {
    id: number;
    name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Parent receives <code>user</code> as slot props:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;UserList&gt;
    &lt;template #default="{ user }"&gt;
        &lt;strong&gt;{{ user.name }}&lt;/strong&gt;
    &lt;/template&gt;
&lt;/UserList&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Slot Props in TypeScript</b></li>
    <br/>
    <ul>
        <li>You can fully type slot props with the <code>SlotsType</code> helper.</li>
        <li>This improves editor autocompletion and ensures correctness.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import type { SlotsType } from "vue"

interface User {
    id: number;
    name: string;
}

defineSlots&lt;SlotsType&lt;{
    default: { user: User }
}&gt;&gt;()
&lt;/script&gt;
</code></pre>
    <ul>
        <li>The parent now gets full TypeScript inference.</li>
    </ul>

    <br/><br/>



    <li><b>Default Slot + Named Slots Together</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Layout.vue --&gt;
&lt;template&gt;
    &lt;div class="layout"&gt;
        &lt;aside&gt;&lt;slot name="sidebar" /&gt;&lt;/aside&gt;
        &lt;section&gt;&lt;slot /&gt;&lt;/section&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;Layout&gt;
    &lt;template #sidebar&gt;Menu items...&lt;/template&gt;
    &lt;p&gt;Main content goes here.&lt;/p&gt;
&lt;/Layout&gt;
</code></pre>

    <br/><br/>



    <li><b>Fallback Content</b></li>
    <br/>
    <ul>
        <li>If a slot has no provided content, fallback appears.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;slot&gt;Nothing provided&lt;/slot&gt;</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Default slot</td>
                <td>Main content placeholder</td>
            </tr>
            <tr>
                <td>Named slots</td>
                <td>Multiple content areas such as header/footer/sidebar</td>
            </tr>
            <tr>
                <td>Scoped slots</td>
                <td>Child passes data to parent templates</td>
            </tr>
            <tr>
                <td>Fallback content</td>
                <td>Shown when no parent content is provided</td>
            </tr>
            <tr>
                <td>TypeScript slots</td>
                <td>Use <code>defineSlots</code> for typing slot props</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-conditional-rendering">Conditional Rendering in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Conditional rendering controls whether parts of the DOM appear or not.</li>
        <br/>
        <li>Vue provides intuitive directives like:
            <ul>
                <li><code>v-if</code></li>
                <li><code>v-else-if</code></li>
                <li><code>v-else</code></li>
                <li><code>v-show</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>v-if</b> — Render Only If Condition Is True</li>
    <br/>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;div&gt;
        &lt;p v-if="loggedIn"&gt;Welcome back!&lt;/p&gt;
        &lt;p v-else&gt;Please log in.&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const loggedIn = ref(false)
&lt;/script&gt;
</code></pre>
    <ul>
        <li>This is efficient for rare updates or expensive components.</li>
    </ul>

    <br/><br/>



    <li><b>v-else-if and v-else</b></li>
    <br/>
    <ul>
        <li>Standard conditional chain.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;div&gt;
        &lt;p v-if="score &gt;= 90"&gt;Excellent&lt;/p&gt;
        &lt;p v-else-if="score &gt;= 60"&gt;Pass&lt;/p&gt;
        &lt;p v-else&gt;Fail&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const score = ref(75)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>v-show</b> — Toggle Visibility with CSS</li>
    <br/>
    <ul>
        <li><code>v-show</code> does NOT remove elements from the DOM.</li>
        <li>It toggles <code>display: none</code>.</li>
        <li>Useful when:
            <ul>
                <li>you need frequent toggling</li>
                <li>the element is expensive to recreate</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;button @click="show = !show"&gt;Toggle&lt;/button&gt;
    &lt;p v-show="show"&gt;I stay in the DOM.&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const show = ref(true)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>v-if vs v-show: When to Use Which?</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Directive</th>
                <th>Behavior</th>
                <th>Best Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>v-if</code></td>
                <td>Creates/removes DOM elements</td>
                <td>Rare toggles, expensive components</td>
            </tr>
            <tr>
                <td><code>v-show</code></td>
                <td>Always renders, toggles visibility via CSS</td>
                <td>Frequent toggling, always needed in DOM</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Conditional Groups Using &lt;template&gt;</b></li>
    <br/>
    <ul>
        <li>Vue allows grouping multiple elements under a single <code>v-if</code> using <code>&lt;template&gt;</code>.</li>
        <li>The template tag does not render itself, only its children appear.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template v-if="user"&gt;
    &lt;h2&gt;User Info&lt;/h2&gt;
    &lt;p&gt;Name: {{ user.name }}&lt;/p&gt;
&lt;/template&gt;

&lt;template v-else&gt;
    &lt;p&gt;No user found.&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
interface User {
    name: string;
}

const user = ref&lt;User | null&gt;({ name: "Alice" })
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Using Computed Properties for Cleaner Conditions</b></li>
    <br/>
    <ul>
        <li>Use <code>computed</code> when logic becomes too complex.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { ref, computed } from "vue"

const age = ref(20)

const isAdult = computed(() =&gt; age.value &gt;= 18)
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p v-if="isAdult"&gt;You are an adult.&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>v-if with Async Data (Common Pattern)</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p v-if="loading"&gt;Loading...&lt;/p&gt;
    &lt;p v-else-if="error"&gt;Error: {{ error }}&lt;/p&gt;
    &lt;p v-else&gt;Data: {{ data }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue"

const loading = ref(true)
const error = ref&lt;string | null&gt;(null)
const data = ref&lt;string | null&gt;(null)

onMounted(async () =&gt; {
    try {
        const res = await fetch("/api/message")
        data.value = await res.text()
    } catch (err) {
        error.value = String(err)
    } finally {
        loading.value = false
    }
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Best Practices</b></li>
    <br/>
    <ul>
        <li>Use <code>v-if</code> when the condition rarely changes.</li>
        <li>Use <code>v-show</code> when toggling frequently.</li>
        <li>Use computed properties for readable conditions.</li>
        <li>Avoid putting heavy logic directly inside template expressions.</li>
        <li>Use <code>&lt;template&gt;</code> for grouping multiple conditional elements.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Directive</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>v-if</code></td>
                <td>Conditionally render elements (added/removed from DOM)</td>
            </tr>
            <tr>
                <td><code>v-else-if</code> / <code>v-else</code></td>
                <td>Chain conditional rendering</td>
            </tr>
            <tr>
                <td><code>v-show</code></td>
                <td>Toggle visibility using CSS, always in DOM</td>
            </tr>
            <tr>
                <td><code>v-if</code> + <code>&lt;template&gt;</code></td>
                <td>Conditionally render a block of elements</td>
            </tr>
            <tr>
                <td>Computed conditions</td>
                <td>Cleaner and reusable conditional logic</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-list-rendering">List Rendering in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue's <u>list rendering</u> uses the <code>v-for</code> directive to loop through arrays, objects, or numbers.</li>
        <br/>
        <li>With the Composition API + TypeScript, list data is usually stored in <code>ref()</code> or <code>reactive()</code> variables.</li>
    </ul>

    <br/><br/>



    <li><b>Basic List Rendering with Arrays</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="name in names" :key="name"&gt;
            {{ name }}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const names = ref&lt;string[]&gt;(["Alice", "Bob", "Charlie"])
&lt;/script&gt;
</code></pre>
    <ul>
        <li><code>:key</code> is required for efficient DOM updates.</li>
    </ul>

    <br/><br/>



    <li><b>Accessing Index in v-for</b></li>

<pre><code class="language-html line-numbers">&lt;li v-for="(name, index) in names" :key="index"&gt;
    {{ index }} - {{ name }}
&lt;/li&gt;
</code></pre>
    <ul>
        <li>Using <code>index</code> as key is allowed but not recommended when list items can change order.</li>
    </ul>

    <br/><br/>



    <li><b>Rendering a List of Objects</b></li>
<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="user in users" :key="user.id"&gt;
            {{ user.name }} ({{ user.age }})
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

interface User {
    id: number
    name: string
    age: number
}

const users = ref&lt;User[]&gt;([
    { id: 1, name: "Alice", age: 20 },
    { id: 2, name: "Bob", age: 25 }
])
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Using Computed Properties to Transform Lists</b></li>
<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { ref, computed } from "vue"

const numbers = ref([1, 2, 3, 4, 5])

const evenNumbers = computed(() =&gt;
    numbers.value.filter(n =&gt; n % 2 === 0)
)
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p v-for="num in evenNumbers" :key="num"&gt;
        {{ num }}
    &lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>v-for on &lt;template&gt; (Multiple Elements)</b></li>
    <br/>
    <ul>
        <li>Use <code>&lt;template&gt;</code> when looping should render multiple sibling elements.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template v-for="user in users" :key="user.id"&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;Age: {{ user.age }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>Looping Through Objects</b></li>
<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;div v-for="(value, key) in settings" :key="key"&gt;
        {{ key }}: {{ value }}
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { reactive } from "vue"

const settings = reactive({
    theme: "dark",
    notifications: true,
    version: 3
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Looping Through a Range (v-for with Numbers)</b></li>
<pre><code class="language-html line-numbers">&lt;li v-for="n in 5" :key="n"&gt;
    Item {{ n }}
&lt;/li&gt;
</code></pre>

    <br/><br/>



    <li><b>Combining v-for with v-if (Warning)</b></li>
    <br/>
    <ul>
        <li><b>Not recommended</b> because it can cause confusing rendering behavior.</li>
        <li>Better to filter the list using computed properties.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ❌ Avoid --&gt;
&lt;li v-for="user in users" v-if="user.active" :key="user.id"&gt;
    {{ user.name }}
&lt;/li&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- ✔ Better --&gt;
&lt;li v-for="user in activeUsers" :key="user.id"&gt;
    {{ user.name }}
&lt;/li&gt;
</code></pre>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { ref, computed } from "vue"

const users = ref([
    { id: 1, name: "Alice", active: true },
    { id: 2, name: "Bob", active: false }
])

const activeUsers = computed(() =&gt;
    users.value.filter(u =&gt; u.active)
)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Tracking List Items with Unique Keys</b></li>
    <br/>
    <ul>
        <li>The <code>:key</code> attribute helps Vue track items when the list changes.</li>
        <li>Keys should be: <u>unique</u> and <u>stable</u> (does not change over time)</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;li v-for="todo in todos" :key="todo.id"&gt;
    {{ todo.text }}
&lt;/li&gt;
</code></pre>

    <br/><br/>



    <li><b>Using List Rendering with Components</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;TodoItem
        v-for="todo in todos"
        :key="todo.id"
        :todo="todo"
    /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import TodoItem from "./TodoItem.vue"

const todos = ref([
    { id: 1, text: "Study Vue" },
    { id: 2, text: "Write components" }
])
&lt;/script&gt;
</code></pre>


    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>v-for</code></td>
                <td>Loop through arrays, objects, or numbers</td>
            </tr>
            <tr>
                <td><code>:key</code></td>
                <td>Helps Vue track elements efficiently</td>
            </tr>
            <tr>
                <td>Computed filtering</td>
                <td>Recommended instead of using v-if inside v-for</td>
            </tr>
            <tr>
                <td>Object iteration</td>
                <td>Access value + key</td>
            </tr>
            <tr>
                <td>Range iteration</td>
                <td>Loop n times using <code>v-for="n in 10"</code></td>
            </tr>
            <tr>
                <td>Component lists</td>
                <td>Use v-for with components and properly typed props</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-event-handling">Event Handling in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Event handling in Vue uses the <code>v-on</code> directive (or the shorthand <code>@</code>) to listen to DOM events.</li>
        <br/>
        <li>Common use cases:
            <ul>
                <li>button clicks</li>
                <li>keyboard events</li>
                <li>form submission</li>
                <li>custom component events</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Basic Event Listening</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;button @click="increment"&gt;Count: {{ count }}&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const count = ref(0)

function increment() {
    count.value++
}
&lt;/script&gt;
</code></pre>
    <ul>
        <li><code>@click</code> is shorthand for <code>v-on:click</code>.</li>
        <li>Functions are called normally with no need for <code>this</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Passing Arguments to Event Handlers</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;button @click="add(5)"&gt;+5&lt;/button&gt;

&lt;script setup lang="ts"&gt;
function add(amount: number) {
    console.log("Added:", amount)
}
&lt;/script&gt;
</code></pre>
    <ul>
        <li>You can pass multiple arguments to your handler.</li>
    </ul>

    <br/><br/>



    <li><b>Accessing the Native Event Object</b></li>
    <br/>
    <ul>
        <li>Use <code>$event</code> to access the original event.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input @input="handleInput($event)" /&gt;

&lt;script setup lang="ts"&gt;
function handleInput(e: Event) {
    const target = e.target as HTMLInputElement
    console.log(target.value)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Inline Arrow Functions</b></li>
<pre><code class="language-html line-numbers">&lt;button @click="() =&gt; count++"&gt;Increment&lt;/button&gt;
</code></pre>

    <ul>
        <li>Works but less readable—prefer named functions for larger components.</li>
    </ul>

    <br/><br/>



    <li><b>Event Modifiers</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Modifier</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>.stop</code></td>
                <td>Calls <code>event.stopPropagation()</code></td>
            </tr>
            <tr>
                <td><code>.prevent</code></td>
                <td>Calls <code>event.preventDefault()</code></td>
            </tr>
            <tr>
                <td><code>.capture</code></td>
                <td>Use capture mode</td>
            </tr>
            <tr>
                <td><code>.once</code></td>
                <td>Listener runs only once</td>
            </tr>
            <tr>
                <td><code>.passive</code></td>
                <td>Use passive mode (scroll performance)</td>
            </tr>
        </tbody>
    </table>

    <br/>

<pre><code class="language-html line-numbers">&lt;button @click.stop="doSomething"&gt;Stop Propagation&lt;/button&gt;
&lt;form @submit.prevent="submit"&gt;...&lt;/form&gt;
</code></pre>

    <br/><br/>



    <li><b>Key Modifiers (Keyboard Events)</b></li>
    <br/>
    <ul>
        <li>Keyboard shortcuts are easy using key modifiers like:</li>
        <li><code>.enter</code>, <code>.esc</code>, <code>.space</code>, <code>.tab</code>, etc.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input @keyup.enter="submit" /&gt;
</code></pre>

    <br/>
    <ul>
        <li>You can also combine modifiers:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input @keyup.ctrl.enter="save" /&gt;
</code></pre>

    <br/><br/>



    <li><b>Mouse Button Modifiers</b></li>
<pre><code class="language-html line-numbers">&lt;button @click.right="onRightClick"&gt;Right Click&lt;/button&gt;
&lt;button @click.middle="onMiddleClick"&gt;Middle Click&lt;/button&gt;
</code></pre>

    <br/><br/>



    <li><b>v-on on &lt;template&gt;</b></li>
    <br/>
    <ul>
        <li>You can attach event listeners to <code>&lt;template&gt;</code> when grouping elements.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template @click="clicked"&gt;
    &lt;button&gt;A&lt;/button&gt;
    &lt;button&gt;B&lt;/button&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>Event Handling with TypeScript (Strong Typing)</b></li>
    <br/>
    <ul>
        <li>You can strongly type events for better safety:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
function onInput(e: Event) {
    const target = e.target as HTMLInputElement
    console.log(target.value)
}

function onClick(e: MouseEvent) {
    console.log("Mouse X:", e.clientX)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Using Events Inside Components</b></li>
<pre><code class="language-html line-numbers">&lt;ChildComponent @update="handleUpdate" /&gt;

&lt;script setup lang="ts"&gt;
function handleUpdate(value: number) {
    console.log("Updated:", value)
}
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Child component emits events using <code>emit()</code> (covered in earlier chapters).</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>@click</code>, <code>@input</code>, etc.</td>
                <td>Attach DOM event listeners</td>
            </tr>
            <tr>
                <td>Event modifiers</td>
                <td><code>.stop</code>, <code>.prevent</code>, <code>.once</code>, etc.</td>
            </tr>
            <tr>
                <td>Key modifiers</td>
                <td><code>.enter</code>, <code>.esc</code>, <code>.ctrl.enter</code>, etc.</td>
            </tr>
            <tr>
                <td>Inline event handlers</td>
                <td>Quick logic but less readable</td>
            </tr>
            <tr>
                <td>Typed events</td>
                <td>Use TypeScript for safe event handling</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-form-input-bindings">Form Input Bindings in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue provides <u>two-way binding</u> for form inputs using <code>v-model</code>.</li>
        <br/>
        <li><code>v-model</code> automatically keeps:
            <ul>
                <li>the input’s value → synced with</li>
                <li>your component’s state</li>
            </ul>
        </li>
        <br/>
        <li>Works with:
            <ul>
                <li>text inputs</li>
                <li>checkboxes</li>
                <li>radio buttons</li>
                <li>select dropdowns</li>
                <li>textareas</li>
                <li>custom components</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Text Input with v-model</b></li>
<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input v-model="name" placeholder="Your name" /&gt;
    &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const name = ref("")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Textarea</b></li>
<pre><code class="language-html line-numbers">&lt;textarea v-model="message"&gt;&lt;/textarea&gt;

&lt;script setup lang="ts"&gt;
const message = ref("")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Checkbox (Boolean)</b></li>
    <br/>
    <ul>
        <li>Single checkbox → boolean value.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input type="checkbox" v-model="isChecked" /&gt;
&lt;p&gt;Checked: {{ isChecked }}&lt;/p&gt;

&lt;script setup lang="ts"&gt;
const isChecked = ref(false)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Checkbox Group (Array Binding)</b></li>
    <br/>
    <ul>
        <li>Multiple checkboxes can bind to an array.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;label&gt;
        &lt;input type="checkbox" value="apple" v-model="fruits" /&gt; Apple
    &lt;/label&gt;
    &lt;label&gt;
        &lt;input type="checkbox" value="banana" v-model="fruits" /&gt; Banana
    &lt;/label&gt;

    &lt;p&gt;Selected: {{ fruits }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const fruits = ref&lt;string[]&gt;([])
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Radio Buttons</b></li>
    <br/>
    <ul>
        <li>Radio groups bind a single selected value.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;label&gt;
        &lt;input type="radio" value="male" v-model="gender" /&gt; Male
    &lt;/label&gt;
    &lt;label&gt;
        &lt;input type="radio" value="female" v-model="gender" /&gt; Female
    &lt;/label&gt;

    &lt;p&gt;Gender: {{ gender }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const gender = ref("male")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Select Dropdown (Single)</b></li>
<pre><code class="language-html line-numbers">&lt;select v-model="city"&gt;
    &lt;option value="Berlin"&gt;Berlin&lt;/option&gt;
    &lt;option value="Munich"&gt;Munich&lt;/option&gt;
    &lt;option value="Hamburg"&gt;Hamburg&lt;/option&gt;
&lt;/select&gt;

&lt;script setup lang="ts"&gt;
const city = ref("Berlin")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Select Dropdown (Multiple)</b></li>
<pre><code class="language-html line-numbers">&lt;select v-model="cities" multiple&gt;
    &lt;option value="Berlin"&gt;Berlin&lt;/option&gt;
    &lt;option value="Munich"&gt;Munich&lt;/option&gt;
    &lt;option value="Hamburg"&gt;Hamburg&lt;/option&gt;
&lt;/select&gt;

&lt;script setup lang="ts"&gt;
const cities = ref&lt;string[]&gt;([])
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Binding Value Types (Number / Boolean / String)</b></li>
    <br/>
    <ul>
        <li>By default, all input values are strings.</li>
        <li>You can convert types using modifiers.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input v-model.number="age" type="number" /&gt;

&lt;script setup lang="ts"&gt;
const age = ref&lt;number | null&gt;(null)
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Available modifiers:
            <ul>
                <li><code>.number</code> → converts input to number</li>
                <li><code>.trim</code> → trims whitespace</li>
                <li><code>.lazy</code> → updates on <code>change</code> instead of <code>input</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input v-model.trim="username" /&gt;
&lt;input v-model.lazy="email" /&gt;
</code></pre>

    <br/><br/>



    <li><b>Binding to reactive() Objects</b></li>
    <br/>
    <ul>
        <li>Useful for grouping form data.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input v-model="form.email" placeholder="Email" /&gt;
    &lt;input type="password" v-model="form.password" placeholder="Password" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { reactive } from "vue"

const form = reactive({
    email: "",
    password: ""
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>TypeScript Typing for Forms</b></li>
<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { reactive } from "vue"

interface LoginForm {
    email: string
    password: string
    remember: boolean
}

const form = reactive&lt;LoginForm&gt;({
    email: "",
    password: "",
    remember: false
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Using v-model with Components</b></li>
    <br/>
    <ul>
        <li>Vue supports two-way binding on custom components using <code>modelValue</code> and <code>update:modelValue</code>.</li>
        <li>(Already covered in chapter “Component v-model”) but included here for completeness.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;CustomInput v-model="username" /&gt;
</code></pre>

    <br/><br/>



    <li><b>Best Practices</b></li>
    <br/>
    <ul>
        <li>Use <code>ref()</code> or <code>reactive()</code> depending on complexity.</li>
        <br/>
        <li>Use modifiers for correct value types.</li>
        <br/>
        <li>For complex forms, consider libraries like <u>VeeValidate</u> or <u>FormKit</u>.</li>
        <br/>
        <li>Use custom component <code>v-model</code> for reusable input fields.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>v-model</code></td>
                <td>Two-way binding for form fields</td>
            </tr>
            <tr>
                <td>Modifiers</td>
                <td><code>.trim</code>, <code>.number</code>, <code>.lazy</code></td>
            </tr>
            <tr>
                <td>Checkbox &amp; Radio</td>
                <td>Boolean, array, or single-value binding</td>
            </tr>
            <tr>
                <td>Select</td>
                <td>Single or multiple selection support</td>
            </tr>
            <tr>
                <td>reactive()</td>
                <td>Organize form data in typed objects</td>
            </tr>
            <tr>
                <td>TypeScript support</td>
                <td>Strong typing for safe form handling</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-scoped-slots">Scoped Slots in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Scoped slots</u> allow a child component to expose data to the parent’s template.</li>
        <br/>
        <li>Unlike normal slots (where the parent provides only markup), scoped slots allow:
            <ul>
                <li>child → provides data</li>
                <li>parent → decides how to display it</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>How Scoped Slots Work (Concept)</b></li>
    <br/>
    <ul>
        <li>A child component exposes variables using:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;slot :user="user"&gt;&lt;/slot&gt;</code></pre>

    <br/>
    <ul>
        <li>The parent receives them using:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template #default="{ user }"&gt;
    {{ user.name }}
&lt;/template&gt;
</code></pre>
    <ul>
        <li>Important points:
            <ul>
                <li>Data flows from <u>child to parent</u>.</li>
                <li>Rendering (HTML structure) flows from <u>parent to child</u>.</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Basic Scoped Slot Example</b></li>
    <br/>
    <ul>
        <li>Child component exposing data:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- UserList.vue --&gt;
&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="user in users" :key="user.id"&gt;
            &lt;slot :user="user"&gt;
                {{ user.name }}
            &lt;/slot&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
interface User {
    id: number
    name: string
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
]
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Parent decides how each user is displayed:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;UserList&gt;
    &lt;template #default="{ user }"&gt;
        &lt;strong&gt;{{ user.name.toUpperCase() }}&lt;/strong&gt;
    &lt;/template&gt;
&lt;/UserList&gt;
</code></pre>
    <ul>
        <li>Even though <code>users</code> is in the child, the parent controls the layout.</li>
    </ul>

    <br/><br/>



    <li><b>Example: Building a Flexible Table</b></li>
    <br/>
    <ul>
        <li>Child defines how rows are generated but not how cells look.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- DataTable.vue --&gt;
&lt;template&gt;
    &lt;table&gt;
        &lt;tr v-for="row in rows" :key="row.id"&gt;
            &lt;slot :row="row"&gt;&lt;/slot&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
interface Row {
    id: number
    name: string
    age: number
}

const rows: Row[] = [
    { id: 1, name: "Alice", age: 20 },
    { id: 2, name: "Bob", age: 25 }
]
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;DataTable&gt;
    &lt;template #default="{ row }"&gt;
        &lt;td&gt;{{ row.name }}&lt;/td&gt;
        &lt;td&gt;{{ row.age }}&lt;/td&gt;
    &lt;/template&gt;
&lt;/DataTable&gt;
</code></pre>
    <br/><br/>



    <li><b>Typing Scoped Slots in TypeScript (Strong Typing)</b></li>
    <br/>
    <ul>
        <li><code>defineSlots()</code>: declares slot names and their prop types in the <u>child</u></li>
        <li><code>SlotsType&lt;T&gt;</code>: helper type used with <code>defineSlots</code> to describe all slots</li>
    </ul>

    <br/>

    <ul>
        <li><b>Example 1: Single Typed Default Slot</b></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- UserCard.vue --&gt;
&lt;template&gt;
    &lt;div class="card"&gt;
        &lt;!-- Expose "user" as a scoped slot prop to the parent --&gt;
        &lt;slot :user="user"&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import type { SlotsType } from "vue"

interface User {
    id: number
    name: string
}

const user: User = {
    id: 1,
    name: "Alice"
}

defineSlots&lt;SlotsType&lt;{
    default: { user: User }
}&gt;&gt;()
&lt;/script&gt;
</code></pre>
    <ul>
        <li>This definition enforces that:
            <ul>
                <li>only a <code>default</code> slot exists and the the parent receives a single prop named <code>user</code></li>
                <li><code>user</code> must match the <code>User</code> interface</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;UserCard&gt;
        &lt;template #default="{ user }"&gt;
            &lt;p&gt;{{ user.name }} (ID: {{ user.id }})&lt;/p&gt;
        &lt;/template&gt;
    &lt;/UserCard&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import UserCard from "./UserCard.vue"
&lt;/script&gt;
</code></pre>

    <br/><br/>

    <ul>
        <li><b>Example 2: Multiple Typed Scoped Slots</b></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Panel.vue --&gt;
&lt;template&gt;
    &lt;section class="panel"&gt;
        &lt;header&gt;
            &lt;slot name="header" :title="title"&gt;&lt;/slot&gt;
        &lt;/header&gt;

        &lt;main&gt;
            &lt;slot :item="item"&gt;&lt;/slot&gt;
        &lt;/main&gt;

        &lt;footer&gt;
            &lt;slot name="footer" :updatedAt="updatedAt"&gt;&lt;/slot&gt;
        &lt;/footer&gt;
    &lt;/section&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import type { SlotsType } from "vue"

const title = "Panel Title"
const item = "Some item"
const updatedAt = new Date()

defineSlots&lt;SlotsType&lt;{
    header: { title: string }
    default: { item: string }
    footer: { updatedAt: Date }
}&gt;&gt;()
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The typing above guarantees that:
            <ul>
                <li>the only allowed slots are <code>header</code>, <code>default</code>, and <code>footer</code></li>
                <li><code>header</code> receives <code>{ title: string }</code></li>
                <li><code>default</code> receives <code>{ item: string }</code></li>
                <li><code>footer</code> receives <code>{ updatedAt: Date }</code></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Panel&gt;
        &lt;template #header="{ title }"&gt;
            &lt;h2&gt; {{ title }} &lt;/h2&gt;
        &lt;/template&gt;

        &lt;template #default="{ item }"&gt;
            &lt;p&gt;Item: {{ item }}&lt;/p&gt;
        &lt;/template&gt;

        &lt;template #footer="{ updatedAt }"&gt;
            &lt;small&gt;Last updated: {{ updatedAt.toLocaleString() }}&lt;/small&gt;
        &lt;/template&gt;
    &lt;/Panel&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Panel from "./Panel.vue"
&lt;/script&gt;
</code></pre>

    <br/><br/>

    <ul>
        <li><b>Example 3: Nullable / Optional Slot Props</b></li>
            Below we only show the <code>&lt;script setup&gt;</code> part of the <u>child</u>, the template can use <code>&lt;slot :user="user"&gt;</code> as before.
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import type { SlotsType } from "vue"

interface User {
    id: number
    name: string
}

const user: User | null = null

defineSlots&lt;SlotsType&lt;{
    default: { user?: User | null }
}&gt;&gt;()
&lt;/script&gt;
</code></pre>
    <ul>
        <li>This tells TypeScript that the slot prop <code>user</code> may be: <code>undefined</code> or <code>null</code> or a valid <code>User</code>
            <br/>and the parent must handle these cases safely.
        </li>
    </ul>

    <br/><br/>




    <li><b>Multiple Scoped Slots</b></li>
    <br/>
    <ul>
        <li>Scoped slots can also be named.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- UserCard.vue --&gt;
&lt;template&gt;
    &lt;div class="card"&gt;
        &lt;slot name="header" :user="user" /&gt;
        &lt;p&gt;Age: {{ user.age }}&lt;/p&gt;
        &lt;slot name="footer" :user="user" /&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const user = {
    name: "Alice",
    age: 22
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;UserCard&gt;
    &lt;template #header="{ user }"&gt;
        &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;/template&gt;

    &lt;template #footer="{ user }"&gt;
        &lt;small&gt;User is {{ user.age }} years old.&lt;/small&gt;
    &lt;/template&gt;
&lt;/UserCard&gt;
</code></pre>

    <br/><br/>



    <li><b>Default Slot Fallback Behavior</b></li>
    <br/>
    <ul>
        <li>If the parent fails to provide a slot, the default content renders.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;slot :item="item"&gt;Default layout for {{ item.name }}&lt;/slot&gt;
</code></pre>

    <br/><br/>



    <li><b>Advanced: Passing Functions via Scoped Slots</b></li>
    <br/>
    <ul>
        <li>Scoped slots can also expose functions, not just data.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ActionList.vue --&gt;
&lt;template&gt;
    &lt;slot :remove="remove" :items="items"&gt;&lt;/slot&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const items = ref(["A", "B", "C"])

function remove(index: number) {
    items.value.splice(index, 1)
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;ActionList&gt;
    &lt;template #default="{ items, remove }"&gt;
        &lt;div v-for="(item, i) in items" :key="item"&gt;
            {{ item }}
            &lt;button @click="remove(i)"&gt;X&lt;/button&gt;
        &lt;/div&gt;
    &lt;/template&gt;
&lt;/ActionList&gt;
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Scoped Slots</td>
                <td>Child exposes data → parent renders UI</td>
            </tr>
            <tr>
                <td>Data Direction</td>
                <td>Child → Parent</td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Lists, tables, cards, customized layouts</td>
            </tr>
            <tr>
                <td>TypeScript Support</td>
                <td>Use <code>defineSlots</code> + <code>SlotsType</code></td>
            </tr>
            <tr>
                <td>Named Scoped Slots</td>
                <td>Useful for components with multiple regions</td>
            </tr>
            <tr>
                <td>Fallback Content</td>
                <td>Default slot content if parent provides none</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-provide-inject">Provide / Inject in Vue (Composition API + TypeScript)</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>provide</code> and <code>inject</code> allow components to share data <u>across the component tree</u> without passing props through every level.</li>
        <br/>
        <li><code>provide</code> is used in an ancestor component, <code>inject</code> is used in any descendant component (not necessarily a direct child).</li>
    </ul>

    <br/><br/>


    <li><b>Basic Usage</b></li>
    <br/>

    <ul>
        <li><b>Parent component (provider):</b> <code>Parent.vue</code></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;Parent&lt;/h2&gt;
        &lt;Child /&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { provide } from "vue"
import Child from "./Child.vue"

const message = "Hello from Parent"

provide("msg", message)  // key = "msg"
&lt;/script&gt;
</code></pre>

    <ul>
        <li><b>Child component (injector):</b> <code>Child.vue</code></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;template&gt;
    &lt;p&gt;Injected: {{ msg }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { inject } from "vue"

const msg = inject("msg")
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>If the key does not exist, injected value is <code>undefined</code>
            (You can also provide a default value).</li>
    </ul>

<pre><code class="language-ts line-numbers">const msg = inject("msg", "default value")
</code></pre>

    <br/><br/>



    <li><b>Typed Provide / Inject Using Injection Keys</b></li>
    <br/>
    <ul>
        <li>Using string keys has no type safety.</li>
        <li>The recommended Vue 3 approach is using a <code>Symbol</code> as an injection key with TypeScript type inference.</li>
    </ul>

<pre><code class="language-ts line-numbers">// keys.ts
import type { InjectionKey } from "vue"

export const userKey: InjectionKey&lt;string&gt; = Symbol("userKey")
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;script setup lang="ts"&gt;
import { provide } from "vue"
import { userKey } from "./keys"

provide(userKey, "Alice")
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;script setup lang="ts"&gt;
import { inject } from "vue"
import { userKey } from "./keys"

const user = inject(userKey)
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li><code>user</code> is automatically typed as <code>string | undefined</code>
            (Provide a default if needed) :</li>
    </ul>

<pre><code class="language-ts line-numbers">const user = inject(userKey, "Guest")
</code></pre>

    <br/><br/>




    <li><b>Providing Reactive Values</b></li>
    <br/>
    <ul>
        <li>You can provide <code>ref()</code> or <code>reactive()</code> values to descendants.</li>
        <li>They remain reactive even across component boundaries.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;script setup lang="ts"&gt;
import { ref, provide } from "vue"
import { countKey } from "./keys"

const count = ref(0)

provide(countKey, count)
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;script setup lang="ts"&gt;
import { inject } from "vue"
import { countKey } from "./keys"

const count = inject(countKey)
&lt;/script&gt;

&lt;template&gt;
    &lt;button @click="count.value++"&gt;Increment&lt;/button&gt;
    &lt;p&gt;Count: {{ count.value }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>Because <code>count</code> is reactive in parent, updating it in child updates all components sharing it.</li>
    </ul>

    <br/><br/>



    <li><b>Providing Complex Objects</b></li>

<pre><code class="language-ts line-numbers">&lt;!-- keys.ts --&gt;
import type { InjectionKey } from "vue"

export interface AuthContext {
    user: string
    login: (name: string) =&gt; void
    logout: () =&gt; void
}

export const authKey: InjectionKey&lt;AuthContext&gt; = Symbol("authKey")
</code></pre>

    <br/>

    <ul>
        <li><b>Provider:</b> <code>AuthProvider.vue</code></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
import { provide, ref } from "vue"
import { authKey } from "./keys"

const user = ref("Guest")

function login(name: string) {
    user.value = name
}

function logout() {
    user.value = "Guest"
}

provide(authKey, { user, login, logout })
&lt;/script&gt;

&lt;template&gt;
    &lt;slot /&gt;
&lt;/template&gt;
</code></pre>

    <br/>

    <ul>
        <li><b>Child consumer:</b> <code>UserPanel.vue</code></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
import { inject } from "vue"
import { authKey } from "./keys"

const auth = inject(authKey)

if (!auth) throw new Error("AuthProvider is missing")
&lt;/script&gt;

&lt;template&gt;
    &lt;p&gt;Current user: {{ auth.user }}&lt;/p&gt;
    &lt;button @click="auth.login('Alice')"&gt;Login as Alice&lt;/button&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>


    <li><b>Default Values</b></li>
    <br/>
    <ul>
        <li>You can give <code>inject()</code> a default value:
            <ul>
                <li>if the provider does not exist</li>
                <li>or you want fallback behavior</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">const config = inject(configKey, { theme: "light" })
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>provide()</code></td>
                <td>Defines shared data from an ancestor component</td>
            </tr>
            <tr>
                <td><code>inject()</code></td>
                <td>Consumes shared data in any descendant</td>
            </tr>
            <tr>
                <td>TypeScript keys</td>
                <td>Use <code>InjectionKey&lt;T&gt;</code> + Symbol for type-safe injection</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Reactive values stay reactive across components</td>
            </tr>
            <tr>
                <td>Use cases</td>
                <td>Global config, services, shared stores, avoiding prop drilling</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
