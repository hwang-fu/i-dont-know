<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>VUE</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/vue.png" alt="VUE Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#vue-introduction">Introduction</a></li>
        <li><a href="#vue-options-vs-composition">Options API vs Composition API</a></li>
        <li><a href="#vue-composition-api">Composition API</a></li>
        <li><a href="#vue-reactive-value">Reactive Value</a></li>
        <li><a href="#vue-create-app">Creating a Vue Application</a></li>
        <li><a href="#vue-template-syntax">Template Syntax</a></li>
        <li><a href="#vue-watchers">Watchers</a></li>
        <li><a href="#vue-template-refs">Template Refs</a></li>
        <li><a href="#vue-typescript">Using Vue with TypeScript</a></li>
        <li><a href="#vue-components-basics">Components Basics</a></li>
        <li><a href="#vue-component-registration">Component Registration</a></li>
        <li><a href="#vue-props">Props</a></li>
        <li><a href="#vue-component-events">Component Events</a></li>
        <li><a href="#vue-component-v-model">Component v-model</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-introduction">Introduction to Vue.js</h3>
<ol>
    <li><b>What Is Vue.js?</b></li>
    <br/>
    <ul>
        <li><b>Vue.js</b> (usually called just “Vue”) is a progressive, flexible, and beginner-friendly JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Vue focuses on the <u>view layer</u> (what the user sees) but can grow into a full application framework using official tools such as:
            <ul>
                <li><code>Vue Router</code>: for navigation</li>
                <li><code>Pinia</code>: for state management</li>
                <li><code>Vite</code>: for fast development tooling</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>How Vue Works</b></li>
    <br/>
    <ul>
        <li>Vue uses a <u>reactive data system</u>: when your data changes, the UI updates automatically.</li>
        <br/>
        <li>Your Vue app contains:
            <ul>
                <li>a JavaScript object storing data and logic</li>
                <li>a template that displays this data</li>
                <li>Vue automatically connects (binds) the two</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;div id="app"&gt;
    {{ message }}
&lt;/div&gt;

&lt;script&gt;
const app = Vue.createApp({
    data() {
        return {
            message: "Hello Vue!"
        }
    }
});
app.mount("#app");
&lt;/script&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{{ }}</code> automatically updates when <code>message</code> changes.</li>
    </ul>

    <br/><br/>



    <li><b>Getting Started (CDN Method)</b></li>
    <br/>
    <ul>
        <li>The easiest way to try Vue is by including it from a CDN:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
</code></pre>
    <ul>
        <li>This allows Vue to run directly in your HTML page.</li>
    </ul>

    <br/><br/>



    <li><b>Core Concepts of Vue</b></li>

    <br/>
    <ol>
    <li><b>Templates &amp; Data Binding</b></li>
    <br/>
    <ul>
        <li>Vue uses a clean declarative template syntax.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;div id="app"&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Counter: {{ count }}&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-js line-numbers">data() {
    return {
        title: "Welcome",
        count: 0
    }
}
</code></pre>

    <br/><br/>



    <li><b>Event Handling</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;button @click="count++"&gt;Increase&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>@click</code> is a shortcut for <code>v-on:click</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Two-Way Binding with <code>v-model</code></b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;input v-model="name"&gt;
&lt;p&gt;Hello {{ name }}&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>

    <br/><br/>



    <li><b>Conditionals and Loops</b></li>
<pre><code class="language-html line-numbers">&lt;p v-if="loggedIn"&gt;Welcome back!&lt;/p&gt;
&lt;p v-else&gt;Please log in.&lt;/p&gt;

&lt;ul&gt;
    &lt;li v-for="item in items"&gt;{{ item }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

    <br/><br/>



    <li><b>Computed Properties</b></li>
    <br/>
    <ul>
        <li>Vue recalculates these automatically when dependent data changes.</li>
    </ul>

<pre><code class="language-js line-numbers">computed: {
    reversed() {
        return this.message.split("").reverse().join("");
    }
}
</code></pre>

    <br/><br/>



    <li><b>Methods</b></li>
<pre><code class="language-js line-numbers">methods: {
    greet() {
        return "Hello " + this.name;
    }
}
</code></pre>
    </ol>

    <br/><br/>



    <li><b>Single File Components (SFC)</b></li>
    <br/>
    <ul>
        <li>For bigger apps, Vue uses <code>.vue</code> files, each containing:</li>
        <ul>
            <li><code>&lt;template&gt;</code> – HTML</li>
            <li><code>&lt;script&gt;</code> – JS</li>
            <li><code>&lt;style&gt;</code> – CSS</li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- MyComponent.vue --&gt;
&lt;template&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        return { title: "Hello SFC" }
    }
}
&lt;/script&gt;

&lt;style&gt;
h1 { color: blue; }
&lt;/style&gt;
</code></pre>

    <br/><br/>



    <li><b>Vue Tooling: Vite & Vue CLI</b></li>
    <br/>
    <ul>
        <li>For real applications, use a build tool:</li>
        <ul>
            <li><code>Vite</code>: modern, very fast</li>
            <li><code>Vue CLI</code>: older but still used</li>
        </ul>
    </ul>

<pre><code class="language-bash line-numbers">npm create vue@latest
cd myproject
npm install
npm run dev
</code></pre>

    <br/><br/>



    <li><b>Ecosystem Overview</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Vue Router</td>
                <td>Navigation for SPA apps</td>
            </tr>
            <tr>
                <td>Pinia</td>
                <td>State management</td>
            </tr>
            <tr>
                <td>Vite</td>
                <td>Development &amp; build tool</td>
            </tr>
            <tr>
                <td>DevTools</td>
                <td>Chrome/Firefox debugging extension</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Why Vue Is Great for Beginners</b></li>
    <br/>
    <ul>
        <li>Simple to understand – start with HTML and small scripts</li>
        <li>Powerful for large applications</li>
        <li>More lightweight and intuitive compared to React or Angular</li>
        <li>Very clean syntax (easy to read)</li>
        <li>Excellent documentation</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Reactivity</td>
                <td>UI updates automatically when data changes</td>
            </tr>
            <tr>
                <td>Declarative templates</td>
                <td>Use <code>{{ }}</code> to display data easily</td>
            </tr>
            <tr>
                <td>Directives</td>
                <td><code>v-if</code>, <code>v-for</code>, <code>v-model</code>, <code>v-on</code></td>
            </tr>
            <tr>
                <td>Components</td>
                <td>Reusable UI blocks, .vue files</td>
            </tr>
            <tr>
                <td>Tooling</td>
                <td>Vite, Vue Router, Pinia</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-options-vs-composition">Vue Options API vs Composition API (Introduction & Comparison)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue components can be written using two different styles:</li>
        <ul>
            <li><b>Options API</b> (Vue 2 style, still fully supported in Vue 3)</li>
            <li><b>Composition API</b> (new in Vue 3, more flexible)</li>
        </ul>
        <br/>
        <li>Both styles are valid, and you can mix them in one project.</li>
        <br/>
        <li>The difference is mainly in:
            <ul>
                <li>how you structure code</li>
                <li>how you define reactive data</li>
                <li>how logic is organized and reused</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Options API (Traditional Vue Style)</b></li>
    <br/>
    <ul>
        <li>The Options API organizes code into <u>sections</u> inside a component:</li>
        <ul>
            <li><code>data()</code></li>
            <li><code>methods</code></li>
            <li><code>computed</code></li>
            <li><code>watch</code></li>
            <li><code>props</code></li>
        </ul>
        <br/>
        <li>This style is easy for beginners because logic is grouped by <u>options</u>, not by <u>functionality</u>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    data() {
        return { count: 0 }
    },
    methods: {
        increment() {
            this.count++
        }
    },
    computed: {
        double() {
            return this.count * 2
        }
    }
}
</code></pre>
    <ul>
        <li>Good for small to medium components, beginners, simple logic.</li>
    </ul>

    <br/><br/>



    <li><b>Composition API (Modern Vue Style)</b></li>
    <br/>
    <ul>
        <li>Composition API moves logic into the <code>setup()</code> function.</li>
        <br/>
        <li>You create reactive variables using:</li>
        <ul>
            <li><code>ref()</code></li>
            <li><code>reactive()</code></li>
            <li><code>computed()</code></li>
            <li><code>watch()</code></li>
        </ul>
        <br/>
        <li>This style is more flexible, easier to scale, and ideal for complex apps.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

export default {
    setup() {
        const count = ref(0)
        const increment = () =&gt; count.value++
        const double = computed(() =&gt; count.value * 2)

        return { count, increment, double }
    }
}
</code></pre>
    <ul>
        <li>Good for large projects, reusable logic, TypeScript support.</li>
    </ul>

    <br/><br/>



    <li><b>Key Differences</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Code organization</td>
                <td>Grouped by <b>option</b> (data, methods, computed)</td>
                <td>Grouped by <b>logic</b> and feature</td>
            </tr>
            <tr>
                <td>Learning curve</td>
                <td>Easier for beginners</td>
                <td>Requires understanding of JS functions and reactivity</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Implicit (<code>this.count++</code>)</td>
                <td>Explicit (<code>ref</code>, <code>reactive</code>, <code>value</code>)</td>
            </tr>
            <tr>
                <td>Logic reuse</td>
                <td>Mixins (old, limited)</td>
                <td>Composable functions (modern, powerful)</td>
            </tr>
            <tr>
                <td>Scaling to large apps</td>
                <td>More difficult</td>
                <td>Much easier</td>
            </tr>
            <tr>
                <td>TypeScript support</td>
                <td>Limited</td>
                <td>Excellent</td>
            </tr>
            <tr>
                <td>IDE autocompletion</td>
                <td>Less precise (due to <code>this</code>)</td>
                <td>Very precise (explicit types &amp; refs)</td>
            </tr>
            <tr>
                <td>Recommended for Vue 3?</td>
                <td>Still supported &amp; fine</td>
                <td><b>Yes, the future direction</b></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When to Use Which?</b></li>
    <br/>
    <ul>
        <li><b>Use Options API if:</b>
            <ul>
                <li>you are a beginner</li>
                <li>your component is small</li>
                <li>your team prefers classic Vue</li>
            </ul>
        </li>
        <br/>
        <li><b>Use Composition API if:</b>
            <ul>
                <li>your application is large</li>
                <li>you want reusable logic</li>
                <li>you use TypeScript</li>
                <li>you need more flexibility</li>
                <li>you want better structure for complex features</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Example Comparison (Same Component in Both APIs)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
<pre><code class="language-js line-numbers">export default {
    data() {
        return { count: 0 }
    },
    methods: {
        increment() {
            this.count++
        }
    }
}
</code></pre>
                </td>
                <td>
<pre><code class="language-js line-numbers">import { ref } from "vue"

export default {
    setup() {
        const count = ref(0)
        const increment = () =&gt; count.value++
        return { count, increment }
    }
}
</code></pre>
                </td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ease of use</td>
                <td>Very easy</td>
                <td>Medium</td>
            </tr>
            <tr>
                <td>Flexibility</td>
                <td>Limited</td>
                <td>Very high</td>
            </tr>
            <tr>
                <td>Logic organization</td>
                <td>Separated by option</td>
                <td>Grouped by feature</td>
            </tr>
            <tr>
                <td>Preferred for new Vue 3 apps?</td>
                <td>Okay</td>
                <td><b>Yes</b></td>
            </tr>
            <tr>
                <td>TypeScript</td>
                <td>Not ideal</td>
                <td><b>Excellent</b></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-composition-api">Introduction to the Vue 3 Composition API (Thorough & Beginner-Friendly)</h3>
<ol>
    <li><b>Short Intro</b></li>
    <br/>
    <ul>
        <li>The <code>Composition API</code> is a modern way to write Vue components using plain JavaScript functions.</li>
        <br/>
        <li>It was introduced in Vue 3 and offers:
            <ul>
                <li>better logic organization</li>
                <li>cleaner code for complex components</li>
                <li>excellent TypeScript support</li>
                <li>more powerful code reuse</li>
            </ul>
        </li>
        <br/>
        <li>Instead of putting logic in separate blocks (<code>data</code>, <code>computed</code>, <code>methods</code>), everything lives together inside <code>setup()</code>.</li>
    </ul>
    <br/><br/>



    <li><b>The Setup Function</b></li>
    <br/>
    <ul>
        <li><code>setup()</code> is the entry point for the Composition API in a component.</li>
        <li>It runs before the component is created and returns what the template can use.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    setup() {
        return {
            // expose things to the template
        }
    }
}
</code></pre>
    <ul>
        <li>Everything used by the template must be returned from <code>setup()</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Creating Reactive State with ref()</b></li>
    <br/>
    <ul>
        <li><code>ref()</code> creates a reactive value.</li>
        <li>Use it for primitives (numbers, strings, booleans).</li>
        <li>The actual value lives in <code>.value</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref } from "vue"

export default {
    setup() {
        const count = ref(0)

        function increment() {
            count.value++
        }

        return { count, increment }
    }
}
</code></pre>
    <ul>
        <li><b>Important:</b> In templates, Vue automatically unwraps <code>ref</code>. No need to use <code>.value</code> inside HTML.</li>
    </ul>

    <br/><br/>



    <li><b>Reactive Objects with reactive()</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> creates a reactive object.</li>
        <li>Use it for collections or multiple related values.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive } from "vue"

export default {
    setup() {
        const state = reactive({
            name: "Hwangfu",
            age: 22
        })

        return { state }
    }
}
</code></pre>
    <ul>
        <li>Reactive objects behave like normal JS objects but trigger UI updates when mutated.</li>
    </ul>

    <br/><br/>



    <li><b>Computed Properties</b></li>
    <br/>
    <ul>
        <li><code>computed()</code> creates values that update automatically when dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

export default {
    setup() {
        const count = ref(5)
        const double = computed(() =&gt; count.value * 2)

        return { count, double }
    }
}
</code></pre>
    <ul>
        <li>Computed properties are cached and recomputed only when needed.</li>
    </ul>

    <br/><br/>



    <li><b>Watchers</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> runs a callback when reactive data changes.</li>
        <li>Good for asynchronous operations, API calls, or side effects.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

export default {
    setup() {
        const name = ref("")

        watch(name, (newVal, oldVal) =&gt; {
            console.log("Changed from", oldVal, "to", newVal)
        })

        return { name }
    }
}
</code></pre>

    <br/><br/>



    <li><b>watchEffect()</b> (Automatic Tracking)</li>
    <br/>
    <ul>
        <li><code>watchEffect()</code> tracks all reactive values inside it automatically.</li>
        <li>It re-runs itself whenever dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watchEffect } from "vue"

export default {
    setup() {
        const x = ref(1)

        watchEffect(() =&gt; {
            console.log("x is", x.value)
        })

        return { x }
    }
}
</code></pre>

    <br/><br/>



    <li><b>Methods in Composition API</b></li>
    <br/>
    <ul>
        <li>There is no <code>methods</code> section.</li>
        <li>You simply define functions inside <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">setup() {
    const count = ref(0)

    function increment() {
        count.value++
    }

    return { count, increment }
}
</code></pre>

    <br/><br/>



    <li><b>Lifecycles in Composition API</b></li>
    <br/>
    <ul>
        <li>Instead of Options API lifecycle hooks (<code>mounted</code>, <code>created</code>), Composition API uses importable functions.</li>
    </ul>

<pre><code class="language-js line-numbers">import { onMounted, onUnmounted } from "vue"

export default {
    setup() {
        onMounted(() =&gt; {
            console.log("Component mounted")
        })

        onUnmounted(() =&gt; {
            console.log("Component removed")
        })
    }
}
</code></pre>

    <br/>
    <ul>
        <li>Other hooks:
            <ul>
                <li><code>onMounted</code></li>
                <li><code>onUpdated</code></li>
                <li><code>onUnmounted</code></li>
                <li><code>onBeforeMount</code></li>
                <li><code>onBeforeUpdate</code></li>
                <li><code>onBeforeUnmount</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Props in Composition API</b></li>
    <br/>
    <ul>
        <li>Props are received as arguments to <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    props: {
        msg: String;
    },

    setup(props) {
        console.log(props.msg);
        return { };
    }
}
</code></pre>

    <br/><br/>



    <li><b>Emitting Events</b></li>
    <br/>
    <ul>
        <li>You receive <code>emit</code> as the second argument in <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
    emits: ["update"],

    setup(props, { emit }) {
        function updateValue() {
            emit("update", 42)
        }

        return { updateValue }
    }
}
</code></pre>

    <br/><br/>



    <li><b>Extracting Logic Into Composables</b></li>
    <br/>
    <ul>
        <li>The Composition API allows you to reuse logic by creating <b>composable functions</b>.</li>
        <li>These are just plain JS functions that return reactive state.</li>
    </ul>

<pre><code class="language-js line-numbers">// useCounter.js
import { ref } from "vue"

export function useCounter() {
    const count = ref(0)
    const increment = () =&gt; count.value++
    return { count, increment }
}
</code></pre>

<pre><code class="language-js line-numbers">// Component.vue
import { useCounter } from "./useCounter"

export default {
    setup() {
        const { count, increment } = useCounter()
        return { count, increment }
    }
}
</code></pre>

    <br/><br/>



    <li><b>Why the Composition API Is Powerful</b></li>
    <br/>
    <ul>
        <li>Flexible code structure</li>
        <li>Easier for large teams</li>
        <li>Better logic reuse (composables)</li>
        <li>Works extremely well with TypeScript</li>
        <li>No complex mixins or inheritance needed</li>
        <li>Cleaner separation of features</li>
    </ul>

    <br/><br/>



    <li><b>Options API vs Composition API Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Organization</td>
                <td>By option type (data, methods, etc.)</td>
                <td>By logic/functionality</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Implicit <code>this</code></td>
                <td>Explicit <code>ref</code>, <code>reactive</code></td>
            </tr>
            <tr>
                <td>Logic reuse</td>
                <td>mixins</td>
                <td>composables</td>
            </tr>
            <tr>
                <td>TypeScript</td>
                <td>not ideal</td>
                <td>excellent</td>
            </tr>
            <tr>
                <td>Best for</td>
                <td>small/simple components</td>
                <td>medium/large apps, reusable logic</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-reactive-value">What Is a Reactive Value in Vue?</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>It allows the UI to update automatically whenever your data changes.</li>
        <br/>
        <li>A <u>reactive value</u> is any value that Vue tracks internally so it can update the DOM when the value changes.</li>
        <br/>
        <li>In Vue 3 (Composition API), reactivity is created using:</li>
        <ul>
            <li><code>ref()</code> — for reactive primitives</li>
            <li><code>reactive()</code> — for reactive objects</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Why Reactivity Matters</b></li>
    <br/>
    <ul>
        <li>In plain JavaScript, changing a variable does <u>not</u> update the UI automatically.<br/>
            You would have to manually modify the DOM:</li>
    </ul>

<pre><code class="language-js line-numbers">let count = 0
document.getElementById("counter").innerText = count
count++
document.getElementById("counter").innerText = count
</code></pre>
    <ul>
        <li>This is slow, repetitive, and error-prone.</li>
        <br/>
        <li>In Vue, you update the variable → UI updates automatically.</li>
    </ul>

<pre><code class="language-js line-numbers">const count = ref(0)
count.value++  // UI updates automatically
</code></pre>

    <br/><br/>



    <li><b>ref(): Reactive Primitive Values</b></li>
    <br/>
    <ul>
        <li><code>ref()</code> wraps a value inside an object with a single property: <code>value</code>.</li>
        <li>This wrapper is reactive.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref } from "vue"

const count = ref(0)
console.log(count.value)  // 0

count.value++
console.log(count.value)  // 1
</code></pre>
    <ul>
        <li>Why <code>.value</code>?</li>
        <ul>
            <li>Because JavaScript primitives (number, string, boolean) cannot be made reactive by themselves.</li>
            <li>Vue wraps them in an object to track changes.</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>reactive(): Reactive Objects (Deep Reactivity)</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> makes an entire object reactive.</li>
        <li>All nested properties also become reactive.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive } from "vue"

const user = reactive({
    name: "Hwangfu",
    age: 22
})

user.age++  // automatically updates UI
</code></pre>

    <br/>
    <ul>
        <li>This is called <u>deep reactivity</u>, where every property is tracked.</li>
    </ul>
    <br/><br/>



    <li><b>How Vue Detects Changes (The Proxy System)</b></li>
    <br/>
    <ul>
        <li>Vue 3 uses the <b>JavaScript Proxy API</b> to intercept operations on reactive values:</li>
        <ul>
            <li>reading</li>
            <li>writing</li>
            <li>deleting</li>
        </ul>
        <br/>
        <li>Whenever a reactive property is read, Vue records the dependency.</li>
        <br/>
        <li>Whenever it’s changed, Vue schedules a UI update.</li>
    </ul>
    <br/><br/>



    <li><b>Reactive Values in Templates</b></li>
    <br/>
    <ul>
        <li>In Vue templates, ref values are <u>auto-unwrapped</u>.</li>
        <li>This means you do NOT write <code>.value</code> in templates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>

    <br/>
    <ul>
        <li>Even though <code>count</code> is a <code>ref</code>, Vue unwraps <code>.value</code> for convenience.</li>
    </ul>

    <br/><br/>



    <li><b>Computed Properties Are Also Reactive</b></li>
    <br/>
    <ul>
        <li><code>computed()</code> returns a special read-only reactive value.</li>
        <li>It updates whenever its dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

const count = ref(5)
const double = computed(() =&gt; count.value * 2)

console.log(double.value) // 10
count.value++
console.log(double.value) // 12
</code></pre>

    <br/><br/>



    <li><b>Watchers React to Changes</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> listens for changes in reactive values.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(count, (newVal, oldVal) =&gt; {
    console.log("Count changed:", oldVal, "-&gt;", newVal)
})
</code></pre>

    <br/><br/>



    <li><b>How Reactivity Differs from Plain JavaScript</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Plain JavaScript</th>
                <th>Vue Reactive Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Variables don't update UI automatically</td>
                <td>UI updates instantly when reactive value changes</td>
            </tr>
            <tr>
                <td>No dependency tracking</td>
                <td>Automatic dependency tracking</td>
            </tr>
            <tr>
                <td>Manual DOM updates needed</td>
                <td>DOM updates handled by Vue</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>ref vs reactive (Quick Comparison)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>ref()</th>
                <th>reactive()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Main use-case</td>
                <td>single primitive</td>
                <td>objects, arrays, maps</td>
            </tr>
            <tr>
                <td>Access</td>
                <td><code>value</code> property</td>
                <td>direct property access</td>
            </tr>
            <tr>
                <td>Deep reactivity</td>
                <td>No (wrapping only)</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Template auto-unwrapping</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When Should You Use ref()?</b></li>
    <br/>
    <ul>
        <li>primitive values (number, string, boolean)</li>
        <li>single reactive state</li>
        <li>you need full control over reactivity</li>
    </ul>

<pre><code class="language-js line-numbers">const isVisible = ref(true)
const count = ref(0)
const message = ref("Hello")
</code></pre>

    <br/><br/>



    <li><b>When Should You Use reactive()?</b></li>
    <br/>
    <ul>
        <li>objects</li>
        <li>arrays</li>
        <li>complex state</li>
    </ul>

<pre><code class="language-js line-numbers">const form = reactive({
    email: "",
    password: "",
    remember: false
})
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-create-app">Creating a Vue Application</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Vue 3, a "Vue application" is created with <code>createApp()</code> and mounted onto a DOM element.</li>
        <br/>
        <li>We will assume the <code>Composition API</code> by default (with <code>setup()</code>, <code>ref()</code>, etc.).</li>
        <br/>
        <li>There are two common ways to start a Vue app:
            <ul>
                <li><b>Quick test</b>: use Vue from a <u>CDN script</u> in a single HTML file</li>
                <li><b>Real project</b>: use a <u>build tool</u> (e.g. Vite with <code>npm create vue@latest</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Quick Start with CDN (Single HTML File)</b></li>
    <br/>
    <ul>
        <li>This is the fastest way to experiment with Vue.</li>
        <li>No build step, no bundler – just an HTML file and a script tag.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Vue 3 App&lt;/title&gt;
    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;button @click="count++"&gt;Clicked {{ count }} times&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        const { createApp, ref } = Vue;

        const App = {
            setup() {
                const title = ref("Hello Vue 3");
                const count = ref(0);

                return { title, count };
            }
        };

        createApp(App).mount("#app");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <ul>
        <li>Key points:
            <ul>
                <li><code>createApp(App)</code> creates a Vue application instance.</li>
                <li><code>.mount("#app")</code> tells Vue to control the <code>&lt;div id="app"&gt;</code>.</li>
                <li>The component object <code>App</code> uses the <b>Composition API</b> via <code>setup()</code>.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Real Project Setup with Vite (Recommended)</b></li>
    <br/>
    <ul>
        <li>For real apps, use a modern build tool. The recommended way is Vite with the official Vue starter.</li>
    </ul>

<pre><code class="language-bash line-numbers"># 1. Create a new Vue 3 + Vite project
npm create vue@latest my-vue-app

# 2. Move into the folder
cd my-vue-app

# 3. Install dependencies
npm install

# 4. Start dev server
npm run dev
</code></pre>
    <ul>
        <li>Then open the URL shown in the terminal (usually <code>http://localhost:5173</code>).</li>
        <li>You will see a default Vue starter page.</li>
    </ul>
    <br/><br/>



    <li><b>Project Structure (Typical Vite + Vue App)</b></li>
    <br/>

<pre><code class="language-text line-numbers">my-vue-app/
  ├─ index.html
  ├─ package.json
  ├─ vite.config.js
  └─ src/
      ├─ main.js
      ├─ App.vue
      └─ components/
          └─ ...
</code></pre>
    <ul>
        <li><code>index.html</code>: main HTML entry file.</li>
        <li><code>src/main.js</code>: JS entry where the Vue app is created and mounted.</li>
        <li><code>src/App.vue</code>: root Vue component.</li>
        <li><code>src/components/</code>: other components you create.</li>
    </ul>
    <br/><br/>



    <li><b>main.js: Creating and Mounting the Application</b></li>
    <br/>
    <ul>
        <li>The <code>main.js</code> file usually looks like this:</li>
    </ul>

<pre><code class="language-js line-numbers">import { createApp } from "vue"
import App from "./App.vue"

const app = createApp(App)

// here you can also use plugins, router, store, etc.
// e.g. app.use(router)

app.mount("#app")
</code></pre>
    <ul>
        <li>Here you:
            <ul>
                <li>import the root component <code>App</code></li>
                <li>create the application instance with <code>createApp(App)</code></li>
                <li>mount it to the DOM element with id <code>app</code> (defined in <code>index.html</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>index.html: The Mount Point</b></li>
<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;My Vue App&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;!-- Vite will inject the compiled JS here --&gt;
        &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <ul>
        <li>The <code>&lt;div id="app"&gt;</code> is the “root” of your Vue application.</li>
        <li>Everything your Vue app renders will appear inside this element.</li>
    </ul>
    <br/><br/>



    <li><b>App.vue: Root Component with Composition API</b></li>
    <br/>
    <ul>
        <li><code>App.vue</code> is a Single File Component (SFC) with three main sections:</li>
        <ul>
            <li><code>&lt;template&gt;</code>: HTML markup</li>
            <li><code>&lt;script&gt;</code> (or <code>&lt;script setup&gt;</code>): logic</li>
            <li><code>&lt;style&gt;</code>: CSS</li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;main&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;button @click="count++"&gt;
            Clicked {{ count }} times
        &lt;/button&gt;
    &lt;/main&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("My First Vue App")
const count = ref(0)
&lt;/script&gt;

&lt;style&gt;
main {
    font-family: system-ui, sans-serif;
}
button {
    margin-top: 1rem;
}
&lt;/style&gt;
</code></pre>
    <ul>
        <li>Using <code>&lt;script setup&gt;</code> is the recommended Vue 3 style:
            <ul>
                <li>No need to explicitly write <code>export default</code>.</li>
                <li>All top-level variables are automatically exposed to the template.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Adding Another Component</b></li>
    <br/>
    <ul>
        <li>Create a component in <code>src/components/Counter.vue</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;Local count: {{ count }}&lt;/p&gt;
        &lt;button @click="count++"&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count = ref(0)
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Then import and use it in <code>App.vue</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;main&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;Counter /&gt;
    &lt;/main&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"
import Counter from "./components/Counter.vue"

const title = ref("My Vue App")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Development vs Production</b></li>
    <br/>
    <ul>
        <li>During development, you run a dev server:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm run dev
</code></pre>

    <br/>
    <ul>
        <li>For production, you build static files:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm run build
npm run preview   # optional: preview the production build locally
</code></pre>
    <ul>
        <li>The build output (usually in <code>dist/</code>) can be deployed to any static file server.</li>
    </ul>
    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Step</th>
                <th>What Happens</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Create project</td>
                <td>Use <code>npm create vue@latest</code> to scaffold a Vue 3 app</td>
            </tr>
            <tr>
                <td>Entry file</td>
                <td><code>main.js</code> imports <code>App.vue</code> and calls <code>createApp(App).mount("#app")</code></td>
            </tr>
            <tr>
                <td>Root component</td>
                <td><code>App.vue</code> defined using Composition API (<code>&lt;script setup&gt;</code>, <code>ref()</code>)</td>
            </tr>
            <tr>
                <td>DOM mount point</td>
                <td><code>&lt;div id="app"&gt;</code> in <code>index.html</code></td>
            </tr>
            <tr>
                <td>Components</td>
                <td>More components go into <code>src/components/</code> and are imported into <code>App.vue</code> or others</td>
            </tr>
            <tr>
                <td>Dev server</td>
                <td><code>npm run dev</code> for live reload while coding</td>
            </tr>
            <tr>
                <td>Production build</td>
                <td><code>npm run build</code> to create optimized static files</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-template-syntax">Template Syntax in Vue</h3>
<ol>
    <li><b>What Is the Template?</b></li>
    <br/>
    <ul>
        <li>In Vue, a <code>template</code> is the HTML-like part of your component that describes what should be rendered.</li>
        <br/>
        <li>With the Composition API, you usually write templates in <code>.vue</code> Single File Components:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("Hello from Vue")
const count = ref(0)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Everything you define in <code>&lt;script setup&gt;</code> is directly usable inside the template (no <code>this</code> keyword).</li>
    </ul>

    <br/><br/>



    <li><b>Text Interpolation with <code>{{ }}</code> (Just like in Angular)</b></li>
    <br/>
    <ul>
        <li>The most basic template feature is <u>interpolation</u> using double curly braces.</li>
        <li>It displays the value of a JavaScript expression as text.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("Welcome")
const name = ref("User")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You can only put one <u>expression</u> inside <code>{{ }}</code>, not full statements or <code>if</code> / <code>for</code> blocks.</li>
    </ul>

    <br/><br/>



    <li><b>Using Simple JavaScript Expressions</b></li>
    <br/>
    <ul>
        <li>You can use simple JS expressions inside <code>{{ }}</code>:</li>
        <ul>
            <li>arithmetic: <code>{{ count + 1 }}</code></li>
            <li>string operations: <code>{{ firstName + " " + lastName }}</code></li>
            <li>ternary: <code>{{ isAdmin ? "Admin" : "User" }}</code></li>
            <li>function calls: <code>{{ formatName(user) }}</code></li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p&gt;Next: {{ count + 1 }}&lt;/p&gt;
    &lt;p&gt;Full name: {{ firstName + " " + lastName }}&lt;/p&gt;
    &lt;p&gt;Role: {{ isAdmin ? "Admin" : "User" }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count     = ref(1)
const firstName = ref("Junzhe")
const lastName  = ref("Hwangfu")
const isAdmin   = ref(false)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Raw HTML with <code>v-html</code> (Be Careful)</b></li>
    <br/>
    <ul>
        <li>By default, <code>{{ }}</code> escapes HTML (e.g., <code>&gt;</code> automatically becomes <code>&amp;gt;</code>) for safety.</li>
        <li>If you really need to render HTML from a string, use <code>v-html</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p&gt;Normal: {{ rawHtml }}&lt;/p&gt;
    &lt;p v-html="rawHtml"&gt;&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
const rawHtml = "&lt;strong&gt;This is bold&lt;/strong&gt;"
&lt;/script&gt;
</code></pre>

    <ul>
        <li><b>WARN:</b> Never use <code>v-html</code> with untrusted user input. It can cause XSS security problems.</li>
    </ul>

    <br/><br/>



    <li><b>Attribute Binding with <code>v-bind:</code> / <code>:</code></b></li>
    <br/>
    <ul>
        <li>Use <code>v-bind:</code> to bind an attribute to a JS expression.</li>
        <li>Short form is a single colon (<code>:</code>).</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;a :href="profileUrl"&gt;Go to profile&lt;/a&gt;
    &lt;img :src="avatarUrl" :alt="username" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
const profileUrl = "https://example.com/user/hwangfu"
const avatarUrl  = "/images/avatar.png"
const username   = "Hwangfu"
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You can even bind to boolean attributes:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;button :disabled="isLoading"&gt;
    {{ isLoading ? "Loading..." : "Submit" }}
&lt;/button&gt;
</code></pre>

    <br/><br/>


    <li><b>Binding <code>class</code> and <code>style</code></b></li>
    <br/>
    <ul>
        <li>Vue makes dynamic classes and styles very convenient.</li>
        <li>You can bind strings, objects, or arrays, but Vue always converts them into normal HTML.</li>
        <li>When using an object, the <u>keys</u> are class/style names and the <u>values</u> are booleans or expressions.</li>
        <li>Vue builds the final <code>class=""</code> or <code>style=""</code> string automatically.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;!-- Dynamic classes --
         Vue evaluates the object and produces a normal class string.
         With isActive=true and hasError=false, the final HTML becomes:
         &lt;p class="active"&gt;
    --&gt;
    &lt;p :class="{ active: isActive, error: hasError }"&gt;
        Status text
    &lt;/p&gt;

    &lt;!-- Dynamic inline styles --
         Vue converts the object to a real style attribute:
         style="color: blue; font-size: 18px;"
    --&gt;
    &lt;div :style="{ color: textColor, fontSize: size + 'px' }"&gt;
        Styled text
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const isActive  = ref(true)
const hasError  = ref(false)

const textColor = ref("blue")
const size      = ref(18)
&lt;/script&gt;
</code></pre>

    <br/><br/>




    <li><b>Conditional Rendering: <code>v-if</code>, <code>v-else-if</code>, <code>v-else</code>, <code>v-show</code></b></li>
    <br/>
    <ul>
        <li><code>v-if</code> actually adds/removes elements from the DOM.</li>
        <li><code>v-show</code> toggles the <code>display</code> CSS property (faster when toggling often).</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;p v-if="loggedIn"&gt;Welcome back!&lt;/p&gt;
    &lt;p v-else&gt;Please log in.&lt;/p&gt;

    &lt;p v-show="showDetails"&gt;
        These details can be quickly shown/hidden.
    &lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const loggedIn    = ref(false)
const showDetails = ref(true)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>List Rendering with <code>v-for</code> and <code>key</code></b></li>
    <br/>
    <ul>
        <li><code>v-for</code> renders a list by iterating over arrays or objects.</li>
        <li>Always provide a unique <code>:key</code> for better performance and stable updates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="user in users" :key="user.id"&gt;
            {{ user.name }} ({{ user.age }})
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup&gt;
const users = [
    { id: 1, name: "Alice", age: 23 },
    { id: 2, name: "Bob", age: 31 },
    { id: 3, name: "Charlie", age: 27 }
]
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Event Handling with <code>v-on:</code> / <code>@</code></b></li>
    <br/>
    <ul>
        <li>Use <code>v-on:</code> (or <code>@</code>) to listen to DOM events.</li>
        <li>You can call methods or inline expressions.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;button @click="increment"&gt;
        Clicked {{ count }} times
    &lt;/button&gt;

    &lt;input
        type="text"
        placeholder="Type something"
        @input="onInput"
    /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count = ref(0)

function increment() {
    count.value++
}

function onInput(event) {
    console.log("You typed:", event.target.value)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Two-Way Binding with <code>v-model</code> (Quick Overview)</b></li>
    <br/>
    <ul>
        <li><code>v-model</code> connects a <b>form input</b> with a reactive value in both directions.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input v-model="name" placeholder="Your name" /&gt;
    &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const name = ref("")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Typing in the input updates <code>name</code>, and changing <code>name</code> in code updates the input.</li>
    </ul>

    <br/><br/>



    <li><b>Directive Shorthands (Cheat Sheet)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Full Form</th>
                <th>Shorthand</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>v-bind:href="url"</code></td>
                <td><code>:href="url"</code></td>
                <td>Bind an attribute to an expression</td>
            </tr>
            <tr>
                <td><code>v-on:click="doSomething"</code></td>
                <td><code>@click="doSomething"</code></td>
                <td>Listen to an event</td>
            </tr>
            <tr>
                <td><code>v-model="value"</code></td>
                <td>none</td>
                <td>Two-way binding</td>
            </tr>
            <tr>
                <td><code>v-if="condition"</code></td>
                <td>none</td>
                <td>Conditional rendering</td>
            </tr>
            <tr>
                <td><code>v-for="item in items"</code></td>
                <td>none</td>
                <td>List rendering</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-watchers">Watchers in Vue (Composition API)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>watcher</code> in Vue lets you run code in response to changes in reactive values.</li>
        <br/>
        <li>Watchers are useful when you need to perform <u>side effects</u> such as:
            <ul>
                <li>fetching data when a value changes</li>
                <li>saving values to localStorage</li>
                <li>debouncing expensive operations</li>
                <li>logging or debugging</li>
            </ul>
        </li>
        <br/>
        <li>In the Composition API, watchers are created using:
            <ul>
                <li><code>watch()</code></li>
                <li><code>watchEffect()</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>watch(): Watching Specific Reactive Sources</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> tracks one or more <u>explicit</u> reactive values and calls a callback when they change.</li>
        <li>It provides both the <code>new</code> and <code>old</code> values.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

const name = ref("")

watch(name, (newValue, oldValue) =&gt; {
    console.log("Changed:", oldValue, "--&gt;", newValue)
})
</code></pre>

    <ul>
        <li>The callback only runs when <code>name</code> changes.</li>
    </ul>

    <br/><br/>



    <li><b>Watching Multiple Sources</b></li>
    <br/>
    <ul>
        <li>You can watch several values by passing an array.</li>
    </ul>

<pre><code class="language-js line-numbers">const first = ref("")
const last  = ref("")

watch([first, last], ([newFirst, newLast], [oldFirst, oldLast]) =&gt; {
    console.log("First:", oldFirst, "--&gt;", newFirst)
    console.log("Last:", oldLast, "--&gt;", newLast)
})
</code></pre>

    <br/><br/>



    <li><b>Watching Reactive Objects</b></li>
    <br/>
    <ul>
        <li>When watching a <code>reactive()</code> object, Vue only tracks changes if you set <code>{ deep: true }</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive, watch } from "vue"

const user = reactive({
    name: "Alice",
    age: 25
})

watch(user, (newVal, oldVal) =&gt; {
    console.log("User changed!")
}, { deep: true })
</code></pre>

    <ul>
        <li><b>NOTE:</b> For objects, Vue <u>cannot</u> give meaningful <code>oldValue</code> because the object is mutated.</li>
    </ul>

    <br/><br/>



    <li><b>Watching a Getter Function</b></li>
    <br/>
    <ul>
        <li>Often you want to watch <u>one part</u> of a reactive object.</li>
        <li>You can pass a function that returns the value you want to track.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(
    () =&gt; user.age,
    (newAge, oldAge) =&gt; {
        console.log("Age changed:", oldAge, "--&gt;", newAge)
    }
)
</code></pre>

    <br/><br/>


    <li><b>Immediate Watchers</b></li>
    <br/>
    <ul>
        <li>Normally, a watcher runs only when the watched value <u>changes</u>.</li>
        <li><code>{ immediate: true }</code>
            tells Vue to run the watcher callback immediately once when the watcher is <u>created</u>,
            even before any changes happen, using the current value of the watched ref.
        </li>
        <li>After that first run, it continues watching as usual.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(
    count,
    (newVal, oldVal) =&gt; {
        console.log("Watcher triggered:", newVal)
    },
    {
        // Run once immediately with the current value
        immediate: true
    }
)
</code></pre>

    <br/><br/>




    <li><b>watchEffect(): Automatic Dependency Tracking</b></li>
    <br/>
    <ul>
        <li><code>watchEffect()</code> runs a function immediately and re-runs it whenever <u>any</u> reactive value inside it changes.</li>
        <li>You do NOT specify what to watch, Vue figures it out.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watchEffect } from "vue"

const count = ref(0)

watchEffect(() =&gt; {
    console.log("Count is", count.value)
})
</code></pre>

    <ul>
        <li>Great for debugging or when watching several related values.</li>
    </ul>

    <br/><br/>



    <li><b>watch vs watchEffect (Comparison)</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>watch()</th>
                <th>watchEffect()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Tracks values</td>
                <td>Explicitly listed values</td>
                <td>Automatically detects dependencies</td>
            </tr>
            <tr>
                <td>First run</td>
                <td>Only when changed (unless <code>immediate</code>)</td>
                <td>Runs immediately</td>
            </tr>
            <tr>
                <td>Best for</td>
                <td>side effects on specific values</td>
                <td>complex reactive logic, debugging</td>
            </tr>
            <tr>
                <td>Old value available?</td>
                <td>Yes (for refs)</td>
                <td>No</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Cleanup (Stopping Watchers)</b></li>
    <br/>
    <ul>
        <li>Both <code>watch()</code> and <code>watchEffect()</code> return a function that stops the watcher.</li>
    </ul>

<pre><code class="language-js line-numbers">const stop = watch(count, () =&gt; {
    console.log("count changed")
})

// Later:
stop()
</code></pre>

    <br/><br/>



    <li><b>Practical Example: Fetching from an API</b></li>
    <br/>
    <ul>
        <li>A very common real use-case is fetching data when a reactive value changes.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

const search = ref("")
const results = ref([])

watch(search, async (term) =&gt; {
    if (term.length &lt; 3) {
        results.value = []
        return
    }

    const res = await fetch(`/api/search?q=${term}`)
    results.value = await res.json()
})
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>watch()</code></td>
                <td>Tracks specific reactive values and gives access to old/new values</td>
            </tr>
            <tr>
                <td><code>watchEffect()</code></td>
                <td>Runs immediately and re-runs whenever any dependency changes</td>
            </tr>
            <tr>
                <td>Deep watch</td>
                <td>Needed to observe changes inside reactive objects</td>
            </tr>
            <tr>
                <td>Immediate</td>
                <td>Runs watcher callback right away on initialization</td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Side effects such as data fetching, logging, reacting to changes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-template-refs">Template Refs in Vue</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Template refs</u> allow you to directly access DOM elements or component instances from your JavaScript code.</li>
        <li>They are useful when:
            <ul>
                <li>you need to manually focus an input</li>
                <li>you must measure elements (height/width)</li>
                <li>you interact with a canvas or third-party library</li>
                <li>you need access to a child component's exposed API</li>
            </ul>
        </li>
        <br/>
        <li>Template refs work naturally with the <b>Composition API</b> using <code>ref()</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Example: Referencing a DOM Element</b></li>
    <br/>
    <ul>
        <li>Use <code>ref=""</code> inside the template to mark an element.</li>
        <li>Inside <code>&lt;script setup&gt;</code>, create a <code>ref()</code> with the same name.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input ref="inputEl" placeholder="Type here..." /&gt;
    &lt;button @click="focusInput"&gt;Focus input&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const inputEl = ref(null)

function focusInput() {
    inputEl.value.focus()
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li><code>inputEl.value</code> becomes the actual DOM element after the component mounts.</li>
        <li>Before mount, <code>inputEl.value</code> is <code>null</code>.</li>
    </ul>

    <br/><br/>



    <li><b>When Is the Template Ref Available?</b></li>
    <br/>
    <ul>
        <li>Refs are only set after the component is mounted.</li>
        <li>To run code immediately after mounting, use <code>onMounted()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, onMounted } from "vue"

const box = ref(null)

onMounted(() =&gt; {
    console.log("Box height:", box.value.offsetHeight)
})
</code></pre>

    <br/><br/>



    <li><b>Template Refs with Components</b></li>
    <br/>
    <ul>
        <li>You can also reference child components, not just DOM elements.</li>
        <li>A child component must explicitly <u>expose</u> what it wants the parent to access.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Child ref="childComp" /&gt;
    &lt;button @click="childComp.increment"&gt;Call child method&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"
import Child from "./Child.vue"

const childComp = ref(null)
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;script setup&gt;
import { ref } from "vue"
import { defineExpose } from "vue"

const count = ref(0)
function increment() { count.value++ }

defineExpose({
    count,
    increment
})
&lt;/script&gt;

&lt;template&gt;
    &lt;p&gt;{{ count }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li><code>defineExpose()</code> is required to make component methods/state available via refs.</li>
        <li>Otherwise the parent cannot access them.</li>
    </ul>

    <br/><br/>



    <li><b>Binding Refs in <code>v-for</code></b></li>
    <br/>
    <ul>
        <li>A common use-case: getting references to multiple elements.</li>
        <li>Vue automatically gives you an array or an object depending on how you bind the ref.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;ul&gt;
        &lt;li
            v-for="(user, index) in users"
            :key="user.id"
            :ref="setItemRef"
        &gt;
            {{ user.name }}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
]

const itemRefs = ref([])

function setItemRef(el) {
    if (el) itemRefs.value.push(el)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Now <code>itemRefs.value</code> is an array of DOM elements.</li>
    </ul>

    <br/><br/>



    <li><b>Using <code>template ref</code> for Non-DOM Purposes</b></li>
    <br/>
    <ul>
        <li>You can store anything in a ref assigned via the template.</li>
        <li>Example: Registering canvas contexts, chart instances, editors, etc.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;canvas ref="canvas" width="200" height="200"&gt;&lt;/canvas&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from "vue"

const canvas = ref(null)

onMounted(() =&gt; {
    const ctx = canvas.value.getContext("2d")
    ctx.fillRect(10, 10, 100, 100)
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Template Ref Caveats</b></li>
    <br/>
    <ul>
        <li><b>Refs do not exist until after mount</b> → use <code>onMounted()</code>.</li>
        <li>Refs pointing to components only work if the child uses <code>defineExpose()</code>.</li>
        <li>Do not overuse refs: rely on Vue’s reactivity first.</li>
        <li>Refs are for when "declarative DOM binding" isn't enough.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>DOM refs</td>
                <td>Use <code>ref="..."</code> to access DOM elements directly</td>
            </tr>
            <tr>
                <td>Component refs</td>
                <td>Require <code>defineExpose()</code> in the child component</td>
            </tr>
            <tr>
                <td>When available</td>
                <td>After mount — use <code>onMounted()</code></td>
            </tr>
            <tr>
                <td>v-for refs</td>
                <td>Bind a function as <code>:ref</code> to collect multiple elements</td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Focus, measurements, canvas, third-party libraries</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-typescript">Using Vue with TypeScript (Vue 3 + Composition API)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue 3 has first-class TypeScript support, especially with the Composition API.</li>
        <br/>
        <li>Vue 3's <code>&lt;script setup lang="ts"&gt;</code> syntax is the recommended way to use TypeScript.</li>
    </ul>

    <br/><br/>



    <li><b>Enabling TypeScript in a Vue SFC</b></li>
    <br/>
    <ul>
        <li>To use TypeScript inside a component, simply add <code>lang="ts"</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const message = ref("Hello TypeScript")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Vue + Vite will automatically compile the TypeScript for you. No extra setup needed.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Refs</b></li>
    <br/>
    <ul>
        <li>By default, <code>ref()</code> infers the type from the initial value.</li>
    </ul>

<pre><code class="language-ts line-numbers">const count = ref(0)          // ref&lt;number&gt;
const username = ref("Alice") // ref&lt;string&gt;
</code></pre>

    <ul>
        <li>If you want to explicitly provide a type, pass a generic:</li>
    </ul>

<pre><code class="language-ts line-numbers">const age = ref&lt;number | null&gt;(null)
</code></pre>

    <br/><br/>



    <li><b>Typing Reactive Objects</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> works well with object types.</li>
    </ul>

<pre><code class="language-ts line-numbers">interface User {
    name: string
    age: number
}

const user = reactive&lt;User&gt;({
    name: "Hwangfu",
    age: 22
})
</code></pre>

    <ul>
        <li>All properties inside the reactive object have proper types.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Functions Inside Components</b></li>
    <br/>
    <ul>
        <li>Just use normal TypeScript syntax.</li>
    </ul>

<pre><code class="language-ts line-numbers">function greet(name: string): string {
    return "Hello, " + name
}
</code></pre>

    <br/><br/>



    <li><b>Typing Computed Properties</b></li>
    <br/>
    <ul>
        <li>Types are inferred automatically in most cases.</li>
    </ul>

<pre><code class="language-ts line-numbers">const count = ref(2)

const double = computed(() =&gt; count.value * 2)
// computed&lt;number&gt;
</code></pre>

    <br/>
    <ul>
        <li>You can force a type if needed:</li>
    </ul>

<pre><code class="language-ts line-numbers">const price = ref(10)

const withTax = computed&lt;number&gt;(() =&gt; price.value * 1.19)
</code></pre>

    <br/><br/>



    <li><b>Typing Props (with <code>&lt;script setup&gt;</code>)</b></li>
    <br/>
    <ul>
        <li>Props are typed using <code>defineProps&lt;&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
interface Props {
    title: string
    count?: number
}

const props = defineProps&lt;Props&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;h1&gt;{{ props.title }}&lt;/h1&gt;
    &lt;p&gt;Count: {{ props.count ?? 0 }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>Props now get full type-checking and IDE hints.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Emits</b></li>
    <br/>
    <ul>
        <li>Use <code>defineEmits&lt;&gt;</code> to type event signatures.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const emit = defineEmits&lt;{
    (event: "update", value: number): void
}&gt;()

emit("update", 42) // ✔️
emit("update")     // ❌ type error
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Template Refs</b></li>
    <br/>
    <ul>
        <li>You must annotate the type of the DOM element.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;input ref="inputEl" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue"

const inputEl = ref&lt;HTMLInputElement | null&gt;(null)

onMounted(() =&gt; {
    inputEl.value?.focus()
})
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Composables</b></li>
    <br/>
    <ul>
        <li>When writing reusable functions, add proper types to arguments and returns.</li>
    </ul>

<pre><code class="language-ts line-numbers">// useCounter.ts
import { ref } from "vue"

export function useCounter(initial = 0) {
    const count = ref(initial)

    function increment(): void {
        count.value++
    }

    return { count, increment }
}
</code></pre>

    <ul>
        <li>Now all components using this composable will have typed reactive values.</li>
    </ul>

    <br/><br/>



    <li><b>Typing Events in the Template</b></li>
    <br/>
    <ul>
        <li>Vue automatically infers the event type for DOM events.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;input @input="onInput" /&gt;

&lt;script setup lang="ts"&gt;
function onInput(event: Event) {
    const target = event.target as HTMLInputElement
    console.log(target.value)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Type Safety with <code>defineModel()</code> (Vue 3.4+)</b></li>
    <br/>
    <ul>
        <li>For custom <code>v-model</code>, you can type the value:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const modelValue = defineModel&lt;string&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;input v-model="modelValue" /&gt;
&lt;/template&gt;
</code></pre>

    <br/><br/>



    <li><b>Recommended Project Setup</b></li>
    <br/>
    <ul>
        <li>Use the official TS template:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm create vue@latest
# choose: Typescript + JSX support (optional)
</code></pre>

    <ul>
        <li>This sets up:
            <ul>
                <li><code>tsconfig.json</code></li>
                <li>full IDE support</li>
                <li>recommended type definitions</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>TypeScript Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Typing refs</td>
                <td><code>ref&lt;T&gt;(initial)</code></td>
            </tr>
            <tr>
                <td>Reactive objects</td>
                <td><code>reactive&lt;Interface&gt;({ ... })</code></td>
            </tr>
            <tr>
                <td>Props</td>
                <td><code>defineProps&lt;Props&gt;()</code></td>
            </tr>
            <tr>
                <td>Emits</td>
                <td><code>defineEmits&lt;Signatures&gt;()</code></td>
            </tr>
            <tr>
                <td>Template refs</td>
                <td><code>ref&lt;ElementType | null&gt;(null)</code></td>
            </tr>
            <tr>
                <td>Computed</td>
                <td>auto inferred or <code>computed&lt;T&gt;()</code></td>
            </tr>
            <tr>
                <td>Composables</td>
                <td>write typed functions returning reactive state</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-components-basics">Components Basics in Vue (Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Components are the building blocks of every Vue application.</li>
        <br/>
        <li>Each component represents an independent, reusable piece of UI combined with logic.</li>
        <br/>
        <li>Every component typically contains:
            <ul>
                <li>a <code>template</code>: how the UI looks</li>
                <li>a <code>script</code>: data + logic</li>
                <li>(optional) <code>style</code> — CSS</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Your First Component</b></li>
    <br/>
    <ul>
        <li>A component lives in its own <code>.vue</code> file (Single-File Component).</li>
        <li>Below is a minimal, fully typed component:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Hello.vue --&gt;
&lt;template&gt;
    &lt;h2&gt;Hello, {{ name }}!&lt;/h2&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { defineProps } from "vue";

const props = defineProps&lt;{
    name: string
}&gt;();
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The <code>name</code> value is passed from the parent component.</li>
    </ul>

    <br/><br/>



    <li><b>Using a Component</b></li>
    <br/>
    <ul>
        <li>Import and register components simply by importing them in <code>&lt;script setup&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Hello name="Junzhe" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Hello from "./components/Hello.vue";
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You do not need <code>components: { ... }</code>. Importing is enough.</li>
    </ul>

    <br/><br/>



    <li><b>Props: Passing Data into Components</b></li>
    <br/>
    <ul>
        <li>Props are the primary way to pass data from parent to child.</li>
        <li>Props are fully type-checked using <code>defineProps&lt;T&gt;()</code>.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    title:  string;
    count?: number;     // optional
}&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;h3&gt;{{ title }}&lt;/h3&gt;
    &lt;p&gt;Count: {{ count ?? 0 }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>

    <ul>
        <li>TypeScript ensures that the parent provides correct prop types.</li>
    </ul>

    <br/><br/>



    <li><b>Emits: Sending Data from Child to Parent</b></li>
    <br/>
    <ul>
        <li>Child components can send events upward using <code>defineEmits</code>.</li>
        <li>TypeScript ensures event names and payloads are correct.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Counter.vue --&gt;
&lt;template&gt;
    &lt;button @click="increment"&gt;Count is {{ count }}&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, defineEmits } from "vue";

const emit = defineEmits&lt;{
    (e: "update:count", value: number): void;
}&gt;()

const count = ref(0);

function increment() {
    count.value++;
    emit("update:count", count.value);
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Counter @update:count="val =&gt; total = val" /&gt;
    &lt;p&gt;Latest count from child: {{ total }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue";
import Counter from "./Counter.vue";

const total = ref(0);
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Highly predictable, type-safe event communication.</li>
    </ul>

    <br/><br/>



    <li><b>Component Slots: Passing Content into Children</b></li>
    <br/>
    <ul>
        <li><b>Slots</b> let parents inject custom content into children.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Card.vue --&gt;
&lt;template&gt;
    &lt;div class="card"&gt;
        &lt;slot /&gt; &lt;!-- default slot --&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Card&gt;
        &lt;p&gt;This is inside the card!&lt;/p&gt;
    &lt;/Card&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Card from "./Card.vue";
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Slots allow components to remain flexible and reusable.</li>
    </ul>

    <br/><br/>



    <li><b>Named Slots</b></li>
    <br/>
    <ul>
        <li>Named slots allow placing content into specific regions.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Layout.vue --&gt;
&lt;template&gt;
    &lt;header&gt;
        &lt;slot name="header"/&gt;
    &lt;/header&gt;

    &lt;main&gt;
        &lt;slot/&gt;
    &lt;/main&gt;

    &lt;footer&gt;
        &lt;slot name="footer"/&gt;
    &lt;/footer&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Layout&gt;
        &lt;template #header&gt;Header content&lt;/template&gt;
        Main area content
        &lt;template #footer&gt;Footer content&lt;/template&gt;
    &lt;/Layout&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Layout from "./Layout.vue"
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Component Naming Conventions</b></li>
    <br/>
    <ul>
        <li>Best practices:
            <ul>
                <li>Use PascalCase for component filenames: <code>UserCard.vue</code></li>
                <li>Use PascalCase or kebab-case in templates:
                    <ul>
                        <li><code>&lt;UserCard /&gt;</code></li>
                        <li><code>&lt;user-card /&gt;</code></li>
                    </ul>
                </li>
                <li>Keep components small &amp; focused</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Reusable Component Pattern (Full Example)</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Button.vue --&gt;
&lt;template&gt;
    &lt;button :class="variant" @click="onClick"&gt;
        &lt;slot /&gt;
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    variant?: "primary" | "secondary"
}&gt;()

const emit = defineEmits&lt;{
    (e: "click"): void
}&gt;()

function onClick() {
    emit("click")
}
&lt;/script&gt;

&lt;style scoped&gt;
.primary { padding: 6px; background: #3b82f6; color: white; }
.secondary { padding: 6px; background: #e5e7eb; }
&lt;/style&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;Button variant="primary" @click="sayHi"&gt;Say Hi&lt;/Button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Button from "./components/Button.vue"

function sayHi() {
    alert("Hello from Vue!")
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Creating components</td>
                <td>Use <code>.vue</code> SFC files with <code>&lt;script setup lang="ts"&gt;</code></td>
            </tr>
            <tr>
                <td>Props</td>
                <td>Typed via <code>defineProps&lt;T&gt;()</code> for safe inputs</td>
            </tr>
            <tr>
                <td>Emits</td>
                <td>Typed events via <code>defineEmits&lt;Signature&gt;()</code></td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Components are imported and used directly in parent templates</td>
            </tr>
            <tr>
                <td>Slots</td>
                <td>Allow flexible insertion of content</td>
            </tr>
            <tr>
                <td>Composition API + TS</td>
                <td>Provides best developer experience &amp; type safety</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-component-registration">Component Registration in Vue (Global & Local)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Component registration determines <u>where</u> a component can be used inside your app.</li>
        <br/>
        <li>Vue 3 supports:
            <ul>
                <li><code>Local Registration</code>: component usable only in the importing component</li>
                <li><code>Global Registration</code>: component usable everywhere in the app</li>
            </ul>
        </li>
        <br/>
        <li>When using <code>&lt;script setup&gt;</code> and TypeScript, registration is very simple.</li>
        <br/>
        <li>Because of tree-shaking and clarity, <u>local registration</u> is recommended for most situations.</li>
    </ul>

    <br/><br/>



    <li><b>Local Registration (Recommended)</b></li>
    <br/>
    <ul>
        <li>In <code>&lt;script setup&gt;</code>, simply <b>import</b> a component and <b>use it directly</b> in your template.</li>
        <li>No need to manually add a <code>components: { ... }</code> section.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;UserCard name="Junzhe" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import UserCard from "./UserCard.vue"
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The imported component <code>UserCard</code> is automatically available in the template.</li>
        <li>This is the most common and cleanest pattern in Vue 3.</li>
    </ul>

    <br/><br/>



    <li><b>Local Registration in Old Syntax (Not Needed with &lt;script setup&gt;)</b></li>
    <br/>
    <ul>
        <li>You may see older Vue 2 / early Vue 3 syntax:</li>
    </ul>

<pre><code class="language-js line-numbers">&lt;script lang="ts"&gt;
import { defineComponent } from "vue";
import UserCard from "./UserCard.vue";

export default defineComponent({
    components: {
        UserCard
    }
})
&lt;/script&gt;
</code></pre>

    <ul>
        <li>You should only use this when not using <code>&lt;script setup&gt;</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Global Registration</b></li>
    <br/>
    <ul>
        <li>Global registration allows you to use a component in <b>any template</b> without importing it.</li>
        <li>This is useful for:
            <ul>
                <li>very common UI elements (Button, Card, Modal)</li>
                <li>global utilities (Icon component)</li>
                <li>documentation/markdown rendering tools</li>
            </ul>
        </li>
        <br/>
        <li>You register global components in your app entry file (<code>main.ts</code> or <code>main.js</code>).</li>
    </ul>

<pre><code class="language-ts line-numbers">import { createApp } from "vue";
import App from "./App.vue";

import BaseButton from "./components/BaseButton.vue";
import BaseCard   from "./components/BaseCard.vue"  ;

const app = createApp(App);

// global registration
app.component("BaseButton", BaseButton);
app.component("BaseCard", BaseCard);

app.mount("#app");
</code></pre>

    <ul>
        <li>Now <code>&lt;BaseButton&gt;</code> and <code>&lt;BaseCard&gt;</code> can be used anywhere in the project.</li>
    </ul>

    <br/><br/>


    <li><b>Automatic Global Registration (Optional)</b></li>
    <br/>
    <ul>
        <li>You can auto-load components using Vite's <code>import.meta.glob()</code> feature.</li>
        <li>This is a powerful trick for large UI libraries.</li>
    </ul>

<pre><code class="language-ts line-numbers">const components = import.meta.glob("./components/global/*.vue", { eager: true })

for (const path in components) {
    const comp = components[path]
    const name = path.split("/").pop()!.replace(".vue", "")
    app.component(name, (comp as any).default)
}
</code></pre>

    <ul>
        <li>Every <code>.vue</code> file inside <code>components/global/</code> is registered automatically.</li>
        <li>Frameworks like Nuxt internally use similar techniques.</li>
    </ul>

    <br/><br/>


    <li><b>Local vs Global Registration (Quick Comparison)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Local Registration</th>
                <th>Global Registration</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Scope</td>
                <td>Only usable inside the importing component</td>
                <td>Usable everywhere in the app</td>
            </tr>
            <tr>
                <td>Recommended?</td>
                <td><b>Yes</b> for most components</td>
                <td>Yes for common UI elements</td>
            </tr>
            <tr>
                <td>Tree-shaking</td>
                <td>Excellent</td>
                <td>Potentially worse (less dead-code elimination)</td>
            </tr>
            <tr>
                <td>Setup style</td>
                <td>Use <code>&lt;script setup&gt;</code> import</td>
                <td>Register in <code>main.ts</code></td>
            </tr>
            <tr>
                <td>Best use-case</td>
                <td>Pages, logic-specific components</td>
                <td>Buttons, form fields, layouts, icons</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Local registration</td>
                <td>Import in <code>&lt;script setup&gt;</code> → immediately available</td>
            </tr>
            <tr>
                <td>Global registration</td>
                <td>Register with <code>app.component()</code> in <code>main.ts</code></td>
            </tr>
            <tr>
                <td>Recommended pattern</td>
                <td>Use local registration for most components</td>
            </tr>
            <tr>
                <td>Global usage</td>
                <td>Use for shared UI primitives (buttons, cards, icons)</td>
            </tr>
            <tr>
                <td>Automatic loading</td>
                <td>Possible using <code>import.meta.glob()</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-props">Props in Vue (Typed Props Composition API + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Props are how a parent component passes data to a child component.</li>
        <li>Props are <u>read-only</u> inside the child — they cannot be mutated directly.</li>
        <li>You declare props using <code>defineProps&lt;T&gt;</code> and a TypeScript interface.</li>
    </ul>

    <br/><br/>



    <li><b>Defining Typed Props</b></li>
    <br/>
    <ul>
        <li>You define props using <code>defineProps</code> in <code>&lt;script setup lang="ts"&gt;</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- UserCard.vue --&gt;
&lt;template&gt;
    &lt;h2&gt;{{ name }}&lt;/h2&gt;
    &lt;p&gt;Age: {{ age }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
interface Props {
    name: string
    age: number
}

const props = defineProps&lt;Props&gt;()
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Props are fully type-checked.</li>
        <li>IDE autocompletion works automatically.</li>
    </ul>

    <br/><br/>



    <li><b>Passing Props from a Parent Component</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;!--
        Without `:` → the value is a plain string
        With    `:` → the value is a JavaScript expression
    --&gt;
    &lt;UserCard name="Junzhe" :age="22" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import UserCard from "./UserCard.vue"
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Optional Props</b></li>
    <br/>
    <ul>
        <li>Optional props are typed with <code>?</code>.</li>
    </ul>

<pre><code class="language-ts line-numbers">const props = defineProps&lt;{
    title: string
    subtitle?: string
}&gt;()
</code></pre>

    <ul>
        <li>Vue and TypeScript ensure the parent does not forget required props.</li>
    </ul>

    <br/><br/>



    <li><b>Props with Default Values</b></li>
    <br/>
    <ul>
        <li>To provide default values, use <code>withDefaults()</code>.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script setup lang="ts"&gt;
const props = withDefaults(
    defineProps&lt;{
        size?: "sm" | "md" | "lg"
        label: string
    }&gt;(),
    {
        size: "md"
    }
)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>TypeScript now treats <code>size</code> as always defined.</li>
    </ul>

    <br/><br/>



    <li><b>Union Types for Props</b></li>
    <br/>
    <ul>
        <li>Union types allow flexible but safe prop values.</li>
    </ul>

<pre><code class="language-ts line-numbers">const props = defineProps&lt;{
    status: "success" | "warning" | "error"
}&gt;()
</code></pre>

    <ul>
        <li>Parents must provide one of the allowed strings.</li>
    </ul>

    <br/><br/>



    <li><b>Props with Complex Types</b></li>
    <br/>
    <ul>
        <li>You can pass objects, arrays, or custom interfaces as props.</li>
    </ul>

<pre><code class="language-ts line-numbers">interface User {
    id: number
    name: string
    email: string
}

const props = defineProps&lt;{
    user: User
    tags: string[]
}&gt;()
</code></pre>

    <ul>
        <li>Vue handles reactivity automatically for these values.</li>
    </ul>

    <br/><br/>



    <li><b>Readonly Behavior of Props</b></li>
    <br/>
    <ul>
        <li>Props cannot be mutated directly.</li>
        <li>The following will throw a warning:</li>
    </ul>

<pre><code class="language-ts line-numbers">props.count++   // ❌ not allowed (props are readonly)
</code></pre>

    <ul>
        <li>Instead, use a local ref:</li>
    </ul>

<pre><code class="language-ts line-numbers">const localCount = ref(props.count)
</code></pre>

    <br/><br/>



    <li><b>Required Props</b></li>
    <br/>
    <ul>
        <li>Props without <code>?</code> are automatically required.</li>
    </ul>

<pre><code class="language-ts line-numbers">const props = defineProps&lt;{
    id: number      // required
    name?: string   // optional
}&gt;()
</code></pre>

    <br/><br/>



    <li><b>Prop Validation with TypeScript</b></li>
    <br/>
    <ul>
        <li>TypeScript replaces the old Vue runtime validators.</li>
        <li>The component will not compile if you pass invalid types.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- ❌ Type error: age must be a number --&gt;
&lt;UserCard name="Alice" age="twenty" /&gt;
</code></pre>

    <br/><br/>



    <li><b>Destructuring Props (Safe Pattern)</b></li>
    <br/>
    <ul>
        <li>You should <u>avoid</u> direct destructuring, because it loses reactivity.</li>
        <li>Use <code>toRefs()</code> to safely destructure props.</li>
    </ul>

<pre><code class="language-ts line-numbers">import { toRefs } from "vue"

const props = defineProps&lt;{
    title: string
    count: number
}&gt;()

const { title, count } = toRefs(props)
</code></pre>

    <ul>
        <li>Now <code>title</code> and <code>count</code> remain reactive.</li>
    </ul>

    <br/><br/>



    <li><b>Props and Emits Together</b></li>
    <br/>
    <ul>
        <li>Combining props with emits enables two-way communication.</li>
        <li>This is the building block for custom <code>v-model</code> implementations.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Toggle.vue --&gt;
&lt;template&gt;
    &lt;button @click="toggle"&gt;{{ modelValue ? "On" : "Off" }}&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    modelValue: boolean
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:modelValue", value: boolean): void
}&gt;()

function toggle() {
    emit("update:modelValue", !props.modelValue)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Best Practices for Props</b></li>
    <br/>
    <ul>
        <li>Use <b>TypeScript</b> <code>interfaces</code> for clarity and reusability.</li>
        <li>Use <code>withDefaults()</code> instead of manual default handling.</li>
        <li>Do <u>not</u> mutate props, use local state instead.</li>
        <li>Use union types to restrict props to valid values.</li>
        <li>Use <code>toRefs(props)</code> when destructuring.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Define props</td>
                <td><code>defineProps&lt;T&gt;()</code> with TypeScript interfaces</td>
            </tr>
            <tr>
                <td>Optional props</td>
                <td>Use <code>?</code> in type definitions</td>
            </tr>
            <tr>
                <td>Default values</td>
                <td>Use <code>withDefaults()</code> around <code>defineProps</code></td>
            </tr>
            <tr>
                <td>Prop immutability</td>
                <td>Props are readonly — cannot mutate directly</td>
            </tr>
            <tr>
                <td>Complex props</td>
                <td>Pass objects, arrays, or interfaces</td>
            </tr>
            <tr>
                <td>Destructuring</td>
                <td>Use <code>toRefs()</code> to keep reactivity</td>
            </tr>
            <tr>
                <td>Type safety</td>
                <td>TypeScript enforces correct prop usage automatically</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-component-events">Component Events in Vue (Emits + TypeScript)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Component events allow child components to <b>send messages to their parents</b>.</li>
        <br/>
        <li>They are fundamental for communication when child components need to:
            <ul>
                <li>notify about user interactions</li>
                <li>update values in the parent</li>
                <li>trigger actions (submit, delete, save)</li>
                <li>implement custom <code>v-model</code></li>
            </ul>
        </li>
        <br/>
        <li>In Vue 3 with the Composition API, events are defined using <code>defineEmits&lt;T&gt;</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Defining Events with <code>defineEmits()</code></b></li>
    <br/>
    <ul>
        <li>The recommended way to define events is using function signatures.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Child.vue --&gt;
&lt;template&gt;
    &lt;button @click="sendMessage"&gt;Send&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const emit = defineEmits&lt;{
    (event: "hello", message: string): void
}&gt;()

function sendMessage() {
    emit("hello", "Hi from child!")
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The event type ensures the event name must be <code>"hello"</code> and the payload must be a <code>string</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Listening to Events in the Parent</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Child @hello="onHello" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import Child from "./Child.vue"

function onHello(message: string) {
    console.log("Child said:", message)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The parent's callback receives a strongly typed payload.</li>
    </ul>

    <br/><br/>



    <li><b>Multiple Events</b></li>
    <br/>
    <ul>
        <li>You can define multiple events by adding more signatures.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
const emit = defineEmits&lt;{
    (e: "increment"): void
    (e: "submit", value: string): void
    (e: "delete", id: number): void
}&gt;()
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Passing Multiple Arguments</b></li>
    <br/>

<pre><code class="language-ts line-numbers">emit("submit", title.value, description.value)
// Typed as: (e: "submit", title: string, desc: string)
</code></pre>

    <ul>
        <li>You can include as many values as needed.</li>
    </ul>

    <br/><br/>



    <li><b>Using Events for User Interaction</b></li>
    <br/>
    <ul>
        <li>Example: A like button that notifies the parent when clicked.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- LikeButton.vue --&gt;
&lt;template&gt;
    &lt;button @click="like"&gt;Like ({{ count }})&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"

const count = ref(0)

const emit = defineEmits&lt;{
    (e: "liked", newCount: number): void
}&gt;()

function like() {
    count.value++
    emit("liked", count.value)
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;LikeButton @liked="onLiked" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import LikeButton from "./LikeButton.vue"

function onLiked(total: number) {
    console.log("Likes:", total)
}
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Events and Custom <code>v-model</code></b></li>
    <br/>
    <ul>
        <li>Vue uses events to power two-way binding with custom components.</li>
        <li>The event must follow the pattern: <code>"update:modelValue"</code></li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Toggle.vue --&gt;
&lt;template&gt;
    &lt;button @click="toggle"&gt;
        {{ modelValue ? "On" : "Off" }}
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    modelValue: boolean
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:modelValue", value: boolean): void
}&gt;()

function toggle() {
    emit("update:modelValue", !props.modelValue)
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;!--
        &lt;Toggle
            :modelValue="enabled"
            @update:modelValue="enabled = $event"
        /&gt;
    --&gt;

    &lt;Toggle v-model="enabled" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import Toggle from "./Toggle.vue"

const enabled = ref(false)
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Typing Event Listeners in Parents</b></li>
    <br/>
    <ul>
        <li>When using TypeScript, listener functions also get type checking automatically:</li>
    </ul>

<pre><code class="language-ts line-numbers">function onSelect(id: number) {
    // id is guaranteed to be a number
}
</code></pre>

    <br/><br/>



    <li><b>Event Validation (Old Vue 2 API)</b></li>
    <br/>
    <ul>
        <li>In Vue 2, you could validate events using an <code>emits: {}</code> object.</li>
        <li>Vue 3 keeps it for compatibility, but <b>TypeScript + defineEmits</b> is preferred.</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
defineEmits({
    submit(payload: string) {
        return payload.length &gt; 0
    }
})
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This pattern is now discouraged in TS-based Vue apps.</li>
    </ul>

    <br/><br/>



    <li><b>Best Practices for Component Events</b></li>
    <br/>
    <ul>
        <li>Use <code>defineEmits&lt;T&gt;</code> for full type safety.</li>
        <br/>
        <li>Use descriptive event names like <code>selected</code>, <code>saved</code>, <code>submitted</code>.</li>
        <br/>
        <li>Use <code>update:modelValue</code> for custom two-way binding.</li>
        <br/>
        <li>Avoid emitting complex objects if a simple ID or string works.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Defining events</td>
                <td><code>defineEmits&lt;Signatures&gt;()</code></td>
            </tr>
            <tr>
                <td>Triggering events</td>
                <td><code>emit("eventName", payload)</code></td>
            </tr>
            <tr>
                <td>Parent listening</td>
                <td><code>&lt;Child @eventName="handler" /&gt;</code></td>
            </tr>
            <tr>
                <td>Multiple events</td>
                <td>Use multiple overload signatures</td>
            </tr>
            <tr>
                <td>Custom v-model</td>
                <td>Event must be <code>update:modelValue</code></td>
            </tr>
            <tr>
                <td>Type safety</td>
                <td>All events strictly typed with TypeScript</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-component-v-model">Component v-model (Custom Two-Way Binding in Vue)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>v-model</code> is normally used with form elements (input, checkbox, select).</li>
        <br/>
        <li>But Vue also allows any <u>custom component</u> to support <code>v-model</code>.</li>
        <br/>
        <li>With the Composition API + TypeScript, custom v-model is implemented using:
            <ul>
                <li>a prop named <code>modelValue</code></li>
                <li>an event named <code>"update:modelValue"</code></li>
            </ul>
        </li>
        <br/>
        <li>This gives a clean two-way data flow between parent and child.</li>
    </ul>

    <br/><br/>



    <li><b>Basic Example: A Simple Toggle Component</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;!-- Toggle.vue --&gt;
&lt;template&gt;
    &lt;button @click="toggle"&gt;
        {{ modelValue ? "ON" : "OFF" }}
    &lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    modelValue: boolean
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:modelValue", value: boolean): void
}&gt;()

function toggle() {
    emit("update:modelValue", !props.modelValue)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This component can now be used with <code>v-model</code> like a normal input.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;Toggle v-model="enabled" /&gt;
    &lt;p&gt;Enabled: {{ enabled }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import Toggle from "./Toggle.vue"

const enabled = ref(false)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>The parent now receives updates automatically whenever the child emits.</li>
    </ul>

    <br/><br/>



    <li><b>Understanding the Pattern</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Part</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>modelValue</code></td>
                <td>The value provided by the parent (v-model)</td>
            </tr>
            <tr>
                <td><code>update:modelValue</code></td>
                <td>The event emitted when the child wants to update the parent</td>
            </tr>
            <tr>
                <td><code>v-model="x"</code></td>
                <td>Links <code>x</code> to <code>modelValue</code> and listens for updates</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>v-model with TypeScript Validation</b></li>
    <br/>

<pre><code class="language-ts line-numbers">const emit = defineEmits&lt;{
    (e: "update:modelValue", value: string): void
}&gt;()
</code></pre>

    <ul>
        <li>Any incorrect payload will be caught at compile time.</li>
    </ul>

    <br/><br/>



    <li><b>Multiple v-model Bindings</b></li>
    <br/>
    <ul>
        <li>Components can define multiple v-models using <u>arguments</u>.</li>
        <li>Each v-model gets its own prop + event pair.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- RangeInput.vue --&gt;
&lt;template&gt;
    &lt;input type="number" :value="min" @input="onMin($event)" /&gt;
    &lt;input type="number" :value="max" @input="onMax($event)" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
    min: number
    max: number
}&gt;()

const emit = defineEmits&lt;{
    (e: "update:min", value: number): void
    (e: "update:max", value: number): void
}&gt;()

function onMin(e: Event) {
    emit("update:min", Number((e.target as HTMLInputElement).value))
}

function onMax(e: Event) {
    emit("update:max", Number((e.target as HTMLInputElement).value))
}
&lt;/script&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;RangeInput v-model:min="start" v-model:max="end" /&gt;
    &lt;p&gt;Range: {{ start }} - {{ end }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import RangeInput from "./RangeInput.vue"

const start = ref(1)
const end = ref(10)
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This allows powerful multi-value component interactions.</li>
    </ul>

    <br/><br/>



    <li><b>Customizing v-model Name</b></li>
    <br/>
    <ul>
        <li>You can use a custom prop name instead of <code>modelValue</code>.</li>
        <li>Use the argument form of v-model.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- SearchInput.vue --&gt;
&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{ query: string }&gt;()

const emit = defineEmits&lt;{
    (e: "update:query", value: string): void
}&gt;()
&lt;/script&gt;

&lt;template&gt;
    &lt;input :value="query" @input="emit('update:query', $event.target.value)" /&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="language-html line-numbers">&lt;!-- Parent.vue --&gt;
&lt;template&gt;
    &lt;SearchInput v-model:query="searchText" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from "vue"
import SearchInput from "./SearchInput.vue"

const searchText = ref("")
&lt;/script&gt;
</code></pre>

    <ul>
        <li>Broader control for naming custom binding patterns.</li>
    </ul>

    <br/><br/>



    <li><b>Using Local State + Props in v-model</b></li>
    <br/>
    <ul>
        <li>Sometimes a component should maintain local state instead of directly showing <code>modelValue</code>:</li>
    </ul>

<pre><code class="language-ts line-numbers">&lt;script setup lang="ts"&gt;
import { ref, watch } from "vue"

const props = defineProps&lt;{ modelValue: string }&gt;()
const emit = defineEmits&lt;{ (e: "update:modelValue", value: string): void }&gt;()

const internal = ref(props.modelValue)

// sync internal state to prop changes
watch(() =&gt; props.modelValue, (v) =&gt; internal.value = v)

function update(v: string) {
    internal.value = v
    emit("update:modelValue", v)
}
&lt;/script&gt;
</code></pre>

    <ul>
        <li>This is useful for text inputs, debounced inputs, sliders, etc.</li>
    </ul>

    <br/><br/>



    <li><b>Best Practices</b></li>
    <br/>
    <ul>
        <li>Always use <code>modelValue</code> + <code>update:modelValue</code> for the default v-model.</li>
        <br/>
        <li>Use <code>v-model:yourProp</code> for additional values.</li>
        <br/>
        <li>Return only new values, never mutate props directly.</li>
        <br/>
        <li>For complex inputs, use an internal state synchronized by watchers.</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Default v-model</td>
                <td>Uses <code>modelValue</code> prop + <code>update:modelValue</code> event</td>
            </tr>
            <tr>
                <td>Multiple v-models</td>
                <td>Use <code>v-model:name</code> + <code>update:name</code></td>
            </tr>
            <tr>
                <td>Type safety</td>
                <td>All payloads validated by TypeScript</td>
            </tr>
            <tr>
                <td>Local state pattern</td>
                <td>Use <code>ref()</code> + <code>watch()</code> for more control</td>
            </tr>
            <tr>
                <td>Component usage</td>
                <td><code>&lt;CustomInput v-model="value" /&gt;</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
