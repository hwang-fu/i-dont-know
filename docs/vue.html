<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>VUE</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }
    /*
    .token.comment {
        color: #888;
    }
    */

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#vue-introduction">Introduction</a></li>
        <li><a href="#vue-options-vs-composition">Options API vs Composition API</a></li>
        <li><a href="#vue-composition-api">Composition API</a></li>
        <li><a href="#vue-reactive-value">Reactive Value</a></li>
        <li><a href="#vue-create-app">Creating a Vue Application</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-introduction">Introduction to Vue.js</h3>
<ol>
    <li><b>What Is Vue.js?</b></li>
    <br/>
    <ul>
        <li><b>Vue.js</b> (usually called just “Vue”) is a progressive, flexible, and beginner-friendly JavaScript framework for building user interfaces.</li>
        <br/>
        <li>Vue focuses on the <u>view layer</u> (what the user sees) but can grow into a full application framework using official tools such as:
            <ul>
                <li><code>Vue Router</code>: for navigation</li>
                <li><code>Pinia</code>: for state management</li>
                <li><code>Vite</code>: for fast development tooling</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>How Vue Works</b></li>
    <br/>
    <ul>
        <li>Vue uses a <u>reactive data system</u>: when your data changes, the UI updates automatically.</li>
        <br/>
        <li>Your Vue app contains:
            <ul>
                <li>a JavaScript object storing data and logic</li>
                <li>a template that displays this data</li>
                <li>Vue automatically connects (binds) the two</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-html line-numbers">&lt;div id="app"&gt;
    {{ message }}
&lt;/div&gt;

&lt;script&gt;
const app = Vue.createApp({
    data() {
        return {
            message: "Hello Vue!"
        }
    }
});
app.mount("#app");
&lt;/script&gt;
</code></pre>
    <ul>
        <li>The text inside <code>{{ }}</code> automatically updates when <code>message</code> changes.</li>
    </ul>

    <br/><br/>



    <li><b>Getting Started (CDN Method)</b></li>
    <br/>
    <ul>
        <li>The easiest way to try Vue is by including it from a CDN:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
</code></pre>
    <ul>
        <li>This allows Vue to run directly in your HTML page.</li>
    </ul>

    <br/><br/>



    <li><b>Core Concepts of Vue</b></li>

    <br/>
    <ol>
    <li><b>Templates &amp; Data Binding</b></li>
    <br/>
    <ul>
        <li>Vue uses a clean declarative template syntax.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;div id="app"&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Counter: {{ count }}&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-js line-numbers">data() {
    return {
        title: "Welcome",
        count: 0
    }
}
</code></pre>

    <br/><br/>



    <li><b>Event Handling</b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;button @click="count++"&gt;Increase&lt;/button&gt;
</code></pre>

    <ul>
        <li><code>@click</code> is a shortcut for <code>v-on:click</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Two-Way Binding with <code>v-model</code></b></li>
    <br/>

<pre><code class="language-html line-numbers">&lt;input v-model="name"&gt;
&lt;p&gt;Hello {{ name }}&lt;/p&gt;
</code></pre>
    <ul>
        <li>Typing into the input updates <code>name</code> immediately.</li>
    </ul>

    <br/><br/>



    <li><b>Conditionals and Loops</b></li>
<pre><code class="language-html line-numbers">&lt;p v-if="loggedIn"&gt;Welcome back!&lt;/p&gt;
&lt;p v-else&gt;Please log in.&lt;/p&gt;

&lt;ul&gt;
    &lt;li v-for="item in items"&gt;{{ item }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

    <br/><br/>



    <li><b>Computed Properties</b></li>
    <br/>
    <ul>
        <li>Vue recalculates these automatically when dependent data changes.</li>
    </ul>

<pre><code class="language-js line-numbers">computed: {
    reversed() {
        return this.message.split("").reverse().join("");
    }
}
</code></pre>

    <br/><br/>



    <li><b>Methods</b></li>
<pre><code class="language-js line-numbers">methods: {
    greet() {
        return "Hello " + this.name;
    }
}
</code></pre>
    </ol>

    <br/><br/>



    <li><b>Single File Components (SFC)</b></li>
    <br/>
    <ul>
        <li>For bigger apps, Vue uses <code>.vue</code> files, each containing:</li>
        <ul>
            <li><code>&lt;template&gt;</code> – HTML</li>
            <li><code>&lt;script&gt;</code> – JS</li>
            <li><code>&lt;style&gt;</code> – CSS</li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;!-- MyComponent.vue --&gt;
&lt;template&gt;
  &lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return { title: "Hello SFC" }
  }
}
&lt;/script&gt;

&lt;style&gt;
h1 { color: blue; }
&lt;/style&gt;
</code></pre>

    <br/><br/>



    <li><b>Vue Tooling: Vite & Vue CLI</b></li>
    <br/>
    <ul>
        <li>For real applications, use a build tool:</li>
        <ul>
            <li><code>Vite</code>: modern, very fast</li>
            <li><code>Vue CLI</code>: older but still used</li>
        </ul>
    </ul>

<pre><code class="language-bash line-numbers">npm create vue@latest
cd myproject
npm install
npm run dev
</code></pre>

    <br/><br/>



    <li><b>Ecosystem Overview</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Vue Router</td>
                <td>Navigation for SPA apps</td>
            </tr>
            <tr>
                <td>Pinia</td>
                <td>State management</td>
            </tr>
            <tr>
                <td>Vite</td>
                <td>Development &amp; build tool</td>
            </tr>
            <tr>
                <td>DevTools</td>
                <td>Chrome/Firefox debugging extension</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Why Vue Is Great for Beginners</b></li>
    <br/>
    <ul>
        <li>Simple to understand – start with HTML and small scripts</li>
        <li>Powerful for large applications</li>
        <li>More lightweight and intuitive compared to React or Angular</li>
        <li>Very clean syntax (easy to read)</li>
        <li>Excellent documentation</li>
    </ul>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Reactivity</td>
                <td>UI updates automatically when data changes</td>
            </tr>
            <tr>
                <td>Declarative templates</td>
                <td>Use <code>{{ }}</code> to display data easily</td>
            </tr>
            <tr>
                <td>Directives</td>
                <td><code>v-if</code>, <code>v-for</code>, <code>v-model</code>, <code>v-on</code></td>
            </tr>
            <tr>
                <td>Components</td>
                <td>Reusable UI blocks, .vue files</td>
            </tr>
            <tr>
                <td>Tooling</td>
                <td>Vite, Vue Router, Pinia</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-options-vs-composition">Vue Options API vs Composition API (Introduction & Comparison)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Vue components can be written using two different styles:</li>
        <ul>
            <li><b>Options API</b> (Vue 2 style, still fully supported in Vue 3)</li>
            <li><b>Composition API</b> (new in Vue 3, more flexible)</li>
        </ul>
        <br/>
        <li>Both styles are valid, and you can mix them in one project.</li>
        <br/>
        <li>The difference is mainly in:
            <ul>
                <li>how you structure code</li>
                <li>how you define reactive data</li>
                <li>how logic is organized and reused</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Options API (Traditional Vue Style)</b></li>
    <br/>
    <ul>
        <li>The Options API organizes code into <u>sections</u> inside a component:</li>
        <ul>
            <li><code>data()</code></li>
            <li><code>methods</code></li>
            <li><code>computed</code></li>
            <li><code>watch</code></li>
            <li><code>props</code></li>
        </ul>
        <br/>
        <li>This style is easy for beginners because logic is grouped by <u>options</u>, not by <u>functionality</u>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
  data() {
    return { count: 0 }
  },
  methods: {
    increment() {
      this.count++
    }
  },
  computed: {
    double() {
      return this.count * 2
    }
  }
}
</code></pre>
    <ul>
        <li>Good for small to medium components, beginners, simple logic.</li>
    </ul>

    <br/><br/>



    <li><b>Composition API (Modern Vue Style)</b></li>
    <br/>
    <ul>
        <li>Composition API moves logic into the <code>setup()</code> function.</li>
        <br/>
        <li>You create reactive variables using:</li>
        <ul>
            <li><code>ref()</code></li>
            <li><code>reactive()</code></li>
            <li><code>computed()</code></li>
            <li><code>watch()</code></li>
        </ul>
        <br/>
        <li>This style is more flexible, easier to scale, and ideal for complex apps.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

export default {
  setup() {
    const count = ref(0)
    const increment = () =&gt; count.value++
    const double = computed(() =&gt; count.value * 2)

    return { count, increment, double }
  }
}
</code></pre>
    <ul>
        <li>Good for large projects, reusable logic, TypeScript support.</li>
    </ul>

    <br/><br/>



    <li><b>Key Differences</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Code organization</td>
                <td>Grouped by <b>option</b> (data, methods, computed)</td>
                <td>Grouped by <b>logic</b> and feature</td>
            </tr>
            <tr>
                <td>Learning curve</td>
                <td>Easier for beginners</td>
                <td>Requires understanding of JS functions and reactivity</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Implicit (<code>this.count++</code>)</td>
                <td>Explicit (<code>ref</code>, <code>reactive</code>, <code>value</code>)</td>
            </tr>
            <tr>
                <td>Logic reuse</td>
                <td>Mixins (old, limited)</td>
                <td>Composable functions (modern, powerful)</td>
            </tr>
            <tr>
                <td>Scaling to large apps</td>
                <td>More difficult</td>
                <td>Much easier</td>
            </tr>
            <tr>
                <td>TypeScript support</td>
                <td>Limited</td>
                <td>Excellent</td>
            </tr>
            <tr>
                <td>IDE autocompletion</td>
                <td>Less precise (due to <code>this</code>)</td>
                <td>Very precise (explicit types &amp; refs)</td>
            </tr>
            <tr>
                <td>Recommended for Vue 3?</td>
                <td>Still supported &amp; fine</td>
                <td><b>Yes, the future direction</b></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When to Use Which?</b></li>
    <br/>
    <ul>
        <li><b>Use Options API if:</b>
            <ul>
                <li>you are a beginner</li>
                <li>your component is small</li>
                <li>your team prefers classic Vue</li>
            </ul>
        </li>
        <br/>
        <li><b>Use Composition API if:</b>
            <ul>
                <li>your application is large</li>
                <li>you want reusable logic</li>
                <li>you use TypeScript</li>
                <li>you need more flexibility</li>
                <li>you want better structure for complex features</li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Example Comparison (Same Component in Both APIs)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
<pre><code class="language-js line-numbers">export default {
  data() {
    return { count: 0 }
  },
  methods: {
    increment() {
      this.count++
    }
  }
}
</code></pre>
                </td>
                <td>
<pre><code class="language-js line-numbers">import { ref } from "vue"

export default {
  setup() {
    const count = ref(0)
    const increment = () =&gt; count.value++
    return { count, increment }
  }
}
</code></pre>
                </td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ease of use</td>
                <td>Very easy</td>
                <td>Medium</td>
            </tr>
            <tr>
                <td>Flexibility</td>
                <td>Limited</td>
                <td>Very high</td>
            </tr>
            <tr>
                <td>Logic organization</td>
                <td>Separated by option</td>
                <td>Grouped by feature</td>
            </tr>
            <tr>
                <td>Preferred for new Vue 3 apps?</td>
                <td>Okay</td>
                <td><b>Yes</b></td>
            </tr>
            <tr>
                <td>TypeScript</td>
                <td>Not ideal</td>
                <td><b>Excellent</b></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-composition-api">Introduction to the Vue 3 Composition API (Thorough & Beginner-Friendly)</h3>
<ol>
    <li><b>Short Intro</b></li>
    <br/>
    <ul>
        <li>The <code>Composition API</code> is a modern way to write Vue components using plain JavaScript functions.</li>
        <br/>
        <li>It was introduced in Vue 3 and offers:
            <ul>
                <li>better logic organization</li>
                <li>cleaner code for complex components</li>
                <li>excellent TypeScript support</li>
                <li>more powerful code reuse</li>
            </ul>
        </li>
        <br/>
        <li>Instead of putting logic in separate blocks (<code>data</code>, <code>computed</code>, <code>methods</code>), everything lives together inside <code>setup()</code>.</li>
    </ul>
    <br/><br/>



    <li><b>The Setup Function</b></li>
    <br/>
    <ul>
        <li><code>setup()</code> is the entry point for the Composition API in a component.</li>
        <li>It runs before the component is created and returns what the template can use.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
  setup() {
    return {
      // expose things to the template
    }
  }
}
</code></pre>
    <ul>
        <li>Everything used by the template must be returned from <code>setup()</code>.</li>
    </ul>

    <br/><br/>



    <li><b>Creating Reactive State with ref()</b></li>
    <br/>
    <ul>
        <li><code>ref()</code> creates a reactive value.</li>
        <li>Use it for primitives (numbers, strings, booleans).</li>
        <li>The actual value lives in <code>.value</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref } from "vue"

export default {
  setup() {
    const count = ref(0)

    function increment() {
      count.value++
    }

    return { count, increment }
  }
}
</code></pre>
    <ul>
        <li><b>Important:</b> In templates, Vue automatically unwraps <code>ref</code>. No need to use <code>.value</code> inside HTML.</li>
    </ul>

    <br/><br/>



    <li><b>Reactive Objects with reactive()</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> creates a reactive object.</li>
        <li>Use it for collections or multiple related values.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive } from "vue"

export default {
  setup() {
    const state = reactive({
      name: "Hwangfu",
      age: 22
    })

    return { state }
  }
}
</code></pre>
    <ul>
        <li>Reactive objects behave like normal JS objects but trigger UI updates when mutated.</li>
    </ul>

    <br/><br/>



    <li><b>Computed Properties</b></li>
    <br/>
    <ul>
        <li><code>computed()</code> creates values that update automatically when dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

export default {
  setup() {
    const count = ref(5)
    const double = computed(() =&gt; count.value * 2)

    return { count, double }
  }
}
</code></pre>
    <ul>
        <li>Computed properties are cached and recomputed only when needed.</li>
    </ul>

    <br/><br/>



    <li><b>Watchers</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> runs a callback when reactive data changes.</li>
        <li>Good for asynchronous operations, API calls, or side effects.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watch } from "vue"

export default {
  setup() {
    const name = ref("")

    watch(name, (newVal, oldVal) =&gt; {
      console.log("Changed from", oldVal, "to", newVal)
    })

    return { name }
  }
}
</code></pre>

    <br/><br/>



    <li><b>watchEffect()</b> (Automatic Tracking)</li>
    <br/>
    <ul>
        <li><code>watchEffect()</code> tracks all reactive values inside it automatically.</li>
        <li>It re-runs itself whenever dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, watchEffect } from "vue"

export default {
  setup() {
    const x = ref(1)

    watchEffect(() =&gt; {
      console.log("x is", x.value)
    })

    return { x }
  }
}
</code></pre>

    <br/><br/>



    <li><b>Methods in Composition API</b></li>
    <br/>
    <ul>
        <li>There is no <code>methods</code> section.</li>
        <li>You simply define functions inside <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">setup() {
  const count = ref(0)

  function increment() {
    count.value++
  }

  return { count, increment }
}
</code></pre>

    <br/><br/>



    <li><b>Lifecycles in Composition API</b></li>
    <br/>
    <ul>
        <li>Instead of Options API lifecycle hooks (<code>mounted</code>, <code>created</code>), Composition API uses importable functions.</li>
    </ul>

<pre><code class="language-js line-numbers">import { onMounted, onUnmounted } from "vue"

export default {
  setup() {
    onMounted(() =&gt; {
      console.log("Component mounted")
    })

    onUnmounted(() =&gt; {
      console.log("Component removed")
    })
  }
}
</code></pre>

    <br/>
    <ul>
        <li>Other hooks:
            <ul>
                <li><code>onMounted</code></li>
                <li><code>onUpdated</code></li>
                <li><code>onUnmounted</code></li>
                <li><code>onBeforeMount</code></li>
                <li><code>onBeforeUpdate</code></li>
                <li><code>onBeforeUnmount</code></li>
            </ul>
        </li>
    </ul>

    <br/><br/>



    <li><b>Props in Composition API</b></li>
    <br/>
    <ul>
        <li>Props are received as arguments to <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
  props: {
    msg: String
  },

  setup(props) {
    console.log(props.msg)
    return { }
  }
}
</code></pre>

    <br/><br/>



    <li><b>Emitting Events</b></li>
    <br/>
    <ul>
        <li>You receive <code>emit</code> as the second argument in <code>setup()</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">export default {
  emits: ["update"],

  setup(props, { emit }) {
    function updateValue() {
      emit("update", 42)
    }

    return { updateValue }
  }
}
</code></pre>

    <br/><br/>



    <li><b>Extracting Logic Into Composables</b></li>
    <br/>
    <ul>
        <li>The Composition API allows you to reuse logic by creating <b>composable functions</b>.</li>
        <li>These are just plain JS functions that return reactive state.</li>
    </ul>

<pre><code class="language-js line-numbers">// useCounter.js
import { ref } from "vue"

export function useCounter() {
  const count = ref(0)
  const increment = () =&gt; count.value++
  return { count, increment }
}
</code></pre>

<pre><code class="language-js line-numbers">// Component.vue
import { useCounter } from "./useCounter"

export default {
  setup() {
    const { count, increment } = useCounter()
    return { count, increment }
  }
}
</code></pre>

    <br/><br/>



    <li><b>Why the Composition API Is Powerful</b></li>
    <br/>
    <ul>
        <li>Flexible code structure</li>
        <li>Easier for large teams</li>
        <li>Better logic reuse (composables)</li>
        <li>Works extremely well with TypeScript</li>
        <li>No complex mixins or inheritance needed</li>
        <li>Cleaner separation of features</li>
    </ul>

    <br/><br/>



    <li><b>Options API vs Composition API Summary</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Options API</th>
                <th>Composition API</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Organization</td>
                <td>By option type (data, methods, etc.)</td>
                <td>By logic/functionality</td>
            </tr>
            <tr>
                <td>Reactivity</td>
                <td>Implicit <code>this</code></td>
                <td>Explicit <code>ref</code>, <code>reactive</code></td>
            </tr>
            <tr>
                <td>Logic reuse</td>
                <td>mixins</td>
                <td>composables</td>
            </tr>
            <tr>
                <td>TypeScript</td>
                <td>not ideal</td>
                <td>excellent</td>
            </tr>
            <tr>
                <td>Best for</td>
                <td>small/simple components</td>
                <td>medium/large apps, reusable logic</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-reactive-value">What Is a Reactive Value in Vue?</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>It allows the UI to update automatically whenever your data changes.</li>
        <br/>
        <li>A <u>reactive value</u> is any value that Vue tracks internally so it can update the DOM when the value changes.</li>
        <br/>
        <li>In Vue 3 (Composition API), reactivity is created using:</li>
        <ul>
            <li><code>ref()</code> — for reactive primitives</li>
            <li><code>reactive()</code> — for reactive objects</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>Why Reactivity Matters</b></li>
    <br/>
    <ul>
        <li>In plain JavaScript, changing a variable does <u>not</u> update the UI automatically.<br/>
            You would have to manually modify the DOM:</li>
    </ul>

<pre><code class="language-js line-numbers">let count = 0
document.getElementById("counter").innerText = count
count++
document.getElementById("counter").innerText = count
</code></pre>
    <ul>
        <li>This is slow, repetitive, and error-prone.</li>
        <br/>
        <li>In Vue, you update the variable → UI updates automatically.</li>
    </ul>

<pre><code class="language-js line-numbers">const count = ref(0)
count.value++  // UI updates automatically
</code></pre>

    <br/><br/>



    <li><b>ref(): Reactive Primitive Values</b></li>
    <br/>
    <ul>
        <li><code>ref()</code> wraps a value inside an object with a single property: <code>value</code>.</li>
        <li>This wrapper is reactive.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref } from "vue"

const count = ref(0)
console.log(count.value)  // 0

count.value++
console.log(count.value)  // 1
</code></pre>
    <ul>
        <li>Why <code>.value</code>?</li>
        <ul>
            <li>Because JavaScript primitives (number, string, boolean) cannot be made reactive by themselves.</li>
            <li>Vue wraps them in an object to track changes.</li>
        </ul>
    </ul>
    <br/><br/>



    <li><b>reactive(): Reactive Objects (Deep Reactivity)</b></li>
    <br/>
    <ul>
        <li><code>reactive()</code> makes an entire object reactive.</li>
        <li>All nested properties also become reactive.</li>
    </ul>

<pre><code class="language-js line-numbers">import { reactive } from "vue"

const user = reactive({
  name: "Hwangfu",
  age: 22
})

user.age++  // automatically updates UI
</code></pre>

    <br/>
    <ul>
        <li>This is called <u>deep reactivity</u>, where every property is tracked.</li>
    </ul>
    <br/><br/>



    <li><b>How Vue Detects Changes (The Proxy System)</b></li>
    <br/>
    <ul>
        <li>Vue 3 uses the <b>JavaScript Proxy API</b> to intercept operations on reactive values:</li>
        <ul>
            <li>reading</li>
            <li>writing</li>
            <li>deleting</li>
        </ul>
        <br/>
        <li>Whenever a reactive property is read, Vue records the dependency.</li>
        <br/>
        <li>Whenever it’s changed, Vue schedules a UI update.</li>
    </ul>
    <br/><br/>



    <li><b>Reactive Values in Templates</b></li>
    <br/>
    <ul>
        <li>In Vue templates, ref values are <u>auto-unwrapped</u>.</li>
        <li>This means you do NOT write <code>.value</code> in templates.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
  &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>

    <br/>
    <ul>
        <li>Even though <code>count</code> is a <code>ref</code>, Vue unwraps <code>.value</code> for convenience.</li>
    </ul>

    <br/><br/>



    <li><b>Computed Properties Are Also Reactive</b></li>
    <br/>
    <ul>
        <li><code>computed()</code> returns a special read-only reactive value.</li>
        <li>It updates whenever its dependencies change.</li>
    </ul>

<pre><code class="language-js line-numbers">import { ref, computed } from "vue"

const count = ref(5)
const double = computed(() =&gt; count.value * 2)

console.log(double.value) // 10
count.value++
console.log(double.value) // 12
</code></pre>

    <br/><br/>



    <li><b>Watchers React to Changes</b></li>
    <br/>
    <ul>
        <li><code>watch()</code> listens for changes in reactive values.</li>
    </ul>

<pre><code class="language-js line-numbers">watch(count, (newVal, oldVal) =&gt; {
  console.log("Count changed:", oldVal, "-&gt;", newVal)
})
</code></pre>

    <br/><br/>



    <li><b>How Reactivity Differs from Plain JavaScript</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Plain JavaScript</th>
                <th>Vue Reactive Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Variables don't update UI automatically</td>
                <td>UI updates instantly when reactive value changes</td>
            </tr>
            <tr>
                <td>No dependency tracking</td>
                <td>Automatic dependency tracking</td>
            </tr>
            <tr>
                <td>Manual DOM updates needed</td>
                <td>DOM updates handled by Vue</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>ref vs reactive (Quick Comparison)</b></li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>ref()</th>
                <th>reactive()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Main use-case</td>
                <td>single primitive</td>
                <td>objects, arrays, maps</td>
            </tr>
            <tr>
                <td>Access</td>
                <td><code>value</code> property</td>
                <td>direct property access</td>
            </tr>
            <tr>
                <td>Deep reactivity</td>
                <td>No (wrapping only)</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Template auto-unwrapping</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>



    <li><b>When Should You Use ref()?</b></li>
    <br/>
    <ul>
        <li>primitive values (number, string, boolean)</li>
        <li>single reactive state</li>
        <li>you need full control over reactivity</li>
    </ul>

<pre><code class="language-js line-numbers">const isVisible = ref(true)
const count = ref(0)
const message = ref("Hello")
</code></pre>

    <br/><br/>



    <li><b>When Should You Use reactive()?</b></li>
    <br/>
    <ul>
        <li>objects</li>
        <li>arrays</li>
        <li>complex state</li>
    </ul>

<pre><code class="language-js line-numbers">const form = reactive({
  email: "",
  password: "",
  remember: false
})
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="vue-create-app">Creating a Vue Application</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Vue 3, a "Vue application" is created with <code>createApp()</code> and mounted onto a DOM element.</li>
        <br/>
        <li>We will assume the <code>Composition API</code> by default (with <code>setup()</code>, <code>ref()</code>, etc.).</li>
        <br/>
        <li>There are two common ways to start a Vue app:
            <ul>
                <li><b>Quick test</b>: use Vue from a <u>CDN script</u> in a single HTML file</li>
                <li><b>Real project</b>: use a <u>build tool</u> (e.g. Vite with <code>npm create vue@latest</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Quick Start with CDN (Single HTML File)</b></li>
    <br/>
    <ul>
        <li>This is the fastest way to experiment with Vue.</li>
        <li>No build step, no bundler – just an HTML file and a script tag.</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Vue 3 App&lt;/title&gt;
    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;button @click="count++"&gt;Clicked {{ count }} times&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        const { createApp, ref } = Vue;

        const App = {
            setup() {
                const title = ref("Hello Vue 3");
                const count = ref(0);

                return { title, count };
            }
        };

        createApp(App).mount("#app");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <ul>
        <li>Key points:
            <ul>
                <li><code>createApp(App)</code> creates a Vue application instance.</li>
                <li><code>.mount("#app")</code> tells Vue to control the <code>&lt;div id="app"&gt;</code>.</li>
                <li>The component object <code>App</code> uses the <b>Composition API</b> via <code>setup()</code>.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Real Project Setup with Vite (Recommended)</b></li>
    <br/>
    <ul>
        <li>For real apps, use a modern build tool. The recommended way is Vite with the official Vue starter.</li>
    </ul>

<pre><code class="language-bash line-numbers"># 1. Create a new Vue 3 + Vite project
npm create vue@latest my-vue-app

# 2. Move into the folder
cd my-vue-app

# 3. Install dependencies
npm install

# 4. Start dev server
npm run dev
</code></pre>
    <ul>
        <li>Then open the URL shown in the terminal (usually <code>http://localhost:5173</code>).</li>
        <li>You will see a default Vue starter page.</li>
    </ul>
    <br/><br/>



    <li><b>Project Structure (Typical Vite + Vue App)</b></li>
    <br/>

<pre><code class="language-text line-numbers">my-vue-app/
  ├─ index.html
  ├─ package.json
  ├─ vite.config.js
  └─ src/
      ├─ main.js
      ├─ App.vue
      └─ components/
          └─ ...
</code></pre>
    <ul>
        <li><code>index.html</code>: main HTML entry file.</li>
        <li><code>src/main.js</code>: JS entry where the Vue app is created and mounted.</li>
        <li><code>src/App.vue</code>: root Vue component.</li>
        <li><code>src/components/</code>: other components you create.</li>
    </ul>
    <br/><br/>



    <li><b>main.js: Creating and Mounting the Application</b></li>
    <br/>
    <ul>
        <li>The <code>main.js</code> file usually looks like this:</li>
    </ul>

<pre><code class="language-js line-numbers">import { createApp } from "vue"
import App from "./App.vue"

const app = createApp(App)

// here you can also use plugins, router, store, etc.
// e.g. app.use(router)

app.mount("#app")
</code></pre>
    <ul>
        <li>Here you:
            <ul>
                <li>import the root component <code>App</code></li>
                <li>create the application instance with <code>createApp(App)</code></li>
                <li>mount it to the DOM element with id <code>app</code> (defined in <code>index.html</code>)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>index.html: The Mount Point</b></li>
<pre><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;My Vue App&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;!-- Vite will inject the compiled JS here --&gt;
        &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <ul>
        <li>The <code>&lt;div id="app"&gt;</code> is the “root” of your Vue application.</li>
        <li>Everything your Vue app renders will appear inside this element.</li>
    </ul>
    <br/><br/>



    <li><b>App.vue: Root Component with Composition API</b></li>
    <br/>
    <ul>
        <li><code>App.vue</code> is a Single File Component (SFC) with three main sections:</li>
        <ul>
            <li><code>&lt;template&gt;</code>: HTML markup</li>
            <li><code>&lt;script&gt;</code> (or <code>&lt;script setup&gt;</code>): logic</li>
            <li><code>&lt;style&gt;</code>: CSS</li>
        </ul>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;main&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;button @click="count++"&gt;
            Clicked {{ count }} times
        &lt;/button&gt;
    &lt;/main&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const title = ref("My First Vue App")
const count = ref(0)
&lt;/script&gt;

&lt;style&gt;
main {
    font-family: system-ui, sans-serif;
}
button {
    margin-top: 1rem;
}
&lt;/style&gt;
</code></pre>
    <ul>
        <li>Using <code>&lt;script setup&gt;</code> is the recommended Vue 3 style:
            <ul>
                <li>No need to explicitly write <code>export default</code>.</li>
                <li>All top-level variables are automatically exposed to the template.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>



    <li><b>Adding Another Component</b></li>
    <br/>
    <ul>
        <li>Create a component in <code>src/components/Counter.vue</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;Local count: {{ count }}&lt;/p&gt;
        &lt;button @click="count++"&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"

const count = ref(0)
&lt;/script&gt;
</code></pre>

    <br/>
    <ul>
        <li>Then import and use it in <code>App.vue</code>:</li>
    </ul>

<pre><code class="language-html line-numbers">&lt;template&gt;
    &lt;main&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
        &lt;Counter /&gt;
    &lt;/main&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue"
import Counter from "./components/Counter.vue"

const title = ref("My Vue App")
&lt;/script&gt;
</code></pre>

    <br/><br/>



    <li><b>Development vs Production</b></li>
    <br/>
    <ul>
        <li>During development, you run a dev server:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm run dev
</code></pre>

    <br/>
    <ul>
        <li>For production, you build static files:</li>
    </ul>

<pre><code class="language-bash line-numbers">npm run build
npm run preview   # optional: preview the production build locally
</code></pre>
    <ul>
        <li>The build output (usually in <code>dist/</code>) can be deployed to any static file server.</li>
    </ul>
    <br/><br/>



    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Step</th>
                <th>What Happens</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Create project</td>
                <td>Use <code>npm create vue@latest</code> to scaffold a Vue 3 app</td>
            </tr>
            <tr>
                <td>Entry file</td>
                <td><code>main.js</code> imports <code>App.vue</code> and calls <code>createApp(App).mount("#app")</code></td>
            </tr>
            <tr>
                <td>Root component</td>
                <td><code>App.vue</code> defined using Composition API (<code>&lt;script setup&gt;</code>, <code>ref()</code>)</td>
            </tr>
            <tr>
                <td>DOM mount point</td>
                <td><code>&lt;div id="app"&gt;</code> in <code>index.html</code></td>
            </tr>
            <tr>
                <td>Components</td>
                <td>More components go into <code>src/components/</code> and are imported into <code>App.vue</code> or others</td>
            </tr>
            <tr>
                <td>Dev server</td>
                <td><code>npm run dev</code> for live reload while coding</td>
            </tr>
            <tr>
                <td>Production build</td>
                <td><code>npm run build</code> to create optimized static files</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
