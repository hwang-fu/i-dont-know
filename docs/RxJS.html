<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>RxJs</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>RxJS</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>What is RxJS?</h3>
<ol>
    <li>RxJS is a JavaScript library for working with data that changes over time.<br/><br/>
        Example: clicks, keyboard events, HTTP responses, timers.</li>

    <br/><br/><br/>

    <li>It uses the idea of <code>Observable</code> streams.<br/><br/>
        An <code>Observable</code> is like a pipe that keeps sending values.</li>

    <br/><br/><br/>

    <li>You can listen to these values using <code>subscribe()</code>.
        When new data comes, your code runs automatically.</li>
    <br/>
</ol>
<br/>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Why use RxJS?</h3>
<ol>
    <li>It helps you handle async tasks in a clean way.
        Example: chain HTTP requests without “callback hell”.</li>
    <br/><br/>

    <li>It can combine many events into one stream.
        Example: filter user typing + wait 300ms + send search request.</li>
    <br/><br/>

    <li>It is used heavily in Angular, so learning it is very helpful.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Key Concepts</h3>
<ol>
    <li><strong>Observable</strong>: A stream of values over time
        (like a river sending values one by one).</li>

    <br/><br/>

    <li><strong>Observer</strong>: An object that watches the stream.
        It reacts when the stream sends data.</li>

    <br/><br/>

    <li><strong>Subscription</strong>: A connection between you and the Observable.
        You can stop it by calling <code>unsubscribe()</code>.</li>

    <br/><br/>

    <li><strong>Operators</strong>: Functions that change the stream.
        Example: <code>map()</code>, <code>filter()</code>, <code>debounceTime()</code>.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basic Example</h3>
<ol>
    <li>Create an <code>Observable</code> that sends 1, 2, 3:</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">import { of } from 'rxjs';

const numbers$ = of(1, 2, 3);

numbers$.subscribe(value =&gt; {
  console.log(value);
});
</code></pre>

    <br/><br/>

    <li><code>of()</code> creates a stream with fixed values.</li>

    <br/><br/>

    <li><code>subscribe()</code> prints each value when it arrives.</li>

    <br/>
</ol>
<br/>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Example with Operators</h3>
<ol>
    <li>Use <code>map()</code> to change each value before it reaches you:</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">import { of, map } from 'rxjs';

const numbers$ = of(1, 2, 3)
  .pipe(
    map(n =&gt; n * 10)
  );

numbers$.subscribe(result =&gt; {
  console.log(result); // 10, 20, 30
});
</code></pre>

    <br/><br/>

    <li><code>pipe()</code> lets you add operators step by step.</li>

    <br/><br/>

    <li>Operators do not change the original stream,
        they create a new stream with new values.</li>

    <br/>
</ol>
<br/>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Does <code>of()</code> emit immediately?</h3>
<ol>
    <li><code>of(1, 2, 3)</code> creates a stream that sends 1, then 2, then 3 as soon as you subscribe.</li>
    <br/><br/>

    <li>It is a "cold" <code>Observable</code>: each subscriber gets the same values from the start.</li>
    <br/><br/>

    <li>So yes — your code will print three values right after <code>subscribe()</code> runs.</li>
    <br/>
<pre class="line-numbers"><code class="language-ts">import { of } from 'rxjs';

const numbers$ = of(1, 2, 3);

numbers$.subscribe(v =&gt; console.log(v)); // 1, 2, 3 (sync, one after another)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How do I add values later and trigger <code>subscribe()</code>?</h3>
<ol>
    <li>Normal Observables (like from <code>of()</code>) are "read-only" from the outside.<br/><br/>
        You cannot push new values into them after creation.</li>

    <br/><br/><br/>

    <li>To push values yourself, use a <code>Subject</code> (or <code>BehaviorSubject</code>, <code>ReplaySubject</code>).<br/><br/>
        They have a <code>next(value)</code> method that emits to all subscribers.</li>

    <br/><br/><br/>

    <li>Or build your own Observable with <code>new Observable()</code> and call <code>observer.next(...)</code> inside.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Add values with <code>Subject</code> (most common)</h3>
<ol>
    <li><code>Subject</code> starts empty. You push values using <code>next()</code>.</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">import { Subject } from 'rxjs';

const clicks$ = new Subject&lt;number&gt;();

// Listen
clicks$.subscribe(v =&gt; console.log('A:', v));
clicks$.subscribe(v =&gt; console.log('B:', v));

// Emit (later, anywhere you hold the subject)
clicks$.next(1);  // A: 1, B: 1
clicks$.next(2);  // A: 2, B: 2
</code></pre>

    <br/><br/>

    <li>Use it for event streams: buttons, sockets, custom signals.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Keep latest value with <code>BehaviorSubject</code></h3>
<ol>
    <li><code>BehaviorSubject</code> needs an initial value and always remembers the latest value.</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">
import { BehaviorSubject } from 'rxjs';

const count$ = new BehaviorSubject&lt;number&gt;(0); // initial value 0

count$.subscribe(v =&gt; console.log('First:', v)); // First: 0

count$.next(1);
count$.next(2);

count$.subscribe(v =&gt; console.log('Second (late):', v)); // Second (late): 2 (gets latest immediately)
</code></pre>

    <br/><br/>

    <li>Great for app state: user, theme, cart, form values.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Build your own Observable (custom producer)</h3>
<ol>
    <li>Use <code>new Observable()</code> when you want control over how values are produced.</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">import { Observable } from 'rxjs';

const ticker$ = new Observable&lt;number&gt;((observer) =&gt; {
    let n = 0;
    const id = setInterval(() =&gt; {
        observer.next(n++);                 // push next number every 500ms
        if (n === 5) observer.complete();   // finish after 5 values
    }, 500);

    // cleanup on unsubscribe
    return () =&gt; clearInterval(id);
});

const sub = ticker$.subscribe({
    next: v =&gt; console.log('tick', v),
    complete: () =&gt; console.log('done'),
});

// Later, if needed: sub.unsubscribe();
</code></pre>

    <br/><br/>

    <li>Good when wrapping <code>setInterval</code>, DOM events, or 3rd-party APIs.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Cold vs Hot (quick idea)</h3>
<ol>
    <li><strong>Cold</strong> (e.g., <code>of()</code>, <code>from()</code>, HTTP):
        each subscriber gets the same sequence from the start.</li>
    <br/><br/>

    <li><strong>Hot</strong> (e.g., <code>Subject</code>, DOM events):
        values happen regardless of subscribers,
        late subscribers may miss older values.</li>
    <br/><br/>

    <li><code>BehaviorSubject</code> is hot, but it replays the latest value to new subscribers.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>When emissions are not immediate</h3>
<ol>
    <li>Sources like <code>interval()</code>, <code>timer()</code>, HTTP calls, or user events emit later (async), not immediately.</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">import { interval, take } from 'rxjs';

interval(1000)
    .pipe(take(3))
    .subscribe(v =&gt; console.log(v)); // prints 0, 1, 2 — one per second
</code></pre>

    <br/><br/>

    <li>So: some streams are sync (<code>of()</code>), some are async (timers, HTTP, UI events).</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Why does Angular HTTP use cold Observables?</h3>
<ol>
    <li>Angular’s <code>HttpClient.get(...)</code> returns a <b>cold</b> Observable.
        This means: the request is sent <em>only when you subscribe</em>.</li>

    <br/><br/>

    <li>Each subscription triggers a <em>new</em> HTTP call.
        This is good for one-off requests (like loading a page) and for retry logic.</li>

    <br/><br/>

    <li>Why cold?
        So your code is predictable: you control <em>when</em> the request happens and you can easily cancel it by unsubscribing.</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">import { HttpClient } from '@angular/common/http';import { shareReplay } from 'rxjs';

class UserService {
    constructor(private http: HttpClient) {}

    // Each subscribe triggers a NEW request (cold)
    loadUsers() {
        return this.http.get('/api/users');
    }

    // If you want to SHARE one request with many subscribers: (First subscriber sends request, later subscribers reuse the result.)
    loadUsersShared() {
        return this.http.get('/api/users')
            .pipe(
                shareReplay(1) // cache the last value for new subscribers
            );
    }
}
</code></pre>
    <br/><br/>

    <li><strong>Tip:</strong> If you see duplicate HTTP calls, you likely subscribed more than once.
        Use <code>shareReplay(1)</code> if you want to share one result.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Why do forms often use <code>BehaviorSubject</code>?</h3>
<ol>
    <li>Forms need to keep the <em>current</em> state: values, errors, dirty/touched flags.
        New listeners (like a new component) must get the latest state right away.</li>

    <br/><br/>

    <li><code>BehaviorSubject</code> is perfect here: it always has a current value and gives it to new subscribers immediately.</li>

    <br/><br/>

    <li>Angular’s <code>FormControl.valueChanges</code> is an Observable of values over time.
        If you keep a mirror of form state yourself, a <code>BehaviorSubject</code> makes it simple.</li>

    <br/>

<pre class="line-numbers"><code class="language-ts">import { BehaviorSubject } from 'rxjs';

type Profile = { name: string; email: string };

class ProfileStore {
  // start with an initial value
  private readonly _state = new BehaviorSubject&lt;Profile&gt;({ name: '', email: '' });

  // expose as Observable for read-only access
  state$ = this._state.asObservable();

  // update from anywhere (e.g., form handlers)
  update(patch: Partial&lt;Profile&gt;) {
    const current = this._state.value;     // latest value
    this._state.next({ ...current, ...patch });
  }
}

// somewhere in your component:
// store.state$.subscribe(profile =&gt; render(profile));
// form.valueChanges.subscribe(val =&gt; store.update(val));
</code></pre>

    <br/><br/>

    <li><strong>Result:</strong> Any subscriber (new or old) immediately sees the current form state and any future changes.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->
<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
