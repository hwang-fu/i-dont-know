<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>About PostgreSQL</title>

    <!-- Prism core -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>

    <!-- Line numbers plugin CSS -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <!-- SQL language support -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-sql.min.js"></script>

<style>
    /* Make comments grey */
    .token.comment {
        color: #888;
    }
    .token.keyword {
        font-weight: 500;
    }
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    body {
        font-family: "KaiTi", "æ¥·ä½“", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "æ¥·ä½“", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<nav id="toc" style="margin-bottom: 2rem;">
    <h2>ðŸ“˜ PostgreSQL Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#creating-tables">Creating Tables in PostgreSQL</a></li>
        <li><a href="#schemas">Understanding Schemas in PostgreSQL</a></li>
        <li><a href="#insert-data">Inserting Data into Tables</a></li>
        <li><a href="#select">Selecting Data from Tables</a></li>
        <li><a href="#concat">Concatenating Strings</a></li>
        <li><a href="#drop">Dropping Tables</a></li>
        <li><a href="#where">WHERE Clause and Operators</a></li>
        <li><a href="#db-design">Database Design</a></li>
        <li><a href="#primary-key">Primary Key Constraint</a></li>
        <li><a href="#not-null">NOT NULL Constraint</a></li>
        <li><a href="#default">DEFAULT Constraint</a></li>
        <li><a href="#check">CHECK Constraint</a></li>
        <li><a href="#foreign-key">Foreign Keys</a></li>
        <li><a href="#joins">Joining Tables</a></li>
        <li><a href="#set-ops">Set Operations</a></li>
        <li><a href="#boolean">Boolean Type</a></li>
        <li><a href="#text-types">CHAR, VARCHAR, and TEXT Types</a></li>
        <li><a href="#integer">Integer Types</a></li>
        <li><a href="#decimal">Decimal (NUMERIC) Type</a></li>
        <li><a href="#date-time">Date and Time Types</a></li>
        <li><a href="#uuid">UUID Type</a></li>
        <li><a href="#cte">Common Table Expressions (CTE)</a></li>
        <li><a href="#view">View</a></li>
        <li><a href="#materialized-view">Materialized View</a></li>
        <li><a href="#pg-case">CASE Expression</a></li>
        <li><a href="#pg-coalesce">COALESCE Function</a></li>
        <li><a href="#pg-nullif">NULLIF Function</a></li>
        <li><a href="#pg-least-greatest">LEAST and GREATEST</a></li>
        <li><a href="#pg-like">Details on LIKE</a></li>
        <li><a href="#pg-extensions">Extensions</a></li>
        <li><a href="#pg-create-extensions">How to Create Extensions</a></li>
        <li><a href="#pg-regex">Regular Expression</a></li>
        <li><a href="#pg-similar-to">SIMILAR TO</a></li>
        <li><a href="#pg-full-text-search-basics">Basics on Full Text Search</a></li>
        <li><a href="#pg-udf">User-defined Functions</a></li>
        <li><a href="#pg-procedures">Stored Procedures</a></li>
        <li><a href="#pg-transactions">Transactions</a></li>
    </ul>
</nav>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="creating-tables">Creating Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In PostgreSQL, a <U>table</u> is a structured collection of rows and columns where data is stored.</li>
        <br/>
        <li>You define a table using the <b>CREATE TABLE</b> command, specifying the column names, data types, and optional constraints (like <code>PRIMARY KEY</code>, <code>NOT NULL</code>, or <code>UNIQUE</code>).</li>
        <br/>
        <li>Tables belong to a <u>schema</u> within a database. By default, they are created inside the <code>public</code> schema unless another one is specified.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name1 data_type [constraint],
    column_name2 data_type [constraint],
    ...
    [table_constraints]
);
</code></pre>
    <br/>
    <ul>
        <li><code>table_name</code>: the name of your new table.</li>
        <li><code>column_name</code>: the name of each column in that table.</li>
        <li><code>data_type</code>: defines the kind of data stored (e.g., <code>INTEGER</code>, <code>TEXT</code>, <code>BOOLEAN</code>, <code>DATE</code>, etc.).</li>
        <li><code>[constraint]</code>: optional restrictions like <code>NOT NULL</code>, <code>DEFAULT</code>, etc.</li>
        <li><code>[table_constraints]</code>: rules applying to multiple columns, e.g. primary keys, foreign keys.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Creating a Simple Table</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  VARCHAR(50) NOT NULL,
    last_name   VARCHAR(50) NOT NULL,
    hire_date   DATE NOT NULL DEFAULT CURRENT_DATE,
    active      BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li><code>SERIAL</code> automatically creates an auto-incrementing integer column (in modern PostgreSQL, use <code>GENERATED ALWAYS AS IDENTITY</code> instead).</li>
        <li><code>PRIMARY KEY</code> ensures each row has a unique, non-null identifier.</li>
        <li><code>VARCHAR(50)</code> defines a text field up to 50 characters.</li>
        <li><code>DEFAULT CURRENT_DATE</code> auto-fills with today's date when no value is given.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Modern Auto-Increment Syntax (Preferred)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL,
    department  TEXT DEFAULT 'General'
);
</code></pre>
    <br/>
    <ul>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is the SQL-standard version of <code>SERIAL</code>.</li>
        <li>You can also use <code>GENERATED BY DEFAULT AS IDENTITY</code> if you want to allow manual insertion of custom IDs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding Table-Level Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id      INT GENERATED ALWAYS AS IDENTITY,
    customer_id   INT NOT NULL,
    order_total   NUMERIC(10,2) NOT NULL CHECK (order_total &gt;= 0),
    order_date    TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (order_id),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
</code></pre>
    <br/>
    <ul>
        <li><code>CHECK (order_total &gt;= 0)</code> ensures totals can't be negative.</li>
        <li><code>PRIMARY KEY</code> and <code>FOREIGN KEY</code> constraints can appear at the bottom as table-level definitions.</li>
        <li><code>NUMERIC(10,2)</code> means up to 10 digits total, 2 after the decimal point.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Common Data Types</b></li>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>INTEGER</code>, <code>BIGINT</code>, <code>SMALLINT</code></td>
                <td>42</td>
                <td>Whole numbers, various ranges.</td>
            </tr>
            <tr>
                <td><code>NUMERIC(p, s)</code></td>
                <td>1234.56</td>
                <td>Fixed-point precision numbers (money, totals).</td>
            </tr>
            <tr>
                <td><code>TEXT</code>, <code>VARCHAR(n)</code>, <code>CHAR(n)</code></td>
                <td>'Hello'</td>
                <td>Variable or fixed-length strings.</td>
            </tr>
            <tr>
                <td><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code></td>
                <td>'2025-01-01'</td>
                <td>Date and time storage.</td>
            </tr>
            <tr>
                <td><code>BOOLEAN</code></td>
                <td>TRUE / FALSE</td>
                <td>Logical values.</td>
            </tr>
            <tr>
                <td><code>JSON</code>, <code>JSONB</code></td>
                <td>'{"key": "value"}'</td>
                <td>Structured JSON data (JSONB is binary-optimized).</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Creating Tables in a Specific Schema</b></li>
<pre><code class="language-sql line-numbers">CREATE SCHEMA company;

CREATE TABLE company.departments (
    id   INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);
</code></pre>
    <br/>
    <ul>
        <li>By default, PostgreSQL creates tables under the <code>public</code> schema.</li>
        <li>Use <code>CREATE SCHEMA</code> to organize tables logically (e.g., per project or domain).</li>
        <li>You can qualify table names like <code>schema_name.table_name</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Tables</b></li>
<pre><code class="language-sql line-numbers">-- List all tables in current database
\dt

-- List tables in a specific schema
\dt company.*

-- Show table structure
\d employees
</code></pre>
    <br/>
    <ul>
        <li>These commands are used inside the <code>psql</code> interactive terminal.</li>
        <li><code>\dt</code> lists tables, <code>\d &lt;table&gt;</code> describes structure, columns, and constraints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Altering or Dropping Tables</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees ADD COLUMN email TEXT;
ALTER TABLE employees DROP COLUMN active;
DROP TABLE employees;
</code></pre>
    <br/>
    <ul>
        <li><code>ALTER TABLE</code> allows adding/removing columns or modifying constraints.</li>
        <li><code>DROP TABLE</code> permanently deletes the table (and all its data).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="schemas">Understanding Schemas in PostgreSQL</h3>
<ol>
    <li><b>What is a Schema?</b></li>
    <br/>
    <ul>
        <li>A <b>schema</b> in PostgreSQL is like a <u>folder</u> or <u>namespace</u> inside a database.</li>
        <br/>
        <li>Each schema contains its own set of tables, views, functions, and other objects â€” just like different folders can contain different files.</li>
        <br/>
        <li>This allows you to:
            <ul>
                <li>Organize your database objects logically (e.g. <code>hr.employees</code>, <code>sales.orders</code>).</li>
                <li>Have tables with the same name in different schemas without conflict (e.g. <code>test.users</code> vs <code>prod.users</code>).</li>
                <li>Control access permissions at a schema level.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Database vs Schema</b></li>
    <br/>
    <ul>
        <li>PostgreSQL databases are the top-level containers.</li>
        <br/>
        <li>A schema lives <u>inside</u> a database, and tables live inside a schema.</li>
    </ul>
<pre><code class="language-text">
Database â†’ Schema â†’ Table â†’ Row
</code></pre>
    <br/>
    <ul>
        <li>For example, you might have a database called <code>company_db</code>, which contains two schemas:</li>
    </ul>
<pre><code class="language-text">
company_db
 â”œâ”€â”€ public
 â”‚    â”œâ”€â”€ employees
 â”‚    â”œâ”€â”€ departments
 â”‚
 â””â”€â”€ analytics
      â”œâ”€â”€ sales_summary
      â”œâ”€â”€ monthly_reports
</code></pre>
    <br/>
    <ul>
        <li>This way, you can separate your operational data (<code>public</code>) from analytical data (<code>analytics</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Default Schema: public</b></li>
    <br/>
    <ul>
        <li>When you first create a new database, PostgreSQL automatically creates a schema named <code>public</code>.</li>
        <br/>
        <li>Unless you specify otherwise, every table, view, or function you create goes into the <code>public</code> schema.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- This table is created inside the default "public" schema
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li>Its full name is actually <code>public.users</code>, even if you normally omit the schema prefix.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating a Custom Schema</b></li>
<pre><code class="language-sql line-numbers">CREATE SCHEMA hr;
CREATE SCHEMA sales;
</code></pre>
    <br/>
    <ul>
        <li>Now you have two additional namespaces: <code>hr</code> and <code>sales</code>.</li>
        <br/>
        <li>You can create tables inside them using a schema-qualified name:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE hr.employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    position TEXT
);

CREATE TABLE sales.orders (
    id SERIAL PRIMARY KEY,
    amount NUMERIC(10,2),
    customer TEXT
);
</code></pre>
    <br/>
    <ul>
        <li>Now <code>hr.employees</code> and <code>sales.orders</code> are two independent tables, even though both live in the same database.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing Tables in Schemas</b></li>
<pre><code class="language-sql line-numbers">-- Access table using schema-qualified name
SELECT * FROM hr.employees;

-- Access table from the default "public" schema
SELECT * FROM public.users;
</code></pre>
    <br/>
    <ul>
        <li>You always access tables by <code>schema_name.table_name</code>.</li>
        <br/>
        <li>If you omit the schema, PostgreSQL looks for the table in the schemas listed in the current <b>search_path</b> (see below).</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Search Path</b></li>
    <br/>
    <ul>
        <li>The <b>search_path</b> is the list of schemas that PostgreSQL looks through when you reference an object without a schema prefix.</li>
        <br/>
        <li>By default, it is usually:</li>
    </ul>
<pre><code class="language-sql line-numbers">SHOW search_path;

-- Output example:
-- "public", "$user"
</code></pre>
    <br/>
    <ul>
        <li>This means:
            <ul>
                <li>First, PostgreSQL looks for the object in <code>public</code>.</li>
                <li>Then, it looks for a schema with the same name as the current user.</li>
            </ul>
        </li>
        <br/>
        <li>You can change the search path to prioritize another schema:</li>
    </ul>
<pre><code class="language-sql line-numbers">SET search_path TO hr, public;

-- Now "employees" means "hr.employees"
SELECT * FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>When working on large projects, this helps you avoid writing <code>hr.</code> or <code>sales.</code> all the time.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Schema</b></li>
<pre><code class="language-sql line-numbers">DROP SCHEMA hr;

-- Or remove all its objects automatically:
DROP SCHEMA hr CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>DROP SCHEMA hr;</code> will fail if the schema is not empty.</li>
        <li><code>CASCADE</code> deletes the schema and all contained tables, views, and functions.</li>
        <li>Use <code>CASCADE</code> with caution â€” this is irreversible!</li>
    </ul>
    <br/>
    <br/>


    <li><b>Schema Permissions</b></li>
    <br/>
    <ul>
        <li>You can grant or revoke access to schemas independently of table permissions.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- Grant a user permission to create objects in a schema
GRANT CREATE ON SCHEMA sales TO alice;

-- Allow a user to use (read from) the schema
GRANT USAGE ON SCHEMA hr TO bob;
</code></pre>
    <br/>
    <ul>
        <li><code>USAGE</code> allows access to existing objects inside the schema.</li>
        <li><code>CREATE</code> allows creating new objects within that schema.</li>
        <li>Combining these allows a user to both read and create inside that namespace.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to Use Schemas</b></li>
    <br/>
    <ul>
        <li><b>Organizing modules</b>: for example, <code>hr</code>, <code>finance</code>, and <code>sales</code> schemas in a company database.</li>
        <br/>
        <li><b>Separating environments</b>: e.g., <code>dev</code>, <code>test</code>, <code>prod</code> schemas in the same database for testing purposes.</li>
        <br/>
        <li><b>Multi-tenant applications</b>: one schema per customer, while keeping all data in a single database.</li>
        <br/>
        <li><b>Access control</b>: different roles can have access to different schemas.</li>
    </ul>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <li>A <b>schema</b> is a namespace inside a PostgreSQL database that groups related tables and objects together.</li>
        <br/>
        <li>By default, all objects go into the <code>public</code> schema, but you can create your own with <code>CREATE SCHEMA</code>.</li>
        <br/>
        <li>Access tables as <code>schema_name.table_name</code>, or adjust <code>search_path</code> for convenience.</li>
        <br/>
        <li>Use schemas to organize projects, control permissions, and keep your database clean and modular.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="insert-data">Inserting Data into Tables</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Once you've created a table, you can add rows of data using the <code>INSERT INTO</code> statement.</li>
        <br/>
        <li>Each inserted row corresponds to one record in the table, containing values for one or more columns.</li>
        <br/>
        <li>PostgreSQL allows flexible insertion:
            <ul>
                <li>Insert all columns at once.</li>
                <li>Insert into selected columns only.</li>
                <li>Insert multiple rows in a single command.</li>
                <li>Insert data from another table or query.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO &lt;table_name&gt; (&lt;column1&gt;, &lt;column2&gt;, &lt;column3&gt;, ...)
VALUES (&lt;value1&gt;, &lt;value2&gt;, &lt;value3&gt;, ...);
</code></pre>
    <br/>
    <br/>


    <li><b>Example: Simple Insert</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES ('Alice', 'Johnson', 'Engineering');
</code></pre>
    <br/>
    <ul>
        <li>The <code>employee_id</code> column (if auto-generated) does not need to be specified, PostgreSQL fills it automatically.</li>
        <li>String literals are enclosed in single quotes (<code>'...'</code>).</li>
        <li>After execution, a new row appears in <code>employees</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting into All Columns</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees
VALUES (DEFAULT, 'Bob', 'Smith', 'Sales');
</code></pre>
    <br/>
    <ul>
        <li>If you omit the column list, you must provide a value for every column in order.</li>
        <li>Use <code>DEFAULT</code> to let PostgreSQL fill an auto-generated value (like an identity or timestamp).</li>
        <li>This form is more error-prone â€” prefer naming columns explicitly when possible.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Multiple Rows at Once</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES
    ('Charlie', 'Wang', 'Finance'),
    ('Diana', 'Lopez', 'Marketing'),
    ('Ethan', 'Neuer', 'IT');
</code></pre>
    <br/>
    <ul>
        <li>This is faster and cleaner than running multiple <code>INSERT</code> statements.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name)
VALUES ('Frank', 'Baker');

INSERT INTO employees (first_name, last_name, department)
VALUES ('Grace', 'Kim', DEFAULT);
</code></pre>
    <br/>
    <ul>
        <li>If a column has a <code>DEFAULT</code> value, you can omit it or explicitly use <code>DEFAULT</code>.</li>
        <li>In both cases, PostgreSQL automatically fills in the default.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Data from Another Table</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO archived_employees (first_name, last_name, department)
SELECT first_name, last_name, department
FROM employees
WHERE active = FALSE;
</code></pre>
    <br/>
    <ul>
        <li>Instead of manually typing values, you can pull data from an existing table or query.</li>
        <li>This is useful for:
            <ul>
                <li>Archiving old records,</li>
                <li>Duplicating data,</li>
                <li>Creating backups or subsets.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Returning Values After Insert</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES ('Helene', 'Zabak', 'Operations')
RETURNING employee_id;
</code></pre>
    <br/>
    <ul>
        <li>The <code>RETURNING</code> clause immediately outputs data from the newly inserted row(s).</li>
        <li>You can return multiple columns:
<pre><code class="language-sql line-numbers">RETURNING employee_id, first_name, hire_date;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling Conflicts (Upserts)</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (employee_id, first_name, last_name, department)
VALUES (1, 'Ian', 'Miller', 'Engineering')
ON CONFLICT (employee_id) DO UPDATE SET department = EXCLUDED.department;
</code></pre>
    <br/>
    <ul>
        <li><code>ON CONFLICT</code> handles cases where an insert violates a unique or primary key constraint.</li>
        <li><code>EXCLUDED</code> refers to the new row that caused the conflict.</li>
        <li>You can:
            <ul>
                <li><code>DO NOTHING</code> to skip the row, or</li>
                <li><code>DO UPDATE</code> to modify the existing row.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Full Insert Scenario</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    id           SERIAL PRIMARY KEY,
    name         TEXT NOT NULL,
    email        TEXT UNIQUE,
    created_at   TIMESTAMP DEFAULT NOW()
);

INSERT INTO customers (name, email)
VALUES
    ('Alice Green', 'alice@example.com'),
    ('Bob White', 'bob@example.com');

INSERT INTO customers (name, email)
VALUES ('Alice Green', 'alice@example.com')
ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
</code></pre>
    <br/>
    <ul>
        <li>The first insert adds two new customers.</li>
        <li>The second one updates an existing customer (instead of erroring) because of the <code>ON CONFLICT</code> rule.</li>
        <li><code>NOW()</code> automatically sets the timestamp.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="select">Basics on Selecting Data from Tables</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>SELECT</code> statement in PostgreSQL is used to <u>query</u> data from one or more tables.</li>
        <br/>
        <li>PostgreSQL processes <code>SELECT</code> queries logically in this order:
<pre><code class="language-text">FROM â†’ WHERE â†’ GROUP BY â†’ HAVING â†’ SELECT â†’ ORDER BY â†’ LIMIT</code></pre>
        </li>
        <br/>
        <li>This order matters when you design complex queries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT &lt;column1&gt;, &lt;column2&gt;, ...
FROM &lt;table_name&gt;;
</code></pre>
    <br/>
    <ul>
        <li>You can select all columns using <code>*</code>, but it's better to specify only what you need.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Select All Columns</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>Retrieves every column and every row from <code>employees</code>.</li>
        <li>Useful for quick checks, but inefficient in production queries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Rows with WHERE</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name
FROM employees
WHERE department = 'Engineering';
</code></pre>
    <br/>
    <ul>
        <li><code>WHERE</code> filters rows based on a condition.</li>
        <li>Operators include:
            <ul>
                <li><code>=</code> equal</li>
                <li><code>&lt;&gt;</code> or <code>!=</code> not equal</li>
                <li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
                <li><code>AND</code>, <code>OR</code>, <code>NOT</code> for logical combinations</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering with Pattern Matching (LIKE)</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name
FROM employees
WHERE last_name LIKE 'S%';
</code></pre>
    <br/>
    <ul>
        <li><code>LIKE</code> is used for pattern matching with wildcards:
            <ul>
                <li><code>%</code>: matches any sequence of characters.</li>
                <li><code>_</code>: matches exactly one character.</li>
            </ul>
        </li>
        <li>Example: <code>'S%'</code> finds all last names starting with "S".</li>
    </ul>
    <br/>
    <br/>


    <li><b>Sorting Results with ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name, hire_date
FROM employees
ORDER BY hire_date DESC;
</code></pre>
    <br/>
    <ul>
        <li><code>ORDER BY</code> sorts rows by one or more columns.</li>
        <li>Use <code>ASC</code> (default) or <code>DESC</code> for descending order.</li>
        <li>You can sort by multiple columns:
<pre><code class="language-sql line-numbers">ORDER BY department ASC, last_name ASC;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Limiting Results with LIMIT and OFFSET</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
ORDER BY employee_id
LIMIT 5 OFFSET 10;
</code></pre>
    <br/>
    <ul>
        <li><code>LIMIT</code> restricts how many rows are returned.</li>
        <li><code>OFFSET</code> skips the given number of rows before starting output.</li>
        <li>Commonly used for pagination (e.g., "page 3, 10 results per page").</li>
    </ul>
    <br/>
    <br/>


    <li><b>Aliasing Columns and Tables</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name AS given,
    last_name AS family
FROM employees AS e;
</code></pre>
    <br/>
    <ul>
        <li>Aliases give temporary names to columns or tables for readability.</li>
        <li>You can omit <code>AS</code>, both forms work:
<pre><code class="language-sql line-numbers">SELECT first_name given, last_name family FROM employees e;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name, department
FROM employees
WHERE department = 'Sales'
    AND hire_date &gt;= '2024-01-01'
    OR active = TRUE;
</code></pre>
    <br/>
    <ul>
        <li>Use parentheses to control logical order:
<pre><code class="language-sql line-numbers">WHERE (department = 'Sales' AND hire_date &gt;= '2024-01-01') OR active = TRUE;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Distinct Rows</b></li>
<pre><code class="language-sql line-numbers">SELECT DISTINCT department
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li><code>DISTINCT</code> removes duplicate rows from the result set.</li>
        <li>You can apply it to one or multiple columns:
<pre><code class="language-sql line-numbers">SELECT DISTINCT department, active FROM employees;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Computed Columns and Expressions</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name,
    EXTRACT(YEAR FROM hire_date)   AS hire_year
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>You can create new columns by combining or transforming existing ones.</li>
        <li><code>||</code> concatenates strings.</li>
        <li><code>EXTRACT()</code> extracts a specific part (like year, month, day) from a date or timestamp.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Aggregating Data with GROUP BY</b></li>
<pre><code class="language-sql line-numbers">SELECT
    department,
    COUNT(*) AS total_employees
FROM employees
GROUP BY department;
</code></pre>
    <br/>
    <ul>
        <li><code>GROUP BY</code> groups rows by unique combinations of column values.</li>
        <li>Often used with aggregate functions:
            <ul>
                <li><code>COUNT()</code>: number of rows.</li>
                <li><code>SUM()</code>: total sum.</li>
                <li><code>AVG()</code>: average.</li>
                <li><code>MIN()</code> / <code>MAX()</code>: smallest / largest value.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Groups with HAVING</b></li>
<pre><code class="language-sql line-numbers">SELECT department, COUNT(*) AS total_employees
FROM employees
GROUP BY department
HAVING COUNT(*) &gt; 5;
</code></pre>
    <br/>
    <ul>
        <li><code>HAVING</code> filters groups (after aggregation), while <code>WHERE</code> filters individual rows (before aggregation).</li>
        <li>Example: only show departments with more than 5 employees.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Results with UNION</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name FROM employees
UNION
SELECT first_name, last_name FROM contractors;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION</code> merges two result sets and removes duplicates.</li>
        <li>Use <code>UNION ALL</code> to keep duplicates.</li>
        <li>Each <code>SELECT</code> must have the same number and type of columns.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="concat">Concatenating Strings in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>String concatenation means joining two or more strings together into a single text value.</li>
        <br/>
        <li>In PostgreSQL, you can concatenate strings using:
            <ul>
                <li>The concatenation operator <code>||</code> (most common and SQL-standard).</li>
                <li>The <code>CONCAT()</code> function.</li>
                <li>The <code>CONCAT_WS()</code> function (concatenate with a separator).</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using the || Operator</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || ' ' || 'World' AS greeting;
</code></pre>
    <br/>
    <ul>
        <li>The <code>||</code> operator joins strings directly.</li>
        <li>In this example, PostgreSQL returns <code>Hello World</code>.</li>
        <li>You can concatenate columns and literals together as well:</li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name
FROM employees;
</code></pre>
        <li>This is the most widely used approach for text combination in PostgreSQL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling NULLs with ||</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || NULL || 'World' AS result;
</code></pre>
    <br/>
    <ul>
        <li>If any operand is <code>NULL</code>, the entire concatenated result becomes <code>NULL</code>.</li>
        <li>Example result: <code>NULL</code>.</li>
        <li>To avoid this, use the <code>COALESCE()</code> function to replace <code>NULL</code> with an empty string:</li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || COALESCE(NULL, '') || 'World' AS safe_concat;</code></pre>
        <li>Result: <code>HelloWorld</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CONCAT()</b></li>
<pre><code class="language-sql line-numbers">SELECT CONCAT('Hello', ' ', 'World') AS greeting;
</code></pre>
    <br/>
    <ul>
        <li><code>CONCAT()</code> joins any number of arguments together.</li>
        <li>Unlike <code>||</code>, it automatically treats <code>NULL</code> as an empty string.</li>
        <li>Example:</li>
<pre><code class="language-sql line-numbers">SELECT CONCAT('Hello', NULL, 'World') AS greeting;</code></pre>
        <li>Result: <code>HelloWorld</code> (not <code>NULL</code>).</li>
        <li>This makes <code>CONCAT()</code> safer when dealing with nullable columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CONCAT_WS() â€” Concatenate with Separator</b></li>
<pre><code class="language-sql line-numbers">SELECT CONCAT_WS('-', '2025', '11', '10') AS formatted_date;
</code></pre>
    <br/>
    <ul>
        <li><code>CONCAT_WS(separator, arg1, arg2, ...)</code> stands for "Concatenate With Separator."</li>
        <li>The first argument is used as the separator between all other arguments.</li>
        <li><code>NULL</code> values are ignored automatically.</li>
        <li>Example with <code>NULL</code>:
<pre><code class="language-sql line-numbers">SELECT CONCAT_WS(' ', 'Alice', NULL, 'Johnson');</code></pre>
        <li>Result: <code>Alice Johnson</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concatenating Columns Example</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name,
    department || ' Department'    AS dept_name
FROM employees;
</code></pre>
    <br/>
    <br/>


    <li><b>Concatenation in UPDATE Statements</b></li>
<pre><code class="language-sql line-numbers">UPDATE employees
SET full_name = first_name || ' ' || last_name;
</code></pre>
    <br/>
    <ul>
        <li>You can use concatenation when updating data, for example, to fill a derived column.</li>
        <li>PostgreSQL evaluates the expressions on the right-hand side for each row.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concatenation with Numbers and Other Types</b></li>
<pre><code class="language-sql line-numbers">SELECT
    'Employee ID: ' || employee_id AS label
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL automatically casts numbers, booleans, and dates to text when concatenated with a string.</li>
        <li>You can also use explicit conversion for clarity:</li>
<pre><code class="language-sql line-numbers">SELECT 'Employee ID: ' || CAST(employee_id AS TEXT) FROM employees;</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting Example: Full Address</b></li>
<pre><code class="language-sql line-numbers">SELECT
    CONCAT_WS(', ',
        street,
        city,
        postal_code,
        country
    ) AS full_address
FROM customers;
</code></pre>
    <br/>
    <ul>
        <li>This builds a clean formatted address string, skipping <code>NULL</code> parts automatically.</li>
        <li>Example result: <code>"Main Street 5, Berlin, 10115, Germany"</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="drop">Dropping Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>DROP TABLE</code> statement permanently removes a table and all its data from a PostgreSQL database.</li>
        <br/>
        <li>When you drop a table, PostgreSQL deletes:
            <ul>
                <li>All rows stored in the table.</li>
                <li>Associated indexes and constraints.</li>
                <li>Any dependent objects (if you use <code>CASCADE</code>).</li>
            </ul>
        </li>
        <br/>
        <li>Once dropped, the data <mark>cannot</mark> be recovered unless you have a backup.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE &lt;table_name&gt;;
</code></pre>
    <br/>
    <ul>
        <li><code>table_name</code> â€” the name of the table you want to delete.</li>
        <li>If the table doesn't exist, PostgreSQL will raise an error unless you use <code>DROP TABLE IF EXISTS</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Dropping a Table</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE employees;
</code></pre>
    <br/>
    <ul>
        <li>Deletes the <code>employees</code> table completely from the database.</li>
        <li>All its data, indexes, and constraints are removed permanently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Safely Dropping a Table</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE IF EXISTS employees;
</code></pre>
    <br/>
    <ul>
        <li>Prevents an error if the table does not exist.</li>
        <li>This is a safer way to clean up tables, especially in scripts or migrations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping Multiple Tables</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE IF EXISTS employees, departments, projects;
</code></pre>
    <br/>
    <ul>
        <li>You can drop multiple tables in one command by separating their names with commas.</li>
        <li>Each table will be dropped in the order listed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CASCADE and RESTRICT</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE employees CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>CASCADE</code> automatically drops any dependent objects (like foreign keys in other tables, views, or triggers).</li>
        <li>Use carefully â€” this can remove more than you expect!</li>
        <li>To prevent accidental cascade deletion, use <code>RESTRICT</code> (the default behavior):</li>
<pre><code class="language-sql line-numbers">DROP TABLE employees RESTRICT;</code></pre>
        <li>PostgreSQL will refuse to drop the table if anything depends on it.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Example: Dropping with Dependencies</b></li>
<pre><code class="language-sql line-numbers">-- Example: "customers" table references "orders" through a foreign key
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY
);

CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id)
);

-- Dropping the parent table with CASCADE
DROP TABLE orders CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>CASCADE</code> tells PostgreSQL to remove not only the <code>orders</code> table itself, but also any <u>objects that depend on it</u> â€” such as foreign key constraints, views, or triggers.</li>
        <br/>
        <li>In this example:
            <ul>
                <li>The table <code>orders</code> is permanently deleted.</li>
                <li>The foreign key constraint (inside <code>customers</code>) is automatically removed, so <code>customers.order_id</code> can take whatever values it wants in the future.</li>
                <li>The <code>customers</code> table itself remains intact â€” only the relationship to <code>orders</code> is dropped.</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL will also print a notice similar to:
<pre><code class="language-text">NOTICE:  drop cascades to constraint customers_order_id_fkey on table customers
DROP TABLE
</code></pre>
        </li>
        <br/>
        <li>Always double-check before using <code>CASCADE</code>, as it can remove multiple dependent objects automatically.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Dropping a Table in a Specific Schema</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE company.employees;
</code></pre>
    <br/>
    <ul>
        <li>If the table belongs to a non-default schema, include the schema name.</li>
        <li>Example: <code>company.employees</code> drops the <code>employees</code> table inside the <code>company</code> schema.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking if a Table Exists</b></li>
<pre><code class="language-sql line-numbers">-- Using psql meta-command
\dt

-- Or query the catalog directly
SELECT tablename
FROM pg_catalog.pg_tables
WHERE tablename = 'employees';
</code></pre>
    <br/>
    <ul>
        <li><code>\dt</code> lists all tables in the current database (works in <code>psql</code>).</li>
        <li>Alternatively, query the <code>pg_catalog.pg_tables</code> system table to check existence programmatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Practical Tip: Use Transactions</b></li>
<pre><code class="language-sql line-numbers">BEGIN;
DROP TABLE employees;
ROLLBACK;
</code></pre>
    <br/>
    <ul>
        <li>During testing, wrap <code>DROP TABLE</code> inside a transaction.</li>
        <li><code>ROLLBACK</code> cancels the deletion if you change your mind before committing.</li>
        <li>This helps prevent irreversible data loss while experimenting.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="where">Filtering Rows with the WHERE Clause</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>WHERE</code> clause in PostgreSQL filters rows returned by a <code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement based on one or more conditions.</li>
        <br/>
        <li>It is evaluated <u>before</u> grouping or ordering results â€” only rows satisfying the condition(s) are kept.</li>
        <br/>
        <li>You can use logical operators (<code>AND</code>, <code>OR</code>, <code>NOT</code>), comparison operators (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, etc.), and range or set operators like <code>BETWEEN</code>, <code>IN</code>, and <code>LIKE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT column1, column2, ...
FROM table_name
WHERE condition;
</code></pre>
    <br/>
    <ul>
        <li><code>condition</code> can include comparisons, logical connectors, or functions that evaluate to <code>TRUE</code> or <code>FALSE</code>.</li>
        <li>Rows for which the condition is <code>TRUE</code> are returned; <code>FALSE</code> or <code>NULL</code> rows are excluded.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Operators</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Engineering';
</code></pre>
    <br/>
    <ul>
        <li><b>Common operators:</b></li>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
                <tr><td><code>=</code></td><td>Equal to</td><td><code>salary = 50000</code></td></tr>
                <tr><td><code>&lt;&gt;</code> or <code>!=</code></td><td>Not equal to</td><td><code>department &lt;&gt; 'IT'</code></td></tr>
                <tr><td><code>&gt;</code></td><td>Greater than</td><td><code>age &gt; 30</code></td></tr>
                <tr><td><code>&lt;</code></td><td>Less than</td><td><code>salary &lt; 40000</code></td></tr>
                <tr><td><code>&gt;=</code></td><td>Greater than or equal to</td><td><code>age &gt;= 18</code></td></tr>
                <tr><td><code>&lt;=</code></td><td>Less than or equal to</td><td><code>hire_date &lt;= '2025-01-01'</code></td></tr>
            </tbody>
        </table>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Conditions with AND, OR, NOT</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Sales'
    AND hire_date &gt;= '2024-01-01'
    OR active = TRUE;
</code></pre>
    <br/>
    <ul>
        <li>It is recommended to use parentheses for clarity:
<pre><code class="language-sql line-numbers">WHERE (department = 'Sales' AND hire_date &gt;= '2024-01-01') OR active = TRUE;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Ranges with BETWEEN</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE salary BETWEEN 40000 AND 60000;
</code></pre>
    <br/>
    <ul>
        <li><code>BETWEEN a AND b</code> is equivalent to <code>(salary &gt;= a AND salary &lt;= b)</code>.</li>
        <li>It <u>includes</u> both boundary values.</li>
        <li>You can use it with dates, numbers, or text:</li>
<pre><code class="language-sql line-numbers">WHERE hire_date BETWEEN '2024-01-01' AND '2024-12-31';</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering by a Set with IN</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department IN ('HR', 'IT', 'Finance');
</code></pre>
    <br/>
    <ul>
        <li><code>IN</code> checks whether a value matches any value in the provided list.</li>
        <li>Equivalent to multiple <code>OR</code> conditions:</li>
<pre><code class="language-sql line-numbers">WHERE department = 'HR' OR department = 'IT' OR department = 'Finance';</code></pre>
        <li>You can also use a subquery:
<pre><code class="language-sql line-numbers">WHERE department_id IN (SELECT id FROM departments WHERE active = TRUE);</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Pattern Matching with LIKE and ILIKE</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE last_name LIKE 'S%';
</code></pre>
    <br/>
    <ul>
        <li><code>LIKE</code> is case-sensitive pattern matching.</li>
        <li><code>ILIKE</code> is the case-insensitive version (PostgreSQL extension).</li>
        <li>Examples:</li>
<pre><code class="language-sql line-numbers">WHERE name LIKE  'A%';      -- starts with A
WHERE name LIKE  '%son';    -- ends with son
WHERE name ILIKE '%SMITH%'; -- contains 'smith' (case-insensitive)
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering NULL Values</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department IS NULL;

SELECT * FROM employees
WHERE department IS NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li><code>= NULL</code> does <u>not</u> work â€” use <code>IS NULL</code> and <code>IS NOT NULL</code>.</li>
        <li>This is because <code>NULL</code> represents "unknown", not an actual value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Membership with EXISTS</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.id = e.department_id
);
</code></pre>
    <br/>
    <ul>
        <li><code>EXISTS</code> checks whether a subquery returns at least one row.</li>
        <li>If it does, the condition is <code>TRUE</code>, otherwise <code>FALSE</code>.</li>
        <li>Often used for correlated subqueries and conditional joins.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using ANY and ALL</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE salary &gt; ANY (SELECT salary FROM interns);

SELECT * FROM employees
WHERE salary &gt; ALL (SELECT salary FROM interns);
</code></pre>
    <br/>
    <ul>
        <li><code>ANY</code> â€” condition is true if it holds for <u>at least one</u> value returned by the subquery.</li>
        <li><code>ALL</code> â€” condition must hold for <u>every</u> value returned by the subquery.</li>
        <li>These are useful when comparing against ranges of values dynamically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Multiple Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Finance'
    AND (salary BETWEEN 40000 AND 60000)
    AND active = TRUE
    AND last_name ILIKE 'J%';
</code></pre>
    <br/>
    <ul>
        <li>Conditions can be chained together in flexible and readable ways.</li>
        <li>Parentheses make the logic explicit and prevent ambiguity.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="db-design">Database Design in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Database design</u> is the process of organizing data into structured tables that represent real-world entities and their relationships.</li>
        <br/>
        <li>Good design ensures:
            <ul>
                <li>Data integrity (accuracy and consistency).</li>
                <li>Scalability (efficient growth with more data).</li>
                <li>Performance (fast queries and updates).</li>
                <li>Maintainability (easy schema evolution and clear relationships).</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL, as a relational database, uses <b>tables</b>, <b>keys</b>, and <b>relationships</b> to represent structured data logically and efficiently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 1: Identify Entities and Attributes</b></li>
    <br/>
    <ul>
        <li>Begin by identifying <b>entities</b> â€” objects or concepts you need to store data about (e.g. <code>customers</code>, <code>orders</code>, <code>products</code>).</li>
        <br/>
        <li>For each entity, determine its <b>attributes</b> â€” descriptive properties or fields.</li>
    </ul>
<pre><code class="language-text">
Entity: Customer
 â”œâ”€â”€ customer_id (primary key)
 â”œâ”€â”€ name
 â”œâ”€â”€ email
 â””â”€â”€ phone

Entity: Order
 â”œâ”€â”€ order_id (primary key)
 â”œâ”€â”€ customer_id (foreign key)
 â”œâ”€â”€ order_date
 â””â”€â”€ total_amount
</code></pre>
    <br/>
    <ul>
        <li>Each entity becomes a table, and each attribute becomes a column.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 2: Define Primary Keys</b></li>
    <br/>
    <ul>
        <li>A <b>primary key</b> uniquely identifies each row in a table.</li>
        <li>PostgreSQL commonly uses:
            <ul>
                <li><code>SERIAL</code> or <code>IDENTITY</code> columns for numeric IDs.</li>
                <li>Or <code>UUID</code> for globally unique identifiers.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name        TEXT NOT NULL,
    email       TEXT UNIQUE
);
</code></pre>
    <br/>
    <ul>
        <li>Each table should have exactly ONE primary key column or a composite key (a combination of multiple columns) when necessary.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 3: Define Relationships with Foreign Keys</b></li>
    <br/>
    <ul>
        <li><u>Foreign keys</u> define relationships between tables by referencing primary keys of other tables.</li>
        <li>They maintain <u>referential integrity</u>, ensuring that related data exists before referencing it.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id     SERIAL PRIMARY KEY,
    customer_id  INT REFERENCES customers(customer_id),
    order_date   DATE NOT NULL DEFAULT CURRENT_DATE,
    total_amount NUMERIC(10,2)
);
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>orders.customer_id</code> links each order to its corresponding customer.</li>
        <li>You can specify actions like <code>ON DELETE CASCADE</code> or <code>ON UPDATE SET NULL</code> for dependency behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 4: Normalize Your Data</b></li>
    <br/>
    <ul>
        <li><u>Normalization</u> is the process of structuring data to reduce redundancy and improve consistency.</li>
        <br/>
        <li>Common normal forms:
            <ul>
                <li><b>1NF (First Normal Form)</b> â€” No repeating groups or arrays, every field holds atomic values.</li>
                <li><b>2NF (Second Normal Form)</b> â€” Every non-key attribute depends entirely on the primary key.</li>
                <li><b>3NF (Third Normal Form)</b> â€” No transitive dependencies (non-key columns shouldn't depend on other non-key columns).</li>
            </ul>
        </li>
        <br/>
        <li>Example â€” Unnormalized table:</li>
<pre><code class="language-text">
orders
 â”œâ”€â”€ order_id
 â”œâ”€â”€ customer_name
 â”œâ”€â”€ customer_email
 â”œâ”€â”€ product_1
 â”œâ”€â”€ product_2
</code></pre>
        <li>Normalized design:</li>
<pre><code class="language-text">
customers
 â”œâ”€â”€ customer_id
 â”œâ”€â”€ name
 â”œâ”€â”€ email

orders
 â”œâ”€â”€ order_id
 â”œâ”€â”€ customer_id
 â”œâ”€â”€ order_date

order_items
 â”œâ”€â”€ order_id
 â”œâ”€â”€ product_id
 â”œâ”€â”€ quantity
</code></pre>
        <li>This separation avoids data duplication and keeps relationships clear.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 5: Add Constraints and Data Integrity Rules</b></li>
    <br/>
    <ul>
        <li>Constraints enforce rules at the database level:
            <ul>
                <li><code>NOT NULL</code> â€” prevents missing values.</li>
                <li><code>UNIQUE</code> â€” ensures no duplicates.</li>
                <li><code>CHECK</code> â€” validates data according to conditions.</li>
                <li><code>DEFAULT</code> â€” sets fallback values automatically.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    id        SERIAL PRIMARY KEY,
    name      TEXT NOT NULL,
    salary    NUMERIC(8,2) CHECK (salary &gt;= 0),
    active    BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>These ensure that invalid or inconsistent data cannot be inserted even by mistake.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 6: Use Indexes for Performance</b></li>
    <br/>
    <ul>
        <li><u>Indexes</u> speed up data retrieval by allowing faster lookups on large tables.</li>
        <li>PostgreSQL automatically creates an index for primary and unique keys, but you can add more as needed.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_employees_department ON employees(department);
</code></pre>
    <br/>
    <ul>
        <li>Use indexes wisely â€” they make reads faster but can slow down inserts and updates.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 7: Consider Denormalization (for Performance)</b></li>
    <br/>
    <ul>
        <li>In some high-performance or reporting cases, you may intentionally duplicate certain data to avoid complex joins.</li>
        <li>This is called <u>denormalization</u> â€” used to trade storage for speed.</li>
        <li>Example: storing <code>customer_name</code> directly inside <code>orders</code> for faster querying, even though it's also in <code>customers</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 8: Plan for Relationships â€” One-to-Many and Many-to-Many</b></li>
    <br/>
    <ul>
        <li><b>One-to-Many</b> â€” a customer can have many orders.</li>
<pre><code class="language-sql line-numbers">-- one-to-many
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
);
</code></pre>
        <li><b>Many-to-Many</b> â€” students can take many courses, and each course has many students.</li>
<pre><code class="language-sql line-numbers">-- many-to-many through a junction table
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id  INT REFERENCES courses(id),
    PRIMARY KEY (student_id, course_id)
);
</code></pre>
        <li>Use junction (bridge) tables for many-to-many relationships.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 9: Naming Conventions and Documentation</b></li>
    <br/>
    <ul>
        <li>Consistent naming improves readability and maintainability:
            <ul>
                <li>Use <code>snake_case</code> for all identifiers (e.g. <code>order_date</code>).</li>
                <li>Plural names for tables (<code>employees</code>, <code>orders</code>).</li>
                <li>Singular names for columns (<code>employee_id</code>).</li>
                <li>Prefix foreign keys with the table they reference (e.g. <code>customer_id</code> in <code>orders</code>).</li>
            </ul>
        </li>
        <li>Document your schema using comments:</li>
<pre><code class="language-sql line-numbers">COMMENT ON TABLE employees IS 'Stores employee data for the company';
COMMENT ON COLUMN employees.salary IS 'Monthly gross salary in euros';
</code></pre>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="primary-key">Primary Keys in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>primary key</u> is a column (or a group of columns) that uniquely identifies each row in a table.</li>
        <br/>
        <li>It ensures that:
            <ul>
                <li>No two rows have the same primary key value.</li>
                <li>The primary key value is never <code>NULL</code>.</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL automatically creates a unique <u>index</u> for every primary key to speed up lookups and enforce uniqueness.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type PRIMARY KEY,
    other_column data_type
);
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>PRIMARY KEY</code> constraint on a column to define it as the table's unique identifier.</li>
        <li>PostgreSQL automatically makes that column <code>NOT NULL</code> and <code>UNIQUE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple Primary Key</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li><code>SERIAL</code> automatically creates an integer column with an internal sequence generator.</li>
        <li>The primary key constraint guarantees that every <code>employee_id</code> value is unique and non-null.</li>
        <li>Primary keys are often numeric because they are efficient for indexing and joining tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using GENERATED AS IDENTITY (Modern SQL)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE departments (
    dept_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name    TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is the SQL-standard replacement for <code>SERIAL</code>.</li>
        <li>PostgreSQL manages the sequence automatically and ensures strict consistency.</li>
        <li>You can also use <code>GENERATED BY DEFAULT AS IDENTITY</code> to allow manual insertion of custom IDs if necessary.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Composite (Multi-Column) Primary Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE enrollments (
    student_id INT NOT NULL,
    course_id  INT NOT NULL,
    enrollment_date DATE DEFAULT CURRENT_DATE,
    PRIMARY KEY (student_id, course_id)
);
</code></pre>
    <br/>
    <ul>
        <li>Composite keys use multiple columns to uniquely identify a record.</li>
        <li>Here, the combination of <code>student_id</code> and <code>course_id</code> must be unique â€” but each one individually may repeat.</li>
        <li>Common in many-to-many relationship tables (also called junction tables).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a Primary Key to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ADD CONSTRAINT employees_pkey PRIMARY KEY (employee_id);
</code></pre>
    <br/>
    <ul>
        <li>If the table was created without a primary key, you can add one later using <code>ALTER TABLE</code>.</li>
        <li>The constraint name (here <code>employees_pkey</code>) can be chosen manually or left for PostgreSQL to assign automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Primary Key</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
DROP CONSTRAINT employees_pkey;
</code></pre>
    <br/>
    <ul>
        <li>You can remove a primary key if you plan to redefine it or change your table structure.</li>
        <li>However, be cautious â€” dropping a primary key may also affect <code>FOREIGN KEY</code> relationships referencing it.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Primary Key vs. Unique Constraint</b></li>
    <br/>
    <ul>
        <li>Both ensure uniqueness, but they serve different purposes:<br/><br/>
            <table>
                <thead>
                    <tr><th>Feature</th><th>PRIMARY KEY</th><th>UNIQUE</th></tr>
                </thead>
                <tbody>
                    <tr><td>NULL allowed?</td><td>No</td><td>Yes</td></tr>
                    <tr><td>Number per table</td><td>One only</td><td>Many allowed</td></tr>
                    <tr><td>Automatically indexed?</td><td>Yes</td><td>Yes</td></tr>
                    <tr><td>Purpose</td><td>Row identity</td><td>Prevent duplicate values</td></tr>
                </tbody>
            </table>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Primary Keys</b></li>
<pre><code class="language-sql line-numbers">-- Inside psql
\d employees

-- Query system catalog
SELECT
    tc.table_name,
    kc.column_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kc
    ON kc.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'PRIMARY KEY';
</code></pre>
    <br/>
    <ul>
        <li><code>\d table_name</code> shows primary keys directly in the <code>psql</code> terminal.</li>
        <li>You can also query the system catalog for programmatic inspection of constraints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior with Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
);
</code></pre>
    <br/>
    <ul>
        <li>Primary keys are the natural targets of <code>FOREIGN KEY</code> relationships.</li>
        <li>They guarantee that every foreign key in another table refers to a unique, existing row.</li>
        <li>If you delete a primary key row, PostgreSQL will enforce the foreign key's action (<code>CASCADE</code>, <code>SET NULL</code>, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing a Good Primary Key</b></li>
    <br/>
    <ul>
        <li>Follow these best practices:
            <ul>
                <li>Keep it <b>simple</b> â€” use one column if possible.</li>
                <li>Use <b>numeric</b> or <b>UUID</b> types for efficiency.</li>
                <li>Never change primary key values after creation.</li>
                <li>Choose a value that is <b>unique and stable</b> across the table's lifetime.</li>
            </ul>
        </li>
        <li>Examples of good candidates:
            <ul>
                <li>Auto-incrementing integers for internal identifiers.</li>
                <li>UUIDs for distributed or external systems.</li>
                <li>Composite keys for many-to-many link tables.</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="not-null">The NOT NULL Constraint in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>NOT NULL</code> constraint ensures that a column cannot contain a <code>NULL</code> value.</li>
        <br/>
        <li>In PostgreSQL, <code>NULL</code> represents "unknown" or "missing" data â€” not the same as an empty string or zero.</li>
        <br/>
        <li>By declaring a column as <code>NOT NULL</code>, you guarantee that every row must have a valid (non-NULL) value in that column.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type NOT NULL,
    ...
);
</code></pre>
    <br/>
    <ul>
        <li>Attach <code>NOT NULL</code> right after the data type in the column definition.</li>
        <li>If you try to insert a row without providing a value for that column, PostgreSQL will raise an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Defining NOT NULL Columns</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL,
    email       TEXT,
    hire_date   DATE NOT NULL DEFAULT CURRENT_DATE
);
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>first_name</code>, <code>last_name</code>, and <code>hire_date</code> must always contain valid values.</li>
        <li><code>email</code> is optional â€” it can be left <code>NULL</code>.</li>
        <li>If you omit a <code>NOT NULL</code> column in an <code>INSERT</code> statement, PostgreSQL will throw an error unless a <code>DEFAULT</code> value is provided.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Attempting to Insert NULL</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, hire_date)
VALUES (NULL, 'Smith', '2025-01-01');
</code></pre>
    <br/>
    <ul>
        <li>This will fail with an error like:</li>
<pre><code class="language-text">ERROR:  null value in column "first_name" of relation "employees" violates not-null constraint
DETAIL: Failing row contains (null, Smith, 2025-01-01).
</code></pre>
        <li>PostgreSQL prevents the insertion because <code>first_name</code> is defined as <code>NOT NULL</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a NOT NULL Constraint to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN email SET NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li>You can add <code>NOT NULL</code> later using <code>ALTER TABLE</code>, but only if all existing rows already have non-NULL values in that column.</li>
        <li>If some rows contain <code>NULL</code>, you must first update or delete them before applying the constraint.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Removing a NOT NULL Constraint</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN email DROP NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li>This makes the column nullable again, allowing future <code>NULL</code> values.</li>
        <li>Dropping <code>NOT NULL</code> is safe and does not affect existing data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT with NOT NULL</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE tasks (
    task_id SERIAL PRIMARY KEY,
    description TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending'
);
</code></pre>
    <br/>
    <ul>
        <li>Combining <code>NOT NULL</code> with a <code>DEFAULT</code> value ensures the column is always filled â€” even if the user doesn't explicitly provide a value.</li>
        <li>Example insert:</li>
<pre><code class="language-sql line-numbers">INSERT INTO tasks (description) VALUES ('Review code');
-- status automatically becomes 'pending'</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Which Columns Are NOT NULL</b></li>
<pre><code class="language-sql line-numbers">SELECT
    column_name,
    is_nullable
FROM information_schema.columns
WHERE table_name = 'employees';
</code></pre>
    <br/>
    <ul>
        <li>The <code>is_nullable</code> column will show <code>NO</code> for <code>NOT NULL</code> columns and <code>YES</code> for nullable ones.</li>
        <li>Useful for verifying schema constraints in large databases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NOT NULL vs. CHECK Constraints</b></li>
    <br/>
    <ul>
        <li>You could technically write a <code>CHECK (column IS NOT NULL)</code> constraint, but <code>NOT NULL</code> is faster, simpler, and the standard method.</li>
        <li>Both enforce the same rule, but <code>NOT NULL</code> is built into the column definition and optimized by PostgreSQL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior with Primary Keys</b></li>
    <br/>
    <ul>
        <li>Primary key columns are automatically <code>NOT NULL</code>, you don't need to specify it explicitly.</li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
</code></pre>
        <li>Even if you omit <code>NOT NULL</code>, the <code>PRIMARY KEY</code> constraint will enforce it internally.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="default">The DEFAULT Constraint in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>DEFAULT</code> constraint in PostgreSQL assigns an automatic value to a column when no value is specified during an <code>INSERT</code> operation.</li>
        <br/>
        <li>It helps maintain data consistency and prevents <code>NULL</code> values in cases where a sensible fallback value exists.</li>
        <br/>
        <li>Defaults can be constant values (like numbers or text), expressions, or even built-in PostgreSQL functions such as <code>CURRENT_DATE</code> or <code>NOW()</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type DEFAULT default_value,
    ...
);
</code></pre>
    <br/>
    <ul>
        <li>The <code>DEFAULT</code> keyword is placed after the data type when defining the column.</li>
        <li>If you omit the column in an <code>INSERT</code> statement, PostgreSQL automatically fills it with the default value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE tasks (
    task_id SERIAL PRIMARY KEY,
    description TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);
</code></pre>
    <br/>
    <ul>
        <li>When a new task is inserted without specifying <code>status</code> or <code>created_at</code>, PostgreSQL automatically assigns:
            <ul>
                <li><code>'pending'</code> to <code>status</code>.</li>
                <li>The current date and time (via <code>NOW()</code>) to <code>created_at</code>.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">INSERT INTO tasks (description) VALUES ('Write documentation');
-- status     â†’ 'pending'
-- created_at â†’ current timestamp
</code></pre>
    <br/>
    <br/>


    <li><b>Using DEFAULT with Numeric and Boolean Columns</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC(10,2) DEFAULT 0.00,
    available BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>If you omit <code>price</code> or <code>available</code> when inserting, PostgreSQL will assign <code>0.00</code> and <code>TRUE</code> respectively.</li>
        <li>This avoids the need to manually fill common defaults like <code>0</code>, <code>TRUE</code>, or <code>'N/A'</code> for each row.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT with Expressions</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) DEFAULT (0.0),
    order_ref TEXT DEFAULT ('ORD-' || EXTRACT(YEAR FROM CURRENT_DATE))
);
</code></pre>
    <br/>
    <ul>
        <li>Defaults can be expressions or function results â€” not just constants.</li>
        <li>Here:
            <ul>
                <li><code>CURRENT_DATE</code> fills in today's date automatically.</li>
                <li><code>('ORD-' || EXTRACT(YEAR FROM CURRENT_DATE))</code> generates a dynamic prefix for each order (e.g., <code>ORD-2025</code>).</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Explicit DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO tasks (description, status)
VALUES ('Review code', DEFAULT);
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>DEFAULT</code> keyword explicitly in <code>INSERT</code> statements to apply the column's predefined default value.</li>
        <li>This is especially useful when inserting into selected columns but still wanting defaults for others.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a DEFAULT Constraint to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN active SET DEFAULT TRUE;
</code></pre>
    <br/>
    <ul>
        <li>You can add or modify default values using <code>ALTER TABLE</code>.</li>
        <li>Defaults affect only <u>future</u> inserts â€” existing rows remain unchanged unless updated manually.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Removing a DEFAULT Constraint</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN active DROP DEFAULT;
</code></pre>
    <br/>
    <ul>
        <li>After dropping the default, you must explicitly provide a value for that column when inserting new rows.</li>
        <li>If the column also has <code>NOT NULL</code>, inserts without a value will raise an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining DEFAULT with NOT NULL</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username TEXT NOT NULL,
    active BOOLEAN NOT NULL DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>This combination ensures every user row always has a valid non-NULL value â€” either the provided one or the default <code>TRUE</code>.</li>
        <li>It's one of the most common patterns for robust schema design.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Default Values</b></li>
<pre><code class="language-sql line-numbers">SELECT
    column_name,
    column_default
FROM information_schema.columns
WHERE table_name = 'tasks';
</code></pre>
    <br/>
    <ul>
        <li>The <code>column_default</code> column displays the default expressions or constant values assigned to each field.</li>
        <li>Useful for auditing and verifying schema configurations.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="check">The CHECK Constraint in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>CHECK</code> constraint ensures that data in a column or row meets a specified logical condition before it is inserted or updated.</li>
        <br/>
        <li>It acts like a built-in validation rule inside the database, preventing invalid or inconsistent values from being stored.</li>
        <br/>
        <li>When a row violates the condition defined by a <code>CHECK</code> constraint, PostgreSQL rejects the operation and raises an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type CHECK (condition),
    ...
);
</code></pre>
    <br/>
    <ul>
        <li>You can apply <code>CHECK</code> directly to a single column or define it as a table-level constraint involving multiple columns.</li>
        <li>The condition must evaluate to <code>TRUE</code> or <code>NULL</code> (not <code>FALSE</code>), otherwise, the insert or update will fail.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple CHECK Constraint</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    salary      NUMERIC(10,2) CHECK (salary &gt;= 0)
);
</code></pre>
    <br/>
    <ul>
        <li>This constraint guarantees that <code>salary</code> values must always be greater than or equal to zero.</li>
        <li>Attempting to insert a negative salary will trigger an error.</li>
<pre><code class="language-text">ERROR:  new row for relation "employees" violates check constraint "employees_salary_check"
DETAIL: Failing row contains (-500).
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Multiple CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name       TEXT NOT NULL,
    price      NUMERIC(10,2) CHECK (price &gt;= 0),
    discount   NUMERIC(5,2) CHECK (discount BETWEEN 0 AND 100)
);
</code></pre>
    <br/>
    <ul>
        <li>Each <code>CHECK</code> is validated independently.</li>
        <li>PostgreSQL allows multiple <code>CHECK</code> constraints on the same table, each with its own rule.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Table-Level CHECK Constraint</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE accounts (
    account_id   SERIAL PRIMARY KEY,
    balance      NUMERIC(10,2),
    credit_limit NUMERIC(10,2),
    CHECK (balance &lt;= credit_limit)
);
</code></pre>
    <br/>
    <ul>
        <li>This constraint compares two columns in the same row.</li>
        <li>It ensures that the <code>balance</code> never exceeds the <code>credit_limit</code>.</li>
        <li>Unlike column-level checks, this form enforces a condition across multiple columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a CHECK Constraint to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ADD CONSTRAINT salary_positive CHECK (salary &gt;= 0);
</code></pre>
    <br/>
    <ul>
        <li>You can add new named <code>CHECK</code> constraints later with <code>ALTER TABLE</code>.</li>
        <li>PostgreSQL immediately validates all existing rows â€” if any violate the rule, the command fails.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a CHECK Constraint</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
DROP CONSTRAINT salary_positive;
</code></pre>
    <br/>
    <ul>
        <li>To remove a <code>CHECK</code> constraint, you must reference it by name.</li>
        <li>Use <code>\d table_name</code> in <code>psql</code> or query <code>pg_constraint</code> to see its name.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CHECK with Logical Operators</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    age        INT CHECK (age &gt;= 5 AND age &lt;= 100),
    grade      TEXT CHECK (grade IN ('A', 'B', 'C', 'D', 'F'))
);
</code></pre>
    <br/>
    <ul>
        <li><code>AND</code>, <code>OR</code>, and <code>IN</code> can be combined inside the condition for complex logic.</li>
        <li>This example:
            <ul>
                <li>Ensures <code>age</code> stays within a reasonable range.</li>
                <li>Limits <code>grade</code> values to a predefined set of letters.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using Functions in CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email   TEXT CHECK (POSITION('@' IN email) &gt; 1)
);
</code></pre>
    <br/>
    <ul>
        <li>You can call PostgreSQL functions or expressions within <code>CHECK</code>.</li>
        <li>Here, <code>POSITION('@' IN email)</code> ensures that the <code>email</code> column contains an "@" symbol.</li>
        <li>However, for complex validations, application-level or trigger-based logic may be preferable.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Deferrable CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE accounts
ADD CONSTRAINT balance_valid CHECK (balance &lt;= credit_limit)
DEFERRABLE INITIALLY DEFERRED;
</code></pre>
    <br/>
    <ul>
        <li>A <code>DEFERRABLE</code> constraint can be checked at the end of a transaction instead of at each statement.</li>
        <li>This is useful when temporary violations occur during intermediate steps of a multi-step update.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">SELECT
    conname AS constraint_name,
    convalidated,
    condeferrable
FROM pg_constraint
WHERE contype = 'c' AND conrelid = 'employees'::regclass;
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>pg_constraint</code> system catalog to inspect existing <code>CHECK</code> constraints.</li>
        <li><code>convalidated = true</code> indicates that all rows currently satisfy the constraint.</li>
    </ul>
    <br/>
    <br/>


    <li><b>CHECK vs. Application-Level Validation</b></li>
    <br/>
    <ul>
        <li>CHECK constraints are enforced at the database level â€” they cannot be bypassed by client errors or inconsistent application code.</li>
        <li>However:
            <ul>
                <li>They should remain simple and deterministic.</li>
                <li>Complex, cross-table validations (e.g., involving subqueries) are better handled with triggers or application logic.</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="foreign-key">Foreign Keys in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>foreign key</u> establishes a relationship between two tables by linking a column (or set of columns) in one table to the <code>PRIMARY KEY</code> or <code>UNIQUE</code> column of another table.</li>
        <br/>
        <li>It enforces <b>referential integrity</b> â€” ensuring that a value in the referencing table must always match an existing value in the referenced table (or be <code>NULL</code> if allowed).</li>
        <br/>
        <li>Foreign keys prevent "orphan" records, i.e., rows that refer to non-existent data in another table.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE child_table (
    column_name data_type REFERENCES parent_table (parent_column)
);
</code></pre>
    <br/>
    <ul>
        <li>The <code>REFERENCES</code> keyword defines the link to the target table and column.</li>
        <li>By default, PostgreSQL enforces that the referenced value must exist in the parent table before it can be inserted into the child table.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Basic Foreign Key Relationship</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name        TEXT NOT NULL
);

CREATE TABLE orders (
    order_id     SERIAL PRIMARY KEY,
    customer_id  INT REFERENCES customers(customer_id),
    order_date   DATE NOT NULL DEFAULT CURRENT_DATE
);
</code></pre>
    <br/>
    <ul>
        <li>Here:
            <ul>
                <li><code>customers</code> is the <b>parent</b> table.</li>
                <li><code>orders</code> is the <b>child</b> table â€” each order must refer to a valid customer.</li>
            </ul>
        </li>
        <li>If you try to insert an order for a non-existent customer, PostgreSQL will reject it.</li>
<pre><code class="language-text">ERROR:  insert or update on table "orders" violates foreign key constraint "orders_customer_id_fkey"
DETAIL: Key (customer_id)=(999) is not present in table "customers".
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Foreign Key Constraint Naming</b></li>
    <br/>
    <ul>
        <li>PostgreSQL automatically generates a name (e.g. <code>orders_customer_id_fkey</code>), but you can define your own for clarity:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT,
    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers (customer_id)
);
</code></pre>
        <li>Explicit naming is recommended for maintainability, especially in large schemas.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting and Deleting Data</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO customers (name) VALUES ('Alice');
INSERT INTO orders (customer_id) VALUES (1);  -- valid

INSERT INTO orders (customer_id) VALUES (999); -- invalid
</code></pre>
    <br/>
    <ul>
        <li>You can only insert a child row if the referenced parent row exists.</li>
        <li>If you delete a parent row that is still referenced by children, PostgreSQL will block the operation unless an <code>ON DELETE</code> rule is specified.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ON DELETE and ON UPDATE Actions</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides several options for handling parent changes:</li>
        <table>
            <thead>
                <tr>
                    <th>Action</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>NO ACTION</code> (default)</td>
                    <td>Rejects the change if it would break referential integrity.</td>
                    <td><code>ON DELETE NO ACTION</code></td>
                </tr>
                <tr>
                    <td><code>RESTRICT</code></td>
                    <td>Similar to <code>NO ACTION</code>, but checked immediately instead of at the end of the transaction.</td>
                    <td><code>ON DELETE RESTRICT</code></td>
                </tr>
                <tr>
                    <td><code>CASCADE</code></td>
                    <td>Deletes or updates dependent child rows automatically.</td>
                    <td><code>ON DELETE CASCADE</code></td>
                </tr>
                <tr>
                    <td><code>SET NULL</code></td>
                    <td>Sets the child's foreign key column to <code>NULL</code>.</td>
                    <td><code>ON DELETE SET NULL</code></td>
                </tr>
                <tr>
                    <td><code>SET DEFAULT</code></td>
                    <td>Sets the column to its default value (must be valid or NULL).</td>
                    <td><code>ON DELETE SET DEFAULT</code></td>
                </tr>
            </tbody>
        </table>
    </ul>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);
</code></pre>
        <li>Now if you delete a customer, all their orders are automatically deleted too.</li>
        <li>If the customer's ID changes (rare but possible), the foreign key in <code>orders</code> updates automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using SET NULL and SET DEFAULT</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
        ON DELETE SET NULL
);
</code></pre>
    <br/>
    <ul>
        <li>When the referenced customer is deleted, the foreign key in <code>orders</code> becomes <code>NULL</code>.</li>
        <li>This requires the foreign key column to allow <code>NULL</code> values, otherwise, PostgreSQL will reject the setup.</li>
    </ul>
    <br/>
    <ul>
        <li>Example with <code>SET DEFAULT</code>:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id    SERIAL PRIMARY KEY,
    customer_id INT DEFAULT 0 REFERENCES customers(customer_id) ON DELETE SET DEFAULT
);
</code></pre>
        <li>Here, when a customer is deleted, all their orders will have <code>customer_id</code> reset to <code>0</code> (a placeholder or "unassigned" value).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Composite Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE enrollments (
    student_id INT,
    course_id  INT,
    PRIMARY KEY (student_id, course_id)
);

CREATE TABLE grades (
    student_id INT,
    course_id  INT,
    grade      CHAR(2),
    FOREIGN KEY (student_id, course_id)
        REFERENCES enrollments (student_id, course_id)
        ON DELETE CASCADE
);
</code></pre>
    <br/>
    <ul>
        <li>Composite keys reference multiple columns together, maintaining multi-column relationships.</li>
        <li>The number and order of columns in the <code>FOREIGN KEY</code> must exactly match those in the referenced key.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Deferrable Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE orders
ADD CONSTRAINT fk_customer
    FOREIGN KEY (customer_id)
    REFERENCES customers (customer_id)
    DEFERRABLE INITIALLY DEFERRED;
</code></pre>
    <br/>
    <ul>
        <li>Normally, PostgreSQL checks foreign key integrity immediately when you insert or update a row.</li>
        <li>With <code>DEFERRABLE INITIALLY DEFERRED</code>, checks occur only when the transaction commits â€” allowing temporary inconsistencies within a transaction.</li>
        <li>Example use case: cyclic relationships between tables that reference each other.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Existing Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">SELECT
    conname             AS constraint_name,
    conrelid::regclass  AS table_name,
    confrelid::regclass AS referenced_table,
    confupdtype         AS on_update,
    confdeltype         AS on_delete
FROM pg_constraint
WHERE contype = 'f';
</code></pre>
    <br/>
    <ul>
        <li>The <code>pg_constraint</code> system catalog stores all foreign key definitions.</li>
        <li>The <code>confdeltype</code> and <code>confupdtype</code> columns contain codes for delete/update actions:
            <ul>
                <li><code>a</code> â€” NO ACTION</li>
                <li><code>r</code> â€” RESTRICT</li>
                <li><code>c</code> â€” CASCADE</li>
                <li><code>n</code> â€” SET NULL</li>
                <li><code>d</code> â€” SET DEFAULT</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior When Dropping Referenced Tables</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE customers;
-- ERROR:  cannot drop table customers because other objects depend on it
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL blocks the drop to preserve referential integrity.</li>
        <li>You can force the removal (and automatically drop all dependent constraints) using <code>CASCADE</code>:</li>
<pre><code class="language-sql line-numbers">DROP TABLE customers CASCADE;</code></pre>
        <li>This will also remove all foreign key constraints in child tables that reference it, but the child tables themselves remain intact.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULL and Foreign Keys</b></li>
    <br/>
    <ul>
        <li>Foreign key columns can contain <code>NULL</code> unless defined as <code>NOT NULL</code>.</li>
        <li>When <code>NULL</code> is present, PostgreSQL skips foreign key validation for that row (because "unknown" cannot be compared).</li>
        <li>This allows optional relationships â€” e.g., an <code>order</code> that may not yet be linked to a <code>customer</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>PostgreSQL automatically creates indexes on the referenced columns in the parent table (if they are primary or unique keys).</li>
        <li>However, you may also create indexes on the foreign key columns in the child table for faster joins and deletions:</li>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_orders_customer_id ON orders(customer_id);
</code></pre>
        <li>This improves query performance when filtering or joining on the foreign key.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="joins">Basics on Joining Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>JOIN</code> combines rows from two or more tables based on a related column between them.</li>
        <br/>
        <li>In PostgreSQL, joins are performed using the <code>JOIN</code> keyword together with <code>ON</code> or <code>USING</code> clauses that specify matching columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic JOIN Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT columns
FROM table1
JOIN table2
  ON table1.column_name = table2.column_name;
</code></pre>
    <br/>
    <ul>
        <li><code>JOIN</code> matches rows from both tables where the condition is true.</li>
        <li>By default, <code>JOIN</code> means <code>INNER JOIN</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example Setup</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    city TEXT
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE DEFAULT CURRENT_DATE,
    amount NUMERIC(10,2)
);

INSERT INTO customers (name, city)
VALUES ('Alice', 'Berlin'),
       ('Bob', 'Munich'),
       ('Charlie', 'Hamburg');

INSERT INTO orders (customer_id, amount)
VALUES (1, 120.00),
       (1, 90.50),
       (2, 45.00);
</code></pre>
    <br/>
    <ul>
        <li>This setup lets us explore all join types using <code>customers</code> and <code>orders</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>INNER JOIN</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
INNER JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>INNER JOIN</code> returns only rows with matching values in both tables.</li>
        <li>If a customer has no orders, that customer will not appear in the result.</li>
        <li>Result:</li>
<pre><code class="language-text"> name   | order_id | amount
--------+-----------+--------
 Alice  |     1     | 120.00
 Alice  |     2     |  90.50
 Bob    |     3     |  45.00
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>2. LEFT JOIN (or LEFT OUTER JOIN)</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
LEFT JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>LEFT JOIN</code> returns all rows from the left table (<code>customers</code>), and the matching rows from the right table (<code>orders</code>).</li>
        <li>If no match exists, PostgreSQL fills right-side columns with <code>NULL</code>.</li>
        <li>Result:</li>
<pre><code class="language-text"> name     | order_id | amount
----------+-----------+--------
 Alice    |     1     | 120.00
 Alice    |     2     |  90.50
 Bob      |     3     |  45.00
 Charlie  |   NULL    | NULL
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>RIGHT JOIN (or RIGHT OUTER JOIN)</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
RIGHT JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>RIGHT JOIN</code> returns all rows from the right table (<code>orders</code>) and matching rows from the left table (<code>customers</code>).</li>
        <li>Unmatched rows from the left table will appear as <code>NULL</code>.</li>
        <li>Typically less used than <code>LEFT JOIN</code> because you can just swap the table order.</li>
    </ul>
    <br/>
    <br/>


    <li><b>FULL JOIN (or FULL OUTER JOIN)</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
FULL JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>FULL JOIN</code> returns all rows from both tables, matching them when possible.</li>
        <li>Unmatched rows from either table get <code>NULL</code> values in the missing columns.</li>
        <li>Result example if some rows had no counterpart:</li>
<pre><code class="language-text"> name     | order_id | amount
----------+-----------+--------
 Alice    |     1     | 120.00
 Alice    |     2     |  90.50
 Bob      |     3     |  45.00
 Charlie  |   NULL    | NULL
 NULL     |     4     |  80.00   -- order without a known customer
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>CROSS JOIN</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id
FROM customers
CROSS JOIN orders;
</code></pre>
    <br/>
    <ul>
        <li><code>CROSS JOIN</code> produces the <b>Cartesian product</b> â€” every row from the first table is combined with every row from the second.</li>
        <li>Use with caution â€” the number of rows grows rapidly (e.g., 10 Ã— 10 = 100).</li>
        <li>This join type does not require an <code>ON</code> condition.</li>
    </ul>
    <br/>
    <br/>


    <li><b>SELF JOIN</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name TEXT,
    manager_id INT REFERENCES employees(employee_id)
);

SELECT e.name AS employee,
       m.name AS manager
FROM employees e
LEFT JOIN employees m
  ON e.manager_id = m.employee_id;
</code></pre>
    <br/>
    <ul>
        <li>A <b>self join</b> joins a table to itself â€” useful for hierarchical or tree-like data such as employees and managers.</li>
        <li>Aliases (<code>e</code>, <code>m</code>) are necessary to distinguish between the two instances of the same table.</li>
    </ul>
    <br/>
    <br/>


    <li><b>USING Clause</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM customers
JOIN orders USING (customer_id);
</code></pre>
    <br/>
    <ul>
        <li>The <code>USING (column_name)</code> syntax is a shortcut when both tables share a column with the same name.</li>
        <li>It automatically merges the duplicate join column in the output, so you'll see only one <code>customer_id</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>8. Joining More Than Two Tables</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    product_name TEXT,
    quantity INT
);

SELECT
    c.name AS customer,
    o.order_id,
    i.product_name,
    i.quantity
FROM customers c
JOIN orders o
  ON c.customer_id = o.customer_id
JOIN order_items i
  ON o.order_id = i.order_id;
</code></pre>
    <br/>
    <ul>
        <li>You can chain multiple <code>JOIN</code> clauses in one query.</li>
        <li>Each <code>JOIN</code> connects one more table through a matching condition.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering After Joins</b></li>
<pre><code class="language-sql line-numbers">SELECT
    c.name, o.amount
FROM customers c
JOIN orders o
  ON c.customer_id = o.customer_id
WHERE o.amount &gt; 50;
</code></pre>
    <br/>
    <ul>
        <li>You can use <code>WHERE</code>, <code>ORDER BY</code>, <code>LIMIT</code>, and other clauses after joining.</li>
        <li>PostgreSQL first performs the join, then filters the results according to your conditions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NATURAL JOIN</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM customers
NATURAL JOIN orders;
</code></pre>
    <br/>
    <ul>
        <li><code>NATURAL JOIN</code> automatically joins tables using all columns with the same names.</li>
        <li>While convenient, it can be dangerous â€” if new columns with the same name are added later, join behavior may change unexpectedly.</li>
        <li>Use <code>JOIN ... USING (...)</code> instead for clarity and control.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>Joins can be computationally expensive for large tables.</li>
        <li>To optimize performance:
            <ul>
                <li>Ensure both sides of join conditions are indexed (especially foreign key columns).</li>
                <li>Use <code>EXPLAIN</code> to analyze query plans and check for sequential scans.</li>
                <li>Limit unnecessary joins â€” fetch only required columns.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">EXPLAIN SELECT * FROM customers JOIN orders ON customers.customer_id = orders.customer_id;</code></pre>
    <br/>
    <ul>
        <li>This shows how PostgreSQL executes the join internally (e.g., nested loop, hash join, merge join).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="set-ops">Set Operations in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Set operations</u> in PostgreSQL allow you to combine the results of two or more <code>SELECT</code> queries into a single result set.</li>
        <br/>
        <li>They work on complete rows (as sets), not on individual columns.</li>
        <br/>
        <li>Common operations include:
            <ul>
                <li><code>UNION</code> â€“ combine and remove duplicates.</li>
                <li><code>UNION ALL</code> â€“ combine and keep duplicates.</li>
                <li><code>INTERSECT</code> â€“ return only rows common to both queries.</li>
                <li><code>EXCEPT</code> â€“ return rows from the first query that are not in the second.</li>
            </ul>
        </li>
        <br/>
        <li>Each query in a set operation MUST:
            <ul>
                <li>Select the <u>same number of columns</u>.</li>
                <li>Have <u>compatible data types</u> for corresponding columns.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Example Setup</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE students_2024 (
    name TEXT,
    city TEXT
);

CREATE TABLE students_2025 (
    name TEXT,
    city TEXT
);

INSERT INTO students_2024 VALUES
    ('Alice', 'Berlin'),
    ('Bob', 'Munich'),
    ('Charlie', 'Hamburg');

INSERT INTO students_2025 VALUES
    ('Alice', 'Berlin'),
    ('David', 'Stuttgart'),
    ('Ella', 'Munich');
</code></pre>
    <br/>
    <ul>
        <li>We now have two tables with overlapping and distinct rows.</li>
    </ul>
    <br/>
    <br/>


    <li><b>1. UNION â€” Combine and Remove Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
UNION
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION</code> merges the two result sets and automatically removes duplicates.</li>
        <li>The combined result is sorted and distinct by default.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Alice      | Berlin
 Bob        | Munich
 Charlie    | Hamburg
 David      | Stuttgart
 Ella       | Munich
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>2. UNION ALL â€” Combine and Keep Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
UNION ALL
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION ALL</code> keeps duplicate rows, without sorting or removing them.</li>
        <li>It is faster than <code>UNION</code> because PostgreSQL skips duplicate checking.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Alice      | Berlin
 Bob        | Munich
 Charlie    | Hamburg
 Alice      | Berlin
 David      | Stuttgart
 Ella       | Munich
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>3. INTERSECT â€” Common Rows Only</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
INTERSECT
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>INTERSECT</code> returns only the rows that appear in <b>both</b> queries.</li>
        <li>Duplicates are automatically removed.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Alice      | Berlin
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>4. INTERSECT ALL â€” Common Rows, Keep Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
INTERSECT ALL
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>INTERSECT ALL</code> keeps duplicates as they appear in both results.</li>
        <li>If a row appears twice in both tables, it appears twice in the output.</li>
        <li>Since our data has only one matching row, the result is identical to <code>INTERSECT</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>5. EXCEPT â€” Rows in First Query but Not in Second</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
EXCEPT
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>EXCEPT</code> returns all rows from the first query that do not appear in the second.</li>
        <li>Duplicates are removed automatically.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Bob        | Munich
 Charlie    | Hamburg
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>6. EXCEPT ALL â€” Keep Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
EXCEPT ALL
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>EXCEPT ALL</code> behaves like <code>EXCEPT</code>, but keeps duplicates according to their frequency in the first query minus the second.</li>
        <li>Example: if a row appears 3 times in the first query and once in the second, it appears twice in the result.</li>
    </ul>
    <br/>
    <br/>


    <li><b>7. Matching Columns and Types</b></li>
<pre><code class="language-sql line-numbers">-- This will fail:
SELECT name FROM students_2024
UNION
SELECT name, city FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li>All participating queries in a set operation must have:
            <ul>
                <li>The <b>same number of columns</b>.</li>
                <li><b>Compatible data types</b> in corresponding positions.</li>
            </ul>
        </li>
        <li>Otherwise PostgreSQL will raise an error:</li>
<pre><code class="language-text">ERROR:  each UNION query must have the same number of columns
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>8. Sorting Combined Results</b></li>
<pre><code class="language-sql line-numbers">SELECT name, city FROM students_2024
UNION
SELECT name, city FROM students_2025
ORDER BY name;
</code></pre>
    <br/>
    <ul>
        <li>Use <code>ORDER BY</code> only <b>after the final set operation</b> â€” not inside each <code>SELECT</code>.</li>
        <li>PostgreSQL treats the combined output as one large table that can be sorted or filtered further.</li>
    </ul>
    <br/>
    <br/>


    <li><b>9. Using Parentheses for Complex Set Operations</b></li>
<pre><code class="language-sql line-numbers">(SELECT * FROM students_2024
 UNION
 SELECT * FROM students_2025)
EXCEPT
SELECT * FROM expelled_students;
</code></pre>
    <br/>
    <ul>
        <li>Parentheses control the evaluation order when mixing multiple set operators.</li>
        <li>Without parentheses, PostgreSQL evaluates from left to right.</li>
        <li>Use parentheses to make complex logic clear and unambiguous.</li>
    </ul>
    <br/>
    <br/>


    <li><b>10. Combining with WHERE or JOIN Clauses</b></li>
<pre><code class="language-sql line-numbers">SELECT name, city FROM students_2024 WHERE city = 'Munich'
UNION
SELECT name, city FROM students_2025 WHERE city = 'Munich';
</code></pre>
    <br/>
    <ul>
        <li>Each <code>SELECT</code> can include its own <code>WHERE</code>, <code>JOIN</code>, or <code>GROUP BY</code> clause before the set operation.</li>
        <li>This allows you to filter and process each dataset independently before combining them.</li>
    </ul>
    <br/>
    <br/>


    <li><b>11. Performance Considerations</b></li>
    <br/>
    <ul>
        <li><code>UNION</code> and <code>INTERSECT</code> remove duplicates â€” they require sorting or hashing internally, which can be expensive on large data sets.</li>
        <li><code>UNION ALL</code> and <code>EXCEPT ALL</code> skip this step and are generally faster.</li>
        <li>When possible, use <code>UNION ALL</code> if you are sure duplicates are not an issue.</li>
    </ul>
<pre><code class="language-sql line-numbers">EXPLAIN SELECT * FROM students_2024 UNION SELECT * FROM students_2025;</code></pre>
    <br/>
    <ul>
        <li><code>EXPLAIN</code> helps visualize how PostgreSQL performs the merge internally.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="boolean">The BOOLEAN Type in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>BOOLEAN</code> type in PostgreSQL represents truth values â€” logical <b>true</b> or <b>false</b> conditions.</li>
        <br/>
        <li>It is often used in columns that represent yes/no, on/off, or active/inactive states.</li>
        <br/>
        <li>Unlike databases that simulate booleans with integers (e.g. 0/1), PostgreSQL has a <b>native</b> boolean type with its own rules and accepted literals.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Declaration Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    name    TEXT NOT NULL,
    active  BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li><code>BOOLEAN</code> columns can take values <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accepted Literal Values</b></li>
    <br/>
    <ul>
        <li>PostgreSQL accepts a variety of textual and numeric representations for boolean values:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Meaning</th>
                    <th>Accepted Values</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><b>TRUE</b></td>
                    <td><code>TRUE</code>, <code>'t'</code>, <code>'true'</code>, <code>'y'</code>, <code>'yes'</code>, <code>'on'</code>, <code>'1'</code></td>
                </tr>
                <tr>
                    <td><b>FALSE</b></td>
                    <td><code>FALSE</code>, <code>'f'</code>, <code>'false'</code>, <code>'n'</code>, <code>'no'</code>, <code>'off'</code>, <code>'0'</code></td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>The matching is <u>case-insensitive</u>, so <code>'True'</code>, <code>'YES'</code>, and <code>'On'</code> all work the same.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Examples of Insertion</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO users (name, active)
VALUES
    ('Alice', TRUE),
    ('Bob', 'yes'),
    ('Charlie', 'f'),
    ('Diana', 0);

SELECT * FROM users;
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL automatically interprets <code>'yes'</code>, <code>'f'</code>, and <code>0</code> according to the truth table above.</li>
        <li>Result:</li>
<pre><code class="language-text"> user_id |  name    | active
----------+----------+---------
 1        | Alice    | t
 2        | Bob      | t
 3        | Charlie  | f
 4        | Diana    | f
</code></pre>
        <li><code>t</code> and <code>f</code> are how PostgreSQL displays boolean values by default.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean Display Formats</b></li>
    <br/>
    <ul>
        <li>Although PostgreSQL stores booleans internally as true/false, by default it displays them as <code>t</code> and <code>f</code>.</li>
        <li>This is a historical choice compatible with early UNIX and SQL standards.</li>
        <li>You can cast or format them differently if needed:</li>
<pre><code class="language-sql line-numbers">SELECT active::text FROM users;
-- Outputs: 't', 'f'

SELECT
    CASE
        WHEN active THEN 'Active'
        ELSE 'Inactive'
    END
FROM users;
-- Custom labels for boolean output
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Using Booleans in Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM users WHERE active = TRUE;

-- Shorter equivalent:
SELECT * FROM users WHERE active;

-- Opposite:
SELECT * FROM users WHERE NOT active;
</code></pre>
    <br/>
    <ul>
        <li>You can write conditions with or without explicitly comparing to <code>TRUE</code> or <code>FALSE</code>.</li>
        <li>The expression <code>WHERE active</code> is shorthand for <code>WHERE active = TRUE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULL with Boolean Columns</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO users (name, active) VALUES ('Eve', NULL);

SELECT name,
       CASE
         WHEN active THEN 'True'
         WHEN NOT active THEN 'False'
         ELSE 'Unknown'
       END AS status
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>Boolean columns can be <code>NULL</code>, representing "unknown" or "not specified."</li>
        <li>This is different from <code>FALSE</code> â€” PostgreSQL treats <code>NULL</code> as neither true nor false.</li>
        <li>The <code>CASE</code> statement (or <code>COALESCE</code>) can be used to handle <code>NULL</code> explicitly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean Operators</b></li>
    <br/>
    <ul>
        <li>PostgreSQL supports standard logical operators on boolean expressions:</li>
        <table>
            <thead>
                <tr>
                    <th>Operator</th>
                    <th>Description</th>
                    <th>Example</th>
                    <th>Result</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>AND</code></td>
                    <td>True if both operands are true</td>
                    <td><code>TRUE AND FALSE</code></td>
                    <td>FALSE</td>
                </tr>
                <tr>
                    <td><code>OR</code></td>
                    <td>True if at least one operand is true</td>
                    <td><code>TRUE OR FALSE</code></td>
                    <td>TRUE</td>
                </tr>
                <tr>
                    <td><code>NOT</code></td>
                    <td>Negates the boolean value</td>
                    <td><code>NOT TRUE</code></td>
                    <td>FALSE</td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>Example usage inside a query:</li>
<pre><code class="language-sql line-numbers">SELECT * FROM users
WHERE active OR name = 'Alice';
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean Expressions in SELECT</b></li>
<pre><code class="language-sql line-numbers">SELECT name,
       (active AND city = 'Berlin') AS active_in_berlin
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>Boolean expressions can appear directly in the <code>SELECT</code> list â€” returning <code>t</code>, <code>f</code>, or <code>NULL</code> per row.</li>
        <li>This is useful for logical flags or derived states.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Indexing Boolean Columns</b></li>
    <br/>
    <ul>
        <li>Boolean columns typically have low selectivity (few distinct values), so simple indexes are often not useful.</li>
        <li>However, you can create <u>partial indexes</u> to speed up queries on a specific boolean value:</li>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_active_true
ON users (user_id)
WHERE active = TRUE;
</code></pre>
        <li>This makes <code>WHERE active = TRUE</code> queries faster without indexing inactive users.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Converting Between Boolean and Other Types</b></li>
<pre><code class="language-sql line-numbers">SELECT CAST(TRUE AS INT);   -- returns 1
SELECT CAST(FALSE AS INT);  -- returns 0

SELECT CAST(1 AS BOOLEAN);  -- returns TRUE
SELECT CAST(0 AS BOOLEAN);  -- returns FALSE
</code></pre>
    <br/>
    <ul>
        <li>You can cast between <code>BOOLEAN</code> and <code>INTEGER</code> types if needed.</li>
        <li>PostgreSQL follows standard semantics: <code>TRUE â†’ 1</code>, <code>FALSE â†’ 0</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="text-types">Character Types: CHAR, VARCHAR, and TEXT in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides several types for storing textual data: <code>CHAR</code>, <code>VARCHAR</code>, and <code>TEXT</code>.</li>
        <br/>
        <li>Although they appear similar, they differ in how they handle length, padding, and validation.</li>
        <br/>
        <li>All three are stored efficiently as variable-length strings internally, but their behavior and use cases differ slightly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>CHAR(n) â€” Fixed-Length Character Type</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products_char (
    code CHAR(5),
    name TEXT
);

INSERT INTO products_char VALUES ('AB', 'Widget');
SELECT code, LENGTH(code) FROM products_char;
</code></pre>
    <br/>
    <ul>
        <li><code>CHAR(n)</code> (or <code>CHARACTER(n)</code>) stores <b>exactly <code>n</code> characters</b>.</li>
        <li>If you insert a shorter string, PostgreSQL <b>pads it with spaces</b> to the fixed length.</li>
        <li>If you insert a longer string, it is <b>truncated</b>.</li>
        <li>Result:</li>
<pre><code class="language-text"> code  | length
-------+--------
 AB    | 5
</code></pre>
        <li>Notice how <code>'AB'</code> was stored as <code>'AB   '</code> (with padding).</li>
        <li>Useful when strings must have uniform length (e.g., fixed codes, legacy systems).</li>
    </ul>
    <br/>
    <br/>


    <li><b>VARCHAR(n) â€” Variable-Length with Limit</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products_varchar (
    code VARCHAR(5),
    name TEXT
);

INSERT INTO products_varchar VALUES ('AB', 'Widget');
INSERT INTO products_varchar VALUES ('ABCDE', 'Gadget');
</code></pre>
    <br/>
    <ul>
        <li><code>VARCHAR(n)</code> (or <code>CHARACTER VARYING(n)</code>) stores a string <b>upto <code>n</code> characters</b> long.</li>
        <li>It <b>does not pad</b> shorter strings with spaces.</li>
        <li>If the input exceeds <code>n</code>, PostgreSQL raises an error:</li>
<pre><code class="language-text">ERROR:  value too long for type character varying(5)
</code></pre>
        <li>This type is ideal when you need a length restriction (e.g., usernames â‰¤ 50 characters).</li>
    </ul>
    <br/>
    <br/>


    <li><b>TEXT â€” Unlimited-Length Variable Text</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT,
    content TEXT
);

INSERT INTO articles (title, content)
VALUES ('Intro to PostgreSQL', 'PostgreSQL is a powerful open-source RDBMS...');
</code></pre>
    <br/>
    <ul>
        <li><code>TEXT</code> stores strings of <b>any length</b> (up to about 1 GB per field).</li>
        <li>It does not require you to specify a limit and does not pad or truncate values.</li>
        <li>Functionally equivalent to <code>VARCHAR</code> without a length limit â€” same performance, same behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Between CHAR, VARCHAR, and TEXT</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Behavior</th>
                <th>Length Limit</th>
                <th>Padded?</th>
                <th>Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>CHAR(n)</code></td>
                <td>Fixed-length</td>
                <td>Yes</td>
                <td>Yes (spaces)</td>
                <td>Fixed-size codes, legacy data</td>
            </tr>
            <tr>
                <td><code>VARCHAR(n)</code></td>
                <td>Variable-length, validated</td>
                <td>Yes</td>
                <td>No</td>
                <td>Text with known maximum length (e.g., names)</td>
            </tr>
            <tr>
                <td><code>TEXT</code></td>
                <td>Variable-length, unlimited</td>
                <td>No</td>
                <td>No</td>
                <td>General-purpose text, documents, comments</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>CHAR vs VARCHAR vs TEXT in Practice</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE demo (
    c1 CHAR(5),
    c2 VARCHAR(5),
    c3 TEXT
);

INSERT INTO demo VALUES ('AB', 'AB', 'AB');
SELECT c1, c2, c3, LENGTH(c1), LENGTH(c2), LENGTH(c3) FROM demo;
</code></pre>
    <br/>
    <ul>
        <li>Result:</li>
<pre><code class="language-text"> c1     | c2 | c3 | length
---------+----+----+--------
 AB     | AB | AB | 5  2  2
</code></pre>
        <li><code>CHAR(5)</code> pads to 5 characters, while <code>VARCHAR</code> and <code>TEXT</code> store only what you insert.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance and Storage</b></li>
    <br/>
    <ul>
        <li>Internally, PostgreSQL stores <code>CHAR</code>, <code>VARCHAR</code>, and <code>TEXT</code> using the same variable-length storage format (<code>varlena</code>).</li>
        <br/>
        <li>There is <b>no performance difference</b> between <code>TEXT</code> and <code>VARCHAR(n)</code> for most workloads.</li>
        <br/>
        <li>The only difference lies in input validation and space padding behavior â€” not storage or speed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Trimming and Padding</b></li>
<pre><code class="language-sql line-numbers">SELECT 'abc'::CHAR(5) = 'abc'::CHAR(5);  -- TRUE
SELECT 'abc'::CHAR(5) = 'abc';           -- TRUE (ignores padding)
SELECT LENGTH('abc'::CHAR(5));           -- 5
</code></pre>
    <br/>
    <ul>
        <li>When comparing <code>CHAR(n)</code> values, PostgreSQL ignores trailing spaces.</li>
        <li>This means <code>'AB   '</code> and <code>'AB'</code> compare as equal.</li>
        <li>However, when concatenating or measuring string length, padding spaces remain visible.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Changing Length or Type</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE products_varchar
ALTER COLUMN code TYPE VARCHAR(10);

ALTER TABLE products_char
ALTER COLUMN code TYPE TEXT;
</code></pre>
    <br/>
    <ul>
        <li>You can safely change between these text types if data fits within the new limits.</li>
        <li>When increasing the <code>VARCHAR</code> length, PostgreSQL validates existing data automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Compatibility</b></li>
<pre><code class="language-sql line-numbers">SELECT UPPER(code), LOWER(name)
FROM products_varchar;

SELECT LENGTH(content), LEFT(content, 20)
FROM articles;
</code></pre>
    <br/>
    <ul>
        <li>All three types (<code>CHAR</code>, <code>VARCHAR</code>, <code>TEXT</code>) are fully compatible with PostgreSQL string functions and operators.</li>
        <li>You can use <code>UPPER()</code>, <code>LOWER()</code>, <code>CONCAT()</code>, <code>LENGTH()</code>, <code>TRIM()</code>, etc., interchangeably.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Recommended Usage</b></li>
    <br/>
    <ul>
        <li>PostgreSQL documentation itself recommends using <code>TEXT</code> for most textual data.</li>
        <li><b>Guidelines:</b>
            <ul>
                <li>Use <code>TEXT</code> when you don't need a maximum length restriction.</li>
                <li>Use <code>VARCHAR(n)</code> if you want to enforce a limit (e.g., 50 characters for a username).</li>
                <li>Use <code>CHAR(n)</code> only when you must store fixed-length data (e.g., ISO codes, status flags).</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="integer">Integer Types in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides several <b>integer data types</b> to represent whole numbers with different storage sizes and numeric ranges.</li>
        <br/>
        <li>All integer types are <b>signed</b> (they support both positive and negative values) and stored efficiently in binary form.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Available Integer Types</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Alias</th>
                <th>Storage Size</th>
                <th>Range</th>
                <th>Typical Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>SMALLINT</code></td>
                <td><code>INT2</code></td>
                <td>2 bytes</td>
                <td>-32,768 to 32,767</td>
                <td>Very small numbers, compact storage</td>
            </tr>
            <tr>
                <td><code>INTEGER</code></td>
                <td><code>INT</code> or <code>INT4</code></td>
                <td>4 bytes</td>
                <td>-2,147,483,648 to 2,147,483,647</td>
                <td>General-purpose integer type (most common)</td>
            </tr>
            <tr>
                <td><code>BIGINT</code></td>
                <td><code>INT8</code></td>
                <td>8 bytes</td>
                <td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
                <td>Very large values (IDs, counts, etc.)</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>All these types behave identically except for their size and range.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Usage</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE inventory (
    item_id     INT PRIMARY KEY,
    quantity    SMALLINT,
    reorder_min INT,
    reorder_max BIGINT
);

INSERT INTO inventory VALUES (1, 25, 10, 5000000000);
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL will automatically select appropriate storage and enforce the numeric range for each column.</li>
        <li>If you try to insert a value beyond the range, it raises an error:</li>
<pre><code class="language-text">ERROR: integer out of range
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Integer Aliases and Compatibility</b></li>
    <br/>
    <ul>
        <li><code>INT</code> and <code>INTEGER</code> are exact synonyms.</li>
        <li><code>INT2</code>, <code>INT4</code>, and <code>INT8</code> are internal aliases for <code>SMALLINT</code>, <code>INTEGER</code>, and <code>BIGINT</code>.</li>
        <li>You can use any version interchangeably â€” all mean the same data type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Auto-Incrementing Integers</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    name    TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li>Internally, PostgreSQL expands this into:
<pre><code class="language-sql line-numbers">user_id INTEGER NOT NULL DEFAULT nextval('users_user_id_seq'::regclass);
</code></pre>
        <li>In modern PostgreSQL, the preferred syntax is the <b>identity column</b>:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT
);
</code></pre>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is SQL-standard and avoids manually managing sequences.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Working with Sequences</b></li>
<pre><code class="language-sql line-numbers">-- Create a table with SERIAL
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    amount   NUMERIC(10,2)
);

-- Check the associated sequence
\d orders
-- Shows: "order_id" integer DEFAULT nextval('orders_order_id_seq'::regclass)

-- Get the next value manually:
SELECT nextval('orders_order_id_seq');
</code></pre>
    <br/>
    <ul>
        <li>Each <code>SERIAL</code> or <code>IDENTITY</code> column uses a dedicated <b>sequence</b> object for generating new values.</li>
        <li>You can control sequences directly using functions like <code>nextval()</code>, <code>currval()</code>, and <code>setval()</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Arithmetic and Overflow</b></li>
<pre><code class="language-sql line-numbers">SELECT 2147483647 + 1;        -- overflow for INTEGER
SELECT 9223372036854775807 + 1;  -- overflow for BIGINT
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL detects overflows and raises an error â€” it does not wrap around silently.</li>
        <li>To handle large numeric computations safely, use <code>NUMERIC</code> (arbitrary precision).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Casting</b></li>
<pre><code class="language-sql line-numbers">SELECT '42'::INT;      -- 42
SELECT 3.7::INT;       -- 4 truncated to 3
SELECT 3.7::BIGINT;    -- also truncates fractional part
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL automatically casts compatible numeric and string literals to integer types when possible.</li>
        <li>Fractions are <b>truncated</b> (not rounded).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison and Sorting</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM inventory ORDER BY quantity DESC;
</code></pre>
    <br/>
    <ul>
        <li>Integers can be sorted and compared normally with <code>&gt;</code>, <code>&lt;</code>, <code>=</code>, etc.</li>
        <li>Indexes on integer columns are highly efficient, making them ideal for primary keys and lookup columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Converting Between Integer Types</b></li>
<pre><code class="language-sql line-numbers">SELECT 500::SMALLINT;   -- OK
SELECT 40000::SMALLINT; -- ERROR: smallint out of range
</code></pre>
    <br/>
    <ul>
        <li>Conversions between integer types work as long as the value fits in the target range.</li>
        <li>If it doesn't, PostgreSQL throws an overflow error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Tips</b></li>
    <br/>
    <ul>
        <li>Use <code>SMALLINT</code> only when saving space truly matters, otherwise <code>INTEGER</code> is more convenient.</li>
        <li><code>BIGINT</code> should be used for IDs or counters that may exceed 2 billion (e.g., event logs, user IDs in large systems).</li>
        <li>All integer types are fast to compare, sort, and index, since they are stored as fixed-size binary numbers.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="decimal">The DECIMAL Type in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>DECIMAL</code> (or its synonym <code>NUMERIC</code>) is a <u>fixed-point, exact numeric</u> data type in PostgreSQL.</li>
        <br/>
        <li>It stores numbers with user-defined precision and scale, ensuring <u>no rounding errors</u> in arithmetic operations.</li>
        <br/>
        <li>This makes it ideal for use in <b>financial, accounting, and scientific</b> calculations where accuracy matters more than speed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Declaration Syntax</b></li>
<pre><code class="language-sql line-numbers">NUMERIC(precision, scale)
-- or
DECIMAL(precision, scale)
</code></pre>
    <br/>
    <ul>
        <li><code>precision</code>: total number of significant digits (before + after decimal point).</li>
        <li><code>scale</code>: number of digits allowed <code>after</code> the decimal point.</li>
        <li>For example: <code>NUMERIC(8, 2)</code> means:
            <ul>
                <li>Up to 8 digits total.</li>
                <li>2 digits after the decimal (so max 999999.99).</li>
            </ul>
        </li>
        <li>If you omit <code>(p, s)</code>, PostgreSQL allows arbitrary precision â€” only limited by memory.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Defining DECIMAL Columns</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE transactions (
    id       GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    amount   DECIMAL(10, 2),
    tax_rate NUMERIC(5, 3),
    total    NUMERIC(12, 4)
);

INSERT INTO transactions (amount, tax_rate, total)
VALUES (1234.56, 0.075, 1326.9300);
</code></pre>
    <br/>
    <ul>
        <li><code>DECIMAL(10, 2)</code> â€” up to 10 digits total, with 2 after the decimal (e.g., 99999999.99).</li>
        <li><code>NUMERIC(5, 3)</code> &nbsp; â€” up to 5 digits total, 3 of them after the decimal (e.g., 12.345).</li>
        <li><code>NUMERIC(12, 4)</code> â€” higher precision for cumulative totals.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Precision and Rounding</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE test_round (
    value NUMERIC(6, 2)
);

INSERT INTO test_round VALUES (123.456);  -- Automatically rounded
SELECT * FROM test_round;
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL rounds values to the defined scale when inserting or updating.</li>
        <li>Result:</li>
<pre><code class="language-text"> value
--------
 123.46
</code></pre>
        <li>If a number exceeds the allowed <b>precision</b>, PostgreSQL raises an error instead of truncating silently.</li>
<pre><code class="language-text">ERROR:  numeric field overflow
DETAIL: A field with precision 6, scale 2 must round to an absolute value less than 10^4.
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison with Floating-Point Types</b></li>
<pre><code class="language-sql line-numbers">SELECT
    0.1 + 0.2                                   AS float_sum,
    CAST(0.1 AS NUMERIC) + CAST(0.2 AS NUMERIC) AS numeric_sum;
</code></pre>
    <br/>
    <ul>
        <li><b>Floating-point (REAL/DOUBLE)</b> types use binary fractions and may produce tiny rounding errors:</li>
<pre><code class="language-text"> float_sum   | numeric_sum
-------------+--------------
 0.300000000 | 0.3
</code></pre>
        <li><code>NUMERIC</code> / <code>DECIMAL</code> performs exact arithmetic and never introduces such artifacts.</li>
        <li>Therefore, prefer <code>DECIMAL</code> for money, interest rates, or measurements requiring exactness.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Default Precision and Scale</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE flexible_numbers (
    value NUMERIC
);

INSERT INTO flexible_numbers VALUES (12345678901234567890.123456789);
SELECT value FROM flexible_numbers;
</code></pre>
    <br/>
    <ul>
        <li>If no precision and scale are specified, <code>NUMERIC</code> stores numbers with arbitrary length and precision.</li>
        <li>This allows very large or very precise numbers, but may be slightly slower to process.</li>
        <li>Output example:</li>
<pre><code class="language-text"> value
---------------------
 12345678901234567890.123456789
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Arithmetic Operations</b></li>
<pre><code class="language-sql line-numbers">SELECT
    amount,
    tax_rate,
    amount * tax_rate AS tax,
    amount + (amount * tax_rate) AS total
FROM transactions;
</code></pre>
    <br/>
    <ul>
        <li><code>NUMERIC</code> values support all arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>.</li>
        <li>PostgreSQL maintains full precision in intermediate steps and rounds only at output or storage.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Rounding Functions</b></li>
<pre><code class="language-sql line-numbers">SELECT ROUND(12.3456, 2),  -- 12.35
       TRUNC(12.3456, 2);  -- 12.34
</code></pre>
    <br/>
    <ul>
        <li><code>ROUND()</code> â€” rounds to the nearest value using standard half-up rounding.</li>
        <li><code>TRUNC()</code> â€” simply cuts off extra digits (no rounding).</li>
        <li>Both functions work natively with <code>NUMERIC</code> values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting and Casting</b></li>
<pre><code class="language-sql line-numbers">SELECT TO_CHAR(1234.5::NUMERIC(10,2), '9999.99');  -- '1234.50'
SELECT TO_CHAR(9876.5432, '9,999.00');             -- '9,876.54'
</code></pre>
    <br/>
    <ul>
        <li><code>TO_CHAR()</code> converts <code>NUMERIC</code> values into formatted text with grouping, padding, or currency symbols.</li>
        <li>You can also cast <code>NUMERIC</code> to <code>INTEGER</code> or <code>DOUBLE PRECISION</code> as needed.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT CAST(12.34 AS INT);              -- 12
SELECT CAST(12.34 AS DOUBLE PRECISION); -- 12.34
</code></pre>
    <br/>
    <br/>


    <li><b>Storage and Performance</b></li>
    <br/>
    <ul>
        <li><code>NUMERIC</code> values are stored in a <b>variable-length</b> binary format, optimized for precision rather than speed.</li>
        <li>For small integers or approximate values, <code>INTEGER</code> or <code>DOUBLE PRECISION</code> are faster.</li>
        <li>However, <code>NUMERIC</code> ensures exactness even for very large or fractional numbers.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Practical Use Cases</b></li>
    <br/>
    <ul>
        <li><b>Finance:</b> storing currency, exchange rates, and interest calculations (<code>NUMERIC(12,2)</code>).</li>
        <li><b>Scientific data:</b> precise measurements with fixed decimals (<code>NUMERIC(8,4)</code>).</li>
        <li><b>Accounting:</b> totals, taxes, and percentages where rounding errors are unacceptable.</li>
    </ul>
    <br/>
</ol>
<br/>

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="date-time">Date and Time Types in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL supports a full suite of <u>temporal data types</u> for working with dates, times, and timestamps.</li>
        <br/>
        <li>They follow the SQL standard closely and provide both <u>timezone-aware</u> and <u>timezone-independent</u> options.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Available Date and Time Types</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>DATE</code></td>
                <td>Stores calendar dates (year, month, day)</td>
                <td><code>'2025-11-11'</code></td>
            </tr>
            <tr>
                <td><code>TIME [ (p) ]</code></td>
                <td>Stores time of day (no date, no timezone)</td>
                <td><code>'13:45:20'</code></td>
            </tr>
            <tr>
                <td><code>TIME [ (p) ] WITH TIME ZONE</code></td>
                <td>Stores time of day including timezone offset</td>
                <td><code>'13:45:20+01'</code></td>
            </tr>
            <tr>
                <td><code>TIMESTAMP [ (p) ]</code></td>
                <td>Stores date and time (no timezone)</td>
                <td><code>'2025-11-11 13:45:20'</code></td>
            </tr>
            <tr>
                <td><code>TIMESTAMP [ (p) ] WITH TIME ZONE</code></td>
                <td>Stores date and time with timezone awareness</td>
                <td><code>'2025-11-11 13:45:20+01'</code></td>
            </tr>
            <tr>
                <td><code>INTERVAL [ fields ] [ (p) ]</code></td>
                <td>Represents duration or difference between timestamps</td>
                <td><code>'3 days 04:05:06'</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li><code>(p)</code> specifies optional fractional seconds precision (0 â€“ 6 digits).</li>
        <li><code>TIMESTAMP WITH TIME ZONE</code> can also be written as <code>TIMESTAMPTZ</code> (shorthand alias).</li>
    </ul>
    <br/>
    <br/>


    <li><b>DATE Type</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE events (
    id          GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    title       TEXT,
    event_date  DATE
);

INSERT INTO events (title, event_date)
VALUES
    ('Conference', '2025-12-01'),
    ('Workshop', CURRENT_DATE);
</code></pre>
    <br/>
    <ul>
        <li><code>DATE</code> stores only the year, month, and day.</li>
        <li><code>CURRENT_DATE</code> returns the system's current date.</li>
        <li>Arithmetic is supported:</li>
<pre><code class="language-sql line-numbers">SELECT
    event_date + INTERVAL '7 days' AS next_week
FROM events;
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>TIME Type</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE shifts (
    employee    TEXT,
    start_time  TIME,
    end_time    TIME
);

INSERT INTO shifts
VALUES
    ('Alice', '09:00', '17:30'),
    ('Bob',   '22:00', '06:00');
</code></pre>
    <br/>
    <ul>
        <li><code>TIME</code> stores the hour, minute, and second (optionally with microseconds).</li>
        <li>It is independent of any date or timezone.</li>
        <li>You can compute time differences as intervals:</li>
<pre><code class="language-sql line-numbers">SELECT
    end_time - start_time AS duration
FROM shifts;</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>TIME WITH TIME ZONE (TIMETZ)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE broadcasts (
    show_name TEXT,
    air_time  TIME WITH TIME ZONE
);

INSERT INTO broadcasts
VALUES
    ('Morning News', '07:00+01'),
    ('Night Talk', '23:00-05');
</code></pre>
    <br/>
    <ul>
        <li><code>TIME WITH TIME ZONE</code> (or <code>TIMETZ</code>) stores a local time and its associated timezone offset.</li>
        <li>Rarely used in modern applications, since most real-world scheduling uses full timestamps instead.</li>
    </ul>
    <br/>
    <br/>


    <li><b>TIMESTAMP (Without Time Zone)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE logs (
    log_id      GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    message     TEXT,
    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO logs (message) VALUES ('System started');
</code></pre>
    <br/>
    <ul>
        <li><code>TIMESTAMP</code> records both date and time but has <u>no timezone awareness</u>.</li>
        <li><code>CURRENT_TIMESTAMP</code> returns the local date and time when the row is inserted.</li>
        <li>Useful when you want consistent "local" timestamps (e.g., system logs).</li>
    </ul>
    <br/>
    <br/>


    <li><b>TIMESTAMP WITH TIME ZONE (TIMESTAMPTZ)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE meetings (
    meeting_id  GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    title       TEXT,
    start_at    TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO meetings (title, start_at) VALUES ('Team Sync', '2025-11-11 09:00:00+01');
</code></pre>
    <br/>
    <ul>
        <li><code>TIMESTAMPTZ</code> automatically normalizes values to UTC internally.</li>
        <li>When displayed, PostgreSQL converts them to the current session timezone (<code>SHOW TIMEZONE;</code>).</li>
        <li>This ensures consistent handling of international data and daylight saving changes.</li>
    </ul>
<pre><code class="language-sql line-numbers">SET TIMEZONE TO 'UTC';
SELECT start_at FROM meetings;

SET TIMEZONE TO 'America/New_York';
SELECT start_at FROM meetings;
</code></pre>
    <br/>
    <ul>
        <li>The same instant in time displays differently under different timezones.</li>
    </ul>
    <br/>
    <br/>


    <li><b>INTERVAL Type</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE rentals (
    rental_id  SERIAL PRIMARY KEY,
    start_date TIMESTAMP,
    duration   INTERVAL
);

INSERT INTO rentals VALUES (1, '2025-11-11 10:00:00', INTERVAL '3 days 4 hours');

SELECT
    start_date + duration AS return_date
FROM rentals;
</code></pre>
    <br/>
    <ul>
        <li><code>INTERVAL</code> represents a time duration or span, not a specific point in time.</li>
        <li>You can add or subtract intervals to/from timestamps or dates.</li>
        <li>Intervals can include multiple components (years, months, days, hours, minutes, seconds).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extracting Date and Time Parts</b></li>
<pre><code class="language-sql line-numbers">SELECT
    EXTRACT(YEAR FROM start_at)   AS year,
    EXTRACT(MONTH FROM start_at)  AS month,
    EXTRACT(DAY FROM start_at)    AS day,
    EXTRACT(HOUR FROM start_at)   AS hour
FROM meetings;
</code></pre>
    <br/>
    <ul>
        <li><code>EXTRACT()</code> retrieves individual components from a date or timestamp.</li>
        <li>Other functions like <code>DATE_PART()</code> and <code>TO_CHAR()</code> provide similar functionality with formatting control.</li>
<pre><code class="language-sql line-numbers">SELECT TO_CHAR(start_at, 'YYYY-MM-DD HH24:MI');</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Date and Time Arithmetic</b></li>
<pre><code class="language-sql line-numbers">SELECT
    NOW()                           AS now,
    NOW() + INTERVAL '7 days'       AS next_week,
    NOW() - INTERVAL '1 month'      AS last_month,
    AGE('2025-12-31', '2025-01-01') AS difference;
</code></pre>
    <br/>
    <ul>
        <li><b>+</b> and <b>-</b> can be used with intervals for addition and subtraction.</li>
        <li><code>AGE()</code> returns a human-readable interval difference between two timestamps.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Useful Built-in Functions</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Function</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>NOW()</code></td>
                <td>Current date and time (same as <code>CURRENT_TIMESTAMP</code>)</td>
            </tr>
            <tr>
                <td><code>CURRENT_DATE</code></td>
                <td>Current date (no time)</td>
            </tr>
            <tr>
                <td><code>CURRENT_TIME</code></td>
                <td>Current time of day</td>
            </tr>
            <tr>
                <td><code>LOCALTIME</code> / <code>LOCALTIMESTAMP</code></td>
                <td>Local time/date-time without timezone conversion</td>
            </tr>
            <tr>
                <td><code>AGE(timestamp1, timestamp2)</code></td>
                <td>Difference between two timestamps as interval</td>
            </tr>
            <tr>
                <td><code>DATE_TRUNC('field', source)</code></td>
                <td>Truncates a timestamp to the specified precision (e.g., hour, day, month)</td>
            </tr>
        </tbody>
    </table>
<pre><code class="language-sql line-numbers">SELECT DATE_TRUNC('month', NOW()); -- first day of current month
</code></pre>
    <br/>
    <br/>


    <li><b>Converting Between Date/Time Types</b></li>
<pre><code class="language-sql line-numbers">SELECT
    '2025-11-11'::DATE + INTERVAL '1 day',   -- date â†’ timestamp
    '13:45:00'::TIME + INTERVAL '2 hours',   -- time + interval
    NOW()::DATE AS current_day,              -- timestamp â†’ date
    CAST('2025-11-11 09:00' AS TIMESTAMPTZ);
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="uuid">The UUID Type in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>UUID</code> stands for <b>Universally Unique Identifier</b>.</li>
        <br/>
        <li>It is a 128-bit value used to uniquely identify rows, records, or entities across systems, databases, and even time â€” without relying on a central sequence generator.</li>
        <br/>
        <li>PostgreSQL natively supports <code>UUID</code> as a built-in data type, compliant with <u>RFC&nbsp;4122</u>.</li>
        <br/>
        <li>UUIDs are often used as <u>primary keys</u> in distributed or large-scale applications where integer IDs might collide or reveal sequence information.</li>
    </ul>
    <br/>
    <br/>


    <li><b>UUID Format</b></li>
    <br/>
    <ul>
        <li>A UUID is typically written as a 36-character string in hexadecimal form, separated by hyphens:</li>
<pre><code class="language-text">550e8400-e29b-41d4-a716-446655440000</code></pre>
        <li>Internally, PostgreSQL stores it efficiently as a 16-byte binary value (not as text).</li>
        <li>UUIDs are <b>case-insensitive</b>, <code>'A23B...'</code> and <code>'a23b...'</code> represent the same value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating a Table with UUID Column</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    name    TEXT NOT NULL
);

INSERT INTO users (user_id, name)
VALUES ('550e8400-e29b-41d4-a716-446655440000', 'Alice');
</code></pre>
    <br/>
    <ul>
        <li><code>UUID</code> columns can be manually assigned, or automatically generated using PostgreSQL's functions.</li>
        <li>Each UUID guarantees uniqueness across space and time with an extremely low probability of collision.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generating UUIDs Automatically</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides UUID generation through the <code>uuid-ossp</code> and <code>pgcrypto</code> extensions.</li>
        <li>To enable them:</li>
<pre><code class="language-sql line-numbers">CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
</code></pre>
        <li>Then you can generate UUIDs using built-in functions:</li>
<pre><code class="language-sql line-numbers">-- Using uuid-ossp:
SELECT uuid_generate_v1();   -- based on MAC + timestamp
SELECT uuid_generate_v4();   -- random-based (most common)

-- Using pgcrypto:
SELECT gen_random_uuid();    -- random version 4 UUID (faster, preferred)
</code></pre>
        <li>Modern PostgreSQL versions (â‰¥13) recommend <code>gen_random_uuid()</code> from <code>pgcrypto</code> for simplicity and performance.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Auto-Generated UUIDs as Primary Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE api_tokens (
    token_id  UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id   UUID NOT NULL,
    issued_at TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO api_tokens (user_id)
VALUES ('550e8400-e29b-41d4-a716-446655440000');
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>gen_random_uuid()</code> generates a new unique identifier automatically when no ID is provided.</li>
        <li>This eliminates the need for numeric sequences and prevents ID collisions across distributed systems.</li>
        <li>UUID-based keys are also non-sequential â€” they don't reveal record creation order or count.</li>
    </ul>
    <br/>
    <br/>


    <li><b>UUID Versions Overview</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Version</th>
                <th>Source</th>
                <th>Function (uuid-ossp)</th>
                <th>Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>v1</td>
                <td>Timestamp + MAC address</td>
                <td><code>uuid_generate_v1()</code></td>
                <td>Predictable, contains machine/time info (not recommended for public use)</td>
            </tr>
            <tr>
                <td>v3</td>
                <td>Namespace + MD5 hash</td>
                <td><code>uuid_generate_v3(namespace, name)</code></td>
                <td>Deterministic generation from names</td>
            </tr>
            <tr>
                <td>v4</td>
                <td>Random numbers</td>
                <td><code>uuid_generate_v4()</code> or <code>gen_random_uuid()</code></td>
                <td>Most common, fast, and secure for general use</td>
            </tr>
            <tr>
                <td>v5</td>
                <td>Namespace + SHA-1 hash</td>
                <td><code>uuid_generate_v5(namespace, name)</code></td>
                <td>Deterministic but safer than v3</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Version 4 (random) UUIDs are the default choice for new projects.</li>
        <li>Versions 3 and 5 are used when deterministic IDs are needed for given input data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparing UUID vs SERIAL IDs</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th><code>SERIAL / IDENTITY</code></th>
                <th><code>UUID</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Uniqueness</td>
                <td>Unique within a single database sequence</td>
                <td>Globally unique across databases and servers</td>
            </tr>
            <tr>
                <td>Predictability</td>
                <td>Sequential, reveals insertion order</td>
                <td>Non-sequential, unpredictable</td>
            </tr>
            <tr>
                <td>Storage Size</td>
                <td>4â€“8 bytes</td>
                <td>16 bytes</td>
            </tr>
            <tr>
                <td>Indexing Speed</td>
                <td>Faster (smaller, sequential)</td>
                <td>Slightly slower (larger, random order)</td>
            </tr>
            <tr>
                <td>Replication / Merging</td>
                <td>May collide between instances</td>
                <td>Safe across distributed databases</td>
            </tr>
            <tr>
                <td>Use Case</td>
                <td>Simple local applications</td>
                <td>Microservices, APIs, distributed systems</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>While <code>UUID</code> keys consume more storage and index space, their <b>global uniqueness</b> makes them ideal for modern scalable systems.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Querying UUID Columns</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM api_tokens
WHERE token_id = 'b36d6d3e-b41a-4d0c-b4e4-9985a93f79a7';

-- You can also use functions:
SELECT token_id::TEXT FROM api_tokens;
</code></pre>
    <br/>
    <ul>
        <li>You can compare, cast, or index UUID columns just like integers.</li>
        <li>UUID comparisons are efficient and type-safe â€” no need for string matching.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Indexing and Performance</b></li>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_api_tokens_user_id ON api_tokens(user_id);
</code></pre>
    <br/>
    <ul>
        <li>Indexing UUID columns works exactly like for integers.</li>
        <li>However, because UUIDs are random, inserts can fragment B-tree indexes, slightly reducing performance for very large tables.</li>
        <li>To optimize insert speed, consider using <code>uuid_generate_v1mc()</code> (MAC/time-ordered UUID) or PostgreSQL's <code>pgcrypto</code> functions with custom ordering strategies.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="cte">Common Table Expressions (CTE) in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>Common Table Expression (CTE)</b> is a temporary, named result set defined within a query using the <code>WITH</code> clause.</li>
        <br/>
        <li>CTEs make SQL queries <b>easier to read, maintain, and debug</b>, especially when dealing with subqueries or recursive data.</li>
        <br/>
        <li>They exist ONLY for the duration of the SINGLE SQL statement and are not stored as permanent tables.</li>
        <br/>
        <li>CTEs can be:
            <ul>
                <li><b>Non-recursive</b>: similar to a named subquery.</li>
                <li><b>Recursive</b>: used to query hierarchical or tree-like data.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">WITH cte_name (optional_columns) AS (
    SQL_query
)
SELECT ...
FROM cte_name;
</code></pre>
    <br/>
    <ul>
        <li><code>cte_name</code> â€” the name of your temporary result set.</li>
        <li><code>optional_columns</code> â€” optional list of column names for the CTE result.</li>
        <li><code>SQL_query</code> â€” a normal SELECT (or even INSERT / UPDATE / DELETE) that defines the data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Basic Non-Recursive CTE</b></li>
<pre><code class="language-sql line-numbers">WITH top_sellers AS (
    SELECT
        seller_id,
        SUM(amount) AS total_sales
    FROM orders
    GROUP BY seller_id
    HAVING SUM(amount) &gt; 5000
)

SELECT
    s.seller_id,
    s.total_sales,
    u.name
FROM top_sellers AS s
JOIN users AS u ON u.id = s.seller_id;
</code></pre>
    <br/>
    <ul>
        <li>The inner query creates a <code>top_sellers</code> CTE containing only sellers with total sales above 5000.</li>
        <li>The main query then joins that result with <code>users</code> to retrieve seller details.</li>
        <li>This improves readability compared to deeply nested subqueries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using Multiple CTEs</b></li>
<pre><code class="language-sql line-numbers">WITH
    orders_per_customer AS (
        SELECT customer_id, COUNT(*) AS order_count
        FROM orders
        GROUP BY customer_id
    ),
    top_customers AS (
        SELECT customer_id
        FROM orders_per_customer
        WHERE order_count &gt; 10
    )

SELECT c.name, opc.order_count
FROM top_customers tc
JOIN orders_per_customer opc ON tc.customer_id = opc.customer_id
JOIN customers c ON c.id = tc.customer_id;
</code></pre>
    <br/>
    <ul>
        <li>You can define multiple CTEs in a single <code>WITH</code> clause â€” each separated by commas.</li>
        <li>Later CTEs can reference earlier ones within the same statement.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Modifying Data with CTEs</b></li>
<pre><code class="language-sql line-numbers">WITH updated AS (
    UPDATE products
    SET price = price * 1.10
    WHERE category = 'electronics'
    RETURNING id, price
)
SELECT * FROM updated;
</code></pre>
    <br/>
    <ul>
        <li>CTEs can be used with <b>INSERT</b>, <b>UPDATE</b>, or <b>DELETE</b> statements that return data using <code>RETURNING</code>.</li>
        <li>This pattern is powerful for performing modifications and immediately reading back affected rows.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Recursive CTEs</b></li>
    <br/>
    <ul>
        <li>Recursive CTEs are used to handle <b>hierarchical data</b> such as organizational charts, category trees, or dependency chains.</li>
        <li>The general form consists of two parts:
            <ul>
                <li><b>Anchor member</b> â€” the base query (starting rows).</li>
                <li><b>Recursive member</b> â€” a query that references the CTE itself, used to fetch related rows iteratively.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">WITH RECURSIVE subordinates AS (
    -- Anchor: start from the manager
    SELECT employee_id, name, manager_id
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive step: find employees reporting to those above
    SELECT e.employee_id, e.name, e.manager_id
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.employee_id
)
SELECT * FROM subordinates;
</code></pre>
    <br/>
    <ul>
        <li>This query builds an entire organization hierarchy starting from the top-level manager.</li>
        <li>The recursion continues until no new rows are produced.</li>
        <li><b>UNION ALL</b> is used (instead of <code>UNION</code>) to include all recursive results efficiently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Folder Hierarchy</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE folders (
    id SERIAL PRIMARY KEY,
    name TEXT,
    parent_id INT REFERENCES folders(id)
);

WITH RECURSIVE folder_tree AS (
    SELECT id, name, parent_id, 1 AS depth
    FROM folders
    WHERE parent_id IS NULL

    UNION ALL

    SELECT f.id, f.name, f.parent_id, ft.depth + 1
    FROM folders f
    JOIN folder_tree ft ON f.parent_id = ft.id
)
SELECT * FROM folder_tree ORDER BY depth;
</code></pre>
    <br/>
    <ul>
        <li>This recursive CTE prints all folders in a tree, showing their depth levels.</li>
        <li>Very useful for hierarchical structures like menus, file systems, and organizational charts.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>CTEs behave like <b>optimization fences</b> in older PostgreSQL versions (â‰¤12):
            <ul>
                <li>The CTE is fully materialized before the main query executes.</li>
                <li>This means it is computed once and stored temporarily, which may hurt performance for very large datasets.</li>
            </ul>
        </li>
        <br/>
        <li>In PostgreSQL â‰¥13, <b>inlinable CTEs</b> were introduced, non-recursive CTEs can now be automatically inlined by the optimizer if safe.</li>
        <br/>
        <li>To enforce materialization (useful for debugging or when side-effects matter):</li>
<pre><code class="language-sql line-numbers">WITH MATERIALIZED temp_data AS (...)
SELECT * FROM temp_data;
</code></pre>
        <br/>
        <li>Or, to explicitly allow inlining for better performance:</li>
<pre><code class="language-sql line-numbers">WITH NOT MATERIALIZED temp_data AS (...)
SELECT * FROM temp_data;
</code></pre>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="view">Views in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>VIEW</b> in PostgreSQL is a <u>virtual table</u> defined by a SQL query.</li>
        <br/>
        <li>It behaves like a table but does not store data physically, instead, it runs the underlying query each time the view is accessed.</li>
        <br/>
        <li>Views simplify complex queries, improve code readability, and help enforce <u>security</u> by exposing only specific columns or rows.</li>
        <br/>
        <li>PostgreSQL also supports <b>materialized views</b>, which store the result physically for faster reads.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE VIEW view_name AS
SELECT column1, column2
FROM table_name
WHERE condition;
</code></pre>
    <br/>
    <ul>
        <li><code>view_name</code> â€” the name of the virtual table.</li>
        <li>The view can then be queried like any normal table using <code>SELECT</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Creating a Simple View</b></li>
<pre><code class="language-sql line-numbers">CREATE VIEW active_users AS
SELECT id, name, email
FROM users
WHERE is_active = true;

SELECT * FROM active_users;
</code></pre>
    <br/>
    <ul>
        <li>This view returns only active users without requiring the filter in every query.</li>
        <li>Views are dynamically updated, changes in underlying tables appear automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using Views to Simplify Complex Queries</b></li>
<pre><code class="language-sql line-numbers">CREATE VIEW monthly_sales AS
SELECT
    seller_id,
    DATE_TRUNC('month', order_date) AS month,
    SUM(amount)                     AS total_sales
FROM orders
GROUP BY seller_id, month;

SELECT * FROM monthly_sales
WHERE total_sales &gt; 5000;
</code></pre>
    <br/>
    <ul>
        <li>Views reduce duplication of complex logic (aggregations, joins, calculations).</li>
        <li>Applications can query the view instead of repeating long SQL statements.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Updating Data Through Views</b></li>
    <br/>
    <ul>
        <li>Some views can be <u>updatable</u>, which means you can run <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> on them.</li>
        <br/>
        <li>A view is updatable when it maps directly to a single table <u>without set operations or aggregates</u>.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE VIEW user_public_info AS
SELECT id, name, email
FROM users;

UPDATE user_public_info
SET name = 'Alice Cooper'
WHERE id = 5;
</code></pre>
    <br/>
    <ul>
        <li>This modifies data in the underlying <code>users</code> table.</li>
        <li>Views involving joins, GROUP BY, DISTINCT, UNION, etc., are usually <u>not updatable</u>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Security and Access Control</b></li>
    <br/>
    <ul>
        <li>Views are often used to restrict sensitive data.</li>
        <br/>
        <li>You can grant access to the view while keeping the underlying tables private.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE VIEW user_safe_view AS
SELECT id, name
FROM users;

GRANT SELECT ON user_safe_view TO analyst_role;
REVOKE SELECT ON users FROM analyst_role;
</code></pre>
    <br/>
    <ul>
        <li>This ensures the role can only see the non-sensitive columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Replacing or Dropping a View</b></li>
<pre><code class="language-sql line-numbers">DROP VIEW IF EXISTS view_name;

CREATE OR REPLACE VIEW view_name AS
SELECT ...
FROM ...;
</code></pre>
    <br/>
    <ul>
        <li><code>CREATE OR REPLACE</code> lets you modify the view without dropping permissions.</li>
        <li>Dropping a view does not affect the underlying data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Materialized Views</b></li>
    <br/>
    <ul>
        <li>A <u>materialized view</u> stores the query result physically on disk.</li>
        <br/>
        <li>Useful for performance when the underlying query is heavy (joins, aggregations, scanning large tables).</li>
        <br/>
        <li>But unlike normal views, materialized views must be <u>manually refreshed</u>.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW sales_summary AS
SELECT seller_id, SUM(amount) AS total_sales
FROM orders
GROUP BY seller_id;

-- Read from the materialized view
SELECT * FROM sales_summary;

-- Refresh when data changes:
REFRESH MATERIALIZED VIEW sales_summary;
</code></pre>
    <br/>
    <ul>
        <li>Materialized views behave like cached query results.</li>
        <li>They significantly speed up analytics on large datasets.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Materialized View with Indexes</b></li>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW monthly_stats AS
SELECT
    DATE_TRUNC('month', created_at) AS month,
    COUNT(*)                        AS total_users
FROM users
GROUP BY month;

CREATE INDEX idx_monthly_stats_month ON monthly_stats(month);
</code></pre>
    <br/>
    <ul>
        <li>Indexes on materialized views improve read performance just like on regular tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Advanced: Refreshing Concurrently</b></li>
    <br/>
    <ul>
        <li>To refresh a materialized view <u>without blocking reads</u>, PostgreSQL provides:</li>
    </ul>
<pre><code class="language-sql line-numbers">REFRESH MATERIALIZED VIEW CONCURRENTLY sales_summary;
</code></pre>
    <br/>
    <ul>
        <li>Requires a unique index on the materialized view.</li>
        <li>Allows reads during the refresh â€” ideal for production systems.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="materialized-view">Materialized Views in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <b>Materialized View</b> (MV) is a database object that stores the <u>physical</u> result of a SQL query.</li>
        <br/>
        <li>Unlike normal views (which run the underlying query every time), materialized views improve performance by caching the data.</li>
        <br/>
        <li>Materialized views are ideal for <u>heavy analytical queries</u>, <u>aggregations</u>, and <u>large datasets</u>.</li>
        <br/>
        <li>They must be <u>manually refreshed</u> to reflect changes in underlying tables.</li>
        <br/>
        <li>PostgreSQL supports both normal refresh and <b>CONCURRENT</b> refresh, which avoids blocking reads.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW view_name AS
SELECT ...
FROM ...
WHERE ...;
</code></pre>
    <br/>
    <ul>
        <li>The materialized view stores the result of the SELECT at creation time.</li>
        <li>The data inside the MV does <b>NOT</b> automatically update, so refresh is required.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Creating a Materialized View</b></li>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW monthly_sales AS
SELECT
    seller_id,
    DATE_TRUNC('month', order_date) AS month,
    SUM(amount)                     AS total_sales
FROM orders
GROUP BY seller_id, month;

SELECT * FROM monthly_sales;
</code></pre>
    <br/>
    <ul>
        <li>Query results are stored physically and retrieved instantly.</li>
        <li>No recomputation happens until a refresh is triggered.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Refreshing Materialized Views</b></li>
    <br/>
    <ul>
        <li>To update the stored data, call <code>REFRESH MATERIALIZED VIEW</code>:</li>
    </ul>
<pre><code class="language-sql line-numbers">REFRESH MATERIALIZED VIEW monthly_sales;
</code></pre>
    <br/>
    <ul>
        <li>This command <b>locks</b> the MV for reads and writes until refresh is complete.</li>
        <li>Use it when downtime during refresh is acceptable.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Refreshing Concurrently (Non-blocking)</b></li>
    <br/>
    <ul>
        <li>To avoid blocking reads while refreshing:</li>
    </ul>
<pre><code class="language-sql line-numbers">REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales;
</code></pre>
    <br/>
    <ul>
        <li>Allows users to still query the MV during refresh.</li>
        <li><b>Requires:</b> A <u>unique index</u> on the MV.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE UNIQUE INDEX idx_monthly_sales_unique ON monthly_sales(seller_id, month);</code></pre>
    <br/>
    <ul>
        <li>Use concurrent refresh for production systems where availability matters.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Materialized Views vs Normal Views</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Normal View</th>
                <th>Materialized View</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Storage</td>
                <td>No physical storage</td>
                <td>Stores data physically</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Runs query every time (slow for heavy logic)</td>
                <td>Fast reads, cached data</td>
            </tr>
            <tr>
                <td>Freshness</td>
                <td>Always up-to-date</td>
                <td>Must be refreshed manually</td>
            </tr>
            <tr>
                <td>Use Case</td>
                <td>Simple abstractions</td>
                <td>Heavy queries, analytics</td>
            </tr>
            <tr>
                <td>Blocking</td>
                <td>No refresh needed</td>
                <td>Refresh blocks reads unless CONCURRENTLY</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Materialized Views with Indexes</b></li>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW user_summary AS
SELECT
    country,
    COUNT(*) AS user_count
FROM users
GROUP BY country;

CREATE INDEX idx_user_summary_country
ON user_summary(country);
</code></pre>
    <br/>
    <ul>
        <li>Indexes on materialized views speed up <code>SELECT</code> queries.</li>
        <li>Indexes persist across refresh operations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Manually Refreshing Only When Needed</b></li>
    <br/>
    <ul>
        <li>Materialized views are often refreshed:</li>
        <br/>
        <ul>
            <li>Nightly (cron job)</li>
            <li>Every hour for dashboard updates</li>
            <li>On-demand when underlying tables change</li>
            <li>After ETL/ELT batch loading</li>
        </ul>
        <br/>
        <li>PostgreSQL does not auto-refresh â€” applications decide the refresh schedule.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Materialized View</b></li>
<pre><code class="language-sql line-numbers">DROP MATERIALIZED VIEW IF EXISTS view_name;
</code></pre>
    <br/>
    <ul>
        <li>Dropping an MV does not affect underlying tables.</li>
        <li>Indexes on the MV are dropped automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Advanced: Materialized Views with Joins</b></li>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW product_stats AS
SELECT
    p.id AS product_id,
    p.name,
    COUNT(o.id) AS orders_count,
    SUM(o.amount) AS total_revenue
FROM products p
LEFT JOIN orders o ON o.product_id = p.id
GROUP BY p.id, p.name;

-- Refresh when needed
REFRESH MATERIALIZED VIEW product_stats;
</code></pre>
    <br/>
    <ul>
        <li>Materialized views shine when performing expensive joins repeatedly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Advanced: Materialized View with WHERE Filters</b></li>
<pre><code class="language-sql line-numbers">CREATE MATERIALIZED VIEW recent_orders AS
SELECT *
FROM orders
WHERE order_date &gt; NOW() - INTERVAL '30 days';
</code></pre>
    <br/>
    <ul>
        <li>Useful for windowed datasets (recent data, daily snapshots, etc.).</li>
        <li>Can be indexed for faster reporting.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-case">The CASE Expression in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>CASE</code> expression in PostgreSQL allows you to perform conditional logic directly inside SQL queries.</li>
        <br/>
        <li>It works similarly to <u>if-else</u> statements in programming languages.</li>
        <br/>
        <li><code>CASE</code> returns different values depending on evaluated conditions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>General Syntax</b></li>
<pre><code class="language-sql line-numbers">CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ...
    ELSE default_result
END
</code></pre>
    <br/>
    <ul>
        <li><code>WHEN</code> clauses are evaluated from top to bottom.</li>
        <li>The first true condition determines the returned value.</li>
        <li><code>ELSE</code> is optional; without it, missing matches return <code>NULL</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Simple CASE Expression</b></li>
    <br/>
    <ul>
        <li>Compares a single expression to several possible values.</li>
    </ul>
<pre><code class="language-sql line-numbers">CASE status
    WHEN 'A' THEN 'Active'
    WHEN 'I' THEN 'Inactive'
    ELSE 'Unknown'
END
</code></pre>
    <br/>
    <ul>
        <li>Useful when conditions depend on equality comparisons.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Searched CASE Expression</b></li>
    <br/>
    <ul>
        <li>Allows complex logical conditions.</li>
        <li>Conditions are evaluated independently.</li>
    </ul>
<pre><code class="language-sql line-numbers">CASE
    WHEN amount &gt; 1000 THEN 'High'
    WHEN amount BETWEEN 500 AND 1000 THEN 'Medium'
    WHEN amount &gt; 0 THEN 'Low'
    ELSE 'None'
END
</code></pre>
    <br/>
    <ul>
        <li>This form is more flexible and widely used.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Categorizing Orders</b></li>
<pre><code class="language-sql line-numbers">SELECT
    order_id,
    amount,
    CASE
        WHEN amount &gt; 1000 THEN 'VIP Order'
        WHEN amount &gt; 100 THEN 'Standard Order'
        ELSE 'Small Order'
    END AS order_type
FROM orders;
</code></pre>
    <br/>
    <ul>
        <li>This query adds a derived column <code>order_type</code> based on order amount.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CASE in ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT name, role
FROM employees
ORDER BY
    CASE
        WHEN role = 'manager'   THEN 1
        WHEN role = 'developer' THEN 2
        ELSE 3
    END;
</code></pre>
    <br/>
    <ul>
        <li>CASE allows custom sorting based on business logic.</li>
        <li>Here, managers appear first, then developers, then everyone else.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CASE in Aggregation</b></li>
<pre><code class="language-sql line-numbers">SELECT
    seller_id,
    SUM(CASE WHEN amount &gt; 500 THEN 1 ELSE 0 END)  AS large_orders,
    SUM(CASE WHEN amount &lt;= 500 THEN 1 ELSE 0 END) AS small_orders
FROM orders
GROUP BY seller_id;
</code></pre>
    <br/>
    <ul>
        <li>Conditional aggregation is a powerful pattern in reporting and analytics.</li>
        <li>Counts rows differently depending on CASE conditions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling NULL with CASE</b></li>
<pre><code class="language-sql line-numbers">SELECT
    name,
    CASE
        WHEN phone IS NULL THEN 'No phone'
        ELSE phone
    END AS phone_display
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>CASE is often used as an alternative to <code>COALESCE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>CASE with Multiple Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT
    product,
    stock,
    CASE
        WHEN stock = 0   THEN 'Out of Stock'
        WHEN stock &lt;= 10 THEN 'Low Stock'
        WHEN stock &lt;= 50 THEN 'In Stock'
        ELSE 'High Stock'
    END AS stock_level
FROM products;
</code></pre>
    <br/>
    <ul>
        <li>Conditions are checked in order, so the order of <code>WHEN</code> clauses matters.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CASE to Avoid Division by Zero</b></li>
<pre><code class="language-sql line-numbers">SELECT
    seller_id,
    total_sales,
    total_orders,
    CASE
        WHEN total_orders = 0 THEN 0
        ELSE total_sales / total_orders
    END AS avg_order_value
FROM seller_stats;
</code></pre>
    <br/>
    <ul>
        <li>CASE can gracefully guard against runtime errors.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Nested CASE Expressions</b></li>
<pre><code class="language-sql line-numbers">SELECT
    name,
    salary,
    CASE
        WHEN salary &gt; 70000 THEN 'Senior'
        WHEN salary &gt; 40000 THEN
            CASE
                WHEN salary &gt; 55000 THEN 'Mid-High'
                ELSE 'Mid'
            END
        ELSE 'Junior'
    END AS level
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>Nested CASE blocks allow complex conditional transformations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>CASE Expression Without ELSE</b></li>
<pre><code class="language-sql line-numbers">CASE
    WHEN score &gt;= 90 THEN 'A'
    WHEN score &gt;= 80 THEN 'B'
END
</code></pre>
    <br/>
    <ul>
        <li>If no condition matches, result is <code>NULL</code>.</li>
        <li>For safety, include <code>ELSE</code> in most production SQL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>The <code>CASE</code> expression is fast, it is evaluated per row and does not require special indexing.</li>
        <br/>
        <li>However, CASE inside:
            <ul>
                <li><code>ORDER BY</code></li>
                <li><code>WHERE</code></li>
                <li><code>JOIN</code> conditions</li>
            </ul>
            can affect query performance because they prevent index-only operations.
        </li>
        <br/>
        <li>Use CASE mainly in <code>SELECT</code> or for computed fields when possible.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-coalesce">The COALESCE Function in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>COALESCE</code> is a SQL function that returns the <u>first non-NULL value</u> in a list of expressions.</li>
        <br/>
        <li>It is commonly used to handle NULL values, provide defaults, clean data, or avoid NULL-related errors.</li>
        <br/>
        <li>PostgreSQL evaluates expressions <u>from left to right</u> and returns the earliest non-NULL result.</li>
        <br/>
        <li><code>COALESCE</code> is equivalent to a simple <code>CASE</code> expression but is shorter and more readable.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Syntax</b></li>
<pre><code class="language-sql line-numbers">COALESCE(value1, value2, value3, ...)
</code></pre>
    <br/>
    <ul>
        <li><code>value1</code>, <code>value2</code>, <code>value3</code>, ... are evaluated in order.</li>
        <li>The first value that is not NULL is returned.</li>
        <li>If all values are NULL, the result is NULL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Example</b></li>
<pre><code class="language-sql line-numbers">SELECT COALESCE(NULL, NULL, 'Hello', 'World');
</code></pre>
    <br/>
    <ul>
        <li>Returns <code>'Hello'</code>, since it is the first non-NULL value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using COALESCE to Replace NULL With a Default</b></li>
<pre><code class="language-sql line-numbers">SELECT
    name,
    COALESCE(phone, 'No phone number') AS phone_display
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>If <code>phone</code> is NULL, it displays a default string instead.</li>
        <li>Useful for UI, reports, and exported data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using COALESCE With Numeric Values</b></li>
<pre><code class="language-sql line-numbers">SELECT
    price,
    COALESCE(discount_price, price) AS effective_price
FROM products;
</code></pre>
    <br/>
    <ul>
        <li>If <code>discount_price</code> is NULL, fallback to original price.</li>
        <li>Prevents NULL from propagating into calculations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using COALESCE in Calculations</b></li>
<pre><code class="language-sql line-numbers">SELECT
    COALESCE(total_sales, 0) / COALESCE(order_count, 1) AS avg_order_value
FROM seller_stats;
</code></pre>
    <br/>
    <ul>
        <li>Prevents division by NULL or NULL arithmetic results.</li>
        <li>Often used in analytics pipelines.</li>
    </ul>
    <br/>
    <br/>


    <li><b>COALESCE With Multiple Alternatives</b></li>
<pre><code class="language-sql line-numbers">SELECT
    COALESCE(username, email, phone, 'Unknown User') AS identifier
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>The first available non-NULL contact method is selected.</li>
        <li>If all fields are NULL, <code>'Unknown User'</code> is returned.</li>
    </ul>
    <br/>
    <br/>


    <li><b>COALESCE vs CASE Expression</b></li>
<pre><code class="language-sql line-numbers">CASE
    WHEN value1 IS NOT NULL THEN value1
    WHEN value2 IS NOT NULL THEN value2
    ELSE value3
END
</code></pre>
    <br/>
    <ul>
        <li>This CASE expression is equivalent to:</li>
    </ul>
<pre><code class="language-sql line-numbers">COALESCE(value1, value2, value3)
</code></pre>
    <br/>
    <ul>
        <li><code>COALESCE</code> is simpler and preferred for NULL-handling.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using COALESCE With Aggregations</b></li>
<pre><code class="language-sql line-numbers">SELECT
    seller_id,
    COALESCE(SUM(amount), 0) AS total_sales
FROM orders
GROUP BY seller_id;
</code></pre>
    <br/>
    <ul>
        <li><code>SUM()</code> returns NULL when no rows exist.</li>
        <li>COALESCE ensures numeric aggregates have meaningful defaults.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling NULL Dates</b></li>
<pre><code class="language-sql line-numbers">SELECT
    name,
    COALESCE(last_login, NOW()) AS effective_last_login
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>If a user never logged in, use the current timestamp.</li>
        <li>Useful for audits and logs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>COALESCE in ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT title
FROM books
ORDER BY COALESCE(published_year, 0);
</code></pre>
    <br/>
    <ul>
        <li>Allows ordering while gracefully handling NULL values.</li>
        <li>NULL is usually treated as larger than all non-NULL values unless COALESCE changes it.</li>
    </ul>
    <br/>
    <br/>


    <li><b>COALESCE in JOIN Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM orders o
JOIN customers c
    ON COALESCE(o.customer_id, 0) = c.id;
</code></pre>
    <br/>
    <ul>
        <li>Can be used to provide fallbacks in join logic.</li>
        <li>Be careful: this may prevent index usage, lowering performance.</li>
    </ul>
    <br/>
    <br/>


    <li><b>COALESCE vs NULLIF</b></li>
    <br/>
    <ul>
        <li><code>COALESCE</code> returns the first non-NULL value.</li>
        <br/>
        <li><code>NULLIF(a, b)</code> returns NULL if <code>a = b</code>, otherwise returns <code>a</code>.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    COALESCE(NULLIF(status, ''), 'unknown') AS clean_status
FROM tasks;
</code></pre>
    <br/>
    <ul>
        <li>NULLIF is often paired with COALESCE to replace "empty" values with defaults.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li><code>COALESCE</code> is extremely fast and evaluated inline per row.</li>
        <br/>
        <li>However, avoid COALESCE on indexed columns in JOIN/WHERE/ORDER BY if possible, because:
            <ul>
                <li>It may disable index usage</li>
                <li>It forces PostgreSQL to evaluate the expression for every row</li>
            </ul>
        </li>
        <br/>
        <li>Using COALESCE in SELECT is always safe and efficient.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-nullif">The NULLIF Function in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>NULLIF</code> is a conditional function in PostgreSQL that returns <b>NULL</b> if two values are equal.</li>
        <br/>
        <li>If the values are not equal, it returns the first value unchanged.</li>
        <br/>
        <li>NULLIF is often used to avoid division-by-zero errors, normalize data, or convert meaningless values into actual NULLs.</li>
        <br/>
        <li>NULLIF is frequently used together with <code>COALESCE</code> for advanced NULL-handling logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Syntax</b></li>
<pre><code class="language-sql line-numbers">NULLIF(value1, value2)
</code></pre>
    <br/>
    <ul>
        <li>If <code>value1 = value2</code>, the result is <code>NULL</code>.</li>
        <li>If <code>value1 â‰  value2</code>, the result is <code>value1</code>.</li>
        <li><code>value1</code> is always the return value unless the values match exactly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Example</b></li>
<pre><code class="language-sql line-numbers">SELECT NULLIF(10, 10);   -- returns NULL
SELECT NULLIF(10, 5);    -- returns 10
</code></pre>
    <br/>
    <ul>
        <li>NULLIF only checks equality.</li>
        <li>It does not support &lt;, &gt;, or complex expressions (you would use <code>CASE</code> for that).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Avoiding Division by Zero</b></li>
    <br/>
    <ul>
        <li>The most common use of NULLIF is to prevent division-by-zero errors.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    total_sales / NULLIF(total_orders, 0) AS avg_order_value
FROM seller_stats;
</code></pre>
    <br/>
    <ul>
        <li>If <code>total_orders = 0</code>, <code>NULLIF(total_orders, 0)</code> becomes <code>NULL</code>.</li>
        <li>Thus the result is <code>NULL</code> instead of raising a runtime error.</li>
        <li>Often paired with <code>COALESCE</code> to provide a fallback:</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    COALESCE(total_sales / NULLIF(total_orders, 0), 0) AS avg_order_value
FROM seller_stats;
</code></pre>
    <br/>
    <ul>
        <li>Here, zero is used instead of NULL for readability or reporting.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Cleaning Up Placeholder Values</b></li>
    <br/>
    <ul>
        <li>Sometimes data uses placeholder values like <code>''</code> or <code>'N/A'</code> instead of NULL.</li>
        <li>NULLIF can convert those placeholder values into true SQL NULLs.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    NULLIF(phone, '') AS clean_phone
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>If <code>phone = ''</code>, the result becomes NULL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Another Example: Converting "unknown" Strings to NULL</b></li>
<pre><code class="language-sql line-numbers">SELECT
    NULLIF(status, 'unknown') AS clean_status
FROM tasks;
</code></pre>
    <br/>
    <ul>
        <li>Useful when CSV imports or old systems store "unknown" as a literal string.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULLIF with Numeric Data</b></li>
<pre><code class="language-sql line-numbers">SELECT
    price,
    discount,
    NULLIF(discount, 0) AS valid_discount
FROM products;
</code></pre>
    <br/>
    <ul>
        <li>If <code>discount = 0</code>, treat it as NULL (e.g., "no discount").</li>
        <li>Prevents misleading values in analytics dashboards.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULLIF Combined with COALESCE</b></li>
    <br/>
    <ul>
        <li>A common pattern is cleaning values with NULLIF, then providing a fallback using COALESCE.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    COALESCE(NULLIF(username, ''), 'Guest') AS display_name
FROM accounts;
</code></pre>
    <br/>
    <ul>
        <li>If username = '', it becomes NULL, and COALESCE replaces it with "Guest".</li>
        <li>Powerful for cleaning and normalizing inconsistent data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULLIF in ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT name
FROM customers
ORDER BY NULLIF(priority, 0);
</code></pre>
    <br/>
    <ul>
        <li>Zero priorities become NULL, which sort last unless modified.</li>
        <li><b>Be cautious</b>: using expressions in <code>ORDER BY</code> may prevent index use.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULLIF Inside Aggregations</b></li>
<pre><code class="language-sql line-numbers">SELECT
    region,
    SUM(NULLIF(amount, 0)) AS total_revenue
FROM sales
GROUP BY region;
</code></pre>
    <br/>
    <ul>
        <li>This ignores zero values inside the SUM (treats them as NULL).</li>
        <li>Useful when zeros represent invalid or missing data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULLIF and Type Casting</b></li>
<pre><code class="language-sql line-numbers">SELECT NULLIF(value::INT, 0)
FROM data;
</code></pre>
    <br/>
    <ul>
        <li>NULLIF works with all PostgreSQL data types, including casts.</li>
        <li>If the casted value matches the comparison, it becomes NULL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULLIF with Multiple Comparisons (Using CASE Instead)</b></li>
    <br/>
    <ul>
        <li><code>NULLIF</code> only checks equality against a single value.</li>
        <br/>
        <li>When you need multiple comparisons, use <code>CASE</code>:</li>
    </ul>
<pre><code class="language-sql line-numbers">CASE
    WHEN score IN (0, -1, -99) THEN NULL
    ELSE score
END
</code></pre>
    <br/>
    <ul>
        <li>Useful when imported data uses multiple "missing value" codes.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li><code>NULLIF</code> is extremely lightweight â€” it is evaluated once per row.</li>
        <br/>
        <li>Be cautious using <code>NULLIF</code> inside:
            <ul>
                <li><code>JOIN</code> conditions</li>
                <li><code>WHERE</code> clauses</li>
                <li><code>ORDER BY</code> expressions</li>
            </ul>
            because it may prevent index-only scans.
        </li>
        <br/>
        <li><code>NULLIF</code> in <code>SELECT</code> lists has no performance drawback.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-least-greatest">The LEAST and GREATEST Functions in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>LEAST</code> and <code>GREATEST</code> are comparison functions in PostgreSQL that return the minimum or maximum value from a list of expressions.</li>
        <br/>
        <li>They evaluate all arguments and pick the smallest (<code>LEAST</code>) or largest (<code>GREATEST</code>) value.</li>
        <br/>
        <li>Both functions accept <u>two or more arguments</u> and work with:
            <ul>
                <li>Numbers</li>
                <li>Text</li>
                <li>Dates and timestamps</li>
                <li>Any comparable data type</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Syntax</b></li>
<pre><code class="language-sql line-numbers">LEAST(value1, value2, value3, ...)
GREATEST(value1, value2, value3, ...)
</code></pre>
    <br/>
    <ul>
        <li>At least two arguments are required.</li>
        <li>All arguments must be of comparable data types.</li>
        <li>If any argument is <code>NULL</code>, the result is <code>NULL</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Examples</b></li>
<pre><code class="language-sql line-numbers">SELECT LEAST(5, 8, 2, 7);       -- returns 2
SELECT GREATEST(5, 8, 2, 7);    -- returns 8
</code></pre>
    <br/>
    <ul>
        <li>Arguments are compared using standard SQL comparison rules.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using LEAST and GREATEST With Text</b></li>
<pre><code class="language-sql line-numbers">SELECT LEAST('banana', 'apple', 'cherry');    -- returns 'apple'
SELECT GREATEST('banana', 'apple', 'cherry'); -- returns 'cherry'
</code></pre>
    <br/>
    <ul>
        <li>Text values are compared lexicographically (dictionary order).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using LEAST and GREATEST With Dates</b></li>
<pre><code class="language-sql line-numbers">SELECT LEAST('2024-01-01', '2023-12-31');    -- 2023-12-31
SELECT GREATEST('2024-01-01', '2023-12-31'); -- 2024-01-01
</code></pre>
    <br/>
    <ul>
        <li>Dates are compared chronologically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling NULL Values</b></li>
<pre><code class="language-sql line-numbers">SELECT LEAST(10, NULL, 5);      -- NULL
SELECT GREATEST(NULL, 100, 50); -- NULL
</code></pre>
    <br/>
    <ul>
        <li>If any argument is NULL, the whole function returns NULL.</li>
        <li>Use <code>COALESCE</code> to avoid NULL propagation:</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT LEAST(COALESCE(a, 0), COALESCE(b, 0)) FROM table;
</code></pre>
    <br/>
    <br/>


    <li><b>Clamping Values (Setting Min/Max Boundaries)</b></li>
    <br/>
    <ul>
        <li>LEAST and GREATEST can be combined to restrict a value within a range.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- Clamp score to range 0â€“100
SELECT LEAST(100, GREATEST(score, 0)) AS clamped_score
FROM results;
</code></pre>
    <br/>
    <ul>
        <li>Values &lt; 0 become 0, values &gt; 100 become 100.</li>
        <li>This is a common technique for input validation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using LEAST / GREATEST for Conditional Logic</b></li>
    <br/>
    <ul>
        <li>These functions often replace simple CASE expressions.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    salary,
    GREATEST(salary, 2000) AS minimum_salary
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>If salary is less than 2000, it becomes 2000.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing the Earliest or Latest Timestamp</b></li>
<pre><code class="language-sql line-numbers">SELECT
    LEAST(start_time, updated_at, created_at) AS earliest_timestamp,
    GREATEST(start_time, updated_at, created_at) AS latest_timestamp
FROM logs;
</code></pre>
    <br/>
    <ul>
        <li>Useful when records track multiple timestamps.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparing Columns Across Rows</b></li>
<pre><code class="language-sql line-numbers">SELECT
    product,
    LEAST(price_usd, price_eur, price_gbp) AS minimum_price,
    GREATEST(price_usd, price_eur, price_gbp) AS maximum_price
FROM products;
</code></pre>
    <br/>
    <ul>
        <li>Helps unify multiple currency columns or alternative pricing sources.</li>
    </ul>
    <br/>
    <br/>


    <li><b>LEAST/GREATEST With Derived Expressions</b></li>
<pre><code class="language-sql line-numbers">SELECT
    id,
    LEAST(amount * 0.9, amount - 10) AS discounted_price
FROM orders;
</code></pre>
    <br/>
    <ul>
        <li>You can freely mix arithmetic and functions within argument lists.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using LEAST and GREATEST in ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT name
FROM employees
ORDER BY GREATEST(salary, bonus);
</code></pre>
    <br/>
    <ul>
        <li>Sorting by "highest compensation component."</li>
        <li>Be careful: expressions in ORDER BY may reduce index usage.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li><code>LEAST</code> and <code>GREATEST</code> are extremely fast â€” evaluated per row, no special overhead.</li>
        <br/>
        <li>However, using them in:
            <ul>
                <li><code>WHERE</code> clauses</li>
                <li><code>JOIN</code> conditions</li>
                <li><code>ORDER BY</code> expressions</li>
            </ul>
            may prevent index-only scans because PostgreSQL must compute values for every row.
        </li>
        <br/>
        <li>In <code>SELECT</code> lists, they are completely safe and efficient.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-like">Details on the LIKE Operator in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>LIKE</code> is a PostgreSQL operator for pattern-based text comparison using wildcards.</li>
        <br/>
        <li>It checks whether a string matches a specified pattern using:
            <ul>
                <li><code>%</code> &ndash; matches zero or more characters</li>
                <li><code>_</code> &ndash; matches exactly one character</li>
            </ul>
        </li>
        <br/>
        <li><code>LIKE</code> is case-sensitive. PostgreSQL provides <code>ILIKE</code> for case-insensitive matching.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Syntax</b></li>
<pre><code class="language-sql line-numbers">&lt;expression&gt; LIKE &lt;pattern&gt;
&lt;expression&gt; NOT LIKE &lt;pattern&gt;
&lt;expression&gt; ILIKE &lt;pattern&gt;
&lt;expression&gt; NOT ILIKE &lt;pattern&gt;
</code></pre>
<br/>
<ul>
    <li><code>expression</code> is the text to match.</li>
    <li><code>pattern</code> is a string literal containing wildcards.</li>
    <li>Returns <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code> (when either side is NULL).</li>
</ul>
<br/>
<br/>



    <li><b>Wildcard Rules: % and _</b></li>
<pre><code class="language-sql line-numbers">-- % wildcard (zero or more characters)
SELECT 'postgresql' LIKE 'post%';   -- TRUE

-- _ wildcard (exactly one character)
SELECT 'cat' LIKE 'c_t';            -- TRUE
</code></pre>
<br/>
<ul>
    <li><code>%</code> matches an arbitrary-length sequence of characters (including empty).</li>
    <li><code>_</code> matches exactly one UTF-8 character &ndash; important when matching multi-byte Unicode characters.</li>
</ul>
<br/>
<br/>



    <li><b>Advanced: Matching Multi-byte Unicode Characters</b></li>
<br/>
<ul>
    <li>PostgreSQL <b>treats characters, not bytes</b>. This means:</li>
</ul>
<pre><code class="language-sql line-numbers">SELECT 'ä½ ' LIKE '_';    -- TRUE (one Chinese character)
SELECT 'ä½ ' LIKE '__';   -- FALSE
</code></pre>
<br/>
<ul>
    <li><code>_</code> never splits a multi-byte UTF-8 character.</li>
    <li>This makes <code>LIKE</code> safe for CJK languages.</li>
</ul>
<br/>
<br/>



    <li><b>Escaping Wildcards: The ESCAPE Clause</b></li>
<br/>
<ul>
    <li>To match literal <code>%</code> or <code>_</code>, define an escape character.</li>
</ul>
<pre><code class="language-sql line-numbers">SELECT '100% match' LIKE '100\% match' ESCAPE '\';   -- TRUE
SELECT 'file_1'     LIKE 'file\_'      ESCAPE '\';   -- TRUE
</code></pre>
<br/>
<ul>
    <li>The default escape character is <u>none</u> &ndash; you must explicitly use <code>ESCAPE</code>.</li>
    <li>Any character can be the escape character:</li>
</ul>
<pre><code class="language-sql line-numbers">SELECT 'file_1' LIKE 'file#_' ESCAPE '#';            -- TRUE
</code></pre>
<br/>
<ul>
    <li>Pattern scanning follows these rules:
        <ul>
            <li><code>&lt;escape&gt;%</code> &rarr; literal percent</li>
            <li><code>&lt;escape&gt;_</code> &rarr; literal underscore</li>
            <li><code>&lt;escape&gt;&lt;escape&gt;</code> &rarr; literal escape</li>
        </ul>
    </li>
</ul>
<br/>
<br/>



    <li><b>Trailing Spaces and LIKE</b></li>
<br/>
<ul>
    <li>PostgreSQL does <u>not</u> ignore trailing spaces in <code>LIKE</code> patterns.</li>
</ul>
<pre><code class="language-sql line-numbers">SELECT 'abc ' LIKE 'abc';     -- FALSE
SELECT 'abc ' LIKE 'abc%';    -- TRUE
</code></pre>
<br/>
<ul>
    <li>Use <code>RTRIM()</code> when comparing padded strings.</li>
</ul>
<br/>
<br/>



    <li><b>Locale and Collation Impact</b></li>
<br/>
<ul>
    <li><code>LIKE</code> follows SQL-standard collation rules.</li>
    <li>Collation affects character comparison but <u>not</u> wildcard behavior.</li>
</ul>
<pre><code class="language-sql line-numbers">SELECT 'Ã¤pfel' LIKE 'a%';    -- depends on collation
</code></pre>
<br/>
<ul>
    <li>With German collation, <code>Ã¤</code> may compare equal to <code>a</code>.</li>
    <li>With C collation, only byte comparison is used.</li>
</ul>
<br/>
<br/>



    <li><b>LIKE vs ILIKE (Case-Insensitive Patterns)</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' LIKE  'h%';   -- FALSE
SELECT 'Hello' ILIKE 'h%';   -- TRUE
</code></pre>
<br/>
<ul>
    <li><code>ILIKE</code> uses PostgreSQL's Unicode-aware case folding.</li>
    <li>Useful for languages with case variants (German: ÃŸ â†’ ss behavior, Turkish dotted/dotless i, etc.).</li>
</ul>
<br/>
<br/>



    <li><b>LIKE and NULL</b></li>
<pre><code class="language-sql line-numbers">SELECT NULL LIKE '%';    -- NULL
SELECT 'abc' LIKE NULL;  -- NULL
</code></pre>
<br/>
<ul>
    <li>If either operand is <code>NULL</code>, the result is <code>NULL</code> (unknown).</li>
    <li>Use <code>COALESCE()</code> when needed.</li>
</ul>
<br/>
<br/>



    <li><b>Using LIKE With ANY / ALL</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM logs
WHERE message LIKE ANY (ARRAY['%error%', '%fail%', '%fatal%']);
</code></pre>
<br/>
<br/>



    <li><b>LIKE vs SIMILAR TO vs Regular Expressions</b></li>
<br/>
<ul>
    <li><code>LIKE</code> &ndash; Simple wildcard patterns <b>(fast, minimal syntax)</b></li>
    <li><code>SIMILAR TO</code> &ndash; SQL-standard regex-like operator <b>(inconsistent, rarely used)</b></li>
    <li><code>~</code>, <code>~*</code> &ndash; POSIX regular expressions <b>(powerful)</b></li>
</ul>
<br/>

<pre><code class="language-sql line-numbers">-- LIKE (simple)
WHERE name LIKE 'A%';

-- SIMILAR TO (regex with SQL syntax)
WHERE name SIMILAR TO '(A|B)%';

-- POSIX regex (preferred for complex patterns)
WHERE name ~ '^(A|B).*';
</code></pre>
<br/>

<ul>
    <li>Prefer <code>LIKE</code> for prefix searches.</li>
    <li>Use regex for complex logic.</li>
    <li>Avoid <code>SIMILAR TO</code> unless required for SQL compliance.</li>
</ul>
<br/>
<br/>



    <li><b>Index Usage Rules</b></li>
<br/>
<ul>
    <li>B-tree indexes are used only for <u>left-anchored</u> patterns:</li>
</ul>
<pre><code class="language-sql line-numbers">-- Index used
WHERE name LIKE 'abc%';
</code></pre>
<br/>
<ul>
    <li>Not used for:</li>
</ul>
<pre><code class="language-sql line-numbers">WHERE name LIKE '%abc';
WHERE name LIKE '%abc%';
WHERE name LIKE '_bc%';             -- cannot use index
WHERE LOWER(name) LIKE 'abc%';      -- no index unless functional index exists
</code></pre>
<br/>
<ul>
    <li><code>ILIKE</code> <u>never uses B-tree indexes</u> unless <code>pg_trgm</code> is installed.</li>
</ul>
<br/>
<br/>



    <li><b>Using pg_trgm for Fast LIKE Searches</b></li>
<br/>
<ul>
    <li>Install extension:</li>
</ul>
<pre><code class="language-sql line-numbers">CREATE EXTENSION IF NOT EXISTS pg_trgm;
</code></pre>
<br/>
<ul>
    <li>Add trigram index:</li>
</ul>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_name_trgm
ON users USING gin (name gin_trgm_ops);
</code></pre>
<br/>
<ul>
    <li>This speeds up:</li>
    <ul>
        <li><code>LIKE '%pattern%'</code></li>
        <li><code>ILIKE '%pattern%'</code></li>
        <li>Regex operations</li>
    </ul>
</ul>
<br/>
<br/>



    <li><b>Performance Considerations</b></li>
<br/>
<ul>
    <li><code>LIKE 'abc%'</code> is very fast with indexes.</li>
    <li><code>LIKE '%abc'</code> is slow, because it requires full scan.</li>
    <li>Always avoid:
        <ul>
            <li>Leading wildcards</li>
            <li>Patterns that require scanning all rows</li>
            <li>Wrapping columns with <code>LOWER()</code> unless using functional index</li>
        </ul>
    </li>
    <br/>
    <li>Use <code>pg_trgm</code> for large text search workloads.</li>
</ul>
<br/>
<br/>



    <li><b>Practical Examples</b></li>
<br/>

<pre><code class="language-sql line-numbers">-- Emails from Gmail
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- Names containing digits
SELECT * FROM users WHERE name LIKE '%_%' ESCAPE '\\';

-- Case-insensitive search
SELECT * FROM cities WHERE name ILIKE 'ber%';

-- Titles that start with a letter Aâ€“F
SELECT * FROM books WHERE title ~ '^[A-F]';
</code></pre>
<br/>
<br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-extensions">PostgreSQL Extensions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A PostgreSQL <u>extension</u> is a package that adds extra functionality to the database server.</li>
        <br/>
        <li>Extensions can contain:
            <ul>
                <li>SQL functions</li>
                <li>Data types</li>
                <li>Indexes and operator classes</li>
                <li>Views, triggers, cast definitions, etc.</li>
            </ul>
        </li>
        <br/>
        <li>They are managed with commands like <code>CREATE EXTENSION</code>, <code>ALTER EXTENSION</code>, and <code>DROP EXTENSION</code>.</li>
        <br/>
        <li>Typical examples: <code>pg_trgm</code>, <code>hstore</code>, <code>uuid-ossp</code>, <code>citext</code>, <code>postgres_fdw</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concept: Installed vs. Available Extensions</b></li>
    <br/>
    <ul>
        <li><u>Available</u> extension: its files are present on the server (in the PostgreSQL installation), but not yet enabled in the current database.</li>
        <br/>
        <li><u>Installed</u> (or "created") extension: registered in the current database via <code>CREATE EXTENSION</code>.</li>
        <br/>
        <li>You can list all available extension packages with:</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT * FROM pg_available_extensions;
</code></pre>
    <br/>
    <ul>
        <li>You can list all extensions currently installed in your database with:</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT * FROM pg_extension;
</code></pre>
    <br/>
    <br/>


    <li><b>Creating an Extension (Enabling It in a Database)</b></li>
<pre><code class="language-sql line-numbers">CREATE EXTENSION pg_trgm;
</code></pre>
    <br/>
    <ul>
        <li>This makes the <code>pg_trgm</code> functionality available in the current database.</li>
        <br/>
        <li>Extensions are installed <u>per database</u>, not globally, so if you have multiple databases, you must run <code>CREATE EXTENSION</code> in each database where you need it.</li>
        <br/>
        <li>You can specify a schema to hold the extension objects:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE EXTENSION pg_trgm WITH SCHEMA extensions;
</code></pre>
    <br/>
    <ul>
        <li>This is useful to keep extension objects separated from your own application schema.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Listing Extensions and Their Versions</b></li>
<pre><code class="language-sql line-numbers">-- Installed in current database
SELECT
    extname,
    extversion,
    extnamespace::regnamespace AS schema_name
FROM
    pg_extension
ORDER BY
    extname;

-- Available (but maybe not installed)
SELECT
    name,
    default_version,
    installed_version
FROM
    pg_available_extensions
ORDER BY
    name;
</code></pre>
    <br/>
    <ul>
        <li><code>default_version</code> is the version shipped with the server.</li>
        <li><code>installed_version</code> is NULL for extensions not yet created in the database.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extension Files and Control Files (High-Level)</b></li>
    <br/>
    <ul>
        <li>Each extension is described by:
            <ul>
                <li>A <u>.control</u> file &ndash; metadata: name, default version, required settings.</li>
                <li>One or more <u>.sql</u> files &ndash; contain the SQL commands to create the extension objects.</li>
            </ul>
        </li>
        <br/>
        <li>These files live in the PostgreSQL installation directories (typically <code>share/extension</code>).</li>
        <br/>
        <li>Database users normally do <u>not</u> touch these files directly, they just use <code>CREATE EXTENSION</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extension Schemas and search_path</b></li>
    <br/>
    <ul>
        <li>When you run <code>CREATE EXTENSION</code> without <code>WITH SCHEMA</code>, the extension is created in the first schema on your <code>search_path</code> that is not a system schema.</li>
        <br/>
        <li>To avoid cluttering <code>public</code>, many teams create a dedicated schema:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE SCHEMA IF NOT EXISTS extensions;

CREATE EXTENSION IF NOT EXISTS hstore
    WITH SCHEMA extensions;
</code></pre>
    <br/>
    <ul>
        <li>When calling extension functions, you can:
            <ul>
                <li>Add the extension schema to <code>search_path</code>, or</li>
                <li>Use fully qualified names, e.g. <code>extensions.some_extension_function(...)</code>.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Updating Extensions (ALTER EXTENSION)</b></li>
<pre><code class="language-sql line-numbers">-- Update a single extension to latest version
ALTER EXTENSION pg_trgm UPDATE;

-- Update to a specific version (if supported)
ALTER EXTENSION some_ext UPDATE TO '1.2';
</code></pre>
    <br/>
    <br/>


    <li><b>Removing Extensions (DROP EXTENSION)</b></li>
<pre><code class="language-sql line-numbers">DROP EXTENSION pg_trgm;
</code></pre>
    <br/>
    <ul>
        <li>This removes all objects created by the extension from the current database.</li>
        <br/>
        <li>If you have objects that depend on the extension (e.g., indexes using <code>gin_trgm_ops</code>), you might see dependency errors.</li>
        <br/>
        <li>You can use <code>CASCADE</code> (careful!) to drop dependent objects:</li>
    </ul>
<pre><code class="language-sql line-numbers">DROP EXTENSION pg_trgm CASCADE;
</code></pre>
    <br/>
    <ul>
        <li>Always verify what will be dropped before using <code>CASCADE</code> in production.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Common Built-In Extensions</b></li>
    <br/>
    <ul>
        <li><code>pg_trgm</code> &ndash; trigram indexes and similarity search, often used with <code>LIKE</code> / <code>ILIKE</code>.</li>
        <br/>
        <li><code>hstore</code> &ndash; key-value text storage in a single column (before JSONB was popular).</li>
        <br/>
        <li><code>uuid-ossp</code> &ndash; functions to generate UUIDs (<code>uuid_generate_v4()</code>, etc.).</li>
        <br/>
        <li><code>citext</code> &ndash; case-insensitive text type (e.g., for case-insensitive emails).</li>
        <br/>
        <li><code>btree_gin</code>, <code>btree_gist</code> &ndash; extra index operator classes.</li>
        <br/>
        <li><code>postgres_fdw</code> &ndash; foreign data wrapper for connecting to other PostgreSQL servers.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extensions Requiring shared_preload_libraries</b></li>
    <br/>
    <ul>
        <li>Some extensions hook deeper into the server and must be loaded at startup via <code>shared_preload_libraries</code> in <code>postgresql.conf</code>.</li>
        <br/>
        <li>Examples:
            <ul>
                <li><code>pg_stat_statements</code> (query statistics)</li>
                <li>Some connection poolers, tracking or sampling modules</li>
            </ul>
        </li>
        <br/>
        <li>Typical flow:</li>
    </ul>
<pre><code class="language-sql line-numbers">-- In postgresql.conf (example)
shared_preload_libraries = 'pg_stat_statements'

-- After server restart, in each database where you want it:
CREATE EXTENSION pg_stat_statements;
</code></pre>
    <br/>
    <ul>
        <li>You need file-level access to the server to change <code>postgresql.conf</code>, this is usually a DBA or admin task.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Permissions and Security</b></li>
    <br/>
    <ul>
        <li>Creating or dropping an extension requires <u>superuser</u> or <u>database owner</u> privileges (depending on configuration).</li>
        <br/>
        <li>Extensions can:
            <ul>
                <li>Run server-side C code</li>
                <li>Access files and system resources</li>
            </ul>
            so installing untrusted third-party extensions can be a security risk.</li>
        <br/>
        <li>Only install extensions that come from trusted sources or your platform provider.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extensions and Backups</b></li>
    <br/>
    <ul>
        <li>When you use <code>pg_dump</code> to export a database with extensions, the dump does <b>not</b> include the extension SQL source code.</li>
        <br/>
        <li>Instead, the dump contains a <code>CREATE EXTENSION</code> command, assuming the extension is available on the target server.</li>
        <br/>
        <li>Therefore:
            <ul>
                <li>Make sure the same extensions (and versions) are installed on the restore server.</li>
                <li>Otherwise, restoring the dump may fail.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Dependencies Between Extensions and Objects</b></li>
    <br/>
    <ul>
        <li>To see which objects belong to an extension:</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT
    objid::regclass,
    classid::regclass
FROM pg_depend d
JOIN pg_extension e ON d.refobjid = e.oid
WHERE e.extname = 'pg_trgm';
</code></pre>
    <br/>
    <ul>
        <li>This is advanced usage, mostly for DBAs who need to audit dependencies.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Practical Workflow Example</b></li>
    <br/>
    <ul>
        <li>Example: enabling <code>pg_trgm</code> for fuzzy search on <code>users(name)</code>:</li>
    </ul>
<pre><code class="language-sql line-numbers">-- 1. Create a dedicated schema for extensions (optional)
CREATE SCHEMA IF NOT EXISTS extensions;

-- 2. Install the pg_trgm extension into that schema
CREATE EXTENSION IF NOT EXISTS pg_trgm
WITH SCHEMA extensions;

-- 3. Create a trigram index for LIKE / ILIKE searches
CREATE INDEX idx_users_name_trgm
ON users
USING gin (name extensions.gin_trgm_ops);

-- 4. Now queries like this become much faster:
SELECT *
FROM users
WHERE name ILIKE '%wang%';
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-create-extensions">Creating Your Own PostgreSQL Extensions</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>You can create your own PostgreSQL extensions to package functions, types, operators, and other database objects into a reusable module.</li>
        <br/>
        <li>Extensions can be:
            <ul>
                <li><b>SQL-only</b> &ndash; written purely in SQL and procedural languages (PL/pgSQL, PL/Perl, etc.).</li>
                <li><b>C-based</b> &ndash; contain compiled C code in a shared library (<code>.so</code>, <code>.dll</code>).</li>
            </ul>
        </li>
        <br/>
        <li>Once packaged as an extension, users only need <code>CREATE EXTENSION my_ext;</code> instead of running long SQL scripts manually.</li>
    </ul>
    <br/>
    <br/>


    <li><b>High-Level Steps</b></li>
    <br/>
    <ul>
        <li>Create a <u>control file</u> (<code>my_ext.control</code>) describing the extension.</li>
        <br/>
        <li>Create one or more <u>SQL script files</u> (<code>my_ext--1.0.sql</code>, <code>my_ext--1.0--1.1.sql</code>, etc.).</li>
        <br/>
        <li>(Optional) Build a <u>shared library</u> in C (<code>my_ext.so</code>) if you need low-level functions.</li>
        <br/>
        <li>Install these files into PostgreSQL's <code>share/extension</code> (and <code>lib</code> for C code).</li>
        <br/>
        <li>Enable the extension in a database using <code>CREATE EXTENSION</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Directory Locations</b></li>
    <br/>
    <ul>
        <li>To find where extension files should be placed, use <code>pg_config</code> on the server:</li>
    </ul>
<pre><code class="language-bash line-numbers">pg_config --sharedir   # usually contains share/extension
pg_config --pkglibdir  # usually contains shared libraries (.so/.dll)
</code></pre>
    <br/>
    <ul>
        <li><u>SQL scripts</u> and <u>.control</u> files go into <code>$sharedir/extension</code>.</li>
        <br/>
        <li><u>Shared libraries</u> go into <code>$pkglibdir</code>.</li>
        <br/>
        <li>On managed services (cloud providers), you usually cannot install your own C extensions, but you can still create SQL-only extensions if they allow it.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating a Simple SQL-only Extension: Example</b></li>
    <br/>
    <ul>
        <li>Suppose we want an extension <code>hello_ext</code> that adds a function <code>hello(name)</code>.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- File: hello_ext--1.0.sql
CREATE OR REPLACE FUNCTION hello(name text)
RETURNS text
LANGUAGE sql
AS
$$
    SELECT 'Hello, ' || name || '!'::text;
$$;
</code></pre>
    <br/>
    <ul>
        <li>This SQL script defines the objects that will be created when the extension is installed.</li>
        <br/>
        <li>The file name must follow the pattern <code>&lt;extname&gt;--&lt;version&gt;.sql</code>, here <code>hello_ext--1.0.sql</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Writing the Control File (.control)</b></li>
    <br/>
    <ul>
        <li>Create a file named <code>hello_ext.control</code> in <code>share/extension</code>:</li>
    </ul>
<pre><code class="language-sql line-numbers"># File: hello_ext.control
comment = 'Simple hello extension example'
default_version = '1.0'
relocatable = true
schema = public
requires = ''
</code></pre>
    <br/>
    <ul>
        <li><b>Fields:</b></li>
        <ul>
            <li><code>comment</code> &ndash; short description of the extension.</li>
            <li><code>default_version</code> &ndash; version used when you run <code>CREATE EXTENSION hello_ext;</code>.</li>
            <li><code>relocatable</code> &ndash; if <code>true</code>, the extension can be moved to another schema using <code>ALTER EXTENSION ... SET SCHEMA</code>.</li>
            <li><code>schema</code> &ndash; default schema where objects will be installed (often <code>public</code>).</li>
            <li><code>requires</code> &ndash; comma-separated list of other extensions that must be installed first (or empty string).</li>
        </ul>
    </ul>
    <br/>
    <br/>


    <li><b>Installing the Files</b></li>
    <br/>
    <ul>
        <li>Copy the files to the appropriate directory on the server:</li>
    </ul>
<pre><code class="language-bash line-numbers">cp hello_ext.control   $(pg_config --sharedir)/extension/
cp hello_ext--1.0.sql  $(pg_config --sharedir)/extension/
</code></pre>
    <br/>
    <ul>
        <li>After this, PostgreSQL knows that an extension named <code>hello_ext</code> is available.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating the Extension in a Database</b></li>
    <br/>
    <ul>
        <li>Connect to the database where you want to use the extension:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE EXTENSION hello_ext;
</code></pre>
    <br/>
    <ul>
        <li>This runs <code>hello_ext--1.0.sql</code> and registers the extension in <code>pg_extension</code>.</li>
    </ul>
<pre><code class="language-sql line-numbers">SELECT hello('Hwangfucius');
-- Result: 'Hello, Hwangfucius!'
</code></pre>
    <br/>
    <ul>
        <li>If you want the extension objects in a specific schema:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE SCHEMA IF NOT EXISTS extensions;
CREATE EXTENSION hello_ext WITH SCHEMA extensions;
</code></pre>
    <br/>
    <br/>


    <li><b>Versioning and Upgrade Scripts</b></li>
    <br/>
    <ul>
        <li>Suppose we want to add a new function and bump the extension to version <code>1.1</code>.</li>
        <br/>
        <li>Steps:</li>
        <ul>
            <li>Update the control file's <code>default_version</code> to <code>'1.1'</code>.</li>
            <li>Add a new SQL script <code>hello_ext--1.0--1.1.sql</code> with the migration.</li>
        </ul>
    </ul>
<pre><code class="language-sql line-numbers"># File: hello_ext.control (updated)
comment = 'Simple hello extension example'
default_version = '1.1'
relocatable = true
schema = public
requires = ''
</code></pre>
<pre><code class="language-sql line-numbers">-- File: hello_ext--1.0--1.1.sql
-- Migration from 1.0 to 1.1

CREATE OR REPLACE FUNCTION hello_upper(name text)
RETURNS text
LANGUAGE sql
AS
$$
    SELECT upper(hello(name));
$$;
</code></pre>
    <br/>
    <ul>
        <li>To upgrade an existing installation:</li>
    </ul>
<pre><code class="language-sql line-numbers">ALTER EXTENSION hello_ext UPDATE TO '1.1';
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL runs <code>hello_ext--1.0--1.1.sql</code> automatically when upgrading from version 1.0.</li>
        <br/>
        <li>You can chain multiple upgrade scripts:
            <ul>
                <li><code>hello_ext--1.0--1.1.sql</code></li>
                <li><code>hello_ext--1.1--1.2.sql</code></li>
                <li>...</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>C-based Extensions (Overview Only)</b></li>
    <br/>
    <ul>
        <li>For performance-sensitive logic or low-level features, you can write C functions and expose them as an extension.</li>
        <br/>
        <li>Typical structure:</li>
    </ul>
<pre><code class="language-bash line-numbers">hello_ext/
  hello_ext.c
  hello_ext.control
  hello_ext--1.0.sql
  Makefile
</code></pre>
    <br/>
    <ul>
        <li>The C file defines server functions using PostgreSQL's C API:</li>
    </ul>
<pre><code class="language-c line-numbers">/* hello_ext.c (simplified example) */
#include "postgres.h"
#include "fmgr.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(hello_c);

Datum
hello_c(PG_FUNCTION_ARGS)
{
    text *name = PG_GETARG_TEXT_PP(0);
    text *prefix = cstring_to_text("Hello, ");
    text *result = catenate_text(prefix, name); /* pseudo helper */
    PG_RETURN_TEXT_P(result);
}
</code></pre>
    <br/>
    <ul>
        <li>The SQL file registers the function:</li>
    </ul>
<pre><code class="language-sql line-numbers">-- hello_ext--1.0.sql
CREATE FUNCTION hello_c(name text)
RETURNS text
AS 'hello_ext', 'hello_c'
LANGUAGE c
STRICT;
</code></pre>
    <br/>
    <ul>
        <li>You build and install the module using <code>make</code> and <code>make install</code> (with PostgreSQL's extension build system).</li>
        <br/>
        <li>This requires PostgreSQL server headers and build tools, and is typically done by DBAs or server admins.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Relocatable vs Non-Relocatable Extensions</b></li>
    <br/>
    <ul>
        <li><b>Relocatable</b> extensions (<code>relocatable = true</code>) can be moved to a different schema:</li>
    </ul>
<pre><code class="language-sql line-numbers">ALTER EXTENSION hello_ext SET SCHEMA extensions;
</code></pre>
    <br/>
    <ul>
        <li><b>Non-relocatable</b> extensions set <code>relocatable = false</code> and often specify a fixed schema using the <code>schema</code> parameter.</li>
        <br/>
        <li>Non-relocatable is safer if your SQL scripts include hard-coded schema-qualified names.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dependencies Between Extensions</b></li>
    <br/>
    <ul>
        <li>Use <code>requires</code> in the control file to depend on other extensions:</li>
    </ul>
<pre><code class="language-sql line-numbers"># File: my_ext.control
comment = 'My extension using pg_trgm'
default_version = '1.0'
relocatable = true
requires = 'pg_trgm'
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL ensures the required extensions are installed first.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Testing and Debugging Your Extension</b></li>
    <br/>
    <ul>
        <li>Use a dedicated test database:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE DATABASE ext_test;
\c ext_test

CREATE EXTENSION hello_ext;
SELECT hello('Test');
</code></pre>
    <br/>
    <ul>
        <li>If something goes wrong, you can:
            <ul>
                <li>Drop and recreate the test database.</li>
                <li>Adjust your SQL or control files, reinstall, and test again.</li>
            </ul>
        </li>
        <br/>
        <li>For C-based extensions, server logs are essential for debugging crashes or errors.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-regex">Regular Expressions in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Regex in PostgreSQL is much more powerful than <code>LIKE</code> or <code>SIMILAR TO</code>, supporting character classes, anchors, quantifiers, alternation, and grouping.</li>
        <br/>
        <li>PostgreSQL uses <u>advanced (extended) POSIX regex</u>, which is similar to Perl-style regex but not identical.</li>
        <br/>
        <li>Regex operators can be used in <code>WHERE</code>, <code>SELECT</code>, <code>CHECK</code> constraints, and more.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Regex Matching Operators</b></li>
    <br/>
    <table>
        <tr><th>Operator</th><th>Description</th><th>Case Sensitivity</th></tr>
        <tr><td><code>~</code></td><td>String matches regular expression</td><td>Sensitive</td></tr>
        <tr><td><code>~*</code></td><td>String matches regular expression</td><td>Insensitive</td></tr>
        <tr><td><code>!~</code></td><td>String does NOT match regular expression</td><td>Sensitive</td></tr>
        <tr><td><code>!~*</code></td><td>String does NOT match regular expression</td><td>Insensitive</td></tr>
    </table>

<pre><code class="language-sql line-numbers">SELECT 'Hello123' ~ '^[A-Za-z]+$';   -- FALSE
SELECT 'Hello'    ~ '^[A-Za-z]+$';   -- TRUE
SELECT 'hello'    ~* 'HELLO';        -- TRUE (case-insensitive)
</code></pre>
<br/>
<br/>



    <li><b>Basic Regex Syntax</b></li>
    <br/>
    <ul>
        <li><code>.</code> â€“ any single character</li>
        <li><code>*</code> â€“ zero or more occurrences</li>
        <li><code>+</code> â€“ one or more occurrences</li>
        <li><code>?</code> â€“ zero or one</li>
        <li><code>|</code> â€“ alternation</li>
        <li><code>()</code> â€“ grouping</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'abc123' ~ '^[a-z]+[0-9]+$';  -- TRUE
SELECT 'cat'    ~ 'c(at|ut)';         -- TRUE
SELECT 'cut'    ~ 'c(at|ut)';         -- TRUE
</code></pre>
<br/>
<br/>



    <li><b>Character Classes</b></li>
    <br/>
    <ul>
        <li><code>[abc]</code> â€“ match 'a' or 'b' or 'c'</li>
        <li><code>[^abc]</code> â€“ any character except a/b/c</li>
        <li><code>[0-9]</code> â€“ any digit</li>
        <li><code>[A-Za-z]</code> â€“ any letter</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT '5'   ~ '^[0-9]$';       -- TRUE
SELECT 'g'   ~ '^[^0-9]$';      -- TRUE
SELECT 'Ã¼'   ~ '^[A-Za-z]$';    -- FALSE (ASCII only!)
</code></pre>

<br/>
<ul>
    <li><b>Important:</b> POSIX classes with ASCII ranges do not match non-ASCII letters.</li>
</ul>
<br/>
<br/>



    <li><b>POSIX Character Classes (Locale-Aware)</b></li>
    <br/>
    <table>
        <tr><th>Class</th><th>Description</th></tr>
        <tr><td><code>[:alpha:]</code></td><td>Letters (locale aware)</td></tr>
        <tr><td><code>[:digit:]</code></td><td>Digits</td></tr>
        <tr><td><code>[:alnum:]</code></td><td>Letters and digits</td></tr>
        <tr><td><code>[:space:]</code></td><td>Whitespace</td></tr>
        <tr><td><code>[:lower:]</code></td><td>Lowercase letters</td></tr>
        <tr><td><code>[:upper:]</code></td><td>Uppercase letters</td></tr>
    </table>

<pre><code class="language-sql line-numbers">SELECT 'Ã¤' ~ '^[[:alpha:]]+$';   -- TRUE (depends on locale)
</code></pre>

<br/>
<ul>
    <li>POSIX classes are much more Unicode-friendly than <code>[A-Za-z]</code>.</li>
</ul>
<br/>
<br/>



    <li><b>Anchors</b></li>
    <br/>
    <ul>
        <li><code>^</code> â€“ start of string</li>
        <li><code>$</code> â€“ end of string</li>
        <li><code>\b</code> â€“ word boundary (POSIX subset)</li>
        <li><code>\&lt;</code> â€“ start of word</li>
        <li><code>\&gt;</code> â€“ end of word</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'postgresql' ~ '^post';     -- TRUE
SELECT 'postgresql' ~ 'sql$';      -- TRUE
SELECT 'cat dog'    ~ '\bdog\b';   -- TRUE
</code></pre>
<br/>
<br/>



    <li><b>Quantifiers</b></li>
    <br/>
    <ul>
        <li><code>a*</code> â€“ zero or more</li>
        <li><code>a+</code> â€“ one or more</li>
        <li><code>a?</code> â€“ zero or one</li>
        <li><code>a{3}</code> â€“ exactly 3</li>
        <li><code>a{2,5}</code> â€“ between 2 and 5</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'hellooo' ~ 'o{2,}';   -- TRUE
SELECT 'ho'      ~ 'o{2,}';   -- FALSE
</code></pre>
<br/>
<br/>



    <li><b>Grouping and Alternation</b></li>
    <br/>
<pre><code class="language-sql line-numbers">SELECT 'gray'  ~ 'gr(a|e)y';  -- TRUE
SELECT 'grey'  ~ 'gr(a|e)y';  -- TRUE
</code></pre>
<br/>
<ul>
    <li>Parentheses group expressions.</li>
    <li><code>|</code> allows alternatives.</li>
</ul>
<br/>
<br/>



    <li><b>Using Regex in WHERE Clauses</b></li>
    <br/>
<pre><code class="language-sql line-numbers">SELECT *
FROM users
WHERE email ~ '^[a-z0-9._%+-]+@example\.com$';
</code></pre>

<br/>
<ul>
    <li>Use <code>~*</code> for case-insensitive search:</li>
</ul>

<pre><code class="language-sql line-numbers">WHERE name ~* '^(junzhe|wang)$';
</code></pre>

<br/>
<br/>



    <li><b>Regex in SELECT (search inside strings)</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT
    regexp_matches('abc123xyz', '[0-9]+');
</code></pre>

<br/>
<ul>
    <li>Returns matching substring(s) as an array.</li>
</ul>

<br/>
<br/>



    <li><b>Regex Functions and Operators</b></li>
    <br/>
    <table>
        <tr><th>Function</th><th>Description</th></tr>
        <tr><td><code>regexp_matches()</code></td><td>Return all matches as text arrays</td></tr>
        <tr><td><code>regexp_replace()</code></td><td>Find &amp; replace using regex</td></tr>
        <tr><td><code>regexp_split_to_array()</code></td><td>Split text using regex</td></tr>
        <tr><td><code>regexp_split_to_table()</code></td><td>Split into table rows</td></tr>
    </table>

<pre><code class="language-sql line-numbers">SELECT regexp_replace('abc123', '[0-9]', '#', 'g');
-- Result: 'abc###'
</code></pre>

<br/>
<br/>



    <li><b>Escaping Characters in Regex</b></li>
    <br/>
    <ul>
        <li>Inside regex, metacharacters like <code>.</code>, <code>[ ]</code>, <code>+</code>, <code>*</code>, <code>?</code>, <code>|</code> must be escaped with <code>\</code>.</li>
        <br/>
        <li>Inside SQL strings, <code>\</code> itself may need escaping depending on settings!</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT '3+4' ~ '3\+4';     -- match literal +
SELECT 'a.b' ~ 'a\.b';     -- match literal dot
</code></pre>

<br/>
<ul>
    <li>If <code>standard_conforming_strings = off</code>, you must double the backslashes.</li>
</ul>
<br/>
<br/>



    <li><b>Dollar-Quoted Strings to Avoid Escaping</b></li>
    <br/>
    <ul>
        <li>To avoid complex escaping issues, use dollar-quoted literals:</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT '3+4' ~ $re$3\+4$re$;
</code></pre>

<br/>
<ul>
    <li>This is the preferred method for regex-heavy code.</li>
</ul>
<br/>
<br/>



    <li><b>Extracting Multiple Matches</b></li>
    <br/>
<pre><code class="language-sql line-numbers">SELECT regexp_matches(
    'a1 b2 c3',
    '([a-z])([0-9])',
    'g'
);
</code></pre>

<br/>
<ul>
    <li>Flag <code>'g'</code> returns all match groups.</li>
</ul>
<br/>
<br/>



    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>Regex is CPU-intensive.</li>
        <br/>
        <li><b>Regex cannot use B-tree indexes</b> (except for fixed-prefix anchors <code>^text</code>).</li>
        <br/>
        <li>For fast substring / fuzzy search, use <code>pg_trgm</code> extension:</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE EXTENSION pg_trgm;

CREATE INDEX idx_users_name_trgm
    ON users USING gin (name gin_trgm_ops);

SELECT * FROM users WHERE name ~ 'wang';
</code></pre>

<br/>
<ul>
    <li>Trigram indexes accelerate many regex operations automatically.</li>
</ul>
<br/>
<br/>



    <li><b>Regex vs LIKE vs SIMILAR TO</b></li>
    <br/>
    <table>
        <tr><th>Feature</th><th>LIKE</th><th>SIMILAR TO</th><th>Regex (~)</th></tr>
        <tr><td>Wildcard power</td><td>Low</td><td>Medium</td><td>High</td></tr>
        <tr><td>Performs complex validation</td><td>No</td><td>Somewhat</td><td>Yes</td></tr>
        <tr><td>Index support</td><td>Only prefix</td><td>No</td><td>No (except pg_trgm)</td></tr>
        <tr><td>Syntax complexity</td><td>Very easy</td><td>Medium</td><td>High</td></tr>
    </table>

<br/>
<ul>
    <li>Regex is the most powerful but most expensive.</li>
</ul>
<br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-similar-to">The SIMILAR TO Operator in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>SIMILAR TO</code> is a SQL-standard pattern matching operator that combines aspects of <code>LIKE</code> and regular expressions.</li>
        <br/>
        <li>It is more powerful than <code>LIKE</code> but less powerful (and less flexible) than PostgreSQL's regex operators (<code>~</code>, <code>~*</code>).</li>
        <br/>
        <li><code>SIMILAR TO</code> uses a <u>regex-like syntax</u> but still follows SQL-standard rules, not POSIX rules.</li>
        <br/>
        <li>It is rarely used in real-world PostgreSQL development because regex operators are more intuitive and consistent.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">value SIMILAR TO pattern
value NOT SIMILAR TO pattern
</code></pre>

<br/>
<ul>
    <li>Returns TRUE if <code>value</code> matches the SQL-standard regex-like <code>pattern</code>.</li>
    <li>Returns FALSE otherwise.</li>
    <li>Returns NULL if either operand is NULL.</li>
</ul>
<br/>
<br/>



    <li><b>Fundamental Rules of SIMILAR TO</b></li>
    <br/>
    <ul>
        <li><code>%</code> â€“ matches zero or more characters (like <code>LIKE</code>).</li>
        <li><code>_</code> â€“ matches exactly one character.</li>
        <li><code>|</code> â€“ regex alternation operator.</li>
        <li><code>()</code> â€“ grouping for alternation.</li>
        <li><code>[]</code> â€“ character classes.</li>
        <li>ESCAPE clause can be used to escape metacharacters.</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'cat' SIMILAR TO '(cat|dog)';   -- TRUE
SELECT 'dog' SIMILAR TO '(cat|dog)';   -- TRUE
SELECT 'frog' SIMILAR TO '(cat|dog)';  -- FALSE
</code></pre>
<br/>
<br/>



    <li><b>SIMILAR TO vs LIKE</b></li>
    <br/>
    <table>
        <tr><th>Feature</th><th>LIKE</th><th>SIMILAR TO</th></tr>
        <tr><td>Alternation</td><td>No</td><td>Yes (<code>|</code>)</td></tr>
        <tr><td>Grouping</td><td>No</td><td>Yes</td></tr>
        <tr><td>Character classes</td><td>No</td><td>Yes</td></tr>
        <tr><td>Complex validation</td><td>No</td><td>Possible</td></tr>
        <tr><td>Case sensitivity</td><td>Sensitive</td><td>Sensitive only (no ILIKE equivalent)</td></tr>
    </table>

<br/>
<ul>
    <li>In short: <code>SIMILAR TO</code> = <code>LIKE</code> + basic regex.</li>
</ul>
<br/>
<br/>



    <li><b>Alternation (|) and Grouping</b></li>
    <br/>
<pre><code class="language-sql line-numbers">SELECT 'apple'  SIMILAR TO '(apple|banana|cherry)';  -- TRUE
SELECT 'guava'  SIMILAR TO '(apple|banana|cherry)';  -- FALSE
</code></pre>

<br/>
<ul>
    <li>Grouping with parentheses is required for alternation.</li>
</ul>
<br/>
<br/>



    <li><b>Character Classes</b></li>
    <br/>
<pre><code class="language-sql line-numbers">SELECT 'a' SIMILAR TO '[abc]';     -- TRUE
SELECT 'd' SIMILAR TO '[abc]';     -- FALSE
SELECT '5' SIMILAR TO '[0-9]';     -- TRUE
</code></pre>
<br/>
<ul>
    <li>Similar to regex classes, but with SQL-standard semantics.</li>
</ul>
<br/>
<br/>



    <li><b>Wildcard Behavior</b></li>
    <br/>
    <ul>
        <li><code>%</code> = zero or more characters.</li>
        <li><code>_</code> = exactly one character.</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'hello' SIMILAR TO 'h%';    -- TRUE
SELECT 'hello' SIMILAR TO 'h_llo'; -- TRUE
</code></pre>
<br/>
<br/>



    <li><b>Anchoring Rules (Implicit Anchors)</b></li>
    <br/>
    <ul>
        <li>Unlike POSIX regex, <code>SIMILAR TO</code> patterns act like the entire string is implicitly wrapped with <code>^ ... $</code>.</li>
        <br/>
        <li>Meaning: <b>SIMILAR TO always matches the entire string</b>. Partial matches are not allowed unless you use <code>%</code>.</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'hello' SIMILAR TO 'ell';    -- FALSE (must match whole string)
SELECT 'hello' SIMILAR TO '%ell%';  -- TRUE
</code></pre>
<br/>
<br/>



    <li><b>Complex Validation Example</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT '2024-10-15' SIMILAR TO '[0-9]{4}-[0-9]{2}-[0-9]{2}';  -- TRUE
SELECT '2024/10/15' SIMILAR TO '[0-9]{4}-[0-9]{2}-[0-9]{2}';  -- FALSE
</code></pre>

<br/>
<ul>
    <li><code>SIMILAR TO</code> supports repetition with curly braces too.</li>
</ul>
<br/>
<br/>



    <li><b>Using SIMILAR TO With NOT</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT 'abc' NOT SIMILAR TO '[0-9]+';   -- TRUE
</code></pre>

<br/>
<ul>
    <li>Behaves similarly to <code>NOT LIKE</code> and <code>!~</code>.</li>
</ul>
<br/>
<br/>



    <li><b>Escaping Special Characters</b></li>
    <br/>

<ul>
    <li>Special characters that require escaping:
        <ul>
            <li><code>%</code>, <code>_</code> (as in LIKE)</li>
            <li><code>( )</code></li>
            <li><code>|</code></li>
            <li><code>[ ]</code></li>
            <li><code>{ }</code></li>
        </ul>
    </li>
</ul>

<pre><code class="language-sql line-numbers">SELECT 'a+b' SIMILAR TO 'a\+b';  -- match literal +
</code></pre>

<br/>
<ul>
    <li>You can specify a custom escape character:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT 'a+b' SIMILAR TO 'a#+' ESCAPE '#';
</code></pre>
<br/>
<br/>



    <li><b>SIMILAR TO is Fully Anchored</b></li>
    <br/>
    <ul>
        <li>Unlike regular expressions, SIMILAR TO matches the <b>entire</b> string unless <code>%</code> or <code>_</code> is used.</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'abc'   SIMILAR TO 'a.*';    -- FALSE
SELECT 'abc'   SIMILAR TO 'a%';     -- TRUE
</code></pre>

<br/>
<ul>
    <li>This difference surprises many users!</li>
</ul>
<br/>
<br/>



    <li><b>Combining Conditions</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT *
FROM logs
WHERE message SIMILAR TO '%(ERROR|WARN|FATAL)%';
</code></pre>

<br/>
<ul>
    <li>Good for basic multi-pattern filtering.</li>
</ul>
<br/>
<br/>



    <li><b>SIMILAR TO vs Regex Operators (~)</b></li>
    <br/>
    <table>
        <tr><th>Feature</th><th>SIMILAR TO</th><th>Regex (~)</th></tr>
        <tr><td>Power level</td><td>Medium</td><td>High</td></tr>
        <tr><td>Performance</td><td>Medium</td><td>Lower (heavier)</td></tr>
        <tr><td>Anchored matching</td><td>Always full string</td><td>Optional</td></tr>
        <tr><td>Unicode support</td><td>Limited</td><td>Full POSIX regex support</td></tr>
        <tr><td>Syntax</td><td>SQL-standard</td><td>POSIX regex syntax</td></tr>
        <tr><td>Alternation</td><td>Yes</td><td>Yes</td></tr>
        <tr><td>Complex patterns</td><td>Limited</td><td>Very strong</td></tr>
    </table>

<br/>
<ul>
    <li>Regex (<code>~</code>) is almost always preferred for non-trivial pattern matching.</li>
</ul>
<br/>
<br/>



    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li><code>SIMILAR TO</code> does <b>not</b> use indexes unless the pattern starts with a fixed prefix.</li>
        <br/>
        <li>Like regex and LIKE with wildcards, it can be slow on large text columns.</li>
        <br/>
        <li>To optimize substring search, use <code>pg_trgm</code>:</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE EXTENSION pg_trgm;

CREATE INDEX idx_logs_msg_trgm
ON logs USING gin (message gin_trgm_ops);

SELECT * FROM logs
WHERE message SIMILAR TO '%fail%';
</code></pre>

<br/>
<ul>
    <li>Trigram indexes dramatically improve performance.</li>
</ul>
<br/>
<br/>



    <li><b>Practical Examples</b></li>
    <br/>

<pre><code class="language-sql line-numbers">-- Validate YYYY-MM-DD
SELECT '2024-12-31' SIMILAR TO '[0-9]{4}-[0-9]{2}-[0-9]{2}';

-- Match emails ending in .com or .net
SELECT 'test@example.com' SIMILAR TO '%@(.*)\.(com|net)';

-- Validate integer or decimal
SELECT '123.45' SIMILAR TO '[0-9]+(\.[0-9]+)?';

-- Match strings starting with Aâ€“F
SELECT 'Apple' SIMILAR TO '[A-F]%';
</code></pre>

<br/>
<ul>
    <li>Use SIMILAR TO for SQL-standard pattern matching where full regex is not required.</li>
</ul>
<br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-full-text-search">Basics on Full-Text Search (FTS) in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides a powerful, built-in <u>full-text search (FTS)</u> system for indexing and searching natural language text.</li>
        <br/>
        <li>FTS understands linguistic structures:
            <ul>
                <li>tokenization</li>
                <li>stemming</li>
                <li>stop-words</li>
                <li>ranking of results</li>
            </ul>
        </li>
        <br/>
        <li>It works with special data types such as <code>tsvector</code> and <code>tsquery</code>.</li>
        <br/>
        <li><u>FTS</u> is more advanced than <code>LIKE</code>, <code>ILIKE</code>, or regex because it understands word forms and relevance.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Core Concepts</b></li>
    <br/>
    <ul>
        <li><code>tsvector</code> â€“ preprocessed document, normalized into lexemes.</li>
        <li><code>tsquery</code> â€“ a structured query for searching <code>tsvector</code> documents.</li>
        <li><code>@@</code> â€“ match operator between <code>tsvector</code> and <code>tsquery</code>.</li>
        <li><code>@@@</code> â€“ phrase search (PostgreSQL â‰¥ 15).</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT 'a fat cat sat on a mat'::tsvector;
-- 'a' 'cat' 'fat' 'mat' 'on' 'sat'

SELECT to_tsvector('English', 'The cars are running');
-- 'car':2 'run':4
</code></pre>
<br/>
<br/>



    <li><b>tsvector: The Document</b></li>
    <br/>
    <ul>
        <li>A <code>tsvector</code> is the indexed representation of a text string.</li>
        <br/>
        <li>It contains:
            <ul>
                <li>lexemes (normalized words)</li>
                <li>positions</li>
                <li>weights (optional)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT to_tsvector('English', 'Programming program programs programmed');
-- 'programm':1,3,4,5
</code></pre>

<br/>
<ul>
    <li>PostgreSQL reduces all of these to the lexeme <code>'programm'</code> via stemming.</li>
</ul>
<br/>
<br/>



    <li><b>tsquery: The Search Expression</b></li>
    <br/>
    <ul>
        <li>A <code>tsquery</code> represents what you are searching for.</li>
        <br/>
        <li>Main operators:
            <ul>
                <li><code>&amp;</code> â€“ AND</li>
                <li><code>|</code> â€“ OR</li>
                <li><code>!</code> â€“ NOT</li>
                <li><code>&lt;-&gt;</code> â€“ phrase (word adjacency)</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT to_tsquery('english', 'cat &amp; dog');
-- 'cat' &amp; 'dog'

SELECT to_tsquery('english', 'car | truck');
-- 'car' | 'truck'
</code></pre>
<br/>
<br/>



    <li><b>Basic Searching with @@ Operator</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT
    to_tsvector('english', 'The big car crashed'),
    to_tsquery('english', 'car');
</code></pre>

<br/>
<ul>
    <li>To check if text matches a query:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT
    to_tsvector('english', 'The big car crashed')
        @@ to_tsquery('english', 'car');     -- TRUE
</code></pre>
<br/>
<br/>



    <li><b>Phrase Search (word adjacency)</b></li>
    <br/>
<pre><code class="language-sql line-numbers">SELECT to_tsquery('english', 'big &lt;-&gt; car');
</code></pre>

<ul>
    <li><code>big &lt;-&gt; car</code> means "big immediately before car".</li>
</ul>
<br/>

<pre><code class="language-sql line-numbers">SELECT to_tsvector('The big car crashed') @@
       to_tsquery('big &lt;-&gt; car');     -- TRUE
</code></pre>
<br/>
<br/>



    <li><b>Phrase Search (exact phrase) in PostgreSQL â‰¥ 15</b></li>
    <br/>
    <ul>
        <li>New phrase search operator <code>@@@</code>:</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT to_tsvector('The big red car') @@@ 'big red car';
-- TRUE
</code></pre>

<br/>
<ul>
    <li>Equivalent to a multi-word adjacency chain.</li>
</ul>
<br/>
<br/>



    <li><b>Indexing Full-Text Search</b></li>
    <br/>
    <ul>
        <li>Use a GIN index for fast text search:</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_docs_fts
ON documents
USING gin (to_tsvector('english', content));
</code></pre>

<br/>
<ul>
    <li>But then queries must repeat the same expression:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT *
FROM documents
WHERE to_tsvector('english', content) @@ to_tsquery('english', 'car');
</code></pre>
<br/>
<br/>



    <li><b>Storing tsvector in a Column</b></li>
    <br/>
    <ul>
        <li>You can store <code>tsvector</code> in a dedicated column and update it automatically:</li>
    </ul>

<pre><code class="language-sql line-numbers">ALTER TABLE documents
ADD COLUMN fts tsvector
    GENERATED ALWAYS AS (to_tsvector('english', content)) STORED;

CREATE INDEX idx_docs_fts ON documents USING gin (fts);
</code></pre>

<br/>
<ul>
    <li>This avoids recomputing the vector on every query.</li>
</ul>
<br/>
<br/>



    <li><b>Composing Queries with plainto_tsquery and websearch_to_tsquery</b></li>
    <br/>
    <ul>
        <li><code>plainto_tsquery</code> â€“ converts plain text into a query using AND logic.</li>
        <li><code>phraseto_tsquery</code> â€“ phrase interpreting version.</li>
        <li><code>websearch_to_tsquery</code> â€“ parses Google-style syntax:
            <ul>
                <li><code>quoted phrases</code></li>
                <li><code>-exclude</code></li>
                <li><code>OR</code></li>
                <li>implicit AND</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT websearch_to_tsquery('english', '"big car" -red');
-- 'big' &lt;-&gt; 'car' &amp; !'red'
</code></pre>
<br/>
<br/>



    <li><b>Ranking Search Results</b></li>
    <br/>
    <ul>
        <li>Use <code>ts_rank</code> or <code>ts_rank_cd</code> to compute relevance:</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT
    id,
    ts_rank(fts, to_tsquery('english', 'car')) AS rank
FROM documents
WHERE fts @@ to_tsquery('english', 'car')
ORDER BY rank DESC;
</code></pre>

<br/>
<ul>
    <li>Common: higher weights for title fields vs body text.</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT setweight(to_tsvector(title), 'A') ||
       setweight(to_tsvector(body),  'D')
       AS fts;
</code></pre>
<br/>
<br/>



    <li><b>Lexeme Weights</b></li>
    <br/>
    <ul>
        <li>You can assign weights <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>:</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT setweight(to_tsvector('Title text'), 'A') ||
       setweight(to_tsvector('Body text'),  'D');
</code></pre>

<br/>
<ul>
    <li>Useful when ranking large documents.</li>
</ul>
<br/>
<br/>



    <li><b>Stop Words</b></li>
    <br/>
    <ul>
        <li>Stop words are common words like <code>the</code>, <code>is</code>, <code>a</code>, etc.</li>
        <br/>
        <li>They are removed during <code>to_tsvector</code> processing.</li>
    </ul>

<pre><code class="language-sql line-numbers">SELECT to_tsvector('english', 'the the the cat');
-- 'cat':4
</code></pre>

<br/>
<ul>
    <li>Different dictionaries have different stop-word lists.</li>
</ul>
<br/>
<br/>



    <li><b>Highlighting Matches (ts_headline)</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT ts_headline(
    'english',
    'The big car crashed near the big house',
    to_tsquery('big &amp; car')
);
</code></pre>

<br/>
<ul>
    <li>Highlights matched words using <code>&lt;b&gt;</code> tags by default.</li>
</ul>
<br/>
<br/>



    <li><b>Using Custom Dictionaries</b></li>
    <br/>
    <ul>
        <li>PostgreSQL FTS supports:
            <ul>
                <li>simple dictionary</li>
                <li>snowball stemmer</li>
                <li>thesaurus</li>
                <li>stop-word files</li>
            </ul>
        </li>
        <br/>
        <li>Thesaurus example:</li>
    </ul>

<pre><code class="language-sql line-numbers"># thesaurus file example:
supercar : car, sports car, racecar
</code></pre>

<br/>
<ul>
    <li>Can be integrated with <code>to_tsvector</code> pipeline.</li>
</ul>
<br/>
<br/>



    <li><b>Practical Example: Search Blog Posts</b></li>
    <br/>

<pre><code class="language-sql line-numbers">ALTER TABLE blog_posts
ADD COLUMN fts tsvector
    GENERATED ALWAYS AS (
        setweight(to_tsvector('english', title), 'A') ||
        setweight(to_tsvector('english', body),  'D')
    ) STORED;

CREATE INDEX idx_blog_fts ON blog_posts USING gin (fts);

SELECT
    id,
    ts_headline(body, q) AS preview,
    ts_rank(fts, q) AS rank
FROM blog_posts,
     to_tsquery('english', 'postgres &amp; search') q
WHERE fts @@ q
ORDER BY rank DESC;
</code></pre>
<br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-udf">User-Defined Functions (UDFs) in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL allows you to create your own functions using <u>SQL</u>, <u>PL/pgSQL</u>, <u>PL/Python</u>, <u>PL/Perl</u>, <u>PL/Java</u>, and even <u>C</u>.</li>
        <br/>
        <li>User-defined functions (UDFs) are first-class citizens: they can be used in
            <code>SELECT</code>, <code>JOIN</code>, <code>WHERE</code>, triggers, indexes, and extensions.</li>
        <br/>
        <li>Functions can return:
            <ul>
                <li>scalar values (INT, TEXT, JSON, etc.)</li>
                <li>composite types (ROW)</li>
                <li>TABLE results (set-returning)</li>
                <li>SETOF anytype</li>
                <li>void</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL optimizes SQL functions aggressively and often inlines them, making them very fast.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Basic SQL Functions</b></li>
    <br/>
    <ul>
        <li>SQL functions are simple wrappers around SQL expressions.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE OR REPLACE FUNCTION add_numbers(a INT, b INT)
RETURNS INT
LANGUAGE sql
AS
$$
    SELECT a + b;
$$;
</code></pre>

<br/>
<ul>
    <li>Executed as:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT add_numbers(10, 20);   -- 30
</code></pre>

<br/>
<br/>



    <li><b>Functions Returning NULL, STRICT Functions</b></li>
    <br/>
    <ul>
        <li><code>STRICT</code> means the function returns <code>NULL</code> immediately if any argument is <code>NULL</code>.</li>
        <br/>
        <li>Equivalent to manually checking for <code>NULL</code>.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE FUNCTION multiply(a INT, b INT)
RETURNS INT
LANGUAGE sql
STRICT
AS
$$
    SELECT a * b;
$$;
</code></pre>

<br/>
<ul>
    <li>Now:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT multiply(NULL, 5);  -- NULL
</code></pre>

<br/>
<br/>



    <li><b>IMMUTABLE, STABLE, VOLATILE</b></li>
    <br/>
    <ul>
        <li>These declarations tell PostgreSQL how predictable your function is:</li>
    </ul>

    <table>
        <tr><th>Category</th><th>Description</th><th>Examples</th></tr>
        <tr>
            <td><code>IMMUTABLE</code></td>
            <td>Always returns the same output for the same input</td>
            <td>pure math, string functions</td>
        </tr>
        <tr>
            <td><code>STABLE</code></td>
            <td>Same result within a single query, but may change between queries</td>
            <td>now(), current_setting()</td>
        </tr>
        <tr>
            <td><code>VOLATILE</code></td>
            <td>Can change anytime, cannot be optimized</td>
            <td>random(), sequences, updates</td>
        </tr>
    </table>

<br/>
<pre><code class="language-sql line-numbers">CREATE FUNCTION greet(name TEXT)
RETURNS TEXT
LANGUAGE sql
IMMUTABLE
AS
$$
    SELECT 'Hello ' || name;
$$;
</code></pre>

<br/>
<br/>



    <li><b>PL/pgSQL Functions (Procedural Language)</b></li>
    <br/>
    <ul>
        <li>PL/pgSQL is PostgreSQL&#39;s powerful procedural language: loops, variables, conditions, exceptions.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE OR REPLACE FUNCTION factorial(n INT)
RETURNS INT
LANGUAGE plpgsql
AS
$$
DECLARE
    result INT := 1;
BEGIN
    IF n &lt; 0 THEN
        RAISE EXCEPTION 'Negative numbers not allowed';
    END IF;

    FOR i IN 1..n LOOP
        result := result * i;
    END LOOP;

    RETURN result;
END;
$$;
</code></pre>

<br/>
<pre><code class="language-sql line-numbers">SELECT factorial(5);  -- 120
</code></pre>

<br/>
<br/>



    <li><b>Using Variables, BEGIN...END Blocks</b></li>
<pre><code class="language-sql line-numbers">CREATE FUNCTION format_user(first TEXT, last TEXT)
RETURNS TEXT
LANGUAGE plpgsql
AS
$$
DECLARE
    full TEXT;
BEGIN
    full := initcap(first || ' ' || last);
    RETURN full;
END;
$$;
</code></pre>
<br/>
<br/>



    <li><b>Control Structures (IF, CASE, LOOP)</b></li>
    <br/>
<pre><code class="language-sql line-numbers">CREATE FUNCTION classify(score INT)
RETURNS TEXT
LANGUAGE plpgsql
AS
$$
BEGIN
    IF score &gt;= 90 THEN
        RETURN 'A';
    ELSIF score &gt;= 80 THEN
        RETURN 'B';
    ELSE
        RETURN 'C';
    END IF;
END;
$$;
</code></pre>
<br/>
<br/>



    <li><b>RETURN QUERY for Set-Returning Functions</b></li>
    <br/>
    <ul>
        <li>You can return multiple rows (like a table).</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE FUNCTION get_users_with_gmail()
RETURNS TABLE(id INT, email TEXT)
LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
    SELECT id, email FROM users WHERE email LIKE '%@gmail.com';
END;
$$;
</code></pre>

<br/>
<pre><code class="language-sql line-numbers">SELECT * FROM get_users_with_gmail();
</code></pre>
<br/>
<br/>



    <li><b>Returning Custom Composite Types</b></li>
    <br/>
<pre><code class="language-sql line-numbers">CREATE TYPE user_info AS (
    id INT,
    name TEXT,
    created TIMESTAMP
);
</code></pre>

<br/>
<pre><code class="language-sql line-numbers">CREATE FUNCTION get_user(uid INT)
RETURNS user_info
LANGUAGE sql
AS
$$
    SELECT id, name, created_at
    FROM users
    WHERE id = uid;
$$;
</code></pre>
<br/>
<br/>



    <li><b>Functions Returning JSON or JSONB</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE FUNCTION product_json(pid INT)
RETURNS JSONB
LANGUAGE sql
AS
$$
    SELECT jsonb_build_object(
        'id', id,
        'name', name,
        'price', price
    )
    FROM products
    WHERE id = pid;
$$;
</code></pre>

<br/>
<br/>



    <li><b>Security Definer Functions</b></li>
    <br/>
    <ul>
        <li><code>SECURITY DEFINER</code> makes the function run with the privileges of the creator, not the caller.</li>
        <li>Useful for controlled data access.</li>
        <li>Dangerous if misused â€“ always restrict the <b>search_path</b>!</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE FUNCTION read_logs()
RETURNS SETOF logs
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS
$$
    SELECT * FROM logs;
$$;
</code></pre>
<br/>
<br/>



    <li><b>Managing search_path Safely</b></li>
    <br/>
    <ul>
        <li>To avoid SQL injection in <code>SECURITY DEFINER</code> functions, always set <b>search_path</b> explicitly:</li>
    </ul>

<pre><code class="language-sql line-numbers">ALTER FUNCTION read_logs() SET search_path = public;
</code></pre>
<br/>
<br/>



    <li><b>Error Handling and Exception Blocks</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE OR REPLACE FUNCTION safe_div(a NUMERIC, b NUMERIC)
RETURNS NUMERIC
LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RETURN NULL;
END;
$$;
</code></pre>
<br/>
<br/>



    <li><b>RAISE Statements</b></li>
    <br/>

<pre><code class="language-sql line-numbers">RAISE NOTICE 'User %, score %', name, score;
RAISE WARNING 'Low disk space';
RAISE EXCEPTION 'Invalid input: %', value;
</code></pre>

<br/>
<br/>



    <li><b>Overloading Functions</b></li>
    <br/>
    <ul>
        <li>PostgreSQL supports function overloading based on argument types.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE FUNCTION info(x INT) RETURNS TEXT AS
$$ SELECT 'int' $$ LANGUAGE sql;
CREATE FUNCTION info(x TEXT) RETURNS TEXT AS
$$ SELECT 'text' $$ LANGUAGE sql;

SELECT info(42);      -- 'int'
SELECT info('foo');   -- 'text'
</code></pre>
<br/>
<br/>



    <li><b>C-Language Functions (Overview)</b></li>
    <br/>
    <ul>
        <li>C functions provide maximum performance and flexibility.</li>
        <li>They are compiled into <code>.so</code> libraries and loaded by PostgreSQL.</li>
        <li>Used for advanced extensions.</li>
    </ul>

<pre><code class="language-c line-numbers">#include "postgres.h"
#include "fmgr.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(add_one);

Datum add_one(PG_FUNCTION_ARGS)
{
    int32 arg = PG_GETARG_INT32(0);
    PG_RETURN_INT32(arg + 1);
}
</code></pre>

<br/>
<ul>
    <li>The SQL wrapper:</li>
</ul>

<pre><code class="language-sql line-numbers">CREATE FUNCTION add_one(int)
RETURNS int
AS 'myext', 'add_one'
LANGUAGE c STRICT;
</code></pre>
<br/>
<br/>



    <li><b>Dropping and Replacing Functions</b></li>
    <br/>

<pre><code class="language-sql line-numbers">DROP FUNCTION add_numbers(INT, INT);
</code></pre>

<br/>
<ul>
    <li>If signature changes, you must drop or use <code>OR REPLACE</code>.</li>
</ul>
<br/>
<br/>



    <li><b>Listing All User-Defined Functions</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT
    proname,
    pg_get_functiondef(p.oid)
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname NOT IN ('pg_catalog', 'information_schema');
</code></pre>

<br/>
<br/>



    <li><b>Practical Real-World UDF Examples</b></li>
    <br/>

<pre><code class="language-sql line-numbers">-- Normalize email
CREATE FUNCTION clean_email(e TEXT)
RETURNS TEXT
IMMUTABLE
LANGUAGE sql
AS
$$ SELECT lower(trim(e)) $$;

-- Generate URL slug
CREATE FUNCTION slugify(s TEXT)
RETURNS TEXT
LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN regexp_replace(lower(s), '[^a-z0-9]+', '-', 'g');
END;
$$;

-- Increase stock safely
CREATE FUNCTION add_stock(pid INT, amount INT)
RETURNS VOID
LANGUAGE plpgsql
AS
$$
BEGIN
    UPDATE products
    SET stock = stock + amount
    WHERE id = pid;
END;
$$;
</code></pre>

<br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-procedures">Stored Procedures</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL distinguishes between <u>functions</u> and <u>stored procedures</u>.</li>
        <br/>
        <li>Procedures were introduced in PostgreSQL&nbsp;11 and allow:
            <ul>
                <li><u>transaction control</u> inside procedure body (<code>COMMIT</code>, <code>ROLLBACK</code>),</li>
                <li>autonomous units of work,</li>
                <li>calls via <code>CALL</code> instead of <code>SELECT</code>.</li>
            </ul>
        </li>
        <br/>
        <li>Procedures do <u>not</u> return values (no <code>RETURNS</code> clause).</li>
        <br/>
        <li>They are ideal for batch jobs, maintenance tasks, cleanup routines, ETL steps, or anything requiring transaction boundaries.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE PROCEDURE procedure_name(arg1 type1, arg2 type2)
LANGUAGE plpgsql
AS
$$
BEGIN
    -- logic
END;
$$;
</code></pre>

<br/>
<ul>
    <li>No <code>RETURNS</code> clause is allowed.</li>
    <li>Execution uses <code>CALL</code>:</li>
</ul>

<pre><code class="language-sql line-numbers">CALL procedure_name(value1, value2);
</code></pre>
<br/>
<br/>



    <li><b>Core Differences Between PROCEDURE and FUNCTION</b></li>
    <br/>
    <table>
        <tr><th>Feature</th><th>FUNCTION</th><th>PROCEDURE</th></tr>
        <tr>
            <td>Returns values</td>
            <td>Yes (scalar, composite, set)</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Executed with</td>
            <td><code>SELECT</code> or <code>PERFORM</code></td>
            <td><code>CALL</code></td>
        </tr>
        <tr>
            <td>Transaction control</td>
            <td><u>No</u></td>
            <td><u>Yes</u>(<code>COMMIT</code> / <code>ROLLBACK</code>)</td>
        </tr>
        <tr>
            <td>Parallel safety</td>
            <td>Declarative (<code>IMMUTABLE</code> / <code>STABLE</code> / <code>VOLATILE</code>)</td>
            <td>Not applicable</td>
        </tr>
        <tr>
            <td>Use cases</td>
            <td>Reusable expressions, business logic</td>
            <td>Batch jobs, maintenance tasks, ETL</td>
        </tr>
    </table>
<br/>
<br/>



    <li><b>Simple Stored Procedure Example</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE OR REPLACE PROCEDURE log_message(msg TEXT)
LANGUAGE plpgsql
AS
$$
BEGIN
    INSERT INTO logs(message, created_at)
    VALUES (msg, NOW());
END;
$$;

CALL log_message('Hello from procedure!');
</code></pre>

<br/>
<ul>
    <li>Side effects (<code>INSERT</code> / <code>UPDATE</code> / <code>DELETE</code>) are typically the goal of a procedure.</li>
</ul>
<br/>
<br/>



    <li><b>Procedures With Transaction Control</b></li>
    <br/>
    <ul>
        <li>This is the biggest reason to use procedures.</li>
        <li>You can <code>COMMIT</code> / <code>ROLLBACK</code> inside the procedure body.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE OR REPLACE PROCEDURE batch_insert()
LANGUAGE plpgsql
AS
$$
BEGIN
    INSERT INTO events(data) VALUES ('step 1');
    COMMIT;   -- commit early

    INSERT INTO events(data) VALUES ('step 2');
    ROLLBACK; -- rollback this part

    INSERT INTO events(data) VALUES ('step 3');
END;
$$;

CALL batch_insert();
</code></pre>

<br/>
<ul>
    <li><mark>NOTE</mark>: Only <u>top-level</u> <code>CALL</code> allows transaction control.
        Procedures cannot be called from inside a function with <code>COMMIT</code> / <code>ROLLBACK</code>.</li>
</ul>
<br/>
<br/>



    <li><b>Using IN, OUT, INOUT Parameters</b></li>
    <br/>
    <ul>
        <li>Procedures may return data via <code>OUT</code> or <code>INOUT</code> parameters.</li>
        <li>This is the only way they can output values.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE PROCEDURE add_and_double(
    IN a INT,
    IN b INT,
    OUT sum_val INT,
    OUT double_sum INT
)
LANGUAGE plpgsql
AS
$$
BEGIN
    sum_val := a + b;
    double_sum := (a + b) * 2;
END;
$$;

CALL add_and_double(3, 5, NULL, NULL);
</code></pre>

<br/>
<ul>
    <li>Client tools will show OUT values as a result set.</li>
</ul>
<br/>
<br/>



    <li><b>Using INOUT Parameters</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE PROCEDURE increment(INOUT x INT)
LANGUAGE plpgsql
AS
$$
BEGIN
    x := x + 1;
END;
$$;

CALL increment(10);   -- returns 11
</code></pre>
<br/>
<br/>



    <li><b>Procedures With Dynamic SQL (EXECUTE)</b></li>
    <br/>
    <ul>
        <li>Useful for administrative tasks, partition management, dynamic operations.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE PROCEDURE drop_table_if_exists(tname TEXT)
LANGUAGE plpgsql
AS
$$
BEGIN
    EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(tname);
END;
$$;

CALL drop_table_if_exists('old_data');
</code></pre>
<br/>
<br/>



    <li><b>Procedures and Exception Handling</b></li>
    <br/>
    <ul>
        <li>Procedures support full PL/pgSQL exception blocks.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE PROCEDURE safe_insert(val INT)
LANGUAGE plpgsql
AS
$$
BEGIN
    INSERT INTO numbers(num) VALUES (val);
EXCEPTION
    WHEN unique_violation THEN
        RAISE NOTICE 'Duplicate ignored: %', val;
END;
$$;

CALL safe_insert(10);
</code></pre>
<br/>
<br/>



    <li><b>Procedures Calling Other Procedures</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE PROCEDURE outer_proc()
LANGUAGE plpgsql
AS
$$
BEGIN
    CALL inner_proc();
END;
$$;
</code></pre>

<br/>
<ul>
    <li>Nested CALLs are allowed.</li>
    <li>But only the top-level CALL controls transactions.</li>
</ul>
<br/>
<br/>



    <li><b>Procedures vs DO Blocks</b></li>
    <br/>
    <table>
        <tr><th>Feature</th><th>PROCEDURE</th><th>DO Block</th></tr>
        <tr>
            <td>Persistence</td>
            <td>Stored permanently</td>
            <td>Temporary (inline execution)</td>
        </tr>
        <tr>
            <td>Transaction control</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Parameters</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Used in extensions</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
    </table>

<br/>
<br/>



    <li><b>Replacing and Dropping Procedures</b></li>
    <br/>

<pre><code class="language-sql line-numbers">DROP PROCEDURE log_message(TEXT);

CREATE OR REPLACE PROCEDURE log_message(TEXT) ...
</code></pre>

<br/>
<ul>
    <li>PostgreSQL identifies procedures by <b>name + argument types</b>.</li>
</ul>
<br/>
<br/>



    <li><b>Listing All Procedures</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT
    p.proname,
    pg_get_function_arguments(p.oid) AS args,
    n.nspname AS schema
FROM pg_proc p
JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE p.prokind = 'p';     -- 'p' = procedure
</code></pre>
<br/>
<br/>



    <li><b>Security Considerations</b></li>
    <br/>
    <ul>
        <li><code>SECURITY DEFINER</code> works for procedures too.</li>
        <li>Always set <b>search_path</b> explicitly to avoid SQL injection:</li>
    </ul>

<pre><code class="language-sql line-numbers">ALTER PROCEDURE log_message(TEXT)
SET search_path = public;
</code></pre>

<br/>
<ul>
    <li>Be cautious with dynamic SQL inside SECURITY DEFINER procedures.</li>
</ul>
<br/>
<br/>



    <li><b>Real-World Example: ETL Batch Job</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE OR REPLACE PROCEDURE nightly_etl()
LANGUAGE plpgsql
AS
$$
BEGIN
    -- Step 1: staging load
    INSERT INTO staging SELECT * FROM raw_data;
    COMMIT;

    -- Step 2: transformations
    UPDATE staging SET cleaned = TRUE WHERE data LIKE '%ok%';
    COMMIT;

    -- Step 3: merge into production
    INSERT INTO production SELECT * FROM staging;
    COMMIT;

    -- Step 4: cleanup
    TRUNCATE staging;
END;
$$;

CALL nightly_etl();
</code></pre>

<br/>
<ul>
    <li>Each ETL phase is committed independently.</li>
    <li>Impossible to implement with functions.</li>
</ul>
<br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-transactions">Transactions, COMMIT, and ROLLBACK in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>transaction</u> in PostgreSQL is a group of SQL statements executed as a single unit of work.</li>
        <br/>
        <li>A transaction guarantees the 4 ACID properties:
            <ul>
                <li><u>A</u>tomicity â€“ all-or-nothing</li>
                <li><u>C</u>onsistency â€“ no broken constraints</li>
                <li><u>I</u>solation â€“ one transaction doesn't see another's partial changes</li>
                <li><u>D</u>urability â€“ committed data is guaranteed to persist</li>
            </ul>
        </li>
        <br/>
        <li>You control a transaction with two commands:
            <ul>
                <li><code>COMMIT</code> â€“ permanently save changes</li>
                <li><code>ROLLBACK</code> â€“ undo changes since the last <code>BEGIN</code></li>
            </ul>
        </li>
        <br/>
        <li>Transactions isolate incomplete work from other users until finalized.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Starting a Transaction</b></li>
    <br/>
<pre><code class="language-sql line-numbers">BEGIN;
-- or: START TRANSACTION;
</code></pre>

<br/>
<ul>
    <li>All subsequent SQL statements become part of this transaction until explicitly ended.</li>
</ul>
<br/>
<br/>



    <li><b>COMMIT: Saving All Changes</b></li>
    <br/>
    <ul>
        <li><code>COMMIT</code> finalizes the transaction and permanently writes changes to the database.</li>
        <li>Once committed, changes <u>cannot be undone</u> (unless you start a new compensating transaction).</li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;   -- both updates permanently saved
</code></pre>

<br/>
<br/>



    <li><b>ROLLBACK: Undoing All Changes</b></li>
    <br/>
    <ul>
        <li><code>ROLLBACK</code> cancels the entire transaction and reverts all statements back to the state before <code>BEGIN</code>.</li>
        <li>No data is modified if rollback occurs.</li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN;

UPDATE products SET stock = stock - 10 WHERE id = 100;
UPDATE products SET stock = stock + 10 WHERE id = 200;

ROLLBACK;   -- both updates undone
</code></pre>

<br/>
<ul>
    <li>Even if multiple statements executed successfully, <code>ROLLBACK</code> erases all of them from the current transaction.</li>
</ul>
<br/>
<br/>



    <li><b>Autocommit Behavior</b></li>
    <br/>
    <ul>
        <li>By default, PostgreSQL runs in <u>autocommit mode</u>:
            <ul>
                <li>each individual statement is its own transaction</li>
                <li>and is automatically committed after execution</li>
            </ul>
        </li>
        <br/>
        <li>Example:</li>
    </ul>

<pre><code class="language-sql line-numbers">UPDATE users SET name = 'A';   -- auto-committed immediately
</code></pre>

<br/>
<ul>
    <li>To use multi-statement transactions, you must explicitly begin them using <code>BEGIN</code>.</li>
</ul>
<br/>
<br/>



    <li><b>Combining Multiple Operations</b></li>
    <br/>
    <ul>
        <li>Transactions allow complex multi-step logic to behave atomically.</li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN;

INSERT INTO orders(user_id, total) VALUES (7, 250);
INSERT INTO order_items(order_id, product_id, qty)
VALUES (currval('orders_id_seq'), 42, 3);

-- If anything goes wrong:
-- ROLLBACK;

COMMIT;
</code></pre>

<br/>
<ul>
    <li>Either <b>both</b> <code>INSERT</code>s happen or neither.</li>
</ul>
<br/>
<br/>



    <li><b>Savepoints: Partial Rollback</b></li>
    <br/>
    <ul>
        <li><u>Savepoints</u> allow you to roll back part of a transaction without canceling the whole thing.</li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;

SAVEPOINT s1;

UPDATE accounts SET balance = balance + 500 WHERE id = 99; -- account 99 doesn&#39;t exist

ROLLBACK TO s1;  -- undo only second update

COMMIT;
</code></pre>

<br/>
<ul>
    <li><code>ROLLBACK TO</code> does not end the transaction, only rewinds to that savepoint.</li>
</ul>
<br/>
<br/>



    <li><b>Transaction Behavior in Functions</b></li>
    <br/>
    <ul>
        <li>Functions (<code>CREATE FUNCTION</code>) <u>cannot</u> use <code>COMMIT</code> or <code>ROLLBACK</code>.</li>
        <li>They run inside the caller's transaction boundary.</li>
    </ul>

<pre><code class="language-sql line-numbers">-- INVALID inside functions:
COMMIT;
ROLLBACK;
</code></pre>

<br/>
<ul>
    <li>Functions must behave atomically.</li>
</ul>
<br/>
<br/>



    <li><b>Transaction Behavior in Procedures</b></li>
    <br/>
    <ul>
        <li>Procedures (<code>CREATE PROCEDURE</code>) <u>can</u> use transaction control.</li>
        <li>They are invoked with <code>CALL</code> at the top level.</li>
        <li>This is the main difference from functions.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE PROCEDURE demo()
LANGUAGE plpgsql
AS
$$
BEGIN
    INSERT INTO logs(msg) VALUES ('step 1');
    COMMIT;   -- allowed

    INSERT INTO logs(msg) VALUES ('step 2');
    ROLLBACK; -- undo step 2 only

    INSERT INTO logs(msg) VALUES ('step 3'); -- part of new transaction
END;
$$;

CALL demo();
</code></pre>

<br/>
<br/>

    <li><b>Transaction Isolation Levels</b></li>
    <br/>
    <ul>
        <li>Transaction isolation levels define <u>what data a transaction can see</u> while other transactions are running concurrently.</li>
        <br/>
        <li>PostgreSQL implements isolation using <u>MVCC (Multi-Version Concurrency Control)</u>, which gives each transaction a consistent <u>snapshot</u> of the database.</li>
        <br/>
        <li>The isolation level determines:
            <ul>
                <li>whether the transaction sees other transactions' updates,</li>
                <li>whether rows can appear or disappear during the transaction,</li>
                <li>whether reading the same row twice always yields the same value,</li>
                <li>whether anomalies (dirty reads, write skew, phantom rows) are allowed.</li>
            </ul>
        </li>
        <br/>
        <li>You set the isolation level per transaction:</li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- work inside transaction

COMMIT;
</code></pre>

<br/>
<ul>
    <li>PostgreSQL supports three standard isolation levels:</li>
</ul>

<table>
    <tr>
        <th>Isolation Level</th>
        <th>Description (Detailed)</th>
    </tr>

    <tr>
        <td><code>READ COMMITTED</code></td>
        <td>
            <ul>
                <li>This is the <u>default</u> isolation level in PostgreSQL.</li>
                <li>Each individual SQL statement sees a snapshot of data committed <u>before that statement began</u>.</li>
                <li>If another transaction commits in-between your statements, your next statement will see the new data.</li>
                <li>Prevents <u>dirty reads</u> (you never see uncommitted data).</li>
                <li>Allows <u>non-repeatable reads</u>:
                    <br/>The same row queried twice may return different values if another transaction modifies and commits it between your statements.</li>
                <li>Allows <u>phantom reads</u>:
                    <br/>Repeated <code>SELECT</code> queries may return more or fewer rows.</li>
                <li>Snapshot: <u>one snapshot per statement</u>.</li>
            </ul>
        </td>
    </tr>

    <tr>
        <td><code>REPEATABLE READ</code></td>
        <td>
            <ul>
                <li>The transaction sees a <u>single consistent snapshot</u> taken when the transaction begins.</li>
                <li>No matter what other transactions commit during your transaction, your reads stay the same.</li>
                <li>Prevents:
                    <ul>
                        <li><u>dirty reads</u>: never see uncommitted data</li>
                        <li><u>non-repeatable reads</u>: reading the same row twice always gives the same result</li>
                    </ul>
                </li>
                <li>Allows <u>phantom reads</u>:
                    <br/>A repeated query on ranges may still return additional rows depending on the situation.</li>
                <li>May allow <u>write skew anomalies</u> (a type of race condition) unless <code>SERIALIZABLE</code> is used.</li>
                <li>Snapshot: <u>one snapshot for the entire transaction</u>.</li>
            </ul>
        </td>
    </tr>

    <tr>
        <td><code>SERIALIZABLE</code></td>
        <td>
            <ul>
                <li>The strongest isolation level â€” ensures the database behaves <u>as if transactions were executed one by one, sequentially</u>, even though they run concurrently.</li>
                <li>Automatically prevents:
                    <ul>
                        <li><u>dirty reads</u></li>
                        <li><u>non-repeatable reads</u></li>
                        <li><u>phantom reads</u></li>
                        <li><u>write skew anomalies</u></li>
                    </ul>
                </li>
                <li>Requires PostgreSQL to automatically detect dangerous conflicts.</li>
                <li>If two concurrent transactions could lead to a serialization anomaly, PostgreSQL <u>aborts one</u> with:</li>
            </ul>
            <pre><code class="language-sql line-numbers">ERROR: could not serialize access due to read/write dependencies</code></pre>
            <ul>
                <li>Your application must <u>retry</u> the entire transaction.</li>
                <li>Snapshot: similar to <code>REPEATABLE READ</code>, but with extra checks using <u>predicate locks</u> to avoid anomalies.</li>
            </ul>
        </td>
    </tr>
</table>

    <br/>
    <br/>

    <li><b>What Happens During Errors?</b></li>
    <br/>
    <ul>
        <li>Any unhandled SQL error causes the current transaction to become <u>aborted</u>.</li>
        <li>You cannot continue until you <code>ROLLBACK</code>.</li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN;

INSERT INTO a VALUES (1);
INSERT INTO a VALUES (1);  -- duplicate key error, transaction aborted

-- Now ANY statement will error until ROLLBACK is issued

ROLLBACK;   -- reset state
</code></pre>
<br/>
<br/>



    <li><b>Real-World Example: Bank Transfer</b></li>
    <br/>

<pre><code class="language-sql line-numbers">BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

COMMIT;   -- transfer completed
</code></pre>

<br/>
<ul>
    <li>Guarantees that money is never lost or created.</li>
</ul>
<br/>
<br/>



    <li><b>Real-World Example: Repairing Data</b></li>
    <br/>

<pre><code class="language-sql line-numbers">BEGIN;

DELETE FROM logs WHERE created_at &lt; NOW() - INTERVAL &#39;90 days&#39;;

-- Oops, wrong condition?
ROLLBACK;

-- try again
BEGIN;
DELETE FROM logs WHERE created_at &lt; NOW() - INTERVAL &#39;30 days&#39;;
COMMIT;
</code></pre>

<br/>
<br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-sequences">Sequences in PostgreSQL</h3>
<ol>
    <li>A <u>sequence</u> in PostgreSQL is a special object that generates a sequence of numeric values, usually used for <u>auto-incrementing primary keys</u>.</li>
    <br/>
    <br/>


    <li>Sequences are independent database objects and not tied to a table unless you explicitly connect them.</li>
    <br/>
    <br/>


    <li>They are <u>non-transactional counters</u>:
        <ul>
            <li>Each call increases the counter immediately</li>
            <li>Sequence increments cannot be rolled back</li>
        </ul>
    </li>
    <br/>
    <br/>


    <li>PostgreSQL automatically creates sequences for <code>SERIAL</code>, <code>BIGSERIAL</code>, and <code>GENERATED AS IDENTITY</code> columns.</li>
    <br/>
    <br/>



    <li><b>Creating a Sequence</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE SEQUENCE user_id_seq;
</code></pre>

<br/>
<ul>
    <li>A minimal sequence starts at 1 and increments by 1.</li>
    <li>You can customize start, increment, min, max, cache, and cycle behavior.</li>
</ul>

<pre><code class="language-sql line-numbers">CREATE SEQUENCE order_seq
    START WITH 1000
    INCREMENT BY 5
    MINVALUE 1
    MAXVALUE 1000000
    CACHE 50
    CYCLE;
</code></pre>

<br/>
<ul>
    <li><code>CYCLE</code>: sequence wraps to <code>MINVALUE</code> when <code>MAXVALUE</code> reached.</li>
    <li><code>CACHE</code>: performance optimization (pre-allocates numbers).</li>
</ul>
<br/>
<br/>



    <li><b>Getting Values From a Sequence</b></li>
    <br/>
    <ul>
        <li>The most important sequence functions:</li>
        <ul>
            <li><code>nextval(seqname)</code> â€“ returns next number and increments sequence</li>
            <li><code>currval(seqname)</code> â€“ returns last value requested by this session</li>
            <li><code>setval(seqname, value)</code> â€“ manually sets sequence value</li>
        </ul>
    </ul>

<pre><code class="language-sql line-numbers">SELECT nextval('user_id_seq');  -- 1
SELECT nextval('user_id_seq');  -- 2
SELECT currval('user_id_seq');  -- 2 (same session only)
</code></pre>

<br/>
<ul>
    <li><code>currval</code> works only after the first <code>nextval</code> has been called in that session.</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT currval('user_id_seq');
-- ERROR: currval of sequence "user_id_seq" is not yet defined in this session
</code></pre>
<br/>
<br/>



    <li><b>Manually Setting the Value</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT setval('user_id_seq', 500);
SELECT nextval('user_id_seq');  -- 501
</code></pre>

<br/>
<ul>
    <li>You can also tell PostgreSQL whether the next <code>nextval</code> should return <code>value</code> or <code>value + 1</code>:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT setval('user_id_seq', 500, false); -- next nextval = 500
SELECT nextval('user_id_seq');            -- 500
</code></pre>
<br/>
<br/>



    <li><b>Linking a Sequence to a Table Column</b></li>
    <br/>
    <ul>
        <li>When you use <code>SERIAL</code> or <code>BIGSERIAL</code>, PostgreSQL automatically creates and links a sequence.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT
);
</code></pre>

<br/>
<ul>
    <li>This expands to:</li>
</ul>

<pre><code class="language-sql line-numbers">CREATE SEQUENCE users_id_seq
OWNED BY users.id;

ALTER TABLE users ALTER COLUMN id SET DEFAULT nextval('users_id_seq');
</code></pre>

<br/>
<ul>
    <li><code>OWNED BY</code> means:</li>
    <ul>
        <li>dropping the column drops the sequence</li>
        <li>the sequence is logically tied to the column</li>
    </ul>
</ul>

<br/>
<br/>



    <li><b>IDENTITY Columns (Modern Alternative to SERIAL)</b></li>
    <br/>
    <ul>
        <li>PostgreSQL 10+ introduced <code>GENERATED AS IDENTITY</code>, which behaves like SQL-standard auto-increment.</li>
        <li>Prefer it over SERIAL in new systems.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    total NUMERIC
);
</code></pre>

<br/>
<ul>
    <li>Two identity modes:</li>
    <ul>
        <li><code>GENERATED ALWAYS</code> â€“ always auto-generate</li>
        <li><code>GENERATED BY DEFAULT</code> â€“ allows manual overrides</li>
    </ul>
</ul>

<br/>
<br/>



    <li><b>Using a Sequence in INSERT Statements</b></li>
    <br/>
<pre><code class="language-sql line-numbers">INSERT INTO users(id, name)
VALUES (nextval('user_id_seq'), 'Alice');
</code></pre>

<br/>
<ul>
    <li>If the column has a default <code>nextval</code>, you can omit it:</li>
</ul>

<pre><code class="language-sql line-numbers">INSERT INTO users(name)
VALUES ('Bob');
</code></pre>
<br/>
<br/>



    <li><b>Viewing Sequence Properties</b></li>
    <br/>

<pre><code class="language-sql line-numbers">SELECT * FROM user_id_seq;
-- or
SELECT * FROM pg_sequences WHERE schemaname = 'public';
</code></pre>

<br/>
<ul>
    <li>You can also inspect definition:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT pg_get_serial_sequence('users', 'id');
</code></pre>

<br/>
<ul>
    <li>Or retrieve details from system table:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT * FROM pg_class WHERE relkind = 'S';
</code></pre>

<br/>
<br/>



    <li><b>Concurrency &amp; Non-Transactional Behavior</b></li>
    <br/>
    <ul>
        <li>
            Sequences are <u>non-transactional</u>:
            A <code>nextval</code> increment is permanent, even if the transaction <code>ROLLBACK</code>s.
        </li>
    </ul>

<pre><code class="language-sql line-numbers">BEGIN;
SELECT nextval('user_id_seq');  -- 10
ROLLBACK;

SELECT nextval('user_id_seq');  -- 11 (NOT 10)
</code></pre>
<br/>
<br/>



    <li><b>Sequences and Race Conditions</b></li>
    <br/>
    <ul>
        <li>Two transactions calling <code>nextval</code> concurrently:
            <ul>
                <li>both get unique values</li>
                <li>no locks are needed</li>
            </ul>
        </li>
        <li>Sequences never cause deadlocks or blocking.</li>
    </ul>

<pre><code class="language-sql line-numbers">-- Transaction A and B both run:
SELECT nextval('user_id_seq');

-- A gets 12
-- B gets 13
</code></pre>

<br/>
<br/>



    <li><b>Resetting or Restarting a Sequence</b></li>
    <br/>

<pre><code class="language-sql line-numbers">ALTER SEQUENCE user_id_seq RESTART WITH 1;
</code></pre>

<br/>
<ul>
    <li>You can also use setval:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT setval('user_id_seq', 1, false);
</code></pre>

<br/>
<ul>
    <li><mark>NOTE</mark>: resetting sequences can break primary key uniqueness if old IDs still exist.</li>
</ul>

<br/>
<br/>



    <li><b>Dropping a Sequence</b></li>
    <br/>

<pre><code class="language-sql line-numbers">DROP SEQUENCE user_id_seq;
</code></pre>

<br/>
<ul>
    <li>If it was <code>OWNED BY</code> a column, dropping the table or column also drops the sequence.</li>
</ul>

<br/>
<br/>



    <li><b>Real-World Examples</b></li>
    <br/>

<pre><code class="language-sql line-numbers">-- Create a custom global invoice numbering generator
CREATE SEQUENCE invoice_seq START WITH 20240001;

INSERT INTO invoices(id, total)
VALUES (nextval('invoice_seq'), 99.99);
</code></pre>

<br/>

<pre><code class="language-sql line-numbers">-- Use sequence to shard IDs by region
CREATE SEQUENCE region1_seq START 1 INCREMENT 10;
CREATE SEQUENCE region2_seq START 2 INCREMENT 10;
</code></pre>

<br/>

<pre><code class="language-sql line-numbers">-- Regenerating sequence after manual data load
SELECT setval('user_id_seq', (SELECT MAX(id) FROM users));
</code></pre>

<br/>
<br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="pg-indexes">Indexes in PostgreSQL</h3>
<ol>

    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>An <u>index</u> in PostgreSQL is a separate data structure used to accelerate row lookups, filtering, sorting, joining, and uniqueness enforcement.</li>
        <br/>
        <li>Indexes speed up <code>WHERE</code> clauses, <code>JOIN</code> conditions, <code>ORDER BY</code>, <code>GROUP BY</code>, and <code>distinct queries</code>.</li>
        <br/>
        <li>Indexes are <u>not</u> free: maintaining them adds CPU, I/O, and storage overhead on <code>INSERT</code> / <code>UPDATE</code> / <code>DELETE</code>.</li>
        <br/>
        <li>PostgreSQL maintains indexes automatically as data changes.</li>
    </ul>
    <br/><br/>



    <li><b>Basic Index Creation</b></li>
    <br/>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_email
ON users(email);
</code></pre>

<br/>
<ul>
    <li>Creates a default <u>B-tree index</u>.</li>
    <li>PostgreSQL chooses B-tree unless you explicitly specify another type.</li>
</ul>

<br/><br/>



    <li><b>The Main Index Types</b></li>
    <br/>

    <table>
        <tr><th>Index Type</th><th>Best For</th><th>Notes</th></tr>

        <tr>
            <td><code>B-tree</code></td>
            <td>Equality (<code>=</code>) and range (<code>&lt;</code>, <code>&gt;</code>) queries</td>
            <td>Default index, supports sorting and <code>UNIQUE</code> constraints</td>
        </tr>

        <tr>
            <td><code>Hash</code></td>
            <td>Equality lookups only</td>
            <td>Rarely used, B-tree is usually faster</td>
        </tr>

        <tr>
            <td><code>GIN</code></td>
            <td>Arrays, JSONB, full-text search</td>
            <td>Multivalued indexing, slower to update but very fast lookup</td>
        </tr>

        <tr>
            <td><code>GiST</code></td>
            <td>Geometric types, full-text search, ranges</td>
            <td>Flexible balanced tree framework</td>
        </tr>

        <tr>
            <td><code>SP-GiST</code></td>
            <td>Partitioned search spaces: IP ranges, quadtrees</td>
            <td>Specialized high-performance search structures</td>
        </tr>

        <tr>
            <td><code>BRIN</code></td>
            <td>Very large tables with natural ordering (timestamps, IDs)</td>
            <td>Tiny index size, block ranges, extremely fast to build</td>
        </tr>

        <tr>
            <td><code>Bloom</code> extension</td>
            <td>Many-column indexes</td>
            <td>Probabilistic index; extension: <code>pg_bloom</code></td>
        </tr>
    </table>

<br/><br/>



    <li><b>B-Tree Indexes (Default)</b></li>
    <br/>
    <ul>
        <li>Suitable for equality and range operations:</li>
    </ul>

<pre><code class="language-sql line-numbers">WHERE email = 'a@example.com'
WHERE age &gt; 18
WHERE price BETWEEN 100 AND 200
ORDER BY created_at DESC
</code></pre>

<br/>
<ul>
    <li>They support unique constraints:</li>
</ul>

<pre><code class="language-sql line-numbers">CREATE UNIQUE INDEX idx_users_email_unique ON users(email);
</code></pre>

<br/><br/>



    <li><b>Expression Indexes (Function Indexes)</b></li>
    <br/>
    <ul>
        <li>Indexes over expressions let PostgreSQL index computed values.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_lower_email
ON users(LOWER(email));
</code></pre>

<br/>
<ul>
    <li>Query must match the expression:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT * FROM users WHERE LOWER(email) = 'a@example.com';
</code></pre>

<br/><br/>



    <li><b>Partial Indexes (Filtered Indexes)</b></li>
    <br/>
    <ul>
        <li>Indexes only part of a table for performance and space savings.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_active_users
ON users(email)
WHERE active = true;
</code></pre>

<br/>
<ul>
    <li>Useful when most rows do not match the condition.</li>
    <li>Example: indexing only <code>WHERE deleted_at IS NULL</code>.</li>
</ul>

<br/><br/>



    <li><b>Multi-Column Indexes</b></li>
    <br/>
    <ul>
        <li>Indexes can contain multiple columns.</li>
        <li>Column order matters a lot.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_last_first
ON users(last_name, first_name);
</code></pre>

<br/>
<ul>
    <li>Index can be used for:</li>
    <ul>
        <li><code>WHERE last_name = ... AND first_name = ...</code></li>
        <li><code>WHERE last_name = ...</code></li>
    </ul>
        <li>But NOT for:</li>
    <ul>
        <li><code>WHERE first_name = ...</code></li>
    </ul>
</ul>

<br/><br/>



    <li><b>Index-Only Scans</b></li>
    <br/>
    <ul>
        <li>If all required columns exist in the index, PostgreSQL can avoid accessing the table entirely.</li>
        <br/>
        <li>This is faster because:
            <ul>
                <li>index pages are smaller than table pages</li>
                <li>no heap tuple visibility checks needed if page is "all-visible"</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_email_only
ON users(email);

SELECT email FROM users WHERE email LIKE '%@gmail.com';
</code></pre>

<br/>
<ul>
    <li>Requires visibility map bits to be set â€” <code>VACUUM</code> affects index-only scan performance.</li>
</ul>

<br/><br/>



    <li><b>GIN Indexes</b></li>
    <br/>
    <ul>
        <li>Designed for multivalued data:</li>
        <ul>
            <li>Array columns</li>
            <li>JSONB documents</li>
            <li>Full-text search</li>
        </ul>
        <li>Supports containment operators:</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_tags_gin
ON posts USING gin(tags);
</code></pre>

<br/>
<ul>
    <li>Examples:</li>
</ul>

<pre><code class="language-sql line-numbers">SELECT * FROM posts WHERE tags &amp;&amp; '{sql}';
SELECT * FROM posts WHERE tags @&gt; '{programming}';
SELECT * FROM data WHERE jsonb_data @&gt; '{"user": {"id": 5}}';
</code></pre>

<br/><br/>



    <li><b>GiST Indexes</b></li>
    <br/>
    <ul>
        <li>Generalized Search Tree â€” supports many non-linear data types:</li>
        <ul>
            <li>geometric types</li>
            <li>ranges</li>
            <li>full-text search</li>
            <li>ltree hierarchical search</li>
        </ul>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_ranges_gist
ON events USING gist(period);
</code></pre>

<br/><br/>



    <li><b>SP-GiST Indexes</b></li>
    <br/>
    <ul>
        <li>Used for partitioned search spaces such as:</li>
        <ul>
            <li>IP addresses (radix trees)</li>
            <li>geometric quadtrees</li>
            <li>trie-like structures</li>
        </ul>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_ip_spgist
ON ips USING spgist(ip_address);
</code></pre>

<br/><br/>



    <li><b>BRIN Indexes</b></li>
    <br/>
    <ul>
        <li><b>Block Range Index</b> â€” extremely tiny and fast to build.</li>
        <li>Best for very large tables where data is naturally ordered:
            <ul>
                <li>timestamps</li>
                <li>auto-incrementing IDs</li>
            </ul>
        </li>
        <li>Index stores summary values for each 8k block range.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_logs_brin
ON logs USING brin(timestamp);
</code></pre>

<br/><br/>



    <li><b>Index Bloat</b></li>
    <br/>
    <ul>
        <li>PostgreSQL never updates index rows in-place.</li>
        <li>Updates create new index entries.</li>
        <li>Dead entries accumulate until vacuumed.</li>
        <li>B-tree indexes are most sensitive to bloat.</li>
    </ul>

<pre><code class="language-sql line-numbers">REINDEX INDEX idx_users_email;
REINDEX TABLE users;
</code></pre>

<br/><br/>



    <li><b>Fillfactor</b></li>
    <br/>
    <ul>
        <li>Defines how full index pages may become.</li>
        <li>Useful for high-update workloads.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_items_price
ON items(price)
WITH (fillfactor = 70);
</code></pre>

<br/><br/>



    <li><b>NULL Handling in Indexes</b></li>
    <br/>
    <ul>
        <li>B-tree indexes store NULLs and sort them first or last depending on ASC/DESC.</li>
        <li>Use partial indexes to exclude NULLs:</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_not_null_price
ON items(price)
WHERE price IS NOT NULL;
</code></pre>

<br/><br/>



    <li><b>Collation-Aware Indexing</b></li>
    <br/>
    <ul>
        <li>Index sorting depends on collation.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_names_collation
ON people(name COLLATE "de_DE");
</code></pre>

<br/><br/>



    <li><b>Operator Classes</b></li>
    <br/>
    <ul>
        <li>Index behavior changes depending on operator classes.</li>
        <li>Example: text pattern ops optimize <code>LIKE 'abc%'</code>.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_email_pattern
ON users(email text_pattern_ops);
</code></pre>

<br/><br/>



    <li><b>Covering Indexes (INCLUDE)</b></li>
    <br/>
    <ul>
        <li>Store extra columns in the index for index-only scans, without affecting index sorting.</li>
    </ul>

<pre><code class="language-sql line-numbers">CREATE INDEX idx_orders_user_date
ON orders(user_id)
INCLUDE (order_date);
</code></pre>

<br/><br/>



    <li><b>Dropping Indexes</b></li>
    <br/>

<pre><code class="language-sql line-numbers">DROP INDEX idx_users_email;
</code></pre>

<br/><br/>



    <li><b>Real-World Index Examples</b></li>
    <br/>

<pre><code class="language-sql line-numbers">-- Search by email, case-insensitive
CREATE INDEX idx_users_lower_email
ON users(LOWER(email));

-- Fast soft-deletes
CREATE INDEX idx_posts_not_deleted
ON posts(id)
WHERE deleted_at IS NULL;

-- Fast JSONB lookup
CREATE INDEX idx_events_jsonb
ON events USING gin(data);

-- Speed up sorting queries
CREATE INDEX idx_logs_ts_desc
ON logs(timestamp DESC);

-- Range queries on large time-based table
CREATE INDEX idx_sensor_brin
ON sensor_data USING brin(recorded_at);
</code></pre>

<br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>More to be expected...</h3>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
