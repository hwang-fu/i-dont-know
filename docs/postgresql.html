<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>About PostgreSQL</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>PostgreSQL</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Creating Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In PostgreSQL, a <U>table</u> is a structured collection of rows and columns where data is stored.</li>
        <br/>
        <li>You define a table using the <b>CREATE TABLE</b> command, specifying the column names, data types, and optional constraints (like <code>PRIMARY KEY</code>, <code>NOT NULL</code>, or <code>UNIQUE</code>).</li>
        <br/>
        <li>Tables belong to a <u>schema</u> within a database. By default, they are created inside the <code>public</code> schema unless another one is specified.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name1 data_type [constraint],
    column_name2 data_type [constraint],
    ...
    [table_constraints]
);
</code></pre>
    <br/>
    <ul>
        <li><code>table_name</code>: the name of your new table.</li>
        <li><code>column_name</code>: the name of each column in that table.</li>
        <li><code>data_type</code>: defines the kind of data stored (e.g., <code>INTEGER</code>, <code>TEXT</code>, <code>BOOLEAN</code>, <code>DATE</code>, etc.).</li>
        <li><code>[constraint]</code>: optional restrictions like <code>NOT NULL</code>, <code>DEFAULT</code>, etc.</li>
        <li><code>[table_constraints]</code>: rules applying to multiple columns, e.g. primary keys, foreign keys.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Creating a Simple Table</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  VARCHAR(50) NOT NULL,
    last_name   VARCHAR(50) NOT NULL,
    hire_date   DATE NOT NULL DEFAULT CURRENT_DATE,
    active      BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li><code>SERIAL</code> automatically creates an auto-incrementing integer column (in modern PostgreSQL, use <code>GENERATED ALWAYS AS IDENTITY</code> instead).</li>
        <li><code>PRIMARY KEY</code> ensures each row has a unique, non-null identifier.</li>
        <li><code>VARCHAR(50)</code> defines a text field up to 50 characters.</li>
        <li><code>DEFAULT CURRENT_DATE</code> auto-fills with today's date when no value is given.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Modern Auto-Increment Syntax (Preferred)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL,
    department  TEXT DEFAULT 'General'
);
</code></pre>
    <br/>
    <ul>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is the SQL-standard version of <code>SERIAL</code>.</li>
        <li>You can also use <code>GENERATED BY DEFAULT AS IDENTITY</code> if you want to allow manual insertion of custom IDs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding Table-Level Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id      INT GENERATED ALWAYS AS IDENTITY,
    customer_id   INT NOT NULL,
    order_total   NUMERIC(10,2) NOT NULL CHECK (order_total &gt;= 0),
    order_date    TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (order_id),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
</code></pre>
    <br/>
    <ul>
        <li><code>CHECK (order_total &gt;= 0)</code> ensures totals can't be negative.</li>
        <li><code>PRIMARY KEY</code> and <code>FOREIGN KEY</code> constraints can appear at the bottom as table-level definitions.</li>
        <li><code>NUMERIC(10,2)</code> means up to 10 digits total, 2 after the decimal point.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Common Data Types</b></li>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>INTEGER</code>, <code>BIGINT</code>, <code>SMALLINT</code></td>
                <td>42</td>
                <td>Whole numbers, various ranges.</td>
            </tr>
            <tr>
                <td><code>NUMERIC(p, s)</code></td>
                <td>1234.56</td>
                <td>Fixed-point precision numbers (money, totals).</td>
            </tr>
            <tr>
                <td><code>TEXT</code>, <code>VARCHAR(n)</code>, <code>CHAR(n)</code></td>
                <td>'Hello'</td>
                <td>Variable or fixed-length strings.</td>
            </tr>
            <tr>
                <td><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code></td>
                <td>'2025-01-01'</td>
                <td>Date and time storage.</td>
            </tr>
            <tr>
                <td><code>BOOLEAN</code></td>
                <td>TRUE / FALSE</td>
                <td>Logical values.</td>
            </tr>
            <tr>
                <td><code>JSON</code>, <code>JSONB</code></td>
                <td>'{"key": "value"}'</td>
                <td>Structured JSON data (JSONB is binary-optimized).</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Creating Tables in a Specific Schema</b></li>
<pre><code class="language-sql line-numbers">CREATE SCHEMA company;

CREATE TABLE company.departments (
    id   INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);
</code></pre>
    <br/>
    <ul>
        <li>By default, PostgreSQL creates tables under the <code>public</code> schema.</li>
        <li>Use <code>CREATE SCHEMA</code> to organize tables logically (e.g., per project or domain).</li>
        <li>You can qualify table names like <code>schema_name.table_name</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Tables</b></li>
<pre><code class="language-sql line-numbers">-- List all tables in current database
\dt

-- List tables in a specific schema
\dt company.*

-- Show table structure
\d employees
</code></pre>
    <br/>
    <ul>
        <li>These commands are used inside the <code>psql</code> interactive terminal.</li>
        <li><code>\dt</code> lists tables, <code>\d &lt;table&gt;</code> describes structure, columns, and constraints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Altering or Dropping Tables</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees ADD COLUMN email TEXT;
ALTER TABLE employees DROP COLUMN active;
DROP TABLE employees;
</code></pre>
    <br/>
    <ul>
        <li><code>ALTER TABLE</code> allows adding/removing columns or modifying constraints.</li>
        <li><code>DROP TABLE</code> permanently deletes the table (and all its data).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Understanding Schemas in PostgreSQL</h3>
<ol>
    <li><b>What is a Schema?</b></li>
    <br/>
    <ul>
        <li>A <b>schema</b> in PostgreSQL is like a <u>folder</u> or <u>namespace</u> inside a database.</li>
        <br/>
        <li>Each schema contains its own set of tables, views, functions, and other objects — just like different folders can contain different files.</li>
        <br/>
        <li>This allows you to:
            <ul>
                <li>Organize your database objects logically (e.g. <code>hr.employees</code>, <code>sales.orders</code>).</li>
                <li>Have tables with the same name in different schemas without conflict (e.g. <code>test.users</code> vs <code>prod.users</code>).</li>
                <li>Control access permissions at a schema level.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Database vs Schema</b></li>
    <br/>
    <ul>
        <li>PostgreSQL databases are the top-level containers.</li>
        <br/>
        <li>A schema lives <u>inside</u> a database, and tables live inside a schema.</li>
    </ul>
<pre><code class="language-text">
Database → Schema → Table → Row
</code></pre>
    <br/>
    <ul>
        <li>For example, you might have a database called <code>company_db</code>, which contains two schemas:</li>
    </ul>
<pre><code class="language-text">
company_db
 ├── public
 │    ├── employees
 │    ├── departments
 │
 └── analytics
      ├── sales_summary
      ├── monthly_reports
</code></pre>
    <br/>
    <ul>
        <li>This way, you can separate your operational data (<code>public</code>) from analytical data (<code>analytics</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Default Schema: public</b></li>
    <br/>
    <ul>
        <li>When you first create a new database, PostgreSQL automatically creates a schema named <code>public</code>.</li>
        <br/>
        <li>Unless you specify otherwise, every table, view, or function you create goes into the <code>public</code> schema.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- This table is created inside the default "public" schema
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li>Its full name is actually <code>public.users</code>, even if you normally omit the schema prefix.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating a Custom Schema</b></li>
<pre><code class="language-sql line-numbers">CREATE SCHEMA hr;
CREATE SCHEMA sales;
</code></pre>
    <br/>
    <ul>
        <li>Now you have two additional namespaces: <code>hr</code> and <code>sales</code>.</li>
        <br/>
        <li>You can create tables inside them using a schema-qualified name:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE hr.employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    position TEXT
);

CREATE TABLE sales.orders (
    id SERIAL PRIMARY KEY,
    amount NUMERIC(10,2),
    customer TEXT
);
</code></pre>
    <br/>
    <ul>
        <li>Now <code>hr.employees</code> and <code>sales.orders</code> are two independent tables, even though both live in the same database.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing Tables in Schemas</b></li>
<pre><code class="language-sql line-numbers">-- Access table using schema-qualified name
SELECT * FROM hr.employees;

-- Access table from the default "public" schema
SELECT * FROM public.users;
</code></pre>
    <br/>
    <ul>
        <li>You always access tables by <code>schema_name.table_name</code>.</li>
        <br/>
        <li>If you omit the schema, PostgreSQL looks for the table in the schemas listed in the current <b>search_path</b> (see below).</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Search Path</b></li>
    <br/>
    <ul>
        <li>The <b>search_path</b> is the list of schemas that PostgreSQL looks through when you reference an object without a schema prefix.</li>
        <br/>
        <li>By default, it is usually:</li>
    </ul>
<pre><code class="language-sql line-numbers">SHOW search_path;

-- Output example:
-- "public", "$user"
</code></pre>
    <br/>
    <ul>
        <li>This means:
            <ul>
                <li>First, PostgreSQL looks for the object in <code>public</code>.</li>
                <li>Then, it looks for a schema with the same name as the current user.</li>
            </ul>
        </li>
        <br/>
        <li>You can change the search path to prioritize another schema:</li>
    </ul>
<pre><code class="language-sql line-numbers">SET search_path TO hr, public;

-- Now "employees" means "hr.employees"
SELECT * FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>When working on large projects, this helps you avoid writing <code>hr.</code> or <code>sales.</code> all the time.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Schema</b></li>
<pre><code class="language-sql line-numbers">DROP SCHEMA hr;

-- Or remove all its objects automatically:
DROP SCHEMA hr CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>DROP SCHEMA hr;</code> will fail if the schema is not empty.</li>
        <li><code>CASCADE</code> deletes the schema and all contained tables, views, and functions.</li>
        <li>Use <code>CASCADE</code> with caution — this is irreversible!</li>
    </ul>
    <br/>
    <br/>


    <li><b>Schema Permissions</b></li>
    <br/>
    <ul>
        <li>You can grant or revoke access to schemas independently of table permissions.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- Grant a user permission to create objects in a schema
GRANT CREATE ON SCHEMA sales TO alice;

-- Allow a user to use (read from) the schema
GRANT USAGE ON SCHEMA hr TO bob;
</code></pre>
    <br/>
    <ul>
        <li><code>USAGE</code> allows access to existing objects inside the schema.</li>
        <li><code>CREATE</code> allows creating new objects within that schema.</li>
        <li>Combining these allows a user to both read and create inside that namespace.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to Use Schemas</b></li>
    <br/>
    <ul>
        <li><b>Organizing modules</b>: for example, <code>hr</code>, <code>finance</code>, and <code>sales</code> schemas in a company database.</li>
        <br/>
        <li><b>Separating environments</b>: e.g., <code>dev</code>, <code>test</code>, <code>prod</code> schemas in the same database for testing purposes.</li>
        <br/>
        <li><b>Multi-tenant applications</b>: one schema per customer, while keeping all data in a single database.</li>
        <br/>
        <li><b>Access control</b>: different roles can have access to different schemas.</li>
    </ul>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <li>A <b>schema</b> is a namespace inside a PostgreSQL database that groups related tables and objects together.</li>
        <br/>
        <li>By default, all objects go into the <code>public</code> schema, but you can create your own with <code>CREATE SCHEMA</code>.</li>
        <br/>
        <li>Access tables as <code>schema_name.table_name</code>, or adjust <code>search_path</code> for convenience.</li>
        <br/>
        <li>Use schemas to organize projects, control permissions, and keep your database clean and modular.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Inserting Data into Tables</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Once you've created a table, you can add rows of data using the <code>INSERT INTO</code> statement.</li>
        <br/>
        <li>Each inserted row corresponds to one record in the table, containing values for one or more columns.</li>
        <br/>
        <li>PostgreSQL allows flexible insertion:
            <ul>
                <li>Insert all columns at once.</li>
                <li>Insert into selected columns only.</li>
                <li>Insert multiple rows in a single command.</li>
                <li>Insert data from another table or query.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO &lt;table_name&gt; (&lt;column1&gt;, &lt;column2&gt;, &lt;column3&gt;, ...)
VALUES (&lt;value1&gt;, &lt;value2&gt;, &lt;value3&gt;, ...);
</code></pre>
    <br/>
    <br/>


    <li><b>Example: Simple Insert</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES ('Alice', 'Johnson', 'Engineering');
</code></pre>
    <br/>
    <ul>
        <li>The <code>employee_id</code> column (if auto-generated) does not need to be specified, PostgreSQL fills it automatically.</li>
        <li>String literals are enclosed in single quotes (<code>'...'</code>).</li>
        <li>After execution, a new row appears in <code>employees</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting into All Columns</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees
VALUES (DEFAULT, 'Bob', 'Smith', 'Sales');
</code></pre>
    <br/>
    <ul>
        <li>If you omit the column list, you must provide a value for every column in order.</li>
        <li>Use <code>DEFAULT</code> to let PostgreSQL fill an auto-generated value (like an identity or timestamp).</li>
        <li>This form is more error-prone — prefer naming columns explicitly when possible.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Multiple Rows at Once</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES
    ('Charlie', 'Wang', 'Finance'),
    ('Diana', 'Lopez', 'Marketing'),
    ('Ethan', 'Neuer', 'IT');
</code></pre>
    <br/>
    <ul>
        <li>This is faster and cleaner than running multiple <code>INSERT</code> statements.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name)
VALUES ('Frank', 'Baker');

INSERT INTO employees (first_name, last_name, department)
VALUES ('Grace', 'Kim', DEFAULT);
</code></pre>
    <br/>
    <ul>
        <li>If a column has a <code>DEFAULT</code> value, you can omit it or explicitly use <code>DEFAULT</code>.</li>
        <li>In both cases, PostgreSQL automatically fills in the default.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Data from Another Table</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO archived_employees (first_name, last_name, department)
SELECT first_name, last_name, department
FROM employees
WHERE active = FALSE;
</code></pre>
    <br/>
    <ul>
        <li>Instead of manually typing values, you can pull data from an existing table or query.</li>
        <li>This is useful for:
            <ul>
                <li>Archiving old records,</li>
                <li>Duplicating data,</li>
                <li>Creating backups or subsets.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Returning Values After Insert</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES ('Helene', 'Zabak', 'Operations')
RETURNING employee_id;
</code></pre>
    <br/>
    <ul>
        <li>The <code>RETURNING</code> clause immediately outputs data from the newly inserted row(s).</li>
        <li>You can return multiple columns:
<pre><code class="language-sql line-numbers">RETURNING employee_id, first_name, hire_date;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling Conflicts (Upserts)</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (employee_id, first_name, last_name, department)
VALUES (1, 'Ian', 'Miller', 'Engineering')
ON CONFLICT (employee_id) DO UPDATE SET department = EXCLUDED.department;
</code></pre>
    <br/>
    <ul>
        <li><code>ON CONFLICT</code> handles cases where an insert violates a unique or primary key constraint.</li>
        <li><code>EXCLUDED</code> refers to the new row that caused the conflict.</li>
        <li>You can:
            <ul>
                <li><code>DO NOTHING</code> to skip the row, or</li>
                <li><code>DO UPDATE</code> to modify the existing row.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Full Insert Scenario</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    id           SERIAL PRIMARY KEY,
    name         TEXT NOT NULL,
    email        TEXT UNIQUE,
    created_at   TIMESTAMP DEFAULT NOW()
);

INSERT INTO customers (name, email)
VALUES
    ('Alice Green', 'alice@example.com'),
    ('Bob White', 'bob@example.com');

INSERT INTO customers (name, email)
VALUES ('Alice Green', 'alice@example.com')
ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
</code></pre>
    <br/>
    <ul>
        <li>The first insert adds two new customers.</li>
        <li>The second one updates an existing customer (instead of erroring) because of the <code>ON CONFLICT</code> rule.</li>
        <li><code>NOW()</code> automatically sets the timestamp.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics on Selecting Data from Tables</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>SELECT</code> statement in PostgreSQL is used to <u>query</u> data from one or more tables.</li>
        <br/>
        <li>PostgreSQL processes <code>SELECT</code> queries logically in this order:
<pre><code class="language-text">FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT</code></pre>
        </li>
        <br/>
        <li>This order matters when you design complex queries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT &lt;column1&gt;, &lt;column2&gt;, ...
FROM &lt;table_name&gt;;
</code></pre>
    <br/>
    <ul>
        <li>You can select all columns using <code>*</code>, but it's better to specify only what you need.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Select All Columns</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>Retrieves every column and every row from <code>employees</code>.</li>
        <li>Useful for quick checks, but inefficient in production queries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Rows with WHERE</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name
FROM employees
WHERE department = 'Engineering';
</code></pre>
    <br/>
    <ul>
        <li><code>WHERE</code> filters rows based on a condition.</li>
        <li>Operators include:
            <ul>
                <li><code>=</code> equal</li>
                <li><code>&lt;&gt;</code> or <code>!=</code> not equal</li>
                <li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
                <li><code>AND</code>, <code>OR</code>, <code>NOT</code> for logical combinations</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering with Pattern Matching (LIKE)</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name
FROM employees
WHERE last_name LIKE 'S%';
</code></pre>
    <br/>
    <ul>
        <li><code>LIKE</code> is used for pattern matching with wildcards:
            <ul>
                <li><code>%</code>: matches any sequence of characters.</li>
                <li><code>_</code>: matches exactly one character.</li>
            </ul>
        </li>
        <li>Example: <code>'S%'</code> finds all last names starting with "S".</li>
    </ul>
    <br/>
    <br/>


    <li><b>Sorting Results with ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name, hire_date
FROM employees
ORDER BY hire_date DESC;
</code></pre>
    <br/>
    <ul>
        <li><code>ORDER BY</code> sorts rows by one or more columns.</li>
        <li>Use <code>ASC</code> (default) or <code>DESC</code> for descending order.</li>
        <li>You can sort by multiple columns:
<pre><code class="language-sql line-numbers">ORDER BY department ASC, last_name ASC;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Limiting Results with LIMIT and OFFSET</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
ORDER BY employee_id
LIMIT 5 OFFSET 10;
</code></pre>
    <br/>
    <ul>
        <li><code>LIMIT</code> restricts how many rows are returned.</li>
        <li><code>OFFSET</code> skips the given number of rows before starting output.</li>
        <li>Commonly used for pagination (e.g., "page 3, 10 results per page").</li>
    </ul>
    <br/>
    <br/>


    <li><b>Aliasing Columns and Tables</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name AS given,
    last_name AS family
FROM employees AS e;
</code></pre>
    <br/>
    <ul>
        <li>Aliases give temporary names to columns or tables for readability.</li>
        <li>You can omit <code>AS</code>, both forms work:
<pre><code class="language-sql line-numbers">SELECT first_name given, last_name family FROM employees e;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name, department
FROM employees
WHERE department = 'Sales'
    AND hire_date &gt;= '2024-01-01'
    OR active = TRUE;
</code></pre>
    <br/>
    <ul>
        <li>Use parentheses to control logical order:
<pre><code class="language-sql line-numbers">WHERE (department = 'Sales' AND hire_date &gt;= '2024-01-01') OR active = TRUE;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Distinct Rows</b></li>
<pre><code class="language-sql line-numbers">SELECT DISTINCT department
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li><code>DISTINCT</code> removes duplicate rows from the result set.</li>
        <li>You can apply it to one or multiple columns:
<pre><code class="language-sql line-numbers">SELECT DISTINCT department, active FROM employees;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Computed Columns and Expressions</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name,
    EXTRACT(YEAR FROM hire_date)   AS hire_year
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>You can create new columns by combining or transforming existing ones.</li>
        <li><code>||</code> concatenates strings.</li>
        <li><code>EXTRACT()</code> extracts a specific part (like year, month, day) from a date or timestamp.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Aggregating Data with GROUP BY</b></li>
<pre><code class="language-sql line-numbers">SELECT
    department,
    COUNT(*) AS total_employees
FROM employees
GROUP BY department;
</code></pre>
    <br/>
    <ul>
        <li><code>GROUP BY</code> groups rows by unique combinations of column values.</li>
        <li>Often used with aggregate functions:
            <ul>
                <li><code>COUNT()</code>: number of rows.</li>
                <li><code>SUM()</code>: total sum.</li>
                <li><code>AVG()</code>: average.</li>
                <li><code>MIN()</code> / <code>MAX()</code>: smallest / largest value.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Groups with HAVING</b></li>
<pre><code class="language-sql line-numbers">SELECT department, COUNT(*) AS total_employees
FROM employees
GROUP BY department
HAVING COUNT(*) &gt; 5;
</code></pre>
    <br/>
    <ul>
        <li><code>HAVING</code> filters groups (after aggregation), while <code>WHERE</code> filters individual rows (before aggregation).</li>
        <li>Example: only show departments with more than 5 employees.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Results with UNION</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name FROM employees
UNION
SELECT first_name, last_name FROM contractors;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION</code> merges two result sets and removes duplicates.</li>
        <li>Use <code>UNION ALL</code> to keep duplicates.</li>
        <li>Each <code>SELECT</code> must have the same number and type of columns.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Concatenating Strings in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>String concatenation means joining two or more strings together into a single text value.</li>
        <br/>
        <li>In PostgreSQL, you can concatenate strings using:
            <ul>
                <li>The concatenation operator <code>||</code> (most common and SQL-standard).</li>
                <li>The <code>CONCAT()</code> function.</li>
                <li>The <code>CONCAT_WS()</code> function (concatenate with a separator).</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using the || Operator</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || ' ' || 'World' AS greeting;
</code></pre>
    <br/>
    <ul>
        <li>The <code>||</code> operator joins strings directly.</li>
        <li>In this example, PostgreSQL returns <code>Hello World</code>.</li>
        <li>You can concatenate columns and literals together as well:</li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name
FROM employees;
</code></pre>
        <li>This is the most widely used approach for text combination in PostgreSQL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling NULLs with ||</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || NULL || 'World' AS result;
</code></pre>
    <br/>
    <ul>
        <li>If any operand is <code>NULL</code>, the entire concatenated result becomes <code>NULL</code>.</li>
        <li>Example result: <code>NULL</code>.</li>
        <li>To avoid this, use the <code>COALESCE()</code> function to replace <code>NULL</code> with an empty string:</li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || COALESCE(NULL, '') || 'World' AS safe_concat;</code></pre>
        <li>Result: <code>HelloWorld</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CONCAT()</b></li>
<pre><code class="language-sql line-numbers">SELECT CONCAT('Hello', ' ', 'World') AS greeting;
</code></pre>
    <br/>
    <ul>
        <li><code>CONCAT()</code> joins any number of arguments together.</li>
        <li>Unlike <code>||</code>, it automatically treats <code>NULL</code> as an empty string.</li>
        <li>Example:</li>
<pre><code class="language-sql line-numbers">SELECT CONCAT('Hello', NULL, 'World') AS greeting;</code></pre>
        <li>Result: <code>HelloWorld</code> (not <code>NULL</code>).</li>
        <li>This makes <code>CONCAT()</code> safer when dealing with nullable columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CONCAT_WS() — Concatenate with Separator</b></li>
<pre><code class="language-sql line-numbers">SELECT CONCAT_WS('-', '2025', '11', '10') AS formatted_date;
</code></pre>
    <br/>
    <ul>
        <li><code>CONCAT_WS(separator, arg1, arg2, ...)</code> stands for "Concatenate With Separator."</li>
        <li>The first argument is used as the separator between all other arguments.</li>
        <li><code>NULL</code> values are ignored automatically.</li>
        <li>Example with <code>NULL</code>:
<pre><code class="language-sql line-numbers">SELECT CONCAT_WS(' ', 'Alice', NULL, 'Johnson');</code></pre>
        <li>Result: <code>Alice Johnson</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concatenating Columns Example</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name,
    department || ' Department'    AS dept_name
FROM employees;
</code></pre>
    <br/>
    <br/>


    <li><b>Concatenation in UPDATE Statements</b></li>
<pre><code class="language-sql line-numbers">UPDATE employees
SET full_name = first_name || ' ' || last_name;
</code></pre>
    <br/>
    <ul>
        <li>You can use concatenation when updating data, for example, to fill a derived column.</li>
        <li>PostgreSQL evaluates the expressions on the right-hand side for each row.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concatenation with Numbers and Other Types</b></li>
<pre><code class="language-sql line-numbers">SELECT
    'Employee ID: ' || employee_id AS label
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL automatically casts numbers, booleans, and dates to text when concatenated with a string.</li>
        <li>You can also use explicit conversion for clarity:</li>
<pre><code class="language-sql line-numbers">SELECT 'Employee ID: ' || CAST(employee_id AS TEXT) FROM employees;</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting Example: Full Address</b></li>
<pre><code class="language-sql line-numbers">SELECT
    CONCAT_WS(', ',
        street,
        city,
        postal_code,
        country
    ) AS full_address
FROM customers;
</code></pre>
    <br/>
    <ul>
        <li>This builds a clean formatted address string, skipping <code>NULL</code> parts automatically.</li>
        <li>Example result: <code>"Main Street 5, Berlin, 10115, Germany"</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Dropping Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>DROP TABLE</code> statement permanently removes a table and all its data from a PostgreSQL database.</li>
        <br/>
        <li>When you drop a table, PostgreSQL deletes:
            <ul>
                <li>All rows stored in the table.</li>
                <li>Associated indexes and constraints.</li>
                <li>Any dependent objects (if you use <code>CASCADE</code>).</li>
            </ul>
        </li>
        <br/>
        <li>Once dropped, the data <mark>cannot</mark> be recovered unless you have a backup.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE &lt;table_name&gt;;
</code></pre>
    <br/>
    <ul>
        <li><code>table_name</code> — the name of the table you want to delete.</li>
        <li>If the table doesn't exist, PostgreSQL will raise an error unless you use <code>DROP TABLE IF EXISTS</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Dropping a Table</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE employees;
</code></pre>
    <br/>
    <ul>
        <li>Deletes the <code>employees</code> table completely from the database.</li>
        <li>All its data, indexes, and constraints are removed permanently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Safely Dropping a Table</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE IF EXISTS employees;
</code></pre>
    <br/>
    <ul>
        <li>Prevents an error if the table does not exist.</li>
        <li>This is a safer way to clean up tables, especially in scripts or migrations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping Multiple Tables</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE IF EXISTS employees, departments, projects;
</code></pre>
    <br/>
    <ul>
        <li>You can drop multiple tables in one command by separating their names with commas.</li>
        <li>Each table will be dropped in the order listed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CASCADE and RESTRICT</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE employees CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>CASCADE</code> automatically drops any dependent objects (like foreign keys in other tables, views, or triggers).</li>
        <li>Use carefully — this can remove more than you expect!</li>
        <li>To prevent accidental cascade deletion, use <code>RESTRICT</code> (the default behavior):</li>
<pre><code class="language-sql line-numbers">DROP TABLE employees RESTRICT;</code></pre>
        <li>PostgreSQL will refuse to drop the table if anything depends on it.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Example: Dropping with Dependencies</b></li>
<pre><code class="language-sql line-numbers">-- Example: "customers" table references "orders" through a foreign key
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY
);

CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id)
);

-- Dropping the parent table with CASCADE
DROP TABLE orders CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>CASCADE</code> tells PostgreSQL to remove not only the <code>orders</code> table itself, but also any <u>objects that depend on it</u> — such as foreign key constraints, views, or triggers.</li>
        <br/>
        <li>In this example:
            <ul>
                <li>The table <code>orders</code> is permanently deleted.</li>
                <li>The foreign key constraint (inside <code>customers</code>) is automatically removed, so <code>customers.order_id</code> can take whatever values it wants in the future.</li>
                <li>The <code>customers</code> table itself remains intact — only the relationship to <code>orders</code> is dropped.</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL will also print a notice similar to:
<pre><code class="language-text">NOTICE:  drop cascades to constraint customers_order_id_fkey on table customers
DROP TABLE
</code></pre>
        </li>
        <br/>
        <li>Always double-check before using <code>CASCADE</code>, as it can remove multiple dependent objects automatically.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Dropping a Table in a Specific Schema</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE company.employees;
</code></pre>
    <br/>
    <ul>
        <li>If the table belongs to a non-default schema, include the schema name.</li>
        <li>Example: <code>company.employees</code> drops the <code>employees</code> table inside the <code>company</code> schema.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking if a Table Exists</b></li>
<pre><code class="language-sql line-numbers">-- Using psql meta-command
\dt

-- Or query the catalog directly
SELECT tablename
FROM pg_catalog.pg_tables
WHERE tablename = 'employees';
</code></pre>
    <br/>
    <ul>
        <li><code>\dt</code> lists all tables in the current database (works in <code>psql</code>).</li>
        <li>Alternatively, query the <code>pg_catalog.pg_tables</code> system table to check existence programmatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Practical Tip: Use Transactions</b></li>
<pre><code class="language-sql line-numbers">BEGIN;
DROP TABLE employees;
ROLLBACK;
</code></pre>
    <br/>
    <ul>
        <li>During testing, wrap <code>DROP TABLE</code> inside a transaction.</li>
        <li><code>ROLLBACK</code> cancels the deletion if you change your mind before committing.</li>
        <li>This helps prevent irreversible data loss while experimenting.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Filtering Rows with the WHERE Clause</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>WHERE</code> clause in PostgreSQL filters rows returned by a <code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement based on one or more conditions.</li>
        <br/>
        <li>It is evaluated <u>before</u> grouping or ordering results — only rows satisfying the condition(s) are kept.</li>
        <br/>
        <li>You can use logical operators (<code>AND</code>, <code>OR</code>, <code>NOT</code>), comparison operators (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, etc.), and range or set operators like <code>BETWEEN</code>, <code>IN</code>, and <code>LIKE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT column1, column2, ...
FROM table_name
WHERE condition;
</code></pre>
    <br/>
    <ul>
        <li><code>condition</code> can include comparisons, logical connectors, or functions that evaluate to <code>TRUE</code> or <code>FALSE</code>.</li>
        <li>Rows for which the condition is <code>TRUE</code> are returned; <code>FALSE</code> or <code>NULL</code> rows are excluded.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Operators</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Engineering';
</code></pre>
    <br/>
    <ul>
        <li><b>Common operators:</b></li>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
                <tr><td><code>=</code></td><td>Equal to</td><td><code>salary = 50000</code></td></tr>
                <tr><td><code>&lt;&gt;</code> or <code>!=</code></td><td>Not equal to</td><td><code>department &lt;&gt; 'IT'</code></td></tr>
                <tr><td><code>&gt;</code></td><td>Greater than</td><td><code>age &gt; 30</code></td></tr>
                <tr><td><code>&lt;</code></td><td>Less than</td><td><code>salary &lt; 40000</code></td></tr>
                <tr><td><code>&gt;=</code></td><td>Greater than or equal to</td><td><code>age &gt;= 18</code></td></tr>
                <tr><td><code>&lt;=</code></td><td>Less than or equal to</td><td><code>hire_date &lt;= '2025-01-01'</code></td></tr>
            </tbody>
        </table>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Conditions with AND, OR, NOT</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Sales'
    AND hire_date &gt;= '2024-01-01'
    OR active = TRUE;
</code></pre>
    <br/>
    <ul>
        <li>It is recommended to use parentheses for clarity:
<pre><code class="language-sql line-numbers">WHERE (department = 'Sales' AND hire_date &gt;= '2024-01-01') OR active = TRUE;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Ranges with BETWEEN</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE salary BETWEEN 40000 AND 60000;
</code></pre>
    <br/>
    <ul>
        <li><code>BETWEEN a AND b</code> is equivalent to <code>(salary &gt;= a AND salary &lt;= b)</code>.</li>
        <li>It <u>includes</u> both boundary values.</li>
        <li>You can use it with dates, numbers, or text:</li>
<pre><code class="language-sql line-numbers">WHERE hire_date BETWEEN '2024-01-01' AND '2024-12-31';</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering by a Set with IN</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department IN ('HR', 'IT', 'Finance');
</code></pre>
    <br/>
    <ul>
        <li><code>IN</code> checks whether a value matches any value in the provided list.</li>
        <li>Equivalent to multiple <code>OR</code> conditions:</li>
<pre><code class="language-sql line-numbers">WHERE department = 'HR' OR department = 'IT' OR department = 'Finance';</code></pre>
        <li>You can also use a subquery:
<pre><code class="language-sql line-numbers">WHERE department_id IN (SELECT id FROM departments WHERE active = TRUE);</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Pattern Matching with LIKE and ILIKE</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE last_name LIKE 'S%';
</code></pre>
    <br/>
    <ul>
        <li><code>LIKE</code> is case-sensitive pattern matching.</li>
        <li><code>ILIKE</code> is the case-insensitive version (PostgreSQL extension).</li>
        <li>Examples:</li>
<pre><code class="language-sql line-numbers">WHERE name LIKE  'A%';      -- starts with A
WHERE name LIKE  '%son';    -- ends with son
WHERE name ILIKE '%SMITH%'; -- contains 'smith' (case-insensitive)
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering NULL Values</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department IS NULL;

SELECT * FROM employees
WHERE department IS NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li><code>= NULL</code> does <u>not</u> work — use <code>IS NULL</code> and <code>IS NOT NULL</code>.</li>
        <li>This is because <code>NULL</code> represents "unknown", not an actual value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Membership with EXISTS</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.id = e.department_id
);
</code></pre>
    <br/>
    <ul>
        <li><code>EXISTS</code> checks whether a subquery returns at least one row.</li>
        <li>If it does, the condition is <code>TRUE</code>, otherwise <code>FALSE</code>.</li>
        <li>Often used for correlated subqueries and conditional joins.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using ANY and ALL</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE salary &gt; ANY (SELECT salary FROM interns);

SELECT * FROM employees
WHERE salary &gt; ALL (SELECT salary FROM interns);
</code></pre>
    <br/>
    <ul>
        <li><code>ANY</code> — condition is true if it holds for <u>at least one</u> value returned by the subquery.</li>
        <li><code>ALL</code> — condition must hold for <u>every</u> value returned by the subquery.</li>
        <li>These are useful when comparing against ranges of values dynamically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Multiple Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Finance'
    AND (salary BETWEEN 40000 AND 60000)
    AND active = TRUE
    AND last_name ILIKE 'J%';
</code></pre>
    <br/>
    <ul>
        <li>Conditions can be chained together in flexible and readable ways.</li>
        <li>Parentheses make the logic explicit and prevent ambiguity.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Database Design in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Database design</u> is the process of organizing data into structured tables that represent real-world entities and their relationships.</li>
        <br/>
        <li>Good design ensures:
            <ul>
                <li>Data integrity (accuracy and consistency).</li>
                <li>Scalability (efficient growth with more data).</li>
                <li>Performance (fast queries and updates).</li>
                <li>Maintainability (easy schema evolution and clear relationships).</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL, as a relational database, uses <b>tables</b>, <b>keys</b>, and <b>relationships</b> to represent structured data logically and efficiently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 1: Identify Entities and Attributes</b></li>
    <br/>
    <ul>
        <li>Begin by identifying <b>entities</b> — objects or concepts you need to store data about (e.g. <code>customers</code>, <code>orders</code>, <code>products</code>).</li>
        <br/>
        <li>For each entity, determine its <b>attributes</b> — descriptive properties or fields.</li>
    </ul>
<pre><code class="language-text">
Entity: Customer
 ├── customer_id (primary key)
 ├── name
 ├── email
 └── phone

Entity: Order
 ├── order_id (primary key)
 ├── customer_id (foreign key)
 ├── order_date
 └── total_amount
</code></pre>
    <br/>
    <ul>
        <li>Each entity becomes a table, and each attribute becomes a column.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 2: Define Primary Keys</b></li>
    <br/>
    <ul>
        <li>A <b>primary key</b> uniquely identifies each row in a table.</li>
        <li>PostgreSQL commonly uses:
            <ul>
                <li><code>SERIAL</code> or <code>IDENTITY</code> columns for numeric IDs.</li>
                <li>Or <code>UUID</code> for globally unique identifiers.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name        TEXT NOT NULL,
    email       TEXT UNIQUE
);
</code></pre>
    <br/>
    <ul>
        <li>Each table should have exactly ONE primary key column or a composite key (a combination of multiple columns) when necessary.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 3: Define Relationships with Foreign Keys</b></li>
    <br/>
    <ul>
        <li><u>Foreign keys</u> define relationships between tables by referencing primary keys of other tables.</li>
        <li>They maintain <u>referential integrity</u>, ensuring that related data exists before referencing it.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id     SERIAL PRIMARY KEY,
    customer_id  INT REFERENCES customers(customer_id),
    order_date   DATE NOT NULL DEFAULT CURRENT_DATE,
    total_amount NUMERIC(10,2)
);
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>orders.customer_id</code> links each order to its corresponding customer.</li>
        <li>You can specify actions like <code>ON DELETE CASCADE</code> or <code>ON UPDATE SET NULL</code> for dependency behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 4: Normalize Your Data</b></li>
    <br/>
    <ul>
        <li><u>Normalization</u> is the process of structuring data to reduce redundancy and improve consistency.</li>
        <br/>
        <li>Common normal forms:
            <ul>
                <li><b>1NF (First Normal Form)</b> — No repeating groups or arrays, every field holds atomic values.</li>
                <li><b>2NF (Second Normal Form)</b> — Every non-key attribute depends entirely on the primary key.</li>
                <li><b>3NF (Third Normal Form)</b> — No transitive dependencies (non-key columns shouldn't depend on other non-key columns).</li>
            </ul>
        </li>
        <br/>
        <li>Example — Unnormalized table:</li>
<pre><code class="language-text">
orders
 ├── order_id
 ├── customer_name
 ├── customer_email
 ├── product_1
 ├── product_2
</code></pre>
        <li>Normalized design:</li>
<pre><code class="language-text">
customers
 ├── customer_id
 ├── name
 ├── email

orders
 ├── order_id
 ├── customer_id
 ├── order_date

order_items
 ├── order_id
 ├── product_id
 ├── quantity
</code></pre>
        <li>This separation avoids data duplication and keeps relationships clear.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 5: Add Constraints and Data Integrity Rules</b></li>
    <br/>
    <ul>
        <li>Constraints enforce rules at the database level:
            <ul>
                <li><code>NOT NULL</code> — prevents missing values.</li>
                <li><code>UNIQUE</code> — ensures no duplicates.</li>
                <li><code>CHECK</code> — validates data according to conditions.</li>
                <li><code>DEFAULT</code> — sets fallback values automatically.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    id        SERIAL PRIMARY KEY,
    name      TEXT NOT NULL,
    salary    NUMERIC(8,2) CHECK (salary &gt;= 0),
    active    BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>These ensure that invalid or inconsistent data cannot be inserted even by mistake.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 6: Use Indexes for Performance</b></li>
    <br/>
    <ul>
        <li><u>Indexes</u> speed up data retrieval by allowing faster lookups on large tables.</li>
        <li>PostgreSQL automatically creates an index for primary and unique keys, but you can add more as needed.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_employees_department ON employees(department);
</code></pre>
    <br/>
    <ul>
        <li>Use indexes wisely — they make reads faster but can slow down inserts and updates.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 7: Consider Denormalization (for Performance)</b></li>
    <br/>
    <ul>
        <li>In some high-performance or reporting cases, you may intentionally duplicate certain data to avoid complex joins.</li>
        <li>This is called <u>denormalization</u> — used to trade storage for speed.</li>
        <li>Example: storing <code>customer_name</code> directly inside <code>orders</code> for faster querying, even though it's also in <code>customers</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 8: Plan for Relationships — One-to-Many and Many-to-Many</b></li>
    <br/>
    <ul>
        <li><b>One-to-Many</b> — a customer can have many orders.</li>
<pre><code class="language-sql line-numbers">-- one-to-many
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
);
</code></pre>
        <li><b>Many-to-Many</b> — students can take many courses, and each course has many students.</li>
<pre><code class="language-sql line-numbers">-- many-to-many through a junction table
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id  INT REFERENCES courses(id),
    PRIMARY KEY (student_id, course_id)
);
</code></pre>
        <li>Use junction (bridge) tables for many-to-many relationships.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 9: Naming Conventions and Documentation</b></li>
    <br/>
    <ul>
        <li>Consistent naming improves readability and maintainability:
            <ul>
                <li>Use <code>snake_case</code> for all identifiers (e.g. <code>order_date</code>).</li>
                <li>Plural names for tables (<code>employees</code>, <code>orders</code>).</li>
                <li>Singular names for columns (<code>employee_id</code>).</li>
                <li>Prefix foreign keys with the table they reference (e.g. <code>customer_id</code> in <code>orders</code>).</li>
            </ul>
        </li>
        <li>Document your schema using comments:</li>
<pre><code class="language-sql line-numbers">COMMENT ON TABLE employees IS 'Stores employee data for the company';
COMMENT ON COLUMN employees.salary IS 'Monthly gross salary in euros';
</code></pre>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Primary Keys in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>primary key</u> is a column (or a group of columns) that uniquely identifies each row in a table.</li>
        <br/>
        <li>It ensures that:
            <ul>
                <li>No two rows have the same primary key value.</li>
                <li>The primary key value is never <code>NULL</code>.</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL automatically creates a unique <u>index</u> for every primary key to speed up lookups and enforce uniqueness.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type PRIMARY KEY,
    other_column data_type
);
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>PRIMARY KEY</code> constraint on a column to define it as the table's unique identifier.</li>
        <li>PostgreSQL automatically makes that column <code>NOT NULL</code> and <code>UNIQUE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple Primary Key</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li><code>SERIAL</code> automatically creates an integer column with an internal sequence generator.</li>
        <li>The primary key constraint guarantees that every <code>employee_id</code> value is unique and non-null.</li>
        <li>Primary keys are often numeric because they are efficient for indexing and joining tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using GENERATED AS IDENTITY (Modern SQL)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE departments (
    dept_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name    TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is the SQL-standard replacement for <code>SERIAL</code>.</li>
        <li>PostgreSQL manages the sequence automatically and ensures strict consistency.</li>
        <li>You can also use <code>GENERATED BY DEFAULT AS IDENTITY</code> to allow manual insertion of custom IDs if necessary.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Composite (Multi-Column) Primary Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE enrollments (
    student_id INT NOT NULL,
    course_id  INT NOT NULL,
    enrollment_date DATE DEFAULT CURRENT_DATE,
    PRIMARY KEY (student_id, course_id)
);
</code></pre>
    <br/>
    <ul>
        <li>Composite keys use multiple columns to uniquely identify a record.</li>
        <li>Here, the combination of <code>student_id</code> and <code>course_id</code> must be unique — but each one individually may repeat.</li>
        <li>Common in many-to-many relationship tables (also called junction tables).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a Primary Key to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ADD CONSTRAINT employees_pkey PRIMARY KEY (employee_id);
</code></pre>
    <br/>
    <ul>
        <li>If the table was created without a primary key, you can add one later using <code>ALTER TABLE</code>.</li>
        <li>The constraint name (here <code>employees_pkey</code>) can be chosen manually or left for PostgreSQL to assign automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Primary Key</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
DROP CONSTRAINT employees_pkey;
</code></pre>
    <br/>
    <ul>
        <li>You can remove a primary key if you plan to redefine it or change your table structure.</li>
        <li>However, be cautious — dropping a primary key may also affect <code>FOREIGN KEY</code> relationships referencing it.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Primary Key vs. Unique Constraint</b></li>
    <br/>
    <ul>
        <li>Both ensure uniqueness, but they serve different purposes:
            <table>
                <thead>
                    <tr><th>Feature</th><th>PRIMARY KEY</th><th>UNIQUE</th></tr>
                </thead>
                <tbody>
                    <tr><td>NULL allowed?</td><td>No</td><td>Yes</td></tr>
                    <tr><td>Number per table</td><td>One only</td><td>Many allowed</td></tr>
                    <tr><td>Automatically indexed?</td><td>Yes</td><td>Yes</td></tr>
                    <tr><td>Purpose</td><td>Row identity</td><td>Prevent duplicate values</td></tr>
                </tbody>
            </table>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Primary Keys</b></li>
<pre><code class="language-sql line-numbers">-- Inside psql
\d employees

-- Query system catalog
SELECT
    tc.table_name,
    kc.column_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kc
  ON kc.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'PRIMARY KEY';
</code></pre>
    <br/>
    <ul>
        <li><code>\d table_name</code> shows primary keys directly in the <code>psql</code> terminal.</li>
        <li>You can also query the system catalog for programmatic inspection of constraints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior with Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
);
</code></pre>
    <br/>
    <ul>
        <li>Primary keys are the natural targets of <code>FOREIGN KEY</code> relationships.</li>
        <li>They guarantee that every foreign key in another table refers to a unique, existing row.</li>
        <li>If you delete a primary key row, PostgreSQL will enforce the foreign key's action (<code>CASCADE</code>, <code>SET NULL</code>, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing a Good Primary Key</b></li>
    <br/>
    <ul>
        <li>Follow these best practices:
            <ul>
                <li>Keep it <b>simple</b> — use one column if possible.</li>
                <li>Use <b>numeric</b> or <b>UUID</b> types for efficiency.</li>
                <li>Never change primary key values after creation.</li>
                <li>Choose a value that is <b>unique and stable</b> across the table's lifetime.</li>
            </ul>
        </li>
        <li>Examples of good candidates:
            <ul>
                <li>Auto-incrementing integers for internal identifiers.</li>
                <li>UUIDs for distributed or external systems.</li>
                <li>Composite keys for many-to-many link tables.</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
