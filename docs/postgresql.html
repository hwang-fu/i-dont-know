<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>About PostgreSQL</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>PostgreSQL</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Creating Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In PostgreSQL, a <U>table</u> is a structured collection of rows and columns where data is stored.</li>
        <br/>
        <li>You define a table using the <b>CREATE TABLE</b> command, specifying the column names, data types, and optional constraints (like <code>PRIMARY KEY</code>, <code>NOT NULL</code>, or <code>UNIQUE</code>).</li>
        <br/>
        <li>Tables belong to a <u>schema</u> within a database. By default, they are created inside the <code>public</code> schema unless another one is specified.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name1 data_type [constraint],
    column_name2 data_type [constraint],
    ...
    [table_constraints]
);
</code></pre>
    <br/>
    <ul>
        <li><code>table_name</code>: the name of your new table.</li>
        <li><code>column_name</code>: the name of each column in that table.</li>
        <li><code>data_type</code>: defines the kind of data stored (e.g., <code>INTEGER</code>, <code>TEXT</code>, <code>BOOLEAN</code>, <code>DATE</code>, etc.).</li>
        <li><code>[constraint]</code>: optional restrictions like <code>NOT NULL</code>, <code>DEFAULT</code>, etc.</li>
        <li><code>[table_constraints]</code>: rules applying to multiple columns, e.g. primary keys, foreign keys.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Creating a Simple Table</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  VARCHAR(50) NOT NULL,
    last_name   VARCHAR(50) NOT NULL,
    hire_date   DATE NOT NULL DEFAULT CURRENT_DATE,
    active      BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li><code>SERIAL</code> automatically creates an auto-incrementing integer column (in modern PostgreSQL, use <code>GENERATED ALWAYS AS IDENTITY</code> instead).</li>
        <li><code>PRIMARY KEY</code> ensures each row has a unique, non-null identifier.</li>
        <li><code>VARCHAR(50)</code> defines a text field up to 50 characters.</li>
        <li><code>DEFAULT CURRENT_DATE</code> auto-fills with today's date when no value is given.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Modern Auto-Increment Syntax (Preferred)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL,
    department  TEXT DEFAULT 'General'
);
</code></pre>
    <br/>
    <ul>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is the SQL-standard version of <code>SERIAL</code>.</li>
        <li>You can also use <code>GENERATED BY DEFAULT AS IDENTITY</code> if you want to allow manual insertion of custom IDs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding Table-Level Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id      INT GENERATED ALWAYS AS IDENTITY,
    customer_id   INT NOT NULL,
    order_total   NUMERIC(10,2) NOT NULL CHECK (order_total &gt;= 0),
    order_date    TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (order_id),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
</code></pre>
    <br/>
    <ul>
        <li><code>CHECK (order_total &gt;= 0)</code> ensures totals can't be negative.</li>
        <li><code>PRIMARY KEY</code> and <code>FOREIGN KEY</code> constraints can appear at the bottom as table-level definitions.</li>
        <li><code>NUMERIC(10,2)</code> means up to 10 digits total, 2 after the decimal point.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Common Data Types</b></li>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>INTEGER</code>, <code>BIGINT</code>, <code>SMALLINT</code></td>
                <td>42</td>
                <td>Whole numbers, various ranges.</td>
            </tr>
            <tr>
                <td><code>NUMERIC(p, s)</code></td>
                <td>1234.56</td>
                <td>Fixed-point precision numbers (money, totals).</td>
            </tr>
            <tr>
                <td><code>TEXT</code>, <code>VARCHAR(n)</code>, <code>CHAR(n)</code></td>
                <td>'Hello'</td>
                <td>Variable or fixed-length strings.</td>
            </tr>
            <tr>
                <td><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code></td>
                <td>'2025-01-01'</td>
                <td>Date and time storage.</td>
            </tr>
            <tr>
                <td><code>BOOLEAN</code></td>
                <td>TRUE / FALSE</td>
                <td>Logical values.</td>
            </tr>
            <tr>
                <td><code>JSON</code>, <code>JSONB</code></td>
                <td>'{"key": "value"}'</td>
                <td>Structured JSON data (JSONB is binary-optimized).</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Creating Tables in a Specific Schema</b></li>
<pre><code class="language-sql line-numbers">CREATE SCHEMA company;

CREATE TABLE company.departments (
    id   INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);
</code></pre>
    <br/>
    <ul>
        <li>By default, PostgreSQL creates tables under the <code>public</code> schema.</li>
        <li>Use <code>CREATE SCHEMA</code> to organize tables logically (e.g., per project or domain).</li>
        <li>You can qualify table names like <code>schema_name.table_name</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Tables</b></li>
<pre><code class="language-sql line-numbers">-- List all tables in current database
\dt

-- List tables in a specific schema
\dt company.*

-- Show table structure
\d employees
</code></pre>
    <br/>
    <ul>
        <li>These commands are used inside the <code>psql</code> interactive terminal.</li>
        <li><code>\dt</code> lists tables, <code>\d &lt;table&gt;</code> describes structure, columns, and constraints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Altering or Dropping Tables</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees ADD COLUMN email TEXT;
ALTER TABLE employees DROP COLUMN active;
DROP TABLE employees;
</code></pre>
    <br/>
    <ul>
        <li><code>ALTER TABLE</code> allows adding/removing columns or modifying constraints.</li>
        <li><code>DROP TABLE</code> permanently deletes the table (and all its data).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Understanding Schemas in PostgreSQL</h3>
<ol>
    <li><b>What is a Schema?</b></li>
    <br/>
    <ul>
        <li>A <b>schema</b> in PostgreSQL is like a <u>folder</u> or <u>namespace</u> inside a database.</li>
        <br/>
        <li>Each schema contains its own set of tables, views, functions, and other objects — just like different folders can contain different files.</li>
        <br/>
        <li>This allows you to:
            <ul>
                <li>Organize your database objects logically (e.g. <code>hr.employees</code>, <code>sales.orders</code>).</li>
                <li>Have tables with the same name in different schemas without conflict (e.g. <code>test.users</code> vs <code>prod.users</code>).</li>
                <li>Control access permissions at a schema level.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Database vs Schema</b></li>
    <br/>
    <ul>
        <li>PostgreSQL databases are the top-level containers.</li>
        <br/>
        <li>A schema lives <u>inside</u> a database, and tables live inside a schema.</li>
    </ul>
<pre><code class="language-text">
Database → Schema → Table → Row
</code></pre>
    <br/>
    <ul>
        <li>For example, you might have a database called <code>company_db</code>, which contains two schemas:</li>
    </ul>
<pre><code class="language-text">
company_db
 ├── public
 │    ├── employees
 │    ├── departments
 │
 └── analytics
      ├── sales_summary
      ├── monthly_reports
</code></pre>
    <br/>
    <ul>
        <li>This way, you can separate your operational data (<code>public</code>) from analytical data (<code>analytics</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Default Schema: public</b></li>
    <br/>
    <ul>
        <li>When you first create a new database, PostgreSQL automatically creates a schema named <code>public</code>.</li>
        <br/>
        <li>Unless you specify otherwise, every table, view, or function you create goes into the <code>public</code> schema.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- This table is created inside the default "public" schema
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li>Its full name is actually <code>public.users</code>, even if you normally omit the schema prefix.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Creating a Custom Schema</b></li>
<pre><code class="language-sql line-numbers">CREATE SCHEMA hr;
CREATE SCHEMA sales;
</code></pre>
    <br/>
    <ul>
        <li>Now you have two additional namespaces: <code>hr</code> and <code>sales</code>.</li>
        <br/>
        <li>You can create tables inside them using a schema-qualified name:</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE hr.employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    position TEXT
);

CREATE TABLE sales.orders (
    id SERIAL PRIMARY KEY,
    amount NUMERIC(10,2),
    customer TEXT
);
</code></pre>
    <br/>
    <ul>
        <li>Now <code>hr.employees</code> and <code>sales.orders</code> are two independent tables, even though both live in the same database.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accessing Tables in Schemas</b></li>
<pre><code class="language-sql line-numbers">-- Access table using schema-qualified name
SELECT * FROM hr.employees;

-- Access table from the default "public" schema
SELECT * FROM public.users;
</code></pre>
    <br/>
    <ul>
        <li>You always access tables by <code>schema_name.table_name</code>.</li>
        <br/>
        <li>If you omit the schema, PostgreSQL looks for the table in the schemas listed in the current <b>search_path</b> (see below).</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Search Path</b></li>
    <br/>
    <ul>
        <li>The <b>search_path</b> is the list of schemas that PostgreSQL looks through when you reference an object without a schema prefix.</li>
        <br/>
        <li>By default, it is usually:</li>
    </ul>
<pre><code class="language-sql line-numbers">SHOW search_path;

-- Output example:
-- "public", "$user"
</code></pre>
    <br/>
    <ul>
        <li>This means:
            <ul>
                <li>First, PostgreSQL looks for the object in <code>public</code>.</li>
                <li>Then, it looks for a schema with the same name as the current user.</li>
            </ul>
        </li>
        <br/>
        <li>You can change the search path to prioritize another schema:</li>
    </ul>
<pre><code class="language-sql line-numbers">SET search_path TO hr, public;

-- Now "employees" means "hr.employees"
SELECT * FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>When working on large projects, this helps you avoid writing <code>hr.</code> or <code>sales.</code> all the time.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Schema</b></li>
<pre><code class="language-sql line-numbers">DROP SCHEMA hr;

-- Or remove all its objects automatically:
DROP SCHEMA hr CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>DROP SCHEMA hr;</code> will fail if the schema is not empty.</li>
        <li><code>CASCADE</code> deletes the schema and all contained tables, views, and functions.</li>
        <li>Use <code>CASCADE</code> with caution — this is irreversible!</li>
    </ul>
    <br/>
    <br/>


    <li><b>Schema Permissions</b></li>
    <br/>
    <ul>
        <li>You can grant or revoke access to schemas independently of table permissions.</li>
    </ul>
<pre><code class="language-sql line-numbers">-- Grant a user permission to create objects in a schema
GRANT CREATE ON SCHEMA sales TO alice;

-- Allow a user to use (read from) the schema
GRANT USAGE ON SCHEMA hr TO bob;
</code></pre>
    <br/>
    <ul>
        <li><code>USAGE</code> allows access to existing objects inside the schema.</li>
        <li><code>CREATE</code> allows creating new objects within that schema.</li>
        <li>Combining these allows a user to both read and create inside that namespace.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to Use Schemas</b></li>
    <br/>
    <ul>
        <li><b>Organizing modules</b>: for example, <code>hr</code>, <code>finance</code>, and <code>sales</code> schemas in a company database.</li>
        <br/>
        <li><b>Separating environments</b>: e.g., <code>dev</code>, <code>test</code>, <code>prod</code> schemas in the same database for testing purposes.</li>
        <br/>
        <li><b>Multi-tenant applications</b>: one schema per customer, while keeping all data in a single database.</li>
        <br/>
        <li><b>Access control</b>: different roles can have access to different schemas.</li>
    </ul>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <li>A <b>schema</b> is a namespace inside a PostgreSQL database that groups related tables and objects together.</li>
        <br/>
        <li>By default, all objects go into the <code>public</code> schema, but you can create your own with <code>CREATE SCHEMA</code>.</li>
        <br/>
        <li>Access tables as <code>schema_name.table_name</code>, or adjust <code>search_path</code> for convenience.</li>
        <br/>
        <li>Use schemas to organize projects, control permissions, and keep your database clean and modular.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Inserting Data into Tables</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Once you've created a table, you can add rows of data using the <code>INSERT INTO</code> statement.</li>
        <br/>
        <li>Each inserted row corresponds to one record in the table, containing values for one or more columns.</li>
        <br/>
        <li>PostgreSQL allows flexible insertion:
            <ul>
                <li>Insert all columns at once.</li>
                <li>Insert into selected columns only.</li>
                <li>Insert multiple rows in a single command.</li>
                <li>Insert data from another table or query.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO &lt;table_name&gt; (&lt;column1&gt;, &lt;column2&gt;, &lt;column3&gt;, ...)
VALUES (&lt;value1&gt;, &lt;value2&gt;, &lt;value3&gt;, ...);
</code></pre>
    <br/>
    <br/>


    <li><b>Example: Simple Insert</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES ('Alice', 'Johnson', 'Engineering');
</code></pre>
    <br/>
    <ul>
        <li>The <code>employee_id</code> column (if auto-generated) does not need to be specified, PostgreSQL fills it automatically.</li>
        <li>String literals are enclosed in single quotes (<code>'...'</code>).</li>
        <li>After execution, a new row appears in <code>employees</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting into All Columns</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees
VALUES (DEFAULT, 'Bob', 'Smith', 'Sales');
</code></pre>
    <br/>
    <ul>
        <li>If you omit the column list, you must provide a value for every column in order.</li>
        <li>Use <code>DEFAULT</code> to let PostgreSQL fill an auto-generated value (like an identity or timestamp).</li>
        <li>This form is more error-prone — prefer naming columns explicitly when possible.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Multiple Rows at Once</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES
    ('Charlie', 'Wang', 'Finance'),
    ('Diana', 'Lopez', 'Marketing'),
    ('Ethan', 'Neuer', 'IT');
</code></pre>
    <br/>
    <ul>
        <li>This is faster and cleaner than running multiple <code>INSERT</code> statements.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name)
VALUES ('Frank', 'Baker');

INSERT INTO employees (first_name, last_name, department)
VALUES ('Grace', 'Kim', DEFAULT);
</code></pre>
    <br/>
    <ul>
        <li>If a column has a <code>DEFAULT</code> value, you can omit it or explicitly use <code>DEFAULT</code>.</li>
        <li>In both cases, PostgreSQL automatically fills in the default.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Data from Another Table</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO archived_employees (first_name, last_name, department)
SELECT first_name, last_name, department
FROM employees
WHERE active = FALSE;
</code></pre>
    <br/>
    <ul>
        <li>Instead of manually typing values, you can pull data from an existing table or query.</li>
        <li>This is useful for:
            <ul>
                <li>Archiving old records,</li>
                <li>Duplicating data,</li>
                <li>Creating backups or subsets.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Returning Values After Insert</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, department)
VALUES ('Helene', 'Zabak', 'Operations')
RETURNING employee_id;
</code></pre>
    <br/>
    <ul>
        <li>The <code>RETURNING</code> clause immediately outputs data from the newly inserted row(s).</li>
        <li>You can return multiple columns:
<pre><code class="language-sql line-numbers">RETURNING employee_id, first_name, hire_date;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling Conflicts (Upserts)</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (employee_id, first_name, last_name, department)
VALUES (1, 'Ian', 'Miller', 'Engineering')
ON CONFLICT (employee_id) DO UPDATE SET department = EXCLUDED.department;
</code></pre>
    <br/>
    <ul>
        <li><code>ON CONFLICT</code> handles cases where an insert violates a unique or primary key constraint.</li>
        <li><code>EXCLUDED</code> refers to the new row that caused the conflict.</li>
        <li>You can:
            <ul>
                <li><code>DO NOTHING</code> to skip the row, or</li>
                <li><code>DO UPDATE</code> to modify the existing row.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Full Insert Scenario</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    id           SERIAL PRIMARY KEY,
    name         TEXT NOT NULL,
    email        TEXT UNIQUE,
    created_at   TIMESTAMP DEFAULT NOW()
);

INSERT INTO customers (name, email)
VALUES
    ('Alice Green', 'alice@example.com'),
    ('Bob White', 'bob@example.com');

INSERT INTO customers (name, email)
VALUES ('Alice Green', 'alice@example.com')
ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
</code></pre>
    <br/>
    <ul>
        <li>The first insert adds two new customers.</li>
        <li>The second one updates an existing customer (instead of erroring) because of the <code>ON CONFLICT</code> rule.</li>
        <li><code>NOW()</code> automatically sets the timestamp.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics on Selecting Data from Tables</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>SELECT</code> statement in PostgreSQL is used to <u>query</u> data from one or more tables.</li>
        <br/>
        <li>PostgreSQL processes <code>SELECT</code> queries logically in this order:
<pre><code class="language-text">FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT</code></pre>
        </li>
        <br/>
        <li>This order matters when you design complex queries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT &lt;column1&gt;, &lt;column2&gt;, ...
FROM &lt;table_name&gt;;
</code></pre>
    <br/>
    <ul>
        <li>You can select all columns using <code>*</code>, but it's better to specify only what you need.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Select All Columns</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>Retrieves every column and every row from <code>employees</code>.</li>
        <li>Useful for quick checks, but inefficient in production queries.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Rows with WHERE</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name
FROM employees
WHERE department = 'Engineering';
</code></pre>
    <br/>
    <ul>
        <li><code>WHERE</code> filters rows based on a condition.</li>
        <li>Operators include:
            <ul>
                <li><code>=</code> equal</li>
                <li><code>&lt;&gt;</code> or <code>!=</code> not equal</li>
                <li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
                <li><code>AND</code>, <code>OR</code>, <code>NOT</code> for logical combinations</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering with Pattern Matching (LIKE)</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name
FROM employees
WHERE last_name LIKE 'S%';
</code></pre>
    <br/>
    <ul>
        <li><code>LIKE</code> is used for pattern matching with wildcards:
            <ul>
                <li><code>%</code>: matches any sequence of characters.</li>
                <li><code>_</code>: matches exactly one character.</li>
            </ul>
        </li>
        <li>Example: <code>'S%'</code> finds all last names starting with "S".</li>
    </ul>
    <br/>
    <br/>


    <li><b>Sorting Results with ORDER BY</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name, hire_date
FROM employees
ORDER BY hire_date DESC;
</code></pre>
    <br/>
    <ul>
        <li><code>ORDER BY</code> sorts rows by one or more columns.</li>
        <li>Use <code>ASC</code> (default) or <code>DESC</code> for descending order.</li>
        <li>You can sort by multiple columns:
<pre><code class="language-sql line-numbers">ORDER BY department ASC, last_name ASC;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Limiting Results with LIMIT and OFFSET</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
ORDER BY employee_id
LIMIT 5 OFFSET 10;
</code></pre>
    <br/>
    <ul>
        <li><code>LIMIT</code> restricts how many rows are returned.</li>
        <li><code>OFFSET</code> skips the given number of rows before starting output.</li>
        <li>Commonly used for pagination (e.g., "page 3, 10 results per page").</li>
    </ul>
    <br/>
    <br/>


    <li><b>Aliasing Columns and Tables</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name AS given,
    last_name AS family
FROM employees AS e;
</code></pre>
    <br/>
    <ul>
        <li>Aliases give temporary names to columns or tables for readability.</li>
        <li>You can omit <code>AS</code>, both forms work:
<pre><code class="language-sql line-numbers">SELECT first_name given, last_name family FROM employees e;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name, department
FROM employees
WHERE department = 'Sales'
    AND hire_date &gt;= '2024-01-01'
    OR active = TRUE;
</code></pre>
    <br/>
    <ul>
        <li>Use parentheses to control logical order:
<pre><code class="language-sql line-numbers">WHERE (department = 'Sales' AND hire_date &gt;= '2024-01-01') OR active = TRUE;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Distinct Rows</b></li>
<pre><code class="language-sql line-numbers">SELECT DISTINCT department
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li><code>DISTINCT</code> removes duplicate rows from the result set.</li>
        <li>You can apply it to one or multiple columns:
<pre><code class="language-sql line-numbers">SELECT DISTINCT department, active FROM employees;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Computed Columns and Expressions</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name,
    EXTRACT(YEAR FROM hire_date)   AS hire_year
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>You can create new columns by combining or transforming existing ones.</li>
        <li><code>||</code> concatenates strings.</li>
        <li><code>EXTRACT()</code> extracts a specific part (like year, month, day) from a date or timestamp.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Aggregating Data with GROUP BY</b></li>
<pre><code class="language-sql line-numbers">SELECT
    department,
    COUNT(*) AS total_employees
FROM employees
GROUP BY department;
</code></pre>
    <br/>
    <ul>
        <li><code>GROUP BY</code> groups rows by unique combinations of column values.</li>
        <li>Often used with aggregate functions:
            <ul>
                <li><code>COUNT()</code>: number of rows.</li>
                <li><code>SUM()</code>: total sum.</li>
                <li><code>AVG()</code>: average.</li>
                <li><code>MIN()</code> / <code>MAX()</code>: smallest / largest value.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Groups with HAVING</b></li>
<pre><code class="language-sql line-numbers">SELECT department, COUNT(*) AS total_employees
FROM employees
GROUP BY department
HAVING COUNT(*) &gt; 5;
</code></pre>
    <br/>
    <ul>
        <li><code>HAVING</code> filters groups (after aggregation), while <code>WHERE</code> filters individual rows (before aggregation).</li>
        <li>Example: only show departments with more than 5 employees.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Results with UNION</b></li>
<pre><code class="language-sql line-numbers">SELECT first_name, last_name FROM employees
UNION
SELECT first_name, last_name FROM contractors;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION</code> merges two result sets and removes duplicates.</li>
        <li>Use <code>UNION ALL</code> to keep duplicates.</li>
        <li>Each <code>SELECT</code> must have the same number and type of columns.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Concatenating Strings in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>String concatenation means joining two or more strings together into a single text value.</li>
        <br/>
        <li>In PostgreSQL, you can concatenate strings using:
            <ul>
                <li>The concatenation operator <code>||</code> (most common and SQL-standard).</li>
                <li>The <code>CONCAT()</code> function.</li>
                <li>The <code>CONCAT_WS()</code> function (concatenate with a separator).</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using the || Operator</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || ' ' || 'World' AS greeting;
</code></pre>
    <br/>
    <ul>
        <li>The <code>||</code> operator joins strings directly.</li>
        <li>In this example, PostgreSQL returns <code>Hello World</code>.</li>
        <li>You can concatenate columns and literals together as well:</li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name
FROM employees;
</code></pre>
        <li>This is the most widely used approach for text combination in PostgreSQL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Handling NULLs with ||</b></li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || NULL || 'World' AS result;
</code></pre>
    <br/>
    <ul>
        <li>If any operand is <code>NULL</code>, the entire concatenated result becomes <code>NULL</code>.</li>
        <li>Example result: <code>NULL</code>.</li>
        <li>To avoid this, use the <code>COALESCE()</code> function to replace <code>NULL</code> with an empty string:</li>
<pre><code class="language-sql line-numbers">SELECT 'Hello' || COALESCE(NULL, '') || 'World' AS safe_concat;</code></pre>
        <li>Result: <code>HelloWorld</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CONCAT()</b></li>
<pre><code class="language-sql line-numbers">SELECT CONCAT('Hello', ' ', 'World') AS greeting;
</code></pre>
    <br/>
    <ul>
        <li><code>CONCAT()</code> joins any number of arguments together.</li>
        <li>Unlike <code>||</code>, it automatically treats <code>NULL</code> as an empty string.</li>
        <li>Example:</li>
<pre><code class="language-sql line-numbers">SELECT CONCAT('Hello', NULL, 'World') AS greeting;</code></pre>
        <li>Result: <code>HelloWorld</code> (not <code>NULL</code>).</li>
        <li>This makes <code>CONCAT()</code> safer when dealing with nullable columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CONCAT_WS() — Concatenate with Separator</b></li>
<pre><code class="language-sql line-numbers">SELECT CONCAT_WS('-', '2025', '11', '10') AS formatted_date;
</code></pre>
    <br/>
    <ul>
        <li><code>CONCAT_WS(separator, arg1, arg2, ...)</code> stands for "Concatenate With Separator."</li>
        <li>The first argument is used as the separator between all other arguments.</li>
        <li><code>NULL</code> values are ignored automatically.</li>
        <li>Example with <code>NULL</code>:
<pre><code class="language-sql line-numbers">SELECT CONCAT_WS(' ', 'Alice', NULL, 'Johnson');</code></pre>
        <li>Result: <code>Alice Johnson</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concatenating Columns Example</b></li>
<pre><code class="language-sql line-numbers">SELECT
    first_name || ' ' || last_name AS full_name,
    department || ' Department'    AS dept_name
FROM employees;
</code></pre>
    <br/>
    <br/>


    <li><b>Concatenation in UPDATE Statements</b></li>
<pre><code class="language-sql line-numbers">UPDATE employees
SET full_name = first_name || ' ' || last_name;
</code></pre>
    <br/>
    <ul>
        <li>You can use concatenation when updating data, for example, to fill a derived column.</li>
        <li>PostgreSQL evaluates the expressions on the right-hand side for each row.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Concatenation with Numbers and Other Types</b></li>
<pre><code class="language-sql line-numbers">SELECT
    'Employee ID: ' || employee_id AS label
FROM employees;
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL automatically casts numbers, booleans, and dates to text when concatenated with a string.</li>
        <li>You can also use explicit conversion for clarity:</li>
<pre><code class="language-sql line-numbers">SELECT 'Employee ID: ' || CAST(employee_id AS TEXT) FROM employees;</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Formatting Example: Full Address</b></li>
<pre><code class="language-sql line-numbers">SELECT
    CONCAT_WS(', ',
        street,
        city,
        postal_code,
        country
    ) AS full_address
FROM customers;
</code></pre>
    <br/>
    <ul>
        <li>This builds a clean formatted address string, skipping <code>NULL</code> parts automatically.</li>
        <li>Example result: <code>"Main Street 5, Berlin, 10115, Germany"</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Dropping Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>DROP TABLE</code> statement permanently removes a table and all its data from a PostgreSQL database.</li>
        <br/>
        <li>When you drop a table, PostgreSQL deletes:
            <ul>
                <li>All rows stored in the table.</li>
                <li>Associated indexes and constraints.</li>
                <li>Any dependent objects (if you use <code>CASCADE</code>).</li>
            </ul>
        </li>
        <br/>
        <li>Once dropped, the data <mark>cannot</mark> be recovered unless you have a backup.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE &lt;table_name&gt;;
</code></pre>
    <br/>
    <ul>
        <li><code>table_name</code> — the name of the table you want to delete.</li>
        <li>If the table doesn't exist, PostgreSQL will raise an error unless you use <code>DROP TABLE IF EXISTS</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Dropping a Table</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE employees;
</code></pre>
    <br/>
    <ul>
        <li>Deletes the <code>employees</code> table completely from the database.</li>
        <li>All its data, indexes, and constraints are removed permanently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Safely Dropping a Table</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE IF EXISTS employees;
</code></pre>
    <br/>
    <ul>
        <li>Prevents an error if the table does not exist.</li>
        <li>This is a safer way to clean up tables, especially in scripts or migrations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping Multiple Tables</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE IF EXISTS employees, departments, projects;
</code></pre>
    <br/>
    <ul>
        <li>You can drop multiple tables in one command by separating their names with commas.</li>
        <li>Each table will be dropped in the order listed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CASCADE and RESTRICT</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE employees CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>CASCADE</code> automatically drops any dependent objects (like foreign keys in other tables, views, or triggers).</li>
        <li>Use carefully — this can remove more than you expect!</li>
        <li>To prevent accidental cascade deletion, use <code>RESTRICT</code> (the default behavior):</li>
<pre><code class="language-sql line-numbers">DROP TABLE employees RESTRICT;</code></pre>
        <li>PostgreSQL will refuse to drop the table if anything depends on it.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Example: Dropping with Dependencies</b></li>
<pre><code class="language-sql line-numbers">-- Example: "customers" table references "orders" through a foreign key
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY
);

CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id)
);

-- Dropping the parent table with CASCADE
DROP TABLE orders CASCADE;
</code></pre>
    <br/>
    <ul>
        <li><code>CASCADE</code> tells PostgreSQL to remove not only the <code>orders</code> table itself, but also any <u>objects that depend on it</u> — such as foreign key constraints, views, or triggers.</li>
        <br/>
        <li>In this example:
            <ul>
                <li>The table <code>orders</code> is permanently deleted.</li>
                <li>The foreign key constraint (inside <code>customers</code>) is automatically removed, so <code>customers.order_id</code> can take whatever values it wants in the future.</li>
                <li>The <code>customers</code> table itself remains intact — only the relationship to <code>orders</code> is dropped.</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL will also print a notice similar to:
<pre><code class="language-text">NOTICE:  drop cascades to constraint customers_order_id_fkey on table customers
DROP TABLE
</code></pre>
        </li>
        <br/>
        <li>Always double-check before using <code>CASCADE</code>, as it can remove multiple dependent objects automatically.</li>
    </ul>
    <br/>
    <br/>



    <li><b>Dropping a Table in a Specific Schema</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE company.employees;
</code></pre>
    <br/>
    <ul>
        <li>If the table belongs to a non-default schema, include the schema name.</li>
        <li>Example: <code>company.employees</code> drops the <code>employees</code> table inside the <code>company</code> schema.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking if a Table Exists</b></li>
<pre><code class="language-sql line-numbers">-- Using psql meta-command
\dt

-- Or query the catalog directly
SELECT tablename
FROM pg_catalog.pg_tables
WHERE tablename = 'employees';
</code></pre>
    <br/>
    <ul>
        <li><code>\dt</code> lists all tables in the current database (works in <code>psql</code>).</li>
        <li>Alternatively, query the <code>pg_catalog.pg_tables</code> system table to check existence programmatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Practical Tip: Use Transactions</b></li>
<pre><code class="language-sql line-numbers">BEGIN;
DROP TABLE employees;
ROLLBACK;
</code></pre>
    <br/>
    <ul>
        <li>During testing, wrap <code>DROP TABLE</code> inside a transaction.</li>
        <li><code>ROLLBACK</code> cancels the deletion if you change your mind before committing.</li>
        <li>This helps prevent irreversible data loss while experimenting.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Filtering Rows with the WHERE Clause</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>WHERE</code> clause in PostgreSQL filters rows returned by a <code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement based on one or more conditions.</li>
        <br/>
        <li>It is evaluated <u>before</u> grouping or ordering results — only rows satisfying the condition(s) are kept.</li>
        <br/>
        <li>You can use logical operators (<code>AND</code>, <code>OR</code>, <code>NOT</code>), comparison operators (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, etc.), and range or set operators like <code>BETWEEN</code>, <code>IN</code>, and <code>LIKE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT column1, column2, ...
FROM table_name
WHERE condition;
</code></pre>
    <br/>
    <ul>
        <li><code>condition</code> can include comparisons, logical connectors, or functions that evaluate to <code>TRUE</code> or <code>FALSE</code>.</li>
        <li>Rows for which the condition is <code>TRUE</code> are returned; <code>FALSE</code> or <code>NULL</code> rows are excluded.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Operators</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Engineering';
</code></pre>
    <br/>
    <ul>
        <li><b>Common operators:</b></li>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
                <tr><td><code>=</code></td><td>Equal to</td><td><code>salary = 50000</code></td></tr>
                <tr><td><code>&lt;&gt;</code> or <code>!=</code></td><td>Not equal to</td><td><code>department &lt;&gt; 'IT'</code></td></tr>
                <tr><td><code>&gt;</code></td><td>Greater than</td><td><code>age &gt; 30</code></td></tr>
                <tr><td><code>&lt;</code></td><td>Less than</td><td><code>salary &lt; 40000</code></td></tr>
                <tr><td><code>&gt;=</code></td><td>Greater than or equal to</td><td><code>age &gt;= 18</code></td></tr>
                <tr><td><code>&lt;=</code></td><td>Less than or equal to</td><td><code>hire_date &lt;= '2025-01-01'</code></td></tr>
            </tbody>
        </table>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Conditions with AND, OR, NOT</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Sales'
    AND hire_date &gt;= '2024-01-01'
    OR active = TRUE;
</code></pre>
    <br/>
    <ul>
        <li>It is recommended to use parentheses for clarity:
<pre><code class="language-sql line-numbers">WHERE (department = 'Sales' AND hire_date &gt;= '2024-01-01') OR active = TRUE;</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering Ranges with BETWEEN</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE salary BETWEEN 40000 AND 60000;
</code></pre>
    <br/>
    <ul>
        <li><code>BETWEEN a AND b</code> is equivalent to <code>(salary &gt;= a AND salary &lt;= b)</code>.</li>
        <li>It <u>includes</u> both boundary values.</li>
        <li>You can use it with dates, numbers, or text:</li>
<pre><code class="language-sql line-numbers">WHERE hire_date BETWEEN '2024-01-01' AND '2024-12-31';</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering by a Set with IN</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department IN ('HR', 'IT', 'Finance');
</code></pre>
    <br/>
    <ul>
        <li><code>IN</code> checks whether a value matches any value in the provided list.</li>
        <li>Equivalent to multiple <code>OR</code> conditions:</li>
<pre><code class="language-sql line-numbers">WHERE department = 'HR' OR department = 'IT' OR department = 'Finance';</code></pre>
        <li>You can also use a subquery:
<pre><code class="language-sql line-numbers">WHERE department_id IN (SELECT id FROM departments WHERE active = TRUE);</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Pattern Matching with LIKE and ILIKE</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE last_name LIKE 'S%';
</code></pre>
    <br/>
    <ul>
        <li><code>LIKE</code> is case-sensitive pattern matching.</li>
        <li><code>ILIKE</code> is the case-insensitive version (PostgreSQL extension).</li>
        <li>Examples:</li>
<pre><code class="language-sql line-numbers">WHERE name LIKE  'A%';      -- starts with A
WHERE name LIKE  '%son';    -- ends with son
WHERE name ILIKE '%SMITH%'; -- contains 'smith' (case-insensitive)
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering NULL Values</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department IS NULL;

SELECT * FROM employees
WHERE department IS NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li><code>= NULL</code> does <u>not</u> work — use <code>IS NULL</code> and <code>IS NOT NULL</code>.</li>
        <li>This is because <code>NULL</code> represents "unknown", not an actual value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Membership with EXISTS</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.id = e.department_id
);
</code></pre>
    <br/>
    <ul>
        <li><code>EXISTS</code> checks whether a subquery returns at least one row.</li>
        <li>If it does, the condition is <code>TRUE</code>, otherwise <code>FALSE</code>.</li>
        <li>Often used for correlated subqueries and conditional joins.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using ANY and ALL</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE salary &gt; ANY (SELECT salary FROM interns);

SELECT * FROM employees
WHERE salary &gt; ALL (SELECT salary FROM interns);
</code></pre>
    <br/>
    <ul>
        <li><code>ANY</code> — condition is true if it holds for <u>at least one</u> value returned by the subquery.</li>
        <li><code>ALL</code> — condition must hold for <u>every</u> value returned by the subquery.</li>
        <li>These are useful when comparing against ranges of values dynamically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining Multiple Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM employees
WHERE department = 'Finance'
    AND (salary BETWEEN 40000 AND 60000)
    AND active = TRUE
    AND last_name ILIKE 'J%';
</code></pre>
    <br/>
    <ul>
        <li>Conditions can be chained together in flexible and readable ways.</li>
        <li>Parentheses make the logic explicit and prevent ambiguity.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Database Design in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Database design</u> is the process of organizing data into structured tables that represent real-world entities and their relationships.</li>
        <br/>
        <li>Good design ensures:
            <ul>
                <li>Data integrity (accuracy and consistency).</li>
                <li>Scalability (efficient growth with more data).</li>
                <li>Performance (fast queries and updates).</li>
                <li>Maintainability (easy schema evolution and clear relationships).</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL, as a relational database, uses <b>tables</b>, <b>keys</b>, and <b>relationships</b> to represent structured data logically and efficiently.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 1: Identify Entities and Attributes</b></li>
    <br/>
    <ul>
        <li>Begin by identifying <b>entities</b> — objects or concepts you need to store data about (e.g. <code>customers</code>, <code>orders</code>, <code>products</code>).</li>
        <br/>
        <li>For each entity, determine its <b>attributes</b> — descriptive properties or fields.</li>
    </ul>
<pre><code class="language-text">
Entity: Customer
 ├── customer_id (primary key)
 ├── name
 ├── email
 └── phone

Entity: Order
 ├── order_id (primary key)
 ├── customer_id (foreign key)
 ├── order_date
 └── total_amount
</code></pre>
    <br/>
    <ul>
        <li>Each entity becomes a table, and each attribute becomes a column.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 2: Define Primary Keys</b></li>
    <br/>
    <ul>
        <li>A <b>primary key</b> uniquely identifies each row in a table.</li>
        <li>PostgreSQL commonly uses:
            <ul>
                <li><code>SERIAL</code> or <code>IDENTITY</code> columns for numeric IDs.</li>
                <li>Or <code>UUID</code> for globally unique identifiers.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name        TEXT NOT NULL,
    email       TEXT UNIQUE
);
</code></pre>
    <br/>
    <ul>
        <li>Each table should have exactly ONE primary key column or a composite key (a combination of multiple columns) when necessary.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 3: Define Relationships with Foreign Keys</b></li>
    <br/>
    <ul>
        <li><u>Foreign keys</u> define relationships between tables by referencing primary keys of other tables.</li>
        <li>They maintain <u>referential integrity</u>, ensuring that related data exists before referencing it.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id     SERIAL PRIMARY KEY,
    customer_id  INT REFERENCES customers(customer_id),
    order_date   DATE NOT NULL DEFAULT CURRENT_DATE,
    total_amount NUMERIC(10,2)
);
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>orders.customer_id</code> links each order to its corresponding customer.</li>
        <li>You can specify actions like <code>ON DELETE CASCADE</code> or <code>ON UPDATE SET NULL</code> for dependency behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 4: Normalize Your Data</b></li>
    <br/>
    <ul>
        <li><u>Normalization</u> is the process of structuring data to reduce redundancy and improve consistency.</li>
        <br/>
        <li>Common normal forms:
            <ul>
                <li><b>1NF (First Normal Form)</b> — No repeating groups or arrays, every field holds atomic values.</li>
                <li><b>2NF (Second Normal Form)</b> — Every non-key attribute depends entirely on the primary key.</li>
                <li><b>3NF (Third Normal Form)</b> — No transitive dependencies (non-key columns shouldn't depend on other non-key columns).</li>
            </ul>
        </li>
        <br/>
        <li>Example — Unnormalized table:</li>
<pre><code class="language-text">
orders
 ├── order_id
 ├── customer_name
 ├── customer_email
 ├── product_1
 ├── product_2
</code></pre>
        <li>Normalized design:</li>
<pre><code class="language-text">
customers
 ├── customer_id
 ├── name
 ├── email

orders
 ├── order_id
 ├── customer_id
 ├── order_date

order_items
 ├── order_id
 ├── product_id
 ├── quantity
</code></pre>
        <li>This separation avoids data duplication and keeps relationships clear.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 5: Add Constraints and Data Integrity Rules</b></li>
    <br/>
    <ul>
        <li>Constraints enforce rules at the database level:
            <ul>
                <li><code>NOT NULL</code> — prevents missing values.</li>
                <li><code>UNIQUE</code> — ensures no duplicates.</li>
                <li><code>CHECK</code> — validates data according to conditions.</li>
                <li><code>DEFAULT</code> — sets fallback values automatically.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    id        SERIAL PRIMARY KEY,
    name      TEXT NOT NULL,
    salary    NUMERIC(8,2) CHECK (salary &gt;= 0),
    active    BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>These ensure that invalid or inconsistent data cannot be inserted even by mistake.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 6: Use Indexes for Performance</b></li>
    <br/>
    <ul>
        <li><u>Indexes</u> speed up data retrieval by allowing faster lookups on large tables.</li>
        <li>PostgreSQL automatically creates an index for primary and unique keys, but you can add more as needed.</li>
    </ul>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_employees_department ON employees(department);
</code></pre>
    <br/>
    <ul>
        <li>Use indexes wisely — they make reads faster but can slow down inserts and updates.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 7: Consider Denormalization (for Performance)</b></li>
    <br/>
    <ul>
        <li>In some high-performance or reporting cases, you may intentionally duplicate certain data to avoid complex joins.</li>
        <li>This is called <u>denormalization</u> — used to trade storage for speed.</li>
        <li>Example: storing <code>customer_name</code> directly inside <code>orders</code> for faster querying, even though it's also in <code>customers</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 8: Plan for Relationships — One-to-Many and Many-to-Many</b></li>
    <br/>
    <ul>
        <li><b>One-to-Many</b> — a customer can have many orders.</li>
<pre><code class="language-sql line-numbers">-- one-to-many
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
);
</code></pre>
        <li><b>Many-to-Many</b> — students can take many courses, and each course has many students.</li>
<pre><code class="language-sql line-numbers">-- many-to-many through a junction table
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id  INT REFERENCES courses(id),
    PRIMARY KEY (student_id, course_id)
);
</code></pre>
        <li>Use junction (bridge) tables for many-to-many relationships.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Step 9: Naming Conventions and Documentation</b></li>
    <br/>
    <ul>
        <li>Consistent naming improves readability and maintainability:
            <ul>
                <li>Use <code>snake_case</code> for all identifiers (e.g. <code>order_date</code>).</li>
                <li>Plural names for tables (<code>employees</code>, <code>orders</code>).</li>
                <li>Singular names for columns (<code>employee_id</code>).</li>
                <li>Prefix foreign keys with the table they reference (e.g. <code>customer_id</code> in <code>orders</code>).</li>
            </ul>
        </li>
        <li>Document your schema using comments:</li>
<pre><code class="language-sql line-numbers">COMMENT ON TABLE employees IS 'Stores employee data for the company';
COMMENT ON COLUMN employees.salary IS 'Monthly gross salary in euros';
</code></pre>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Primary Keys in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>primary key</u> is a column (or a group of columns) that uniquely identifies each row in a table.</li>
        <br/>
        <li>It ensures that:
            <ul>
                <li>No two rows have the same primary key value.</li>
                <li>The primary key value is never <code>NULL</code>.</li>
            </ul>
        </li>
        <br/>
        <li>PostgreSQL automatically creates a unique <u>index</u> for every primary key to speed up lookups and enforce uniqueness.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type PRIMARY KEY,
    other_column data_type
);
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>PRIMARY KEY</code> constraint on a column to define it as the table's unique identifier.</li>
        <li>PostgreSQL automatically makes that column <code>NOT NULL</code> and <code>UNIQUE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple Primary Key</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li><code>SERIAL</code> automatically creates an integer column with an internal sequence generator.</li>
        <li>The primary key constraint guarantees that every <code>employee_id</code> value is unique and non-null.</li>
        <li>Primary keys are often numeric because they are efficient for indexing and joining tables.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using GENERATED AS IDENTITY (Modern SQL)</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE departments (
    dept_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name    TEXT NOT NULL
);
</code></pre>
    <br/>
    <ul>
        <li><code>GENERATED ALWAYS AS IDENTITY</code> is the SQL-standard replacement for <code>SERIAL</code>.</li>
        <li>PostgreSQL manages the sequence automatically and ensures strict consistency.</li>
        <li>You can also use <code>GENERATED BY DEFAULT AS IDENTITY</code> to allow manual insertion of custom IDs if necessary.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Composite (Multi-Column) Primary Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE enrollments (
    student_id INT NOT NULL,
    course_id  INT NOT NULL,
    enrollment_date DATE DEFAULT CURRENT_DATE,
    PRIMARY KEY (student_id, course_id)
);
</code></pre>
    <br/>
    <ul>
        <li>Composite keys use multiple columns to uniquely identify a record.</li>
        <li>Here, the combination of <code>student_id</code> and <code>course_id</code> must be unique — but each one individually may repeat.</li>
        <li>Common in many-to-many relationship tables (also called junction tables).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a Primary Key to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ADD CONSTRAINT employees_pkey PRIMARY KEY (employee_id);
</code></pre>
    <br/>
    <ul>
        <li>If the table was created without a primary key, you can add one later using <code>ALTER TABLE</code>.</li>
        <li>The constraint name (here <code>employees_pkey</code>) can be chosen manually or left for PostgreSQL to assign automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a Primary Key</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
DROP CONSTRAINT employees_pkey;
</code></pre>
    <br/>
    <ul>
        <li>You can remove a primary key if you plan to redefine it or change your table structure.</li>
        <li>However, be cautious — dropping a primary key may also affect <code>FOREIGN KEY</code> relationships referencing it.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Primary Key vs. Unique Constraint</b></li>
    <br/>
    <ul>
        <li>Both ensure uniqueness, but they serve different purposes:<br/><br/>
            <table>
                <thead>
                    <tr><th>Feature</th><th>PRIMARY KEY</th><th>UNIQUE</th></tr>
                </thead>
                <tbody>
                    <tr><td>NULL allowed?</td><td>No</td><td>Yes</td></tr>
                    <tr><td>Number per table</td><td>One only</td><td>Many allowed</td></tr>
                    <tr><td>Automatically indexed?</td><td>Yes</td><td>Yes</td></tr>
                    <tr><td>Purpose</td><td>Row identity</td><td>Prevent duplicate values</td></tr>
                </tbody>
            </table>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Primary Keys</b></li>
<pre><code class="language-sql line-numbers">-- Inside psql
\d employees

-- Query system catalog
SELECT
    tc.table_name,
    kc.column_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kc
    ON kc.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'PRIMARY KEY';
</code></pre>
    <br/>
    <ul>
        <li><code>\d table_name</code> shows primary keys directly in the <code>psql</code> terminal.</li>
        <li>You can also query the system catalog for programmatic inspection of constraints.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior with Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
);
</code></pre>
    <br/>
    <ul>
        <li>Primary keys are the natural targets of <code>FOREIGN KEY</code> relationships.</li>
        <li>They guarantee that every foreign key in another table refers to a unique, existing row.</li>
        <li>If you delete a primary key row, PostgreSQL will enforce the foreign key's action (<code>CASCADE</code>, <code>SET NULL</code>, etc.).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Choosing a Good Primary Key</b></li>
    <br/>
    <ul>
        <li>Follow these best practices:
            <ul>
                <li>Keep it <b>simple</b> — use one column if possible.</li>
                <li>Use <b>numeric</b> or <b>UUID</b> types for efficiency.</li>
                <li>Never change primary key values after creation.</li>
                <li>Choose a value that is <b>unique and stable</b> across the table's lifetime.</li>
            </ul>
        </li>
        <li>Examples of good candidates:
            <ul>
                <li>Auto-incrementing integers for internal identifiers.</li>
                <li>UUIDs for distributed or external systems.</li>
                <li>Composite keys for many-to-many link tables.</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>The NOT NULL Constraint in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>NOT NULL</code> constraint ensures that a column cannot contain a <code>NULL</code> value.</li>
        <br/>
        <li>In PostgreSQL, <code>NULL</code> represents "unknown" or "missing" data — not the same as an empty string or zero.</li>
        <br/>
        <li>By declaring a column as <code>NOT NULL</code>, you guarantee that every row must have a valid (non-NULL) value in that column.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type NOT NULL,
    ...
);
</code></pre>
    <br/>
    <ul>
        <li>Attach <code>NOT NULL</code> right after the data type in the column definition.</li>
        <li>If you try to insert a row without providing a value for that column, PostgreSQL will raise an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Defining NOT NULL Columns</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    last_name   TEXT NOT NULL,
    email       TEXT,
    hire_date   DATE NOT NULL DEFAULT CURRENT_DATE
);
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>first_name</code>, <code>last_name</code>, and <code>hire_date</code> must always contain valid values.</li>
        <li><code>email</code> is optional — it can be left <code>NULL</code>.</li>
        <li>If you omit a <code>NOT NULL</code> column in an <code>INSERT</code> statement, PostgreSQL will throw an error unless a <code>DEFAULT</code> value is provided.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Attempting to Insert NULL</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO employees (first_name, last_name, hire_date)
VALUES (NULL, 'Smith', '2025-01-01');
</code></pre>
    <br/>
    <ul>
        <li>This will fail with an error like:</li>
<pre><code class="language-text">ERROR:  null value in column "first_name" of relation "employees" violates not-null constraint
DETAIL: Failing row contains (null, Smith, 2025-01-01).
</code></pre>
        <li>PostgreSQL prevents the insertion because <code>first_name</code> is defined as <code>NOT NULL</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a NOT NULL Constraint to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN email SET NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li>You can add <code>NOT NULL</code> later using <code>ALTER TABLE</code>, but only if all existing rows already have non-NULL values in that column.</li>
        <li>If some rows contain <code>NULL</code>, you must first update or delete them before applying the constraint.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Removing a NOT NULL Constraint</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN email DROP NOT NULL;
</code></pre>
    <br/>
    <ul>
        <li>This makes the column nullable again, allowing future <code>NULL</code> values.</li>
        <li>Dropping <code>NOT NULL</code> is safe and does not affect existing data.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT with NOT NULL</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE tasks (
    task_id SERIAL PRIMARY KEY,
    description TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending'
);
</code></pre>
    <br/>
    <ul>
        <li>Combining <code>NOT NULL</code> with a <code>DEFAULT</code> value ensures the column is always filled — even if the user doesn't explicitly provide a value.</li>
        <li>Example insert:</li>
<pre><code class="language-sql line-numbers">INSERT INTO tasks (description) VALUES ('Review code');
-- status automatically becomes 'pending'</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Which Columns Are NOT NULL</b></li>
<pre><code class="language-sql line-numbers">SELECT
    column_name,
    is_nullable
FROM information_schema.columns
WHERE table_name = 'employees';
</code></pre>
    <br/>
    <ul>
        <li>The <code>is_nullable</code> column will show <code>NO</code> for <code>NOT NULL</code> columns and <code>YES</code> for nullable ones.</li>
        <li>Useful for verifying schema constraints in large databases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NOT NULL vs. CHECK Constraints</b></li>
    <br/>
    <ul>
        <li>You could technically write a <code>CHECK (column IS NOT NULL)</code> constraint, but <code>NOT NULL</code> is faster, simpler, and the standard method.</li>
        <li>Both enforce the same rule, but <code>NOT NULL</code> is built into the column definition and optimized by PostgreSQL.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior with Primary Keys</b></li>
    <br/>
    <ul>
        <li>Primary key columns are automatically <code>NOT NULL</code>, you don't need to specify it explicitly.</li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
</code></pre>
        <li>Even if you omit <code>NOT NULL</code>, the <code>PRIMARY KEY</code> constraint will enforce it internally.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>The DEFAULT Constraint in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>DEFAULT</code> constraint in PostgreSQL assigns an automatic value to a column when no value is specified during an <code>INSERT</code> operation.</li>
        <br/>
        <li>It helps maintain data consistency and prevents <code>NULL</code> values in cases where a sensible fallback value exists.</li>
        <br/>
        <li>Defaults can be constant values (like numbers or text), expressions, or even built-in PostgreSQL functions such as <code>CURRENT_DATE</code> or <code>NOW()</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type DEFAULT default_value,
    ...
);
</code></pre>
    <br/>
    <ul>
        <li>The <code>DEFAULT</code> keyword is placed after the data type when defining the column.</li>
        <li>If you omit the column in an <code>INSERT</code> statement, PostgreSQL automatically fills it with the default value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE tasks (
    task_id SERIAL PRIMARY KEY,
    description TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);
</code></pre>
    <br/>
    <ul>
        <li>When a new task is inserted without specifying <code>status</code> or <code>created_at</code>, PostgreSQL automatically assigns:
            <ul>
                <li><code>'pending'</code> to <code>status</code>.</li>
                <li>The current date and time (via <code>NOW()</code>) to <code>created_at</code>.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">INSERT INTO tasks (description) VALUES ('Write documentation');
-- status     → 'pending'
-- created_at → current timestamp
</code></pre>
    <br/>
    <br/>


    <li><b>Using DEFAULT with Numeric and Boolean Columns</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC(10,2) DEFAULT 0.00,
    available BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>If you omit <code>price</code> or <code>available</code> when inserting, PostgreSQL will assign <code>0.00</code> and <code>TRUE</code> respectively.</li>
        <li>This avoids the need to manually fill common defaults like <code>0</code>, <code>TRUE</code>, or <code>'N/A'</code> for each row.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using DEFAULT with Expressions</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) DEFAULT (0.0),
    order_ref TEXT DEFAULT ('ORD-' || EXTRACT(YEAR FROM CURRENT_DATE))
);
</code></pre>
    <br/>
    <ul>
        <li>Defaults can be expressions or function results — not just constants.</li>
        <li>Here:
            <ul>
                <li><code>CURRENT_DATE</code> fills in today's date automatically.</li>
                <li><code>('ORD-' || EXTRACT(YEAR FROM CURRENT_DATE))</code> generates a dynamic prefix for each order (e.g., <code>ORD-2025</code>).</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting Explicit DEFAULT Values</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO tasks (description, status)
VALUES ('Review code', DEFAULT);
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>DEFAULT</code> keyword explicitly in <code>INSERT</code> statements to apply the column's predefined default value.</li>
        <li>This is especially useful when inserting into selected columns but still wanting defaults for others.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a DEFAULT Constraint to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN active SET DEFAULT TRUE;
</code></pre>
    <br/>
    <ul>
        <li>You can add or modify default values using <code>ALTER TABLE</code>.</li>
        <li>Defaults affect only <u>future</u> inserts — existing rows remain unchanged unless updated manually.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Removing a DEFAULT Constraint</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ALTER COLUMN active DROP DEFAULT;
</code></pre>
    <br/>
    <ul>
        <li>After dropping the default, you must explicitly provide a value for that column when inserting new rows.</li>
        <li>If the column also has <code>NOT NULL</code>, inserts without a value will raise an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining DEFAULT with NOT NULL</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username TEXT NOT NULL,
    active BOOLEAN NOT NULL DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li>This combination ensures every user row always has a valid non-NULL value — either the provided one or the default <code>TRUE</code>.</li>
        <li>It's one of the most common patterns for robust schema design.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing Default Values</b></li>
<pre><code class="language-sql line-numbers">SELECT
    column_name,
    column_default
FROM information_schema.columns
WHERE table_name = 'tasks';
</code></pre>
    <br/>
    <ul>
        <li>The <code>column_default</code> column displays the default expressions or constant values assigned to each field.</li>
        <li>Useful for auditing and verifying schema configurations.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>The CHECK Constraint in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>CHECK</code> constraint ensures that data in a column or row meets a specified logical condition before it is inserted or updated.</li>
        <br/>
        <li>It acts like a built-in validation rule inside the database, preventing invalid or inconsistent values from being stored.</li>
        <br/>
        <li>When a row violates the condition defined by a <code>CHECK</code> constraint, PostgreSQL rejects the operation and raises an error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE table_name (
    column_name data_type CHECK (condition),
    ...
);
</code></pre>
    <br/>
    <ul>
        <li>You can apply <code>CHECK</code> directly to a single column or define it as a table-level constraint involving multiple columns.</li>
        <li>The condition must evaluate to <code>TRUE</code> or <code>NULL</code> (not <code>FALSE</code>), otherwise, the insert or update will fail.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Simple CHECK Constraint</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name  TEXT NOT NULL,
    salary      NUMERIC(10,2) CHECK (salary &gt;= 0)
);
</code></pre>
    <br/>
    <ul>
        <li>This constraint guarantees that <code>salary</code> values must always be greater than or equal to zero.</li>
        <li>Attempting to insert a negative salary will trigger an error.</li>
<pre><code class="language-text">ERROR:  new row for relation "employees" violates check constraint "employees_salary_check"
DETAIL: Failing row contains (-500).
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Multiple CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name       TEXT NOT NULL,
    price      NUMERIC(10,2) CHECK (price &gt;= 0),
    discount   NUMERIC(5,2) CHECK (discount BETWEEN 0 AND 100)
);
</code></pre>
    <br/>
    <ul>
        <li>Each <code>CHECK</code> is validated independently.</li>
        <li>PostgreSQL allows multiple <code>CHECK</code> constraints on the same table, each with its own rule.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Table-Level CHECK Constraint</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE accounts (
    account_id   SERIAL PRIMARY KEY,
    balance      NUMERIC(10,2),
    credit_limit NUMERIC(10,2),
    CHECK (balance &lt;= credit_limit)
);
</code></pre>
    <br/>
    <ul>
        <li>This constraint compares two columns in the same row.</li>
        <li>It ensures that the <code>balance</code> never exceeds the <code>credit_limit</code>.</li>
        <li>Unlike column-level checks, this form enforces a condition across multiple columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Adding a CHECK Constraint to an Existing Table</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
ADD CONSTRAINT salary_positive CHECK (salary &gt;= 0);
</code></pre>
    <br/>
    <ul>
        <li>You can add new named <code>CHECK</code> constraints later with <code>ALTER TABLE</code>.</li>
        <li>PostgreSQL immediately validates all existing rows — if any violate the rule, the command fails.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Dropping a CHECK Constraint</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE employees
DROP CONSTRAINT salary_positive;
</code></pre>
    <br/>
    <ul>
        <li>To remove a <code>CHECK</code> constraint, you must reference it by name.</li>
        <li>Use <code>\d table_name</code> in <code>psql</code> or query <code>pg_constraint</code> to see its name.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using CHECK with Logical Operators</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    age        INT CHECK (age &gt;= 5 AND age &lt;= 100),
    grade      TEXT CHECK (grade IN ('A', 'B', 'C', 'D', 'F'))
);
</code></pre>
    <br/>
    <ul>
        <li><code>AND</code>, <code>OR</code>, and <code>IN</code> can be combined inside the condition for complex logic.</li>
        <li>This example:
            <ul>
                <li>Ensures <code>age</code> stays within a reasonable range.</li>
                <li>Limits <code>grade</code> values to a predefined set of letters.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using Functions in CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email   TEXT CHECK (POSITION('@' IN email) &gt; 1)
);
</code></pre>
    <br/>
    <ul>
        <li>You can call PostgreSQL functions or expressions within <code>CHECK</code>.</li>
        <li>Here, <code>POSITION('@' IN email)</code> ensures that the <code>email</code> column contains an "@" symbol.</li>
        <li>However, for complex validations, application-level or trigger-based logic may be preferable.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Deferrable CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE accounts
ADD CONSTRAINT balance_valid CHECK (balance &lt;= credit_limit)
DEFERRABLE INITIALLY DEFERRED;
</code></pre>
    <br/>
    <ul>
        <li>A <code>DEFERRABLE</code> constraint can be checked at the end of a transaction instead of at each statement.</li>
        <li>This is useful when temporary violations occur during intermediate steps of a multi-step update.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Viewing CHECK Constraints</b></li>
<pre><code class="language-sql line-numbers">SELECT
    conname AS constraint_name,
    convalidated,
    condeferrable
FROM pg_constraint
WHERE contype = 'c' AND conrelid = 'employees'::regclass;
</code></pre>
    <br/>
    <ul>
        <li>Use the <code>pg_constraint</code> system catalog to inspect existing <code>CHECK</code> constraints.</li>
        <li><code>convalidated = true</code> indicates that all rows currently satisfy the constraint.</li>
    </ul>
    <br/>
    <br/>


    <li><b>CHECK vs. Application-Level Validation</b></li>
    <br/>
    <ul>
        <li>CHECK constraints are enforced at the database level — they cannot be bypassed by client errors or inconsistent application code.</li>
        <li>However:
            <ul>
                <li>They should remain simple and deterministic.</li>
                <li>Complex, cross-table validations (e.g., involving subqueries) are better handled with triggers or application logic.</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Foreign Keys in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <u>foreign key</u> establishes a relationship between two tables by linking a column (or set of columns) in one table to the <code>PRIMARY KEY</code> or <code>UNIQUE</code> column of another table.</li>
        <br/>
        <li>It enforces <b>referential integrity</b> — ensuring that a value in the referencing table must always match an existing value in the referenced table (or be <code>NULL</code> if allowed).</li>
        <br/>
        <li>Foreign keys prevent "orphan" records, i.e., rows that refer to non-existent data in another table.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE child_table (
    column_name data_type REFERENCES parent_table (parent_column)
);
</code></pre>
    <br/>
    <ul>
        <li>The <code>REFERENCES</code> keyword defines the link to the target table and column.</li>
        <li>By default, PostgreSQL enforces that the referenced value must exist in the parent table before it can be inserted into the child table.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Basic Foreign Key Relationship</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name        TEXT NOT NULL
);

CREATE TABLE orders (
    order_id     SERIAL PRIMARY KEY,
    customer_id  INT REFERENCES customers(customer_id),
    order_date   DATE NOT NULL DEFAULT CURRENT_DATE
);
</code></pre>
    <br/>
    <ul>
        <li>Here:
            <ul>
                <li><code>customers</code> is the <b>parent</b> table.</li>
                <li><code>orders</code> is the <b>child</b> table — each order must refer to a valid customer.</li>
            </ul>
        </li>
        <li>If you try to insert an order for a non-existent customer, PostgreSQL will reject it.</li>
<pre><code class="language-text">ERROR:  insert or update on table "orders" violates foreign key constraint "orders_customer_id_fkey"
DETAIL: Key (customer_id)=(999) is not present in table "customers".
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Foreign Key Constraint Naming</b></li>
    <br/>
    <ul>
        <li>PostgreSQL automatically generates a name (e.g. <code>orders_customer_id_fkey</code>), but you can define your own for clarity:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT,
    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers (customer_id)
);
</code></pre>
        <li>Explicit naming is recommended for maintainability, especially in large schemas.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Inserting and Deleting Data</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO customers (name) VALUES ('Alice');
INSERT INTO orders (customer_id) VALUES (1);  -- valid

INSERT INTO orders (customer_id) VALUES (999); -- invalid
</code></pre>
    <br/>
    <ul>
        <li>You can only insert a child row if the referenced parent row exists.</li>
        <li>If you delete a parent row that is still referenced by children, PostgreSQL will block the operation unless an <code>ON DELETE</code> rule is specified.</li>
    </ul>
    <br/>
    <br/>


    <li><b>ON DELETE and ON UPDATE Actions</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides several options for handling parent changes:</li>
        <table>
            <thead>
                <tr>
                    <th>Action</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>NO ACTION</code> (default)</td>
                    <td>Rejects the change if it would break referential integrity.</td>
                    <td><code>ON DELETE NO ACTION</code></td>
                </tr>
                <tr>
                    <td><code>RESTRICT</code></td>
                    <td>Similar to <code>NO ACTION</code>, but checked immediately instead of at the end of the transaction.</td>
                    <td><code>ON DELETE RESTRICT</code></td>
                </tr>
                <tr>
                    <td><code>CASCADE</code></td>
                    <td>Deletes or updates dependent child rows automatically.</td>
                    <td><code>ON DELETE CASCADE</code></td>
                </tr>
                <tr>
                    <td><code>SET NULL</code></td>
                    <td>Sets the child's foreign key column to <code>NULL</code>.</td>
                    <td><code>ON DELETE SET NULL</code></td>
                </tr>
                <tr>
                    <td><code>SET DEFAULT</code></td>
                    <td>Sets the column to its default value (must be valid or NULL).</td>
                    <td><code>ON DELETE SET DEFAULT</code></td>
                </tr>
            </tbody>
        </table>
    </ul>
    <br/>
    <ul>
        <li>Example:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);
</code></pre>
        <li>Now if you delete a customer, all their orders are automatically deleted too.</li>
        <li>If the customer's ID changes (rare but possible), the foreign key in <code>orders</code> updates automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using SET NULL and SET DEFAULT</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id)
        ON DELETE SET NULL
);
</code></pre>
    <br/>
    <ul>
        <li>When the referenced customer is deleted, the foreign key in <code>orders</code> becomes <code>NULL</code>.</li>
        <li>This requires the foreign key column to allow <code>NULL</code> values, otherwise, PostgreSQL will reject the setup.</li>
    </ul>
    <br/>
    <ul>
        <li>Example with <code>SET DEFAULT</code>:</li>
<pre><code class="language-sql line-numbers">CREATE TABLE orders (
    order_id    SERIAL PRIMARY KEY,
    customer_id INT DEFAULT 0 REFERENCES customers(customer_id) ON DELETE SET DEFAULT
);
</code></pre>
        <li>Here, when a customer is deleted, all their orders will have <code>customer_id</code> reset to <code>0</code> (a placeholder or "unassigned" value).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Composite Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE enrollments (
    student_id INT,
    course_id  INT,
    PRIMARY KEY (student_id, course_id)
);

CREATE TABLE grades (
    student_id INT,
    course_id  INT,
    grade      CHAR(2),
    FOREIGN KEY (student_id, course_id)
        REFERENCES enrollments (student_id, course_id)
        ON DELETE CASCADE
);
</code></pre>
    <br/>
    <ul>
        <li>Composite keys reference multiple columns together, maintaining multi-column relationships.</li>
        <li>The number and order of columns in the <code>FOREIGN KEY</code> must exactly match those in the referenced key.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Deferrable Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE orders
ADD CONSTRAINT fk_customer
    FOREIGN KEY (customer_id)
    REFERENCES customers (customer_id)
    DEFERRABLE INITIALLY DEFERRED;
</code></pre>
    <br/>
    <ul>
        <li>Normally, PostgreSQL checks foreign key integrity immediately when you insert or update a row.</li>
        <li>With <code>DEFERRABLE INITIALLY DEFERRED</code>, checks occur only when the transaction commits — allowing temporary inconsistencies within a transaction.</li>
        <li>Example use case: cyclic relationships between tables that reference each other.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Checking Existing Foreign Keys</b></li>
<pre><code class="language-sql line-numbers">SELECT
    conname             AS constraint_name,
    conrelid::regclass  AS table_name,
    confrelid::regclass AS referenced_table,
    confupdtype         AS on_update,
    confdeltype         AS on_delete
FROM pg_constraint
WHERE contype = 'f';
</code></pre>
    <br/>
    <ul>
        <li>The <code>pg_constraint</code> system catalog stores all foreign key definitions.</li>
        <li>The <code>confdeltype</code> and <code>confupdtype</code> columns contain codes for delete/update actions:
            <ul>
                <li><code>a</code> — NO ACTION</li>
                <li><code>r</code> — RESTRICT</li>
                <li><code>c</code> — CASCADE</li>
                <li><code>n</code> — SET NULL</li>
                <li><code>d</code> — SET DEFAULT</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Behavior When Dropping Referenced Tables</b></li>
<pre><code class="language-sql line-numbers">DROP TABLE customers;
-- ERROR:  cannot drop table customers because other objects depend on it
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL blocks the drop to preserve referential integrity.</li>
        <li>You can force the removal (and automatically drop all dependent constraints) using <code>CASCADE</code>:</li>
<pre><code class="language-sql line-numbers">DROP TABLE customers CASCADE;</code></pre>
        <li>This will also remove all foreign key constraints in child tables that reference it, but the child tables themselves remain intact.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULL and Foreign Keys</b></li>
    <br/>
    <ul>
        <li>Foreign key columns can contain <code>NULL</code> unless defined as <code>NOT NULL</code>.</li>
        <li>When <code>NULL</code> is present, PostgreSQL skips foreign key validation for that row (because "unknown" cannot be compared).</li>
        <li>This allows optional relationships — e.g., an <code>order</code> that may not yet be linked to a <code>customer</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>PostgreSQL automatically creates indexes on the referenced columns in the parent table (if they are primary or unique keys).</li>
        <li>However, you may also create indexes on the foreign key columns in the child table for faster joins and deletions:</li>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_orders_customer_id ON orders(customer_id);
</code></pre>
        <li>This improves query performance when filtering or joining on the foreign key.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics on Joining Tables in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>JOIN</code> combines rows from two or more tables based on a related column between them.</li>
        <br/>
        <li>In PostgreSQL, joins are performed using the <code>JOIN</code> keyword together with <code>ON</code> or <code>USING</code> clauses that specify matching columns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic JOIN Syntax</b></li>
<pre><code class="language-sql line-numbers">SELECT columns
FROM table1
JOIN table2
  ON table1.column_name = table2.column_name;
</code></pre>
    <br/>
    <ul>
        <li><code>JOIN</code> matches rows from both tables where the condition is true.</li>
        <li>By default, <code>JOIN</code> means <code>INNER JOIN</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example Setup</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    city TEXT
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE DEFAULT CURRENT_DATE,
    amount NUMERIC(10,2)
);

INSERT INTO customers (name, city)
VALUES ('Alice', 'Berlin'),
       ('Bob', 'Munich'),
       ('Charlie', 'Hamburg');

INSERT INTO orders (customer_id, amount)
VALUES (1, 120.00),
       (1, 90.50),
       (2, 45.00);
</code></pre>
    <br/>
    <ul>
        <li>This setup lets us explore all join types using <code>customers</code> and <code>orders</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>INNER JOIN</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
INNER JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>INNER JOIN</code> returns only rows with matching values in both tables.</li>
        <li>If a customer has no orders, that customer will not appear in the result.</li>
        <li>Result:</li>
<pre><code class="language-text"> name   | order_id | amount
--------+-----------+--------
 Alice  |     1     | 120.00
 Alice  |     2     |  90.50
 Bob    |     3     |  45.00
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>2. LEFT JOIN (or LEFT OUTER JOIN)</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
LEFT JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>LEFT JOIN</code> returns all rows from the left table (<code>customers</code>), and the matching rows from the right table (<code>orders</code>).</li>
        <li>If no match exists, PostgreSQL fills right-side columns with <code>NULL</code>.</li>
        <li>Result:</li>
<pre><code class="language-text"> name     | order_id | amount
----------+-----------+--------
 Alice    |     1     | 120.00
 Alice    |     2     |  90.50
 Bob      |     3     |  45.00
 Charlie  |   NULL    | NULL
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>RIGHT JOIN (or RIGHT OUTER JOIN)</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
RIGHT JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>RIGHT JOIN</code> returns all rows from the right table (<code>orders</code>) and matching rows from the left table (<code>customers</code>).</li>
        <li>Unmatched rows from the left table will appear as <code>NULL</code>.</li>
        <li>Typically less used than <code>LEFT JOIN</code> because you can just swap the table order.</li>
    </ul>
    <br/>
    <br/>


    <li><b>FULL JOIN (or FULL OUTER JOIN)</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id,
    orders.amount
FROM customers
FULL JOIN orders
    ON customers.customer_id = orders.customer_id;
</code></pre>
    <br/>
    <ul>
        <li><code>FULL JOIN</code> returns all rows from both tables, matching them when possible.</li>
        <li>Unmatched rows from either table get <code>NULL</code> values in the missing columns.</li>
        <li>Result example if some rows had no counterpart:</li>
<pre><code class="language-text"> name     | order_id | amount
----------+-----------+--------
 Alice    |     1     | 120.00
 Alice    |     2     |  90.50
 Bob      |     3     |  45.00
 Charlie  |   NULL    | NULL
 NULL     |     4     |  80.00   -- order without a known customer
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>CROSS JOIN</b></li>
<pre><code class="language-sql line-numbers">SELECT
    customers.name,
    orders.order_id
FROM customers
CROSS JOIN orders;
</code></pre>
    <br/>
    <ul>
        <li><code>CROSS JOIN</code> produces the <b>Cartesian product</b> — every row from the first table is combined with every row from the second.</li>
        <li>Use with caution — the number of rows grows rapidly (e.g., 10 × 10 = 100).</li>
        <li>This join type does not require an <code>ON</code> condition.</li>
    </ul>
    <br/>
    <br/>


    <li><b>SELF JOIN</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name TEXT,
    manager_id INT REFERENCES employees(employee_id)
);

SELECT e.name AS employee,
       m.name AS manager
FROM employees e
LEFT JOIN employees m
  ON e.manager_id = m.employee_id;
</code></pre>
    <br/>
    <ul>
        <li>A <b>self join</b> joins a table to itself — useful for hierarchical or tree-like data such as employees and managers.</li>
        <li>Aliases (<code>e</code>, <code>m</code>) are necessary to distinguish between the two instances of the same table.</li>
    </ul>
    <br/>
    <br/>


    <li><b>USING Clause</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM customers
JOIN orders USING (customer_id);
</code></pre>
    <br/>
    <ul>
        <li>The <code>USING (column_name)</code> syntax is a shortcut when both tables share a column with the same name.</li>
        <li>It automatically merges the duplicate join column in the output, so you'll see only one <code>customer_id</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>8. Joining More Than Two Tables</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    product_name TEXT,
    quantity INT
);

SELECT
    c.name AS customer,
    o.order_id,
    i.product_name,
    i.quantity
FROM customers c
JOIN orders o
  ON c.customer_id = o.customer_id
JOIN order_items i
  ON o.order_id = i.order_id;
</code></pre>
    <br/>
    <ul>
        <li>You can chain multiple <code>JOIN</code> clauses in one query.</li>
        <li>Each <code>JOIN</code> connects one more table through a matching condition.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Filtering After Joins</b></li>
<pre><code class="language-sql line-numbers">SELECT
    c.name, o.amount
FROM customers c
JOIN orders o
  ON c.customer_id = o.customer_id
WHERE o.amount &gt; 50;
</code></pre>
    <br/>
    <ul>
        <li>You can use <code>WHERE</code>, <code>ORDER BY</code>, <code>LIMIT</code>, and other clauses after joining.</li>
        <li>PostgreSQL first performs the join, then filters the results according to your conditions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NATURAL JOIN</b></li>
<pre><code class="language-sql line-numbers">SELECT *
FROM customers
NATURAL JOIN orders;
</code></pre>
    <br/>
    <ul>
        <li><code>NATURAL JOIN</code> automatically joins tables using all columns with the same names.</li>
        <li>While convenient, it can be dangerous — if new columns with the same name are added later, join behavior may change unexpectedly.</li>
        <li>Use <code>JOIN ... USING (...)</code> instead for clarity and control.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Considerations</b></li>
    <br/>
    <ul>
        <li>Joins can be computationally expensive for large tables.</li>
        <li>To optimize performance:
            <ul>
                <li>Ensure both sides of join conditions are indexed (especially foreign key columns).</li>
                <li>Use <code>EXPLAIN</code> to analyze query plans and check for sequential scans.</li>
                <li>Limit unnecessary joins — fetch only required columns.</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-sql line-numbers">EXPLAIN SELECT * FROM customers JOIN orders ON customers.customer_id = orders.customer_id;</code></pre>
    <br/>
    <ul>
        <li>This shows how PostgreSQL executes the join internally (e.g., nested loop, hash join, merge join).</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Set Operations in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Set operations</u> in PostgreSQL allow you to combine the results of two or more <code>SELECT</code> queries into a single result set.</li>
        <br/>
        <li>They work on complete rows (as sets), not on individual columns.</li>
        <br/>
        <li>Common operations include:
            <ul>
                <li><code>UNION</code> – combine and remove duplicates.</li>
                <li><code>UNION ALL</code> – combine and keep duplicates.</li>
                <li><code>INTERSECT</code> – return only rows common to both queries.</li>
                <li><code>EXCEPT</code> – return rows from the first query that are not in the second.</li>
            </ul>
        </li>
        <br/>
        <li>Each query in a set operation MUST:
            <ul>
                <li>Select the <u>same number of columns</u>.</li>
                <li>Have <u>compatible data types</u> for corresponding columns.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Example Setup</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE students_2024 (
    name TEXT,
    city TEXT
);

CREATE TABLE students_2025 (
    name TEXT,
    city TEXT
);

INSERT INTO students_2024 VALUES
    ('Alice', 'Berlin'),
    ('Bob', 'Munich'),
    ('Charlie', 'Hamburg');

INSERT INTO students_2025 VALUES
    ('Alice', 'Berlin'),
    ('David', 'Stuttgart'),
    ('Ella', 'Munich');
</code></pre>
    <br/>
    <ul>
        <li>We now have two tables with overlapping and distinct rows.</li>
    </ul>
    <br/>
    <br/>


    <li><b>1. UNION — Combine and Remove Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
UNION
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION</code> merges the two result sets and automatically removes duplicates.</li>
        <li>The combined result is sorted and distinct by default.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Alice      | Berlin
 Bob        | Munich
 Charlie    | Hamburg
 David      | Stuttgart
 Ella       | Munich
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>2. UNION ALL — Combine and Keep Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
UNION ALL
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>UNION ALL</code> keeps duplicate rows, without sorting or removing them.</li>
        <li>It is faster than <code>UNION</code> because PostgreSQL skips duplicate checking.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Alice      | Berlin
 Bob        | Munich
 Charlie    | Hamburg
 Alice      | Berlin
 David      | Stuttgart
 Ella       | Munich
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>3. INTERSECT — Common Rows Only</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
INTERSECT
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>INTERSECT</code> returns only the rows that appear in <b>both</b> queries.</li>
        <li>Duplicates are automatically removed.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Alice      | Berlin
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>4. INTERSECT ALL — Common Rows, Keep Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
INTERSECT ALL
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>INTERSECT ALL</code> keeps duplicates as they appear in both results.</li>
        <li>If a row appears twice in both tables, it appears twice in the output.</li>
        <li>Since our data has only one matching row, the result is identical to <code>INTERSECT</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>5. EXCEPT — Rows in First Query but Not in Second</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
EXCEPT
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>EXCEPT</code> returns all rows from the first query that do not appear in the second.</li>
        <li>Duplicates are removed automatically.</li>
        <li>Result:</li>
<pre><code class="language-text">   name    |    city
------------+------------
 Bob        | Munich
 Charlie    | Hamburg
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>6. EXCEPT ALL — Keep Duplicates</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM students_2024
EXCEPT ALL
SELECT * FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li><code>EXCEPT ALL</code> behaves like <code>EXCEPT</code>, but keeps duplicates according to their frequency in the first query minus the second.</li>
        <li>Example: if a row appears 3 times in the first query and once in the second, it appears twice in the result.</li>
    </ul>
    <br/>
    <br/>


    <li><b>7. Matching Columns and Types</b></li>
<pre><code class="language-sql line-numbers">-- This will fail:
SELECT name FROM students_2024
UNION
SELECT name, city FROM students_2025;
</code></pre>
    <br/>
    <ul>
        <li>All participating queries in a set operation must have:
            <ul>
                <li>The <b>same number of columns</b>.</li>
                <li><b>Compatible data types</b> in corresponding positions.</li>
            </ul>
        </li>
        <li>Otherwise PostgreSQL will raise an error:</li>
<pre><code class="language-text">ERROR:  each UNION query must have the same number of columns
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>8. Sorting Combined Results</b></li>
<pre><code class="language-sql line-numbers">SELECT name, city FROM students_2024
UNION
SELECT name, city FROM students_2025
ORDER BY name;
</code></pre>
    <br/>
    <ul>
        <li>Use <code>ORDER BY</code> only <b>after the final set operation</b> — not inside each <code>SELECT</code>.</li>
        <li>PostgreSQL treats the combined output as one large table that can be sorted or filtered further.</li>
    </ul>
    <br/>
    <br/>


    <li><b>9. Using Parentheses for Complex Set Operations</b></li>
<pre><code class="language-sql line-numbers">(SELECT * FROM students_2024
 UNION
 SELECT * FROM students_2025)
EXCEPT
SELECT * FROM expelled_students;
</code></pre>
    <br/>
    <ul>
        <li>Parentheses control the evaluation order when mixing multiple set operators.</li>
        <li>Without parentheses, PostgreSQL evaluates from left to right.</li>
        <li>Use parentheses to make complex logic clear and unambiguous.</li>
    </ul>
    <br/>
    <br/>


    <li><b>10. Combining with WHERE or JOIN Clauses</b></li>
<pre><code class="language-sql line-numbers">SELECT name, city FROM students_2024 WHERE city = 'Munich'
UNION
SELECT name, city FROM students_2025 WHERE city = 'Munich';
</code></pre>
    <br/>
    <ul>
        <li>Each <code>SELECT</code> can include its own <code>WHERE</code>, <code>JOIN</code>, or <code>GROUP BY</code> clause before the set operation.</li>
        <li>This allows you to filter and process each dataset independently before combining them.</li>
    </ul>
    <br/>
    <br/>


    <li><b>11. Performance Considerations</b></li>
    <br/>
    <ul>
        <li><code>UNION</code> and <code>INTERSECT</code> remove duplicates — they require sorting or hashing internally, which can be expensive on large data sets.</li>
        <li><code>UNION ALL</code> and <code>EXCEPT ALL</code> skip this step and are generally faster.</li>
        <li>When possible, use <code>UNION ALL</code> if you are sure duplicates are not an issue.</li>
    </ul>
<pre><code class="language-sql line-numbers">EXPLAIN SELECT * FROM students_2024 UNION SELECT * FROM students_2025;</code></pre>
    <br/>
    <ul>
        <li><code>EXPLAIN</code> helps visualize how PostgreSQL performs the merge internally.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>The BOOLEAN Type in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>The <code>BOOLEAN</code> type in PostgreSQL represents truth values — logical <b>true</b> or <b>false</b> conditions.</li>
        <br/>
        <li>It is often used in columns that represent yes/no, on/off, or active/inactive states.</li>
        <br/>
        <li>Unlike databases that simulate booleans with integers (e.g. 0/1), PostgreSQL has a <b>native</b> boolean type with its own rules and accepted literals.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Declaration Syntax</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    name    TEXT NOT NULL,
    active  BOOLEAN DEFAULT TRUE
);
</code></pre>
    <br/>
    <ul>
        <li><code>BOOLEAN</code> columns can take values <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Accepted Literal Values</b></li>
    <br/>
    <ul>
        <li>PostgreSQL accepts a variety of textual and numeric representations for boolean values:</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Meaning</th>
                    <th>Accepted Values</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><b>TRUE</b></td>
                    <td><code>TRUE</code>, <code>'t'</code>, <code>'true'</code>, <code>'y'</code>, <code>'yes'</code>, <code>'on'</code>, <code>'1'</code></td>
                </tr>
                <tr>
                    <td><b>FALSE</b></td>
                    <td><code>FALSE</code>, <code>'f'</code>, <code>'false'</code>, <code>'n'</code>, <code>'no'</code>, <code>'off'</code>, <code>'0'</code></td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>The matching is <u>case-insensitive</u>, so <code>'True'</code>, <code>'YES'</code>, and <code>'On'</code> all work the same.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Examples of Insertion</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO users (name, active)
VALUES
    ('Alice', TRUE),
    ('Bob', 'yes'),
    ('Charlie', 'f'),
    ('Diana', 0);

SELECT * FROM users;
</code></pre>
    <br/>
    <ul>
        <li>PostgreSQL automatically interprets <code>'yes'</code>, <code>'f'</code>, and <code>0</code> according to the truth table above.</li>
        <li>Result:</li>
<pre><code class="language-text"> user_id |  name    | active
----------+----------+---------
 1        | Alice    | t
 2        | Bob      | t
 3        | Charlie  | f
 4        | Diana    | f
</code></pre>
        <li><code>t</code> and <code>f</code> are how PostgreSQL displays boolean values by default.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean Display Formats</b></li>
    <br/>
    <ul>
        <li>Although PostgreSQL stores booleans internally as true/false, by default it displays them as <code>t</code> and <code>f</code>.</li>
        <li>This is a historical choice compatible with early UNIX and SQL standards.</li>
        <li>You can cast or format them differently if needed:</li>
<pre><code class="language-sql line-numbers">SELECT active::text FROM users;
-- Outputs: 't', 'f'

SELECT
    CASE
        WHEN active THEN 'Active'
        ELSE 'Inactive'
    END
FROM users;
-- Custom labels for boolean output
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Using Booleans in Conditions</b></li>
<pre><code class="language-sql line-numbers">SELECT * FROM users WHERE active = TRUE;

-- Shorter equivalent:
SELECT * FROM users WHERE active;

-- Opposite:
SELECT * FROM users WHERE NOT active;
</code></pre>
    <br/>
    <ul>
        <li>You can write conditions with or without explicitly comparing to <code>TRUE</code> or <code>FALSE</code>.</li>
        <li>The expression <code>WHERE active</code> is shorthand for <code>WHERE active = TRUE</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>NULL with Boolean Columns</b></li>
<pre><code class="language-sql line-numbers">INSERT INTO users (name, active) VALUES ('Eve', NULL);

SELECT name,
       CASE
         WHEN active THEN 'True'
         WHEN NOT active THEN 'False'
         ELSE 'Unknown'
       END AS status
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>Boolean columns can be <code>NULL</code>, representing "unknown" or "not specified."</li>
        <li>This is different from <code>FALSE</code> — PostgreSQL treats <code>NULL</code> as neither true nor false.</li>
        <li>The <code>CASE</code> statement (or <code>COALESCE</code>) can be used to handle <code>NULL</code> explicitly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean Operators</b></li>
    <br/>
    <ul>
        <li>PostgreSQL supports standard logical operators on boolean expressions:</li>
        <table>
            <thead>
                <tr>
                    <th>Operator</th>
                    <th>Description</th>
                    <th>Example</th>
                    <th>Result</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>AND</code></td>
                    <td>True if both operands are true</td>
                    <td><code>TRUE AND FALSE</code></td>
                    <td>FALSE</td>
                </tr>
                <tr>
                    <td><code>OR</code></td>
                    <td>True if at least one operand is true</td>
                    <td><code>TRUE OR FALSE</code></td>
                    <td>TRUE</td>
                </tr>
                <tr>
                    <td><code>NOT</code></td>
                    <td>Negates the boolean value</td>
                    <td><code>NOT TRUE</code></td>
                    <td>FALSE</td>
                </tr>
            </tbody>
        </table>
        <br/>
        <li>Example usage inside a query:</li>
<pre><code class="language-sql line-numbers">SELECT * FROM users
WHERE active OR name = 'Alice';
</code></pre>
    </ul>
    <br/>
    <br/>


    <li><b>Boolean Expressions in SELECT</b></li>
<pre><code class="language-sql line-numbers">SELECT name,
       (active AND city = 'Berlin') AS active_in_berlin
FROM users;
</code></pre>
    <br/>
    <ul>
        <li>Boolean expressions can appear directly in the <code>SELECT</code> list — returning <code>t</code>, <code>f</code>, or <code>NULL</code> per row.</li>
        <li>This is useful for logical flags or derived states.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Indexing Boolean Columns</b></li>
    <br/>
    <ul>
        <li>Boolean columns typically have low selectivity (few distinct values), so simple indexes are often not useful.</li>
        <li>However, you can create <u>partial indexes</u> to speed up queries on a specific boolean value:</li>
<pre><code class="language-sql line-numbers">CREATE INDEX idx_users_active_true
ON users (user_id)
WHERE active = TRUE;
</code></pre>
        <li>This makes <code>WHERE active = TRUE</code> queries faster without indexing inactive users.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Converting Between Boolean and Other Types</b></li>
<pre><code class="language-sql line-numbers">SELECT CAST(TRUE AS INT);   -- returns 1
SELECT CAST(FALSE AS INT);  -- returns 0

SELECT CAST(1 AS BOOLEAN);  -- returns TRUE
SELECT CAST(0 AS BOOLEAN);  -- returns FALSE
</code></pre>
    <br/>
    <ul>
        <li>You can cast between <code>BOOLEAN</code> and <code>INTEGER</code> types if needed.</li>
        <li>PostgreSQL follows standard semantics: <code>TRUE → 1</code>, <code>FALSE → 0</code>.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Character Types: CHAR, VARCHAR, and TEXT in PostgreSQL</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>PostgreSQL provides several types for storing textual data: <code>CHAR</code>, <code>VARCHAR</code>, and <code>TEXT</code>.</li>
        <br/>
        <li>Although they appear similar, they differ in how they handle length, padding, and validation.</li>
        <br/>
        <li>All three are stored efficiently as variable-length strings internally, but their behavior and use cases differ slightly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>CHAR(n) — Fixed-Length Character Type</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products_char (
    code CHAR(5),
    name TEXT
);

INSERT INTO products_char VALUES ('AB', 'Widget');
SELECT code, LENGTH(code) FROM products_char;
</code></pre>
    <br/>
    <ul>
        <li><code>CHAR(n)</code> (or <code>CHARACTER(n)</code>) stores <b>exactly <code>n</code> characters</b>.</li>
        <li>If you insert a shorter string, PostgreSQL <b>pads it with spaces</b> to the fixed length.</li>
        <li>If you insert a longer string, it is <b>truncated</b>.</li>
        <li>Result:</li>
<pre><code class="language-text"> code  | length
-------+--------
 AB    | 5
</code></pre>
        <li>Notice how <code>'AB'</code> was stored as <code>'AB   '</code> (with padding).</li>
        <li>Useful when strings must have uniform length (e.g., fixed codes, legacy systems).</li>
    </ul>
    <br/>
    <br/>


    <li><b>VARCHAR(n) — Variable-Length with Limit</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE products_varchar (
    code VARCHAR(5),
    name TEXT
);

INSERT INTO products_varchar VALUES ('AB', 'Widget');
INSERT INTO products_varchar VALUES ('ABCDE', 'Gadget');
</code></pre>
    <br/>
    <ul>
        <li><code>VARCHAR(n)</code> (or <code>CHARACTER VARYING(n)</code>) stores a string <b>upto <code>n</code> characters</b> long.</li>
        <li>It <b>does not pad</b> shorter strings with spaces.</li>
        <li>If the input exceeds <code>n</code>, PostgreSQL raises an error:</li>
<pre><code class="language-text">ERROR:  value too long for type character varying(5)
</code></pre>
        <li>This type is ideal when you need a length restriction (e.g., usernames ≤ 50 characters).</li>
    </ul>
    <br/>
    <br/>


    <li><b>TEXT — Unlimited-Length Variable Text</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT,
    content TEXT
);

INSERT INTO articles (title, content)
VALUES ('Intro to PostgreSQL', 'PostgreSQL is a powerful open-source RDBMS...');
</code></pre>
    <br/>
    <ul>
        <li><code>TEXT</code> stores strings of <b>any length</b> (up to about 1 GB per field).</li>
        <li>It does not require you to specify a limit and does not pad or truncate values.</li>
        <li>Functionally equivalent to <code>VARCHAR</code> without a length limit — same performance, same behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Between CHAR, VARCHAR, and TEXT</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Behavior</th>
                <th>Length Limit</th>
                <th>Padded?</th>
                <th>Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>CHAR(n)</code></td>
                <td>Fixed-length</td>
                <td>Yes</td>
                <td>Yes (spaces)</td>
                <td>Fixed-size codes, legacy data</td>
            </tr>
            <tr>
                <td><code>VARCHAR(n)</code></td>
                <td>Variable-length, validated</td>
                <td>Yes</td>
                <td>No</td>
                <td>Text with known maximum length (e.g., names)</td>
            </tr>
            <tr>
                <td><code>TEXT</code></td>
                <td>Variable-length, unlimited</td>
                <td>No</td>
                <td>No</td>
                <td>General-purpose text, documents, comments</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>CHAR vs VARCHAR vs TEXT in Practice</b></li>
<pre><code class="language-sql line-numbers">CREATE TABLE demo (
    c1 CHAR(5),
    c2 VARCHAR(5),
    c3 TEXT
);

INSERT INTO demo VALUES ('AB', 'AB', 'AB');
SELECT c1, c2, c3, LENGTH(c1), LENGTH(c2), LENGTH(c3) FROM demo;
</code></pre>
    <br/>
    <ul>
        <li>Result:</li>
<pre><code class="language-text"> c1     | c2 | c3 | length
---------+----+----+--------
 AB     | AB | AB | 5  2  2
</code></pre>
        <li><code>CHAR(5)</code> pads to 5 characters, while <code>VARCHAR</code> and <code>TEXT</code> store only what you insert.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance and Storage</b></li>
    <br/>
    <ul>
        <li>Internally, PostgreSQL stores <code>CHAR</code>, <code>VARCHAR</code>, and <code>TEXT</code> using the same variable-length storage format (<code>varlena</code>).</li>
        <br/>
        <li>There is <b>no performance difference</b> between <code>TEXT</code> and <code>VARCHAR(n)</code> for most workloads.</li>
        <br/>
        <li>The only difference lies in input validation and space padding behavior — not storage or speed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Trimming and Padding</b></li>
<pre><code class="language-sql line-numbers">SELECT 'abc'::CHAR(5) = 'abc'::CHAR(5);  -- TRUE
SELECT 'abc'::CHAR(5) = 'abc';           -- TRUE (ignores padding)
SELECT LENGTH('abc'::CHAR(5));           -- 5
</code></pre>
    <br/>
    <ul>
        <li>When comparing <code>CHAR(n)</code> values, PostgreSQL ignores trailing spaces.</li>
        <li>This means <code>'AB   '</code> and <code>'AB'</code> compare as equal.</li>
        <li>However, when concatenating or measuring string length, padding spaces remain visible.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Changing Length or Type</b></li>
<pre><code class="language-sql line-numbers">ALTER TABLE products_varchar
ALTER COLUMN code TYPE VARCHAR(10);

ALTER TABLE products_char
ALTER COLUMN code TYPE TEXT;
</code></pre>
    <br/>
    <ul>
        <li>You can safely change between these text types if data fits within the new limits.</li>
        <li>When increasing the <code>VARCHAR</code> length, PostgreSQL validates existing data automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Compatibility</b></li>
<pre><code class="language-sql line-numbers">SELECT UPPER(code), LOWER(name)
FROM products_varchar;

SELECT LENGTH(content), LEFT(content, 20)
FROM articles;
</code></pre>
    <br/>
    <ul>
        <li>All three types (<code>CHAR</code>, <code>VARCHAR</code>, <code>TEXT</code>) are fully compatible with PostgreSQL string functions and operators.</li>
        <li>You can use <code>UPPER()</code>, <code>LOWER()</code>, <code>CONCAT()</code>, <code>LENGTH()</code>, <code>TRIM()</code>, etc., interchangeably.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Recommended Usage</b></li>
    <br/>
    <ul>
        <li>PostgreSQL documentation itself recommends using <code>TEXT</code> for most textual data.</li>
        <li><b>Guidelines:</b>
            <ul>
                <li>Use <code>TEXT</code> when you don’t need a maximum length restriction.</li>
                <li>Use <code>VARCHAR(n)</code> if you want to enforce a limit (e.g., 50 characters for a username).</li>
                <li>Use <code>CHAR(n)</code> only when you must store fixed-length data (e.g., ISO codes, status flags).</li>
            </ul>
        </li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>More to be expected...</h3>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
