<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>chez scheme</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/chez.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#scm-syntax-overview">Syntax Overview</a></li>
        <li><a href="#scm-multiple-expressions">Multiple Expressions</a></li>
        <li><a href="#scm-naming-conventions">Naming Conventions</a></li>
        <li><a href="#scm-compiler-interpreter">Interacting with Chez Scheme</a></li>
        <li><a href="#scm-command-line-options">Command Line Options</a></li>
        <li><a href="#scm-r6rs">R6RS</a></li>
        <li><a href="#scm-control-flow">Control Flow</a></li>
        <li><a href="#scm-debugging">Debugging</a></li>
        <li><a href="#scm-foreign-interface">Foreign Interface</a></li>
        <li><a href="#scm-binding-forms">Binding Forms</a></li>
        <li><a href="#scm-control-structures">Control Structures</a></li>
        <li><a href="#scm-operations-objects">Operations on Objects</a></li>
        <li><a href="#scm-numeric-operations">Numeric Operations</a></li>
        <li><a href="#scm-input-output">Input / Output</a></li>
        <li><a href="#scm-"></a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-syntax-overview">Chez Scheme Syntax Overview</h3>
<ol>

    <li>Understanding Scheme Basics</li>
    <br/>
    <ul>
        <li>Scheme is a dialect of Lisp with minimal, elegant syntax.</li>
        <br/>
        <li><b>Core principle:</b> Everything is an expression that returns a value.</li>
        <br/>
        <li><b>Syntax pattern:</b> <code>(function arg1 arg2 arg3 ...)</code></li>
        <ul>
            <li>Parentheses group expressions</li>
            <li>First element is the function/operator</li>
            <li>Remaining elements are arguments</li>
            <li>This is called "prefix notation" or "Polish notation"</li>
        </ul>
        <br/>
        <li><b>Examples of basic syntax:</b></li>
<pre><code class="language-scheme line-numbers">; Addition
(+ 2 3)          ; Returns: 5

; Multiplication
(* 4 5)          ; Returns: 20

; Function call
(string-length "hello")  ; Returns: 5

; Nested expressions
(+ (* 2 3) 4)    ; Returns: 10
                 ; First evaluates (* 2 3) = 6
                 ; Then evaluates (+ 6 4) = 10</code></pre>
        <br/>
        <li><b>Comments:</b></li>
<pre><code class="language-scheme line-numbers">; Single-line comment starts with semicolon

#|
  Multi-line
  comment between
  #| and |#
|#</code></pre>
        <br/>
        <li><b>Case sensitivity:</b> Scheme is case-insensitive by default, but Chez Scheme preserves case.</li>
<pre><code class="language-scheme line-numbers">(define MyVar 10)
MyVar    ; Works
MYVAR    ; Doesn't Work</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Data Types</li>
    <br/>
    <ul>
        <li>Scheme has several fundamental data types:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Examples</th>
            <th>Predicate</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Number</td>
            <td><code>42</code>, <code>3.14</code>, <code>1/3</code>, <code>2+3i</code></td>
            <td><code>number?</code></td>
        </tr>
        <tr>
            <td>Boolean</td>
            <td><code>#t</code>, <code>#f</code></td>
            <td><code>boolean?</code></td>
        </tr>
        <tr>
            <td>String</td>
            <td><code>"hello"</code>, <code>"world"</code></td>
            <td><code>string?</code></td>
        </tr>
        <tr>
            <td>Character</td>
            <td><code>#\a</code>, <code>#\space</code></td>
            <td><code>char?</code></td>
        </tr>
        <tr>
            <td>Symbol</td>
            <td><code>'foo</code>, <code>'bar</code></td>
            <td><code>symbol?</code></td>
        </tr>
        <tr>
            <td>List</td>
            <td><code>'(1 2 3)</code>, <code>'(a b c)</code></td>
            <td><code>list?</code></td>
        </tr>
        <tr>
            <td>Pair</td>
            <td><code>'(1 . 2)</code></td>
            <td><code>pair?</code></td>
        </tr>
        <tr>
            <td>Vector</td>
            <td><code>#(1 2 3)</code></td>
            <td><code>vector?</code></td>
        </tr>
        <tr>
            <td>Procedure</td>
            <td><code>(lambda (x) (* x x))</code></td>
            <td><code>procedure?</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Numbers:</b></li>
<pre><code class="language-scheme line-numbers">; Integers
42
-17
0

; Floating point
3.14
-2.5

; Fractions (exact rationals)
1/3
22/7

; Complex numbers
2+3i
-1-4i

; Different bases
#b1010      ; Binary (10 in decimal)
#o755       ; Octal (493 in decimal)
#x1A        ; Hexadecimal (26 in decimal)</code></pre>
        <br/>
        <li><b>Booleans:</b></li>
<pre><code class="language-scheme line-numbers">#t          ; True
#f          ; False

; Everything except #f is considered true
(if 0 'yes 'no)        ; Returns: yes
(if "" 'yes 'no)       ; Returns: yes
(if '() 'yes 'no)      ; Returns: yes
(if #f 'yes 'no)       ; Returns: no</code></pre>
        <br/>
        <li><b>Strings:</b></li>
<pre><code class="language-scheme line-numbers">"Hello, World!"
"Multiple\nlines"
"Escape \"quotes\""
""              ; Empty string</code></pre>
        <br/>
        <li><b>Characters:</b></li>
<pre><code class="language-scheme line-numbers">#\a             ; Letter 'a'
#\Z             ; Letter 'Z'
#\0             ; Digit '0'
#\space         ; Space character
#\newline       ; Newline character
#\tab           ; Tab character</code></pre>
        <br/>
        <li><b>Symbols:</b></li>
<pre><code class="language-scheme line-numbers">'foo            ; Symbol foo
'hello-world    ; Symbol hello-world
'+              ; Symbol +
'lambda         ; Symbol lambda

; Symbols are like unique identifiers/names</code></pre>
    </ul>
    <br/><br/>


    <li>Variables and Definitions</li>
    <br/>
    <ul>
        <li><b>define:</b> Create global variables and functions.</li>
        <br/>
        <li><b>Syntax for variables:</b></li>
<pre><code class="language-scheme line-numbers">(define variable-name value)</code></pre>
        <br/>
        <li><b>Examples:</b></li>
<pre><code class="language-scheme line-numbers">; Define a number
(define x 10)
x                   ; Returns: 10

; Define a string
(define message "Hello")
message             ; Returns: "Hello"

; Define using an expression
(define y (* 5 4))
y                   ; Returns: 20

; Redefine (changes value)
(define x 100)
x                   ; Returns: 100</code></pre>
        <br/>
        <li><b>Syntax for functions:</b></li>
<pre><code class="language-scheme line-numbers">(define (function-name parameter1 parameter2 ...)
  body-expression)</code></pre>
        <br/>
        <li><b>Function examples:</b></li>
<pre><code class="language-scheme line-numbers">; Simple function
(define (square x)
  (* x x))

(square 5)          ; Returns: 25

; Multiple parameters
(define (add a b)
  (+ a b))

(add 3 7)           ; Returns: 10

; Multiple expressions (returns last one)
(define (greet name)
  (display "Processing...")
  (newline)
  (string-append "Hello, " name "!"))

(greet "Alice")     ; Prints "Processing..." then returns "Hello, Alice!"</code></pre>
    </ul>
    <br/><br/>


    <li>Arithmetic Operations</li>
    <br/>
    <ul>
        <li>All arithmetic uses prefix notation.</li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Syntax</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Addition</td>
            <td><code>(+ n1 n2 ...)</code></td>
            <td><code>(+ 1 2 3)</code></td>
            <td>6</td>
        </tr>
        <tr>
            <td>Subtraction</td>
            <td><code>(- n1 n2 ...)</code></td>
            <td><code>(- 10 3)</code></td>
            <td>7</td>
        </tr>
        <tr>
            <td>Multiplication</td>
            <td><code>(* n1 n2 ...)</code></td>
            <td><code>(* 2 3 4)</code></td>
            <td>24</td>
        </tr>
        <tr>
            <td>Division</td>
            <td><code>(/ n1 n2 ...)</code></td>
            <td><code>(/ 10 2)</code></td>
            <td>5</td>
        </tr>
        <tr>
            <td>Quotient</td>
            <td><code>(quotient n1 n2)</code></td>
            <td><code>(quotient 10 3)</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td>Remainder</td>
            <td><code>(remainder n1 n2)</code></td>
            <td><code>(remainder 10 3)</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td>Modulo</td>
            <td><code>(modulo n1 n2)</code></td>
            <td><code>(modulo 10 3)</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td>Exponentiation</td>
            <td><code>(expt base exp)</code></td>
            <td><code>(expt 2 8)</code></td>
            <td>256</td>
        </tr>
        <tr>
            <td>Square root</td>
            <td><code>(sqrt n)</code></td>
            <td><code>(sqrt 16)</code></td>
            <td>4</td>
        </tr>
        <tr>
            <td>Absolute value</td>
            <td><code>(abs n)</code></td>
            <td><code>(abs -5)</code></td>
            <td>5</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Multiple arguments:</b></li>
<pre><code class="language-scheme line-numbers">(+ 1 2 3 4 5)       ; Returns: 15
(* 2 3 4)           ; Returns: 24

; With single argument
(+ 5)               ; Returns: 5
(- 10)              ; Returns: -10 (negation)

; No arguments
(+)                 ; Returns: 0
(*)                 ; Returns: 1</code></pre>
        <br/>
        <li><b>Nested operations:</b></li>
<pre><code class="language-scheme line-numbers">; Traditional: (2 + 3) * 4
(* (+ 2 3) 4)       ; Returns: 20

; Traditional: 2 + 3 * 4
(+ 2 (* 3 4))       ; Returns: 14

; Traditional: (10 - 2) / (3 + 1)
(/ (- 10 2) (+ 3 1))  ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Comparison and Logical Operations</li>
    <br/>
    <ul>
        <li><b>Comparison operators:</b></li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>=</code></td>
            <td>Numeric equality</td>
            <td><code>(= 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&lt;</code></td>
            <td>Less than</td>
            <td><code>(&lt; 3 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&gt;</code></td>
            <td>Greater than</td>
            <td><code>(&gt; 5 3)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&lt;=</code></td>
            <td>Less than or equal</td>
            <td><code>(&lt;= 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&gt;=</code></td>
            <td>Greater than or equal</td>
            <td><code>(&gt;= 5 3)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>eq?</code></td>
            <td>Same object</td>
            <td><code>(eq? 'a 'a)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>eqv?</code></td>
            <td>Equivalent value</td>
            <td><code>(eqv? 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>equal?</code></td>
            <td>Structurally equal</td>
            <td><code>(equal? '(1 2) '(1 2))</code></td>
            <td><code>#t</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Comparison examples:</b></li>
<pre><code class="language-scheme line-numbers">; Numeric comparisons
(= 5 5)             ; #t
(= 5 6)             ; #f
(&lt; 3 5)             ; #t
(&gt; 5 3)             ; #t

; Multiple arguments (chain)
(&lt; 1 2 3 4)         ; #t (all comparisons true)
(&lt; 1 3 2 4)         ; #f (3 is not &lt; 2)

; String comparison
(string=? "hello" "hello")    ; #t
(string&lt;? "abc" "xyz")        ; #t
</code></pre>
        <br/>
        <li><b>Logical operators:</b></li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>and</code></td>
            <td>Logical AND</td>
            <td><code>(and #t #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>or</code></td>
            <td>Logical OR</td>
            <td><code>(or #f #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>not</code></td>
            <td>Logical NOT</td>
            <td><code>(not #t)</code> → #f</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Logical examples:</b></li>
<pre><code class="language-scheme line-numbers">; AND - returns #f if any argument is #f
(and #t #t #t)      ; #t
(and #t #f #t)      ; #f

; OR - returns #t if any argument is true
(or #f #f #t)       ; #t
(or #f #f #f)       ; #f

; NOT
(not #t)            ; #f
(not #f)            ; #t

; Short-circuit evaluation
(and #f (display "This won't print"))  ; #f (doesn't evaluate second)
(or #t (display "This won't print"))   ; #t (doesn't evaluate second)</code></pre>
    </ul>
    <br/><br/>


    <li>Conditional Expressions</li>
    <br/>
    <ul>
        <li><b>if expression syntax:</b></li>
<pre><code class="language-scheme line-numbers">(if condition
    then-expression
    else-expression)</code></pre>
        <br/>
        <li><b>if examples:</b></li>
<pre><code class="language-scheme line-numbers">; Basic if
(if (> 5 3)
    "yes"
    "no")           ; Returns: "yes"

; If with computation
(if (= (* 2 3) 6)
    (+ 10 5)
    (- 10 5))       ; Returns: 15

; Nested if
(define (sign x)
  (if (< x 0)
      "negative"
      (if (= x 0)
          "zero"
          "positive")))

(sign -5)           ; Returns: "negative"
(sign 0)            ; Returns: "zero"
(sign 5)            ; Returns: "positive"</code></pre>
        <br/>
        <li><b>cond expression (multi-way conditional):</b></li>
<pre><code class="language-scheme line-numbers">(cond
  (condition1 result1)
  (condition2 result2)
  (condition3 result3)
  ...
  (else default-result))</code></pre>
        <br/>
        <li><b>cond examples:</b></li>
<pre><code class="language-scheme line-numbers">; Multiple conditions
(define (grade score)
  (cond
    ((>= score 90) "A")
    ((>= score 80) "B")
    ((>= score 70) "C")
    ((>= score 60) "D")
    (else "F")))

(grade 85)          ; Returns: "B"
(grade 55)          ; Returns: "F"

; Without else
(cond
  ((< 5 3) "impossible")
  ((> 5 3) "correct"))  ; Returns: "correct"</code></pre>
        <br/>
        <li><b>case expression (switch-like):</b></li>
<pre><code class="language-scheme line-numbers">(case key-expression
  ((value1 value2 ...) result1)
  ((value3 value4 ...) result2)
  ...
  (else default-result))</code></pre>
        <br/>
        <li><b>case examples:</b></li>
<pre><code class="language-scheme line-numbers">(define (day-name n)
  (case n
    ((1) "Monday")
    ((2) "Tuesday")
    ((3) "Wednesday")
    ((4) "Thursday")
    ((5) "Friday")
    ((6 7) "Weekend")
    (else "Invalid day")))

(day-name 1)        ; Returns: "Monday"
(day-name 6)        ; Returns: "Weekend"</code></pre>
    </ul>
    <br/><br/>


    <li>Lists and Pairs</li>
    <br/>
    <ul>
        <li>Lists are fundamental to Scheme.</li>
        <br/>
        <li><b>Creating lists:</b></li>
<pre><code class="language-scheme line-numbers">; Quoted list (doesn't evaluate)
'(1 2 3 4)

; Using list function
(list 1 2 3 4)

; Empty list
'()
(list)

; Mixed types
'(1 "hello" x #t)
(list 1 "hello" 'x #t)</code></pre>
        <br/>
        <li><b>Difference between quote and list:</b></li>
<pre><code class="language-scheme line-numbers">; With quote - literal
'(+ 1 2)            ; Returns: (+ 1 2) - just a list of symbols
'((+ 1 2) 3)        ; Returns: ((+ 1 2) 3)

; With list - evaluates arguments
(list + 1 2)        ; Returns: (#&lt;procedure:+&gt; 1 2)
(list (+ 1 2) 3)    ; Returns: (3 3)</code></pre>
        <br/>
        <li><b>Accessing list elements:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>car</code></td>
            <td>First element</td>
            <td><code>(car '(1 2 3))</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td><code>cdr</code></td>
            <td>Rest of list</td>
            <td><code>(cdr '(1 2 3))</code></td>
            <td>(2 3)</td>
        </tr>
        <tr>
            <td><code>cadr</code></td>
            <td>Second element</td>
            <td><code>(cadr '(1 2 3))</code></td>
            <td>2</td>
        </tr>
        <tr>
            <td><code>caddr</code></td>
            <td>Third element</td>
            <td><code>(caddr '(1 2 3))</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td><code>list-ref</code></td>
            <td>Element at index (0-based)</td>
            <td><code>(list-ref '(a b c) 1)</code></td>
            <td>b</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>List manipulation:</b></li>
<pre><code class="language-scheme line-numbers">; cons - add element to front
(cons 1 '(2 3))             ; Returns: (1 2 3)
(cons 'a '())               ; Returns: (a)

; append - combine lists
(append '(1 2) '(3 4))      ; Returns: (1 2 3 4)
(append '(a) '(b) '(c))     ; Returns: (a b c)

; length
(length '(1 2 3 4))         ; Returns: 4
(length '())                ; Returns: 0

; reverse
(reverse '(1 2 3))          ; Returns: (3 2 1)

; member - find element
(member 3 '(1 2 3 4))       ; Returns: (3 4)
(member 'x '(a b c))        ; Returns: #f</code></pre>
        <br/>
        <li><b>Pairs (dotted pairs):</b></li>
<pre><code class="language-scheme line-numbers">; Create pair with cons
(cons 1 2)              ; Returns: (1 . 2)

; Lists are chains of pairs ending in '()
(cons 1 (cons 2 (cons 3 '())))  ; Returns: (1 2 3)
; Same as '(1 2 3)

; Access pair elements
(car '(1 . 2))          ; Returns: 1
(cdr '(1 . 2))          ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Lambda Expressions</li>
    <br/>
    <ul>
        <li><b>lambda creates anonymous functions.</b></li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(lambda (parameter1 parameter2 ...)
  body-expression)</code></pre>
        <br/>
        <li><b>Basic examples:</b></li>
<pre><code class="language-scheme line-numbers">; Anonymous function
(lambda (x) (* x x))

; Call immediately
((lambda (x) (* x x)) 5)    ; Returns: 25

; Assign to variable
(define square (lambda (x) (* x x)))
(square 5)                  ; Returns: 25

; Multiple parameters
(define add (lambda (a b) (+ a b)))
(add 3 7)                   ; Returns: 10</code></pre>
        <br/>
        <li><b>Note: These are equivalent:</b></li>
<pre><code class="language-scheme line-numbers">; Using lambda explicitly
(define square (lambda (x) (* x x)))

; Shorthand (what we've been using)
(define (square x) (* x x))

; Both create the same function</code></pre>
        <br/>
        <li><b>Variable number of arguments:</b></li>
<pre><code class="language-scheme line-numbers">; Rest parameters
(define (sum . numbers)
  (if (null? numbers)
      0
      (+ (car numbers) (apply sum (cdr numbers)))))

(sum 1 2 3 4 5)     ; Returns: 15

; Mix fixed and rest parameters
(define (greet name . titles)
  (string-append name " " (apply string-append titles)))

(greet "John" "Dr. " "PhD")  ; Returns: "John Dr. PhD"</code></pre>
        <br/>
        <li><b>Higher-order functions:</b></li>
<pre><code class="language-scheme line-numbers">; Function that returns a function
(define (make-adder n)
  (lambda (x) (+ x n)))

(define add5 (make-adder 5))
(add5 10)           ; Returns: 15
(add5 3)            ; Returns: 8

; Function that takes a function
(define (apply-twice f x)
  (f (f x)))

(apply-twice (lambda (x) (* x 2)) 3)  ; Returns: 12
; First: (* 3 2) = 6
; Second: (* 6 2) = 12</code></pre>
    </ul>
    <br/><br/>


    <li>Local Bindings: let, let*, and letrec</li>
    <br/>
    <ul>
        <li><b>let:</b> Create local variables (parallel binding).</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(let ((var1 value1)
      (var2 value2)
      ...)
  body-expression)</code></pre>
        <br/>
        <li><b>let examples:</b></li>
<pre><code class="language-scheme line-numbers">; Simple let
(let ((x 5)
      (y 10))
  (+ x y))          ; Returns: 15

; Variables are parallel (can't reference each other)
(let ((x 5)
      (y x))        ; Error! x not yet defined
  (+ x y))

; Correct way
(let ((x 5))
  (let ((y x))
    (+ x y)))       ; Returns: 10</code></pre>
        <br/>
        <li><b>let*:</b> Create local variables (sequential binding).</li>
<pre><code class="language-scheme line-numbers">(let* ((var1 value1)
       (var2 value2)  ; Can use var1 here
       ...)
  body-expression)</code></pre>
        <br/>
        <li><b>let* examples:</b></li>
<pre><code class="language-scheme line-numbers">; Sequential binding
(let* ((x 5)
       (y (* x 2)))     ; Can use x
  (+ x y))              ; Returns: 15

; Each binding can use previous ones
(let* ((a 1)
       (b (+ a 1))      ; Uses a
       (c (+ a b)))     ; Uses a and b
  c)                    ; Returns: 3</code></pre>
        <br/>
        <li><b>letrec:</b> Create local recursive functions.</li>
<pre><code class="language-scheme line-numbers">(letrec ((var1 value1)
         (var2 value2)
         ...)
  body-expression)</code></pre>
        <br/>
        <li><b>letrec examples:</b></li>
<pre><code class="language-scheme line-numbers">; Recursive function
(letrec ((factorial
          (lambda (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))))
  (factorial 5))    ; Returns: 120

; Mutually recursive functions
(letrec ((even?
          (lambda (n)
            (if (= n 0)
                #t
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (= n 0)
                #f
                (even? (- n 1))))))
  (even? 10))       ; Returns: #t</code></pre>
    </ul>
    <br/><br/>


    <li>Recursion</li>
    <br/>
    <ul>
        <li>Recursion is the primary iteration mechanism in Scheme.</li>
        <br/>
        <li><b>Basic recursive pattern:</b></li>
<pre><code class="language-scheme line-numbers">(define (function-name param)
  (if base-case
      base-result
      (recursive-call)))</code></pre>
        <br/>
        <li><b>Factorial example:</b></li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (if (<= n 1)
      1                         ; Base case
      (* n (factorial (- n 1)))))  ; Recursive case

(factorial 5)       ; Returns: 120
; 5 * 4 * 3 * 2 * 1 = 120</code></pre>
        <br/>
        <li><b>List recursion:</b></li>
<pre><code class="language-scheme line-numbers">; Sum all numbers in list
(define (sum-list lst)
  (if (null? lst)
      0                         ; Base: empty list
      (+ (car lst)              ; Add first element
         (sum-list (cdr lst))))) ; Recursively sum rest

(sum-list '(1 2 3 4))   ; Returns: 10

; Length of list
(define (my-length lst)
  (if (null? lst)
      0
      (+ 1 (my-length (cdr lst)))))

(my-length '(a b c d))  ; Returns: 4</code></pre>
        <br/>
        <li><b>Tail recursion (more efficient):</b></li>
<pre><code class="language-scheme line-numbers">; Tail-recursive factorial
(define (factorial n)
  (define (fact-iter n acc)
    (if (<= n 1)
        acc
        (fact-iter (- n 1) (* n acc))))
  (fact-iter n 1))

; Tail-recursive sum
(define (sum-list lst)
  (define (sum-iter lst acc)
    (if (null? lst)
        acc
        (sum-iter (cdr lst) (+ acc (car lst)))))
  (sum-iter lst 0))

(sum-list '(1 2 3 4))   ; Returns: 10</code></pre>
    </ul>
    <br/><br/>


    <li>Common List Operations</li>
    <br/>
    <ul>
        <li><b>map:</b> Apply function to each element.</li>
<pre><code class="language-scheme line-numbers">; Syntax: (map function list)

(map (lambda (x) (* x 2)) '(1 2 3))
; Returns: (2 4 6)

(map car '((a b) (c d) (e f)))
; Returns: (a c e)

; Multiple lists
(map + '(1 2 3) '(10 20 30))
; Returns: (11 22 33)</code></pre>
        <br/>
        <li><b>filter:</b> Keep elements that satisfy predicate.</li>
<pre><code class="language-scheme line-numbers">; Keep only even numbers
(filter even? '(1 2 3 4 5 6))
; Returns: (2 4 6)

; Keep numbers > 5
(filter (lambda (x) (> x 5)) '(1 8 3 9 2 7))
; Returns: (8 9 7)</code></pre>
        <br/>
        <li><b>fold (reduce):</b> Combine elements.</li>
<pre><code class="language-scheme line-numbers">; foldl - fold from left
(foldl + 0 '(1 2 3 4))
; Returns: 10
; ((((0 + 1) + 2) + 3) + 4)

; foldr - fold from right
(foldr cons '() '(1 2 3))
; Returns: (1 2 3)

; foldl vs foldr
(foldl - 0 '(1 2 3))    ; (((0 - 1) - 2) - 3) = -6
(foldr - 0 '(1 2 3))    ; (1 - (2 - (3 - 0))) = 2</code></pre>
        <br/>
        <li><b>apply:</b> Apply function to list as arguments.</li>
<pre><code class="language-scheme line-numbers">(apply + '(1 2 3 4))
; Same as: (+ 1 2 3 4)
; Returns: 10

(apply max '(3 7 2 9 1))
; Same as: (max 3 7 2 9 1)
; Returns: 9</code></pre>
    </ul>
    <br/><br/>


    <li>String Operations</li>
    <br/>
    <ul>
        <li><b>Common string functions:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>string-length</code></td>
            <td>Get length</td>
            <td><code>(string-length "hello")</code></td>
            <td>5</td>
        </tr>
        <tr>
            <td><code>string-append</code></td>
            <td>Concatenate</td>
            <td><code>(string-append "hi" " " "there")</code></td>
            <td>"hi there"</td>
        </tr>
        <tr>
            <td><code>string-ref</code></td>
            <td>Get character</td>
            <td><code>(string-ref "hello" 1)</code></td>
            <td>#\e</td>
        </tr>
        <tr>
            <td><code>substring</code></td>
            <td>Extract portion</td>
            <td><code>(substring "hello" 1 4)</code></td>
            <td>"ell"</td>
        </tr>
        <tr>
            <td><code>string-upcase</code></td>
            <td>Uppercase</td>
            <td><code>(string-upcase "hello")</code></td>
            <td>"HELLO"</td>
        </tr>
        <tr>
            <td><code>string-downcase</code></td>
            <td>Lowercase</td>
            <td><code>(string-downcase "HELLO")</code></td>
            <td>"hello"</td>
        </tr>
        <tr>
            <td><code>string->list</code></td>
            <td>Convert to list</td>
            <td><code>(string->list "abc")</code></td>
            <td>(#\a #\b #\c)</td>
        </tr>
        <tr>
            <td><code>list->string</code></td>
            <td>Convert from list</td>
            <td><code>(list->string '(#\a #\b))</code></td>
            <td>"ab"</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Examples:</b></li>
<pre><code class="language-scheme line-numbers">; Concatenation
(string-append "Hello" ", " "World" "!")
; Returns: "Hello, World!"

; Substring
(substring "Hello, World!" 0 5)
; Returns: "Hello"

; Character access
(string-ref "Scheme" 0)     ; Returns: #\S

; String manipulation
(string-upcase "hello")     ; Returns: "HELLO"
(string-downcase "WORLD")   ; Returns: "world"</code></pre>
    </ul>
    <br/><br/>


    <li>Input and Output</li>
    <br/>
    <ul>
        <li><b>Display output:</b></li>
<pre><code class="language-scheme line-numbers">; display - print without quotes
(display "Hello, World!")   ; Prints: Hello, World!

; newline - print newline
(newline)

; write - print with quotes
(write "Hello")             ; Prints: "Hello"

; print multiple things
(display "x = ")
(display 42)
(newline)
; Prints: x = 42</code></pre>
        <br/>
        <li><b>Read input:</b></li>
<pre><code class="language-scheme line-numbers">; read - read S-expression
(define input (read))
; User types: (1 2 3)
; input is: '(1 2 3)

; read-line - read line as string
(define line (read-line))
; User types: Hello World
; line is: "Hello World"</code></pre>
        <br/>
        <li><b>File I/O:</b></li>
<pre><code class="language-scheme line-numbers">; Open file for reading
(define in (open-input-file "input.txt"))

; Read from file
(read in)
(read-line in)

; Close file
(close-input-port in)

; Open file for writing
(define out (open-output-file "output.txt"))

; Write to file
(write '(1 2 3) out)
(display "Hello" out)

; Close file
(close-output-port out)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Predicates</li>
    <br/>
    <ul>
        <li>Predicates are functions that return boolean values.</li>
<table>
    <thead>
        <tr>
            <th>Predicate</th>
            <th>Tests for</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>null?</code></td>
            <td>Empty list</td>
            <td><code>(null? '())</code> → #t</td>
        </tr>
        <tr>
            <td><code>pair?</code></td>
            <td>Pair/cons cell</td>
            <td><code>(pair? '(1 2))</code> → #t</td>
        </tr>
        <tr>
            <td><code>list?</code></td>
            <td>Proper list</td>
            <td><code>(list? '(1 2))</code> → #t</td>
        </tr>
        <tr>
            <td><code>number?</code></td>
            <td>Number</td>
            <td><code>(number? 42)</code> → #t</td>
        </tr>
        <tr>
            <td><code>integer?</code></td>
            <td>Integer</td>
            <td><code>(integer? 5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>real?</code></td>
            <td>Real number</td>
            <td><code>(real? 3.14)</code> → #t</td>
        </tr>
        <tr>
            <td><code>string?</code></td>
            <td>String</td>
            <td><code>(string? "hi")</code> → #t</td>
        </tr>
        <tr>
            <td><code>char?</code></td>
            <td>Character</td>
            <td><code>(char? #\a)</code> → #t</td>
        </tr>
        <tr>
            <td><code>symbol?</code></td>
            <td>Symbol</td>
            <td><code>(symbol? 'x)</code> → #t</td>
        </tr>
        <tr>
            <td><code>boolean?</code></td>
            <td>Boolean</td>
            <td><code>(boolean? #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>procedure?</code></td>
            <td>Function</td>
            <td><code>(procedure? +)</code> → #t</td>
        </tr>
        <tr>
            <td><code>zero?</code></td>
            <td>Zero</td>
            <td><code>(zero? 0)</code> → #t</td>
        </tr>
        <tr>
            <td><code>positive?</code></td>
            <td>Positive number</td>
            <td><code>(positive? 5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>negative?</code></td>
            <td>Negative number</td>
            <td><code>(negative? -5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>even?</code></td>
            <td>Even number</td>
            <td><code>(even? 4)</code> → #t</td>
        </tr>
        <tr>
            <td><code>odd?</code></td>
            <td>Odd number</td>
            <td><code>(odd? 3)</code> → #t</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Quick Reference Summary</li>
    <br/>
    <ul>
        <li><b>Basic syntax patterns:</b></li>
<pre><code class="language-scheme line-numbers">; Define variable
(define name value)

; Define function
(define (name params...) body)

; Lambda
(lambda (params...) body)

; Conditional
(if test then else)
(cond (test1 result1) (test2 result2) ... (else default))

; Local binding
(let ((var val) ...) body)
(let* ((var val) ...) body)
(letrec ((var val) ...) body)

; List operations
(car list)          ; First element
(cdr list)          ; Rest
(cons item list)    ; Add to front
(append list1 list2) ; Combine

; Higher-order
(map function list)
(filter predicate list)
(apply function list)</code></pre>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-multiple-expressions">Multiple Expressions in Conditionals</h3>
<ol>

    <li>The Problem with if</li>
    <br/>
    <ul>
        <li><b>if only accepts single expressions</b> for then and else branches.</li>
        <br/>
        <li><b>This doesn't work:</b></li>
<pre><code class="language-scheme line-numbers">; ✗ Error - trying multiple expressions
(if (> x 0)
    (display "Positive")
    (newline)           ; Error! if expects only one expression
    (display "Negative"))
</code></pre>
        <br/>
        <li>You need a way to <b>group multiple expressions into one</b>.</li>
    </ul>
    <br/><br/>


    <li>Solution: Using begin</li>
    <br/>
    <ul>
        <li><b>begin:</b> Groups multiple expressions into a single expression.</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(begin
  expression1
  expression2
  expression3
  ...
  final-expression)</code></pre>
        <br/>
        <li><b>What begin does:</b></li>
        <ul>
            <li>Evaluates all expressions in sequence (top to bottom)</li>
            <li>Returns the value of the <b>last expression only</b></li>
            <li>Side effects (like display, file I/O) from all expressions occur</li>
        </ul>
        <br/>
        <li><b>Basic begin example:</b></li>
<pre><code class="language-scheme line-numbers">(begin
  (display "First")
  (newline)
  (display "Second")
  (newline)
  42)               ; This value is returned

; Prints:
; First
; Second
; Returns: 42</code></pre>
    </ul>
    <br/><br/>


    <li>Using begin with if</li>
    <br/>
    <ul>
        <li><b>Pattern for multiple expressions in then branch:</b></li>
<pre><code class="language-scheme line-numbers">(if condition
    (begin
      expression1
      expression2
      ...)
    else-expression)</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-scheme line-numbers">(define x 10)

(if (&gt; x 0)
    (begin
      (display "x is positive")
      (newline)
      (display "x = ")
      (display x)
      #t)           ; Return value
    #f)

; Prints:
; x is positive
; x = 10
; Returns: #t</code></pre>
        <br/>
        <li><b>Multiple expressions in else branch:</b></li>
<pre><code class="language-scheme line-numbers">(if (> x 0)
    (display "Positive")
    (begin
      (display "Not positive")
      (newline)
      (display "Please enter a positive number")
      #f))</code></pre>
        <br/>
        <li><b>Multiple expressions in both branches:</b></li>
<pre><code class="language-scheme line-numbers">(if (> x 0)
    (begin
      (display "Positive: ")
      (display x)
      'positive)
    (begin
      (display "Not positive: ")
      (display x)
      'not-positive))</code></pre>
        <br/>
        <li><b>Real-world example - login check:</b></li>
<pre><code class="language-scheme line-numbers">(define (login username password)
  (if (and (string=? username "admin")
           (string=? password "secret"))
      (begin
        (display "Login successful!")
        (newline)
        (display "Welcome, ")
        (display username)
        (newline)
        #t)         ; Return success
      (begin
        (display "Login failed!")
        (newline)
        (display "Invalid credentials")
        (newline)
        #f)))       ; Return failure

(login "admin" "secret")
; Prints:
; Login successful!
; Welcome, admin
; Returns: #t
</code></pre>
    </ul>
    <br/><br/>


    <li>Alternative: when and unless</li>
    <br/>
    <ul>
        <li>Chez Scheme provides <code>when</code> and <code>unless</code> for common cases.</li>
        <br/>
        <li><b>when:</b> Execute multiple expressions if condition is true.</li>
<pre><code class="language-scheme line-numbers">; Syntax
(when condition
  expression1
  expression2
  ...)

; Equivalent to:
(if condition
    (begin expression1 expression2 ...)
    (void))     ; or returns unspecified value</code></pre>
        <br/>
        <li><b>when example:</b></li>
<pre><code class="language-scheme line-numbers">(define x 10)

(when (&gt; x 0)
  (display "x is positive")
  (newline)
  (display "x = ")
  (display x))

; No else branch needed
; If condition is false, does nothing</code></pre>
        <br/>
        <li><b>unless:</b> Execute multiple expressions if condition is false.</li>
<pre><code class="language-scheme line-numbers">; Syntax
(unless condition
  expression1
  expression2
  ...)

; Equivalent to:
(if (not condition)
    (begin expression1 expression2 ...)
    (void))</code></pre>
        <br/>
        <li><b>unless example:</b></li>
<pre><code class="language-scheme line-numbers">(define balance 50)

(unless (&gt;= balance 100)
  (display "Warning: Low balance")
  (newline)
  (display "Current balance: ")
  (display balance))

; Executes when balance < 100</code></pre>
        <br/>
        <li><b>Comparison:</b></li>
<table>
    <thead>
        <tr>
            <th>Form</th>
            <th>When to Use</th>
            <th>Has else?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>if</code> + <code>begin</code></td>
            <td>Need both then and else branches</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td><code>when</code></td>
            <td>Only execute if true, no else needed</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>unless</code></td>
            <td>Only execute if false, no else needed</td>
            <td>No</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Using cond for Multiple Expressions</li>
    <br/>
    <ul>
        <li><code>cond</code> clauses can have multiple expressions without <code>begin</code>.</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(cond
  (condition1
    expression1
    expression2
    ...)
  (condition2
    expression1
    expression2
    ...)
  (else
    expression1
    expression2
    ...))</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-scheme line-numbers">(define (grade-message score)
  (cond
    ((&gt;= score 90)
     (display "Excellent!")
     (newline)
     (display "Grade: A")
     'A)
    ((&gt;= score 80)
     (display "Good job!")
     (newline)
     (display "Grade: B")
     'B)
    ((&gt;= score 70)
     (display "Passing")
     (newline)
     (display "Grade: C")
     'C)
    (else
     (display "Failed")
     (newline)
     (display "Grade: F")
     'F)))

(grade-message 85)
; Prints:
; Good job!
; Grade: B
; Returns: B</code></pre>
        <br/>
        <li><b>Note:</b> Each clause can have multiple expressions, and the value of the last expression is returned if that clause matches.</li>
        <br/>
        <li><b>Comparison with if + begin:</b></li>
<pre><code class="language-scheme line-numbers">; Using if + begin (verbose)
(if (&gt;= score 90)
    (begin
      (display "Excellent!")
      'A)
    (if (&gt;= score 80)
        (begin
          (display "Good!")
          'B)
        ...))

; Using cond (cleaner)
(cond
  ((&gt;= score 90)
   (display "Excellent!")
   'A)
  ((&gt;= score 80)
   (display "Good!")
   'B)
  ...)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Patterns and Examples</li>
    <br/>
    <ul>
        <li><b>Pattern 1: Validation with multiple actions</b></li>
<pre><code class="language-scheme line-numbers">(define (validate-age age)
  (if (and (&gt;= age 0) (<= age 150))
      (begin
        (display "Age is valid")
        (newline)
        #t)
      (begin
        (display "Error: Invalid age")
        (newline)
        (display "Age must be between 0 and 150")
        (newline)
        #f)))
</code></pre>
        <br/>
        <li><b>Pattern 2: Side effects only when condition is true</b></li>
<pre><code class="language-scheme line-numbers">; Using when
(when (file-exists? "config.txt")
  (display "Loading config...")
  (newline)
  (load-config)
  (display "Config loaded"))

; Without when (more verbose)
(if (file-exists? "config.txt")
    (begin
      (display "Loading config...")
      (newline)
      (load-config)
      (display "Config loaded"))
    (void))</code></pre>
        <br/>
        <li><b>Pattern 3: Guard clauses</b></li>
<pre><code class="language-scheme line-numbers">(define (process-data data)
  ; Early return with multiple expressions
  (unless (valid-data? data)
    (display "Error: Invalid data")
    (newline)
    (return-error))

  ; Continue processing if valid
  (display "Processing...")
  (transform-data data))</code></pre>
        <br/>
        <li><b>Pattern 4: Logging with computation</b></li>
<pre><code class="language-scheme line-numbers">(define (calculate x y)
  (if (= y 0)
      (begin
        (display "Error: Division by zero")
        (newline)
        (display "Returning default value")
        (newline)
        0)
      (begin
        (display "Calculating: ")
        (display x)
        (display " / ")
        (display y)
        (newline)
        (/ x y))))</code></pre>
    </ul>
    <br/><br/>


    <li>When begin is NOT Needed</li>
    <br/>
    <ul>
        <li>Some forms already allow multiple expressions implicitly.</li>
        <br/>
        <li><b>Function bodies (define):</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in function body
(define (greet name)
  (display "Hello, ")
  (display name)
  (display "!")
  (newline)
  'done)            ; Returns 'done

; All expressions execute in sequence
; Last one is the return value</code></pre>
        <br/>
        <li><b>let, let*, letrec bodies:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in let body
(let ((x 10)
      (y 20))
  (display "Computing sum")
  (newline)
  (+ x y))          ; Returns 30</code></pre>
        <br/>
        <li><b>lambda bodies:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in lambda body
(lambda (x)
  (display "Processing: ")
  (display x)
  (newline)
  (* x x))          ; Returns x squared</code></pre>
        <br/>
        <li><b>cond clauses:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in cond clauses
(cond
  ((> x 0)
   (display "Positive")
   (newline)
   'pos)
  (else
   (display "Not positive")
   'not-pos))</code></pre>
        <br/>
        <li><b>case clauses:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in case clauses
(case n
  ((1)
   (display "One")
   1)
  ((2)
   (display "Two")
   2))</code></pre>
    </ul>
    <br/><br/>


    <li>Summary: When to Use What</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Situation</th>
            <th>Use</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Multiple expressions in if then/else</td>
            <td><code>begin</code></td>
            <td><code>(if test (begin e1 e2) e3)</code></td>
        </tr>
        <tr>
            <td>Only execute if true, no else</td>
            <td><code>when</code></td>
            <td><code>(when test e1 e2)</code></td>
        </tr>
        <tr>
            <td>Only execute if false, no else</td>
            <td><code>unless</code></td>
            <td><code>(unless test e1 e2)</code></td>
        </tr>
        <tr>
            <td>Multi-way with multiple expressions</td>
            <td><code>cond</code></td>
            <td><code>(cond (t1 e1 e2) (t2 e3 e4))</code></td>
        </tr>
        <tr>
            <td>In function/lambda/let body</td>
            <td>Nothing (implicit)</td>
            <td><code>(define (f) e1 e2)</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <ul>
        <li><b>Quick reference:</b></li>
    </ul>
<pre><code class="language-scheme line-numbers">; if with multiple expressions
(if test
    (begin e1 e2 e3)
    (begin e4 e5 e6))

; when (cleaner for one-sided if)
(when test
  e1
  e2
  e3)

; unless (cleaner for negative one-sided if)
(unless test
  e1
  e2
  e3)

; cond (no begin needed)
(cond
  (test1 e1 e2 e3)
  (test2 e4 e5 e6)
  (else e7 e8 e9))

; Function body (no begin needed)
(define (func)
  e1
  e2
  e3)</code></pre>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-naming-conventions">Chez Scheme Naming Conventions</h3>
<ol>

    <li>Understanding Scheme Identifiers</li>
    <br/>
    <ul>
        <li>Scheme has flexible rules for naming variables and functions.</li>
        <br/>
        <li><b>Core principle:</b> Names should be descriptive and follow consistent patterns.</li>
        <br/>
        <li><b>Valid characters in identifiers:</b></li>
        <ul>
            <li>Letters: <code>a-z</code>, <code>A-Z</code></li>
            <li>Digits: <code>0-9</code> (not at the start)</li>
            <li>Special characters: <code>!</code> <code>$</code> <code>%</code> <code>&</code> <code>*</code> <code>+</code> <code>-</code> <code>.</code> <code>/</code> <code>:</code> <code>&lt;</code> <code>=</code> <code>&gt;</code> <code&gt;?</code> <code>@</code> <code>^</code> <code>_</code> <code>~</code></li>
        </ul>
        <br/>
        <li><b>Examples of valid identifiers:</b></li>
<pre><code class="language-scheme line-numbers">; All valid
x
my-variable
list->vector
string-ref
empty?
set!
<=
+
make-counter
file-exists?
*global-config*</code></pre>
        <br/>
        <li><b>Examples of invalid identifiers:</b></li>
<pre><code class="language-scheme line-numbers">; Invalid - starts with digit
123abc

; Invalid - contains space
my variable

; Invalid - contains special chars not allowed
my#var
item[0]
value{x}</code></pre>
    </ul>
    <br/><br/>


    <li>Predicate Naming Convention</li>
    <br/>
    <ul>
        <li>Functions that return boolean values end with <code&gt;?</code></li>
        <br/>
        <li><b>Purpose:</b> Immediately identifies a function as a test or check.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Type predicates
(number? 42)        ; Returns: #t
(string? "hi")      ; Returns: #t
(list? '(1 2 3))    ; Returns: #t
(pair? '(a . b))    ; Returns: #t
(null? '())         ; Returns: #t

; Comparison predicates
(zero? 0)           ; Returns: #t
(positive? 5)       ; Returns: #t
(negative? -3)      ; Returns: #t
(even? 4)           ; Returns: #t
(odd? 7)            ; Returns: #t

; State predicates
(eof-object? x)     ; Checks for EOF
(file-exists? "test.txt")
(char-whitespace? #\space)</code></pre>
        <br/>
        <li><b>Creating your own predicates:</b></li>
<pre><code class="language-scheme line-numbers">(define (adult? age)
  (>= age 18))

(define (valid-email? email)
  (and (string? email)
       (string-contains? email "@")))

(define (empty-list? lst)
  (null? lst))

; Using predicates
(adult? 25)                    ; Returns: #t
(valid-email? "test@test.com") ; Returns: #t
(empty-list? '())              ; Returns: #t</code></pre>
    </ul>
    <br/><br/>


    <li>Mutating Function Convention</li>
    <br/>
    <ul>
        <li>Functions that modify (mutate) their arguments end with <code>!</code></li>
        <br/>
        <li><b>Warning:</b> The <code>!</code> signals side effects - use with caution.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Variable mutation
(define x 10)
(set! x 20)         ; Modifies x
x                   ; Returns: 20

; List mutation
(define lst '(1 2 3))
(set-car! lst 99)   ; Modifies first element
lst                 ; Returns: (99 2 3)

(set-cdr! lst '(8 9))
lst                 ; Returns: (99 8 9)

; Vector mutation
(define vec #(1 2 3))
(vector-set! vec 0 42)  ; Modifies element at index 0
vec                     ; Returns: #(42 2 3)</code></pre>
        <br/>
        <li><b>Creating your own mutators:</b></li>
<pre><code class="language-scheme line-numbers">(define (reset-counter! counter)
  (set-car! counter 0))

(define (increment! counter)
  (set-car! counter (+ (car counter) 1)))

(define (update-status! object new-status)
  (set-car! (cdr object) new-status))

; Usage
(define my-counter (list 0))
(increment! my-counter)
my-counter              ; Returns: (1)</code></pre>
        <br/>
        <li><b>Contrast with non-mutating functions:</b></li>
<pre><code class="language-scheme line-numbers">; Non-mutating - returns new value
(define (increment counter)
  (+ counter 1))

(define x 5)
(increment x)       ; Returns: 6
x                   ; Still: 5

; Mutating - modifies in place
(define (increment! counter-box)
  (set-car! counter-box
            (+ (car counter-box) 1)))

(define y (list 5))
(increment! y)      ; Modifies y
y                   ; Now: (6)</code></pre>
    </ul>
    <br/><br/>


    <li>Type Conversion Convention</li>
    <br/>
    <ul>
        <li>Conversion functions use <code>-&gt;</code> pattern: <code>source-&gt;target</code></li>
        <br/>
        <li><b>Pattern:</b> <code>(type-a-&gt;type-b value)</code> converts from type A to type B.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Number conversions
(string->number "42")       ; Returns: 42
(number->string 123)        ; Returns: "123"
(char->integer #\A)         ; Returns: 65
(integer->char 65)          ; Returns: #\A

; List/vector conversions
(list->vector '(1 2 3))     ; Returns: #(1 2 3)
(vector->list #(a b c))     ; Returns: (a b c)
(list->string '(#\h #\i))   ; Returns: "hi"
(string->list "abc")        ; Returns: (#\a #\b #\c)

; Symbol conversions
(symbol->string 'hello)     ; Returns: "hello"
(string->symbol "world")    ; Returns: world</code></pre>
        <br/>
        <li><b>Creating your own converters:</b></li>
<pre><code class="language-scheme line-numbers">(define (celsius->fahrenheit c)
  (+ (* c 9/5) 32))

(define (fahrenheit->celsius f)
  (* (- f 32) 5/9))

(define (list->set lst)
  ; Convert list to set (remove duplicates)
  (delete-duplicates lst))

(define (record->alist rec)
  ; Convert record to association list
  (map cons (record-field-names rec)
            (record-field-values rec)))

; Usage
(celsius->fahrenheit 100)   ; Returns: 212
(fahrenheit->celsius 32)    ; Returns: 0
(list->set '(1 2 2 3 3 3))  ; Returns: (1 2 3)</code></pre>
    </ul>
    <br/><br/>


    <li>Multi-word Identifier Convention</li>
    <br/>
    <ul>
        <li>Use <code>kebab-case</code> (words separated by hyphens) for multi-word names.</li>
        <br/>
        <li><b>Scheme style:</b> <code>kebab-case</code> is standard, NOT <code>camelCase</code> or <code>snake_case</code></li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Standard functions
string-length
string-append
list-ref
vector-set!
make-vector
call-with-current-continuation
call-with-input-file
read-char
write-char</code></pre>
        <br/>
        <li><b>Creating your own multi-word names:</b></li>
<pre><code class="language-scheme line-numbers">; Variables
(define max-retry-count 5)
(define database-connection-string "localhost:5432")
(define user-input-buffer '())

; Functions
(define (calculate-total-price items tax-rate)
  (* (apply + items) (+ 1 tax-rate)))

(define (validate-user-credentials username password)
  (and (valid-username? username)
       (valid-password? password)))

(define (send-email-notification recipient subject body)
  (email-send recipient subject body))

; Usage
(calculate-total-price '(10 20 30) 0.1)  ; Returns: 66.0</code></pre>
        <br/>
        <li><b>Bad examples (don't do this):</b></li>
<pre><code class="language-scheme line-numbers">; Wrong - camelCase (not Scheme style)
calculateTotalPrice
getUserInput
sendEmailNotification

; Wrong - snake_case (not Scheme style)
calculate_total_price
get_user_input
send_email_notification

; Right - kebab-case (Scheme style)
calculate-total-price
get-user-input
send-email-notification</code></pre>
    </ul>
    <br/><br/>


    <li>Global Variable Convention</li>
    <br/>
    <ul>
        <li>Global variables and parameters are sometimes surrounded by asterisks <code>*name*</code></li>
        <br/>
        <li><b>Note:</b> This convention is not universal in Scheme, but common in some codebases.</li>
        <br/>
        <li><b>Examples from libraries:</b></li>
<pre><code class="language-scheme line-numbers">; Common in some Scheme systems
*random-state*
*default-input-port*
*default-output-port*
*error-port*
*command-line-args*</code></pre>
        <br/>
        <li><b>Creating your own globals:</b></li>
<pre><code class="language-scheme line-numbers">(define *debug-mode* #f)
(define *max-connections* 100)
(define *database-url* "localhost:5432")
(define *application-version* "1.0.0")

; Usage
(when *debug-mode*
  (display "Debug: Processing request")
  (newline))

(if (< (connection-count) *max-connections*)
    (accept-connection)
    (reject-connection))</code></pre>
        <br/>
        <li><b>Alternative convention:</b> Some prefer <code>%name</code> for internal/private globals</li>
<pre><code class="language-scheme line-numbers">; Internal implementation details
(define %internal-cache (make-hash-table))
(define %debug-counter 0)
(define %temporary-buffer (make-vector 1024))</code></pre>
    </ul>
    <br/><br/>


    <li>Constructor and Maker Convention</li>
    <br/>
    <ul>
        <li>Constructor functions often use <code>make-</code> prefix.</li>
        <br/>
        <li><b>Pattern:</b> <code>(make-type args...)</code> creates a new instance of type.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Creating data structures
(make-vector 10)                  ; Creates vector of size 10
(make-vector 5 'x)                ; Creates #(x x x x x)
(make-string 3 #\a)               ; Creates "aaa"
(make-hash-table)                 ; Creates hash table
(make-list 4 0)                   ; Creates (0 0 0 0)</code></pre>
        <br/>
        <li><b>Creating your own constructors:</b></li>
<pre><code class="language-scheme line-numbers">(define (make-point x y)
  (cons x y))

(define (make-rectangle width height)
  (list 'rectangle width height))

(define (make-account name balance)
  (list name balance '()))  ; name, balance, transaction-history

(define (make-counter initial-value)
  (let ((count initial-value))
    (lambda ()
      (set! count (+ count 1))
      count)))

; Usage
(define p1 (make-point 10 20))
(define r1 (make-rectangle 100 50))
(define acc (make-account "John" 1000))
(define counter (make-counter 0))
(counter)  ; Returns: 1
(counter)  ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Private/Internal Naming</li>
    <br/>
    <ul>
        <li>Internal helper functions sometimes use <code>%</code> prefix or <code>-internal</code> suffix.</li>
        <br/>
        <li><b>Purpose:</b> Signals that a function is not part of the public API.</li>
        <br/>
        <li><b>Using % prefix:</b></li>
<pre><code class="language-scheme line-numbers">; Public API
(define (parse-expression expr)
  (%validate-syntax expr)
  (%transform-expr expr))

; Internal helpers (not for public use)
(define (%validate-syntax expr)
  ; Internal validation logic
  #t)

(define (%transform-expr expr)
  ; Internal transformation logic
  expr)</code></pre>
        <br/>
        <li><b>Using -internal suffix:</b></li>
<pre><code class="language-scheme line-numbers">; Public API
(define (calculate-total items)
  (apply + (map calculate-price-internal items)))

; Internal helper
(define (calculate-price-internal item)
  (* (item-quantity item)
     (item-unit-price item)
     (+ 1 (item-tax-rate item))))</code></pre>
        <br/>
        <li><b>Nested definitions (alternative):</b></li>
<pre><code class="language-scheme line-numbers">; Internal helpers defined inside public function
(define (process-data data)
  ; Helper only accessible within this function
  (define (validate item)
    (and (number? item) (positive? item)))

  (define (transform item)
    (* item 2))

  ; Use helpers
  (map transform (filter validate data)))

(process-data '(1 -2 3 4))  ; Returns: (2 6 8)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Naming Patterns Summary</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Convention</th>
            <th>Pattern</th>
            <th>Examples</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Predicates (boolean returns)</td>
            <td><code>name?</code></td>
            <td><code>empty?</code>, <code>valid?</code>, <code>member?</code></td>
        </tr>
        <tr>
            <td>Mutating functions</td>
            <td><code>name!</code></td>
            <td><code>set!</code>, <code>vector-set!</code>, <code>increment!</code></td>
        </tr>
        <tr>
            <td>Type conversions</td>
            <td><code>type-a-&gt;type-b</code></td>
            <td><code>list-&gt;vector</code>, <code>string-&gt;number</code></td>
        </tr>
        <tr>
            <td>Multi-word names</td>
            <td><code>kebab-case</code></td>
            <td><code>string-length</code>, <code>file-exists?</code></td>
        </tr>
        <tr>
            <td>Global variables</td>
            <td><code>*name*</code></td>
            <td><code>*debug-mode*</code>, <code>*max-size*</code></td>
        </tr>
        <tr>
            <td>Constructors</td>
            <td><code>make-name</code></td>
            <td><code>make-vector</code>, <code>make-point</code></td>
        </tr>
        <tr>
            <td>Internal/private</td>
            <td><code>%name</code> or <code>name-internal</code></td>
            <td><code>%helper</code>, <code>parse-internal</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <ul>
        <li><b>Complete example using multiple conventions:</b></li>
<pre><code class="language-scheme line-numbers">; Global configuration
(define *max-retries* 3)

; Constructor
(define (make-connection host port)
  (list host port 'disconnected))

; Predicate
(define (connected? conn)
  (eq? (caddr conn) 'connected))

; Type conversion
(define (connection-&gt;string conn)
  (string-append (car conn) ":" (number-&gt;string (cadr conn))))

; Mutator
(define (connect! conn)
  (set-car! (cddr conn) 'connected))

; Multi-word function
(define (establish-secure-connection host port)
  (let ((conn (make-connection host port)))
    (when (%validate-host host)
      (connect! conn))
    conn))

; Internal helper
(define (%validate-host host)
  (and (string? host)
       (> (string-length host) 0)))

; Usage
(define my-conn (make-connection "localhost" 8080))
(connected? my-conn)                    ; Returns: #f
(connect! my-conn)
(connected? my-conn)                    ; Returns: #t
(connection-&gt;string my-conn)             ; Returns: "localhost:8080"</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-compiler-interpreter">Interacting with Chez Scheme</h3>
<ol>

    <li>Starting Chez Scheme</li>
    <br/>
    <ul>
        <li>Chez Scheme provides both an interactive REPL and a compiler.</li>
        <br/>
        <li><b>Starting the REPL:</b></li>
<pre><code class="language-bash line-numbers"># Start interactive session
$ scheme

# Start with specific options
$ scheme --script myscript.scm
$ scheme --program myprogram.ss</code></pre>
        <br/>
        <li><b>Basic interaction:</b></li>
<pre><code class="language-scheme line-numbers">> (+ 2 3)
5

> (define x 10)

> x
10

> (string-append "Hello, " "World!")
"Hello, World!"</code></pre>
        <br/>
        <li><b>Exiting the REPL:</b></li>
<pre><code class="language-scheme line-numbers">; Method 1: Use exit procedure
> (exit)

; Method 2: Ctrl+D (Unix/Linux/Mac)
> ^D

; Method 3: Ctrl+Z then Enter (Windows)
> ^Z</code></pre>
    </ul>
    <br/><br/>


    <li>Loading and Compiling Files</li>
    <br/>
    <ul>
        <li>Chez Scheme can load source files or compiled object files.</li>
        <br/>
        <li><b>Loading source files with load:</b></li>
<pre><code class="language-scheme line-numbers">; Load a Scheme source file
> (load "myfile.ss")

; Load with .scm extension
> (load "library.scm")

; Load from specific path
> (load "/home/user/code/utils.ss")

; Load relative to current directory
> (load "./helpers/math.ss")</code></pre>
        <br/>
        <li><b>What load does:</b></li>
        <ul>
            <li>Reads and evaluates all expressions in the file</li>
            <li>Definitions become available immediately</li>
            <li>Side effects (like <code>display</code>) happen during load</li>
        </ul>
        <br/>
        <li><b>Example file to load:</b></li>
<pre><code class="language-scheme line-numbers">; File: math-utils.ss
(define (square x)
  (* x x))

(define (cube x)
  (* x x x))

(display "Math utilities loaded")
(newline)</code></pre>
<pre><code class="language-scheme line-numbers">; In REPL
> (load "math-utils.ss")
Math utilities loaded

> (square 5)
25

> (cube 3)
27</code></pre>
        <br/>
        <li><b>Compiling files:</b></li>
<pre><code class="language-scheme line-numbers">; Compile a source file to object file
> (compile-file "myfile.ss")

; This creates myfile.so (compiled object)</code></pre>
        <br/>
        <li><b>Loading compiled files:</b></li>
<pre><code class="language-scheme line-numbers">; Load compiled object (faster)
> (load "myfile.so")

; Chez automatically uses .so if available
> (load "myfile")  ; Loads myfile.so if it exists and is newer</code></pre>
        <br/>
        <li><b>Compilation workflow:</b></li>
<pre><code class="language-bash line-numbers"># From command line
$ echo '(compile-file "myfile.ss")' | scheme

# Or in REPL
> (compile-file "myfile.ss")
> (exit)

# Then load the compiled version
$ scheme
> (load "myfile.so")</code></pre>
    </ul>
    <br/><br/>


    <li>Command-Line Usage</li>
    <br/>
    <ul>
        <li>Chez Scheme supports various command-line options for different use cases.</li>
        <br/>
        <li><b>Running a script:</b></li>
<pre><code class="language-bash line-numbers"># Execute script and exit
$ scheme --script myscript.ss

# With arguments
$ scheme --script myscript.ss arg1 arg2 arg3</code></pre>
        <br/>
        <li><b>Running a program:</b></li>
<pre><code class="language-bash line-numbers"># Run as R6RS program
$ scheme --program myprogram.ss

# Programs must start with library/import declarations
$ scheme --program myprogram.ss arg1 arg2</code></pre>
        <br/>
        <li><b>Evaluating expressions:</b></li>
<pre><code class="language-bash line-numbers"># Evaluate expression and exit
$ scheme --eval '(display "Hello")' --eval '(newline)'

# Combine multiple expressions
$ scheme --eval '(+ 2 3)' --eval '(* 4 5)'</code></pre>
        <br/>
        <li><b>Loading files on startup:</b></li>
<pre><code class="language-bash line-numbers"># Load file then start REPL
$ scheme myfile.ss

# Load multiple files
$ scheme file1.ss file2.ss file3.ss

# Load and run expression
$ scheme myfile.ss --eval '(main)'</code></pre>
        <br/>
        <li><b>Common command-line options:</b></li>
<table>
    <thead>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>--script file</code></td>
            <td>Run script and exit</td>
            <td><code>scheme --script test.ss</code></td>
        </tr>
        <tr>
            <td><code>--program file</code></td>
            <td>Run R6RS program and exit</td>
            <td><code>scheme --program app.ss</code></td>
        </tr>
        <tr>
            <td><code>--eval expr</code></td>
            <td>Evaluate expression</td>
            <td><code>scheme --eval '(+ 1 2)'</code></td>
        </tr>
        <tr>
            <td><code>-q</code></td>
            <td>Quiet mode (no banner)</td>
            <td><code>scheme -q</code></td>
        </tr>
        <tr>
            <td><code>--version</code></td>
            <td>Display version and exit</td>
            <td><code>scheme --version</code></td>
        </tr>
        <tr>
            <td><code>--help</code></td>
            <td>Display help message</td>
            <td><code>scheme --help</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Example script file:</b></li>
<pre><code class="language-scheme line-numbers">#!/usr/bin/env scheme --script
; File: hello.ss

(display "Hello from Chez Scheme!")
(newline)

; Access command-line arguments
(display "Arguments: ")
(display (command-line))
(newline)</code></pre>
<pre><code class="language-bash line-numbers"># Make executable
$ chmod +x hello.ss

# Run directly
$ ./hello.ss arg1 arg2
Hello from Chez Scheme!
Arguments: ("./hello.ss" "arg1" "arg2")</code></pre>
    </ul>
    <br/><br/>


    <li>REPL Special Commands and Features</li>
    <br/>
    <ul>
        <li>The REPL provides special commands for development and debugging.</li>
        <br/>
        <li><b>Inspecting values:</b></li>
<pre><code class="language-scheme line-numbers">; Display value with details
> (define lst '(1 2 3))
> lst
(1 2 3)

; Inspect procedure
> car
#&lt;procedure car&gt;

; Get procedure information
> (procedure-arity car)
#&lt;arity (1)&gt;</code></pre>
        <br/>
        <li><b>Getting help and documentation:</b></li>
<pre><code class="language-scheme line-numbers">; Load help system (if available)
> (load "help.ss")

; Describe a procedure
> (describe '+)
; Shows documentation for +

; Apropos - search for procedures
> (apropos "list")
; Shows all procedures with "list" in name</code></pre>
        <br/>
        <li><b>Compiler and runtime information:</b></li>
<pre><code class="language-scheme line-numbers">; Check Scheme version
> (scheme-version)
"10.0.0"

; Machine type
> (machine-type)
'ta6le  ; or 'a6le, etc.

; Optimize level
> (optimize-level)
2

; Set optimize level (0-3)
> (optimize-level 3)</code></pre>
        <br/>
        <li><b>Timing expressions:</b></li>
<pre><code class="language-scheme line-numbers">; Time an expression
> (time (+ 2 3))
(time (+ 2 3))
    no collections
    0.000000s elapsed cpu time
    0.000001s elapsed real time
    0 bytes allocated
5

; Time a longer computation
> (time (apply + (iota 1000000)))
(time (apply + (iota 1000000)))
    5 collections
    0.021000s elapsed cpu time
    0.021234s elapsed real time
    24000016 bytes allocated
499999500000</code></pre>
        <br/>
        <li><b>Viewing compiler output:</b></li>
<pre><code class="language-scheme line-numbers">; Generate and view assembly
> (expand '(lambda (x) (* x x)))
; Shows expanded form

; Compile and inspect
> (compile '(lambda (x) (* x x)))
#&lt;procedure&gt;</code></pre>
        <br/>
        <li><b>Multi-line input in REPL:</b></li>
<pre><code class="language-scheme line-numbers">; REPL waits for complete expression
> (define (factorial n)
    (if (= n 0)
        1
        (* n (factorial (- n 1)))))

> (factorial 5)
120</code></pre>
        <br/>
        <li><b>Recovering from errors:</b></li>
<pre><code class="language-scheme line-numbers">; Error example
> (/ 1 0)
Exception: attempt to divide by zero

; REPL continues
> (+ 2 3)
5

; Reset environment if needed
> (reset)
; Or restart REPL</code></pre>
    </ul>
    <br/><br/>


    <li>Working with Libraries and Imports</li>
    <br/>
    <ul>
        <li>Chez Scheme supports R6RS libraries and import system.</li>
        <br/>
        <li><b>Defining a library file:</b></li>
<pre><code class="language-scheme line-numbers">; File: mylib.sls (Scheme Library Source)
(library (mylib)
  (export square cube double)
  (import (chezscheme))

  (define (square x)
    (* x x))

  (define (cube x)
    (* x x x))

  (define (double x)
    (* 2 x)))</code></pre>
        <br/>
        <li><b>Importing a library in REPL:</b></li>
<pre><code class="language-scheme line-numbers">; Import library
> (import (mylib))

; Use exported functions
> (square 5)
25

> (cube 3)
27

> (double 10)
20</code></pre>
        <br/>
        <li><b>Importing specific bindings:</b></li>
<pre><code class="language-scheme line-numbers">; Import only specific functions
> (import (only (mylib) square cube))

; Import all except specific
> (import (except (mylib) double))

; Import with rename
> (import (rename (mylib) (square sq)))
> (sq 4)
16

; Import with prefix
> (import (prefix (mylib) math:))
> (math:square 5)
25</code></pre>
        <br/>
        <li><b>Standard library imports:</b></li>
<pre><code class="language-scheme line-numbers">; Import R6RS base library
> (import (rnrs base))

; Import specific R6RS libraries
> (import (rnrs io simple))
> (import (rnrs lists))
> (import (rnrs sorting))

; Import Chez-specific features
> (import (chezscheme))

; Multiple imports at once
> (import (rnrs base)
          (rnrs io simple)
          (mylib))</code></pre>
        <br/>
        <li><b>Library search paths:</b></li>
<pre><code class="language-scheme line-numbers">; Check current library paths
> (library-directories)
(("." . "."))

; Add library path
> (library-directories
    '(("." . ".")
      ("/usr/local/lib/scheme" . "/usr/local/lib/scheme/compiled")))

; Now libraries in /usr/local/lib/scheme are searchable</code></pre>
        <br/>
        <li><b>Creating a program with imports:</b></li>
<pre><code class="language-scheme line-numbers">; File: myprogram.ss
#!chezscheme
(import (chezscheme)
        (mylib))

(define (main)
  (display "Square of 10: ")
  (display (square 10))
  (newline)

  (display "Cube of 5: ")
  (display (cube 5))
  (newline))

(main)</code></pre>
<pre><code class="language-bash line-numbers"># Run the program
$ scheme --program myprogram.ss
Square of 10: 100
Cube of 5: 125</code></pre>
    </ul>
    <br/><br/>


    <li>Compilation Options and Optimization</li>
    <br/>
    <ul>
        <li>Chez Scheme provides optimization levels and compilation controls.</li>
        <br/>
        <li><b>Optimization levels:</b></li>
<table>
    <thead>
        <tr>
            <th>Level</th>
            <th>Description</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>0</code></td>
            <td>No optimization, fastest compile</td>
            <td>Development, debugging</td>
        </tr>
        <tr>
            <td><code>1</code></td>
            <td>Basic optimization</td>
            <td>Default development</td>
        </tr>
        <tr>
            <td><code>2</code></td>
            <td>Standard optimization</td>
            <td>Default (balanced)</td>
        </tr>
        <tr>
            <td><code>3</code></td>
            <td>Aggressive optimization</td>
            <td>Production, performance</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Setting optimization level:</b></li>
<pre><code class="language-scheme line-numbers">; In REPL
> (optimize-level 3)

; Now compilations use level 3
> (compile-file "myfile.ss")

; Check current level
> (optimize-level)
3</code></pre>
        <br/>
        <li><b>Safety vs speed trade-offs:</b></li>
<pre><code class="language-scheme line-numbers">; Debug mode (more checks)
> (debug-level 3)
> (optimize-level 0)

; Production mode (maximum speed)
> (debug-level 0)
> (optimize-level 3)

; Balanced (default)
> (debug-level 2)
> (optimize-level 2)</code></pre>
        <br/>
        <li><b>Compiling with specific options:</b></li>
<pre><code class="language-scheme line-numbers">; Set options before compiling
(parameterize ([optimize-level 3]
               [debug-level 0])
  (compile-file "myfile.ss"))

; Compile multiple files with settings
(for-each
  (lambda (file)
    (parameterize ([optimize-level 3])
      (compile-file file)))
  '("file1.ss" "file2.ss" "file3.ss"))</code></pre>
        <br/>
        <li><b>Whole-program optimization:</b></li>
<pre><code class="language-scheme line-numbers">; Compile library for whole-program optimization
> (compile-library "mylib.sls")

; Or with options
> (parameterize ([optimize-level 3]
                 [generate-wpo-files #t])
    (compile-library "mylib.sls"))</code></pre>
        <br/>
        <li><b>Performance tips:</b></li>
        <ul>
            <li>Use <code>(optimize-level 3)</code> for production code</li>
            <li>Compile files to <code>.so</code> for faster loading</li>
            <li>Use type declarations when possible</li>
            <li>Profile with <code>time</code> to find bottlenecks</li>
            <li>Avoid <code>eval</code> and <code>load</code> in performance-critical code</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Debugging and Error Handling</li>
    <br/>
    <ul>
        <li>Chez Scheme provides tools for debugging and error inspection.</li>
        <br/>
        <li><b>Reading error messages:</b></li>
<pre><code class="language-scheme line-numbers">; Error example
> (car 42)
Exception in car: 42 is not a pair

; Error with context
> (define (process x)
    (car x))
> (process 42)
Exception in car: 42 is not a pair
Exception occurred in process</code></pre>
        <br/>
        <li><b>Stack traces:</b></li>
<pre><code class="language-scheme line-numbers">; Enable debug mode for better traces
> (debug-level 3)

; Now errors show more context
> (define (a) (b))
> (define (b) (c))
> (define (c) (car 42))
> (a)
Exception in car: 42 is not a pair
  in c
  in b
  in a</code></pre>
        <br/>
        <li><b>Exception handling:</b></li>
<pre><code class="language-scheme line-numbers">; Try-catch style with guard
(guard (ex
        [(error? ex)
         (display "Error caught: ")
         (display (error-object-message ex))
         (newline)
         #f])
  (car 42))
; Prints: Error caught: car: 42 is not a pair
; Returns: #f

; With-exception-handler
(with-exception-handler
  (lambda (ex)
    (display "Exception occurred")
    (newline)
    'error)
  (lambda ()
    (/ 1 0)))
; Prints: Exception occurred
; Returns: error</code></pre>
        <br/>
        <li><b>Tracing procedures:</b></li>
<pre><code class="language-scheme line-numbers">; Define a function
> (define (factorial n)
    (if (= n 0)
        1
        (* n (factorial (- n 1)))))

; Trace it
> (trace factorial)

; Now calls are traced
> (factorial 5)
|(factorial 5)
| (factorial 4)
| |(factorial 3)
| | (factorial 2)
| | |(factorial 1)
| | | (factorial 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120

; Untrace
> (untrace factorial)</code></pre>
        <br/>
        <li><b>Break and inspect:</b></li>
<pre><code class="language-scheme line-numbers">; Insert breakpoint
(define (compute x y)
  (let ((a (* x 2))
        (b (+ y 3)))
    (break)  ; Stop here
    (+ a b)))

; When break is hit, can inspect variables
> (compute 5 10)
Break in compute
debug> a
10
debug> b
13
debug> (continue)</code></pre>
        <br/>
        <li><b>Pretty-printing for debugging:</b></li>
<pre><code class="language-scheme line-numbers">; Pretty-print complex structures
> (pretty-print '((a b c) (d (e f) g) (h i)))
((a b c)
 (d (e f) g)
 (h i))

; Print with line numbers
> (pretty-print
    '(define (long-function x y z)
       (let ((a (+ x y))
             (b (* y z)))
         (+ a b))))
(define (long-function x y z)
  (let ((a (+ x y))
        (b (* y z)))
    (+ a b)))</code></pre>
    </ul>
    <br/><br/>


    <li>Creating Standalone Executables</li>
    <br/>
    <ul>
        <li>Chez Scheme can create standalone executable programs.</li>
        <br/>
        <li><b>Creating a boot file:</b></li>
<pre><code class="language-scheme line-numbers">; Compile program to boot file
$ echo '(make-boot-file "myapp.boot" '() "myprogram.ss")' | scheme

; This creates a boot file containing your program</code></pre>
        <br/>
        <li><b>Running a boot file:</b></li>
<pre><code class="language-bash line-numbers"># Run boot file with Scheme
$ scheme -b myapp.boot

# Or specify boot file and entry point
$ scheme -b myapp.boot --eval '(main)'</code></pre>
        <br/>
        <li><b>Creating shell script wrapper:</b></li>
<pre><code class="language-bash line-numbers">#!/bin/sh
# File: myapp
exec scheme -b myapp.boot "$@"</code></pre>
<pre><code class="language-bash line-numbers"># Make executable
$ chmod +x myapp

# Run like a normal program
$ ./myapp
$ ./myapp arg1 arg2</code></pre>
        <br/>
        <li><b>Example: complete program structure</b></li>
<pre><code class="language-scheme line-numbers">; File: myapp.ss
#!chezscheme

(import (chezscheme))

(define (main args)
  (display "MyApp v1.0")
  (newline)
  (when (> (length args) 1)
    (display "Arguments: ")
    (display (cdr args))
    (newline))
  (display "Hello from standalone app!")
  (newline))

; Auto-run main when loaded
(main (command-line))</code></pre>
<pre><code class="language-bash line-numbers"># Build steps
$ scheme --compile-imported-libraries --program myapp.ss
$ echo '(make-boot-file "myapp.boot" '() "myapp.ss")' | scheme

# Create wrapper script
$ cat > myapp << 'EOF'
#!/bin/sh
exec scheme -b myapp.boot "$@"
EOF
$ chmod +x myapp

# Run
$ ./myapp hello world
MyApp v1.0
Arguments: (hello world)
Hello from standalone app!</code></pre>
    </ul>
    <br/><br/>


    <li>Common Workflow Examples</li>
    <br/>
    <ul>
        <li><b>Interactive development workflow:</b></li>
<pre><code class="language-scheme line-numbers">; 1. Start REPL
$ scheme

; 2. Load your code
> (load "mycode.ss")

; 3. Test functions interactively
> (my-function test-data)

; 4. Modify code in editor

; 5. Reload
> (load "mycode.ss")

; 6. Test again
> (my-function test-data)

; Repeat 4-6 until satisfied</code></pre>
        <br/>
        <li><b>Library development workflow:</b></li>
<pre><code class="language-bash line-numbers"># 1. Create library file
$ cat > mylib.sls << 'EOF'
(library (mylib)
  (export func1 func2)
  (import (chezscheme))
  (define (func1 x) ...)
  (define (func2 y) ...))
EOF

# 2. Compile library
$ echo '(compile-library "mylib.sls")' | scheme

# 3. Test in REPL
$ scheme
> (import (mylib))
> (func1 test-input)

# 4. Modify and recompile as needed</code></pre>
        <br/>
        <li><b>Script development workflow:</b></li>
<pre><code class="language-bash line-numbers"># 1. Create script
$ cat > myscript.ss << 'EOF'
#!/usr/bin/env scheme --script
(display "Running script")
(newline)
EOF

# 2. Make executable
$ chmod +x myscript.ss

# 3. Test
$ ./myscript.ss

# 4. Debug if needed
$ scheme
> (load "myscript.ss")</code></pre>
        <br/>
        <li><b>Production deployment workflow:</b></li>
<pre><code class="language-bash line-numbers"># 1. Set optimization and compile all files
$ scheme &lt;&lt; 'EOF'
(optimize-level 3)
(debug-level 0)
(compile-file "module1.ss")
(compile-file "module2.ss")
(compile-library "mylib.sls")
(compile-program "main.ss")
EOF

# 2. Create boot file
$ echo '(make-boot-file "app.boot" '() "main.ss")' | scheme

# 3. Create launcher script
$ cat > app << 'EOF'
#!/bin/sh
exec scheme -b app.boot "$@"
EOF
$ chmod +x app

# 4. Deploy: copy app, app.boot, and .so files to target</code></pre>
    </ul>
    <br/><br/>


    <li>Tips and Best Practices</li>
    <br/>
    <ul>
        <li><b>Development mode setup:</b></li>
<pre><code class="language-scheme line-numbers">; In your .chezscheme.rc or startup file
(optimize-level 1)
(debug-level 3)
(case-sensitive #t)
(print-gensym #t)

; Load commonly used utilities
(load "~/scheme/utils.ss")</code></pre>
        <br/>
        <li><b>REPL productivity tips:</b></li>
        <ul>
            <li>Use arrow keys for command history</li>
            <li>Use Tab for completion (if enabled)</li>
            <li>Define helper functions in a utils file</li>
            <li>Keep a scratch file for experiments</li>
            <li>Use <code>(trace ...)</code> liberally during debugging</li>
        </ul>
        <br/>
        <li><b>File organization:</b></li>
<pre><code class="language-plaintext line-numbers">project/
  src/
    mylib.sls          ; Library definitions
    module1.ss         ; Module source
    module2.ss         ; Module source
  compiled/
    mylib.so           ; Compiled library
    module1.so         ; Compiled module
    module2.so         ; Compiled module
  tests/
    test-mylib.ss      ; Tests
  scripts/
    build.ss           ; Build script
  main.ss              ; Entry point</code></pre>
        <br/>
        <li><b>Avoid common pitfalls:</b></li>
<pre><code class="language-scheme line-numbers">; Don't redefine in REPL without restarting
; if you change function signatures

; Don't:
> (define (func x) ...)      ; Define with 1 arg
> (define (func x y) ...)    ; Redefine with 2 args
; Old callers may still use 1-arg version!

; Do: Restart REPL after signature changes
; Or use parameterize for temporary changes

; Don't load same file multiple times
; without understanding effects

; Don't rely on load order side effects

; Do use libraries for clean interfaces</code></pre>
        <br/>
        <li><b>Performance considerations:</b></li>
        <ul>
            <li>Compile files for production use</li>
            <li>Use <code>(optimize-level 3)</code> for hot paths</li>
            <li>Profile before optimizing</li>
            <li>Consider whole-program compilation for maximum performance</li>
            <li>Avoid unnecessary <code>eval</code> calls</li>
        </ul>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-command-line-options">Chez Scheme Command Line Options</h3>
<ol>

    <li>Basic Invocation</li>
    <br/>
    <ul>
        <li>Chez Scheme is invoked from the command line using <code>scheme</code> (full version) or <code>petite</code> (interpreter-only version).</li>
        <br/>
        <li>General syntax:</li>
<pre><code class="language-bash line-numbers"># Start interactive REPL
$ scheme

# Start Petite Chez Scheme (no compiler)
$ petite

# Load files before entering REPL
$ scheme file1.scm file2.scm

# Run a script
$ scheme --script myscript.scm

# Run an R6RS program
$ scheme --program myprogram.scm
</code></pre>
    </ul>
    <br/><br/>


    <li>Execution Mode Options</li>
    <br/>
    <ul>
        <li><code>--script file</code> runs file as a Scheme shell script.</li>
        <br/>
        <li><code>--program file</code> runs file as an R6RS top-level program.</li>
        <br/>
        <li><code>-q</code> or <code>--quiet</code> suppresses greeting banner and prompts.</li>
        <br/>
        <li>Script example:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --script
(display "Hello from script!")
(newline)
(display "Arguments: ")
(display (cdr (command-line)))
(newline)</code></pre>
        <br/>
        <li>R6RS program example:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --program
(import (rnrs))

(define (main args)
  (for-each
    (lambda (arg)
      (display arg)
      (newline))
    args))

(main (cdr (command-line)))</code></pre>
        <br/>
        <li>You can also use <code>scheme-script</code> as an alias for <code>scheme --program</code>:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/env scheme-script
(import (rnrs))
(display "Running as R6RS program")
(newline)</code></pre>
    </ul>
    <br/><br/>


    <li>Library Options</li>
    <br/>
    <ul>
        <li><code>--libdirs dir:...</code> — Set library source/object directories.</li>
        <br/>
        <li><code>--libexts ext:...</code> — Set library file extensions.</li>
        <br/>
        <li><code>--compile-imported-libraries</code> — Compile libraries before loading them.</li>
        <br/>
        <li><code>--import-notify</code> — Print messages when searching for libraries.</li>
        <br/>
        <li>Directory format uses colons (or semicolons on Windows) as separators:</li>
<pre><code class="language-bash line-numbers"># Set library directories
$ scheme --libdirs /path/to/libs:/another/path

# Set library extensions
$ scheme --libexts .sls:.scm

# Compile libraries automatically
$ scheme --compile-imported-libraries --program myapp.ss

# Debug library loading
$ scheme --import-notify --program myapp.ss</code></pre>
        <br/>
        <li>The source and object directories can be specified separately using double colons:</li>
<pre><code class="language-bash line-numbers"># source-dir::object-dir format
$ scheme --libdirs ./src::./obj:/usr/lib/scheme</code></pre>
        <br/>
        <li>Append to default directories by ending with a colon:</li>
<pre><code class="language-bash line-numbers"># Add to existing directories (note trailing colon)
$ scheme --libdirs /my/libs:</code></pre>
    </ul>
    <br/><br/>


    <li>Optimization and Debugging Options</li>
    <br/>
    <ul>
        <li><code>--optimize-level 0|1|2|3</code> — Set the optimization level (default: 0).</li>
        <ul>
            <li>Levels 0, 1, 2: Safe code with full type and bounds checking</li>
            <li>Level 3: Unsafe code, may omit checks for better performance</li>
        </ul>
        <br/>
        <li><code>--debug-on-exception</code> — Enter debugger on uncaught exceptions.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Maximum optimization (unsafe, for production)
$ scheme --optimize-level 3 --program myapp.ss

# Debug a script that's crashing
$ scheme --debug-on-exception --script buggy.ss

# Safe optimization for development
$ scheme --optimize-level 2 --program myapp.ss</code></pre>
        <br/>
        <li>When <code>--debug-on-exception</code> is active, exceptions enter the inspector:</li>
<pre><code class="language-scheme line-numbers">$ scheme --debug-on-exception
> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.
debug> i     ; inspect continuation
debug> ?     ; show help
debug> q     ; quit debugger</code></pre>
    </ul>
    <br/><br/>


    <li>Expression Editor Options</li>
    <br/>
    <ul>
        <li><code>--eedisable</code> — Disable the expression editor (use plain input).</li>
        <br/>
        <li><code>--eehistory off|file</code> — Set history file location or disable history.</li>
        <br/>
        <li>The expression editor provides:</li>
        <ul>
            <li>Multi-line expression editing with auto-indentation</li>
            <li>Emacs-style key bindings</li>
            <li>History across sessions (stored in <code>~/.chezscheme_history</code>)</li>
            <li>Tab completion for identifiers</li>
            <li>Parenthesis matching and auto-correction</li>
        </ul>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Disable expression editor (useful for piped input)
$ scheme --eedisable

# Use custom history file
$ scheme --eehistory /tmp/my_history

# Disable history saving
$ scheme --eehistory off

# Piping input (editor auto-disabled)
$ echo '(+ 1 2)' | scheme -q</code></pre>
    </ul>
    <br/><br/>


    <li>Boot File Options</li>
    <br/>
    <ul>
        <li><code>-b file</code> or <code>--boot file</code> — Load boot code from specified file.</li>
        <br/>
        <li><code>--verbose</code> — Trace the boot file search process.</li>
        <br/>
        <li>Boot files contain compiled Scheme code implementing the system. By default, the system searches for boot files based on the executable name.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Use custom boot file
$ scheme -b /path/to/custom.boot

# Multiple boot files (order matters: dependencies first)
$ scheme -b petite.boot -b scheme.boot -b myapp.boot

# Trace boot file searching
$ scheme --verbose

# Custom application with boot file
$ scheme -b myapp.boot --program main.ss</code></pre>
        <br/>
        <li>Creating boot files programmatically:</li>
<pre><code class="language-scheme line-numbers">; Create boot file depending on petite or scheme
(make-boot-file "myapp.boot"
                '("petite" "scheme")  ; alternatives
                "module1.so"
                "module2.so")

; Create standalone boot file (includes petite.boot)
(make-boot-file "standalone.boot"
                '()                    ; no dependencies
                "petite.boot"
                "myapp.so")</code></pre>
    </ul>
    <br/><br/>


    <li>Other Options</li>
    <br/>
    <ul>
        <li><code>--version</code> — Print version information and exit.</li>
        <br/>
        <li><code>--help</code> — Print brief help message and exit.</li>
        <br/>
        <li><code>--</code> — Pass all remaining arguments to Scheme (not processed as options).</li>
        <br/>
        <li><code>--enable-object-counts</code> — Have garbage collector maintain object counts.</li>
        <br/>
        <li><code>--retain-static-relocation</code> — Keep relocation info for <code>compute-size</code>, etc.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Check version
$ scheme --version
Chez Scheme Version 10.0.0

# Pass arguments that look like options to your script
$ scheme --script myapp.ss -- --my-flag --another-flag

# Enable object counting for memory profiling
$ scheme --enable-object-counts</code></pre>
    </ul>
    <br/><br/>


    <li>Environment Variables</li>
    <br/>
    <ul>
        <li><code>SCHEMEHEAPDIRS</code> — Colon-separated list of directories to search for boot files.</li>
        <ul>
            <li><code>%v</code> is replaced by the version number</li>
            <li><code>%m</code> is replaced by the machine type</li>
            <li><code>%%</code> is replaced by a literal <code>%</code></li>
        </ul>
        <br/>
        <li><code>CHEZSCHEMELIBDIRS</code> — Default value for <code>--libdirs</code> if not specified.</li>
        <br/>
        <li><code>CHEZSCHEMELIBEXTS</code> — Default value for <code>--libexts</code> if not specified.</li>
        <br/>
        <li><code>CHEZSCHEME_HISTORY</code> — Location of expression editor history file.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Set boot file search path
export SCHEMEHEAPDIRS="/opt/chez/%v/%m:/usr/lib/csv%v"

# Set default library directories
export CHEZSCHEMELIBDIRS="/home/user/scheme/libs:/usr/local/lib/scheme"

# Set custom history location
export CHEZSCHEME_HISTORY="$HOME/.config/chez_history"</code></pre>
    </ul>
    <br/><br/>


    <li>Accessing Command Line Arguments in Scheme</li>
    <br/>
    <ul>
        <li>Use <code>(command-line)</code> to get arguments as a list.</li>
        <br/>
        <li>The first element is the script/program name, remaining elements are arguments.</li>
        <br/>
        <li>Use <code>(command-line-arguments)</code> for just the arguments (Chez-specific).</li>
        <br/>
        <li>Example script with argument parsing:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --script

(define args (command-line))

(display "Program: ")
(display (car args))
(newline)

(display "Arguments: ")
(display (cdr args))
(newline)

(display "Argument count: ")
(display (length (cdr args)))
(newline)

; Process arguments
(for-each
  (lambda (arg)
    (cond
      [(string=? arg "--help")
       (display "Usage: myscript [options]")
       (newline)
       (exit 0)]
      [(string=? arg "--verbose")
       (display "Verbose mode enabled")
       (newline)]
      [else
       (display "Unknown argument: ")
       (display arg)
       (newline)]))
  (cdr args))</code></pre>
<pre><code class="language-bash line-numbers">$ chmod +x myscript.ss
$ ./myscript.ss --verbose foo bar
Program: ./myscript.ss
Arguments: (--verbose foo bar)
Argument count: 3
Verbose mode enabled
Unknown argument: foo
Unknown argument: bar</code></pre>
    </ul>
    <br/><br/>


    <li>Quick Reference Table</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Option</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>-q, --quiet</code></td>
            <td>Suppress greeting and prompts</td>
        </tr>
        <tr>
            <td><code>--script file</code></td>
            <td>Run file as shell script</td>
        </tr>
        <tr>
            <td><code>--program file</code></td>
            <td>Run file as R6RS program</td>
        </tr>
        <tr>
            <td><code>--libdirs dir:...</code></td>
            <td>Set library directories</td>
        </tr>
        <tr>
            <td><code>--libexts ext:...</code></td>
            <td>Set library extensions</td>
        </tr>
        <tr>
            <td><code>--compile-imported-libraries</code></td>
            <td>Compile libraries before loading</td>
        </tr>
        <tr>
            <td><code>--import-notify</code></td>
            <td>Trace library search</td>
        </tr>
        <tr>
            <td><code>--optimize-level n</code></td>
            <td>Set optimization (0-3)</td>
        </tr>
        <tr>
            <td><code>--debug-on-exception</code></td>
            <td>Enter debugger on exceptions</td>
        </tr>
        <tr>
            <td><code>--eedisable</code></td>
            <td>Disable expression editor</td>
        </tr>
        <tr>
            <td><code>--eehistory off|file</code></td>
            <td>Set/disable history file</td>
        </tr>
        <tr>
            <td><code>-b, --boot file</code></td>
            <td>Load boot file</td>
        </tr>
        <tr>
            <td><code>--verbose</code></td>
            <td>Trace boot search</td>
        </tr>
        <tr>
            <td><code>--enable-object-counts</code></td>
            <td>Enable GC object counting</td>
        </tr>
        <tr>
            <td><code>--retain-static-relocation</code></td>
            <td>Keep relocation info</td>
        </tr>
        <tr>
            <td><code>--version</code></td>
            <td>Print version and exit</td>
        </tr>
        <tr>
            <td><code>--help</code></td>
            <td>Print help and exit</td>
        </tr>
        <tr>
            <td><code>--</code></td>
            <td>Pass remaining args to Scheme</td>
        </tr>
    </tbody>
</table>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-r6rs">R6RS in Chez Scheme</h3>
<ol>

    <li>What is R6RS?</li>
    <br/>
    <ul>
        <li>R6RS (Revised⁶ Report on the Algorithmic Language Scheme) is a major Scheme standard ratified in 2007.</li>
        <br/>
        <li>Key features introduced by R6RS:</li>
        <ul>
            <li>Standard library system for modular code</li>
            <li>Unicode support for source code and strings</li>
            <li>Exception handling and condition system</li>
            <li>Record types with procedural and syntactic layers</li>
            <li>Bytevectors for binary data</li>
            <li>Hash tables</li>
            <li>Hygienic macros via <code>syntax-case</code></li>
            <li>Full numeric tower requirement</li>
        </ul>
        <br/>
        <li>Chez Scheme fully implements R6RS and its standard libraries.</li>
    </ul>
    <br/><br/>


    <li>R6RS Standard Libraries</li>
    <br/>
    <ul>
        <li>R6RS organizes functionality into standard libraries that can be imported as needed:</li>
<table>
    <thead>
        <tr>
            <th>Library</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>(rnrs base (6))</code></td>
            <td>Core language: define, lambda, if, let, etc.</td>
        </tr>
        <tr>
            <td><code>(rnrs lists (6))</code></td>
            <td>List operations: find, filter, fold-left, etc.</td>
        </tr>
        <tr>
            <td><code>(rnrs sorting (6))</code></td>
            <td>Sorting: list-sort, vector-sort</td>
        </tr>
        <tr>
            <td><code>(rnrs control (6))</code></td>
            <td>Control: when, unless, do, case-lambda</td>
        </tr>
        <tr>
            <td><code>(rnrs io simple (6))</code></td>
            <td>Simple I/O: read, write, display</td>
        </tr>
        <tr>
            <td><code>(rnrs io ports (6))</code></td>
            <td>Port-based I/O: binary/textual ports</td>
        </tr>
        <tr>
            <td><code>(rnrs files (6))</code></td>
            <td>File operations: file-exists?, delete-file</td>
        </tr>
        <tr>
            <td><code>(rnrs unicode (6))</code></td>
            <td>Unicode: char-upcase, string-normalize-nfc</td>
        </tr>
        <tr>
            <td><code>(rnrs bytevectors (6))</code></td>
            <td>Binary data: bytevector operations</td>
        </tr>
        <tr>
            <td><code>(rnrs hashtables (6))</code></td>
            <td>Hash tables: make-hashtable, hashtable-ref</td>
        </tr>
        <tr>
            <td><code>(rnrs records syntactic (6))</code></td>
            <td>Record definitions via define-record-type</td>
        </tr>
        <tr>
            <td><code>(rnrs records procedural (6))</code></td>
            <td>Procedural record creation</td>
        </tr>
        <tr>
            <td><code>(rnrs records inspection (6))</code></td>
            <td>Record introspection</td>
        </tr>
        <tr>
            <td><code>(rnrs conditions (6))</code></td>
            <td>Condition types for exceptions</td>
        </tr>
        <tr>
            <td><code>(rnrs exceptions (6))</code></td>
            <td>Exception handling: guard, raise</td>
        </tr>
        <tr>
            <td><code>(rnrs syntax-case (6))</code></td>
            <td>Procedural macros</td>
        </tr>
        <tr>
            <td><code>(rnrs arithmetic fixnums (6))</code></td>
            <td>Fixed-precision integer operations</td>
        </tr>
        <tr>
            <td><code>(rnrs arithmetic flonums (6))</code></td>
            <td>Floating-point operations</td>
        </tr>
        <tr>
            <td><code>(rnrs arithmetic bitwise (6))</code></td>
            <td>Bitwise operations</td>
        </tr>
        <tr>
            <td><code>(rnrs enums (6))</code></td>
            <td>Enumeration types</td>
        </tr>
        <tr>
            <td><code>(rnrs eval (6))</code></td>
            <td>Evaluation: eval, environment</td>
        </tr>
        <tr>
            <td><code>(rnrs mutable-pairs (6))</code></td>
            <td>set-car!, set-cdr!</td>
        </tr>
        <tr>
            <td><code>(rnrs mutable-strings (6))</code></td>
            <td>string-set!, string-fill!</td>
        </tr>
        <tr>
            <td><code>(rnrs programs (6))</code></td>
            <td>command-line, exit</td>
        </tr>
        <tr>
            <td><code>(rnrs r5rs (6))</code></td>
            <td>R5RS compatibility: delay, force, etc.</td>
        </tr>
        <tr>
            <td><code>(rnrs (6))</code></td>
            <td>Composite: exports all of the above</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The version number <code>(6)</code> can usually be omitted:</li>
<pre><code class="language-scheme line-numbers">; These are equivalent
(import (rnrs base (6)))
(import (rnrs base))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Top-Level Programs</li>
    <br/>
    <ul>
        <li>An R6RS top-level program starts with an <code>import</code> form followed by a body:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

(define (greet name)
  (display "Hello, ")
  (display name)
  (display "!")
  (newline))

(greet "World")</code></pre>
        <br/>
        <li>Run with the <code>--program</code> option:</li>
<pre><code class="language-bash line-numbers">$ scheme --program hello.ss
Hello, World!</code></pre>
        <br/>
        <li>Make it executable with a shebang:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --program
(import (rnrs))

(for-each
  (lambda (arg)
    (display arg)
    (newline))
  (cdr (command-line)))</code></pre>
<pre><code class="language-bash line-numbers">$ chmod +x myprogram.ss
$ ./myprogram.ss arg1 arg2
arg1
arg2</code></pre>
        <br/>
        <li>Alternative shebang using <code>env</code>:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/env scheme-script
(import (rnrs))
(display "Portable shebang!")
(newline)</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Library Definition</li>
    <br/>
    <ul>
        <li>Libraries are defined with the <code>library</code> form:</li>
<pre><code class="language-scheme line-numbers">(library (mylib utils)
  (export square cube average)
  (import (rnrs))

  (define (square x) (* x x))
  (define (cube x) (* x x x))
  (define (average x y) (/ (+ x y) 2)))</code></pre>
        <br/>
        <li>Save as <code>mylib/utils.sls</code> (directory structure matches library name).</li>
        <br/>
        <li>Use the library in a program:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs)
        (mylib utils))

(display (square 5))    ; 25
(newline)
(display (cube 3))      ; 27
(newline)</code></pre>
        <br/>
        <li>Library with versioning:</li>
<pre><code class="language-scheme line-numbers">(library (mylib math (1 0 0))
  (export factorial fibonacci)
  (import (rnrs))

  (define (factorial n)
    (if (zero? n) 1 (* n (factorial (- n 1)))))

  (define (fibonacci n)
    (if (< n 2) n
        (+ (fibonacci (- n 1))
           (fibonacci (- n 2))))))</code></pre>
    </ul>
    <br/><br/>


    <li>Import Specifications</li>
    <br/>
    <ul>
        <li>R6RS provides several ways to control imports:</li>
        <br/>
        <li><code>only</code> — import specific identifiers:</li>
<pre><code class="language-scheme line-numbers">(import (only (rnrs) define lambda if))</code></pre>
        <br/>
        <li><code>except</code> — import all except specified:</li>
<pre><code class="language-scheme line-numbers">(import (except (rnrs) set-car! set-cdr!))</code></pre>
        <br/>
        <li><code>prefix</code> — add prefix to all imports:</li>
<pre><code class="language-scheme line-numbers">(import (prefix (rnrs lists) list:))

(list:filter odd? '(1 2 3 4 5))  ; (1 3 5)</code></pre>
        <br/>
        <li><code>rename</code> — rename specific imports:</li>
<pre><code class="language-scheme line-numbers">(import (rename (rnrs)
                (display print)
                (newline nl)))

(print "Hello")
(nl)</code></pre>
        <br/>
        <li>Combinations:</li>
<pre><code class="language-scheme line-numbers">(import (prefix (only (rnrs lists) filter map) list:))

(list:map square '(1 2 3))       ; (1 4 9)
(list:filter even? '(1 2 3 4))   ; (2 4)</code></pre>
    </ul>
    <br/><br/>


    <li>Export Specifications</li>
    <br/>
    <ul>
        <li>Control what a library exports:</li>
        <br/>
        <li>Simple export:</li>
<pre><code class="language-scheme line-numbers">(library (mylib)
  (export public-proc another-proc)
  (import (rnrs))

  (define (public-proc x) (helper x))
  (define (another-proc y) (* y 2))
  (define (helper x) (+ x 1)))  ; not exported</code></pre>
        <br/>
        <li>Export with renaming:</li>
<pre><code class="language-scheme line-numbers">(library (mylib)
  (export (rename (internal-name external-name)
                  (proc1 public-proc1)))
  (import (rnrs))

  (define (internal-name x) ...)
  (define (proc1 x) ...))</code></pre>
        <br/>
        <li>Re-export from another library:</li>
<pre><code class="language-scheme line-numbers">(library (mylib combined)
  (export
    ; Export from this library
    my-func
    ; Re-export from rnrs lists
    (import (rnrs lists)))
  (import (rnrs)
          (rnrs lists))

  (define (my-func x) ...))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Records</li>
    <br/>
    <ul>
        <li>R6RS provides a powerful record system with syntactic and procedural layers.</li>
        <br/>
        <li>Syntactic layer (most common):</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

; Define a point record
(define-record-type point
  (fields x y))

; Create instances
(define p1 (make-point 3 4))

; Access fields
(point-x p1)    ; 3
(point-y p1)    ; 4

; Type predicate
(point? p1)     ; #t
(point? 42)     ; #f</code></pre>
        <br/>
        <li>Mutable fields:</li>
<pre><code class="language-scheme line-numbers">(define-record-type counter
  (fields (mutable value)))

(define c (make-counter 0))
(counter-value c)           ; 0
(counter-value-set! c 10)
(counter-value c)           ; 10</code></pre>
        <br/>
        <li>Record inheritance:</li>
<pre><code class="language-scheme line-numbers">(define-record-type point
  (fields x y))

(define-record-type point3d
  (parent point)
  (fields z))

(define p (make-point3d 1 2 3))
(point-x p)      ; 1 (inherited)
(point-y p)      ; 2 (inherited)
(point3d-z p)    ; 3
(point? p)       ; #t
(point3d? p)     ; #t</code></pre>
        <br/>
        <li>Custom constructor:</li>
<pre><code class="language-scheme line-numbers">(define-record-type person
  (fields name age)
  (protocol
    (lambda (new)
      (lambda (name birth-year)
        (new name (- 2025 birth-year))))))

(define p (make-person "Alice" 1990))
(person-name p)  ; "Alice"
(person-age p)   ; 35</code></pre>
        <br/>
        <li>Nongenerative records (same type across invocations):</li>
<pre><code class="language-scheme line-numbers">(define-record-type point
  (nongenerative point-uid-12345)
  (fields x y))</code></pre>
        <br/>
        <li>Sealed and opaque records:</li>
<pre><code class="language-scheme line-numbers">; Sealed: cannot be inherited
(define-record-type final-type
  (sealed #t)
  (fields value))

; Opaque: cannot be inspected
(define-record-type private-type
  (opaque #t)
  (fields secret))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Exception Handling</li>
    <br/>
    <ul>
        <li>R6RS provides <code>guard</code> for exception handling:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

(guard (ex
        [(error? ex)
         (display "Error: ")
         (display (condition-message ex))
         (newline)]
        [(assertion-violation? ex)
         (display "Assertion failed!")
         (newline)]
        [else
         (display "Unknown exception")
         (newline)])
  (assertion-violation 'test "something went wrong"))</code></pre>
        <br/>
        <li>Raising exceptions:</li>
<pre><code class="language-scheme line-numbers">; Raise continuable exception
(raise-continuable (make-warning))

; Raise non-continuable exception
(raise (make-error))

; Convenience procedures
(error 'proc-name "message" irritant1 irritant2)
(assertion-violation 'proc-name "message" irritant)</code></pre>
        <br/>
        <li>Condition hierarchy (partial):</li>
<pre><code class="language-scheme line-numbers">&condition
├── &warning
├── &serious
│   ├── &error
│   └── &violation
│       ├── &assertion
│       ├── &non-continuable
│       ├── &implementation-restriction
│       ├── &lexical
│       ├── &syntax
│       └── &undefined
├── &message
├── &irritants
└── &who</code></pre>
        <br/>
        <li>Creating compound conditions:</li>
<pre><code class="language-scheme line-numbers">(define my-condition
  (condition
    (make-error)
    (make-who-condition 'my-proc)
    (make-message-condition "Something failed")
    (make-irritants-condition '(bad-value))))

(raise my-condition)</code></pre>
        <br/>
        <li>Defining custom condition types:</li>
<pre><code class="language-scheme line-numbers">(define-condition-type &my-error &error
  make-my-error my-error?
  (code my-error-code))

(guard (ex
        [(my-error? ex)
         (display "My error with code: ")
         (display (my-error-code ex))])
  (raise (make-my-error 42)))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Bytevectors</li>
    <br/>
    <ul>
        <li>Bytevectors are sequences of bytes for binary data:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

; Create bytevector
(define bv (make-bytevector 10 0))  ; 10 bytes, filled with 0

; Direct creation
(define bv2 #vu8(1 2 3 4 5))

; Access bytes
(bytevector-u8-ref bv2 0)           ; 1
(bytevector-u8-set! bv 0 255)

; Length
(bytevector-length bv2)             ; 5</code></pre>
        <br/>
        <li>Multi-byte access with endianness:</li>
<pre><code class="language-scheme line-numbers">; 16-bit access
(bytevector-u16-ref bv 0 (endianness big))
(bytevector-u16-set! bv 0 1000 (endianness little))

; 32-bit access
(bytevector-s32-ref bv 0 (endianness native))

; 64-bit access
(bytevector-u64-ref bv 0 (endianness big))

; Floating point
(bytevector-ieee-single-ref bv 0 (endianness native))
(bytevector-ieee-double-set! bv 0 3.14159 (endianness big))</code></pre>
        <br/>
        <li>String conversion:</li>
<pre><code class="language-scheme line-numbers">; UTF-8
(string->utf8 "Hello")           ; #vu8(72 101 108 108 111)
(utf8->string #vu8(72 101 108 108 111))  ; "Hello"

; UTF-16
(string->utf16 "Hello" (endianness big))
(utf16->string bv (endianness little))

; UTF-32
(string->utf32 "Hello" (endianness native))</code></pre>
        <br/>
        <li>Bytevector operations:</li>
<pre><code class="language-scheme line-numbers">; Copy
(bytevector-copy bv)
(bytevector-copy! src src-start dst dst-start count)

; Compare
(bytevector=? bv1 bv2)

; Fill
(bytevector-fill! bv 0)</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Hash Tables</li>
    <br/>
    <ul>
        <li>R6RS provides standard hash table operations:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

; Create hash tables
(define ht (make-hashtable string-hash string=?))
(define eq-ht (make-eq-hashtable))
(define eqv-ht (make-eqv-hashtable))

; Set and get
(hashtable-set! ht "name" "Alice")
(hashtable-set! ht "age" 30)
(hashtable-ref ht "name" #f)        ; "Alice"
(hashtable-ref ht "missing" 'default) ; default

; Check existence
(hashtable-contains? ht "name")     ; #t

; Delete
(hashtable-delete! ht "age")

; Size
(hashtable-size ht)                 ; 1</code></pre>
        <br/>
        <li>Iteration:</li>
<pre><code class="language-scheme line-numbers">; Get keys and values as vectors
(hashtable-keys ht)                 ; #("name")
(hashtable-entries ht)              ; #("name"), #("Alice")

; Process all entries
(let-values ([(keys vals) (hashtable-entries ht)])
  (vector-for-each
    (lambda (k v)
      (display k) (display ": ") (display v) (newline))
    keys vals))</code></pre>
        <br/>
        <li>Update operations:</li>
<pre><code class="language-scheme line-numbers">; Update existing or insert
(hashtable-update! ht "count"
  (lambda (v) (+ v 1))
  0)  ; default if not present

; Clear all
(hashtable-clear! ht)

; Copy
(hashtable-copy ht)
(hashtable-copy ht #t)  ; mutable copy</code></pre>
    </ul>
    <br/><br/>


    <li>Chez Scheme vs R6RS Mode</li>
    <br/>
    <ul>
        <li>Chez Scheme extends R6RS with additional features. Use <code>#!r6rs</code> for strict R6RS mode:</li>
<pre><code class="language-scheme line-numbers">; File starts in R6RS mode
#!r6rs
(import (rnrs))

; Only R6RS syntax allowed here
(define x 10)</code></pre>
        <br/>
        <li>Use <code>#!chezscheme</code> to enable Chez extensions:</li>
<pre><code class="language-scheme line-numbers">#!chezscheme
(import (chezscheme))

; Chez-specific features available
(printf "~a~n" "Hello")
(define-syntax my-macro
  (syntax-rules ()
    [(_ x) x]))  ; fenders allowed</code></pre>
        <br/>
        <li>The <code>(chezscheme)</code> library provides all R6RS bindings plus Chez extensions:</li>
<pre><code class="language-scheme line-numbers">; (rnrs) is strict R6RS
; (chezscheme) extends R6RS

; Some differences:
; - (chezscheme) syntax-rules allows fenders
; - (chezscheme) current-input-port accepts optional argument
; - (chezscheme) includes additional procedures</code></pre>
        <br/>
        <li>Chez also provides R6RS bindings with <code>rnrs:</code> prefix:</li>
<pre><code class="language-scheme line-numbers">(import (chezscheme))

; Both available:
(current-input-port)       ; Chez version (can set port)
(rnrs:current-input-port)  ; Strict R6RS version</code></pre>
    </ul>
    <br/><br/>


    <li>Compiling R6RS Programs</li>
    <br/>
    <ul>
        <li>Compile libraries:</li>
<pre><code class="language-bash line-numbers"># Compile a library
$ echo '(compile-library "mylib.sls")' | scheme

# Compile with auto-compilation of dependencies
$ scheme --compile-imported-libraries --program main.ss</code></pre>
        <br/>
        <li>Compile top-level programs:</li>
<pre><code class="language-bash line-numbers"># compile-program preserves shebang line
$ echo '(compile-program "myapp.ss")' | scheme

# Result: myapp.so (compiled program)</code></pre>
        <br/>
        <li>Programmatic compilation:</li>
<pre><code class="language-scheme line-numbers">; In REPL or build script
(compile-imported-libraries #t)  ; Auto-compile imports
(compile-library "mylib.sls")
(compile-program "main.ss")</code></pre>
        <br/>
        <li>Library search paths:</li>
<pre><code class="language-bash line-numbers"># Set library directories
$ scheme --libdirs ./src:./lib --program main.ss

# Set via environment
$ export CHEZSCHEMELIBDIRS="./src:./lib"
$ scheme --program main.ss</code></pre>
    </ul>
    <br/><br/>


    <li>Portability Tips</li>
    <br/>
    <ul>
        <li>R6RS does not guarantee argument evaluation order:</li>
<pre><code class="language-scheme line-numbers">; Don't rely on left-to-right evaluation
(define counter 0)
(define (inc!) (set! counter (+ counter 1)) counter)

; Result is implementation-dependent!
(list (inc!) (inc!) (inc!))  ; Could be (1 2 3) or (3 2 1) etc.</code></pre>
        <br/>
        <li>Fixnum range varies by implementation:</li>
<pre><code class="language-scheme line-numbers">; Minimum guaranteed: 24 bits (-8388608 to 8388607)
; Chez Scheme typically: 61 bits on 64-bit systems

; For portable code, use generic arithmetic for large numbers
(+ x y)  ; Always safe
(fx+ x y)  ; May overflow on small fixnum implementations</code></pre>
        <br/>
        <li>Specify endianness explicitly for binary data:</li>
<pre><code class="language-scheme line-numbers">; Don't use (endianness native) for files/network
(bytevector-u32-set! bv 0 value (endianness big))  ; Portable</code></pre>
        <br/>
        <li>Use <code>#!r6rs</code> at the start of portable code to ensure strict compliance.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-control-flow">Chez Scheme Control Flow</h3>
<ol>

    <li>Conditional Expressions</li>
    <br/>
    <ul>
        <li><code>if</code> is the fundamental conditional:</li>
<pre><code class="language-scheme line-numbers">; Basic if: (if test consequent alternative)
(if (> 5 3) 'yes 'no)           ; yes

; Without alternative (returns unspecified if false)
(if (> 5 3) (display "yes"))

; Nested if
(define (sign n)
  (if (> n 0)
      'positive
      (if (< n 0)
          'negative
          'zero)))

(sign 5)    ; positive
(sign -3)   ; negative
(sign 0)    ; zero</code></pre>
        <br/>
        <li><code>cond</code> for multiple conditions:</li>
<pre><code class="language-scheme line-numbers">; (cond [test expr ...] ... [else expr ...])
(define (grade score)
  (cond
    [(>= score 90) 'A]
    [(>= score 80) 'B]
    [(>= score 70) 'C]
    [(>= score 60) 'D]
    [else 'F]))

(grade 85)  ; B
(grade 55)  ; F

; cond with => (passes test result to procedure)
(cond
  [(assq 'b '((a 1) (b 2) (c 3))) => cadr]
  [else 'not-found])  ; 2

; Multiple expressions in clause
(cond
  [(even? x)
   (display "even")
   (newline)
   'even]
  [else 'odd])</code></pre>
        <br/>
        <li><code>case</code> for value matching:</li>
<pre><code class="language-scheme line-numbers">; (case key [(datum ...) expr ...] ... [else expr ...])
(define (day-type day)
  (case day
    [(saturday sunday) 'weekend]
    [(monday tuesday wednesday thursday friday) 'weekday]
    [else 'unknown]))

(day-type 'saturday)  ; weekend
(day-type 'monday)    ; weekday

; case uses eqv? for comparison
(case (car '(a b))
  [(a) 'first]
  [(b) 'second]
  [else 'other])  ; first

; Multiple values in single clause
(define (vowel? c)
  (case c
    [(a e i o u A E I O U) #t]
    [else #f]))</code></pre>
        <br/>
        <li><code>when</code> and <code>unless</code> for one-sided conditionals:</li>
<pre><code class="language-scheme line-numbers">; when: execute if true
(when (> x 0)
  (display "positive")
  (newline))

; unless: execute if false
(unless (null? lst)
  (display "list is not empty")
  (process lst))

; Equivalent to:
; (when test body ...) = (if test (begin body ...))
; (unless test body ...) = (if (not test) (begin body ...))</code></pre>
        <br/>
        <li>Boolean operations for control flow:</li>
<pre><code class="language-scheme line-numbers">; and: returns first false or last value
(and (> 5 3) (< 2 4) 'ok)       ; ok
(and (> 5 3) (< 4 2) 'ok)       ; #f
(and)                            ; #t

; or: returns first true or last value
(or (> 1 5) (> 3 2) 'fallback)  ; #t
(or #f #f 'default)             ; default
(or)                             ; #f

; Short-circuit evaluation
(and (pair? x) (car x))         ; Safe: car only if pair
(or (hashtable-ref ht key #f)
    (compute-default key))       ; Only compute if not found</code></pre>
    </ul>
    <br/><br/>


    <li>Sequencing</li>
    <br/>
    <ul>
        <li><code>begin</code> evaluates expressions in order:</li>
<pre><code class="language-scheme line-numbers">; Returns the value of the last expression
(begin
  (display "one")
  (newline)
  (display "two")
  (newline)
  'done)  ; displays "one" and "two", returns done

; Implicit begin in lambda, let, define, etc.
(define (greet name)
  (display "Hello, ")    ; implicit begin
  (display name)
  (newline))

; begin is often used in conditionals
(if (check-condition)
    (begin
      (do-something)
      (do-another)
      result)
    alternative)</code></pre>
        <br/>
        <li><code>begin0</code> returns the first value (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Returns value of first expression
(begin0
  (get-result)      ; This value is returned
  (cleanup)
  (log-completion))

; Useful for cleanup after getting a value
(define (pop! stack)
  (begin0
    (car stack)
    (set! stack (cdr stack))))</code></pre>
    </ul>
    <br/><br/>


    <li>Iteration with Named let</li>
    <br/>
    <ul>
        <li>Named <code>let</code> creates a local recursive procedure:</li>
<pre><code class="language-scheme line-numbers">; (let name ([var init] ...) body)
(let loop ([i 0])
  (when (< i 5)
    (display i)
    (newline)
    (loop (+ i 1))))
; Prints 0 1 2 3 4

; Summing a list
(define (sum lst)
  (let loop ([lst lst] [acc 0])
    (if (null? lst)
        acc
        (loop (cdr lst) (+ acc (car lst))))))

(sum '(1 2 3 4 5))  ; 15

; Finding an element
(define (find pred lst)
  (let loop ([lst lst])
    (cond
      [(null? lst) #f]
      [(pred (car lst)) (car lst)]
      [else (loop (cdr lst))])))</code></pre>
        <br/>
        <li>Named let for multiple accumulators:</li>
<pre><code class="language-scheme line-numbers">; Partition a list
(define (partition pred lst)
  (let loop ([lst lst] [yes '()] [no '()])
    (cond
      [(null? lst)
       (values (reverse yes) (reverse no))]
      [(pred (car lst))
       (loop (cdr lst) (cons (car lst) yes) no)]
      [else
       (loop (cdr lst) yes (cons (car lst) no))])))

(partition even? '(1 2 3 4 5 6))
; Values: (2 4 6) (1 3 5)</code></pre>
    </ul>
    <br/><br/>


    <li>The do Loop</li>
    <br/>
    <ul>
        <li><code>do</code> provides traditional loop syntax:</li>
<pre><code class="language-scheme line-numbers">; (do ([var init step] ...)
;     (test result ...)
;   body ...)

; Simple counting loop
(do ([i 0 (+ i 1)])
    [(= i 5) 'done]
  (display i)
  (newline))
; Prints 0 1 2 3 4, returns done

; Factorial
(define (factorial n)
  (do ([i n (- i 1)]
       [acc 1 (* acc i)])
      [(zero? i) acc]))

(factorial 5)  ; 120

; Multiple variables
(do ([i 0 (+ i 1)]
     [j 10 (- j 1)])
    [(= i j) (list i j)]
  (printf "i=~a j=~a~n" i j))
; Prints pairs until i=j=5</code></pre>
        <br/>
        <li>Building a list with do:</li>
<pre><code class="language-scheme line-numbers">; Map using do
(define (my-map f lst)
  (do ([lst lst (cdr lst)]
       [result '() (cons (f (car lst)) result)])
      [(null? lst) (reverse result)]))

(my-map square '(1 2 3 4 5))  ; (1 4 9 16 25)

; Collect first n elements
(define (take n lst)
  (do ([i 0 (+ i 1)]
       [lst lst (cdr lst)]
       [acc '() (cons (car lst) acc)])
      [(or (= i n) (null? lst))
       (reverse acc)]))</code></pre>
    </ul>
    <br/><br/>


    <li>Higher-Order Iteration</li>
    <br/>
    <ul>
        <li><code>for-each</code> for side effects:</li>
<pre><code class="language-scheme line-numbers">; Apply procedure to each element
(for-each display '(1 2 3 4 5))      ; Prints: 12345
(for-each
  (lambda (x) (display x) (newline))
  '(a b c))

; Multiple lists (stops at shortest)
(for-each
  (lambda (x y) (printf "~a + ~a = ~a~n" x y (+ x y)))
  '(1 2 3)
  '(10 20 30))
; 1 + 10 = 11
; 2 + 20 = 22
; 3 + 30 = 33</code></pre>
        <br/>
        <li><code>map</code> transforms lists:</li>
<pre><code class="language-scheme line-numbers">(map square '(1 2 3 4 5))           ; (1 4 9 16 25)
(map + '(1 2 3) '(10 20 30))        ; (11 22 33)
(map cons '(a b c) '(1 2 3))        ; ((a . 1) (b . 2) (c . 3))

; Nested map
(map (lambda (row)
       (map square row))
     '((1 2) (3 4) (5 6)))
; ((1 4) (9 16) (25 36))</code></pre>
        <br/>
        <li>Folding operations:</li>
<pre><code class="language-scheme line-numbers">; fold-left: accumulate left to right
; (fold-left proc init list)
(fold-left + 0 '(1 2 3 4 5))        ; 15
(fold-left cons '() '(1 2 3))       ; ((((() . 1) . 2) . 3)
(fold-left (lambda (acc x) (cons x acc))
           '() '(1 2 3))             ; (3 2 1) - reverse!

; fold-right: accumulate right to left
(fold-right cons '() '(1 2 3))      ; (1 2 3) - copy
(fold-right + 0 '(1 2 3 4 5))       ; 15

; Practical examples
(define (my-length lst)
  (fold-left (lambda (acc _) (+ acc 1)) 0 lst))

(define (my-reverse lst)
  (fold-left (lambda (acc x) (cons x acc)) '() lst))

(define (my-append lst1 lst2)
  (fold-right cons lst2 lst1))</code></pre>
        <br/>
        <li>Filtering and searching:</li>
<pre><code class="language-scheme line-numbers">; filter: keep matching elements
(filter even? '(1 2 3 4 5 6))       ; (2 4 6)
(filter (lambda (x) (> x 3)) '(1 2 3 4 5))  ; (4 5)

; find: first matching element
(find even? '(1 3 4 5 6))           ; 4
(find even? '(1 3 5))               ; #f

; exists: any element matches?
(exists even? '(1 3 4 5))           ; #t
(exists even? '(1 3 5))             ; #f

; for-all: all elements match?
(for-all even? '(2 4 6))            ; #t
(for-all even? '(2 3 4))            ; #f

; partition: split by predicate
(partition even? '(1 2 3 4 5 6))
; Values: (2 4 6) (1 3 5)</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Values</li>
    <br/>
    <ul>
        <li><code>values</code> returns multiple values:</li>
<pre><code class="language-scheme line-numbers">; Return multiple values
(define (quotient-remainder n d)
  (values (quotient n d) (remainder n d)))

(quotient-remainder 17 5)  ; 3 and 2

; values with any number of results
(values 1 2 3)             ; Three values
(values)                   ; Zero values
(values 'single)           ; One value (same as just 'single)</code></pre>
        <br/>
        <li><code>call-with-values</code> receives multiple values:</li>
<pre><code class="language-scheme line-numbers">; (call-with-values producer consumer)
(call-with-values
  (lambda () (values 1 2 3))
  (lambda (a b c) (+ a b c)))  ; 6

(call-with-values
  (lambda () (quotient-remainder 17 5))
  (lambda (q r) (list 'quotient q 'remainder r)))
; (quotient 3 remainder 2)</code></pre>
        <br/>
        <li><code>let-values</code> and <code>let*-values</code> bind multiple values:</li>
<pre><code class="language-scheme line-numbers">; let-values: bind multiple value results
(let-values ([(q r) (quotient-remainder 17 5)])
  (printf "17 = 5 * ~a + ~a~n" q r))
; 17 = 5 * 3 + 2

; Multiple bindings
(let-values ([(a b) (values 1 2)]
             [(x y z) (values 10 20 30)])
  (list a b x y z))  ; (1 2 10 20 30)

; let*-values: sequential binding
(let*-values ([(a b) (values 1 2)]
              [(c) (+ a b)])
  c)  ; 3

; With regular bindings mixed
(let-values ([(x y) (values 1 2)]
             [(z) 3])
  (+ x y z))  ; 6</code></pre>
        <br/>
        <li><code>define-values</code> for top-level definitions:</li>
<pre><code class="language-scheme line-numbers">(define-values (min-val max-val)
  (values 0 100))

min-val  ; 0
max-val  ; 100

(define-values (head . tail)
  (values 1 2 3 4 5))

head  ; 1
tail  ; (2 3 4 5)</code></pre>
    </ul>
    <br/><br/>


    <li>Continuations</li>
    <br/>
    <ul>
        <li><code>call/cc</code> captures the current continuation:</li>
<pre><code class="language-scheme line-numbers">; call/cc = call-with-current-continuation

; Early exit from computation
(define (find-first pred lst)
  (call/cc
    (lambda (return)
      (for-each
        (lambda (x)
          (when (pred x)
            (return x)))
        lst)
      #f)))

(find-first even? '(1 3 5 4 7))  ; 4
(find-first even? '(1 3 5 7))    ; #f

; Product with early exit on zero
(define (product lst)
  (call/cc
    (lambda (return)
      (let loop ([lst lst] [acc 1])
        (cond
          [(null? lst) acc]
          [(zero? (car lst)) (return 0)]
          [else (loop (cdr lst) (* acc (car lst)))])))))</code></pre>
        <br/>
        <li>Continuations as first-class values:</li>
<pre><code class="language-scheme line-numbers">; Save and reuse continuations
(define saved-k #f)

(+ 1 (call/cc
       (lambda (k)
         (set! saved-k k)
         2)))  ; 3

(saved-k 10)   ; 11 (continues from where we left)
(saved-k 100)  ; 101

; Continuations can be called multiple times
(let ([times 0])
  (let ([result (call/cc (lambda (k)
                           (set! saved-k k)
                           'first))])
    (set! times (+ times 1))
    (if (< times 3)
        (saved-k (string->symbol
                   (format "attempt-~a" times)))
        result)))
; Returns attempt-2 after being called multiple times</code></pre>
        <br/>
        <li>Implementing exceptions with continuations:</li>
<pre><code class="language-scheme line-numbers">(define (with-exception-handler handler thunk)
  (call/cc
    (lambda (return)
      (let ([raise (lambda (exn) (return (handler exn)))])
        (thunk raise)))))

(with-exception-handler
  (lambda (exn) (list 'caught exn))
  (lambda (raise)
    (raise 'my-error)))
; (caught my-error)</code></pre>
    </ul>
    <br/><br/>


    <li>Dynamic Wind</li>
    <br/>
    <ul>
        <li><code>dynamic-wind</code> ensures cleanup with continuations:</li>
<pre><code class="language-scheme line-numbers">; (dynamic-wind before thunk after)
; before: called when entering
; thunk: the main body
; after: called when exiting (even via continuation)

(dynamic-wind
  (lambda () (display "entering\n"))
  (lambda () (display "in body\n") 'result)
  (lambda () (display "leaving\n")))
; entering
; in body
; leaving
; Returns: result</code></pre>
        <br/>
        <li>Resource management:</li>
<pre><code class="language-scheme line-numbers">(define (with-input-file filename proc)
  (let ([port #f])
    (dynamic-wind
      (lambda () (set! port (open-input-file filename)))
      (lambda () (proc port))
      (lambda () (close-input-port port)))))

(with-input-file "data.txt"
  (lambda (port)
    (read port)))

; Even if continuation jumps out, port is closed
(call/cc
  (lambda (escape)
    (with-input-file "data.txt"
      (lambda (port)
        (escape 'early-exit)))))
; Port still properly closed!</code></pre>
        <br/>
        <li>Tracking entry/exit:</li>
<pre><code class="language-scheme line-numbers">(define level 0)

(define (show-level label)
  (printf "~a: level = ~a~n" label level))

(define (with-level thunk)
  (dynamic-wind
    (lambda ()
      (set! level (+ level 1))
      (show-level "enter"))
    thunk
    (lambda ()
      (show-level "exit")
      (set! level (- level 1)))))

(with-level
  (lambda ()
    (with-level
      (lambda ()
        (display "innermost\n")))))
; enter: level = 1
; enter: level = 2
; innermost
; exit: level = 2
; exit: level = 1</code></pre>
    </ul>
    <br/><br/>


    <li>Delimited Continuations</li>
    <br/>
    <ul>
        <li>Chez Scheme provides delimited continuations via <code>call/1cc</code>:</li>
<pre><code class="language-scheme line-numbers">; call/1cc: one-shot continuation (more efficient)
; Can only be called once

(define (find-first-1cc pred lst)
  (call/1cc
    (lambda (return)
      (for-each
        (lambda (x)
          (when (pred x)
            (return x)))
        lst)
      #f)))

; Use call/1cc when you only need to escape once</code></pre>
        <br/>
        <li>Prompts and control with <code>call/cc</code>:</li>
<pre><code class="language-scheme line-numbers">; Simulating generators with continuations
(define (make-generator proc)
  (let ([resume #f]
        [yield-k #f])
    (lambda ()
      (call/cc
        (lambda (return)
          (if resume
              (resume 'continue)
              (proc (lambda (value)
                      (call/cc
                        (lambda (k)
                          (set! resume k)
                          (return value)))))))))))

(define counter
  (make-generator
    (lambda (yield)
      (let loop ([i 0])
        (yield i)
        (loop (+ i 1))))))

(counter)  ; 0
(counter)  ; 1
(counter)  ; 2</code></pre>
    </ul>
    <br/><br/>


    <li>Exception Handling</li>
    <br/>
    <ul>
        <li><code>guard</code> for structured exception handling:</li>
<pre><code class="language-scheme line-numbers">(guard (exn
        [(error? exn)
         (display "An error occurred: ")
         (display (condition-message exn))
         (newline)
         'error-result]
        [(assertion-violation? exn)
         'assertion-failed]
        [else
         (raise exn)])  ; Re-raise if not handled
  (risky-operation))

; Nested guard
(guard (outer
        [else (display "outer caught it\n")])
  (guard (inner
          [(warning? inner) (display "just a warning\n")])
    (error 'test "something bad")))</code></pre>
        <br/>
        <li><code>with-exception-handler</code> for low-level handling:</li>
<pre><code class="language-scheme line-numbers">; Handler receives exception, can return or re-raise
(with-exception-handler
  (lambda (exn)
    (display "Handler called\n")
    (raise exn))  ; Re-raise to outer handler
  (lambda ()
    (error 'test "oops")))

; Handling continuable exceptions
(with-exception-handler
  (lambda (exn)
    (when (warning? exn)
      (display "Warning noted\n"))
    'continue-value)  ; Return value for continuable
  (lambda ()
    (let ([result (raise-continuable (make-warning))])
      (display "Continued with: ")
      (display result)
      (newline))))</code></pre>
        <br/>
        <li>Chez-specific <code>parameterize</code> for exception handling:</li>
<pre><code class="language-scheme line-numbers">; Using parameters for global exception behavior
(parameterize ([current-exception-handler
                (lambda (exn)
                  (printf "Caught: ~a~n" exn)
                  (default-exception-handler exn))])
  (error 'test "demo"))</code></pre>
    </ul>
    <br/><br/>


    <li>Non-Local Exit Patterns</li>
    <br/>
    <ul>
        <li>Early return from nested loops:</li>
<pre><code class="language-scheme line-numbers">(define (find-in-matrix pred matrix)
  (call/cc
    (lambda (return)
      (for-each
        (lambda (row)
          (for-each
            (lambda (elem)
              (when (pred elem)
                (return elem)))
            row))
        matrix)
      #f)))

(find-in-matrix
  (lambda (x) (> x 10))
  '((1 2 3) (4 5 6) (7 8 15)))  ; 15</code></pre>
        <br/>
        <li>Break and continue in loops:</li>
<pre><code class="language-scheme line-numbers">; Simulating break
(define (process-until-done lst)
  (call/cc
    (lambda (break)
      (for-each
        (lambda (x)
          (if (eq? x 'stop)
              (break 'stopped)
              (process x)))
        lst)
      'completed)))

; Simulating continue
(define (process-skip-negatives lst)
  (for-each
    (lambda (x)
      (call/cc
        (lambda (continue)
          (when (< x 0)
            (continue #f))
          (process x))))
    lst))</code></pre>
        <br/>
        <li>Return multiple levels:</li>
<pre><code class="language-scheme line-numbers">(define (deep-search tree target)
  (call/cc
    (lambda (found)
      (let search ([tree tree])
        (cond
          [(null? tree) #f]
          [(equal? (car tree) target)
           (found #t)]
          [(pair? (car tree))
           (search (car tree))
           (search (cdr tree))]
          [else
           (search (cdr tree))]))
      #f)))

(deep-search '(a (b (c d)) (e (f target g))) 'target)  ; #t</code></pre>
    </ul>
    <br/><br/>


    <li>Trampolining and Tail Calls</li>
    <br/>
    <ul>
        <li>Scheme guarantees tail call optimization:</li>
<pre><code class="language-scheme line-numbers">; This won't overflow the stack
(define (count-to n)
  (let loop ([i 0])
    (if (= i n)
        'done
        (loop (+ i 1)))))

(count-to 10000000)  ; Works fine!

; Tail recursive factorial
(define (factorial n)
  (let loop ([n n] [acc 1])
    (if (zero? n)
        acc
        (loop (- n 1) (* acc n)))))

; NOT tail recursive (multiplication after recursive call)
(define (factorial-bad n)
  (if (zero? n)
      1
      (* n (factorial-bad (- n 1)))))  ; Will overflow</code></pre>
        <br/>
        <li>Mutual recursion with tail calls:</li>
<pre><code class="language-scheme line-numbers">(define (even? n)
  (if (zero? n)
      #t
      (odd? (- n 1))))

(define (odd? n)
  (if (zero? n)
      #f
      (even? (- n 1))))

(even? 1000000)  ; #t, no stack overflow</code></pre>
        <br/>
        <li>Converting non-tail to tail recursive:</li>
<pre><code class="language-scheme line-numbers">; Non-tail recursive (builds up stack)
(define (sum-list lst)
  (if (null? lst)
      0
      (+ (car lst) (sum-list (cdr lst)))))

; Tail recursive with accumulator
(define (sum-list-tr lst)
  (let loop ([lst lst] [acc 0])
    (if (null? lst)
        acc
        (loop (cdr lst) (+ acc (car lst))))))

; CPS transformation for complex cases
(define (fib-cps n k)
  (if (< n 2)
      (k n)
      (fib-cps (- n 1)
               (lambda (a)
                 (fib-cps (- n 2)
                          (lambda (b)
                            (k (+ a b))))))))</code></pre>
    </ul>
    <br/><br/>


    <li>Fluid Bindings (Parameters)</li>
    <br/>
    <ul>
        <li>Parameters provide dynamic scoping:</li>
<pre><code class="language-scheme line-numbers">; Create a parameter
(define current-user (make-parameter "guest"))

(current-user)           ; "guest"

; Set temporarily with parameterize
(parameterize ([current-user "admin"])
  (display (current-user)))  ; "admin"

(current-user)           ; "guest" (restored)

; Nested parameterize
(parameterize ([current-user "alice"])
  (display (current-user))   ; alice
  (newline)
  (parameterize ([current-user "bob"])
    (display (current-user)) ; bob
    (newline))
  (display (current-user)))  ; alice</code></pre>
        <br/>
        <li>Parameters with validation:</li>
<pre><code class="language-scheme line-numbers">; Parameter with guard procedure
(define current-level
  (make-parameter 0
    (lambda (v)
      (unless (and (integer? v) (>= v 0))
        (error 'current-level "must be non-negative integer" v))
      v)))

(current-level 5)        ; OK
(current-level -1)       ; Error!</code></pre>
        <br/>
        <li>Common built-in parameters:</li>
<pre><code class="language-scheme line-numbers">; I/O parameters
(parameterize ([current-output-port (open-output-string)])
  (display "captured")
  (get-output-string (current-output-port)))

; Compilation parameters
(parameterize ([optimize-level 3]
               [debug-level 0])
  (compile-file "fast.ss"))

; Print parameters
(parameterize ([print-length 10]
               [print-level 5])
  (pretty-print deeply-nested-structure))</code></pre>
    </ul>
    <br/><br/>


    <li>Control Flow Summary</li>
    <br/>
    <ul>
        <li>Quick reference:</li>
<table>
    <thead>
        <tr>
            <th>Construct</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>if</code></td>
            <td>Simple two-way branch</td>
        </tr>
        <tr>
            <td><code>cond</code></td>
            <td>Multiple conditions</td>
        </tr>
        <tr>
            <td><code>case</code></td>
            <td>Match against literal values</td>
        </tr>
        <tr>
            <td><code>when/unless</code></td>
            <td>One-sided conditional with body</td>
        </tr>
        <tr>
            <td><code>and/or</code></td>
            <td>Short-circuit boolean logic</td>
        </tr>
        <tr>
            <td><code>begin</code></td>
            <td>Sequence expressions</td>
        </tr>
        <tr>
            <td>Named <code>let</code></td>
            <td>General iteration/recursion</td>
        </tr>
        <tr>
            <td><code>do</code></td>
            <td>Traditional loop with step</td>
        </tr>
        <tr>
            <td><code>for-each</code></td>
            <td>Iterate for side effects</td>
        </tr>
        <tr>
            <td><code>map</code></td>
            <td>Transform lists</td>
        </tr>
        <tr>
            <td><code>fold-left/right</code></td>
            <td>Accumulate over lists</td>
        </tr>
        <tr>
            <td><code>values</code></td>
            <td>Return multiple values</td>
        </tr>
        <tr>
            <td><code>let-values</code></td>
            <td>Bind multiple values</td>
        </tr>
        <tr>
            <td><code>call/cc</code></td>
            <td>Capture continuation</td>
        </tr>
        <tr>
            <td><code>dynamic-wind</code></td>
            <td>Ensure cleanup with continuations</td>
        </tr>
        <tr>
            <td><code>guard</code></td>
            <td>Exception handling</td>
        </tr>
        <tr>
            <td><code>parameterize</code></td>
            <td>Dynamic/fluid bindings</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-debugging">Chez Scheme Debugging</h3>
<ol>

    <li>Print Debugging with printf</li>
    <br/>
    <ul>
        <li>The simplest debugging technique — insert print statements:</li>
<pre><code class="language-scheme line-numbers">; printf works like C's printf but uses ~ instead of %
(define (factorial n)
  (printf "factorial called with n = ~a~n" n)
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

(factorial 5)
; factorial called with n = 5
; factorial called with n = 4
; factorial called with n = 3
; factorial called with n = 2
; factorial called with n = 1
; factorial called with n = 0
; 120</code></pre>
        <br/>
        <li>Common format directives:</li>
<table>
    <thead>
        <tr>
            <th>Directive</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>~a</code></td>
            <td>Display (human-readable, no quotes on strings)</td>
        </tr>
        <tr>
            <td><code>~s</code></td>
            <td>Write (machine-readable, quotes on strings)</td>
        </tr>
        <tr>
            <td><code>~d</code></td>
            <td>Decimal integer</td>
        </tr>
        <tr>
            <td><code>~b</code></td>
            <td>Binary integer</td>
        </tr>
        <tr>
            <td><code>~x</code></td>
            <td>Hexadecimal integer</td>
        </tr>
        <tr>
            <td><code>~n</code> or <code>~%</code></td>
            <td>Newline</td>
        </tr>
        <tr>
            <td><code>~~</code></td>
            <td>Literal tilde</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Examples:</li>
<pre><code class="language-scheme line-numbers">(printf "~a~n" "hello")       ; hello
(printf "~s~n" "hello")       ; "hello"
(printf "~d in binary is ~b~n" 42 42)  ; 42 in binary is 101010
(printf "hex: ~x~n" 255)      ; hex: ff

; Multiple values
(printf "x=~a, y=~a, sum=~a~n" 3 4 (+ 3 4))
; x=3, y=4, sum=7</code></pre>
        <br/>
        <li>Using <code>format</code> to create strings:</li>
<pre><code class="language-scheme line-numbers">; format returns a string instead of printing
(define msg (format "Value is ~a" 42))
msg  ; "Value is 42"

; Useful for logging
(define (log level msg . args)
  (printf "[~a] ~a~n" level (apply format msg args)))

(log 'INFO "Processing item ~a of ~a" 5 10)
; [INFO] Processing item 5 of 10</code></pre>
    </ul>
    <br/><br/>


    <li>Tracing Procedures</li>
    <br/>
    <ul>
        <li><code>trace</code> shows procedure calls and return values:</li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

; Enable tracing
(trace factorial)  ; (factorial)

(factorial 5)
; |(factorial 5)
; | (factorial 4)
; | |(factorial 3)
; | | (factorial 2)
; | | |(factorial 1)
; | | | (factorial 0)
; | | | 1
; | | |1
; | | 2
; | |6
; | 24
; |120
; 120

; Disable tracing
(untrace factorial)</code></pre>
        <br/>
        <li>Trace multiple procedures including built-ins:</li>
<pre><code class="language-scheme line-numbers">(trace factorial * -)  ; (factorial * -)

(factorial 3)
; |(factorial 3)
; | (factorial 2)
; | |(factorial 1)
; | | (factorial 0)
; | | 1
; | |(* 1 1)
; | |1
; | (* 2 1)
; | 2
; |(* 3 2)
; |6
; 6

; Untrace specific procedures
(untrace *)            ; (-)

; Untrace all
(untrace)              ; (factorial -)</code></pre>
        <br/>
        <li>Check what's being traced:</li>
<pre><code class="language-scheme line-numbers">(trace)  ; Returns list of currently traced procedures</code></pre>
        <br/>
        <li><code>trace-define</code> for inline tracing:</li>
<pre><code class="language-scheme line-numbers">; Automatically traced when defined
(trace-define (sum-list lst)
  (if (null? lst)
      0
      (+ (car lst) (sum-list (cdr lst)))))

(sum-list '(1 2 3))
; |(sum-list (1 2 3))
; | (sum-list (2 3))
; | |(sum-list (3))
; | | (sum-list ())
; | | 0
; | |3
; | 5
; |6
; 6</code></pre>
        <br/>
        <li><code>trace-lambda</code> for anonymous procedures:</li>
<pre><code class="language-scheme line-numbers">(define factorial
  (trace-lambda fact (n)
    (if (zero? n)
        1
        (* n (fact (- n 1))))))

(factorial 4)
; |(fact 4)
; | (fact 3)
; | |(fact 2)
; | | (fact 1)
; | | |(fact 0)
; | | |1
; | | 1
; | |2
; | 6
; |24
; 24</code></pre>
        <br/>
        <li><code>trace-define-syntax</code> for macros:</li>
<pre><code class="language-scheme line-numbers">(trace-define-syntax my-or
  (syntax-rules ()
    [(_) #f]
    [(_ e) e]
    [(_ e1 e2 ...) (let ([t e1]) (if t t (my-or e2 ...)))]))

(my-or #f #f 'found)
; |(my-or (my-or #f #f 'found))
; |(let ((t #f)) (if t t (my-or #f 'found)))
; found</code></pre>
    </ul>
    <br/><br/>


    <li>The Debugger</li>
    <br/>
    <ul>
        <li>When an error occurs, Chez Scheme suggests entering the debugger:</li>
<pre><code class="language-scheme line-numbers">> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.
></code></pre>
        <br/>
        <li>Enter the debugger with <code>(debug)</code>:</li>
<pre><code class="language-scheme line-numbers">> (debug)
debug></code></pre>
        <br/>
        <li>Debugger commands (type <code&gt;?</code> to see):</li>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code&gt;?</code></td>
            <td>Show available commands</td>
        </tr>
        <tr>
            <td><code>i</code></td>
            <td>Inspect the raise continuation</td>
        </tr>
        <tr>
            <td><code>c</code></td>
            <td>Inspect the condition</td>
        </tr>
        <tr>
            <td><code>s</code></td>
            <td>Display the condition</td>
        </tr>
        <tr>
            <td><code>e</code></td>
            <td>Exit debugger, retain error continuation</td>
        </tr>
        <tr>
            <td><code>r</code></td>
            <td>Reset to REPL</td>
        </tr>
        <tr>
            <td><code>a</code></td>
            <td>Abort Scheme entirely</td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>Enter a new café</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Typical debugging session:</li>
<pre><code class="language-scheme line-numbers">> (define (my-reverse lst)
    (if (null? lst)
        '()
        (append (my-reverse (cdr lst)) (car lst))))

> (my-reverse '(1 2 3))
Exception in append: 1 is not a proper list
Type (debug) to enter the debugger.

> (debug)
debug> i                    ; Inspect continuation
#<continuation in append> :
debug> sf                   ; Show stack frames</code></pre>
    </ul>
    <br/><br/>


    <li>The Inspector</li>
    <br/>
    <ul>
        <li>After typing <code>i</code> in the debugger, you enter the inspector:</li>
<pre><code class="language-scheme line-numbers">debug> i
#<continuation in my-reverse> :</code></pre>
        <br/>
        <li>Inspector commands for continuations:</li>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code&gt;?</code></td>
            <td>Show commands for current object type</td>
        </tr>
        <tr>
            <td><code&gt;??</code></td>
            <td>Show navigation commands</td>
        </tr>
        <tr>
            <td><code>s</code> or <code>show</code></td>
            <td>Show code and free variables</td>
        </tr>
        <tr>
            <td><code>sf</code></td>
            <td>Show stack frames</td>
        </tr>
        <tr>
            <td><code>d</code> or <code>down</code></td>
            <td>Move down to next frame</td>
        </tr>
        <tr>
            <td><code>u</code> or <code>up</code></td>
            <td>Move up to previous frame</td>
        </tr>
        <tr>
            <td><code>r N</code> or <code>ref N</code></td>
            <td>Inspect Nth free variable</td>
        </tr>
        <tr>
            <td><code>code</code> or <code>c</code></td>
            <td>Inspect the procedure code</td>
        </tr>
        <tr>
            <td><code>call</code></td>
            <td>Inspect the pending call</td>
        </tr>
        <tr>
            <td><code>q</code> or <code>quit</code></td>
            <td>Exit inspector</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Inspecting stack frames:</li>
<pre><code class="language-scheme line-numbers">#<continuation in my-reverse> : sf
0: #<continuation in my-reverse>
1: #<continuation in my-reverse>
2: #<continuation in my-reverse>
3: #<continuation in my-reverse>
4: #<system continuation>

#<continuation in my-reverse> : s
continuation: #<continuation in my-reverse>
procedure code: (lambda (lst) (if (null? lst) ... ...))
call code: (append (my-reverse (cdr lst)) (car lst))
free variables:
  0. lst: (1)

#<continuation in my-reverse> : d    ; Move to next frame
#<continuation in my-reverse> : s
free variables:
  0. lst: (2 1)

#<continuation in my-reverse> : r 0  ; Inspect lst
(2 1) :</code></pre>
        <br/>
        <li>Directly inspect any object with <code>inspect</code>:</li>
<pre><code class="language-scheme line-numbers">> (define (square x) (* x x))
> (inspect square)
#<procedure square> : ?
  show(s) .......... show code and free variables
  code(c) .......... inspect the code for the procedure
  ref(r) ........... inspect [nth] free variable
  length(l) ........ display number of free variables

#<procedure square> : c
(lambda (x) (* x x)) :

#<procedure square> : quit
></code></pre>
        <br/>
        <li>Inspector commands for different object types:</li>
<pre><code class="language-scheme line-numbers">; Lists
> (inspect '(1 2 3))
(1 2 3) : ?
  car .............. inspect car of pair
  cdr .............. inspect cdr of pair
  ref(r) ........... inspect [nth] car
  tail ............. inspect [nth] cdr
  show(s) .......... show [n] elements
  length(l) ........ display list length

(1 2 3) : car
1 :

; Vectors
> (inspect #(a b c))
#(a b c) : ref 1
b :</code></pre>
    </ul>
    <br/><br/>


    <li>Breakpoints</li>
    <br/>
    <ul>
        <li>Insert <code>(break)</code> to pause execution:</li>
<pre><code class="language-scheme line-numbers">(define (process-items items)
  (for-each
    (lambda (item)
      (break)              ; Pause here
      (display item)
      (newline))
    items))

> (process-items '(a b c))
break>                     ; Execution paused</code></pre>
        <br/>
        <li>Break handler commands:</li>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code&gt;?</code></td>
            <td>Show options</td>
        </tr>
        <tr>
            <td><code>e</code></td>
            <td>Exit break and continue execution</td>
        </tr>
        <tr>
            <td><code>i</code></td>
            <td>Inspect current continuation</td>
        </tr>
        <tr>
            <td><code>r</code></td>
            <td>Reset to REPL</td>
        </tr>
        <tr>
            <td><code>a</code></td>
            <td>Abort Scheme</td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>Enter new café</td>
        </tr>
        <tr>
            <td><code>s</code></td>
            <td>Display statistics</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Break with a message:</li>
<pre><code class="language-scheme line-numbers">(define (compute x y)
  (let ([sum (+ x y)]
        [product (* x y)])
    (break 'compute "checking values")
    (list sum product)))

> (compute 3 4)
break in compute: "checking values"
break> i
#<continuation in compute> : s
free variables:
  0. product: 12
  1. sum: 7
  2. y: 4
  3. x: 3
#<continuation in compute> : q
break> e              ; Continue execution
(7 12)</code></pre>
        <br/>
        <li>Conditional breakpoints:</li>
<pre><code class="language-scheme line-numbers">(define (process n)
  (when (> n 100)        ; Only break on large values
    (break 'process "n is large"))
  (* n 2))

; Or using a helper
(define-syntax break-when
  (syntax-rules ()
    [(_ condition msg)
     (when condition (break 'break-when msg))]))

(define (search lst target)
  (break-when (> (length lst) 1000) "large list")
  (member target lst))</code></pre>
    </ul>
    <br/><br/>


    <li>Interrupting Infinite Loops</li>
    <br/>
    <ul>
        <li>Press <code>Ctrl-C</code> to interrupt a running computation:</li>
<pre><code class="language-scheme line-numbers">(define (infinite-loop)
  (infinite-loop))

> (infinite-loop)
^C                         ; Press Ctrl-C
break>                     ; Enters break handler</code></pre>
        <br/>
        <li>From the break handler, inspect where you are:</li>
<pre><code class="language-scheme line-numbers">break> i                   ; Inspect continuation
#<continuation in infinite-loop> : sf
0: #<continuation in infinite-loop>
1: #<continuation in infinite-loop>
2: #<continuation in infinite-loop>
... many frames ...

#<continuation in infinite-loop> : s
procedure code: (lambda () (infinite-loop))
call code: (infinite-loop)

break> r                   ; Reset to REPL
></code></pre>
        <br/>
        <li>Finding where a loop is stuck:</li>
<pre><code class="language-scheme line-numbers">(define (buggy-find x lst)
  (cond
    [(null? lst) #f]
    [(equal? x (car lst)) #t]
    [else (buggy-find x lst)]))  ; Bug: should be (cdr lst)

> (buggy-find 'z '(a b c))
^C
break> i
#<continuation in buggy-find> : s
free variables:
  0. lst: (a b c)         ; lst never changes!
  1. x: z</code></pre>
    </ul>
    <br/><br/>


    <li>Debug Parameters</li>
    <br/>
    <ul>
        <li><code>debug-on-exception</code> — enter debugger automatically:</li>
<pre><code class="language-scheme line-numbers">; Enable automatic debugging
(debug-on-exception #t)

> (car 5)
Exception in car: 5 is not a pair
debug>                     ; Directly in debugger, no need for (debug)

; From command line
$ scheme --debug-on-exception --script buggy.ss</code></pre>
        <br/>
        <li><code>debug-level</code> — control debug information (0-3):</li>
<pre><code class="language-scheme line-numbers">; Higher levels retain more debug info
(debug-level 3)            ; Maximum debug info (default)
(debug-level 0)            ; Minimal debug info (faster)

; Check current level
(debug-level)              ; Returns current level</code></pre>
        <br/>
        <li><code>generate-inspector-information</code> — control what's saved:</li>
<pre><code class="language-scheme line-numbers">; Disable for production (smaller, faster code)
(parameterize ([generate-inspector-information #f])
  (compile-file "production.ss"))

; Enable for development (better debugging)
(parameterize ([generate-inspector-information #t])
  (compile-file "development.ss"))</code></pre>
        <br/>
        <li><code>debug-condition</code> — access the last exception:</li>
<pre><code class="language-scheme line-numbers">> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.

> (debug-condition)
#<condition &assertion>

> (condition-message (debug-condition))
"~s is not a pair"

> (condition-irritants (debug-condition))
(5)</code></pre>
    </ul>
    <br/><br/>


    <li>Pretty Printing</li>
    <br/>
    <ul>
        <li><code>pretty-print</code> for readable output:</li>
<pre><code class="language-scheme line-numbers">(define complex-data
  '((name . "Alice")
    (scores . (90 85 92 88))
    (address . ((street . "123 Main")
                (city . "Boston")))))

> (write complex-data)
((name . "Alice") (scores 90 85 92 88) (address (street . "123 Main") (city . "Boston")))

> (pretty-print complex-data)
((name . "Alice")
 (scores 90 85 92 88)
 (address
   (street . "123 Main")
   (city . "Boston")))</code></pre>
        <br/>
        <li>Control pretty-print behavior:</li>
<pre><code class="language-scheme line-numbers">; Limit depth
(parameterize ([print-level 2])
  (pretty-print '(a (b (c (d (e)))))))
; (a (b (#1=#2#)))

; Limit length
(parameterize ([print-length 3])
  (pretty-print '(1 2 3 4 5 6 7 8 9 10)))
; (1 2 3 ...)

; Both limits
(parameterize ([print-level 2]
               [print-length 5])
  (pretty-print deeply-nested-list))</code></pre>
        <br/>
        <li><code>pretty-format</code> returns a string:</li>
<pre><code class="language-scheme line-numbers">(define formatted (pretty-format '(define (f x) (+ x 1))))
; Returns formatted string instead of printing</code></pre>
    </ul>
    <br/><br/>


    <li>Assertions and Contracts</li>
    <br/>
    <ul>
        <li><code>assert</code> for runtime checks:</li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (assert (and (integer? n) (>= n 0)))
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

> (factorial -1)
Exception: failed assertion (and (integer? n) (>= n 0))
Type (debug) to enter the debugger.

> (factorial 5)
120</code></pre>
        <br/>
        <li>Custom assertions with better messages:</li>
<pre><code class="language-scheme line-numbers">(define-syntax assert-type
  (syntax-rules ()
    [(_ pred val msg)
     (unless (pred val)
       (assertion-violation 'assert-type msg val))]))

(define (process-list lst)
  (assert-type list? lst "expected a list")
  (map add1 lst))

> (process-list 5)
Exception in assert-type: expected a list
  irritants: 5</code></pre>
        <br/>
        <li>Design-by-contract style:</li>
<pre><code class="language-scheme line-numbers">(define (divide x y)
  ; Preconditions
  (assert (number? x))
  (assert (number? y))
  (assert (not (zero? y)))

  (let ([result (/ x y)])
    ; Postcondition
    (assert (number? result))
    result))</code></pre>
    </ul>
    <br/><br/>


    <li>Timing and Profiling</li>
    <br/>
    <ul>
        <li><code>time</code> measures execution:</li>
<pre><code class="language-scheme line-numbers">> (time (factorial 10000))
(time (factorial 10000))
    no collections
    0.023756917s elapsed cpu time
    0.023821000s elapsed real time
    134696 bytes allocated
#<very large number...></code></pre>
        <br/>
        <li><code>statistics</code> for detailed info:</li>
<pre><code class="language-scheme line-numbers">> (statistics)
    0 collections
    no time in collector
    0.156250000s elapsed cpu time
    1.234567000s elapsed real time
    1234567 bytes allocated</code></pre>
        <br/>
        <li>Manual timing:</li>
<pre><code class="language-scheme line-numbers">(define (time-it thunk)
  (let ([start (current-time)])
    (let ([result (thunk)])
      (let ([end (current-time)])
        (printf "Elapsed: ~a seconds~n"
                (- (time-second end) (time-second start)))
        result))))

(time-it (lambda () (factorial 50000)))</code></pre>
        <br/>
        <li>Profile with <code>profile</code> (Chez-specific):</li>
<pre><code class="language-scheme line-numbers">; Enable profiling
(compile-profile #t)

; Compile with profiling
(compile-file "mycode.ss")

; Run code
(load "mycode.so")
(my-function test-data)

; Show profile
(profile-dump-html "profile.html")</code></pre>
    </ul>
    <br/><br/>


    <li>Café System</li>
    <br/>
    <ul>
        <li>Chez Scheme uses "cafés" as nested REPL levels:</li>
<pre><code class="language-scheme line-numbers">; One angle bracket = level 1
>

; Enter a new café
> (new-cafe)
>>                         ; Two brackets = level 2

; Exit back to level 1
>> (exit)
></code></pre>
        <br/>
        <li>Each café has its own reset and exit:</li>
<pre><code class="language-scheme line-numbers">> (new-cafe)
>> (new-cafe)
>>>                        ; Level 3

>>> (reset)                ; Reset level 3
>>>

>>> (exit)                 ; Exit to level 2
>>

>> (exit)                  ; Exit to level 1
></code></pre>
        <br/>
        <li>From break/debug, <code>n</code> enters a new café for testing:</li>
<pre><code class="language-scheme line-numbers">> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.

> (debug)
debug> n                   ; New café
>>                         ; Can test things here
>> (+ 1 2)
3
>> (exit)                  ; Return to debug
debug> r                   ; Reset to main REPL
></code></pre>
    </ul>
    <br/><br/>


    <li>Common Debugging Patterns</li>
    <br/>
    <ul>
        <li>Debug wrapper for procedures:</li>
<pre><code class="language-scheme line-numbers">(define (debug-wrap name proc)
  (lambda args
    (printf "ENTER ~a: ~s~n" name args)
    (let ([result (apply proc args)])
      (printf "EXIT ~a: ~s~n" name result)
      result)))

(define my-add (debug-wrap 'add +))
> (my-add 1 2 3)
ENTER add: (1 2 3)
EXIT add: 6
6</code></pre>
        <br/>
        <li>Conditional debug output:</li>
<pre><code class="language-scheme line-numbers">(define *debug* (make-parameter #f))

(define-syntax debug-print
  (syntax-rules ()
    [(_ fmt args ...)
     (when (*debug*)
       (printf fmt args ...))]))

(define (my-function x)
  (debug-print "Processing ~a~n" x)
  (* x 2))

; Enable debugging
(parameterize ([*debug* #t])
  (my-function 5))
; Processing 5
; 10

; Disable debugging
(my-function 5)
; 10</code></pre>
        <br/>
        <li>Safe evaluation for testing:</li>
<pre><code class="language-scheme line-numbers">(define (safe-eval expr)
  (guard (ex
          [else
           (printf "Error: ~a~n" (condition-message ex))
           #f])
    (eval expr)))

> (safe-eval '(+ 1 2))
3
> (safe-eval '(car 5))
Error: ~s is not a pair
#f</code></pre>
        <br/>
        <li>Step-by-step execution helper:</li>
<pre><code class="language-scheme line-numbers">(define-syntax step
  (syntax-rules ()
    [(_ label expr)
     (begin
       (printf "~a: ~s~n" label 'expr)
       (let ([result expr])
         (printf "  => ~s~n" result)
         result))]))

(define (calculate x)
  (step "square" (* x x))
  (step "add-one" (+ (* x x) 1))
  (step "final" (sqrt (+ (* x x) 1))))

> (calculate 3)
square: (* x x)
  => 9
add-one: (+ (* x x) 1)
  => 10
final: (sqrt (+ (* x x) 1))
  => 3.1622776601683795
3.1622776601683795</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-foreign-interface">Foreign Interface in Chez Scheme</h3>
<ol>

    <li>Subprocess Communication</li>
    <br/>
    <ul>
        <li>Chez Scheme provides two ways to interact with external code: <u>subprocess communication</u> and <u>direct foreign procedure calls</u>.</li>
        <br/>
        <li><code>system</code> runs a shell command and waits for completion:</li>
<pre><code class="language-scheme line-numbers">; Run a command, wait for it to finish
(system "ls -la")           ; Returns exit code

; Capture exit status
(let ([status (system "gcc -o myprogram myprogram.c")])
  (if (zero? status)
      (display "Compilation succeeded\n")
      (printf "Compilation failed with code ~a~n" status)))

; On Unix, negative return means signal termination
(system "sleep 100")        ; If killed by SIGTERM, returns -15</code></pre>
        <br/>
        <li><code>open-process-ports</code> creates a subprocess with bidirectional communication:</li>
<pre><code class="language-scheme line-numbers">; Returns 4 values: to-stdin, from-stdout, from-stderr, process-id
(define-values (to-stdin from-stdout from-stderr pid)
  (open-process-ports "cat" 'block (native-transcoder)))

; Write to subprocess
(display "Hello, subprocess!\n" to-stdin)
(flush-output-port to-stdin)

; Read from subprocess
(get-line from-stdout)      ; "Hello, subprocess!"

; Close ports when done
(close-port to-stdin)
(close-port from-stdout)
(close-port from-stderr)</code></pre>
        <br/>
        <li><code>process</code> is a simpler variant returning a list:</li>
<pre><code class="language-scheme line-numbers">; Returns (from-stdout to-stdin process-id)
(define proc (process "bc -l"))
(define from-stdout (car proc))
(define to-stdin (cadr proc))
(define pid (caddr proc))

; Interact with bc calculator
(display "2 + 3\n" to-stdin)
(flush-output-port to-stdin)
(get-line from-stdout)      ; "5"

(display "scale=10; 1/3\n" to-stdin)
(flush-output-port to-stdin)
(get-line from-stdout)      ; ".3333333333"</code></pre>
        <br/>
        <li>Using <code>exec</code> prefix for direct execution:</li>
<pre><code class="language-scheme line-numbers">; "exec" causes shell to replace itself with the command
; This reduces subprocess count and gives correct PID
(define-values (in out err pid)
  (open-process-ports "exec python3" 'line (native-transcoder)))</code></pre>
    </ul>
    <br/><br/>


    <li>Calling Out of Scheme</li>
    <br/>
    <ul>
        <li><code>foreign-procedure</code> creates a Scheme wrapper for a C function:</li>
<pre><code class="language-scheme line-numbers">; Syntax: (foreign-procedure name (param-types ...) return-type)

; First, load the shared library
(load-shared-object "libc.so.6")  ; Linux
; (load-shared-object "libc.dylib")  ; macOS

; Create wrapper for strlen
(define c-strlen
  (foreign-procedure "strlen" (string) size_t))

(c-strlen "hello")          ; 5

; Create wrapper for getenv
(define c-getenv
  (foreign-procedure "getenv" (string) string))

(c-getenv "HOME")           ; "/home/username"
(c-getenv "NONEXISTENT")    ; #f (null pointer becomes #f)</code></pre>
        <br/>
        <li>Common parameter and return types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>int</code>, <code>unsigned</code></td>
            <td>C int types</td>
        </tr>
        <tr>
            <td><code>integer-8</code>, <code>integer-16</code>, <code>integer-32</code>, <code>integer-64</code></td>
            <td>Fixed-size signed integers</td>
        </tr>
        <tr>
            <td><code>unsigned-8</code>, <code>unsigned-16</code>, <code>unsigned-32</code>, <code>unsigned-64</code></td>
            <td>Fixed-size unsigned integers</td>
        </tr>
        <tr>
            <td><code>double-float</code>, <code>single-float</code></td>
            <td>Floating-point types</td>
        </tr>
        <tr>
            <td><code>boolean</code></td>
            <td>#f ↔ 0, others ↔ 1</td>
        </tr>
        <tr>
            <td><code>char</code>, <code>wchar_t</code></td>
            <td>Character types</td>
        </tr>
        <tr>
            <td><code>string</code>, <code>wstring</code></td>
            <td>Null-terminated strings (UTF-8/wide)</td>
        </tr>
        <tr>
            <td><code>u8*</code>, <code>u16*</code>, <code>u32*</code></td>
            <td>Bytevector pointers</td>
        </tr>
        <tr>
            <td><code>void*</code>, <code>uptr</code>, <code>iptr</code></td>
            <td>Pointer/address types</td>
        </tr>
        <tr>
            <td><code>scheme-object</code>, <code>ptr</code></td>
            <td>Raw Scheme object (use carefully)</td>
        </tr>
        <tr>
            <td><code>void</code></td>
            <td>No return value</td>
        </tr>
        <tr>
            <td><code>(* ftype)</code></td>
            <td>Pointer to foreign type</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>More examples:</li>
<pre><code class="language-scheme line-numbers">; Math functions
(define c-sin (foreign-procedure "sin" (double) double))
(define c-cos (foreign-procedure "cos" (double) double))
(define c-sqrt (foreign-procedure "sqrt" (double) double))

(c-sin 0.0)                 ; 0.0
(c-sqrt 2.0)                ; 1.4142135623730951

; Memory functions
(define c-malloc (foreign-procedure "malloc" (size_t) void*))
(define c-free (foreign-procedure "free" (void*) void))
(define c-memcpy (foreign-procedure "memcpy" (void* void* size_t) void*))

; System functions
(define c-getpid (foreign-procedure "getpid" () int))
(c-getpid)                  ; Current process ID</code></pre>
        <br/>
        <li>Creating procedure templates:</li>
<pre><code class="language-scheme line-numbers">; Template for double -> double functions
(define (make-math-proc name)
  (foreign-procedure name (double) double))

(define sin (make-math-proc "sin"))
(define cos (make-math-proc "cos"))
(define tan (make-math-proc "tan"))
(define log (make-math-proc "log"))
(define exp (make-math-proc "exp"))</code></pre>
        <br/>
        <li>Checking if an entry exists:</li>
<pre><code class="language-scheme line-numbers">(foreign-entry? "strlen")   ; #t if available
(foreign-entry? "nonexistent_function")  ; #f

; Get address of entry
(foreign-entry "strlen")    ; Address as exact integer</code></pre>
    </ul>
    <br/><br/>


    <li>Calling Into Scheme</li>
    <br/>
    <ul>
        <li><code>foreign-callable</code> creates a C-callable wrapper for a Scheme procedure:</li>
<pre><code class="language-scheme line-numbers">; Syntax: (foreign-callable proc (param-types ...) return-type)

; Create callable wrapper
(define scheme-callback
  (foreign-callable
    (lambda (x y)
      (printf "Scheme received: ~a, ~a~n" x y)
      (+ x y))
    (int int)
    int))

; Lock the code object (prevents garbage collection)
(lock-object scheme-callback)

; Get the entry point address for C code
(define callback-addr
  (foreign-callable-entry-point scheme-callback))</code></pre>
        <br/>
        <li>Example: Registering a callback with C code:</li>
<pre><code class="language-scheme line-numbers">; Assume C code with:
; typedef void (*Callback)(char);
; void register_callback(char c, Callback cb);
; void trigger_callbacks(void);

(define register-callback
  (foreign-procedure "register_callback" (char void*) void))

(define trigger-callbacks
  (foreign-procedure "trigger_callbacks" () void))

; Create and register callbacks
(define (make-callback proc)
  (let ([code (foreign-callable proc (char) void)])
    (lock-object code)
    (foreign-callable-entry-point code)))

(define on-a-pressed
  (make-callback
    (lambda (c) (printf "Key 'a' pressed!~n"))))

(define on-b-pressed
  (make-callback
    (lambda (c) (printf "Key 'b' pressed!~n"))))

(register-callback #\a on-a-pressed)
(register-callback #\b on-b-pressed)</code></pre>
        <br/>
        <li>Unlocking when no longer needed:</li>
<pre><code class="language-scheme line-numbers">; Convert address back to code object and unlock
(define (free-callback addr)
  (unlock-object
    (foreign-callable-code-object addr)))

; When done with callback
(free-callback on-a-pressed)</code></pre>
        <br/>
        <li>Using ftypes for callbacks:</li>
<pre><code class="language-scheme line-numbers">; Define function type
(define-ftype callback-t (function (int int) int))

; Create ftype pointer from Scheme procedure
(define adder-fptr
  (make-ftype-pointer callback-t
    (lambda (x y) (+ x y))))

; Get address (code is auto-locked)
(ftype-pointer-address adder-fptr)

; Unlock when done
(unlock-object
  (foreign-callable-code-object
    (ftype-pointer-address adder-fptr)))</code></pre>
    </ul>
    <br/><br/>


    <li>Continuations and Foreign Calls</li>
    <br/>
    <ul>
        <li>Chez Scheme allows arbitrary nesting of Scheme and C calls, but continuations require care.</li>
        <br/>
        <li>A foreign context becomes "stale" after returning through it:</li>
<pre><code class="language-scheme line-numbers">; Scheme calls C calls Scheme calls C...
; Each C frame creates a "foreign context"

; Safe: Non-local exits (throw upward)
(call/cc
  (lambda (escape)
    (c-function-that-calls-scheme
      (lambda ()
        (escape 'early-exit)))))  ; OK: jumps out

; Dangerous: Returning to stale context
(define saved-k #f)
(c-function-that-calls-scheme
  (lambda ()
    (call/cc (lambda (k) (set! saved-k k)))))
; Later...
(saved-k 'value)  ; BAD: C context is stale!</code></pre>
        <br/>
        <li>Resetting C stack with continuations:</li>
<pre><code class="language-scheme line-numbers">; Helper to reset C stack on continuation invocation
(define (with-exit-proc p)
  (define th (lambda () (call/cc p)))
  (define-ftype ->ptr (function () ptr))
  (let ([fptr (make-ftype-pointer ->ptr th)])
    (let ([v ((ftype-ref ->ptr () fptr))])
      (unlock-object
        (foreign-callable-code-object
          (ftype-pointer-address fptr)))
      v)))

; Usage: like call/cc but resets C stack
(with-exit-proc
  (lambda (exit)
    (process-items
      (lambda (item)
        (when (error-item? item)
          (exit 'error))))
    'success))</code></pre>
        <br/>
        <li>General rules:</li>
        <ul>
            <li>Non-local exits (escape continuations) are always safe</li>
            <li>Don't save continuations captured inside C callbacks for later use</li>
            <li>If you must use general continuations, reset C stack first</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Foreign Data</li>
    <br/>
    <ul>
        <li><code>foreign-alloc</code> and <code>foreign-free</code> manage foreign memory:</li>
<pre><code class="language-scheme line-numbers">; Allocate 100 bytes
(define ptr (foreign-alloc 100))

; Use the memory...

; Free when done
(foreign-free ptr)</code></pre>
        <br/>
        <li><code>foreign-ref</code> and <code>foreign-set!</code> read/write foreign memory:</li>
<pre><code class="language-scheme line-numbers">; Allocate space for an int
(define int-ptr (foreign-alloc (foreign-sizeof 'int)))

; Write value
(foreign-set! 'int int-ptr 0 42)

; Read value
(foreign-ref 'int int-ptr 0)    ; 42

; Different types at different offsets
(define buf (foreign-alloc 24))
(foreign-set! 'integer-32 buf 0 100)
(foreign-set! 'double buf 8 3.14159)
(foreign-set! 'char buf 16 #\A)

(foreign-ref 'integer-32 buf 0)  ; 100
(foreign-ref 'double buf 8)      ; 3.14159
(foreign-ref 'char buf 16)       ; #\A

(foreign-free buf)</code></pre>
        <br/>
        <li><code>foreign-sizeof</code> returns size of types:</li>
<pre><code class="language-scheme line-numbers">(foreign-sizeof 'int)           ; 4 (typically)
(foreign-sizeof 'double)        ; 8
(foreign-sizeof 'void*)         ; 4 or 8 (platform-dependent)
(foreign-sizeof 'char)          ; 1</code></pre>
        <br/>
        <li>Defining foreign types with <code>define-ftype</code>:</li>
<pre><code class="language-scheme line-numbers">; Simple struct
(define-ftype Point
  (struct
    [x double]
    [y double]))

(ftype-sizeof Point)            ; 16

; Nested structures
(define-ftype Rectangle
  (struct
    [top-left Point]
    [bottom-right Point]))

; Arrays
(define-ftype IntArray10
  (array 10 int))

; Pointers
(define-ftype PointPtr (* Point))

; Unions
(define-ftype Number
  (union
    [as-int integer-32]
    [as-float single-float]))

; Bit fields
(define-ftype Flags
  (bits
    [enabled unsigned 1]
    [mode unsigned 3]
    [priority unsigned 4]))</code></pre>
        <br/>
        <li>Using ftype pointers:</li>
<pre><code class="language-scheme line-numbers">; Allocate and create pointer
(define p
  (make-ftype-pointer Point
    (foreign-alloc (ftype-sizeof Point))))

; Set fields
(ftype-set! Point (x) p 3.0)
(ftype-set! Point (y) p 4.0)

; Get fields
(ftype-ref Point (x) p)         ; 3.0
(ftype-ref Point (y) p)         ; 4.0

; Get address of field
(ftype-&ref Point (x) p)        ; Pointer to x field

; Convert to s-expression for debugging
(ftype-pointer->sexpr p)
; (struct [x 3.0] [y 4.0])

; Free when done
(foreign-free (ftype-pointer-address p))</code></pre>
        <br/>
        <li>Complex ftype example:</li>
<pre><code class="language-scheme line-numbers">(define-ftype Person
  (struct
    [name (array 64 char)]
    [age integer-32]
    [height double]
    [next (* Person)]))         ; Linked list

; Allocate
(define person
  (make-ftype-pointer Person
    (foreign-alloc (ftype-sizeof Person))))

; Set fields
(ftype-set! Person (age) person 30)
(ftype-set! Person (height) person 1.75)
(ftype-set! Person (next) person
  (make-ftype-pointer Person 0))  ; null pointer

; Access array elements
(ftype-set! Person (name 0) person #\J)
(ftype-set! Person (name 1) person #\o)
(ftype-set! Person (name 2) person #\e)
(ftype-set! Person (name 3) person #\nul)</code></pre>
    </ul>
    <br/><br/>


    <li>Foreign Arrays of Managed Objects</li>
    <br/>
    <ul>
        <li>Arrays with pointers to Scheme objects require special care due to garbage collection.</li>
        <br/>
        <li>Lock objects that foreign code will reference:</li>
<pre><code class="language-scheme line-numbers">; Create array of Scheme objects for C access
(define (make-object-array objects)
  (let* ([n (length objects)]
         [ptr (foreign-alloc (* n (foreign-sizeof 'ptr)))])
    ; Store and lock each object
    (let loop ([objs objects] [i 0])
      (unless (null? objs)
        (let ([obj (car objs)])
          (lock-object obj)
          (foreign-set! 'ptr ptr (* i (foreign-sizeof 'ptr)) obj))
        (loop (cdr objs) (+ i 1))))
    ptr))

; Free and unlock
(define (free-object-array ptr n)
  (do ([i 0 (+ i 1)])
      ((= i n))
    (let ([obj (foreign-ref 'ptr ptr (* i (foreign-sizeof 'ptr)))])
      (unlock-object obj)))
  (foreign-free ptr))</code></pre>
        <br/>
        <li>Using bytevectors for binary data (automatically managed):</li>
<pre><code class="language-scheme line-numbers">; Pass bytevector to C as u8*
(define bv (make-bytevector 100 0))

; C function receiving bytevector
(define fill-buffer
  (foreign-procedure "fill_buffer" (u8* size_t) int))

; Bytevector data is accessible during call
(fill-buffer bv (bytevector-length bv))

; Don't store bv pointer in C across Scheme calls!</code></pre>
        <br/>
        <li>Converting between strings and foreign memory:</li>
<pre><code class="language-scheme line-numbers">; String to bytevector (for passing to C)
(define (string->foreign-utf8 str)
  (string->utf8 str))

; Bytevector from C (null-terminated)
(define (foreign-utf8->string bv)
  (let loop ([i 0])
    (if (zero? (bytevector-u8-ref bv i))
        (utf8->string (bytevector-copy bv 0 i))
        (loop (+ i 1)))))</code></pre>
    </ul>
    <br/><br/>


    <li>Providing Access to Foreign Procedures</li>
    <br/>
    <ul>
        <li><code>load-shared-object</code> loads dynamic libraries:</li>
<pre><code class="language-scheme line-numbers">; Load system libraries
(case (machine-type)
  [(i3le ti3le a6le ta6le)       ; Linux
   (load-shared-object "libc.so.6")
   (load-shared-object "libm.so.6")]
  [(i3osx ti3osx a6osx ta6osx)   ; macOS
   (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt)       ; Windows
   (load-shared-object "msvcrt.dll")])

; Load custom library
(load-shared-object "./mylib.so")

; With path
(load-shared-object "/usr/local/lib/libfoo.so")</code></pre>
        <br/>
        <li>Building shared libraries:</li>
<pre><code class="language-bash line-numbers"># Linux
$ gcc -fPIC -shared -o mylib.so mylib.c

# macOS
$ gcc -dynamiclib -o mylib.dylib mylib.c

# Windows (Visual Studio)
$ cl -c mylib.c
$ link -dll -out:mylib.dll mylib.obj</code></pre>
        <br/>
        <li>Export symbols on Windows:</li>
<pre><code class="language-c line-numbers">// mylib.c for Windows
#ifdef WIN32
#define EXPORT __declspec(dllexport)
#else
#define EXPORT
#endif

EXPORT int add(int x, int y) {
    return x + y;
}</code></pre>
        <br/>
        <li>Registering symbols manually:</li>
<pre><code class="language-scheme line-numbers">; Check if entry exists
(foreign-entry? "my_function")  ; #t or #f

; Get address
(foreign-entry "my_function")   ; Address

; Get name from address
(foreign-address-name addr)     ; "my_function" or #f

; Remove entry (for cleanup)
(remove-foreign-entry "my_function")</code></pre>
    </ul>
    <br/><br/>


    <li>Using Other Foreign Languages</li>
    <br/>
    <ul>
        <li>Any language that follows C calling conventions can interoperate.</li>
        <br/>
        <li>Name mangling considerations:</li>
<pre><code class="language-scheme line-numbers">; C compilers may prepend underscore to names
; Use "=" prefix to bypass name interpretation
(foreign-entry? "foo")      ; May be false
(foreign-entry? "=foo")     ; Check raw name

; For assembly-coded procedures
(foreign-procedure "=_my_asm_proc" (int) int)</code></pre>
        <br/>
        <li>Calling conventions (Windows):</li>
<pre><code class="language-scheme line-numbers">; Default (cdecl)
(foreign-procedure "func" (int) int)

; stdcall (Windows API)
(foreign-procedure __stdcall "MessageBoxA"
  (void* string string unsigned-32)
  int)

; COM interface
(foreign-procedure __com 12    ; vtable offset
  (iptr double-float)
  integer-32)</code></pre>
        <br/>
        <li>Interfacing with C++:</li>
<pre><code class="language-cpp line-numbers">// C++ code - use extern "C" to disable name mangling
extern "C" {
    int my_function(int x) {
        return x * 2;
    }

    // Create/destroy C++ objects through C interface
    void* create_object() {
        return new MyClass();
    }

    void destroy_object(void* ptr) {
        delete static_cast&lt;MyClass*&gt;(ptr);
    }

    int call_method(void* ptr, int arg) {
        return static_cast&lt;MyClass*&gt;(ptr)->method(arg);
    }
}</code></pre>
<pre><code class="language-scheme line-numbers">; Scheme interface to C++ object
(load-shared-object "./myclass.so")

(define create-object
  (foreign-procedure "create_object" () void*))
(define destroy-object
  (foreign-procedure "destroy_object" (void*) void))
(define call-method
  (foreign-procedure "call_method" (void* int) int))

(define obj (create-object))
(call-method obj 42)
(destroy-object obj)</code></pre>
    </ul>
    <br/><br/>


    <li>C Library Routines</li>
    <br/>
    <ul>
        <li>Chez Scheme provides C-callable routines via <code>scheme.h</code>:</li>
<pre><code class="language-c line-numbers">/* Include Chez Scheme header */
#include "scheme.h"

/* Predicates: check object types */
Sfixnump(obj)       /* Is obj a fixnum? */
Spairp(obj)         /* Is obj a pair? */
Sstringp(obj)       /* Is obj a string? */
Svectorp(obj)       /* Is obj a vector? */
Sprocedurep(obj)    /* Is obj a procedure? */

/* Accessors: extract values */
Sfixnum_value(fixnum)    /* fixnum -> C integer */
Schar_value(char)        /* character -> C char */
Sflonum_value(flonum)    /* flonum -> C double */
Scar(pair)               /* car of pair */
Scdr(pair)               /* cdr of pair */
Sstring_length(str)      /* string length */
Svector_ref(vec, i)      /* vector element */</code></pre>
        <br/>
        <li>Constructors:</li>
<pre><code class="language-c line-numbers">/* Immediate values */
Snil                     /* Empty list */
Strue                    /* #t */
Sfalse                   /* #f */
Svoid                    /* void */

/* Create Scheme objects */
Sfixnum(n)               /* C int -> fixnum */
Schar(c)                 /* C char -> character */
Sflonum(x)               /* C double -> flonum */
Sstring(s)               /* C string -> Scheme string */
Scons(car, cdr)          /* Create pair */
Sbox(obj)                /* Create box */
Smake_string(n, c)       /* Make string of length n */
Smake_vector(n, obj)     /* Make vector of length n */
Sinteger(n)              /* C int -> exact integer (any size) */
Sstring_to_symbol(s)     /* C string -> symbol */</code></pre>
        <br/>
        <li>Calling Scheme from C:</li>
<pre><code class="language-c line-numbers">/* Call with 0-3 arguments */
ptr Scall0(ptr proc);
ptr Scall1(ptr proc, ptr arg1);
ptr Scall2(ptr proc, ptr arg1, ptr arg2);
ptr Scall3(ptr proc, ptr arg1, ptr arg2, ptr arg3);

/* General call interface */
void Sinitframe(iptr n);          /* Initialize for n args */
void Sput_arg(iptr i, ptr arg);   /* Set argument i */
ptr Scall(ptr proc, iptr n);      /* Call with n args */

/* Example: call Scheme + from C */
ptr plus = Stop_level_value(Sstring_to_symbol("+"));
ptr result = Scall2(plus, Sfixnum(3), Sfixnum(4));
/* result is Scheme 7 */</code></pre>
        <br/>
        <li>Locking objects:</li>
<pre><code class="language-c line-numbers">/* Prevent GC from moving/collecting object */
void Slock_object(ptr obj);
void Sunlock_object(ptr obj);

/* Must lock Scheme objects that C code retains
   across calls back into Scheme */
ptr str = Sstring("hello");
Slock_object(str);
/* ... use str, possibly calling Scheme ... */
Sunlock_object(str);</code></pre>
        <br/>
        <li>Registering foreign symbols:</li>
<pre><code class="language-c line-numbers">/* Make C function visible to Scheme */
void Sforeign_symbol(const char *name, void *addr);
void Sregister_symbol(const char *name, void *addr);

/* Example */
int my_add(int x, int y) { return x + y; }

void init_my_lib(void) {
    Sregister_symbol("my_add", (void*)my_add);
}</code></pre>
        <br/>
        <li>Embedding Chez Scheme:</li>
<pre><code class="language-c line-numbers">/* Initialize Scheme */
Sscheme_init(NULL);

/* Register boot file */
Sregister_boot_file("petite.boot");
Sregister_boot_file("scheme.boot");

/* Build heap */
Sbuild_heap(NULL, NULL);

/* Run Scheme code */
ptr result = Scall1(
    Stop_level_value(Sstring_to_symbol("eval")),
    Scons(Sstring_to_symbol("+"),
          Scons(Sfixnum(1),
                Scons(Sfixnum(2), Snil))));

/* Cleanup */
Sscheme_deinit();</code></pre>
    </ul>
    <br/><br/>


    <li>Example: Socket Operations</li>
    <br/>
    <ul>
        <li>C helper code (csocket.c):</li>
<pre><code class="language-c line-numbers">/* csocket.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

/* Write entire buffer, handling interrupts */
int c_write(int fd, char *buf, unsigned n) {
    unsigned i, m;
    m = n;
    while (m &gt; 0) {
        if ((i = write(fd, buf, m)) &lt; 0) {
            if (errno != EAGAIN &amp;&amp; errno != EINTR)
                return i;
        } else {
            m -= i;
            buf += i;
        }
    }
    return n;
}

/* Read handling interrupts */
int c_read(int fd, char *buf, unsigned n) {
    int i;
    for (;;) {
        i = read(fd, buf, n);
        if (i &gt;= 0) return i;
        if (errno != EAGAIN &amp;&amp; errno != EINTR) return -1;
    }
}

/* Check if data available */
int bytes_ready(int fd) {
    int n;
    ioctl(fd, FIONREAD, &amp;n);
    return n;
}

/* Create Unix domain socket */
int do_socket(void) {
    return socket(AF_UNIX, SOCK_STREAM, 0);
}

/* Bind socket to name */
int do_bind(int s, char *name) {
    struct sockaddr_un sun;
    sun.sun_family = AF_UNIX;
    strcpy(sun.sun_path, name);
    return bind(s, (struct sockaddr*)&amp;sun,
                sizeof(sun.sun_family) + strlen(name) + 1);
}

/* Accept connection */
int do_accept(int s) {
    struct sockaddr_un sun;
    socklen_t len = sizeof(sun);
    return accept(s, (struct sockaddr*)&amp;sun, &amp;len);
}

/* Connect to server */
int do_connect(int s, char *name) {
    struct sockaddr_un sun;
    sun.sun_family = AF_UNIX;
    strcpy(sun.sun_path, name);
    return connect(s, (struct sockaddr*)&amp;sun,
                   sizeof(sun.sun_family) + strlen(name) + 1);
}

/* Get error string */
char* get_error(void) {
    return strerror(errno);
}</code></pre>
        <br/>
        <li>Compile the C code:</li>
<pre><code class="language-bash line-numbers"># Linux
$ gcc -fPIC -shared -o csocket.so csocket.c

# macOS
$ gcc -dynamiclib -o csocket.so csocket.c</code></pre>
        <br/>
        <li>Scheme socket interface:</li>
<pre><code class="language-scheme line-numbers">;;; socket.ss

;; Load libraries
(load-shared-object "libc.so.6")  ; or libc.dylib on macOS
(load-shared-object "./csocket.so")

;; Basic C library functions
(define close (foreign-procedure "close" (int) int))
(define dup (foreign-procedure "dup" (int) int))
(define fork (foreign-procedure "fork" () int))
(define listen (foreign-procedure "listen" (int int) int))
(define unlink (foreign-procedure "unlink" (string) int))

;; Socket functions from csocket.c
(define socket (foreign-procedure "do_socket" () int))
(define bind (foreign-procedure "do_bind" (int string) int))
(define accept (foreign-procedure "do_accept" (int) int))
(define connect (foreign-procedure "do_connect" (int string) int))
(define c-read (foreign-procedure "c_read" (int string int) int))
(define c-write (foreign-procedure "c_write" (int string int) int))
(define bytes-ready? (foreign-procedure "bytes_ready" (int) boolean))
(define c-error (foreign-procedure "get_error" () string))

;; Error checking helper
(define (check who x)
  (if (< x 0)
      (errorf who "~a" (c-error))
      x))

;; Set up server socket
(define (setup-server-socket name)
  (let ([sock (check 'socket (socket))])
    (unlink name)
    (check 'bind (bind sock name))
    (check 'listen (listen sock 1))
    sock))

;; Set up client socket
(define (setup-client-socket name)
  (let ([sock (check 'socket (socket))])
    (check 'connect (connect sock name))
    sock))

;; Accept a connection
(define (accept-socket sock)
  (check 'accept (accept sock)))

;; Read from socket
(define (socket-read sock max-bytes)
  (let ([buf (make-string max-bytes)])
    (let ([n (c-read sock buf max-bytes)])
      (if (< n 0)
          (errorf 'socket-read "~a" (c-error))
          (substring buf 0 n)))))

;; Write to socket
(define (socket-write sock str)
  (let ([n (c-write sock str (string-length str))])
    (if (< n 0)
        (errorf 'socket-write "~a" (c-error))
        n)))</code></pre>
        <br/>
        <li>Example usage - Echo server:</li>
<pre><code class="language-scheme line-numbers">(load "socket.ss")

(define (run-echo-server socket-name)
  (let ([server-sock (setup-server-socket socket-name)])
    (printf "Server listening on ~a~n" socket-name)
    (let ([client-sock (accept-socket server-sock)])
      (printf "Client connected~n")
      (let loop ()
        (when (bytes-ready? client-sock)
          (let ([data (socket-read client-sock 1024)])
            (unless (string=? data "")
              (printf "Received: ~a" data)
              (socket-write client-sock data)
              (loop)))))
      (close client-sock))
    (close server-sock)
    (unlink socket-name)))

; Run with: (run-echo-server "/tmp/echo.sock")</code></pre>
        <br/>
        <li>Example usage - Client:</li>
<pre><code class="language-scheme line-numbers">(load "socket.ss")

(define (run-echo-client socket-name message)
  (let ([sock (setup-client-socket socket-name)])
    (socket-write sock message)
    (let ([response (socket-read sock 1024)])
      (printf "Response: ~a~n" response))
    (close sock)))

; Run with: (run-echo-client "/tmp/echo.sock" "Hello!\n")</code></pre>
        <br/>
        <li>Creating a process port (bidirectional communication with subprocess):</li>
<pre><code class="language-scheme line-numbers">;; Create port that wraps socket I/O
(define (make-socket-port sock)
  (define (read! bv start count)
    (let ([buf (make-string count)])
      (let ([n (c-read sock buf count)])
        (do ([i 0 (+ i 1)])
            ((= i n) n)
          (bytevector-u8-set! bv (+ start i)
            (char->integer (string-ref buf i)))))))

  (define (write! bv start count)
    (let ([str (make-string count)])
      (do ([i 0 (+ i 1)])
          ((= i count))
        (string-set! str i
          (integer->char (bytevector-u8-ref bv (+ start i)))))
      (c-write sock str count)))

  (define (close-proc)
    (close sock))

  (make-custom-binary-input/output-port
    "socket-port"
    read!
    write!
    #f      ; get-position
    #f      ; set-position
    close-proc))</code></pre>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-binding-forms">Binding Forms in Chez Scheme</h3>
<ol>

    <li>Definitions</li>
    <br/>
    <ul>
        <li>The <code>define</code> form creates bindings for variables and procedures:</li>
<pre><code class="language-scheme line-numbers">; Variable definition
(define x 42)
(define greeting "Hello, World!")

; Procedure definition (full form)
(define square
  (lambda (x)
    (* x x)))

; Procedure definition (shorthand)
(define (square x)
  (* x x))

; Shorthand with multiple parameters
(define (add a b)
  (+ a b))

; Shorthand with rest parameter
(define (sum . numbers)
  (apply + numbers))

(sum 1 2 3 4 5)             ; 15

; Shorthand with required and rest parameters
(define (format-message prefix . args)
  (apply format prefix args))</code></pre>
        <br/>
        <li><code>let</code> creates local bindings evaluated in parallel:</li>
<pre><code class="language-scheme line-numbers">; Basic let
(let ([x 10]
      [y 20])
  (+ x y))                  ; 30

; Bindings are parallel - can't reference each other
(let ([x 5]
      [y x])                ; ERROR: x not yet bound
  (+ x y))

; Shadowing outer bindings
(define x 100)
(let ([x 1])
  x)                        ; 1 (inner x shadows outer)
x                           ; 100 (outer x unchanged)</code></pre>
        <br/>
        <li><code>let*</code> creates sequential bindings:</li>
<pre><code class="language-scheme line-numbers">; Bindings are sequential - later can reference earlier
(let* ([x 5]
       [y (* x 2)]          ; Can use x
       [z (+ x y)])         ; Can use x and y
  z)                        ; 15

; Equivalent to nested lets
(let ([x 5])
  (let ([y (* x 2)])
    (let ([z (+ x y)])
      z)))

; Useful for step-by-step computation
(let* ([input "  hello world  "]
       [trimmed (string-trim input)]
       [upper (string-upcase trimmed)]
       [words (string-split upper " ")])
  words)                    ; ("HELLO" "WORLD")</code></pre>
        <br/>
        <li><code>letrec</code> creates mutually recursive bindings:</li>
<pre><code class="language-scheme line-numbers">; Mutually recursive procedures
(letrec ([even? (lambda (n)
                  (or (zero? n)
                      (odd? (- n 1))))]
         [odd? (lambda (n)
                 (and (not (zero? n))
                      (even? (- n 1))))])
  (list (even? 10) (odd? 10)))  ; (#t #f)

; Self-recursive procedure
(letrec ([factorial
          (lambda (n)
            (if (zero? n)
                1
                (* n (factorial (- n 1)))))])
  (factorial 5))            ; 120

; All bindings in scope for all right-hand sides
(letrec ([a (lambda () (b))]
         [b (lambda () 42)])
  (a))                      ; 42</code></pre>
        <br/>
        <li><code>letrec*</code> combines <code>letrec</code> semantics with left-to-right evaluation:</li>
<pre><code class="language-scheme line-numbers">; Guaranteed left-to-right evaluation
(letrec* ([x 1]
          [y (+ x 1)]       ; Can reference x's value
          [z (+ y 1)])      ; Can reference y's value
  (list x y z))             ; (1 2 3)

; Useful when initialization order matters
(letrec* ([counter 0]
          [inc! (lambda ()
                  (set! counter (+ counter 1))
                  counter)]
          [first (inc!)]    ; Evaluated first
          [second (inc!)])  ; Evaluated second
  (list first second counter))  ; (1 2 2)</code></pre>
        <br/>
        <li>Named <code>let</code> for recursive iteration:</li>
<pre><code class="language-scheme line-numbers">; Named let creates a recursive procedure
(let loop ([n 5] [acc 1])
  (if (zero? n)
      acc
      (loop (- n 1) (* n acc))))  ; 120

; Equivalent to:
(letrec ([loop (lambda (n acc)
                 (if (zero? n)
                     acc
                     (loop (- n 1) (* n acc))))])
  (loop 5 1))

; List processing with named let
(let loop ([lst '(1 2 3 4 5)] [sum 0])
  (if (null? lst)
      sum
      (loop (cdr lst) (+ sum (car lst)))))  ; 15</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple-value Definitions</li>
    <br/>
    <ul>
        <li><code>define-values</code> binds multiple variables from a multiple-value expression:</li>
<pre><code class="language-scheme line-numbers">; Basic define-values
(define-values (quotient remainder)
  (div-and-mod 17 5))

quotient                    ; 3
remainder                   ; 2

; From partition
(define-values (evens odds)
  (partition even? '(1 2 3 4 5 6)))

evens                       ; (2 4 6)
odds                        ; (1 3 5)

; Multiple return values from custom procedure
(define (min-max lst)
  (values (apply min lst)
          (apply max lst)))

(define-values (lo hi)
  (min-max '(3 1 4 1 5 9 2 6)))

lo                          ; 1
hi                          ; 9</code></pre>
        <br/>
        <li><code>let-values</code> creates local multiple-value bindings:</li>
<pre><code class="language-scheme line-numbers">; Basic let-values
(let-values ([(q r) (div-and-mod 17 5)])
  (printf "~a with remainder ~a~n" q r))

; Multiple clauses
(let-values ([(a b) (values 1 2)]
             [(x y z) (values 10 20 30)])
  (+ a b x y z))            ; 63

; Combining with regular values (use extra parens)
(let-values ([(q r) (div-and-mod 100 7)]
             [(name) (values "test")])
  (list name q r))          ; ("test" 14 2)

; Single value (equivalent to let)
(let-values ([(x) (values 42)])
  x)                        ; 42</code></pre>
        <br/>
        <li><code>let*-values</code> for sequential multiple-value bindings:</li>
<pre><code class="language-scheme line-numbers">; Sequential binding - later can reference earlier
(let*-values ([(a b) (values 2 3)]
              [(c) (values (* a b))]
              [(d e) (values (+ c 1) (- c 1))])
  (list a b c d e))         ; (2 3 6 7 5)

; Useful for chained transformations
(define (parse-and-validate input)
  (let*-values ([(parsed ok?) (parse input)]
                [(validated valid?)
                 (if ok?
                     (validate parsed)
                     (values #f #f))])
    (values validated (and ok? valid?))))</code></pre>
        <br/>
        <li>Using <code>call-with-values</code> directly:</li>
<pre><code class="language-scheme line-numbers">; Explicit call-with-values
(call-with-values
  (lambda () (values 1 2 3))
  (lambda (a b c) (+ a b c)))  ; 6

; Equivalent let-values
(let-values ([(a b c) (values 1 2 3)])
  (+ a b c))                ; 6

; Useful for inline value handling
(call-with-values
  (lambda () (partition even? '(1 2 3 4 5)))
  (lambda (evens odds)
    (printf "Evens: ~a, Odds: ~a~n" evens odds)))</code></pre>
        <br/>
        <li>Patterns with multiple values:</li>
<pre><code class="language-scheme line-numbers">; Ignoring some values
(let-values ([(_ remainder) (div-and-mod 17 5)])
  remainder)                ; 2

; Collecting extra values with rest
(define (first-and-rest producer)
  (call-with-values producer
    (lambda (first . rest)
      (values first rest))))

(first-and-rest (lambda () (values 1 2 3 4)))
; Returns: 1 and (2 3 4)

; Zero values
(let-values ([() (values)])  ; No bindings
  'done)                    ; done</code></pre>
    </ul>
    <br/><br/>


    <li>Recursive Bindings</li>
    <br/>
    <ul>
        <li><code>letrec</code> allows procedures to reference themselves and each other:</li>
<pre><code class="language-scheme line-numbers">; Self-reference
(letrec ([count-down
          (lambda (n)
            (if (zero? n)
                'done
                (begin
                  (printf "~a~n" n)
                  (count-down (- n 1)))))])
  (count-down 3))
; Prints: 3 2 1
; Returns: done

; Mutual recursion
(letrec ([ping (lambda (n)
                 (if (zero? n)
                     'ping
                     (pong (- n 1))))]
         [pong (lambda (n)
                 (if (zero? n)
                     'pong
                     (ping (- n 1))))])
  (list (ping 5) (pong 5)))  ; (pong ping)</code></pre>
        <br/>
        <li>State machines with <code>letrec</code>:</li>
<pre><code class="language-scheme line-numbers">; Simple state machine
(define (parse-number str)
  (letrec
    ([start (lambda (chars)
              (cond
                [(null? chars) #f]
                [(char=? (car chars) #\-)
                 (digits (cdr chars) '() #t)]
                [(char-numeric? (car chars))
                 (digits chars '() #f)]
                [else #f]))]
     [digits (lambda (chars acc neg?)
               (cond
                 [(null? chars)
                  (if (null? acc)
                      #f
                      (let ([n (string->number
                                 (list->string (reverse acc)))])
                        (if neg? (- n) n)))]
                 [(char-numeric? (car chars))
                  (digits (cdr chars) (cons (car chars) acc) neg?)]
                 [else #f]))])
    (start (string->list str))))

(parse-number "123")        ; 123
(parse-number "-456")       ; -456
(parse-number "abc")        ; #f</code></pre>
        <br/>
        <li><code>rec</code> for single self-recursive bindings:</li>
<pre><code class="language-scheme line-numbers">; rec creates single recursive binding
(define factorial
  (rec fact
    (lambda (n)
      (if (zero? n)
          1
          (* n (fact (- n 1)))))))

(factorial 5)               ; 120

; Useful for anonymous recursive procedures
(map (rec sum-tree
       (lambda (tree)
         (if (pair? tree)
             (+ (sum-tree (car tree))
                (sum-tree (cdr tree)))
             (if (number? tree) tree 0))))
     '((1 2) (3 (4 5)) ((6))))
; (3 12 6)</code></pre>
        <br/>
        <li>Internal definitions (implicitly <code>letrec*</code>):</li>
<pre><code class="language-scheme line-numbers">; Internal defines in procedure body
(define (process-tree tree)
  ; These are like letrec* bindings
  (define (leaf? x) (not (pair? x)))
  (define (process-node node)
    (if (leaf? node)
        (handle-leaf node)
        (handle-branch node)))
  (define (handle-leaf x) (* x 2))
  (define (handle-branch node)
    (cons (process-node (car node))
          (process-node (cdr node))))
  ; Body starts here
  (process-node tree))

(process-tree '(1 (2 3) 4))  ; (2 (4 6) 8)

; Internal defines can reference later definitions
(define (example)
  (define (a) (b))          ; References b defined below
  (define (b) 42)
  (a))

(example)                   ; 42</code></pre>
        <br/>
        <li>Avoiding evaluation order issues:</li>
<pre><code class="language-scheme line-numbers">; Problematic: referencing value during initialization
(letrec ([x (+ y 1)]        ; ERROR: y not yet initialized
         [y 5])
  x)

; Solution 1: use lambda to delay evaluation
(letrec ([x (lambda () (+ (y) 1))]
         [y (lambda () 5)])
  ((x)))                    ; 6

; Solution 2: use letrec* with proper order
(letrec* ([y 5]
          [x (+ y 1)])
  x)                        ; 6

; Note: letrec is for procedures, letrec* for values</code></pre>
    </ul>
    <br/><br/>


    <li>Fluid Bindings</li>
    <br/>
    <ul>
        <li>Parameters provide dynamically-scoped (fluid) bindings:</li>
<pre><code class="language-scheme line-numbers">; Create a parameter with initial value
(define current-user (make-parameter "guest"))

; Access current value
(current-user)              ; "guest"

; Set globally
(current-user "admin")
(current-user)              ; "admin"

; Dynamic binding with parameterize
(parameterize ([current-user "alice"])
  (current-user))           ; "alice"

(current-user)              ; "admin" (restored)</code></pre>
        <br/>
        <li><code>parameterize</code> creates dynamic extent bindings:</li>
<pre><code class="language-scheme line-numbers">; Dynamic scope in action
(define current-indent (make-parameter 0))

(define (print-indented msg)
  (display (make-string (current-indent) #\space))
  (display msg)
  (newline))

(define (print-tree tree)
  (cond
    [(pair? tree)
     (print-indented "(")
     (parameterize ([current-indent (+ (current-indent) 2)])
       (for-each print-tree tree))
     (print-indented ")")]
    [else
     (print-indented tree)]))

(print-tree '(a (b c) d))
; (
;   a
;   (
;     b
;     c
;   )
;   d
; )</code></pre>
        <br/>
        <li>Parameter validation with guard procedures:</li>
<pre><code class="language-scheme line-numbers">; Parameter with validation
(define current-verbosity
  (make-parameter 0
    (lambda (v)
      (unless (and (integer? v) (<= 0 v 3))
        (error 'current-verbosity
               "must be integer 0-3, got ~s" v))
      v)))

(current-verbosity 2)       ; OK
(current-verbosity 5)       ; ERROR

; Parameter with transformation
(define current-output-file
  (make-parameter "output.txt"
    (lambda (v)
      (if (string? v)
          v
          (format "~a.txt" v)))))

(current-output-file 'data)
(current-output-file)       ; "data.txt"</code></pre>
        <br/>
        <li>Nested and multiple parameter bindings:</li>
<pre><code class="language-scheme line-numbers">; Multiple parameters
(define debug-mode (make-parameter #f))
(define trace-calls (make-parameter #f))

(parameterize ([debug-mode #t]
               [trace-calls #t])
  (when (trace-calls)
    (display "Tracing enabled\n"))
  (when (debug-mode)
    (display "Debug mode\n")))

; Nested parameterize
(define level (make-parameter 0))

(parameterize ([level 1])
  (printf "Level: ~a~n" (level))   ; 1
  (parameterize ([level 2])
    (printf "Level: ~a~n" (level))) ; 2
  (printf "Level: ~a~n" (level)))  ; 1</code></pre>
        <br/>
        <li>Parameters and continuations:</li>
<pre><code class="language-scheme line-numbers">; Parameters are saved/restored with continuations
(define p (make-parameter 'initial))

(define saved-k #f)

(parameterize ([p 'inside])
  (call/cc (lambda (k)
             (set! saved-k k)
             (p))))              ; 'inside

(p)                             ; 'initial

; Re-entering the parameterize restores the binding
(saved-k 'ignored)              ; 'inside

; dynamic-wind ensures proper parameter handling
(define log-output (make-parameter '()))

(define (with-logging thunk)
  (parameterize ([log-output '()])
    (thunk)
    (reverse (log-output))))

(define (log msg)
  (log-output (cons msg (log-output))))</code></pre>
        <br/>
        <li>Common built-in parameters:</li>
<pre><code class="language-scheme line-numbers">; I/O parameters
(current-input-port)
(current-output-port)
(current-error-port)

(parameterize ([current-output-port (open-output-string)])
  (display "captured")
  (get-output-string (current-output-port)))  ; "captured"

; Print parameters
(print-level)               ; Max nesting depth
(print-length)              ; Max list elements

(parameterize ([print-length 3])
  (printf "~s~n" '(1 2 3 4 5)))  ; (1 2 3 ...)

; Compilation parameters
(optimize-level)            ; 0-3
(compile-interpret-simple)  ; #t/#f

; Interaction environment
(interaction-environment)</code></pre>
    </ul>
    <br/><br/>


    <li>Top-Level Bindings</li>
    <br/>
    <ul>
        <li>Top-level <code>define</code> creates or modifies bindings:</li>
<pre><code class="language-scheme line-numbers">; Create new binding
(define x 10)

; Redefine (modify) existing binding
(define x 20)

; Top-level defines are mutable
(set! x 30)

; Procedure definitions at top level
(define (greet name)
  (printf "Hello, ~a!~n" name))</code></pre>
        <br/>
        <li><code>top-level-value</code> and <code>set-top-level-value!</code> for programmatic access:</li>
<pre><code class="language-scheme line-numbers">; Get value of top-level binding
(define x 42)
(top-level-value 'x)        ; 42

; Set top-level binding
(set-top-level-value! 'y 100)
y                           ; 100

; Check if bound
(top-level-bound? 'x)       ; #t
(top-level-bound? 'nonexistent)  ; #f

; Dynamic binding creation
(define (create-binding name value)
  (set-top-level-value! name value))

(create-binding 'dynamic-var 999)
dynamic-var                 ; 999</code></pre>
        <br/>
        <li><code>define-top-level-value</code> for explicit top-level definition:</li>
<pre><code class="language-scheme line-numbers">; Explicitly define at top level (even from nested context)
(let ([x 10])
  (define-top-level-value 'from-let (* x 2)))

from-let                    ; 20

; Useful in macros that need to create top-level bindings
(define-syntax def-constant
  (syntax-rules ()
    [(_ name value)
     (define-top-level-value 'name value)]))</code></pre>
        <br/>
        <li>Interaction environment bindings:</li>
<pre><code class="language-scheme line-numbers">; The interaction environment contains REPL bindings
(interaction-environment)   ; Returns the environment

; Evaluate in specific environment
(define env (interaction-environment))

(eval '(define z 50) env)
(eval 'z env)               ; 50

; Create new environment
(define my-env (copy-environment (scheme-environment)))
(eval '(define private 42) my-env)

; private visible in my-env but not globally
(eval 'private my-env)      ; 42
; private                   ; ERROR: unbound</code></pre>
        <br/>
        <li><code>alias</code> creates alternative names for bindings:</li>
<pre><code class="language-scheme line-numbers">; Create an alias
(define original-name 42)
(alias new-name original-name)

new-name                    ; 42
(set! new-name 100)
original-name               ; 100 (same binding)

; Alias for imported procedure
(alias λ lambda)
(define add (λ (x y) (+ x y)))

; Alias for keyword
(alias fn define)
(fn (square x) (* x x))</code></pre>
        <br/>
        <li>Module and library exports as top-level:</li>
<pre><code class="language-scheme line-numbers">; Library exports become available at top level when imported
(import (rnrs))             ; Makes R6RS bindings available

; Specific imports
(import (only (chezscheme) printf format))

; Top-level program structure
; #!/usr/bin/env scheme-script
; (import (rnrs) (my-library))
; (main-procedure)</code></pre>
        <br/>
        <li>Top-level syntax definitions:</li>
<pre><code class="language-scheme line-numbers">; Define syntax at top level
(define-syntax when
  (syntax-rules ()
    [(_ test body ...)
     (if test (begin body ...))]))

; Syntax is also a top-level binding
(top-level-bound? 'when)    ; #t

; But top-level-value doesn't work for syntax
; (top-level-value 'when)   ; ERROR

; Check if identifier is bound to syntax
(top-level-syntax? 'when)   ; #t
(top-level-syntax? 'car)    ; #f</code></pre>
        <br/>
        <li>Forward references at top level:</li>
<pre><code class="language-scheme line-numbers">; Top-level allows forward references
(define (f x) (g x))        ; References g not yet defined
(define (g x) (* x 2))      ; Now defined
(f 21)                      ; 42

; This works because:
; 1. define creates a binding location
; 2. The lambda body isn't evaluated until f is called
; 3. By then, g is defined

; Be careful with immediate evaluation
; (define a (+ b 1))        ; ERROR: b not defined
; (define b 10)

; Solution: use thunks or proper ordering
(define b 10)
(define a (+ b 1))          ; OK</code></pre>
    </ul>
    <br/><br/>


    <li>Additional Binding Forms</li>
    <br/>
    <ul>
        <li><code>fluid-let</code> for temporary mutation (deprecated, prefer parameters):</li>
<pre><code class="language-scheme line-numbers">; fluid-let temporarily changes a variable's value
(define counter 0)

(fluid-let ([counter 100])
  (set! counter (+ counter 1))
  counter)                  ; 101

counter                     ; 0 (restored)

; Note: prefer make-parameter and parameterize instead
; fluid-let has issues with continuations and threads</code></pre>
        <br/>
        <li><code>let-syntax</code> and <code>letrec-syntax</code> for local macros:</li>
<pre><code class="language-scheme line-numbers">; Local syntax binding
(let-syntax ([swap!
              (syntax-rules ()
                [(_ a b)
                 (let ([tmp a])
                   (set! a b)
                   (set! b tmp))])])
  (define x 1)
  (define y 2)
  (swap! x y)
  (list x y))               ; (2 1)

; letrec-syntax for mutually recursive macros
(letrec-syntax
  ([my-or
    (syntax-rules ()
      [(_) #f]
      [(_ e) e]
      [(_ e1 e2 ...)
       (let ([t e1])
         (if t t (my-or e2 ...)))])]
   [my-and
    (syntax-rules ()
      [(_) #t]
      [(_ e) e]
      [(_ e1 e2 ...)
       (if e1 (my-and e2 ...) #f)])])
  (my-and (my-or #f 1) (my-or 2 #f)))  ; 2</code></pre>
        <br/>
        <li><code>case-lambda</code> for variable arity:</li>
<pre><code class="language-scheme line-numbers">; Different bodies for different arities
(define greet
  (case-lambda
    [() (greet "World")]
    [(name) (printf "Hello, ~a!~n" name)]
    [(greeting name) (printf "~a, ~a!~n" greeting name)]))

(greet)                     ; "Hello, World!"
(greet "Alice")             ; "Hello, Alice!"
(greet "Goodbye" "Bob")     ; "Goodbye, Bob!"

; With rest arguments
(define sum
  (case-lambda
    [() 0]
    [(x) x]
    [(x y) (+ x y)]
    [(x y . rest) (apply + x y rest)]))

(sum)                       ; 0
(sum 1)                     ; 1
(sum 1 2)                   ; 3
(sum 1 2 3 4 5)             ; 15</code></pre>
        <br/>
        <li><code>receive</code> for multiple values (SRFI-8 style):</li>
<pre><code class="language-scheme line-numbers">; receive binds multiple values more concisely
; (not standard, but can be defined)
(define-syntax receive
  (syntax-rules ()
    [(_ formals expr body ...)
     (call-with-values
       (lambda () expr)
       (lambda formals body ...))]))

(receive (q r) (div-and-mod 17 5)
  (printf "~a remainder ~a~n" q r))

; With rest parameter
(receive (first . rest) (values 1 2 3 4)
  (list first rest))        ; (1 (2 3 4))</code></pre>
        </ul>
        <br/>
        <br/>


    <li>Summary of binding forms:</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Form</th>
            <th>Scope</th>
            <th>Evaluation</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>define</code></td>
            <td>Top-level or local</td>
            <td>Immediate</td>
            <td>Variables and procedures</td>
        </tr>
        <tr>
            <td><code>let</code></td>
            <td>Local</td>
            <td>Parallel</td>
            <td>Independent bindings</td>
        </tr>
        <tr>
            <td><code>let*</code></td>
            <td>Local</td>
            <td>Sequential</td>
            <td>Dependent bindings</td>
        </tr>
        <tr>
            <td><code>letrec</code></td>
            <td>Local</td>
            <td>Recursive</td>
            <td>Mutually recursive procedures</td>
        </tr>
        <tr>
            <td><code>letrec*</code></td>
            <td>Local</td>
            <td>Sequential + recursive</td>
            <td>Recursive with order guarantees</td>
        </tr>
        <tr>
            <td><code>let-values</code></td>
            <td>Local</td>
            <td>Parallel</td>
            <td>Multiple value bindings</td>
        </tr>
        <tr>
            <td><code>let*-values</code></td>
            <td>Local</td>
            <td>Sequential</td>
            <td>Chained multiple values</td>
        </tr>
        <tr>
            <td><code>define-values</code></td>
            <td>Top-level or local</td>
            <td>Immediate</td>
            <td>Multiple value definitions</td>
        </tr>
        <tr>
            <td><code>parameterize</code></td>
            <td>Dynamic</td>
            <td>For dynamic extent</td>
            <td>Fluid/dynamic bindings</td>
        </tr>
        <tr>
            <td><code>let-syntax</code></td>
            <td>Local</td>
            <td>Compile-time</td>
            <td>Local macros</td>
        </tr>
    </tbody>
</table>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-control-structures">Control Structures in Chez Scheme</h3>
<ol>

    <li>Conditionals</li>
    <br/>
    <ul>
        <li><code>if</code> is the fundamental conditional:</li>
<pre><code class="language-scheme line-numbers">; Basic if with two branches
(if (> 5 3)
    'yes
    'no)                    ; yes

; Without else branch (returns unspecified if false)
(if (> 5 3)
    (display "5 is greater"))

; Multiple expressions require begin
(if (even? 4)
    (begin
      (display "It's even")
      (newline)
      'even)
    (begin
      (display "It's odd")
      (newline)
      'odd))

; Nested if
(define (sign n)
  (if (> n 0)
      'positive
      (if (< n 0)
          'negative
          'zero)))</code></pre>
        <br/>
        <li><code>cond</code> handles multiple conditions:</li>
<pre><code class="language-scheme line-numbers">; Basic cond
(define (grade score)
  (cond
    [(>= score 90) 'A]
    [(>= score 80) 'B]
    [(>= score 70) 'C]
    [(>= score 60) 'D]
    [else 'F]))

(grade 85)                  ; B

; Multiple expressions per clause (implicit begin)
(cond
  [(assq 'name data)
   => (lambda (pair)
        (display "Found: ")
        (display (cdr pair))
        (cdr pair))]
  [else
   (display "Not found")
   #f])

; Using => with procedure
(cond
  [(assoc 'key alist) => cdr]  ; Apply cdr to result if truthy
  [else 'not-found])

; Guard expressions
(define (safe-divide a b)
  (cond
    [(zero? b) 'division-by-zero]
    [(and (integer? a) (integer? b)) (quotient a b)]
    [else (/ a b)]))</code></pre>
        <br/>
        <li><code>case</code> dispatches on values:</li>
<pre><code class="language-scheme line-numbers">; Basic case
(define (day-type day)
  (case day
    [(saturday sunday) 'weekend]
    [(monday tuesday wednesday thursday friday) 'weekday]
    [else 'unknown]))

(day-type 'saturday)        ; weekend
(day-type 'monday)          ; weekday

; Multiple values per clause
(define (vowel? c)
  (case c
    [(#\a #\e #\i #\o #\u
      #\A #\E #\I #\O #\U) #t]
    [else #f]))

; case uses eqv? for comparison
(case (+ 1 1)
  [(1) 'one]
  [(2) 'two]
  [(3) 'three]
  [else 'many])             ; two

; Numeric dispatch
(define (month-name n)
  (case n
    [(1) "January"]
    [(2) "February"]
    [(3) "March"]
    [(4) "April"]
    [(5) "May"]
    [(6) "June"]
    [(7) "July"]
    [(8) "August"]
    [(9) "September"]
    [(10) "October"]
    [(11) "November"]
    [(12) "December"]
    [else "Invalid month"]))</code></pre>
        <br/>
        <li><code>when</code> and <code>unless</code> for one-sided conditionals:</li>
<pre><code class="language-scheme line-numbers">; when executes body if test is true
(when (> x 0)
  (display "Positive")
  (newline)
  (process-positive x))

; Equivalent to:
(if (> x 0)
    (begin
      (display "Positive")
      (newline)
      (process-positive x)))

; unless executes body if test is false
(unless (null? lst)
  (display "Processing: ")
  (display (car lst))
  (newline))

; Equivalent to:
(when (not (null? lst))
  ...)

; Common patterns
(define (ensure-positive x)
  (unless (positive? x)
    (error 'ensure-positive "expected positive number" x))
  x)

(define (maybe-log message)
  (when (current-debug-mode)
    (fprintf (current-error-port) "DEBUG: ~a~n" message)))</code></pre>
        <br/>
        <li><code>and</code> and <code>or</code> with short-circuit evaluation:</li>
<pre><code class="language-scheme line-numbers">; and returns first false value or last value
(and #t #t #t)              ; #t
(and #t #f #t)              ; #f
(and 1 2 3)                 ; 3
(and)                       ; #t

; Short-circuit: stops at first false
(and (pair? x)
     (number? (car x))
     (> (car x) 0))         ; Safe - checks pair? first

; or returns first true value or last value
(or #f #f #t)               ; #t
(or #f #f #f)               ; #f
(or 1 2 3)                  ; 1
(or #f 'default)            ; default
(or)                        ; #f

; Short-circuit: stops at first true
(or (cached-value key)
    (compute-expensive-value key))

; Default values pattern
(define (greet name)
  (printf "Hello, ~a!~n" (or name "World")))

(greet "Alice")             ; Hello, Alice!
(greet #f)                  ; Hello, World!

; Validation chains
(define (valid-input? x)
  (and (string? x)
       (> (string-length x) 0)
       (< (string-length x) 100)
       (string-alphabetic? x)))</code></pre>
        <br/>
        <li><code>not</code> and <code>boolean</code> conversions:</li>
<pre><code class="language-scheme line-numbers">; not negates boolean
(not #f)                    ; #t
(not #t)                    ; #f
(not '())                   ; #f (only #f is false)
(not 0)                     ; #f (only #f is false)

; Double negation for boolean conversion
(not (not 'anything))       ; #t
(not (not #f))              ; #f

; Explicit boolean check
(define (boolean-value x)
  (if x #t #f))

; In Scheme, only #f is false
(if '() 'true 'false)       ; true
(if 0 'true 'false)         ; true
(if "" 'true 'false)        ; true</code></pre>
        <br/>
        <li><code>exclusive-cond</code> (Chez extension) for exhaustive cases:</li>
<pre><code class="language-scheme line-numbers">; exclusive-cond requires exactly one clause to match
; Useful for ensuring complete case coverage

(define (classify n)
  (exclusive-cond
    [(negative? n) 'negative]
    [(zero? n) 'zero]
    [(positive? n) 'positive]))

; Raises exception if no clause matches or multiple match</code></pre>
    </ul>
    <br/><br/>


    <li>Mapping and Folding</li>
    <br/>
    <ul>
        <li><code>map</code> applies a procedure to each element:</li>
<pre><code class="language-scheme line-numbers">; Single list
(map add1 '(1 2 3 4 5))     ; (2 3 4 5 6)

(map (lambda (x) (* x x)) '(1 2 3 4))
; (1 4 9 16)

; Multiple lists (must be same length)
(map + '(1 2 3) '(10 20 30))
; (11 22 33)

(map cons '(a b c) '(1 2 3))
; ((a . 1) (b . 2) (c . 3))

(map (lambda (x y z) (+ x y z))
     '(1 2 3)
     '(4 5 6)
     '(7 8 9))
; (12 15 18)

; map preserves list structure
(map list '(a b c) '(1 2 3))
; ((a 1) (b 2) (c 3))

; Nested mapping
(map (lambda (row)
       (map (lambda (x) (* x 2)) row))
     '((1 2 3) (4 5 6)))
; ((2 4 6) (8 10 12))</code></pre>
        <br/>
        <li><code>for-each</code> for side effects:</li>
<pre><code class="language-scheme line-numbers">; Like map but doesn't collect results
(for-each display '(1 2 3 4 5))
; Prints: 12345

(for-each
  (lambda (x)
    (printf "Processing ~a~n" x))
  '(a b c))
; Processing a
; Processing b
; Processing c

; Multiple lists
(for-each
  (lambda (name age)
    (printf "~a is ~a years old~n" name age))
  '("Alice" "Bob" "Carol")
  '(30 25 35))

; Returns unspecified value
(for-each display '(1 2 3))  ; Returns #<void></code></pre>
        <br/>
        <li><code>fold-left</code> accumulates left to right:</li>
<pre><code class="language-scheme line-numbers">; (fold-left proc init list)
; Computes: (proc (proc (proc init e1) e2) e3) ...

; Sum of list
(fold-left + 0 '(1 2 3 4 5))  ; 15

; Product
(fold-left * 1 '(1 2 3 4 5))  ; 120

; Building a list (reverses)
(fold-left (lambda (acc x) (cons x acc))
           '()
           '(1 2 3))        ; (3 2 1)

; Finding maximum
(fold-left max -inf.0 '(3 1 4 1 5 9 2 6))  ; 9

; Counting elements
(fold-left (lambda (count x)
             (if (even? x) (+ count 1) count))
           0
           '(1 2 3 4 5 6))  ; 3

; Multiple lists
(fold-left (lambda (acc x y) (+ acc (* x y)))
           0
           '(1 2 3)
           '(4 5 6))        ; 32 = 1*4 + 2*5 + 3*6

; Association list from two lists
(fold-left (lambda (acc k v) (cons (cons k v) acc))
           '()
           '(a b c)
           '(1 2 3))        ; ((c . 3) (b . 2) (a . 1))</code></pre>
        <br/>
        <li><code>fold-right</code> accumulates right to left:</li>
<pre><code class="language-scheme line-numbers">; (fold-right proc init list)
; Computes: (proc e1 (proc e2 (proc e3 init))) ...

; Building a list (preserves order)
(fold-right cons '() '(1 2 3))
; (1 2 3)

; Append implementation
(define (my-append lst1 lst2)
  (fold-right cons lst2 lst1))

(my-append '(1 2 3) '(4 5 6))  ; (1 2 3 4 5 6)

; Flatten one level
(fold-right append '() '((1 2) (3 4) (5 6)))
; (1 2 3 4 5 6)

; Filter implementation
(define (my-filter pred lst)
  (fold-right
    (lambda (x acc)
      (if (pred x) (cons x acc) acc))
    '()
    lst))

(my-filter even? '(1 2 3 4 5 6))  ; (2 4 6)

; Map implementation
(define (my-map proc lst)
  (fold-right
    (lambda (x acc)
      (cons (proc x) acc))
    '()
    lst))

(my-map add1 '(1 2 3))      ; (2 3 4)</code></pre>
        <br/>
        <li><code>filter</code>, <code>partition</code>, and <code>remove</code>:</li>
<pre><code class="language-scheme line-numbers">; filter keeps elements satisfying predicate
(filter even? '(1 2 3 4 5 6))
; (2 4 6)

(filter (lambda (x) (> x 3)) '(1 2 3 4 5))
; (4 5)

(filter string? '(1 "a" 2 "b" 3))
; ("a" "b")

; partition splits into matching and non-matching
(partition even? '(1 2 3 4 5 6))
; Returns two values: (2 4 6) and (1 3 5)

(let-values ([(evens odds) (partition even? '(1 2 3 4 5 6))])
  (printf "Evens: ~a, Odds: ~a~n" evens odds))

; remove/remp removes elements
(remove 3 '(1 2 3 4 3 5))   ; (1 2 4 5) - uses equal?
(remv 3 '(1 2 3 4 3 5))     ; (1 2 4 5) - uses eqv?
(remq 'a '(a b a c a))      ; (b c) - uses eq?

(remp even? '(1 2 3 4 5 6)) ; (1 3 5) - removes if pred true

; remove duplicates (Chez extension)
(remove-duplicates '(1 2 1 3 2 4))  ; (1 2 3 4)</code></pre>
        <br/>
        <li><code>find</code>, <code>exists</code>, and <code>for-all</code>:</li>
<pre><code class="language-scheme line-numbers">; find returns first match or #f
(find even? '(1 3 5 6 7))   ; 6
(find even? '(1 3 5 7))     ; #f

(find (lambda (x) (> x 10)) '(5 8 12 3))  ; 12

; exists checks if any element satisfies predicate
(exists even? '(1 3 5 6 7)) ; #t
(exists even? '(1 3 5 7 9)) ; #f

; Multiple lists - true if any tuple satisfies
(exists < '(1 2 3) '(2 2 2))  ; #t (1 < 2)

; for-all checks if all elements satisfy predicate
(for-all even? '(2 4 6 8))  ; #t
(for-all even? '(2 4 5 8))  ; #f

; Multiple lists
(for-all < '(1 2 3) '(2 3 4))  ; #t (all pairs satisfy <)

; Short-circuit behavior
(for-all
  (lambda (x)
    (printf "Checking ~a~n" x)
    (even? x))
  '(2 4 5 8))
; Prints: Checking 2, Checking 4, Checking 5
; Returns: #f (stops at first failure)</code></pre>
        <br/>
        <li><code>map</code> variants and <code>andmap</code>/<code>ormap</code>:</li>
<pre><code class="language-scheme line-numbers">; andmap - like for-all but returns last value
(andmap even? '(2 4 6))     ; #t
(andmap values '(1 2 3))    ; 3

; ormap - like exists but returns the actual value
(ormap (lambda (x) (and (even? x) x))
       '(1 3 5 6 7))        ; 6

; vector-map for vectors
(vector-map add1 '#(1 2 3 4))
; #(2 3 4 5)

(vector-map + '#(1 2 3) '#(10 20 30))
; #(11 22 33)

; string-map for strings (character by character)
(define (string-map proc str)
  (list->string
    (map proc (string->list str))))

; hash table mapping
(define ht (make-eq-hashtable))
(hashtable-set! ht 'a 1)
(hashtable-set! ht 'b 2)

(vector-map
  (lambda (k) (cons k (hashtable-ref ht k #f)))
  (hashtable-keys ht))</code></pre>
        <br/>
        <li>List comprehension patterns:</li>
<pre><code class="language-scheme line-numbers">; Cartesian product
(define (cartesian-product lst1 lst2)
  (apply append
    (map (lambda (x)
           (map (lambda (y) (list x y))
                lst2))
         lst1)))

(cartesian-product '(a b) '(1 2 3))
; ((a 1) (a 2) (a 3) (b 1) (b 2) (b 3))

; Filter-map (map + filter)
(define (filter-map proc lst)
  (fold-right
    (lambda (x acc)
      (let ([result (proc x)])
        (if result
            (cons result acc)
            acc)))
    '()
    lst))

(filter-map (lambda (x)
              (and (even? x) (* x 2)))
            '(1 2 3 4 5))   ; (4 8)

; Zip multiple lists
(define (zip . lists)
  (apply map list lists))

(zip '(1 2 3) '(a b c) '(x y z))
; ((1 a x) (2 b y) (3 c z))

; Enumerate with index
(define (enumerate lst)
  (let loop ([lst lst] [i 0])
    (if (null? lst)
        '()
        (cons (cons i (car lst))
              (loop (cdr lst) (+ i 1))))))

(enumerate '(a b c))        ; ((0 . a) (1 . b) (2 . c))</code></pre>
    </ul>
    <br/><br/>


    <li>Continuations</li>
    <br/>
    <ul>
        <li><code>call/cc</code> (call-with-current-continuation) captures control:</li>
<pre><code class="language-scheme line-numbers">; Basic call/cc
(call/cc
  (lambda (k)
    (+ 1 (k 42))))          ; 42 (jumps out, skipping + 1)

; Early exit from recursion
(define (find-first pred lst)
  (call/cc
    (lambda (return)
      (for-each
        (lambda (x)
          (when (pred x)
            (return x)))
        lst)
      #f)))

(find-first even? '(1 3 5 6 7 8))  ; 6

; The continuation represents "the rest of the computation"
(+ 1 (call/cc (lambda (k) (* 2 (k 3)))))
; k is "add 1 to the result"
; (k 3) means "add 1 to 3" = 4</code></pre>
        <br/>
        <li>Saving and reusing continuations:</li>
<pre><code class="language-scheme line-numbers">; Store continuation for later use
(define saved-k #f)

(+ 1 (call/cc
       (lambda (k)
         (set! saved-k k)
         2)))               ; 3

; Resume the computation with different value
(saved-k 10)                ; 11
(saved-k 100)               ; 101

; Continuations can be called multiple times
(define (make-generator lst)
  (define current lst)
  (lambda ()
    (call/cc
      (lambda (return)
        (for-each
          (lambda (x)
            (call/cc
              (lambda (resume)
                (set! current resume)
                (return x))))
          current)
        (return 'done)))))

(define gen (make-generator '(1 2 3)))
(gen)                       ; 1
(gen)                       ; 2
(gen)                       ; 3
(gen)                       ; done</code></pre>
        <br/>
        <li>Implementing control structures with continuations:</li>
<pre><code class="language-scheme line-numbers">; Return (early exit)
(define (process-items items)
  (call/cc
    (lambda (return)
      (for-each
        (lambda (item)
          (when (error-item? item)
            (return 'error))
          (process item))
        items)
      'success)))

; Break and continue for loops
(define-syntax while-break
  (syntax-rules ()
    [(_ test body ...)
     (call/cc
       (lambda (break)
         (let loop ()
           (when test
             body ...
             (loop)))))]))

; Exception-like behavior
(define (with-exception-handler handler thunk)
  (call/cc
    (lambda (k)
      (let ([raise (lambda (exn) (k (handler exn)))])
        (thunk raise)))))

(with-exception-handler
  (lambda (e) (printf "Error: ~a~n" e) 'error)
  (lambda (raise)
    (raise "something went wrong")
    'never-reached))</code></pre>
        <br/>
        <li><code>call/1cc</code> for one-shot continuations:</li>
<pre><code class="language-scheme line-numbers">; call/1cc creates a one-shot continuation (more efficient)
(call/1cc
  (lambda (k)
    (k 42)))                ; 42

; One-shot means it can only be called once
(define one-shot-k #f)

(call/1cc
  (lambda (k)
    (set! one-shot-k k)
    'initial))              ; initial

(one-shot-k 'resumed)       ; resumed
; (one-shot-k 'again)       ; ERROR: already used

; Use call/1cc when you only need escape continuation
(define (find-first-1cc pred lst)
  (call/1cc
    (lambda (return)
      (for-each
        (lambda (x)
          (when (pred x) (return x)))
        lst)
      #f)))</code></pre>
        <br/>
        <li><code>dynamic-wind</code> for guaranteed cleanup:</li>
<pre><code class="language-scheme line-numbers">; (dynamic-wind before thunk after)
; before and after run on entry/exit, even with continuations

(dynamic-wind
  (lambda () (display "entering\n"))
  (lambda () (display "body\n") 42)
  (lambda () (display "leaving\n")))
; Prints: entering, body, leaving
; Returns: 42

; Resource management
(define (with-file filename proc)
  (let ([port #f])
    (dynamic-wind
      (lambda () (set! port (open-input-file filename)))
      (lambda () (proc port))
      (lambda () (close-port port)))))

(with-file "data.txt"
  (lambda (port)
    (get-line port)))

; Re-entry also triggers before/after
(define k #f)
(dynamic-wind
  (lambda () (printf "enter~n"))
  (lambda ()
    (call/cc (lambda (c) (set! k c)))
    (printf "body~n"))
  (lambda () (printf "exit~n")))
; First: enter, body, exit

(k 'resume)
; Re-entry: enter, body, exit</code></pre>
        <br/>
        <li>Continuation marks (for stack inspection):</li>
<pre><code class="language-scheme line-numbers">; Continuation marks attach data to continuations
(define trace-key (make-continuation-mark-key 'trace))

(define (traced-call name thunk)
  (with-continuation-mark trace-key name
    (thunk)))

(define (get-trace)
  (continuation-mark-set->list
    (current-continuation-marks)
    trace-key))

(traced-call 'outer
  (lambda ()
    (traced-call 'middle
      (lambda ()
        (traced-call 'inner
          (lambda ()
            (get-trace)))))))
; (inner middle outer)

; Useful for debugging, profiling, dynamic scope</code></pre>
        <br/>
        <li><code>let/cc</code> and <code>let/1cc</code> shorthand:</li>
<pre><code class="language-scheme line-numbers">; Chez provides convenient shorthand
(let/cc k
  (+ 1 (k 42)))             ; 42

; Equivalent to:
(call/cc (lambda (k) (+ 1 (k 42))))

; One-shot version
(let/1cc k
  (when (problem?)
    (k 'error))
  'success)

; Common idiom: early return
(define (validate data)
  (let/cc return
    (unless (list? data)
      (return "must be a list"))
    (unless (> (length data) 0)
      (return "must be non-empty"))
    (unless (for-all number? data)
      (return "must contain only numbers"))
    #t))</code></pre>
        <br/>
        <li>Coroutines with continuations:</li>
<pre><code class="language-scheme line-numbers">; Simple coroutine implementation
(define (make-coroutine proc)
  (let ([local-cont #f]
        [resume-cont #f])

    (define (yield value)
      (call/cc
        (lambda (k)
          (set! local-cont k)
          (resume-cont value))))

    (define (resume value)
      (call/cc
        (lambda (k)
          (set! resume-cont k)
          (if local-cont
              (local-cont value)
              (proc yield)))))

    resume))

; Usage
(define counter
  (make-coroutine
    (lambda (yield)
      (let loop ([n 0])
        (yield n)
        (loop (+ n 1))))))

(counter 'start)            ; 0
(counter 'next)             ; 1
(counter 'next)             ; 2</code></pre>
    </ul>
    <br/><br/>


    <li>Engines</li>
    <br/>
    <ul>
        <li>Engines provide timed preemption for computations:</li>
<pre><code class="language-scheme line-numbers">; (make-engine thunk) creates an engine
; An engine is a computation with a fuel limit

(define eng
  (make-engine
    (lambda ()
      (let loop ([n 0])
        (loop (+ n 1))))))  ; Infinite loop

; Run engine with fuel (ticks)
; Returns via complete or expire procedure
(eng 1000
     (lambda (ticks value)     ; complete: finished with fuel left
       (printf "Completed with ~a ticks, value: ~a~n" ticks value))
     (lambda (new-engine)      ; expire: ran out of fuel
       (printf "Expired, can resume~n")
       new-engine))

; The engine mechanism:
; - Allocate fuel (ticks)
; - Run until fuel exhausted or computation completes
; - If expired, get new engine to continue</code></pre>
        <br/>
        <li>Basic engine usage:</li>
<pre><code class="language-scheme line-numbers">; Engine that completes
(define eng1
  (make-engine
    (lambda ()
      (+ 1 2 3))))

(eng1 100
      (lambda (ticks val)
        (printf "Done! Result: ~a, Remaining: ~a~n" val ticks))
      (lambda (e)
        (printf "Expired~n")))
; Done! Result: 6, Remaining: ~90

; Engine that needs more fuel
(define eng2
  (make-engine
    (lambda ()
      (let loop ([n 0] [sum 0])
        (if (= n 1000000)
            sum
            (loop (+ n 1) (+ sum n)))))))

; May need multiple runs
(define (run-to-completion engine fuel)
  (engine fuel
          (lambda (ticks value)
            (printf "Complete: ~a~n" value)
            value)
          (lambda (new-engine)
            (printf "Continuing...~n")
            (run-to-completion new-engine fuel))))

(run-to-completion eng2 10000)</code></pre>
        <br/>
        <li>Implementing timeouts with engines:</li>
<pre><code class="language-scheme line-numbers">; Run computation with timeout
(define (with-timeout fuel thunk default)
  ((make-engine thunk)
   fuel
   (lambda (ticks value) value)
   (lambda (engine) default)))

; Examples
(with-timeout 1000
              (lambda () (+ 1 2 3))
              'timeout)     ; 6

(with-timeout 100
              (lambda ()
                (let loop () (loop)))
              'timeout)     ; timeout

; Timeout with continuation for resumption
(define (with-timeout/resume fuel thunk)
  (let ([result #f]
        [remaining-engine #f])
    ((make-engine thunk)
     fuel
     (lambda (ticks value)
       (set! result (cons 'complete value)))
     (lambda (engine)
       (set! result 'expired)
       (set! remaining-engine engine)))
    (values result remaining-engine)))</code></pre>
        <br/>
        <li>Nested engines:</li>
<pre><code class="language-scheme line-numbers">; Engines can be nested
(define outer-engine
  (make-engine
    (lambda ()
      (define inner-engine
        (make-engine
          (lambda ()
            (let loop ([n 0])
              (if (= n 100)
                  'inner-done
                  (loop (+ n 1)))))))

      ; Run inner engine with portion of outer's fuel
      (inner-engine 50
                    (lambda (t v) (cons 'inner-complete v))
                    (lambda (e) 'inner-expired)))))

; Timer ticks are shared hierarchically
(outer-engine 200
              (lambda (t v) (printf "Outer complete: ~a~n" v))
              (lambda (e) (printf "Outer expired~n")))</code></pre>
        <br/>
        <li>Engine-based round-robin scheduler:</li>
<pre><code class="language-scheme line-numbers">; Simple cooperative multitasking
(define (make-scheduler quantum)
  (let ([ready-queue '()])

    (define (add-task thunk)
      (set! ready-queue
            (append ready-queue
                    (list (make-engine thunk)))))

    (define (run)
      (unless (null? ready-queue)
        (let ([current (car ready-queue)])
          (set! ready-queue (cdr ready-queue))
          (current quantum
                   (lambda (ticks value)
                     (printf "Task completed: ~a~n" value)
                     (run))
                   (lambda (new-engine)
                     (set! ready-queue
                           (append ready-queue (list new-engine)))
                     (run))))))

    (values add-task run)))

; Usage
(define-values (add-task run-scheduler)
  (make-scheduler 100))

(add-task (lambda () (printf "Task 1 running~n") 'task1))
(add-task (lambda () (printf "Task 2 running~n") 'task2))
(add-task (lambda ()
            (let loop ([n 3])
              (when (> n 0)
                (printf "Task 3 iteration ~a~n" n)
                (loop (- n 1))))
            'task3))

(run-scheduler)</code></pre>
        <br/>
        <li><code>engine-block</code> for voluntary yielding:</li>
<pre><code class="language-scheme line-numbers">; engine-block causes immediate expiration
(define yielding-engine
  (make-engine
    (lambda ()
      (printf "Phase 1~n")
      (engine-block)        ; Yield to scheduler
      (printf "Phase 2~n")
      (engine-block)
      (printf "Phase 3~n")
      'done)))

; Each run does one phase
(define (step engine)
  (engine 1000000           ; Plenty of fuel
          (lambda (t v) (printf "Complete: ~a~n" v) #f)
          (lambda (e) (printf "Yielded~n") e)))

(define e1 (step yielding-engine))  ; Phase 1, Yielded
(define e2 (step e1))               ; Phase 2, Yielded
(define e3 (step e2))               ; Phase 3, Complete: done</code></pre>
        <br/>
        <li><code>engine-return</code> for early completion:</li>
<pre><code class="language-scheme line-numbers">; engine-return immediately completes with value
(define early-exit-engine
  (make-engine
    (lambda ()
      (let loop ([n 0])
        (when (= n 50)
          (engine-return 'found-it))
        (loop (+ n 1))))))

(early-exit-engine 10000
                   (lambda (t v) (printf "Result: ~a~n" v))
                   (lambda (e) (printf "Expired~n")))
; Result: found-it</code></pre>
        <br/>
        <li>Timed computations with engines:</li>
<pre><code class="language-scheme line-numbers">; Benchmark with fixed fuel
(define (benchmark-ticks fuel thunk)
  (let ([start-fuel fuel])
    ((make-engine thunk)
     fuel
     (lambda (remaining-ticks value)
       (values value (- start-fuel remaining-ticks)))
     (lambda (engine)
       (values 'incomplete fuel)))))

(let-values ([(result ticks) (benchmark-ticks 10000
                                               (lambda ()
                                                 (fold-left + 0
                                                            (iota 1000))))])
  (printf "Result: ~a, Ticks used: ~a~n" result ticks))

; Adaptive execution - run until consistent result
(define (stable-compute thunk max-fuel tolerance)
  (let loop ([fuel 100])
    (if (> fuel max-fuel)
        'no-stable-result
        (let-values ([(r1 t1) (benchmark-ticks fuel thunk)]
                     [(r2 t2) (benchmark-ticks fuel thunk)])
          (if (and (not (eq? r1 'incomplete))
                   (not (eq? r2 'incomplete))
                   (equal? r1 r2))
              r1
              (loop (* fuel 2)))))))</code></pre>
        <br/>
        <li>Comparing engines with threads:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>Engines</th>
            <th>Threads</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Preemption</td>
            <td>Tick-based (deterministic)</td>
            <td>Time-based (non-deterministic)</td>
        </tr>
        <tr>
            <td>Scheduling</td>
            <td>Explicit in Scheme</td>
            <td>OS/runtime managed</td>
        </tr>
        <tr>
            <td>Parallelism</td>
            <td>None (cooperative)</td>
            <td>True parallelism possible</td>
        </tr>
        <tr>
            <td>State sharing</td>
            <td>Sequential access</td>
            <td>Concurrent (needs synchronization)</td>
        </tr>
        <tr>
            <td>Debugging</td>
            <td>Deterministic, reproducible</td>
            <td>Race conditions possible</td>
        </tr>
        <tr>
            <td>Use case</td>
            <td>Timeouts, simulation, fair scheduling</td>
            <td>I/O parallelism, CPU parallelism</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Sequencing and Iteration</li>
    <br/>
    <ul>
        <li><code>begin</code> sequences expressions:</li>
<pre><code class="language-scheme line-numbers">; begin evaluates expressions in order, returns last
(begin
  (display "First")
  (newline)
  (display "Second")
  (newline)
  42)                       ; Returns 42

; Implicit begin in lambda body
(lambda (x)
  (display "Computing...")
  (newline)
  (* x x))

; Implicit begin in cond/case clauses
(cond
  [(positive? x)
   (display "positive")
   x]
  [else
   (display "non-positive")
   0])</code></pre>
        <br/>
        <li><code>begin0</code> returns first value:</li>
<pre><code class="language-scheme line-numbers">; begin0 evaluates all but returns first value
(begin0
  (compute-result)
  (cleanup)
  (log-completion))

; Useful for returning value before side effects
(define (pop! stack-ref)
  (begin0
    (car (stack-ref))       ; Return this
    (stack-ref (cdr (stack-ref)))))  ; Then modify

; Compare:
(begin 1 2 3)               ; 3
(begin0 1 2 3)              ; 1</code></pre>
        <br/>
        <li><code>do</code> loop:</li>
<pre><code class="language-scheme line-numbers">; (do ((var init step) ...) (test result ...) body ...)

; Factorial
(do ([n 5 (- n 1)]
     [acc 1 (* acc n)])
    ((zero? n) acc))        ; 120

; Build reversed list
(do ([lst '(1 2 3 4 5) (cdr lst)]
     [result '() (cons (car lst) result)])
    ((null? lst) result))   ; (5 4 3 2 1)

; With body for side effects
(do ([i 0 (+ i 1)])
    ((= i 5))
  (printf "i = ~a~n" i))

; Nested loops
(do ([i 0 (+ i 1)])
    ((= i 3))
  (do ([j 0 (+ j 1)])
      ((= j 3))
    (printf "(~a,~a) " i j))
  (newline))</code></pre>
        <br/>
        <li>Recursion patterns:</li>
<pre><code class="language-scheme line-numbers">; Named let for tail-recursive loops
(let loop ([n 10] [acc 0])
  (if (zero? n)
      acc
      (loop (- n 1) (+ acc n))))  ; 55

; Mutual recursion
(letrec ([process-list
          (lambda (lst)
            (if (null? lst)
                '()
                (cons (process-item (car lst))
                      (process-list (cdr lst)))))]
         [process-item
          (lambda (item)
            (if (list? item)
                (process-list item)
                (* item 2)))])
  (process-list '(1 (2 3) 4)))  ; (2 (4 6) 8)

; Accumulator pattern
(define (reverse-acc lst)
  (let loop ([lst lst] [acc '()])
    (if (null? lst)
        acc
        (loop (cdr lst) (cons (car lst) acc)))))</code></pre>
    </ul>
    <br/><br/>


    <li>Delayed Evaluation</li>
    <br/>
    <ul>
        <li><code>delay</code> and <code>force</code> for lazy evaluation:</li>
<pre><code class="language-scheme line-numbers">; delay creates a promise
(define p (delay (begin (display "Computing!") (+ 1 2))))
; Nothing printed yet

; force evaluates the promise
(force p)                   ; Prints "Computing!", returns 3
(force p)                   ; Returns 3 (cached, no recomputation)

; Lazy infinite sequences
(define (integers-from n)
  (cons n (delay (integers-from (+ n 1)))))

(define naturals (integers-from 0))

(car naturals)              ; 0
(car (force (cdr naturals))) ; 1
(car (force (cdr (force (cdr naturals))))) ; 2

; Take from lazy list
(define (take-lazy n lazy-list)
  (if (zero? n)
      '()
      (cons (car lazy-list)
            (take-lazy (- n 1) (force (cdr lazy-list))))))

(take-lazy 10 naturals)     ; (0 1 2 3 4 5 6 7 8 9)</code></pre>
        <br/>
        <li>Streams (SRFI-41 style):</li>
<pre><code class="language-scheme line-numbers">; Stream primitives
(define-syntax stream-cons
  (syntax-rules ()
    [(_ a b) (cons a (delay b))]))

(define stream-car car)
(define (stream-cdr s) (force (cdr s)))
(define stream-null '())
(define stream-null? null?)

; Infinite stream of ones
(define ones (stream-cons 1 ones))

; Fibonacci stream
(define fibs
  (stream-cons 0
    (stream-cons 1
      (let loop ([a 0] [b 1])
        (let ([c (+ a b)])
          (stream-cons c (loop b c)))))))

; Stream operations
(define (stream-take n s)
  (if (or (zero? n) (stream-null? s))
      '()
      (cons (stream-car s)
            (stream-take (- n 1) (stream-cdr s)))))

(define (stream-filter pred s)
  (cond
    [(stream-null? s) stream-null]
    [(pred (stream-car s))
     (stream-cons (stream-car s)
                  (stream-filter pred (stream-cdr s)))]
    [else (stream-filter pred (stream-cdr s))]))

(stream-take 10 fibs)       ; (0 1 1 2 3 5 8 13 21 34)
(stream-take 5 (stream-filter even? fibs))  ; (0 2 8 34 144)</code></pre>
        <br/>
        <li>Memoization patterns:</li>
<pre><code class="language-scheme line-numbers">; Simple memoization with delay
(define (memoize thunk)
  (let ([promise (delay (thunk))])
    (lambda () (force promise))))

; Memoized expensive computation
(define expensive
  (memoize
    (lambda ()
      (display "Computing expensive result...")
      (newline)
      (fold-left + 0 (iota 1000000)))))

(expensive)                 ; Computes first time
(expensive)                 ; Returns cached value

; Memoization with arguments
(define (memoize-proc proc)
  (let ([cache (make-hashtable equal-hash equal?)])
    (lambda args
      (let ([cached (hashtable-ref cache args 'not-found)])
        (if (eq? cached 'not-found)
            (let ([result (apply proc args)])
              (hashtable-set! cache args result)
              result)
            cached)))))

(define fib
  (memoize-proc
    (lambda (n)
      (if (< n 2)
          n
          (+ (fib (- n 1)) (fib (- n 2)))))))

(fib 100)                   ; Fast due to memoization</code></pre>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-operations-objects">Operations on Objects in Chez Scheme</h3>
<ol>

    <li>Missing R6RS Type Predicates</li>
    <br/>
    <ul>
        <li>Chez Scheme provides additional type predicates beyond R6RS:</li>
<pre><code class="language-scheme line-numbers">; Atom predicate (not a pair)
(atom? 'x)                  ; #t
(atom? 5)                   ; #t
(atom? '())                 ; #t
(atom? '(a b))              ; #f

; List predicates
(list? '(1 2 3))            ; #t
(list? '(1 . 2))            ; #f (improper list)
(list? '())                 ; #t

; Proper list check (terminates with null)
(proper-list? '(1 2 3))     ; #t (from Chez, not in all Schemes)

; Chez-specific gensym predicate
(gensym? (gensym))          ; #t
(gensym? 'regular)          ; #f

; Mutable vs immutable
(mutable-string? (string #\a #\b))  ; #t
(immutable-string? "hello")         ; #t (literal strings)
(mutable-vector? (vector 1 2 3))    ; #t
(mutable-bytevector? (make-bytevector 10))  ; #t</code></pre>
        <br/>
        <li>Numeric type predicates:</li>
<pre><code class="language-scheme line-numbers">; Fixnum - small exact integers (fast)
(fixnum? 42)                ; #t
(fixnum? (expt 2 100))      ; #f (bignum)

; Bignum - arbitrary precision integers
(bignum? (expt 2 100))      ; #t
(bignum? 42)                ; #f

; Ratnum - exact rationals
(ratnum? 3/4)               ; #t
(ratnum? 0.75)              ; #f (flonum)

; Flonum - floating point
(flonum? 3.14)              ; #t
(flonum? 3)                 ; #f

; Cflonum - complex with flonum parts
(cflonum? 1.0+2.0i)         ; #t
(cflonum? 1+2i)             ; #f (exact complex)

; Fixnum range
(greatest-fixnum)           ; Platform dependent (e.g., 1152921504606846975)
(least-fixnum)              ; Platform dependent (e.g., -1152921504606846976)
(fixnum-width)              ; Usually 61 on 64-bit systems</code></pre>
        <br/>
        <li>Port and procedure predicates:</li>
<pre><code class="language-scheme line-numbers">; Port predicates
(port? (current-input-port))         ; #t
(input-port? (current-input-port))   ; #t
(output-port? (current-output-port)) ; #t
(binary-port? (open-bytevector-input-port #vu8()))  ; #t
(textual-port? (current-input-port)) ; #t

; Procedure predicates
(procedure? car)            ; #t
(procedure? (lambda (x) x)) ; #t
(procedure? 'car)           ; #f

; Code object (compiled procedure)
(code? (closure-code car))  ; #t

; Continuation predicates
(continuation? (call/cc values))  ; #t</code></pre>
        <br/>
        <li>Record and ftype predicates:</li>
<pre><code class="language-scheme line-numbers">; General record predicate
(record? (make-point 1 2))  ; #t (if point is a record type)

; Record-type descriptor
(record-type-descriptor? (record-rtd some-record))  ; #t

; Ftype pointer
(ftype-pointer? ptr)        ; #t if ftype pointer

; Condition predicates (from exception system)
(condition? (make-who-condition 'test))  ; #t
(who-condition? (make-who-condition 'test))  ; #t</code></pre>
        <br/>
        <li>Miscellaneous predicates:</li>
<pre><code class="language-scheme line-numbers">; Eq-hashtable vs general hashtable
(eq-hashtable? (make-eq-hashtable))       ; #t
(hashtable? (make-eq-hashtable))          ; #t
(hashtable? (make-hashtable equal-hash equal?))  ; #t

; Box predicate
(box? (box 42))             ; #t
(box? 42)                   ; #f

; Weak pair
(weak-pair? (weak-cons 'a 'b))  ; #t
(weak-pair? (cons 'a 'b))       ; #f

; Ephemeron
(ephemeron-pair? (ephemeron-cons 'key 'value))  ; #t

; Thread predicates
(thread? (fork-thread (lambda () #t)))  ; #t (in threaded Chez)
(mutex? (make-mutex))       ; #t
(condition? (make-condition))  ; #t (thread condition, not exception)</code></pre>
    </ul>
    <br/><br/>


    <li>Pairs and Lists</li>
    <br/>
    <ul>
        <li>Basic pair operations:</li>
<pre><code class="language-scheme line-numbers">; Construction
(cons 'a 'b)                ; (a . b)
(cons 1 (cons 2 (cons 3 '())))  ; (1 2 3)

; Access
(car '(a b c))              ; a
(cdr '(a b c))              ; (b c)

; Mutation
(define p (cons 1 2))
(set-car! p 10)
p                           ; (10 . 2)
(set-cdr! p 20)
p                           ; (10 . 20)

; Composition accessors
(caar '((a b) c))           ; a
(cadr '(a b c))             ; b
(cdar '((a b) c))           ; (b)
(cddr '(a b c))             ; (c)

; Up to four levels
(caaddr '(a (b (c d))))     ; c
(cddddr '(1 2 3 4 5 6))     ; (5 6)</code></pre>
        <br/>
        <li>List construction:</li>
<pre><code class="language-scheme line-numbers">; list creates a proper list
(list 1 2 3)                ; (1 2 3)
(list)                      ; ()
(list 'a (+ 1 2) "hello")   ; (a 3 "hello")

; list* creates improper list (last element is cdr)
(list* 1 2 3)               ; (1 2 . 3)
(list* 1 2 '(3 4))          ; (1 2 3 4)
(list* 'a)                  ; a

; cons* is alias for list*
(cons* 1 2 3 '())           ; (1 2 3)

; make-list creates list of repeated elements
(make-list 5 'x)            ; (x x x x x)
(make-list 3 0)             ; (0 0 0)

; iota creates numeric sequence (Chez extension)
(iota 5)                    ; (0 1 2 3 4)
(iota 5 1)                  ; (1 2 3 4 5)
(iota 5 0 2)                ; (0 2 4 6 8) - start, step</code></pre>
        <br/>
        <li>List access and search:</li>
<pre><code class="language-scheme line-numbers">; Length
(length '(a b c d))         ; 4
(length '())                ; 0

; Indexing
(list-ref '(a b c d) 2)     ; c
(list-tail '(a b c d) 2)    ; (c d)

; First and last
(car '(a b c))              ; a
(last-pair '(a b c))        ; (c)
(list-head '(a b c d) 2)    ; (a b) - Chez extension

; Membership (returns tail starting at match)
(memq 'b '(a b c))          ; (b c)
(memv 2 '(1 2 3))           ; (2 3)
(member "b" '("a" "b" "c")) ; ("b" "c")

(memp even? '(1 3 4 5))     ; (4 5)

; Association lists
(assq 'b '((a . 1) (b . 2) (c . 3)))   ; (b . 2)
(assv 2 '((1 . a) (2 . b) (3 . c)))    ; (2 . b)
(assoc "b" '(("a" . 1) ("b" . 2)))     ; ("b" . 2)

(assp (lambda (x) (> x 5)) '((3 . a) (7 . b) (2 . c)))  ; (7 . b)</code></pre>
        <br/>
        <li>List manipulation:</li>
<pre><code class="language-scheme line-numbers">; Append (creates new pairs except last)
(append '(a b) '(c d))      ; (a b c d)
(append '(a) '(b) '(c))     ; (a b c)
(append '(a b) 'c)          ; (a b . c)

; Reverse
(reverse '(a b c))          ; (c b a)

; Copy
(list-copy '(a b c))        ; New copy of list

; Sublist operations (Chez extensions)
(sublist '(a b c d e) 1 4)  ; (b c d)

; Remove elements
(remq 'b '(a b c b d))      ; (a c d)
(remv 2 '(1 2 3 2 4))       ; (1 3 4)
(remove "b" '("a" "b" "c")) ; ("a" "c")
(remp odd? '(1 2 3 4 5))    ; (2 4)

; Remove duplicates
(remq-duplicates '(a b a c b))  ; (a b c) - Chez extension</code></pre>
        <br/>
        <li>List transformation:</li>
<pre><code class="language-scheme line-numbers">; Flatten (Chez extension)
(flatten '((a b) (c (d e)) f))  ; (a b c d e f)

; Transpose
(define (transpose matrix)
  (apply map list matrix))
(transpose '((1 2 3) (4 5 6)))  ; ((1 4) (2 5) (3 6))

; Partition
(partition even? '(1 2 3 4 5 6))
; Values: (2 4 6) (1 3 5)

; Split at index
(split-at '(a b c d e) 3)   ; Values: (a b c) (d e) - SRFI-1 style

; Take and drop
(define (take lst n)
  (if (or (zero? n) (null? lst))
      '()
      (cons (car lst) (take (cdr lst) (- n 1)))))

(define (drop lst n)
  (if (or (zero? n) (null? lst))
      lst
      (drop (cdr lst) (- n 1))))

(take '(a b c d e) 3)       ; (a b c)
(drop '(a b c d e) 3)       ; (d e)</code></pre>
        <br/>
        <li>Weak pairs and ephemerons:</li>
<pre><code class="language-scheme line-numbers">; Weak pairs - car can be collected if not referenced elsewhere
(define wp (weak-cons 'key 'value))
(weak-pair? wp)             ; #t
(car wp)                    ; key (or #!bwp if collected)
(cdr wp)                    ; value
(bwp-object? (car wp))      ; #t if car was collected

; Ephemerons - value kept alive only if key is alive
(define ep (ephemeron-cons 'key 'value))
(ephemeron-pair? ep)        ; #t
(car ep)                    ; key
(cdr ep)                    ; value (collected with key)</code></pre>
    </ul>
    <br/><br/>


    <li>Characters</li>
    <br/>
    <ul>
        <li>Character predicates:</li>
<pre><code class="language-scheme line-numbers">; Basic predicate
(char? #\a)                 ; #t
(char? "a")                 ; #f

; Classification
(char-alphabetic? #\a)      ; #t
(char-numeric? #\5)         ; #t
(char-whitespace? #\space)  ; #t
(char-whitespace? #\tab)    ; #t
(char-whitespace? #\newline) ; #t

(char-upper-case? #\A)      ; #t
(char-lower-case? #\a)      ; #t
(char-title-case? #\x01C5)  ; #t (Unicode titlecase)

; General category
(char-general-category #\a) ; Ll (lowercase letter)
(char-general-category #\A) ; Lu (uppercase letter)
(char-general-category #\5) ; Nd (decimal number)
(char-general-category #\space)  ; Zs (space separator)</code></pre>
        <br/>
        <li>Character comparison:</li>
<pre><code class="language-scheme line-numbers">; Case-sensitive
(char=? #\a #\a)            ; #t
(char&lt;? #\a #\b)            ; #t
(char&lt;=? #\a #\a)           ; #t
(char&gt;? #\b #\a)            ; #t
(char&gt;=? #\b #\a)           ; #t

; Multiple arguments
(char&lt;? #\a #\b #\c)        ; #t

; Case-insensitive
(char-ci=? #\a #\A)         ; #t
(char-ci&lt;? #\a #\B)         ; #t
(char-ci&lt;=? #\A #\a)        ; #t
(char-ci&gt;? #\B #\a)         ; #t
(char-ci&gt;=? #\A #\a)        ; #t</code></pre>
        <br/>
        <li>Character conversion:</li>
<pre><code class="language-scheme line-numbers">; Case conversion
(char-upcase #\a)           ; #\A
(char-downcase #\A)         ; #\a
(char-titlecase #\a)        ; #\A
(char-foldcase #\A)         ; #\a

; Integer conversion (Unicode code point)
(char-&gt;integer #\a)         ; 97
(char-&gt;integer #\λ)         ; 955
(integer-&gt;char 97)          ; #\a
(integer-&gt;char 955)         ; #\λ

; Common conversions
(char-&gt;integer #\0)         ; 48
(char-&gt;integer #\9)         ; 57
(char-&gt;integer #\A)         ; 65
(char-&gt;integer #\Z)         ; 90
(char-&gt;integer #\a)         ; 97
(char-&gt;integer #\z)         ; 122

; Digit conversion helper
(define (char-&gt;digit c)
  (- (char-&gt;integer c) (char-&gt;integer #\0)))
(char-&gt;digit #\7)           ; 7
</code></pre>
        <br/>
        <li>Special character literals:</li>
<pre><code class="language-scheme line-numbers">; Named characters
#\nul                       ; Null (0)
#\alarm                     ; Bell (7)
#\backspace                 ; Backspace (8)
#\tab                       ; Tab (9)
#\linefeed                  ; Newline (10)
#\newline                   ; Newline (10)
#\vtab                      ; Vertical tab (11)
#\page                      ; Form feed (12)
#\return                    ; Carriage return (13)
#\esc                       ; Escape (27)
#\space                     ; Space (32)
#\delete                    ; Delete (127)

; Hex notation
#\x41                       ; #\A
#\x03BB                     ; #\λ (lambda)
#\x1F600                    ; 😀 (emoji)

; Unicode names (Chez extension)
#\GREEK_SMALL_LETTER_LAMBDA ; #\λ</code></pre>
    </ul>
    <br/><br/>


    <li>Strings</li>
    <br/>
    <ul>
        <li>String construction:</li>
<pre><code class="language-scheme line-numbers">; Literal strings (immutable)
"hello"
"hello\nworld"              ; With newline
"tab\there"                 ; With tab
"quote: \"text\""           ; With escaped quotes

; Make mutable string
(make-string 5 #\x)         ; "xxxxx"
(make-string 10)            ; 10 unspecified chars

; From characters
(string #\h #\e #\l #\l #\o)  ; "hello"

; From list
(list->string '(#\a #\b #\c))  ; "abc"

; Copy (creates mutable copy)
(string-copy "hello")       ; "hello" (mutable)

; Substring
(substring "hello world" 0 5)  ; "hello"
(substring "hello world" 6 11) ; "world"</code></pre>
        <br/>
        <li>String access and modification:</li>
<pre><code class="language-scheme line-numbers">; Length
(string-length "hello")     ; 5

; Access
(string-ref "hello" 1)      ; #\e

; Mutation (mutable strings only)
(define s (string-copy "hello"))
(string-set! s 0 #\H)
s                           ; "Hello"

; Fill
(define s (make-string 5))
(string-fill! s #\x)
s                           ; "xxxxx"

; Copy region
(define src "source")
(define dst (make-string 10 #\-))
(string-copy! src 0 dst 2 6)
dst                         ; "--source--"</code></pre>
        <br/>
        <li>String comparison:</li>
<pre><code class="language-scheme line-numbers">; Case-sensitive
(string=? "hello" "hello")  ; #t
(string&lt;? "abc" "abd")      ; #t
(string&lt;=? "abc" "abc")     ; #t
(string&gt;? "xyz" "abc")      ; #t
(string&gt;=? "xyz" "xyz")     ; #t

; Case-insensitive
(string-ci=? "Hello" "hello")  ; #t
(string-ci&lt;? "ABC" "abd")      ; #t

; Multiple arguments
(string&lt;? "a" "b" "c")      ; #t
</code></pre>
        <br/>
        <li>String searching and manipulation:</li>
<pre><code class="language-scheme line-numbers">; Append
(string-append "hello" " " "world")  ; "hello world"

; Concatenate (from list)
(apply string-append '("a" "b" "c"))  ; "abc"

; Case conversion
(string-upcase "hello")     ; "HELLO"
(string-downcase "HELLO")   ; "hello"
(string-titlecase "hello world")  ; "Hello World"
(string-foldcase "Hello")   ; "hello"

; Trimming (Chez extensions)
(string-trim "  hello  ")   ; "hello"
(string-trim-left "  hello")   ; "hello"
(string-trim-right "hello  ")  ; "hello"

; Searching
(define (string-contains haystack needle)
  (let ([h-len (string-length haystack)]
        [n-len (string-length needle)])
    (let loop ([i 0])
      (cond
        [(&gt; (+ i n-len) h-len) #f]
        [(string=? (substring haystack i (+ i n-len)) needle) i]
        [else (loop (+ i 1))]))))

(string-contains "hello world" "wor")  ; 6
</code></pre>
        <br/>
        <li>String conversion:</li>
<pre><code class="language-scheme line-numbers">; To/from list
(string-&gt;list "hello")      ; (#\h #\e #\l #\l #\o)
(list-&gt;string '(#\a #\b #\c))  ; "abc"

; To/from symbol
(string-&gt;symbol "hello")    ; hello
(symbol-&gt;string 'hello)     ; "hello"

; To/from number
(string-&gt;number "123")      ; 123
(string-&gt;number "3.14")     ; 3.14
(string-&gt;number "ff" 16)    ; 255
(string-&gt;number "101" 2)    ; 5
(string-&gt;number "not-a-number")  ; #f

(number-&gt;string 123)        ; "123"
(number-&gt;string 255 16)     ; "ff"
(number-&gt;string 5 2)        ; "101"

; Format to string
(format "~a + ~a = ~a" 1 2 3)  ; "1 + 2 = 3"
</code></pre>
        <br/>
        <li>String encoding:</li>
<pre><code class="language-scheme line-numbers">; UTF-8
(string-&gt;utf8 "hello")      ; #vu8(104 101 108 108 111)
(utf8-&gt;string #vu8(104 101 108 108 111))  ; "hello"

; UTF-16
(string-&gt;utf16 "hello" 'little)  ; Little-endian
(string-&gt;utf16 "hello" 'big)     ; Big-endian
(utf16-&gt;string bv 'little)

; UTF-32
(string-&gt;utf32 "hello" 'little)
(utf32-&gt;string bv 'little)

; Latin-1 (Chez extension)
(string-&gt;bytevector "hello" (make-transcoder (latin-1-codec)))
(bytevector-&gt;string bv (make-transcoder (latin-1-codec)))
</code></pre>
    </ul>
    <br/><br/>


    <li>Vectors</li>
    <br/>
    <ul>
        <li>Vector construction:</li>
<pre><code class="language-scheme line-numbers">; Literal vector
'#(1 2 3)                   ; #(1 2 3)
#(a b c)                    ; #(a b c)

; Make vector
(make-vector 5)             ; #(0 0 0 0 0) or unspecified
(make-vector 5 'x)          ; #(x x x x x)

; From elements
(vector 1 2 3)              ; #(1 2 3)
(vector 'a (+ 1 2) "hello") ; #(a 3 "hello")

; From list
(list->vector '(a b c))     ; #(a b c)

; Copy
(vector-copy '#(1 2 3))     ; #(1 2 3) (mutable)
</code></pre>
        <br/>
        <li>Vector access and modification:</li>
<pre><code class="language-scheme line-numbers">; Length
(vector-length '#(a b c d)) ; 4

; Access
(vector-ref '#(a b c d) 2)  ; c

; Mutation
(define v (vector 1 2 3))
(vector-set! v 1 'x)
v                           ; #(1 x 3)

; Fill
(define v (make-vector 5))
(vector-fill! v 'z)
v                           ; #(z z z z z)

; Copy region
(define src '#(a b c d e))
(define dst (make-vector 5 '-))
(vector-copy! src 1 dst 2 3)
dst                         ; #(- - b c d)</code></pre>
        <br/>
        <li>Vector operations:</li>
<pre><code class="language-scheme line-numbers">; Append (Chez extension)
(vector-append '#(1 2) '#(3 4))  ; #(1 2 3 4)

; To/from list
(vector->list '#(a b c))    ; (a b c)
(list->vector '(1 2 3))     ; #(1 2 3)

; Map (R6RS)
(vector-map add1 '#(1 2 3)) ; #(2 3 4)
(vector-map + '#(1 2 3) '#(10 20 30))  ; #(11 22 33)

; For-each
(vector-for-each
  (lambda (x) (printf "~a " x))
  '#(a b c))                ; Prints: a b c

; Sort (Chez extension)
(vector-sort < '#(3 1 4 1 5))  ; #(1 1 3 4 5)
(vector-sort! < (vector 3 1 4 1 5))  ; Sorts in place

; Subvector (Chez extension)
(subvector '#(a b c d e) 1 4)  ; #(b c d)</code></pre>
        <br/>
        <li>Immutable vectors:</li>
<pre><code class="language-scheme line-numbers">; Check mutability
(mutable-vector? (vector 1 2 3))      ; #t
(immutable-vector? '#(1 2 3))         ; Depends on context

; Create immutable copy
(vector->immutable-vector (vector 1 2 3))

; Attempting to mutate immutable vector raises exception
; (vector-set! '#(1 2 3) 0 'x)  ; Error</code></pre>
    </ul>
    <br/><br/>


    <li>Bytevectors</li>
    <br/>
    <ul>
        <li>Bytevector construction:</li>
<pre><code class="language-scheme line-numbers">; Literal
#vu8(1 2 3 255)             ; Bytevector of 4 bytes

; Make bytevector
(make-bytevector 10)        ; 10 bytes, unspecified values
(make-bytevector 10 0)      ; 10 zero bytes

; From u8 list
(u8-list->bytevector '(1 2 3 4))  ; #vu8(1 2 3 4)

; Copy
(bytevector-copy #vu8(1 2 3))</code></pre>
        <br/>
        <li>Single-byte access:</li>
<pre><code class="language-scheme line-numbers">; Length
(bytevector-length #vu8(1 2 3 4))  ; 4

; Unsigned byte access (0-255)
(bytevector-u8-ref #vu8(1 2 255) 2)   ; 255
(define bv (make-bytevector 4 0))
(bytevector-u8-set! bv 0 255)
bv                          ; #vu8(255 0 0 0)

; Signed byte access (-128 to 127)
(bytevector-s8-ref #vu8(255) 0)  ; -1 (two's complement)
(bytevector-s8-set! bv 1 -1)
bv                          ; #vu8(255 255 0 0)</code></pre>
        <br/>
        <li>Multi-byte access:</li>
<pre><code class="language-scheme line-numbers">; 16-bit access
(define bv (make-bytevector 8 0))

; Native endianness
(bytevector-u16-native-set! bv 0 1000)
(bytevector-u16-native-ref bv 0)   ; 1000

; Explicit endianness
(bytevector-u16-set! bv 2 1000 'little)
(bytevector-u16-set! bv 4 1000 'big)
(bytevector-u16-ref bv 2 'little)  ; 1000
(bytevector-u16-ref bv 4 'big)     ; 1000

; Signed 16-bit
(bytevector-s16-ref bv 0 'little)
(bytevector-s16-set! bv 0 -1000 'little)

; 32-bit and 64-bit similar
(bytevector-u32-ref bv 0 'little)
(bytevector-u32-set! bv 0 value 'little)
(bytevector-u64-ref bv 0 'little)
(bytevector-u64-set! bv 0 value 'little)

; Floating point
(bytevector-ieee-single-ref bv 0 'little)
(bytevector-ieee-single-set! bv 0 3.14 'little)
(bytevector-ieee-double-ref bv 0 'little)
(bytevector-ieee-double-set! bv 0 3.14159 'little)</code></pre>
        <br/>
        <li>Bytevector operations:</li>
<pre><code class="language-scheme line-numbers">; Copy region
(define src #vu8(1 2 3 4 5))
(define dst (make-bytevector 10 0))
(bytevector-copy! src 0 dst 5 5)
dst                         ; #vu8(0 0 0 0 0 1 2 3 4 5)

; Fill
(bytevector-fill! dst 255)
dst                         ; All 255s

; Equality
(bytevector=? #vu8(1 2 3) #vu8(1 2 3))  ; #t

; Conversion to/from list
(bytevector->u8-list #vu8(1 2 3))  ; (1 2 3)
(u8-list->bytevector '(1 2 3))    ; #vu8(1 2 3)

; Append (Chez extension)
(bytevector-append #vu8(1 2) #vu8(3 4))  ; #vu8(1 2 3 4)

; Truncate/extend (Chez extension)
(bytevector-truncate! bv 5)  ; Shorten to 5 bytes</code></pre>
        <br/>
        <li>Bytevector compression (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Compress bytevector
(define data #vu8(1 2 3 4 5 1 2 3 4 5 1 2 3 4 5))
(define compressed (bytevector-compress data))

; Uncompress
(define restored (bytevector-uncompress compressed))
(bytevector=? data restored)  ; #t</code></pre>
    </ul>
    <br/><br/>


    <li>Stencil Vectors</li>
    <br/>
    <ul>
        <li>Stencil vectors are specialized sparse vectors:</li>
<pre><code class="language-scheme line-numbers">; Stencil vectors store only non-default elements
; The "stencil" is a bitmask indicating which positions have values

; Create stencil vector
; Mask indicates which of 0-57 positions have values
(define sv (stencil-vector #b10101 'a 'b 'c))
; Positions 0, 2, 4 have values 'a, 'b, 'c

; Check if stencil vector
(stencil-vector? sv)        ; #t

; Get the mask
(stencil-vector-mask sv)    ; #b10101 = 21

; Length (number of actual values stored)
(stencil-vector-length sv)  ; 3

; Reference by stencil bit position
(stencil-vector-ref sv #b00001)  ; 'a (bit 0)
(stencil-vector-ref sv #b00100)  ; 'b (bit 2)
(stencil-vector-ref sv #b10000)  ; 'c (bit 4)</code></pre>
        <br/>
        <li>Stencil vector operations:</li>
<pre><code class="language-scheme line-numbers">; Update creates new stencil vector (immutable style)
(define sv2 (stencil-vector-update sv #b00010 'new))
; Now has values at positions 0, 1, 2, 4

; Truncate mask (remove positions)
(define sv3 (stencil-vector-truncate sv #b00101))
; Only positions 0 and 2 remain

; Check for specific bits
(fxlogbit? 0 (stencil-vector-mask sv))  ; #t
(fxlogbit? 1 (stencil-vector-mask sv))  ; #f
(fxlogbit? 2 (stencil-vector-mask sv))  ; #t

; Iterate over stencil vector
(define (stencil-vector-for-each proc sv)
  (let ([mask (stencil-vector-mask sv)])
    (let loop ([bit 0] [idx 0])
      (when (< bit 58)
        (when (fxlogbit? bit mask)
          (proc bit (stencil-vector-ref sv (fxsll 1 bit)))
          (loop (+ bit 1) (+ idx 1)))
        (unless (fxlogbit? bit mask)
          (loop (+ bit 1) idx))))))</code></pre>
        <br/>
        <li>Use cases for stencil vectors:</li>
<pre><code class="language-scheme line-numbers">; Stencil vectors are useful for:
; - Sparse data with known position range (0-57)
; - Record-like structures with optional fields
; - Compact representation of small sets

; Example: optional configuration fields
(define config-keys
  '((debug . 0) (verbose . 1) (output-file . 2)
    (input-file . 3) (timeout . 4)))

(define (make-config . options)
  (let loop ([opts options] [mask 0] [values '()])
    (if (null? opts)
        (apply stencil-vector mask (reverse values))
        (let* ([key (caar opts)]
               [val (cdar opts)]
               [bit (cdr (assq key config-keys))])
          (loop (cdr opts)
                (fxlogior mask (fxsll 1 bit))
                (cons val values))))))

(define cfg (make-config '(debug . #t) '(timeout . 30)))
(stencil-vector-mask cfg)   ; Shows which options are set</code></pre>
    </ul>
    <br/><br/>


    <li>Boxes</li>
    <br/>
    <ul>
        <li>Boxes are single-element mutable containers:</li>
<pre><code class="language-scheme line-numbers">; Create box
(box 42)                    ; #&42
(box 'hello)                ; #&hello
(box (list 1 2 3))          ; #&(1 2 3)

; Check if box
(box? (box 42))             ; #t
(box? 42)                   ; #f

; Access content
(unbox (box 42))            ; 42

; Modify content
(define b (box 1))
(set-box! b 2)
(unbox b)                   ; 2</code></pre>
        <br/>
        <li>Boxes for mutable state:</li>
<pre><code class="language-scheme line-numbers">; Counter using box
(define (make-counter)
  (let ([count (box 0)])
    (lambda ()
      (let ([current (unbox count)])
        (set-box! count (+ current 1))
        current))))

(define counter (make-counter))
(counter)                   ; 0
(counter)                   ; 1
(counter)                   ; 2

; Memoization cell
(define (make-lazy thunk)
  (let ([cell (box #f)]
        [computed? (box #f)])
    (lambda ()
      (unless (unbox computed?)
        (set-box! cell (thunk))
        (set-box! computed? #t))
      (unbox cell))))

(define expensive
  (make-lazy
    (lambda ()
      (display "Computing...")
      42)))

(expensive)                 ; Computing... 42
(expensive)                 ; 42 (cached)</code></pre>
        <br/>
        <li>Immutable boxes (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Create immutable box
(define ib (box-immutable 42))

; Check
(box? ib)                   ; #t
(immutable-box? ib)         ; #t
(mutable-box? ib)           ; #f

; Unbox works
(unbox ib)                  ; 42

; set-box! would raise exception
; (set-box! ib 100)         ; Error</code></pre>
    </ul>
    <br/><br/>


    <li>Symbols</li>
    <br/>
    <ul>
        <li>Symbol basics:</li>
<pre><code class="language-scheme line-numbers">; Symbol literals
'hello                      ; hello
'with-hyphen                ; with-hyphen
'CamelCase                  ; CamelCase (case preserved)
'|with spaces|              ; |with spaces|
'|has "quotes"|             ; |has "quotes"|

; Check if symbol
(symbol? 'hello)            ; #t
(symbol? "hello")           ; #f

; Convert to/from string
(symbol->string 'hello)     ; "hello"
(string->symbol "hello")    ; hello

; Symbols are interned (eq? comparable)
(eq? 'hello 'hello)         ; #t
(eq? (string->symbol "hello")
     (string->symbol "hello"))  ; #t</code></pre>
        <br/>
        <li>Gensyms (unique symbols):</li>
<pre><code class="language-scheme line-numbers">; Generate unique symbol
(gensym)                    ; #{g0}
(gensym)                    ; #{g1}

; With prefix
(gensym "temp")             ; #{temp2}

; With specific name
(gensym "x" "unique-id")    ; #{x unique-id}

; Check if gensym
(gensym? (gensym))          ; #t
(gensym? 'regular)          ; #f

; Gensyms are unique
(eq? (gensym) (gensym))     ; #f

; Get gensym components
(define g (gensym "prefix"))
(gensym->unique-string g)   ; The unique identifier part

; Gensyms in macros (hygiene)
(define-syntax with-temp
  (lambda (stx)
    (syntax-case stx ()
      [(_ body ...)
       (with-syntax ([temp (datum->syntax #'body (gensym "temp"))])
         #'(let ([temp #f])
             body ...))])))</code></pre>
        <br/>
        <li>Symbol properties (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Attach property to symbol
(putprop 'my-symbol 'color 'red)
(putprop 'my-symbol 'size 42)

; Retrieve property
(getprop 'my-symbol 'color)  ; red
(getprop 'my-symbol 'size)   ; 42
(getprop 'my-symbol 'missing)  ; #f

; Remove property
(remprop 'my-symbol 'color)
(getprop 'my-symbol 'color)  ; #f

; List all properties
(property-list 'my-symbol)  ; ((size . 42))

; Use case: metadata storage
(define (define-type name . properties)
  (for-each
    (lambda (prop)
      (putprop name (car prop) (cdr prop)))
    properties))

(define-type 'person
  '(fields . (name age))
  '(constructor . make-person))</code></pre>
        <br/>
        <li>Oblist (symbol table):</li>
<pre><code class="language-scheme line-numbers">; Access all interned symbols
(oblist)                    ; List of all symbols

; Find symbols matching pattern
(define (find-symbols pred)
  (filter pred (oblist)))

(find-symbols
  (lambda (s)
    (let ([str (symbol->string s)])
      (and (> (string-length str) 5)
           (char=? (string-ref str 0) #\m)))))
; All symbols starting with 'm' longer than 5 chars</code></pre>
    </ul>
    <br/><br/>


    <li>Void</li>
    <br/>
    <ul>
        <li>The void object represents "no useful value":</li>
<pre><code class="language-scheme line-numbers">; Void is the return value of side-effecting procedures
(void)                      ; #<void>
(display "hi")              ; Returns #<void>
(set! x 10)                 ; Returns #<void>
(vector-set! v 0 'x)        ; Returns #<void>

; Check for void
(void? (void))              ; #t (Chez extension)
(void? 42)                  ; #f
(void? #f)                  ; #f

; Create void explicitly
(void)                      ; #<void>

; Note: void is NOT false
(if (void) 'yes 'no)        ; yes
(not (void))                ; #f

; Common pattern: suppress return value
(define (do-something)
  (perform-action)
  (void))  ; Explicitly return void</code></pre>
        <br/>
        <li>Void vs other "nothing" values:</li>
<pre><code class="language-scheme line-numbers">; Different "empty" values
(void)                      ; #<void> - no return value
'()                         ; () - empty list
#f                          ; #f - boolean false
(eof-object)                ; #!eof - end of file

; All are distinct
(eq? (void) '())            ; #f
(eq? (void) #f)             ; #f
(null? (void))              ; #f
(not (void))                ; #f (void is truthy!)

; Only #f is false in conditionals
(if (void) 'truthy 'falsy)       ; truthy
(if '() 'truthy 'falsy)          ; truthy
(if #f 'truthy 'falsy)           ; falsy
(if (eof-object) 'truthy 'falsy) ; truthy</code></pre>
    </ul>
    <br/><br/>


    <li>Sorting</li>
    <br/>
    <ul>
        <li>List sorting:</li>
<pre><code class="language-scheme line-numbers">; sort (stable sort)
(sort < '(3 1 4 1 5 9 2 6)) ; (1 1 2 3 4 5 6 9)
(sort > '(3 1 4 1 5 9 2 6)) ; (9 6 5 4 3 2 1 1)

; With custom comparator
(sort (lambda (a b) (< (abs a) (abs b)))
      '(3 -1 4 -1 5 -9 2 6))
; (-1 -1 2 3 4 5 6 -9)

; Sort strings
(sort string&lt;? '("banana" "apple" "cherry"))
; ("apple" "banana" "cherry")

(sort string-ci&lt;? '("Banana" "apple" "CHERRY"))
; ("apple" "Banana" "CHERRY")

; Sort by key
(define (sort-by key lst)
  (sort (lambda (a b) (< (key a) (key b))) lst))

(sort-by car '((3 a) (1 b) (2 c)))
; ((1 b) (2 c) (3 a))

(sort-by string-length '("aaa" "b" "cc"))
; ("b" "cc" "aaa")</code></pre>
        <br/>
        <li>Vector sorting:</li>
<pre><code class="language-scheme line-numbers">; vector-sort returns new sorted vector
(vector-sort < '#(3 1 4 1 5 9 2 6))
; #(1 1 2 3 4 5 6 9)

; vector-sort! sorts in place
(define v (vector 3 1 4 1 5 9 2 6))
(vector-sort! < v)
v                           ; #(1 1 2 3 4 5 6 9)

; Partial sort (Chez extension)
(define v (vector 5 3 8 1 9 2 7 4 6))
(vector-sort! < v 2 7)      ; Sort only indices 2-6
v                           ; #(5 3 1 2 7 8 9 4 6)</code></pre>
        <br/>
        <li>Merge operations:</li>
<pre><code class="language-scheme line-numbers">; merge combines two sorted lists
(merge < '(1 3 5 7) '(2 4 6 8))
; (1 2 3 4 5 6 7 8)

; merge! destructively merges (Chez extension)
(define lst1 (list 1 3 5))
(define lst2 (list 2 4 6))
(merge! < lst1 lst2)        ; (1 2 3 4 5 6)

; Merge sort implementation
(define (merge-sort lst)
  (if (or (null? lst) (null? (cdr lst)))
      lst
      (let-values ([(left right) (split-list lst)])
        (merge < (merge-sort left) (merge-sort right)))))

(define (split-list lst)
  (let loop ([slow lst] [fast lst] [acc '()])
    (if (or (null? fast) (null? (cdr fast)))
        (values (reverse acc) slow)
        (loop (cdr slow) (cddr fast) (cons (car slow) acc)))))</code></pre>
        <br/>
        <li>Sorting stability:</li>
<pre><code class="language-scheme line-numbers">; Chez's sort is stable - equal elements maintain order
(sort (lambda (a b) (< (car a) (car b)))
      '((1 first) (2 second) (1 third) (2 fourth)))
; ((1 first) (1 third) (2 second) (2 fourth))

; Use for multi-key sorting
(define (multi-sort comparators lst)
  (fold-right
    (lambda (cmp lst)
      (sort cmp lst))
    lst
    comparators))

; Sort by name, then by age
(define people
  '((alice 30) (bob 25) (alice 25) (bob 30)))

(multi-sort
  (list (lambda (a b) (< (cadr a) (cadr b)))      ; age
        (lambda (a b) (string&lt;? (symbol->string (car a))
                                (symbol->string (car b))))) ; name
  people)
; ((alice 25) (alice 30) (bob 25) (bob 30))</code></pre>
    </ul>
    <br/><br/>


    <li>Hashtables</li>
    <br/>
    <ul>
        <li>Creating hashtables:</li>
<pre><code class="language-scheme line-numbers">; Eq hashtable (uses eq? for comparison)
(define ht-eq (make-eq-hashtable))

; Eqv hashtable (uses eqv?)
(define ht-eqv (make-eqv-hashtable))

; General hashtable (custom hash and equal)
(define ht-equal
  (make-hashtable equal-hash equal?))

; String hashtable
(define ht-string
  (make-hashtable string-hash string=?))

; Case-insensitive string hashtable
(define ht-ci
  (make-hashtable string-ci-hash string-ci=?))

; Symbol hashtable (Chez extension)
(define ht-sym (make-eq-hashtable))  ; Use eq? for symbols

; With initial size hint
(make-eq-hashtable 1000)    ; Preallocate for ~1000 entries</code></pre>
        <br/>
        <li>Basic operations:</li>
<pre><code class="language-scheme line-numbers">; Set value
(hashtable-set! ht 'key 'value)
(hashtable-set! ht "name" "Alice")
(hashtable-set! ht 42 "forty-two")

; Get value
(hashtable-ref ht 'key #f)  ; value or #f
(hashtable-ref ht 'missing #f)  ; #f
(hashtable-ref ht 'missing 'default)  ; default

; Check existence
(hashtable-contains? ht 'key)  ; #t
(hashtable-contains? ht 'missing)  ; #f

; Delete
(hashtable-delete! ht 'key)

; Size
(hashtable-size ht)         ; Number of entries

; Clear
(hashtable-clear! ht)</code></pre>
        <br/>
        <li>Hashtable iteration:</li>
<pre><code class="language-scheme line-numbers">; Get all keys
(hashtable-keys ht)         ; Returns vector of keys

; Get all values
(hashtable-values ht)       ; Returns vector of values

; Get entries (keys and values)
(hashtable-entries ht)      ; Returns 2 values: keys-vec, values-vec

; Iterate with for-each
(let-values ([(keys vals) (hashtable-entries ht)])
  (vector-for-each
    (lambda (k v)
      (printf "~a: ~a~n" k v))
    keys vals))

; Convert to association list
(define (hashtable->alist ht)
  (let-values ([(keys vals) (hashtable-entries ht)])
    (vector->list
      (vector-map cons keys vals))))

; Create from association list
(define (alist->hashtable alist)
  (let ([ht (make-eq-hashtable)])
    (for-each
      (lambda (pair)
        (hashtable-set! ht (car pair) (cdr pair)))
      alist)
    ht))</code></pre>
        <br/>
        <li>Update operations:</li>
<pre><code class="language-scheme line-numbers">; Update with procedure
(hashtable-update! ht 'count add1 0)
; If exists: apply add1 to current value
; If missing: use 0 as initial value

; Increment counter pattern
(define (increment-count! ht key)
  (hashtable-update! ht key add1 0))

(define counts (make-eq-hashtable))
(increment-count! counts 'a)  ; 1
(increment-count! counts 'a)  ; 2
(increment-count! counts 'b)  ; 1

; Accumulate in list
(define (add-to-list! ht key value)
  (hashtable-update! ht key
    (lambda (lst) (cons value lst))
    '()))

; Set if absent (Chez extension)
(hashtable-ref-cell ht 'key)  ; Returns cell or #f

; Cell operations for atomic updates
(define cell (hashtable-cell ht 'key 'default))
(car cell)                  ; key
(cdr cell)                  ; value
(set-cdr! cell 'new-value)  ; Update atomically</code></pre>
        <br/>
        <li>Weak and ephemeron hashtables:</li>
<pre><code class="language-scheme line-numbers">; Weak hashtable - keys can be garbage collected
(define wht (make-weak-eq-hashtable))
(hashtable-set! wht some-key 'value)
; If some-key becomes unreachable, entry is removed

; Weak-eqv hashtable
(define wht-eqv (make-weak-eqv-hashtable))

; Ephemeron hashtable - values kept only if keys alive
(define eht (make-ephemeron-eq-hashtable))
(define eht-eqv (make-ephemeron-eqv-hashtable))

; Use case: caching with automatic cleanup
(define cache (make-weak-eq-hashtable))

(define (cached-compute key compute-proc)
  (or (hashtable-ref cache key #f)
      (let ([result (compute-proc key)])
        (hashtable-set! cache key result)
        result)))</code></pre>
        <br/>
        <li>Hashtable copying and equivalence:</li>
<pre><code class="language-scheme line-numbers">; Copy hashtable
(hashtable-copy ht)         ; Immutable copy
(hashtable-copy ht #t)      ; Mutable copy

; Check equivalence
(hashtable-equivalence-function ht)  ; Returns equal?
(hashtable-hash-function ht)         ; Returns hash proc

; Check mutability
(hashtable-mutable? ht)     ; #t or #f

; Hashtable type predicates
(hashtable? ht)             ; #t
(eq-hashtable? ht-eq)       ; #t
(eqv-hashtable? ht-eqv)     ; #t (Chez extension)</code></pre>
    </ul>
    <br/><br/>


    <li>Record Types</li>
    <br/>
    <ul>
        <li>R6RS syntactic layer records:</li>
<pre><code class="language-scheme line-numbers">; Basic record definition
(define-record-type point
  (fields x y))

; Create instance
(make-point 3 4)            ; #<point>

; Access fields
(point-x (make-point 3 4))  ; 3
(point-y (make-point 3 4))  ; 4

; Predicate
(point? (make-point 3 4))   ; #t

; With mutable fields
(define-record-type mpoint
  (fields (mutable x)
          (mutable y)))

(define p (make-mpoint 1 2))
(mpoint-x-set! p 10)
(mpoint-x p)                ; 10</code></pre>
        <br/>
        <li>Record inheritance:</li>
<pre><code class="language-scheme line-numbers">; Parent record
(define-record-type shape
  (fields (immutable color)))

; Child record
(define-record-type (circle shape)
  (fields (immutable radius)))

(define c (make-circle 'red 5))
(shape-color c)             ; red
(circle-radius c)           ; 5
(shape? c)                  ; #t
(circle? c)                 ; #t

; Multiple inheritance levels
(define-record-type (filled-circle circle)
  (fields (immutable fill-pattern)))

(define fc (make-filled-circle 'blue 10 'solid))
(shape-color fc)            ; blue
(circle-radius fc)          ; 10
(filled-circle-fill-pattern fc)  ; solid</code></pre>
        <br/>
        <li>Custom constructors and protocols:</li>
<pre><code class="language-scheme line-numbers">; Custom constructor with protocol
(define-record-type point3d
  (fields x y z)
  (protocol
    (lambda (new)
      (case-lambda
        [(x y) (new x y 0)]         ; Default z to 0
        [(x y z) (new x y z)]))))

(make-point3d 1 2)          ; z defaults to 0
(make-point3d 1 2 3)        ; All specified

; Protocol with parent
(define-record-type (named-point point)
  (fields name)
  (protocol
    (lambda (pnew)
      (lambda (name x y)
        ((pnew x y) name)))))

(define np (make-named-point "origin" 0 0))
(point-x np)                ; 0
(named-point-name np)       ; "origin"

; Validation in protocol
(define-record-type positive-point
  (fields x y)
  (protocol
    (lambda (new)
      (lambda (x y)
        (unless (and (positive? x) (positive? y))
          (error 'make-positive-point "values must be positive"))
        (new x y)))))</code></pre>
        <br/>
        <li>Nongenerative and sealed records:</li>
<pre><code class="language-scheme line-numbers">; Nongenerative - same definition produces same type
(define-record-type point-ng
  (nongenerative point-ng-uid)
  (fields x y))

; Two definitions with same UID are the same type
; Useful for separate compilation

; Sealed - cannot be inherited
(define-record-type final-record
  (sealed #t)
  (fields value))

; (define-record-type (child final-record) ...)  ; Error!

; Opaque - internal structure hidden
(define-record-type opaque-record
  (opaque #t)
  (fields secret))

; record? returns #f for opaque records
; But type predicate still works</code></pre>
        <br/>
        <li>Chez Scheme record extensions:</li>
<pre><code class="language-scheme line-numbers">; Define-record (Chez legacy syntax)
(define-record person (name age))

; Automatically creates:
; make-person, person?, person-name, person-age
; set-person-name!, set-person-age! (mutable by default)

; Record type descriptors
(define rtd (record-type-descriptor person))
(record-type-name rtd)      ; person
(record-type-parent rtd)    ; #f
(record-type-field-names rtd)  ; (name age)

; Reflection
(record-rtd (make-person "Alice" 30))  ; Get RTD from instance

; Create record dynamically
(define p ((record-constructor rtd) "Bob" 25))
((record-accessor rtd 0) p) ; "Bob"
((record-mutator rtd 1) p 26)  ; Set age to 26</code></pre>
        <br/>
        <li>Record printing (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Custom record writer
(define-record-type point
  (fields x y))

(record-writer (record-type-descriptor point)
  (lambda (r port write?)
    (fprintf port "#<point ~a,~a>"
             (point-x r) (point-y r))))

(make-point 3 4)            ; #<point 3,4>

; Generic record printing
(record-print-procedure)    ; Current print procedure
(parameterize ([print-record #t])
  (printf "~s" (make-point 3 4)))  ; Shows structure</code></pre>
    </ul>
    <br/><br/>


    <li>Record Equality and Hashing</li>
    <br/>
    <ul>
        <li>Default record equality:</li>
<pre><code class="language-scheme line-numbers">; By default, records use eq? (identity)
(define-record-type point (fields x y))

(define p1 (make-point 3 4))
(define p2 (make-point 3 4))

(eq? p1 p1)                 ; #t
(eq? p1 p2)                 ; #f (different objects)
(eqv? p1 p2)                ; #f
(equal? p1 p2)              ; #f (by default)</code></pre>
        <br/>
        <li>Custom equality with record-equal-procedure:</li>
<pre><code class="language-scheme line-numbers">; Set custom equality for record type
(define-record-type point
  (fields x y))

(record-type-equal-procedure
  (record-type-descriptor point)
  (lambda (p1 p2 equal?)
    (and (equal? (point-x p1) (point-x p2))
         (equal? (point-y p1) (point-y p2)))))

; Now equal? works on points
(define p1 (make-point 3 4))
(define p2 (make-point 3 4))
(equal? p1 p2)              ; #t

; Recursive equality with equal? parameter
(define-record-type tree
  (fields value left right))

(record-type-equal-procedure
  (record-type-descriptor tree)
  (lambda (t1 t2 equal?)
    (and (equal? (tree-value t1) (tree-value t2))
         (equal? (tree-left t1) (tree-left t2))
         (equal? (tree-right t1) (tree-right t2)))))</code></pre>
        <br/>
        <li>Custom hashing with record-hash-procedure:</li>
<pre><code class="language-scheme line-numbers">; Set custom hash for record type
(record-type-hash-procedure
  (record-type-descriptor point)
  (lambda (p hash)
    (fxxor (hash (point-x p))
           (fxsll (hash (point-y p)) 16))))

; Now points can be hashtable keys with equal-hash
(define ht (make-hashtable equal-hash equal?))
(hashtable-set! ht (make-point 1 2) 'value)
(hashtable-ref ht (make-point 1 2) #f)  ; 'value

; Combined equal and hash for complex record
(define-record-type person
  (fields name age address))

(record-type-equal-procedure
  (record-type-descriptor person)
  (lambda (p1 p2 equal?)
    (and (equal? (person-name p1) (person-name p2))
         (equal? (person-age p1) (person-age p2))
         (equal? (person-address p1) (person-address p2)))))

(record-type-hash-procedure
  (record-type-descriptor person)
  (lambda (p hash)
    (fxxor (hash (person-name p))
           (fxxor (hash (person-age p))
                  (hash (person-address p))))))</code></pre>
        <br/>
        <li>Generic record comparison helpers:</li>
<pre><code class="language-scheme line-numbers">; Helper to compare all fields
(define (make-record-equal rtd)
  (let ([accessors (map (lambda (i)
                          (record-accessor rtd i))
                        (iota (length (record-type-field-names rtd))))])
    (lambda (r1 r2 equal?)
      (for-all (lambda (acc)
                 (equal? (acc r1) (acc r2)))
               accessors))))

; Helper to hash all fields
(define (make-record-hash rtd)
  (let ([accessors (map (lambda (i)
                          (record-accessor rtd i))
                        (iota (length (record-type-field-names rtd))))])
    (lambda (r hash)
      (fold-left (lambda (h acc)
                   (fxxor h (hash (acc r))))
                 0
                 accessors))))

; Apply to a record type
(let ([rtd (record-type-descriptor my-record)])
  (record-type-equal-procedure rtd (make-record-equal rtd))
  (record-type-hash-procedure rtd (make-record-hash rtd)))</code></pre>
        <br/>
        <li>Structural equality considerations:</li>
<pre><code class="language-scheme line-numbers">; Be careful with mutable fields
(define-record-type mutable-point
  (fields (mutable x) (mutable y)))

; If using as hashtable key, mutating changes hash!
(define ht (make-hashtable equal-hash equal?))
(define mp (make-mutable-point 1 2))

(hashtable-set! ht mp 'value)
(hashtable-ref ht mp #f)    ; 'value

(mutable-point-x-set! mp 100)  ; Mutation!
(hashtable-ref ht mp #f)    ; #f - hash changed!

; Solution: use immutable records as keys, or
; hash only immutable fields</code></pre>
    </ul>
    <br/><br/>


    <li>Procedures</li>
    <br/>
    <ul>
        <li>Procedure basics:</li>
<pre><code class="language-scheme line-numbers">; Check if procedure
(procedure? car)            ; #t
(procedure? (lambda (x) x)) ; #t
(procedure? '+)             ; #f (symbol, not procedure)
(procedure? +)              ; #t

; Apply procedure
(apply + '(1 2 3))          ; 6
(apply + 1 2 '(3 4))        ; 10
(apply list 'a 'b '(c d))   ; (a b c d)

; Procedure arity (Chez extension)
(procedure-arity car)       ; 1
(procedure-arity cons)      ; 2
(procedure-arity list)      ; -1 (variadic)
(procedure-arity +)         ; -1</code></pre>
        <br/>
        <li>Procedure introspection (Chez extensions):</li>
<pre><code class="language-scheme line-numbers">; Get procedure name
(define (my-proc x) x)
(#%$procedure-name my-proc)  ; my-proc (internal)

; Procedure source information
(#%$procedure-source-object my-proc)

; Get code object
(closure-code my-proc)      ; #&lt;code&gt;

; Code object properties
(define code (closure-code car))
(code? code)                ; #t

; Inspect closure variables
(define (make-adder n)
  (lambda (x) (+ x n)))

(define add5 (make-adder 5))
; add5 closes over n=5
</code></pre>
        <br/>
        <li>Procedure composition:</li>
<pre><code class="language-scheme line-numbers">; Compose procedures (right to left)
(define (compose . procs)
  (if (null? procs)
      values
      (let ([proc (car procs)]
            [rest (apply compose (cdr procs))])
        (lambda args
          (call-with-values
            (lambda () (apply rest args))
            proc)))))

(define add1-then-double
  (compose (lambda (x) (* x 2)) add1))

(add1-then-double 5)        ; 12 = (5+1)*2

; Pipeline (left to right)
(define (pipe . procs)
  (apply compose (reverse procs)))

(define process
  (pipe string-&gt;list
        (lambda (lst) (filter char-alphabetic? lst))
        list-&gt;string
        string-upcase))

(process "Hello, World! 123")  ; "HELLOWORLD"
</code></pre>
        <br/>
        <li>Currying and partial application:</li>
<pre><code class="language-scheme line-numbers">; Curry a binary procedure
(define (curry2 proc)
  (lambda (x)
    (lambda (y)
      (proc x y))))

(define currried-add (curry2 +))
((curried-add 3) 4)         ; 7

; Partial application
(define (partial proc . args)
  (lambda more-args
    (apply proc (append args more-args))))

(define add10 (partial + 10))
(add10 5)                   ; 15

(define greet (partial format "Hello, ~a!"))
(greet "World")             ; "Hello, World!"

; Right partial application
(define (partial-right proc . args)
  (lambda more-args
    (apply proc (append more-args args))))

(define halve (partial-right / 2))
(halve 10)                  ; 5
</code></pre>
        <br/>
        <li>Higher-order procedure utilities:</li>
<pre><code class="language-scheme line-numbers">; Negate a predicate
(define (negate pred)
  (lambda args
    (not (apply pred args))))

(define not-null? (negate null?))
(not-null? '(1 2))          ; #t
(not-null? '())             ; #f

; Complement (alias for negate)
(define complement negate)

; Conjoin predicates (and)
(define (conjoin . preds)
  (lambda (x)
    (for-all (lambda (p) (p x)) preds)))

(define positive-even?
  (conjoin positive? even?))

(positive-even? 4)          ; #t
(positive-even? -4)         ; #f

; Disjoin predicates (or)
(define (disjoin . preds)
  (lambda (x)
    (exists (lambda (p) (p x)) preds)))

(define number-or-string?
  (disjoin number? string?))

(number-or-string? 42)      ; #t
(number-or-string? "hi")    ; #t
(number-or-string? 'sym)    ; #f
</code></pre>
        <br/>
        <li>Procedure caching and memoization:</li>
<pre><code class="language-scheme line-numbers">; Simple memoization
(define (memoize proc)
  (let ([cache (make-hashtable equal-hash equal?)])
    (lambda args
      (let ([cached (hashtable-ref cache args 'not-found)])
        (if (eq? cached 'not-found)
            (let ([result (apply proc args)])
              (hashtable-set! cache args result)
              result)
            cached)))))

(define slow-fib
  (lambda (n)
    (if (&lt; n 2)
        n
        (+ (slow-fib (- n 1))
           (slow-fib (- n 2))))))

(define fast-fib (memoize slow-fib))

(time (slow-fib 35))        ; Slow
(time (fast-fib 35))        ; Fast (cached)

; Memoization with weak references
(define (memoize-weak proc)
  (let ([cache (make-weak-eq-hashtable)])
    (lambda args
      (let ([key (if (= (length args) 1)
                     (car args)
                     args)])
        (or (hashtable-ref cache key #f)
            (let ([result (apply proc args)])
              (hashtable-set! cache key result)
              result))))))
</code></pre>
        <br/>
        <li>Procedure tracing and debugging:</li>
<pre><code class="language-scheme line-numbers">; Wrap procedure with tracing
(define (trace-proc name proc)
  (lambda args
    (printf "~a called with ~s~n" name args)
    (let ([result (apply proc args)])
      (printf "~a returned ~s~n" name result)
      result)))

(define traced-add (trace-proc 'add +))
(traced-add 1 2 3)
; add called with (1 2 3)
; add returned 6

; Built-in trace (Chez)
(trace +)                   ; Enable tracing
(+ 1 2 3)                   ; Shows trace
(untrace +)                 ; Disable tracing

; Trace multiple
(trace car cdr cons)
(untrace car cdr cons)

; Count calls
(define (counted proc)
  (let ([count (box 0)])
    (values
      (lambda args
        (set-box! count (+ (unbox count) 1))
        (apply proc args))
      (lambda () (unbox count)))))

(define-values (counted-add get-count) (counted +))
(counted-add 1 2)
(counted-add 3 4)
(get-count)                 ; 2
</code></pre>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-numeric-operations">Numeric Operations in Chez Scheme</h3>
<ol>

    <li>Numeric Type Predicates</li>
    <br/>
    <ul>
        <li>General numeric predicates:</li>
<pre><code class="language-scheme line-numbers">; Check if number
(number? 42)                ; #t
(number? 3.14)              ; #t
(number? 3+4i)              ; #t
(number? "42")              ; #f

; Complex numbers (all numbers are complex)
(complex? 42)               ; #t
(complex? 3.14)             ; #t
(complex? 3+4i)             ; #t

; Real numbers (no imaginary part)
(real? 42)                  ; #t
(real? 3.14)                ; #t
(real? 3+4i)                ; #f
(real? 3+0i)                ; #t (imaginary part is 0)

; Rational numbers (exact ratio)
(rational? 42)              ; #t
(rational? 3/4)             ; #t
(rational? 3.14)            ; #t (flonums are rational)
(rational? +inf.0)          ; #f
(rational? +nan.0)          ; #f

; Integer (whole numbers)
(integer? 42)               ; #t
(integer? 42.0)             ; #t
(integer? 3.14)             ; #f
(integer? 3/4)              ; #f</code></pre>
        <br/>
        <li>Exactness predicates:</li>
<pre><code class="language-scheme line-numbers">; Exact numbers (precise representation)
(exact? 42)                 ; #t
(exact? 3/4)                ; #t
(exact? 3+4i)               ; #t (exact complex)
(exact? 3.14)               ; #f

; Inexact numbers (floating-point)
(inexact? 3.14)             ; #t
(inexact? 42)               ; #f
(inexact? 3.0+4.0i)         ; #t

; Exact integer predicate
(exact-integer? 42)         ; #t
(exact-integer? 42.0)       ; #f
(exact-integer? 3/4)        ; #f

; Exact non-negative integer
(exact-nonnegative-integer? 42)   ; #t
(exact-nonnegative-integer? -42)  ; #f
(exact-nonnegative-integer? 0)    ; #t

; Exact positive integer
(exact-positive-integer? 42)  ; #t
(exact-positive-integer? 0)   ; #f</code></pre>
        <br/>
        <li>Chez-specific type predicates:</li>
<pre><code class="language-scheme line-numbers">; Fixnum - small exact integers (fast)
(fixnum? 42)                ; #t
(fixnum? (expt 2 100))      ; #f (too large)
(fixnum? 3.14)              ; #f

; Fixnum bounds (platform-dependent)
(greatest-fixnum)           ; e.g., 1152921504606846975 (60-bit)
(least-fixnum)              ; e.g., -1152921504606846976
(fixnum-width)              ; e.g., 61 (including sign)

(fixnum? (greatest-fixnum)) ; #t
(fixnum? (+ (greatest-fixnum) 1))  ; #f (becomes bignum)

; Bignum - arbitrary precision integers
(bignum? (expt 2 100))      ; #t
(bignum? 42)                ; #f (fits in fixnum)

; Ratnum - exact ratios (not integers)
(ratnum? 3/4)               ; #t
(ratnum? 4/2)               ; #f (reduces to integer 2)
(ratnum? 0.75)              ; #f (flonum)

; Flonum - floating-point numbers
(flonum? 3.14)              ; #t
(flonum? 42)                ; #f
(flonum? 42.0)              ; #t
(flonum? +inf.0)            ; #t
(flonum? +nan.0)            ; #t

; Cflonum - complex with flonum parts
(cflonum? 3.0+4.0i)         ; #t
(cflonum? 3+4i)             ; #f (exact complex)
(cflonum? 3.14)             ; #f (real flonum)</code></pre>
        <br/>
        <li>Sign and comparison predicates:</li>
<pre><code class="language-scheme line-numbers">; Sign predicates
(positive? 42)              ; #t
(positive? -42)             ; #f
(positive? 0)               ; #f

(negative? -42)             ; #t
(negative? 42)              ; #f
(negative? 0)               ; #f

(zero? 0)                   ; #t
(zero? 0.0)                 ; #t
(zero? 0+0i)                ; #t
(zero? 1)                   ; #f

(nonnegative? 0)            ; #t (Chez extension)
(nonnegative? 42)           ; #t
(nonnegative? -1)           ; #f

(nonpositive? 0)            ; #t (Chez extension)
(nonpositive? -42)          ; #t
(nonpositive? 1)            ; #f

; Even and odd (integers only)
(even? 42)                  ; #t
(even? 43)                  ; #f
(odd? 43)                   ; #t
(odd? 42)                   ; #f

; Finite and infinite
(finite? 42)                ; #t
(finite? 3.14)              ; #t
(finite? +inf.0)            ; #f
(finite? -inf.0)            ; #f
(finite? +nan.0)            ; #f

(infinite? +inf.0)          ; #t
(infinite? -inf.0)          ; #t
(infinite? 42)              ; #f

(nan? +nan.0)               ; #t
(nan? 42)                   ; #f</code></pre>
        <br/>
        <li>Numeric comparison:</li>
<pre><code class="language-scheme line-numbers">; Equality
(= 42 42)                   ; #t
(= 42 42.0)                 ; #t (cross-type)
(= 1/2 0.5)                 ; #t
(= 1 2 3)                   ; #f
(= 5 5 5 5)                 ; #t

; Ordering (real numbers only)
(< 1 2 3)                   ; #t
(<= 1 1 2)                  ; #t
(> 3 2 1)                   ; #t
(>= 3 3 2)                  ; #t

; Mixed exact/inexact
(< 1 2.5 3)                 ; #t
(= 1 1.0)                   ; #t

; Special values
(< -inf.0 0 +inf.0)         ; #t
(= +nan.0 +nan.0)           ; #f (NaN ≠ NaN)</code></pre>
    </ul>
    <br/><br/>


    <li>Fixnum Operations</li>
    <br/>
    <ul>
        <li>Fixnum arithmetic:</li>
<pre><code class="language-scheme line-numbers">; Basic fixnum operations (fast, no overflow checking)
(fx+ 10 20)                 ; 30
(fx- 30 10)                 ; 20
(fx* 6 7)                   ; 42
(fxdiv 17 5)                ; 3 (truncated quotient)
(fxmod 17 5)                ; 2 (remainder)
(fxdiv-and-mod 17 5)        ; Returns 2 values: 3, 2

; Euclidean division
(fxdiv0 -17 5)              ; -4
(fxmod0 -17 5)              ; 3
(fxdiv0-and-mod0 -17 5)     ; Returns 2 values: -4, 3

; Negation and absolute value
(fx- 42)                    ; -42 (unary minus)
(fxabs -42)                 ; 42

; Increment/decrement
(fx1+ 41)                   ; 42
(fx1- 43)                   ; 42

; Quotient and remainder (R6RS)
(fxquotient 17 5)           ; 3
(fxremainder 17 5)          ; 2
(fxremainder -17 5)         ; -2</code></pre>
        <br/>
        <li>Fixnum with overflow checking:</li>
<pre><code class="language-scheme line-numbers">; These raise exception on overflow
(fx+/carry 10 20 0)         ; Returns 2 values: sum, carry
(fx-/carry 10 20 0)         ; Returns 2 values: diff, borrow
(fx*/carry 1000000 1000000 0)  ; Returns 2 values: low, high

; Safe operations (return #f on overflow)
(fx+? 10 20)                ; 30 (Chez extension)
(fx+? (greatest-fixnum) 1)  ; #f (would overflow)
(fx-? 10 20)                ; -10
(fx*? 6 7)                  ; 42

; Example: checked addition
(define (safe-fx+ a b)
  (or (fx+? a b)
      (+ a b)))             ; Fall back to generic</code></pre>
        <br/>
        <li>Fixnum comparison:</li>
<pre><code class="language-scheme line-numbers">; Equality and ordering
(fx=? 42 42)                ; #t
(fx&lt;? 1 2 3)                ; #t
(fx&lt;=? 1 1 2)               ; #t
(fx&gt;? 3 2 1)                ; #t
(fx&gt;=? 3 3 2)               ; #t

; Min and max
(fxmin 3 1 4 1 5)           ; 1
(fxmax 3 1 4 1 5)           ; 5

; Sign predicates
(fxzero? 0)                 ; #t
(fxpositive? 42)            ; #t
(fxnegative? -42)           ; #t
(fxnonnegative? 0)          ; #t
(fxnonpositive? 0)          ; #t
(fxeven? 42)                ; #t
(fxodd? 43)                 ; #t</code></pre>
        <br/>
        <li>Fixnum bitwise operations:</li>
<pre><code class="language-scheme line-numbers">; Logical operations
(fxlogand #b1100 #b1010)    ; #b1000 = 8
(fxlogior #b1100 #b1010)    ; #b1110 = 14
(fxlogxor #b1100 #b1010)    ; #b0110 = 6
(fxlognot #b1100)           ; Complement (all bits flipped)

; Aliases
(fxand #b1100 #b1010)       ; Same as fxlogand
(fxior #b1100 #b1010)       ; Same as fxlogior
(fxxor #b1100 #b1010)       ; Same as fxlogxor
(fxnot #b1100)              ; Same as fxlognot

; Shift operations
(fxsll 1 4)                 ; 16 (shift left logical)
(fxsrl 16 2)                ; 4 (shift right logical)
(fxsra -16 2)               ; -4 (shift right arithmetic)

; Arithmetic shift
(fxarithmetic-shift 1 4)    ; 16 (left by positive)
(fxarithmetic-shift 16 -2)  ; 4 (right by negative)
(fxarithmetic-shift-left 1 4)   ; 16
(fxarithmetic-shift-right 16 2) ; 4

; Rotate
(fxrotate-bit-field #b110010 1 5 2)  ; Rotate bits 1-4</code></pre>
        <br/>
        <li>Fixnum bit manipulation:</li>
<pre><code class="language-scheme line-numbers">; Bit testing
(fxlogbit? 0 #b1010)        ; #f (bit 0 is 0)
(fxlogbit? 1 #b1010)        ; #t (bit 1 is 1)
(fxlogbit? 3 #b1010)        ; #t (bit 3 is 1)

; Bit counting
(fxbit-count #b1010)        ; 2 (number of 1 bits)
(fxbit-count -1)            ; -1 (for negative, returns -(1+count of 0s))

(fxlength #b1010)           ; 4 (bits needed to represent)
(fxlength 0)                ; 0
(fxlength -1)               ; 0

(fxfirst-bit-set #b1010)    ; 1 (index of lowest 1 bit)
(fxfirst-bit-set 0)         ; -1

; Bit field operations
(fxbit-field #b110101 2 5)  ; #b101 = 5 (extract bits 2-4)
(fxbit-field-set #b110101 2 5 #b010)  ; Replace bits 2-4

; Copy bit
(fxcopy-bit 0 #b1010 #t)    ; #b1011 (set bit 0)
(fxcopy-bit 1 #b1010 #f)    ; #b1000 (clear bit 1)

; If operation (bitwise)
(fxif #b1100 #b1010 #b0110) ; #b1010 (where mask=1, use arg1; else arg2)</code></pre>
        <br/>
        <li>Fixnum vector operations:</li>
<pre><code class="language-scheme line-numbers">; Fxvector (vector of fixnums, compact storage)
(fxvector 1 2 3 4 5)        ; #vfx(1 2 3 4 5)
(make-fxvector 5 0)         ; #vfx(0 0 0 0 0)

; Access
(fxvector-length '#vfx(1 2 3))  ; 3
(fxvector-ref '#vfx(10 20 30) 1)  ; 20

; Mutation
(define fxv (fxvector 1 2 3))
(fxvector-set! fxv 1 200)
fxv                         ; #vfx(1 200 3)

; Fill
(fxvector-fill! fxv 0)
fxv                         ; #vfx(0 0 0)

; Copy
(fxvector-copy '#vfx(1 2 3))

; Conversion
(fxvector->list '#vfx(1 2 3))   ; (1 2 3)
(list->fxvector '(1 2 3))       ; #vfx(1 2 3)</code></pre>
    </ul>
    <br/><br/>


    <li>Flonum Operations</li>
    <br/>
    <ul>
        <li>Flonum arithmetic:</li>
<pre><code class="language-scheme line-numbers">; Basic flonum operations
(fl+ 1.5 2.5)               ; 4.0
(fl- 5.0 2.0)               ; 3.0
(fl* 3.0 4.0)               ; 12.0
(fl/ 10.0 4.0)              ; 2.5

; Multiple arguments
(fl+ 1.0 2.0 3.0 4.0)       ; 10.0
(fl* 1.0 2.0 3.0 4.0)       ; 24.0

; Unary operations
(fl- 3.14)                  ; -3.14 (negation)
(fl/ 2.0)                   ; 0.5 (reciprocal)
(flabs -3.14)               ; 3.14

; Division operations
(fldiv 17.0 5.0)            ; 3.0
(flmod 17.0 5.0)            ; 2.0
(fldiv-and-mod 17.0 5.0)    ; Returns: 3.0, 2.0

(fldiv0 -17.0 5.0)          ; -4.0 (Euclidean)
(flmod0 -17.0 5.0)          ; 3.0
(fldiv0-and-mod0 -17.0 5.0) ; Returns: -4.0, 3.0</code></pre>
        <br/>
        <li>Flonum comparison:</li>
<pre><code class="language-scheme line-numbers">; Equality and ordering
(fl=? 3.14 3.14)            ; #t
(fl&lt;? 1.0 2.0 3.0)          ; #t
(fl&lt;=? 1.0 1.0 2.0)         ; #t
(fl&gt;? 3.0 2.0 1.0)          ; #t
(fl&gt;=? 3.0 3.0 2.0)         ; #t

; Min and max
(flmin 3.0 1.0 4.0)         ; 1.0
(flmax 3.0 1.0 4.0)         ; 4.0

; Sign predicates
(flzero? 0.0)               ; #t
(flpositive? 3.14)          ; #t
(flnegative? -3.14)         ; #t
(flnonnegative? 0.0)        ; #t
(flnonpositive? 0.0)        ; #t

; Special value predicates
(flfinite? 3.14)            ; #t
(flfinite? +inf.0)          ; #f
(flinfinite? +inf.0)        ; #t
(flinfinite? -inf.0)        ; #t
(flnan? +nan.0)             ; #t
(flnan? 3.14)               ; #f

; Integer check
(flinteger? 3.0)            ; #t
(flinteger? 3.14)           ; #f

; Even/odd (for integer flonums)
(fleven? 4.0)               ; #t
(flodd? 3.0)                ; #t</code></pre>
        <br/>
        <li>Flonum mathematical functions:</li>
<pre><code class="language-scheme line-numbers">; Exponential and logarithm
(flexp 1.0)                 ; 2.718281828... (e^x)
(fllog 2.718281828)         ; ~1.0 (natural log)
(fllog 100.0 10.0)          ; 2.0 (log base 10)

; Powers and roots
(flexpt 2.0 10.0)           ; 1024.0
(flsqrt 16.0)               ; 4.0

; Trigonometric
(flsin 0.0)                 ; 0.0
(flcos 0.0)                 ; 1.0
(fltan 0.0)                 ; 0.0

; Inverse trigonometric
(flasin 0.0)                ; 0.0
(flacos 1.0)                ; 0.0
(flatan 0.0)                ; 0.0
(flatan 1.0 1.0)            ; 0.785... (atan2)

; Hyperbolic
(flsinh 0.0)                ; 0.0
(flcosh 0.0)                ; 1.0
(fltanh 0.0)                ; 0.0

; Inverse hyperbolic
(flasinh 0.0)               ; 0.0
(flacosh 1.0)               ; 0.0
(flatanh 0.0)               ; 0.0</code></pre>
        <br/>
        <li>Flonum rounding:</li>
<pre><code class="language-scheme line-numbers">; Floor (toward -infinity)
(flfloor 3.7)               ; 3.0
(flfloor -3.7)              ; -4.0

; Ceiling (toward +infinity)
(flceiling 3.2)             ; 4.0
(flceiling -3.7)            ; -3.0

; Truncate (toward zero)
(fltruncate 3.7)            ; 3.0
(fltruncate -3.7)           ; -3.0

; Round (to nearest, ties to even)
(flround 3.5)               ; 4.0
(flround 4.5)               ; 4.0 (ties to even)
(flround 3.4)               ; 3.0

; Numerator and denominator (for exact conversion)
(flnumerator 3.5)           ; 7.0
(fldenominator 3.5)         ; 2.0</code></pre>
        <br/>
        <li>Flonum special values and IEEE operations:</li>
<pre><code class="language-scheme line-numbers">; Special values
+inf.0                      ; Positive infinity
-inf.0                      ; Negative infinity
+nan.0                      ; Not a number
-0.0                        ; Negative zero

; Checking special values
(fl=? +inf.0 +inf.0)        ; #t
(fl=? +nan.0 +nan.0)        ; #f (NaN never equal)
(fl&lt;? -inf.0 +inf.0)        ; #t

; Negative zero
(fl=? 0.0 -0.0)             ; #t
(eqv? 0.0 -0.0)             ; #f (different representations)
(flnegative? -0.0)          ; #f (negative zero is not negative!)

; Decode flonum (IEEE representation)
(fldecode 3.14)             ; Returns: mantissa, exponent, sign
(flencode 0.785 2 1)        ; Encode mantissa, exp, sign

; Integer decode
(flinteger-decode 3.14)     ; Integer mantissa, exp, sign</code></pre>
        <br/>
        <li>Flonum vector operations:</li>
<pre><code class="language-scheme line-numbers">; Flvector (vector of flonums, compact storage)
(flvector 1.0 2.0 3.0)      ; #vfl(1.0 2.0 3.0)
(make-flvector 5 0.0)       ; #vfl(0.0 0.0 0.0 0.0 0.0)

; Access
(flvector-length '#vfl(1.0 2.0 3.0))  ; 3
(flvector-ref '#vfl(1.0 2.0 3.0) 1)   ; 2.0

; Mutation
(define flv (flvector 1.0 2.0 3.0))
(flvector-set! flv 1 20.0)
flv                         ; #vfl(1.0 20.0 3.0)

; Fill and copy
(flvector-fill! flv 0.0)
(flvector-copy '#vfl(1.0 2.0 3.0))

; Conversion
(flvector->list '#vfl(1.0 2.0 3.0))  ; (1.0 2.0 3.0)
(list->flvector '(1.0 2.0 3.0))      ; #vfl(1.0 2.0 3.0)</code></pre>
    </ul>
    <br/><br/>


    <li>Inexact Complex Operations</li>
    <br/>
    <ul>
        <li>Complex number basics:</li>
<pre><code class="language-scheme line-numbers">; Complex literals
3+4i                        ; Exact complex
3.0+4.0i                    ; Inexact complex (cflonum)
0+1i                        ; Pure imaginary
1+0i                        ; Complex with zero imaginary

; Construction
(make-rectangular 3 4)      ; 3+4i
(make-rectangular 3.0 4.0)  ; 3.0+4.0i
(make-polar 5.0 0.927)      ; ~3.0+4.0i (magnitude, angle)

; Accessors
(real-part 3+4i)            ; 3
(imag-part 3+4i)            ; 4
(magnitude 3+4i)            ; 5.0
(angle 3+4i)                ; 0.927... (radians)

; Type check
(complex? 3+4i)             ; #t
(cflonum? 3.0+4.0i)         ; #t (Chez extension)
(cflonum? 3+4i)             ; #f (exact complex)</code></pre>
        <br/>
        <li>Cflonum operations (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Cflonum arithmetic
(cfl+ 1.0+2.0i 3.0+4.0i)    ; 4.0+6.0i
(cfl- 5.0+6.0i 2.0+3.0i)    ; 3.0+3.0i
(cfl* 1.0+2.0i 3.0+4.0i)    ; -5.0+10.0i
(cfl/ 1.0+2.0i 3.0+4.0i)    ; 0.44+0.08i

; Unary operations
(cfl- 3.0+4.0i)             ; -3.0-4.0i (negation)
(cfl/ 1.0+0.0i)             ; 1.0+0.0i (reciprocal)

; Conjugate (flip imaginary sign)
(conjugate 3.0+4.0i)        ; 3.0-4.0i
(fl-make-rectangular
  (real-part z)
  (fl- (imag-part z)))      ; Manual conjugate

; Magnitude and angle for cflonums
(cfl-magnitude 3.0+4.0i)    ; 5.0
(cfl-angle 3.0+4.0i)        ; 0.927...

; Real and imaginary parts
(cfl-real-part 3.0+4.0i)    ; 3.0
(cfl-imag-part 3.0+4.0i)    ; 4.0</code></pre>
        <br/>
        <li>Complex mathematical functions:</li>
<pre><code class="language-scheme line-numbers">; Exponential and logarithm (work with complex)
(exp 0+3.14159i)            ; -1.0+0.0i (Euler's identity)
(log -1)                    ; 0.0+3.14159i

; Powers
(expt 2.71828 0+3.14159i)   ; -1.0+0.0i
(sqrt -1)                   ; 0.0+1.0i

; Trigonometric (extended to complex)
(sin 0+1i)                  ; 0.0+1.1752i
(cos 0+1i)                  ; 1.5431+0.0i

; Inverse trig (return complex)
(asin 2)                    ; 1.5708-1.317i
(acos 2)                    ; 0.0+1.317i

; Hyperbolic
(sinh 0+1i)                 ; 0.0+0.8414i
(cosh 0+1i)                 ; 0.5403+0.0i</code></pre>
        <br/>
        <li>Complex comparisons:</li>
<pre><code class="language-scheme line-numbers">; Equality only (complex numbers aren't ordered)
(= 3+4i 3+4i)               ; #t
(= 3+4i 3.0+4.0i)           ; #t

; Can't use &lt; &gt; with complex
; (&lt; 1+2i 3+4i)             ; Error!

; Compare by magnitude
(define (complex&lt;? a b)
  (&lt; (magnitude a) (magnitude b)))

(complex&lt;? 1+1i 3+4i)       ; #t (1.41 &lt; 5)

; Compare by real part, then imaginary
(define (complex-compare a b)
  (let ([ra (real-part a)] [rb (real-part b)])
    (if (= ra rb)
        (&lt; (imag-part a) (imag-part b))
        (&lt; ra rb))))
</code></pre>
        <br/>
        <li>Conversion between exact and inexact complex:</li>
<pre><code class="language-scheme line-numbers">; To inexact
(inexact 3+4i)              ; 3.0+4.0i
(exact-&gt;inexact 3+4i)       ; 3.0+4.0i

; To exact (if possible)
(exact 3.0+4.0i)            ; 3+4i
(inexact-&gt;exact 3.0+4.0i)   ; 3+4i

; Rationalize real and imaginary parts
(define (rationalize-complex z tolerance)
  (make-rectangular
    (rationalize (real-part z) tolerance)
    (rationalize (imag-part z) tolerance)))

(rationalize-complex 3.14159+2.71828i 0.01)
; 22/7+193/71i (approximate)

; Check if effectively real
(define (effectively-real? z)
  (&lt; (abs (imag-part z)) 1e-10))

(effectively-real? 3.0+1e-15i)  ; #t
</code></pre>
    </ul>
    <br/><br/>


    <li>Bitwise and Logical Operators</li>
    <br/>
    <ul>
        <li>Generic bitwise operations (arbitrary precision):</li>
<pre><code class="language-scheme line-numbers">; Logical AND
(bitwise-and #b1100 #b1010)     ; #b1000 = 8
(logand #b1100 #b1010)          ; Same (alias)

; Logical OR
(bitwise-ior #b1100 #b1010)     ; #b1110 = 14
(logior #b1100 #b1010)          ; Same (alias)
(bitwise-or #b1100 #b1010)      ; Same

; Logical XOR
(bitwise-xor #b1100 #b1010)     ; #b0110 = 6
(logxor #b1100 #b1010)          ; Same (alias)

; Logical NOT (one's complement)
(bitwise-not 0)                 ; -1
(bitwise-not #b1010)            ; ...11110101 (infinite 1s)
(lognot #b1010)                 ; Same (alias)

; Multiple arguments
(bitwise-and #b1111 #b1100 #b1010)  ; #b1000
(bitwise-ior #b0001 #b0010 #b0100)  ; #b0111
</code></pre>
        <br/>
        <li>Bitwise shift operations:</li>
<pre><code class="language-scheme line-numbers">; Arithmetic shift (preserves sign)
(bitwise-arithmetic-shift 1 4)      ; 16 (shift left)
(bitwise-arithmetic-shift 16 -2)    ; 4 (shift right)
(ash 1 4)                           ; 16 (alias)

(bitwise-arithmetic-shift-left 1 4)     ; 16
(bitwise-arithmetic-shift-right 16 2)   ; 4

; Negative numbers
(bitwise-arithmetic-shift -8 -1)    ; -4 (preserves sign)
(ash -8 -1)                         ; -4

; Large shifts
(bitwise-arithmetic-shift 1 100)    ; 2^100
(ash 1 100)                         ; Same

; Logical shift (Chez extension for fixnums)
(fxsrl -1 1)                        ; Large positive (sign not preserved)
</code></pre>
        <br/>
        <li>Bit testing and manipulation:</li>
<pre><code class="language-scheme line-numbers">; Test if bit is set
(bitwise-bit-set? #b1010 1)         ; #t (bit 1 is 1)
(bitwise-bit-set? #b1010 2)         ; #f (bit 2 is 0)
(logbit? 1 #b1010)                  ; #t (alias, args reversed)

; Count bits
(bitwise-bit-count #b1010)          ; 2 (number of 1s)
(logcount #b1010)                   ; 2 (alias)
(bitwise-bit-count -1)              ; -1 (infinite 1s)

; Bit length (minimum bits to represent)
(bitwise-length #b1010)             ; 4
(integer-length #b1010)             ; 4 (alias)
(bitwise-length 0)                  ; 0
(bitwise-length -1)                 ; 0
(bitwise-length -8)                 ; 3

; First bit set (lowest)
(bitwise-first-bit-set #b1010)      ; 1
(bitwise-first-bit-set #b1000)      ; 3
(bitwise-first-bit-set 0)           ; -1

; Copy bit (set or clear specific bit)
(bitwise-copy-bit 0 #b1010 1)       ; #b1011 (set bit 0)
(bitwise-copy-bit 1 #b1010 0)       ; #b1000 (clear bit 1)
</code></pre>
        <br/>
        <li>Bit field operations:</li>
<pre><code class="language-scheme line-numbers">; Extract bit field
(bitwise-bit-field #b110101 2 5)    ; #b101 = 5 (bits 2-4)
(bit-field #b110101 2 5)            ; Same (alias)

; Bit field width = 5-2 = 3 bits extracted
; Position 2 becomes position 0 in result

; Replace bit field
(bitwise-copy-bit-field #b110101 2 5 #b010)  ; #b101001
; Replaces bits 2-4 with #b010

; Rotate bit field
(bitwise-rotate-bit-field #b110101 2 5 1)
; Rotate bits 2-4 left by 1

; Reverse bit field
(bitwise-reverse-bit-field #b110101 0 6)
; Reverse bits 0-5

; Practical example: extract RGB from 24-bit color
(define (color-rgb color)
  (values
    (bitwise-bit-field color 16 24)  ; Red
    (bitwise-bit-field color 8 16)   ; Green
    (bitwise-bit-field color 0 8)))  ; Blue

(color-rgb #xFF8040)        ; Values: 255, 128, 64
</code></pre>
        <br/>
        <li>Bitwise conditionals:</li>
<pre><code class="language-scheme line-numbers">; Bitwise if (ternary)
(bitwise-if #b1100 #b1010 #b0110)   ; #b1010
; Where mask=1, take from arg2; where mask=0, take from arg3

; Equivalently:
(bitwise-ior
  (bitwise-and #b1100 #b1010)       ; Bits from arg2 where mask=1
  (bitwise-and (bitwise-not #b1100) #b0110))  ; Bits from arg3 where mask=0

; NAND, NOR, etc. (combinations)
(define (bitwise-nand a b)
  (bitwise-not (bitwise-and a b)))

(define (bitwise-nor a b)
  (bitwise-not (bitwise-ior a b)))

(define (bitwise-xnor a b)
  (bitwise-not (bitwise-xor a b)))

(define (bitwise-andc1 a b)  ; AND with complement of first
  (bitwise-and (bitwise-not a) b))

(define (bitwise-orc1 a b)   ; OR with complement of first
  (bitwise-ior (bitwise-not a) b))
</code></pre>
        <br/>
        <li>Binary representation utilities:</li>
<pre><code class="language-scheme line-numbers">; Convert to binary string
(number-&gt;string 42 2)               ; "101010"
(number-&gt;string -42 2)              ; "-101010"

; Parse binary string
(string-&gt;number "101010" 2)         ; 42

; Hex representation
(number-&gt;string 255 16)             ; "ff"
(string-&gt;number "ff" 16)            ; 255
(format "~x" 255)                   ; "ff"
(format "~b" 42)                    ; "101010"

; Pretty print binary with grouping
(define (binary-string n width)
  (let* ([s (number-&gt;string (if (negative? n)
                                (+ (expt 2 width) n)
                                n) 2)]
         [padded (string-append
                   (make-string (- width (string-length s)) #\0)
                   s)])
    padded))

(binary-string 42 8)                ; "00101010"
(binary-string -1 8)                ; "11111111"
</code></pre>
    </ul>
    <br/><br/>


    <li>Random Number Generation</li>
    <br/>
    <ul>
        <li>Basic random number generation:</li>
<pre><code class="language-scheme line-numbers">; Random integer in range [0, n)
(random 100)                ; 0-99
(random 6)                  ; 0-5 (dice roll - 1)

; Random real in [0.0, 1.0)
(random 1.0)                ; e.g., 0.7234...

; Random exact rational
(random 1/1)                ; Exact rational in [0, 1)

; Multiple calls give different values
(list (random 100) (random 100) (random 100))
; e.g., (42 17 89)
</code></pre>
        <br/>
        <li>Random state management:</li>
<pre><code class="language-scheme line-numbers">; Get current random state
(random-seed)               ; Current seed (implementation-dependent)

; Set random seed (for reproducibility)
(random-seed 12345)
(random 100)                ; Same result every time with same seed

; Save and restore state
(define saved-seed (random-seed))
(list (random 100) (random 100))  ; e.g., (42 17)

(random-seed saved-seed)
(list (random 100) (random 100))  ; Same: (42 17)

; Different seed, different sequence
(random-seed 99999)
(list (random 100) (random 100))  ; Different values
</code></pre>
        <br/>
        <li>Random distributions and utilities:</li>
<pre><code class="language-scheme line-numbers">; Random in range [a, b)
(define (random-range a b)
  (+ a (random (- b a))))

(random-range 10 20)        ; 10-19

; Random float in range [a, b)
(define (random-float-range a b)
  (+ a (* (random 1.0) (- b a))))

(random-float-range 0.0 100.0)  ; e.g., 47.23...

; Random boolean
(define (random-bool)
  (zero? (random 2)))

(random-bool)               ; #t or #f

; Random choice from list
(define (random-choice lst)
  (list-ref lst (random (length lst))))

(random-choice '(red green blue))  ; Random element

; Random sample (n items without replacement)
(define (random-sample lst n)
  (let loop ([remaining lst] [count n] [result '()])
    (cond
      [(or (zero? count) (null? remaining)) (reverse result)]
      [(&lt; (random 1.0) (/ count (length remaining)))
       (loop (cdr remaining) (- count 1) (cons (car remaining) result))]
      [else
       (loop (cdr remaining) count result)])))

(random-sample '(1 2 3 4 5 6 7 8 9 10) 3)  ; e.g., (2 5 9)
</code></pre>
        <br/>
        <li>Shuffling:</li>
<pre><code class="language-scheme line-numbers">; Fisher-Yates shuffle (vector)
(define (vector-shuffle! vec)
  (let ([n (vector-length vec)])
    (do ([i (- n 1) (- i 1)])
        ((&lt; i 1) vec)
      (let* ([j (random (+ i 1))]
             [temp (vector-ref vec i)])
        (vector-set! vec i (vector-ref vec j))
        (vector-set! vec j temp)))))

(define v (vector 1 2 3 4 5))
(vector-shuffle! v)
v                           ; e.g., #(3 1 5 2 4)

; Shuffle list
(define (shuffle lst)
  (let ([vec (list-&gt;vector lst)])
    (vector-shuffle! vec)
    (vector-&gt;list vec)))

(shuffle '(1 2 3 4 5))      ; e.g., (4 2 5 1 3)

; Shuffle immutably (returns new vector)
(define (vector-shuffle vec)
  (let ([copy (vector-copy vec)])
    (vector-shuffle! copy)
    copy))
</code></pre>
        <br/>
        <li>Probability distributions:</li>
<pre><code class="language-scheme line-numbers">; Uniform distribution is built-in with (random)

; Normal (Gaussian) distribution - Box-Muller transform
(define (random-normal mean std-dev)
  (let ([u1 (random 1.0)]
        [u2 (random 1.0)])
    (+ mean
       (* std-dev
          (sqrt (* -2.0 (log u1)))
          (cos (* 2.0 3.14159265 u2))))))

(random-normal 0.0 1.0)     ; Standard normal

; Exponential distribution
(define (random-exponential rate)
  (/ (- (log (random 1.0))) rate))

(random-exponential 1.0)    ; Mean = 1/rate

; Weighted random choice
(define (weighted-choice items weights)
  (let* ([total (apply + weights)]
         [r (* (random 1.0) total)])
    (let loop ([items items] [weights weights] [sum 0])
      (let ([new-sum (+ sum (car weights))])
        (if (&lt; r new-sum)
            (car items)
            (loop (cdr items) (cdr weights) new-sum))))))

(weighted-choice '(rare common) '(1 9))  ; common 90% of time

; Bernoulli trial
(define (bernoulli p)
  (&lt; (random 1.0) p))

(bernoulli 0.7)             ; #t with 70% probability

; Geometric distribution (number of trials until success)
(define (random-geometric p)
  (let loop ([count 1])
    (if (bernoulli p)
        count
        (loop (+ count 1)))))
</code></pre>
        <br/>
        <li>Cryptographically secure randomness (if available):</li>
<pre><code class="language-scheme line-numbers">; Read from /dev/urandom (Unix-like systems)
(define (crypto-random-bytes n)
  (call-with-port (open-file-input-port "/dev/urandom")
    (lambda (port)
      (get-bytevector-n port n))))

(crypto-random-bytes 16)    ; 16 random bytes

; Convert to integer
(define (crypto-random-integer n)
  (let* ([bytes-needed (ceiling (/ (integer-length n) 8))]
         [bv (crypto-random-bytes bytes-needed)]
         [value (bytevector-uint-ref bv 0 'big bytes-needed)])
    (mod value n)))

(crypto-random-integer 1000000)  ; Cryptographically random

; UUID generation
(define (random-uuid)
  (let ([bv (crypto-random-bytes 16)])
    ; Set version 4 and variant bits
    (bytevector-u8-set! bv 6
      (fxior #x40 (fxand #x0f (bytevector-u8-ref bv 6))))
    (bytevector-u8-set! bv 8
      (fxior #x80 (fxand #x3f (bytevector-u8-ref bv 8))))
    (format "~8,'0x-~4,'0x-~4,'0x-~4,'0x-~12,'0x"
            (bytevector-u32-ref bv 0 'big)
            (bytevector-u16-ref bv 4 'big)
            (bytevector-u16-ref bv 6 'big)
            (bytevector-u16-ref bv 8 'big)
            (+ (ash (bytevector-u32-ref bv 10 'big) 16)
               (bytevector-u16-ref bv 14 'big)))))
</code></pre>
    </ul>
    <br/><br/>


    <li>Miscellaneous Numeric Operations</li>
    <br/>
    <ul>
        <li>Type conversion:</li>
<pre><code class="language-scheme line-numbers">; Exact to inexact
(inexact 42)                ; 42.0
(exact-&gt;inexact 3/4)        ; 0.75
(inexact 3+4i)              ; 3.0+4.0i

; Inexact to exact
(exact 42.0)                ; 42
(inexact-&gt;exact 0.5)        ; 1/2
(exact 3.14)                ; 7070651414971679/2251799813685248

; Rationalize (find simple approximation)
(rationalize 3.14159 0.001) ; 22/7
(rationalize 0.333 0.01)    ; 1/3

; Round to integer
(round 3.5)                 ; 4.0 (or 4 for exact)
(floor 3.7)                 ; 3.0
(ceiling 3.2)               ; 4.0
(truncate 3.9)              ; 3.0
(truncate -3.9)             ; -3.0

; Exact round
(exact (round 3.5))         ; 4
</code></pre>
        <br/>
        <li>Arithmetic operations:</li>
<pre><code class="language-scheme line-numbers">; Basic operations (generic)
(+ 1 2 3 4 5)               ; 15
(- 10 3 2)                  ; 5
(* 2 3 4)                   ; 24
(/ 24 4 2)                  ; 3

; Unary minus and reciprocal
(- 42)                      ; -42
(/ 4)                       ; 1/4

; Division variants
(quotient 17 5)             ; 3 (truncate toward zero)
(remainder 17 5)            ; 2 (sign follows dividend)
(modulo 17 5)               ; 2 (sign follows divisor)

(quotient -17 5)            ; -3
(remainder -17 5)           ; -2
(modulo -17 5)              ; 3

; Euclidean division
(div 17 5)                  ; 3
(mod 17 5)                  ; 2
(div-and-mod 17 5)          ; Returns: 3, 2

(div0 -17 5)                ; -4
(mod0 -17 5)                ; 3
(div0-and-mod0 -17 5)       ; Returns: -4, 3

; Absolute value
(abs -42)                   ; 42
(abs -3.14)                 ; 3.14
(abs 3+4i)                  ; 5.0 (magnitude)
</code></pre>
        <br/>
        <li>Powers and logarithms:</li>
<pre><code class="language-scheme line-numbers">; Exponentiation
(expt 2 10)                 ; 1024
(expt 2 -1)                 ; 1/2
(expt 2 1/2)                ; 1.414... (sqrt 2)
(expt -1 1/2)               ; 0.0+1.0i
(expt 2.0 10.0)             ; 1024.0

; Square root
(sqrt 16)                   ; 4
(sqrt 2)                    ; 1.414...
(sqrt -1)                   ; 0.0+1.0i

; Exact integer square root (Chez extension)
(isqrt 17)                  ; 4 (floor of sqrt)
(exact-integer-sqrt 17)     ; Returns: 4, 1 (root and remainder)

; Natural logarithm
(log 2.71828)               ; ~1.0
(log (exp 1))               ; 1.0

; Logarithm with base
(log 100 10)                ; 2.0
(log 8 2)                   ; 3.0

; Exponential
(exp 1)                     ; 2.71828... (e)
(exp 0)                     ; 1
</code></pre>
        <br/>
        <li>Trigonometric functions:</li>
<pre><code class="language-scheme line-numbers">; Basic trig (radians)
(sin 0)                     ; 0
(cos 0)                     ; 1
(tan 0)                     ; 0

; Pi constant
(define pi 3.141592653589793)
(sin pi)                    ; ~0 (small floating-point error)
(cos pi)                    ; -1.0

; Inverse trig
(asin 0)                    ; 0
(acos 1)                    ; 0
(atan 1)                    ; 0.785... (pi/4)
(atan 1 1)                  ; 0.785... (atan2)
(atan 1 -1)                 ; 2.356... (3*pi/4)

; Hyperbolic
(sinh 0)                    ; 0
(cosh 0)                    ; 1
(tanh 0)                    ; 0

; Inverse hyperbolic
(asinh 0)                   ; 0
(acosh 1)                   ; 0
(atanh 0)                   ; 0

; Degrees conversion helpers
(define (degrees-&gt;radians d)
  (* d (/ pi 180)))
(define (radians-&gt;degrees r)
  (* r (/ 180 pi)))

(sin (degrees-&gt;radians 90)) ; 1.0
</code></pre>
        <br/>
        <li>GCD, LCM, and modular arithmetic:</li>
<pre><code class="language-scheme line-numbers">; Greatest common divisor
(gcd 48 18)                 ; 6
(gcd 48 18 12)              ; 6
(gcd)                       ; 0

; Least common multiple
(lcm 4 6)                   ; 12
(lcm 4 6 8)                 ; 24
(lcm)                       ; 1

; Numerator and denominator
(numerator 3/4)             ; 3
(denominator 3/4)           ; 4
(numerator 3)               ; 3
(denominator 3)             ; 1

; Modular exponentiation (efficient)
(define (mod-expt base exp mod)
  (let loop ([base (modulo base mod)]
             [exp exp]
             [result 1])
    (cond
      [(zero? exp) result]
      [(odd? exp)
       (loop (modulo (* base base) mod)
             (quotient exp 2)
             (modulo (* result base) mod))]
      [else
       (loop (modulo (* base base) mod)
             (quotient exp 2)
             result)])))

(mod-expt 2 100 1000000007) ; Efficient large power mod prime

; Modular inverse (extended Euclidean algorithm)
(define (mod-inverse a m)
  (let loop ([old-r m] [r a] [old-s 0] [s 1])
    (if (zero? r)
        (if (= old-r 1)
            #f  ; No inverse
            (modulo old-s m))
        (let ([q (quotient old-r r)])
          (loop r (- old-r (* q r))
                s (- old-s (* q s)))))))
</code></pre>
        <br/>
        <li>Number theoretic functions:</li>
<pre><code class="language-scheme line-numbers">; Primality test (simple)
(define (prime? n)
  (cond
    [(&lt; n 2) #f]
    [(= n 2) #t]
    [(even? n) #f]
    [else
     (let ([limit (isqrt n)])
       (let loop ([d 3])
         (cond
           [(&gt; d limit) #t]
           [(zero? (modulo n d)) #f]
           [else (loop (+ d 2))])))]))

(filter prime? (iota 30 2))  ; (2 3 5 7 11 13 17 19 23 29)

; Prime factorization
(define (prime-factors n)
  (let loop ([n n] [d 2] [factors '()])
    (cond
      [(= n 1) (reverse factors)]
      [(&gt; (* d d) n) (reverse (cons n factors))]
      [(zero? (modulo n d))
       (loop (/ n d) d (cons d factors))]
      [else
       (loop n (if (= d 2) 3 (+ d 2)) factors)])))

(prime-factors 360)         ; (2 2 2 3 3 5)

; Euler's totient function
(define (totient n)
  (let ([factors (remove-duplicates (prime-factors n))])
    (fold-left
      (lambda (result p)
        (* result (- p 1) (/ n p) (/ 1 (- (/ n (expt p (count-factor n p))) 1))))
      n
      factors)))

; Simpler totient
(define (totient n)
  (length (filter (lambda (k) (= 1 (gcd k n)))
                  (iota n 1))))

(totient 12)                ; 4 (1, 5, 7, 11 are coprime to 12)
</code></pre>
        <br/>
        <li>Numeric precision and limits:</li>
<pre><code class="language-scheme line-numbers">; Fixnum limits (platform-dependent)
(greatest-fixnum)           ; Largest fixnum
(least-fixnum)              ; Smallest fixnum
(fixnum-width)              ; Bit width

; Flonum limits
(define fl-max 1.7976931348623157e+308)
(define fl-min 2.2250738585072014e-308)
(define fl-epsilon 2.220446049250313e-16)

; Machine epsilon
(let loop ([eps 1.0])
  (if (= 1.0 (+ 1.0 eps))
      (* eps 2.0)
      (loop (/ eps 2.0))))  ; ~2.22e-16

; Check if flonum operations would overflow
(define (fl-overflow? x y op)
  (let ([result (op x y)])
    (or (infinite? result) (nan? result))))

; Arbitrary precision
(expt 10 100)               ; Exact 10^100
(factorial 100)             ; Huge exact integer

; Working with big numbers
(define (factorial n)
  (if (&lt;= n 1)
      1
      (* n (factorial (- n 1)))))

(integer-length (factorial 100))  ; 525 bits needed

; String representation of large numbers
(number-&gt;string (factorial 50))   ; Long exact decimal
</code></pre>
        <br/>
        <li>Numeric string formatting:</li>
<pre><code class="language-scheme line-numbers">; Basic number to string
(number-&gt;string 42)         ; "42"
(number-&gt;string 3.14159)    ; "3.14159"
(number-&gt;string 3+4i)       ; "3+4i"

; With radix
(number-&gt;string 255 16)     ; "ff"
(number-&gt;string 255 2)      ; "11111111"
(number-&gt;string 255 8)      ; "377"

; Format with precision
(format "~,2f" 3.14159)     ; "3.14"
(format "~,5f" 3.14159)     ; "3.14159"
(format "~e" 12345.6)       ; "1.23456e4"

; Padding and alignment
(format "~8d" 42)           ; "      42"
(format "~8,'0d" 42)        ; "00000042"
(format "~8,2f" 3.14)       ; "    3.14"

; Hex and binary formatting
(format "~x" 255)           ; "ff"
(format "~X" 255)           ; "FF"
(format "~b" 42)            ; "101010"
(format "~o" 64)            ; "100"

; Custom decimal formatting
(define (format-decimal n places)
  (let* ([factor (expt 10 places)]
         [rounded (/ (round (* n factor)) factor)])
    (format "~v,vf" (+ places 3) places rounded)))

(format-decimal 3.14159 2)  ; "3.14"
</code></pre>
        <br/>
        <li>Numeric utilities:</li>
<pre><code class="language-scheme line-numbers">; Min and max
(min 3 1 4 1 5)             ; 1
(max 3 1 4 1 5)             ; 5
(min 1.0 2 3/4)             ; 0.75 (mixed types)

; Clamping
(define (clamp x lo hi)
  (max lo (min hi x)))

(clamp 5 0 10)              ; 5
(clamp -5 0 10)             ; 0
(clamp 15 0 10)             ; 10

; Linear interpolation
(define (lerp a b t)
  (+ a (* t (- b a))))

(lerp 0 100 0.5)            ; 50.0
(lerp 0 100 0.25)           ; 25.0

; Map value from one range to another
(define (map-range x in-min in-max out-min out-max)
  (+ out-min
     (* (- out-max out-min)
        (/ (- x in-min)
           (- in-max in-min)))))

(map-range 50 0 100 0 1)    ; 0.5

; Sign function
(define (sgn x)
  (cond
    [(positive? x) 1]
    [(negative? x) -1]
    [else 0]))

(sgn -42)                   ; -1
(sgn 42)                    ; 1
(sgn 0)                     ; 0

; Sum and product of lists
(define (sum lst) (apply + lst))
(define (product lst) (apply * lst))

(sum '(1 2 3 4 5))          ; 15
(product '(1 2 3 4 5))      ; 120

; Average
(define (average lst)
  (/ (sum lst) (length lst)))

(average '(1 2 3 4 5))      ; 3
</code></pre>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-input-output">Input/Output Operations in Chez Scheme</h3>
<ol>

    <li>Generic Ports</li>
    <br/>
    <ul>
        <li>Ports are the abstraction for I/O in Scheme:</li>
<pre><code class="language-scheme line-numbers">; Port type hierarchy
; - Input ports (for reading)
; - Output ports (for writing)
; - Input/output ports (bidirectional)
; - Binary ports (raw bytes)
; - Textual ports (characters with encoding)

; Standard ports
(current-input-port)        ; stdin
(current-output-port)       ; stdout
(current-error-port)        ; stderr

; Port predicates
(port? (current-input-port))         ; #t
(input-port? (current-input-port))   ; #t
(output-port? (current-output-port)) ; #t
(binary-port? port)                  ; #t if binary
(textual-port? port)                 ; #t if textual

; Input/output port check
(input-port? (open-input-output-file "test.txt"))   ; #t
(output-port? (open-input-output-file "test.txt"))  ; #t</code></pre>
        <br/>
        <li>Port direction and type combinations:</li>
<pre><code class="language-scheme line-numbers">; Four main combinations:
; 1. Textual input port - reads characters
; 2. Textual output port - writes characters
; 3. Binary input port - reads bytes
; 4. Binary output port - writes bytes

; Plus bidirectional versions:
; 5. Textual input/output port
; 6. Binary input/output port

; Check port capabilities
(define (port-info port)
  (printf "Input: ~a~n" (input-port? port))
  (printf "Output: ~a~n" (output-port? port))
  (printf "Binary: ~a~n" (binary-port? port))
  (printf "Textual: ~a~n" (textual-port? port)))

; Example
(port-info (current-input-port))
; Input: #t
; Output: #f
; Binary: #f
; Textual: #t</code></pre>
        <br/>
        <li>Port parameters:</li>
<pre><code class="language-scheme line-numbers">; Rebind standard ports temporarily
(parameterize ([current-output-port (open-output-file "log.txt")])
  (display "This goes to log.txt")
  (newline))

; Redirect error output
(parameterize ([current-error-port (current-output-port)])
  (error 'test "error message"))  ; Goes to stdout

; Console ports (Chez extension)
(console-input-port)        ; Direct console input
(console-output-port)       ; Direct console output
(console-error-port)        ; Direct console error

; These bypass any redirection</code></pre>
    </ul>
    <br/><br/>


    <li>File Options</li>
    <br/>
    <ul>
        <li>File options control how files are opened:</li>
<pre><code class="language-scheme line-numbers">; file-options creates a file-options object
(file-options)              ; No options (default behavior)

; Available options:
; no-create    - Don't create if doesn't exist
; no-fail      - Don't fail if exists (for output)
; no-truncate  - Don't truncate existing file
; append       - Append to existing file
; exclusive    - Fail if file exists
; compressed   - Use compression (Chez extension)
; replace      - Replace existing file

; Common combinations for output:
(file-options no-fail)      ; Overwrite if exists, create if not
(file-options no-fail no-truncate)  ; Keep existing content
(file-options append)       ; Append to file
(file-options exclusive)    ; Create new only, fail if exists

; For input (fewer options matter):
(file-options)              ; Normal open
(file-options compressed)   ; Open compressed file</code></pre>
        <br/>
        <li>Using file options:</li>
<pre><code class="language-scheme line-numbers">; Default output: fail if exists
(open-file-output-port "new.txt")  ; Error if file exists

; Allow overwriting
(open-file-output-port "new.txt"
  (file-options no-fail))

; Append mode
(open-file-output-port "log.txt"
  (file-options no-fail append))

; Exclusive creation
(open-file-output-port "unique.txt"
  (file-options exclusive))  ; Fail if exists

; Keep existing content, write at beginning
(open-file-output-port "data.txt"
  (file-options no-fail no-truncate))

; Compressed file (Chez extension)
(open-file-output-port "data.gz"
  (file-options no-fail compressed))</code></pre>
        <br/>
        <li>Buffer modes:</li>
<pre><code class="language-scheme line-numbers">; Buffer mode affects when data is actually written
; - none: Write immediately (unbuffered)
; - line: Write when newline encountered
; - block: Write when buffer full (default)

; Specify buffer mode when opening
(open-file-output-port "file.txt"
  (file-options no-fail)
  'line)                    ; Line buffering

(open-file-output-port "file.txt"
  (file-options no-fail)
  'none)                    ; Unbuffered

(open-file-output-port "file.txt"
  (file-options no-fail)
  'block)                   ; Block buffered (default)

; Buffer mode affects:
; - Performance (buffered is faster)
; - When output becomes visible
; - Behavior with multiple writers</code></pre>
    </ul>
    <br/><br/>


    <li>Transcoders</li>
    <br/>
    <ul>
        <li>Transcoders convert between bytes and characters:</li>
<pre><code class="language-scheme line-numbers">; A transcoder combines:
; - Codec (encoding): UTF-8, UTF-16, Latin-1, etc.
; - EOL style: lf, cr, crlf, nel, crnel, ls, none
; - Error handling mode: ignore, raise, replace

; Create transcoder
(make-transcoder (utf-8-codec))

(make-transcoder
  (utf-8-codec)
  'lf                       ; EOL style
  'replace)                 ; Error mode

; Available codecs
(utf-8-codec)               ; UTF-8 encoding
(utf-16-codec)              ; UTF-16 with BOM
(utf-16le-codec)            ; UTF-16 little-endian
(utf-16be-codec)            ; UTF-16 big-endian
(latin-1-codec)             ; ISO-8859-1
(native-transcoder)         ; Platform default</code></pre>
        <br/>
        <li>EOL (end-of-line) styles:</li>
<pre><code class="language-scheme line-numbers">; EOL styles for line ending conversion
; 'none   - No conversion
; 'lf     - Unix style (linefeed)
; 'cr     - Old Mac style (carriage return)
; 'crlf   - Windows style (carriage return + linefeed)
; 'nel    - Unicode next line
; 'crnel  - CR + NEL
; 'ls     - Unicode line separator

; Native EOL style
(native-eol-style)          ; 'lf on Unix, 'crlf on Windows

; Create transcoder with specific EOL
(make-transcoder
  (utf-8-codec)
  'crlf)                    ; Windows-style line endings

; EOL conversion on input:
; - All EOL sequences converted to #\newline
; EOL conversion on output:
; - #\newline converted to specified style</code></pre>
        <br/>
        <li>Error handling modes:</li>
<pre><code class="language-scheme line-numbers">; Error modes for invalid byte sequences
; 'ignore  - Skip invalid bytes
; 'raise   - Raise exception
; 'replace - Insert replacement character (U+FFFD)

; Strict transcoder (raise on error)
(make-transcoder
  (utf-8-codec)
  'none
  'raise)

; Lenient transcoder (replace invalid)
(make-transcoder
  (utf-8-codec)
  'none
  'replace)

; Using transcoders with ports
(open-file-input-port "data.txt"
  (file-options)
  'block
  (make-transcoder (utf-8-codec)))

; Transcoded port (wrap binary port)
(define bin-port (open-file-input-port "data.txt"))
(define text-port
  (transcoded-port bin-port (make-transcoder (utf-8-codec))))

; Get transcoder from port
(port-transcoder text-port)  ; Returns transcoder or #f</code></pre>
        <br/>
        <li>Transcoder inspection:</li>
<pre><code class="language-scheme line-numbers">; Extract components from transcoder
(define tc (make-transcoder (utf-8-codec) 'crlf 'replace))

(transcoder-codec tc)       ; UTF-8 codec
(transcoder-eol-style tc)   ; crlf
(transcoder-error-handling-mode tc)  ; replace

; Check if Latin-1 codec
(define (latin-1-transcoder? tc)
  (eq? (transcoder-codec tc) (latin-1-codec)))

; Create matching transcoder with different EOL
(define (transcoder-with-eol tc eol)
  (make-transcoder
    (transcoder-codec tc)
    eol
    (transcoder-error-handling-mode tc)))</code></pre>
    </ul>
    <br/><br/>


    <li>Port Operations</li>
    <br/>
    <ul>
        <li>Opening and closing ports:</li>
<pre><code class="language-scheme line-numbers">; Close any port
(close-port port)

; Close specific direction
(close-input-port port)     ; Close input side
(close-output-port port)    ; Close output side

; Check if port is closed (Chez extension)
(port-closed? port)         ; #t if closed

; Ports and garbage collection
; Ports are closed when garbage collected, but
; explicit closing is recommended for resources

; Safe port handling with dynamic-wind
(define (call-with-port port proc)
  (dynamic-wind
    (lambda () #f)
    (lambda () (proc port))
    (lambda () (close-port port))))

; Built-in call-with-* procedures
(call-with-input-file "data.txt"
  (lambda (port)
    (get-line port)))

(call-with-output-file "data.txt"
  (lambda (port)
    (display "Hello" port)))</code></pre>
        <br/>
        <li>Port positioning:</li>
<pre><code class="language-scheme line-numbers">; Check if port supports positioning
(port-has-port-position? port)
(port-has-set-port-position!? port)

; Get current position
(port-position port)        ; Returns position

; Set position
(set-port-position! port 0)  ; Go to beginning
(set-port-position! port 100) ; Go to byte/char 100

; Position is in:
; - Bytes for binary ports
; - Characters for some textual ports
; - May be opaque for textual ports (codec-dependent)

; Seek from different origins (Chez extension)
(file-position port)        ; Current position
(file-position port 0)      ; Seek to beginning
(file-position port pos)    ; Seek to position

; File length (Chez extension)
(file-length port)          ; Total length in bytes</code></pre>
        <br/>
        <li>Port buffer control:</li>
<pre><code class="language-scheme line-numbers">; Flush output buffer
(flush-output-port port)
(flush-output-port)         ; Flush current-output-port

; Check for available input
(input-port-ready? port)    ; #t if data available without blocking

; Clear input buffer (Chez extension)
(clear-input-port port)
(clear-input-port)          ; Clear current-input-port

; Clear output buffer without writing (Chez extension)
(clear-output-port port)
(clear-output-port)         ; Clear current-output-port

; Port buffer mode
(output-port-buffer-mode port)  ; 'none, 'line, or 'block

; Set buffer mode (Chez extension)
(set-port-output-buffer-mode! port 'line)</code></pre>
        <br/>
        <li>Port names and information:</li>
<pre><code class="language-scheme line-numbers">; Get port name (for error messages, debugging)
(port-name port)            ; Returns string

; Chez extensions for port info
(port-file-descriptor port) ; OS file descriptor (if applicable)

; Check port EOF status
(port-eof? port)            ; #t if at end of file

; Mark port as EOF (Chez extension)
(set-port-eof! port #t)

; Input port position tracking
(port-has-port-length? port)  ; Can get length?
(port-length port)            ; Get length if available</code></pre>
    </ul>
    <br/><br/>


    <li>String Ports</li>
    <br/>
    <ul>
        <li>String input ports:</li>
<pre><code class="language-scheme line-numbers">; Create input port from string
(open-input-string "Hello, World!")

; Read from string
(let ([port (open-input-string "Hello, World!")])
  (get-line port))          ; "Hello, World!"

; Parse data from string
(let ([port (open-input-string "(1 2 3) (4 5 6)")])
  (list (read port) (read port)))
; ((1 2 3) (4 5 6))

; Read multiple values
(let ([port (open-input-string "42 3.14 hello")])
  (let* ([a (read port)]
         [b (read port)]
         [c (read port)])
    (list a b c)))          ; (42 3.14 hello)

; Useful for testing
(define (parse-expression str)
  (read (open-input-string str)))

(parse-expression "(+ 1 2)")  ; (+ 1 2)</code></pre>
        <br/>
        <li>String output ports:</li>
<pre><code class="language-scheme line-numbers">; Create output port to string
(open-output-string)

; Write to string
(let ([port (open-output-string)])
  (display "Hello, " port)
  (display "World!" port)
  (get-output-string port)) ; "Hello, World!"

; Get accumulated output
(define port (open-output-string))
(display "Line 1\n" port)
(display "Line 2\n" port)
(get-output-string port)    ; "Line 1\nLine 2\n"

; get-output-string can be called multiple times
(display "More" port)
(get-output-string port)    ; "Line 1\nLine 2\nMore"

; Build formatted string
(let ([port (open-output-string)])
  (fprintf port "Name: ~a~n" "Alice")
  (fprintf port "Age: ~a~n" 30)
  (get-output-string port))
; "Name: Alice\nAge: 30\n"</code></pre>
        <br/>
        <li>with-output-to-string and with-input-from-string:</li>
<pre><code class="language-scheme line-numbers">; Capture output to string (Chez extension)
(with-output-to-string
  (lambda ()
    (display "Hello")
    (newline)
    (display "World")))
; "Hello\nWorld"

; Read from string as current input (Chez extension)
(with-input-from-string "(1 2 3)"
  (lambda ()
    (read)))                ; (1 2 3)

; Capture pretty-printed output
(with-output-to-string
  (lambda ()
    (pretty-print '(define (factorial n)
                     (if (zero? n) 1 (* n (factorial (- n 1))))))))

; Parse multiple items from string
(with-input-from-string "1 2 3 4 5"
  (lambda ()
    (let loop ([acc '()])
      (let ([x (read)])
        (if (eof-object? x)
            (reverse acc)
            (loop (cons x acc)))))))</code></pre>
        <br/>
        <li>Bytevector ports:</li>
<pre><code class="language-scheme line-numbers">; Binary input from bytevector
(open-bytevector-input-port #vu8(1 2 3 4 5))

(let ([port (open-bytevector-input-port #vu8(72 101 108 108 111))])
  (get-bytevector-all port))
; #vu8(72 101 108 108 111)

; Binary output to bytevector
(let ([port (open-bytevector-output-port)])
  (put-u8 port 72)
  (put-u8 port 105)
  (get-output-bytevector port))
; #vu8(72 105)

; With extraction procedure
(let-values ([(port extract) (open-bytevector-output-port)])
  (put-bytevector port #vu8(1 2 3))
  (put-bytevector port #vu8(4 5 6))
  (extract))                ; #vu8(1 2 3 4 5 6)

; Transcoded bytevector port
(let ([port (open-bytevector-input-port
              (string->utf8 "Hello"))])
  (let ([tport (transcoded-port port (native-transcoder))])
    (get-line tport)))      ; "Hello"</code></pre>
    </ul>
    <br/><br/>


    <li>File Ports</li>
    <br/>
    <ul>
        <li>Opening files for input:</li>
<pre><code class="language-scheme line-numbers">; Simple file input (textual)
(open-input-file "data.txt")

; Binary file input
(open-file-input-port "data.bin")

; With transcoder (textual)
(open-file-input-port "data.txt"
  (file-options)
  'block
  (native-transcoder))

; Read entire file
(define (read-file filename)
  (call-with-input-file filename
    (lambda (port)
      (get-string-all port))))

(read-file "data.txt")      ; Entire file as string

; Read lines
(define (read-lines filename)
  (call-with-input-file filename
    (lambda (port)
      (let loop ([lines '()])
        (let ([line (get-line port)])
          (if (eof-object? line)
              (reverse lines)
              (loop (cons line lines))))))))

(read-lines "data.txt")     ; List of lines</code></pre>
        <br/>
        <li>Opening files for output:</li>
<pre><code class="language-scheme line-numbers">; Simple file output (textual)
(open-output-file "output.txt")  ; Fails if exists

; With options
(open-output-file "output.txt"
  '(mode #o644))            ; Unix permissions (Chez)

; Binary file output
(open-file-output-port "data.bin")

; Allow overwrite
(open-file-output-port "data.bin"
  (file-options no-fail))

; Append mode
(open-file-output-port "log.txt"
  (file-options no-fail append))

; With transcoder
(open-file-output-port "data.txt"
  (file-options no-fail)
  'block
  (make-transcoder (utf-8-codec)))

; Write entire file
(define (write-file filename content)
  (call-with-output-file filename
    (lambda (port)
      (display content port))
    '(replace)))            ; Replace if exists

(write-file "output.txt" "Hello, World!")</code></pre>
        <br/>
        <li>Bidirectional file ports:</li>
<pre><code class="language-scheme line-numbers">; Open for both input and output
(open-file-input/output-port "data.txt"
  (file-options no-fail no-truncate))

; Chez extension
(open-input-output-file "data.txt")

; Use cases:
; - In-place file modification
; - Database-like random access
; - Log files with read-back

; Example: read, modify, write back
(let ([port (open-file-input/output-port "counter.txt"
              (file-options no-fail no-truncate)
              'block
              (native-transcoder))])
  (let ([value (read port)])
    (set-port-position! port 0)
    (write (+ value 1) port)
    (truncate-port port)    ; Remove excess
    (close-port port)))

; truncate-port cuts file at current position (Chez extension)
(truncate-port port)</code></pre>
        <br/>
        <li>Compressed files (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Write compressed file
(let ([port (open-file-output-port "data.gz"
              (file-options no-fail compressed))])
  (put-bytevector port (string->utf8 "Lots of repeated text... "))
  ; ... write more data
  (close-port port))

; Read compressed file
(let ([port (open-file-input-port "data.gz"
              (file-options compressed))])
  (let ([data (get-bytevector-all port)])
    (close-port port)
    data))

; Note: Compressed ports may not support positioning</code></pre>
    </ul>
    <br/><br/>


    <li>Custom Ports</li>
    <br/>
    <ul>
        <li>Custom binary input ports:</li>
<pre><code class="language-scheme line-numbers">; make-custom-binary-input-port
; Arguments:
;   id          - string identifier
;   read!       - (bytevector start count) -> bytes-read
;   get-position - () -> position, or #f
;   set-position! - (position) -> void, or #f
;   close       - () -> void, or #f

(define (make-repeating-port byte count)
  (let ([pos 0])
    (make-custom-binary-input-port
      "repeating-byte"
      (lambda (bv start n)          ; read!
        (let ([to-read (min n (- count pos))])
          (do ([i 0 (+ i 1)])
              ((= i to-read)
               (set! pos (+ pos to-read))
               to-read)
            (bytevector-u8-set! bv (+ start i) byte))))
      (lambda () pos)               ; get-position
      (lambda (p) (set! pos p))     ; set-position!
      #f)))                         ; close

(define port (make-repeating-port 65 10))  ; 10 'A's
(get-bytevector-all port)   ; #vu8(65 65 65 65 65 65 65 65 65 65)</code></pre>
        <br/>
        <li>Custom binary output ports:</li>
<pre><code class="language-scheme line-numbers">; make-custom-binary-output-port
; Arguments:
;   id           - string identifier
;   write!       - (bytevector start count) -> bytes-written
;   get-position - () -> position, or #f
;   set-position! - (position) -> void, or #f
;   close        - () -> void, or #f

; Port that counts bytes written
(define (make-counting-port)
  (let ([count 0])
    (values
      (make-custom-binary-output-port
        "counting"
        (lambda (bv start n)        ; write!
          (set! count (+ count n))
          n)                        ; Return bytes "written"
        #f                          ; get-position
        #f                          ; set-position!
        #f)                         ; close
      (lambda () count))))          ; Get count

(define-values (port get-count) (make-counting-port))
(put-bytevector port #vu8(1 2 3 4 5))
(put-bytevector port #vu8(6 7 8))
(get-count)                 ; 8</code></pre>
        <br/>
        <li>Custom textual ports:</li>
<pre><code class="language-scheme line-numbers">; make-custom-textual-input-port
(define (make-string-generator-port generator)
  (let ([buffer ""]
        [pos 0])
    (make-custom-textual-input-port
      "generator"
      (lambda (str start count)     ; read!
        (when (>= pos (string-length buffer))
          (set! buffer (generator))
          (set! pos 0))
        (if (string? buffer)
            (let ([available (- (string-length buffer) pos)])
              (let ([to-copy (min count available)])
                (string-copy! buffer pos str start to-copy)
                (set! pos (+ pos to-copy))
                to-copy))
            0))                     ; EOF
      #f                            ; get-position
      #f                            ; set-position!
      #f)))                         ; close

; make-custom-textual-output-port
(define (make-line-collector)
  (let ([lines '()])
    (values
      (make-custom-textual-output-port
        "line-collector"
        (lambda (str start count)   ; write!
          (let ([s (substring str start (+ start count))])
            (set! lines (cons s lines)))
          count)
        #f #f #f)
      (lambda () (reverse lines)))))  ; Get lines</code></pre>
        <br/>
        <li>Custom input/output ports:</li>
<pre><code class="language-scheme line-numbers">; make-custom-binary-input/output-port
; Combines read! and write! procedures

(define (make-memory-port size)
  (let ([buffer (make-bytevector size 0)]
        [pos 0])
    (make-custom-binary-input/output-port
      "memory"
      (lambda (bv start count)      ; read!
        (let ([to-read (min count (- size pos))])
          (bytevector-copy! buffer pos bv start to-read)
          (set! pos (+ pos to-read))
          to-read))
      (lambda (bv start count)      ; write!
        (let ([to-write (min count (- size pos))])
          (bytevector-copy! bv start buffer pos to-write)
          (set! pos (+ pos to-write))
          to-write))
      (lambda () pos)               ; get-position
      (lambda (p) (set! pos p))     ; set-position!
      (lambda () #f))))             ; close

(define mem (make-memory-port 100))
(put-bytevector mem #vu8(1 2 3 4 5))
(set-port-position! mem 0)
(get-bytevector-n mem 5)    ; #vu8(1 2 3 4 5)</code></pre>
    </ul>
    <br/><br/>


    <li>Input Operations</li>
    <br/>
    <ul>
        <li>Reading bytes (binary input):</li>
<pre><code class="language-scheme line-numbers">; Read single byte
(get-u8 port)               ; Returns byte (0-255) or eof-object

; Lookahead (don't consume)
(lookahead-u8 port)         ; Peek at next byte

; Read multiple bytes
(get-bytevector-n port 10)  ; Read exactly 10 bytes (or less at EOF)
(get-bytevector-n! port bv start count)  ; Read into existing bytevector

; Read all remaining bytes
(get-bytevector-all port)   ; Returns bytevector or eof-object

; Read some bytes (may return fewer)
(get-bytevector-some port)  ; Read available bytes, at least 1

; Example
(let ([port (open-bytevector-input-port #vu8(1 2 3 4 5))])
  (list (get-u8 port)       ; 1
        (get-u8 port)       ; 2
        (get-bytevector-n port 2)))  ; #vu8(3 4)</code></pre>
        <br/>
        <li>Reading characters (textual input):</li>
<pre><code class="language-scheme line-numbers">; Read single character
(get-char port)             ; Returns char or eof-object
(read-char port)            ; R5RS name, same behavior
(read-char)                 ; From current-input-port

; Lookahead
(lookahead-char port)       ; Peek at next character
(peek-char port)            ; R5RS name

; Read string of fixed length
(get-string-n port 10)      ; Read 10 characters
(get-string-n! port str start count)  ; Into existing string

; Read all remaining characters
(get-string-all port)       ; Entire remaining content

; Read some characters
(get-string-some port)      ; Read available, at least 1

; Example
(let ([port (open-input-string "Hello")])
  (list (get-char port)     ; #\H
        (lookahead-char port) ; #\e (not consumed)
        (get-char port)))   ; #\e</code></pre>
        <br/>
        <li>Reading lines:</li>
<pre><code class="language-scheme line-numbers">; Read line (until newline or EOF)
(get-line port)             ; Returns string without newline
(read-line port)            ; Chez extension, same as get-line
(read-line)                 ; From current-input-port

; Example
(let ([port (open-input-string "Line 1\nLine 2\nLine 3")])
  (list (get-line port)     ; "Line 1"
        (get-line port)     ; "Line 2"
        (get-line port)     ; "Line 3"
        (get-line port)))   ; #!eof

; Read all lines
(define (port->lines port)
  (let loop ([lines '()])
    (let ([line (get-line port)])
      (if (eof-object? line)
          (reverse lines)
          (loop (cons line lines))))))

; With continuation for each line
(define (for-each-line port proc)
  (let loop ()
    (let ([line (get-line port)])
      (unless (eof-object? line)
        (proc line)
        (loop)))))</code></pre>
        <br/>
        <li>Reading Scheme data:</li>
<pre><code class="language-scheme line-numbers">; Read Scheme datum
(read port)                 ; Parse one Scheme object
(read)                      ; From current-input-port

; Examples
(read (open-input-string "42"))        ; 42
(read (open-input-string "(+ 1 2)"))   ; (+ 1 2)
(read (open-input-string "#(1 2 3)"))  ; #(1 2 3)
(read (open-input-string "'hello"))    ; 'hello = (quote hello)

; Read multiple datums
(let ([port (open-input-string "1 2 3")])
  (list (read port) (read port) (read port)))
; (1 2 3)

; Read with shared structure
(let ([port (open-input-string "#0=(1 . #0#)")])
  (read port))              ; Circular list

; Chez extensions
(get-datum port)            ; Same as read
(get-datum/annotations port)  ; With source annotations</code></pre>
        <br/>
        <li>Reading with parameters:</li>
<pre><code class="language-scheme line-numbers">; Control read behavior with parameters
(parameterize ([case-sensitive #t])  ; Preserve symbol case
  (read (open-input-string "Hello")))  ; Hello (not hello)

; Read with source information (Chez extension)
(read-token port)           ; Returns token type and value

; Skip whitespace and comments
(define (skip-whitespace port)
  (let ([c (lookahead-char port)])
    (when (and (char? c) (char-whitespace? c))
      (get-char port)
      (skip-whitespace port))))

; Check for EOF
(eof-object? (read port))   ; #t at end of file
(port-eof? port)            ; #t if at EOF (Chez extension)</code></pre>
    </ul>
    <br/><br/>


    <li>Output Operations</li>
    <br/>
    <ul>
        <li>Writing bytes (binary output):</li>
<pre><code class="language-scheme line-numbers">; Write single byte
(put-u8 port 65)            ; Write byte 65 ('A')

; Write bytevector
(put-bytevector port #vu8(1 2 3 4 5))

; Write portion of bytevector
(put-bytevector port bv start count)

; Example
(let ([port (open-bytevector-output-port)])
  (put-u8 port 72)          ; H
  (put-u8 port 105)         ; i
  (get-output-bytevector port))
; #vu8(72 105)</code></pre>
        <br/>
        <li>Writing characters (textual output):</li>
<pre><code class="language-scheme line-numbers">; Write single character
(put-char port #\A)
(write-char #\A port)       ; R5RS name
(write-char #\A)            ; To current-output-port

; Write string
(put-string port "Hello")
(put-string port str start count)  ; Portion of string

; Write newline
(newline port)
(newline)                   ; To current-output-port

; Example
(let ([port (open-output-string)])
  (put-char port #\H)
  (put-string port "ello")
  (newline port)
  (get-output-string port)) ; "Hello\n"</code></pre>
        <br/>
        <li>Display and write:</li>
<pre><code class="language-scheme line-numbers">; display - human-readable output
(display "Hello" port)      ; Hello (no quotes)
(display 42 port)           ; 42
(display #\A port)          ; A (no #\)
(display '(1 2 3) port)     ; (1 2 3)

; write - machine-readable output (can be read back)
(write "Hello" port)        ; "Hello" (with quotes)
(write 42 port)             ; 42
(write #\A port)            ; #\A
(write '(1 2 3) port)       ; (1 2 3)

; Difference
(let ([port (open-output-string)])
  (display "Hello\n" port)
  (get-output-string port)) ; "Hello\n" (actual newline)

(let ([port (open-output-string)])
  (write "Hello\n" port)
  (get-output-string port)) ; "\"Hello\\n\"" (escaped)

; write output can be read back
(equal? '(1 2 3)
        (read (open-input-string
                (with-output-to-string
                  (lambda () (write '(1 2 3)))))))
; #t</code></pre>
        <br/>
        <li>Put-datum and write variants:</li>
<pre><code class="language-scheme line-numbers">; put-datum - R6RS standard write
(put-datum port '(1 2 3))

; print - Chez extension, like write but handles cycles
(print '(1 2 3) port)

; Write with shared structure
(let ([x (list 1 2 3)])
  (set-car! (cddr x) x)     ; Create cycle
  (parameterize ([print-graph #t])
    (write x)))             ; #0=(1 2 #0#)

; printf for formatted output
(printf "Hello, ~a!~n" "World")

; fprintf to specific port
(fprintf port "Value: ~a~n" 42)</code></pre>
    </ul>
    <br/><br/>


    <li>Input/Output Operations</li>
    <br/>
    <ul>
        <li>Standard I/O shortcuts:</li>
<pre><code class="language-scheme line-numbers">; These use current-input-port or current-output-port

; Input shortcuts
(read)                      ; (read (current-input-port))
(read-char)                 ; (read-char (current-input-port))
(peek-char)                 ; (peek-char (current-input-port))
(read-line)                 ; (read-line (current-input-port))

; Output shortcuts
(display x)                 ; (display x (current-output-port))
(write x)                   ; (write x (current-output-port))
(newline)                   ; (newline (current-output-port))
(write-char c)              ; (write-char c (current-output-port))

; Flush
(flush-output-port)         ; Flush current-output-port</code></pre>
        <br/>
        <li>File copy operations:</li>
<pre><code class="language-scheme line-numbers">; Copy file (binary)
(define (copy-binary-file src dst)
  (call-with-port (open-file-input-port src)
    (lambda (in)
      (call-with-port (open-file-output-port dst
                        (file-options no-fail))
        (lambda (out)
          (let ([buffer (make-bytevector 4096)])
            (let loop ()
              (let ([n (get-bytevector-n! in buffer 0 4096)])
                (unless (eof-object? n)
                  (put-bytevector out buffer 0 n)
                  (loop))))))))))

; Copy file (textual)
(define (copy-text-file src dst)
  (call-with-input-file src
    (lambda (in)
      (call-with-output-file dst
        (lambda (out)
          (let loop ()
            (let ([line (get-line in)])
              (unless (eof-object? line)
                (put-string out line)
                (newline out)
                (loop)))))
        '(replace)))))</code></pre>
        <br/>
        <li>Transcoding between ports:</li>
<pre><code class="language-scheme line-numbers">; Convert file encoding
(define (convert-encoding input-file output-file
                          input-codec output-codec)
  (let ([in (open-file-input-port input-file
              (file-options)
              'block
              (make-transcoder input-codec))]
        [out (open-file-output-port output-file
               (file-options no-fail)
               'block
               (make-transcoder output-codec))])
    (let loop ()
      (let ([s (get-string-some in)])
        (unless (eof-object? s)
          (put-string out s)
          (loop))))
    (close-port in)
    (close-port out)))

; UTF-8 to Latin-1
(convert-encoding "utf8.txt" "latin1.txt"
                  (utf-8-codec) (latin-1-codec))</code></pre>
        <br/>
        <li>Interactive I/O:</li>
<pre><code class="language-scheme line-numbers">; Prompt and read
(define (prompt-read prompt)
  (display prompt)
  (flush-output-port)
  (read-line))

(define name (prompt-read "Enter your name: "))

; Yes/no prompt
(define (yes-or-no? prompt)
  (display prompt)
  (display " (yes/no) ")
  (flush-output-port)
  (let ([response (read-line)])
    (cond
      [(member response '("yes" "y" "Y" "YES")) #t]
      [(member response '("no" "n" "N" "NO")) #f]
      [else
       (display "Please answer yes or no.\n")
       (yes-or-no? prompt)])))

; Read with default
(define (prompt-with-default prompt default)
  (printf "~a [~a]: " prompt default)
  (flush-output-port)
  (let ([response (read-line)])
    (if (string=? response "")
        default
        response)))</code></pre>
    </ul>
    <br/><br/>


    <li>Non-Unicode Bytevector/String Conversions</li>
    <br/>
    <ul>
        <li>Legacy encoding conversions:</li>
<pre><code class="language-scheme line-numbers">; Latin-1 (ISO-8859-1) conversions
(define (string->latin-1 str)
  (let ([bv (make-bytevector (string-length str))])
    (do ([i 0 (+ i 1)])
        ((= i (string-length str)) bv)
      (let ([c (char->integer (string-ref str i))])
        (if (> c 255)
            (bytevector-u8-set! bv i #x3F)  ; '?' for unmappable
            (bytevector-u8-set! bv i c))))))

(define (latin-1->string bv)
  (let ([str (make-string (bytevector-length bv))])
    (do ([i 0 (+ i 1)])
        ((= i (bytevector-length bv)) str)
      (string-set! str i
        (integer->char (bytevector-u8-ref bv i))))))

; Using transcoders
(define (string->bytevector/transcoder str tc)
  (call-with-bytevector-output-port
    (lambda (port)
      (put-string (transcoded-port port tc) str))))

(string->bytevector/transcoder "Hello"
  (make-transcoder (latin-1-codec)))</code></pre>
        <br/>
        <li>ASCII conversions:</li>
<pre><code class="language-scheme line-numbers">; ASCII string to bytevector
(define (string->ascii str)
  (let ([bv (make-bytevector (string-length str))])
    (do ([i 0 (+ i 1)])
        ((= i (string-length str)) bv)
      (let ([c (char->integer (string-ref str i))])
        (bytevector-u8-set! bv i (fxand c #x7F))))))

; Bytevector to ASCII string
(define (ascii->string bv)
  (let ([str (make-string (bytevector-length bv))])
    (do ([i 0 (+ i 1)])
        ((= i (bytevector-length bv)) str)
      (string-set! str i
        (integer->char (bytevector-u8-ref bv i))))))

; Check if string is ASCII-safe
(define (ascii-string? str)
  (let loop ([i 0])
    (or (= i (string-length str))
        (and (< (char->integer (string-ref str i)) 128)
             (loop (+ i 1))))))</code></pre>
        <br/>
        <li>Bytevector encoding utilities:</li>
<pre><code class="language-scheme line-numbers">; Hex encoding
(define (bytevector->hex-string bv)
  (let ([str (make-string (* 2 (bytevector-length bv)))])
    (do ([i 0 (+ i 1)])
        ((= i (bytevector-length bv)) str)
      (let* ([b (bytevector-u8-ref bv i)]
             [hi (fxsrl b 4)]
             [lo (fxand b #xF)])
        (string-set! str (* i 2)
          (string-ref "0123456789abcdef" hi))
        (string-set! str (+ (* i 2) 1)
          (string-ref "0123456789abcdef" lo))))))

(bytevector->hex-string #vu8(255 128 0))  ; "ff8000"

; Hex decoding
(define (hex-string->bytevector str)
  (let* ([len (quotient (string-length str) 2)]
         [bv (make-bytevector len)])
    (do ([i 0 (+ i 1)])
        ((= i len) bv)
      (let ([hi (string-ref str (* i 2))]
            [lo (string-ref str (+ (* i 2) 1))])
        (bytevector-u8-set! bv i
          (+ (* 16 (hex-digit hi))
             (hex-digit lo)))))))

(define (hex-digit c)
  (cond
    [(char&lt;=? #\0 c #\9) (- (char->integer c) 48)]
    [(char&lt;=? #\a c #\f) (+ 10 (- (char->integer c) 97))]
    [(char&lt;=? #\A c #\F) (+ 10 (- (char->integer c) 65))]
    [else (error 'hex-digit "invalid hex digit" c)]))</code></pre>
        <br/>
        <li>Base64 encoding:</li>
<pre><code class="language-scheme line-numbers">; Base64 encoding
(define base64-chars
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")

(define (bytevector->base64 bv)
  (let* ([len (bytevector-length bv)]
         [out-len (* 4 (ceiling (/ len 3)))]
         [str (make-string out-len #\=)])
    (let loop ([i 0] [j 0])
      (when (< i len)
        (let* ([b0 (bytevector-u8-ref bv i)]
               [b1 (if (< (+ i 1) len)
                       (bytevector-u8-ref bv (+ i 1)) 0)]
               [b2 (if (< (+ i 2) len)
                       (bytevector-u8-ref bv (+ i 2)) 0)]
               [n (+ (ash b0 16) (ash b1 8) b2)])
          (string-set! str j
            (string-ref base64-chars (fxand (fxsrl n 18) #x3F)))
          (string-set! str (+ j 1)
            (string-ref base64-chars (fxand (fxsrl n 12) #x3F)))
          (when (< (+ i 1) len)
            (string-set! str (+ j 2)
              (string-ref base64-chars (fxand (fxsrl n 6) #x3F))))
          (when (< (+ i 2) len)
            (string-set! str (+ j 3)
              (string-ref base64-chars (fxand n #x3F))))
          (loop (+ i 3) (+ j 4)))))
    str))

(bytevector->base64 #vu8(72 101 108 108 111))  ; "SGVsbG8="</code></pre>
    </ul>
    <br/><br/>


    <li>Pretty Printing</li>
    <br/>
    <ul>
        <li>Basic pretty printing:</li>
<pre><code class="language-scheme line-numbers">; pretty-print formats Scheme data nicely
(pretty-print '(define (factorial n)
                 (if (zero? n)
                     1
                     (* n (factorial (- n 1))))))
; Prints with proper indentation

; Compare with write
(write '(define (factorial n) (if (zero? n) 1 (* n (factorial (- n 1))))))
; Prints on one line

; Pretty-print to specific port
(pretty-print datum port)

; Pretty-print to string
(with-output-to-string
  (lambda ()
    (pretty-print '(1 2 3))))</code></pre>
        <br/>
        <li>Pretty printing parameters:</li>
<pre><code class="language-scheme line-numbers">; Line width
(pretty-line-length)        ; Get current (default 75)
(pretty-line-length 100)    ; Set to 100

(parameterize ([pretty-line-length 40])
  (pretty-print long-expression))

; Initial indentation
(pretty-initial-indent 4)   ; Start with 4 spaces

; One-line limit (try to fit on one line if under this)
(pretty-one-line-limit)     ; Get
(pretty-one-line-limit 60)  ; Set

; Maximum depth
(print-level)               ; Maximum nesting depth
(parameterize ([print-level 3])
  (pretty-print deeply-nested))  ; Shows ... for deeper

; Maximum length
(print-length)              ; Maximum list length
(parameterize ([print-length 10])
  (pretty-print long-list))      ; Shows ... after 10</code></pre>
        <br/>
        <li>Pretty format control:</li>
<pre><code class="language-scheme line-numbers">; pretty-format sets formatting for specific forms
(pretty-format 'my-special-form
  '(my-special-form (bracket x ...) #f body ...))

; Format specifiers:
; (bracket x ...)  - arguments on same line
; #f               - break here
; body ...         - indented body expressions

; Built-in formats
(pretty-format 'define)     ; See how define is formatted
(pretty-format 'lambda)     ; See how lambda is formatted
(pretty-format 'let)        ; See how let is formatted

; Custom formatting for DSL
(pretty-format 'when-valid
  '(when-valid test #f body ...))

; Reset to default
(pretty-format 'my-form #f)</code></pre>
        <br/>
        <li>Print parameters affecting output:</li>
<pre><code class="language-scheme line-numbers">; print-graph - handle shared/cyclic structure
(parameterize ([print-graph #t])
  (let ([x (list 1 2 3)])
    (set-cdr! (cddr x) x)
    (pretty-print x)))      ; #0=(1 2 3 . #0#)

; print-vector-length - show vector length
(parameterize ([print-vector-length #t])
  (pretty-print '#(1 2 3))) ; #3(1 2 3)

; print-gensym - how to print gensyms
(parameterize ([print-gensym #t])
  (pretty-print (gensym "x")))  ; #{x n}

; print-brackets - use [ ] for some forms
(parameterize ([print-brackets #t])
  (pretty-print '(let ([x 1] [y 2]) (+ x y))))
; (let ([x 1] [y 2]) (+ x y))

; print-unicode - use Unicode escapes
(parameterize ([print-unicode #f])
  (write #\λ))              ; #\x3BB</code></pre>
    </ul>
    <br/><br/>


    <li>Formatted Output</li>
    <br/>
    <ul>
        <li>Format strings with format and printf:</li>
<pre><code class="language-scheme line-numbers">; format returns string
(format "Hello, ~a!" "World")   ; "Hello, World!"

; printf prints to current-output-port
(printf "Hello, ~a!~n" "World")

; fprintf prints to specific port
(fprintf port "Value: ~a~n" 42)

; errorf prints to current-error-port and raises error
(errorf 'proc "Error: ~a" message)

; warningf prints warning
(warningf 'proc "Warning: ~a" message)</code></pre>
        <br/>
        <li>Common format directives:</li>
<pre><code class="language-scheme line-numbers">; ~a - display (aesthetic, human-readable)
(format "~a" "hello")       ; "hello" (no quotes)
(format "~a" 42)            ; "42"
(format "~a" '(1 2 3))      ; "(1 2 3)"

; ~s - write (machine-readable)
(format "~s" "hello")       ; "\"hello\"" (with quotes)
(format "~s" #\a)           ; "#\\a"

; ~d - decimal integer
(format "~d" 42)            ; "42"

; ~b - binary
(format "~b" 42)            ; "101010"

; ~o - octal
(format "~o" 42)            ; "52"

; ~x - hexadecimal (lowercase)
(format "~x" 255)           ; "ff"

; ~X - hexadecimal (uppercase)
(format "~X" 255)           ; "FF"

; ~c - character
(format "~c" #\A)           ; "A"

; ~% or ~n - newline
(format "Line 1~%Line 2")   ; "Line 1\nLine 2"
(format "Line 1~nLine 2")   ; Same

; ~~ - literal tilde
(format "50~~")             ; "50~"</code></pre>
        <br/>
        <li>Numeric formatting:</li>
<pre><code class="language-scheme line-numbers">; Width specification
(format "~5d" 42)           ; "   42" (right-aligned)
(format "~5,'0d" 42)        ; "00042" (zero-padded)

; Floating point
(format "~f" 3.14159)       ; "3.14159"
(format "~,2f" 3.14159)     ; "3.14" (2 decimal places)
(format "~8,2f" 3.14159)    ; "    3.14" (width 8)

; Scientific notation
(format "~e" 12345.6)       ; "1.23456e4"
(format "~,2e" 12345.6)     ; "1.23e4"

; General (chooses f or e)
(format "~g" 0.0001)        ; Uses exponential
(format "~g" 3.14)          ; Uses fixed

; With sign
(format "~@d" 42)           ; "+42"
(format "~@d" -42)          ; "-42"

; Comma separation (Chez extension)
(format "~:d" 1000000)      ; "1,000,000"</code></pre>
        <br/>
        <li>Padding and alignment:</li>
<pre><code class="language-scheme line-numbers">; Right-align (default)
(format "~10a" "hello")     ; "     hello"

; Left-align with @
(format "~10@a" "hello")    ; "hello     "

; Custom padding character
(format "~10,'*a" "hello")  ; "*****hello"

; Truncation
(format "~5a" "hello world") ; "hello" (truncated)

; Combining width and precision
(format "~10,5a" "hello world")  ; Truncate to 5, pad to 10

; Multiple values
(format "~a ~a ~a" 1 2 3)   ; "1 2 3"

; Using * for computed width
(format "~va" 10 "hello")   ; "     hello" (width from arg)</code></pre>
        <br/>
        <li>Conditional and iteration directives:</li>
<pre><code class="language-scheme line-numbers">; ~[ ~] - conditional
(format "~[zero~;one~;two~]" 1)     ; "one"
(format "~[zero~;one~;two~:;many~]" 5)  ; "many" (default)

; ~{ ~} - iteration
(format "~{~a ~}" '(1 2 3)) ; "1 2 3 "
(format "~{~a~^, ~}" '(1 2 3))  ; "1, 2, 3" (no trailing comma)

; ~? or ~@ - recursive format
(format "~?" "~a + ~a" '(1 2))  ; "1 + 2"

; ~* - skip argument
(format "~a ~* ~a" 1 2 3)   ; "1  3"

; ~p - plural
(format "~d item~p" 1)      ; "1 item"
(format "~d item~p" 2)      ; "2 items"
(format "~d ~:p" 2)         ; "2 ies" (y -> ies)

; ~r - radix
(format "~2r" 42)           ; "101010" (binary)
(format "~16r" 255)         ; "ff" (hex)
(format "~r" 42)            ; "forty-two" (English)</code></pre>
    </ul>
    <br/><br/>


    <li>Input/Output Control Operations</li>
    <br/>
    <ul>
        <li>Buffer control:</li>
<pre><code class="language-scheme line-numbers">; Flush output buffer
(flush-output-port port)
(flush-output-port)         ; Current output port

; Get buffer mode
(output-port-buffer-mode port)  ; 'none, 'line, 'block

; Block vs line buffering
; - block: flush when buffer full
; - line: flush on newline
; - none: write immediately

; Example: ensure prompt appears before input
(display "Enter name: ")
(flush-output-port)
(read-line)

; Clear input buffer (Chez extension)
(clear-input-port port)     ; Discard buffered input

; Clear output buffer (Chez extension)
(clear-output-port port)    ; Discard without writing</code></pre>
        <br/>
        <li>Port positioning:</li>
<pre><code class="language-scheme line-numbers">; File position
(file-position port)        ; Get current position

(file-position port 0)      ; Seek to beginning
(file-position port 100)    ; Seek to byte 100

; Chez extension: seek from end
(file-position port (- (file-length port) 10))  ; 10 from end

; Standard R6RS positioning
(port-has-port-position? port)  ; Can get position?
(port-position port)            ; Get position

(port-has-set-port-position!? port)  ; Can set?
(set-port-position! port 0)          ; Set position

; Truncate file at current position (Chez extension)
(truncate-port port)

; File length (Chez extension)
(file-length port)          ; Total file size

; Set file length (Chez extension)
(set-file-length! port 100) ; Truncate or extend to 100 bytes</code></pre>
        <br/>
        <li>Port status and information:</li>
<pre><code class="language-scheme line-numbers">; Check for available input (non-blocking)
(input-port-ready? port)    ; #t if data available
(char-ready? port)          ; Same for textual ports

; Check for EOF
(port-eof? port)            ; #t if at end of file

; Port name (for error messages)
(port-name port)            ; Returns string

; Port file descriptor (Chez extension)
(port-file-descriptor port) ; OS file descriptor or #f

; Check if port is a file port
(file-port? port)           ; #t if backed by file

; Mark port as closed state
(mark-port-closed! port)    ; Chez extension</code></pre>
        <br/>
        <li>Timeout operations (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Set read timeout
(set-port-input-timeout! port seconds)

; Non-blocking mode
(set-port-input-timeout! port 0)  ; Return immediately

; Example: read with timeout
(define (read-with-timeout port seconds)
  (set-port-input-timeout! port seconds)
  (let ([result (guard (c [#t #f])
                  (read port))])
    (set-port-input-timeout! port #f)  ; Reset
    result))

; Check if input ready before blocking read
(define (safe-read port)
  (if (input-port-ready? port)
      (read port)
      'no-input))</code></pre>
    </ul>
    <br/><br/>


    <li>Fasl Output</li>
    <br/>
    <ul>
        <li>Fasl (Fast Load) format:</li>
<pre><code class="language-scheme line-numbers">; Fasl is a compact binary format for Scheme data
; Used for compiled files, faster than text read/write

; Write fasl output
(fasl-write datum port)

; Read fasl input
(fasl-read port)            ; Returns datum

; Example: save and restore data
(call-with-port
  (open-file-output-port "data.fasl"
    (file-options no-fail))
  (lambda (port)
    (fasl-write '(1 2 3 4 5) port)
    (fasl-write '#(a b c) port)))

(call-with-port
  (open-file-input-port "data.fasl")
  (lambda (port)
    (list (fasl-read port)
          (fasl-read port))))
; ((1 2 3 4 5) #(a b c))</code></pre>
        <br/>
        <li>Fasl for compiled code:</li>
<pre><code class="language-scheme line-numbers">; Compile to fasl file
(compile-file "source.ss")  ; Creates source.so

; Compile to specific output
(compile-file "source.ss" "output.so")

; Compile library
(compile-library "mylib.ss")

; Compile whole program
(compile-program "main.ss")

; Load compiled file
(load "source.so")          ; Load fasl file
(load-library "mylib.so")

; Visit (load but don't instantiate)
(visit "mylib.so")

; Revisit (visit again)
(revisit "mylib.so")</code></pre>
        <br/>
        <li>Fasl compression:</li>
<pre><code class="language-scheme line-numbers">; Compressed fasl output
(parameterize ([fasl-compressed #t])
  (fasl-write large-datum port))

; Check compression setting
(fasl-compressed)           ; #t or #f

; Compression level (Chez extension)
(fasl-compressed 'lz4)      ; Fast compression
(fasl-compressed 'gzip)     ; Better compression

; Compile with compression
(parameterize ([compile-compressed #t])
  (compile-file "source.ss"))</code></pre>
        <br/>
        <li>Fasl version and compatibility:</li>
<pre><code class="language-scheme line-numbers">; Fasl version (Chez extension)
(fasl-version)              ; Current fasl format version

; Cross-compilation fasl
; Fasl files are platform-specific by default

; Strip fasl file (remove debugging info)
(strip-fasl-file "input.so" "output.so")

; Fasl can store most Scheme objects:
; - Lists, vectors, bytevectors
; - Strings, symbols, numbers
; - Records (with proper setup)
; - Procedures (as compiled code)
; - Hashtables

; Cannot store:
; - Ports
; - Foreign pointers
; - Locked objects</code></pre>
    </ul>
    <br/><br/>


    <li>File System Interface</li>
    <br/>
    <ul>
        <li>File existence and type:</li>
<pre><code class="language-scheme line-numbers">; Check file existence
(file-exists? "data.txt")   ; #t if exists

; File type
(file-regular? "data.txt")  ; #t if regular file
(file-directory? "mydir")   ; #t if directory
(file-symbolic-link? "link") ; #t if symlink

; Get file type
(file-type "path")          ; 'regular, 'directory, 'symbolic-link,
                            ; 'char-device, 'block-device,
                            ; 'fifo, 'socket

; Follow symlinks
(file-type "path" #t)       ; Follow symlinks</code></pre>
        <br/>
        <li>File information:</li>
<pre><code class="language-scheme line-numbers">; File size
(file-size "data.txt")      ; Size in bytes (Chez extension)

; Modification time
(file-modification-time "data.txt")  ; Time value

; Access time
(file-access-time "data.txt")

; Change time
(file-change-time "data.txt")

; Compare times
(time&lt;? (file-modification-time "a.txt")
        (file-modification-time "b.txt"))

; Convert to date
(date-and-time (file-modification-time "data.txt"))</code></pre>
        <br/>
        <li>File operations:</li>
<pre><code class="language-scheme line-numbers">; Delete file
(delete-file "data.txt")
(delete-file "data.txt" #f)  ; Don't error if missing

; Rename/move file
(rename-file "old.txt" "new.txt")

; Copy file (Chez extension)
(copy-file "src.txt" "dst.txt")

; Create symbolic link (Unix)
(create-symbolic-link "target" "link")

; Read symbolic link
(read-symbolic-link "link") ; Returns target path

; File permissions (Unix)
(chmod "file.txt" #o644)    ; Chez extension
(file-permissions "file.txt")  ; Get permissions</code></pre>
        <br/>
        <li>Directory operations:</li>
<pre><code class="language-scheme line-numbers">; Create directory
(mkdir "newdir")
(mkdir "newdir" #o755)      ; With permissions

; Delete directory (must be empty)
(rmdir "emptydir")
(delete-directory "emptydir")

; Delete directory recursively (Chez extension)
(delete-directory "dir" #t)

; List directory contents
(directory-list ".")        ; List of filenames
(directory-list "." #t)     ; Include hidden files (Chez)

; Example: find all .ss files
(filter (lambda (f) (string-suffix? ".ss" f))
        (directory-list "."))

; Current directory
(current-directory)         ; Get current directory
(current-directory "/tmp")  ; Change directory

; Path manipulation (Chez extensions)
(path-last "a/b/c.txt")     ; "c.txt"
(path-parent "a/b/c.txt")   ; "a/b"
(path-extension "file.txt") ; "txt"
(path-root "file.txt")      ; "file"</code></pre>
        <br/>
        <li>Path utilities:</li>
<pre><code class="language-scheme line-numbers">; Combine path components
(define (path-join . parts)
  (let loop ([parts parts] [acc ""])
    (if (null? parts)
        acc
        (let ([part (car parts)])
          (loop (cdr parts)
                (if (string=? acc "")
                    part
                    (string-append acc "/" part)))))))

(path-join "a" "b" "c.txt") ; "a/b/c.txt"

; Absolute path check
(define (absolute-path? path)
  (and (> (string-length path) 0)
       (char=? (string-ref path 0) #\/)))

; Normalize path (remove . and ..)
(define (normalize-path path)
  (let loop ([parts (string-split path "/")]
             [acc '()])
    (cond
      [(null? parts)
       (string-join (reverse acc) "/")]
      [(string=? (car parts) ".")
       (loop (cdr parts) acc)]
      [(and (string=? (car parts) "..")
            (pair? acc)
            (not (string=? (car acc) "..")))
       (loop (cdr parts) (cdr acc))]
      [else
       (loop (cdr parts) (cons (car parts) acc))])))

; Get absolute path (Chez extension)
(cd "relative")             ; Alias for current-directory
(current-directory)</code></pre>
        <br/>
        <li>Temporary files:</li>
<pre><code class="language-scheme line-numbers">; Create temporary file name
(tmpnam)                    ; Deprecated, returns temp filename

; Open temporary file (Chez extension)
(open-temporary-file)       ; Returns port and filename

; Better: use standard temp directory
(define (temp-directory)
  (or (getenv "TMPDIR")
      (getenv "TMP")
      (getenv "TEMP")
      "/tmp"))

; Create temporary file with prefix
(define (make-temp-file prefix)
  (let loop ([n 0])
    (let ([name (format "~a/~a~a" (temp-directory) prefix n)])
      (if (file-exists? name)
          (loop (+ n 1))
          name))))

; Clean up temporary files
(define (with-temp-file prefix proc)
  (let ([filename (make-temp-file prefix)])
    (dynamic-wind
      (lambda () #f)
      (lambda () (proc filename))
      (lambda ()
        (when (file-exists? filename)
          (delete-file filename))))))</code></pre>
    </ul>
    <br/><br/>


    <li>Generic Port Examples</li>
    <br/>
    <ul>
        <li>Logging port wrapper:</li>
<pre><code class="language-scheme line-numbers">; Create a port that logs all output
(define (make-logging-port underlying-port log-port)
  (make-custom-textual-output-port
    "logging-port"
    (lambda (str start count)       ; write!
      (put-string underlying-port str start count)
      (put-string log-port str start count)
      (flush-output-port log-port)
      count)
    #f                              ; get-position
    #f                              ; set-position!
    (lambda ()                      ; close
      (close-port underlying-port))))

; Usage
(define log-file (open-output-file "output.log" '(replace)))
(define logged-output
  (make-logging-port (current-output-port) log-file))

(parameterize ([current-output-port logged-output])
  (display "This goes to both console and log\n"))

(close-port log-file)</code></pre>
        <br/>
        <li>Counting port:</li>
<pre><code class="language-scheme line-numbers">; Port that tracks lines and characters
(define (make-counting-input-port port)
  (let ([line 1]
        [col 0])
    (values
      (make-custom-textual-input-port
        "counting"
        (lambda (str start count)   ; read!
          (let ([n (get-string-n! port str start count)])
            (when (and (fixnum? n) (> n 0))
              (do ([i start (+ i 1)])
                  ((= i (+ start n)))
                (let ([c (string-ref str i)])
                  (if (char=? c #\newline)
                      (begin (set! line (+ line 1))
                             (set! col 0))
                      (set! col (+ col 1))))))
            n))
        #f #f
        (lambda () (close-port port)))
      (lambda () (values line col)))))  ; get-position

; Usage
(define-values (port get-pos)
  (make-counting-input-port
    (open-input-string "hello\nworld")))

(get-string-n port 7)       ; "hello\nw"
(get-pos)                   ; Values: 2, 1</code></pre>
        <br/>
        <li>Broadcast port (tee):</li>
<pre><code class="language-scheme line-numbers">; Write to multiple ports simultaneously
(define (make-broadcast-port . ports)
  (make-custom-textual-output-port
    "broadcast"
    (lambda (str start count)       ; write!
      (for-each
        (lambda (port)
          (put-string port str start count))
        ports)
      count)
    #f                              ; get-position
    #f                              ; set-position!
    (lambda ()                      ; close
      (for-each close-port ports))))

; Usage: write to file and console
(define both
  (make-broadcast-port
    (current-output-port)
    (open-output-file "copy.txt" '(replace))))

(display "This goes everywhere\n" both)
(close-port both)</code></pre>
        <br/>
        <li>Process port:</li>
<pre><code class="language-scheme line-numbers">; Create bidirectional port to subprocess
(define (open-process-port* command)
  (let-values ([(to-stdin from-stdout from-stderr pid)
                (open-process-ports command 'block (native-transcoder))])
    ; Create combined I/O port
    (make-custom-textual-input/output-port
      (format "process:~a" command)
      (lambda (str start count)     ; read!
        (if (input-port-ready? from-stdout)
            (get-string-n! from-stdout str start count)
            0))
      (lambda (str start count)     ; write!
        (put-string to-stdin str start count)
        (flush-output-port to-stdin)
        count)
      #f                            ; get-position
      #f                            ; set-position!
      (lambda ()                    ; close
        (close-port to-stdin)
        (close-port from-stdout)
        (close-port from-stderr)))))

; Usage
(define bc (open-process-port* "bc -l"))
(put-string bc "2 + 3\n")
(flush-output-port bc)
(get-line bc)               ; "5"
(close-port bc)</code></pre>
        <br/>
        <li>Limited input port:</li>
<pre><code class="language-scheme line-numbers">; Port that limits bytes read
(define (make-limited-input-port port limit)
  (let ([remaining limit])
    (make-custom-binary-input-port
      "limited"
      (lambda (bv start count)      ; read!
        (if (&lt;= remaining 0)
            0                       ; EOF
            (let* ([to-read (min count remaining)]
                   [n (get-bytevector-n! port bv start to-read)])
              (if (eof-object? n)
                  (begin (set! remaining 0) 0)
                  (begin (set! remaining (- remaining n)) n)))))
      #f                            ; get-position
      #f                            ; set-position!
      (lambda () (close-port port)))))

; Usage: read only first 100 bytes
(define limited
  (make-limited-input-port
    (open-file-input-port "large-file.bin")
    100))

(get-bytevector-all limited) ; At most 100 bytes
</code></pre>
        <br/>
        <li>Socket port example:</li>
<pre><code class="language-scheme line-numbers">; TCP socket ports (using foreign interface)
; Simplified example - see Foreign Interface chapter for details

(define (make-socket-port fd)
  (let ([closed? #f])
    (make-custom-binary-input/output-port
      (format "socket:~a" fd)
      (lambda (bv start count)      ; read!
        (if closed?
            0
            (let ([n (socket-read fd bv start count)])
              (if (&lt;= n 0) 0 n))))
      (lambda (bv start count)      ; write!
        (if closed?
            0
            (socket-write fd bv start count)))
      #f                            ; get-position
      #f                            ; set-position!
      (lambda ()                    ; close
        (set! closed? #t)
        (socket-close fd)))))

; With transcoder for text
(define (open-text-socket-port fd)
  (transcoded-port
    (make-socket-port fd)
    (make-transcoder (utf-8-codec) 'none 'replace)))
</code></pre>
        <br/>
        <li>Filtering port:</li>
<pre><code class="language-scheme line-numbers">; Transform input as it's read
(define (make-uppercase-port port)
  (make-custom-textual-input-port
    "uppercase"
    (lambda (str start count)       ; read!
      (let ([n (get-string-n! port str start count)])
        (when (fixnum? n)
          (do ([i start (+ i 1)])
              ((= i (+ start n)))
            (string-set! str i
              (char-upcase (string-ref str i)))))
        n))
    #f #f
    (lambda () (close-port port))))

; Usage
(define upper
  (make-uppercase-port
    (open-input-string "hello world")))

(get-string-all upper)      ; "HELLO WORLD"

; Transforming output port
(define (make-rot13-port port)
  (define (rot13-char c)
    (cond
      [(char&lt;=? #\a c #\m) (integer-&gt;char (+ (char-&gt;integer c) 13))]
      [(char&lt;=? #\n c #\z) (integer-&gt;char (- (char-&gt;integer c) 13))]
      [(char&lt;=? #\A c #\M) (integer-&gt;char (+ (char-&gt;integer c) 13))]
      [(char&lt;=? #\N c #\Z) (integer-&gt;char (- (char-&gt;integer c) 13))]
      [else c]))
  (make-custom-textual-output-port
    "rot13"
    (lambda (str start count)
      (let ([rotated (make-string count)])
        (do ([i 0 (+ i 1)])
            ((= i count))
          (string-set! rotated i
            (rot13-char (string-ref str (+ start i)))))
        (put-string port rotated)
        count))
    #f #f
    (lambda () (close-port port))))
</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
