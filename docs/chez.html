<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>chez scheme</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/chez.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#scm-syntax-overview">Syntax Overview</a></li>
        <li><a href="#scm-multiple-expressions">Multiple Expressions</a></li>
        <li><a href="#scm-naming-conventions">Naming Conventions</a></li>
        <li><a href="#scm-compiler-interpreter">Interacting with Chez Scheme</a></li>
        <li><a href="#scm-command-line-options">Command Line Options</a></li>
        <li><a href="#scm-r6rs">R6RS</a></li>
        <li><a href="#scm-control-flow">Control Flow</a></li>
        <li><a href="#scm-debugging">Debugging</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-syntax-overview">Chez Scheme Syntax Overview</h3>
<ol>

    <li>Understanding Scheme Basics</li>
    <br/>
    <ul>
        <li>Scheme is a dialect of Lisp with minimal, elegant syntax.</li>
        <br/>
        <li><b>Core principle:</b> Everything is an expression that returns a value.</li>
        <br/>
        <li><b>Syntax pattern:</b> <code>(function arg1 arg2 arg3 ...)</code></li>
        <ul>
            <li>Parentheses group expressions</li>
            <li>First element is the function/operator</li>
            <li>Remaining elements are arguments</li>
            <li>This is called "prefix notation" or "Polish notation"</li>
        </ul>
        <br/>
        <li><b>Examples of basic syntax:</b></li>
<pre><code class="language-scheme line-numbers">; Addition
(+ 2 3)          ; Returns: 5

; Multiplication
(* 4 5)          ; Returns: 20

; Function call
(string-length "hello")  ; Returns: 5

; Nested expressions
(+ (* 2 3) 4)    ; Returns: 10
                 ; First evaluates (* 2 3) = 6
                 ; Then evaluates (+ 6 4) = 10</code></pre>
        <br/>
        <li><b>Comments:</b></li>
<pre><code class="language-scheme line-numbers">; Single-line comment starts with semicolon

#|
  Multi-line
  comment between
  #| and |#
|#</code></pre>
        <br/>
        <li><b>Case sensitivity:</b> Scheme is case-insensitive by default, but Chez Scheme preserves case.</li>
<pre><code class="language-scheme line-numbers">(define MyVar 10)
MyVar    ; Works
MYVAR    ; Doesn't Work</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Data Types</li>
    <br/>
    <ul>
        <li>Scheme has several fundamental data types:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Examples</th>
            <th>Predicate</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Number</td>
            <td><code>42</code>, <code>3.14</code>, <code>1/3</code>, <code>2+3i</code></td>
            <td><code>number?</code></td>
        </tr>
        <tr>
            <td>Boolean</td>
            <td><code>#t</code>, <code>#f</code></td>
            <td><code>boolean?</code></td>
        </tr>
        <tr>
            <td>String</td>
            <td><code>"hello"</code>, <code>"world"</code></td>
            <td><code>string?</code></td>
        </tr>
        <tr>
            <td>Character</td>
            <td><code>#\a</code>, <code>#\space</code></td>
            <td><code>char?</code></td>
        </tr>
        <tr>
            <td>Symbol</td>
            <td><code>'foo</code>, <code>'bar</code></td>
            <td><code>symbol?</code></td>
        </tr>
        <tr>
            <td>List</td>
            <td><code>'(1 2 3)</code>, <code>'(a b c)</code></td>
            <td><code>list?</code></td>
        </tr>
        <tr>
            <td>Pair</td>
            <td><code>'(1 . 2)</code></td>
            <td><code>pair?</code></td>
        </tr>
        <tr>
            <td>Vector</td>
            <td><code>#(1 2 3)</code></td>
            <td><code>vector?</code></td>
        </tr>
        <tr>
            <td>Procedure</td>
            <td><code>(lambda (x) (* x x))</code></td>
            <td><code>procedure?</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Numbers:</b></li>
<pre><code class="language-scheme line-numbers">; Integers
42
-17
0

; Floating point
3.14
-2.5

; Fractions (exact rationals)
1/3
22/7

; Complex numbers
2+3i
-1-4i

; Different bases
#b1010      ; Binary (10 in decimal)
#o755       ; Octal (493 in decimal)
#x1A        ; Hexadecimal (26 in decimal)</code></pre>
        <br/>
        <li><b>Booleans:</b></li>
<pre><code class="language-scheme line-numbers">#t          ; True
#f          ; False

; Everything except #f is considered true
(if 0 'yes 'no)        ; Returns: yes
(if "" 'yes 'no)       ; Returns: yes
(if '() 'yes 'no)      ; Returns: yes
(if #f 'yes 'no)       ; Returns: no</code></pre>
        <br/>
        <li><b>Strings:</b></li>
<pre><code class="language-scheme line-numbers">"Hello, World!"
"Multiple\nlines"
"Escape \"quotes\""
""              ; Empty string</code></pre>
        <br/>
        <li><b>Characters:</b></li>
<pre><code class="language-scheme line-numbers">#\a             ; Letter 'a'
#\Z             ; Letter 'Z'
#\0             ; Digit '0'
#\space         ; Space character
#\newline       ; Newline character
#\tab           ; Tab character</code></pre>
        <br/>
        <li><b>Symbols:</b></li>
<pre><code class="language-scheme line-numbers">'foo            ; Symbol foo
'hello-world    ; Symbol hello-world
'+              ; Symbol +
'lambda         ; Symbol lambda

; Symbols are like unique identifiers/names</code></pre>
    </ul>
    <br/><br/>


    <li>Variables and Definitions</li>
    <br/>
    <ul>
        <li><b>define:</b> Create global variables and functions.</li>
        <br/>
        <li><b>Syntax for variables:</b></li>
<pre><code class="language-scheme line-numbers">(define variable-name value)</code></pre>
        <br/>
        <li><b>Examples:</b></li>
<pre><code class="language-scheme line-numbers">; Define a number
(define x 10)
x                   ; Returns: 10

; Define a string
(define message "Hello")
message             ; Returns: "Hello"

; Define using an expression
(define y (* 5 4))
y                   ; Returns: 20

; Redefine (changes value)
(define x 100)
x                   ; Returns: 100</code></pre>
        <br/>
        <li><b>Syntax for functions:</b></li>
<pre><code class="language-scheme line-numbers">(define (function-name parameter1 parameter2 ...)
  body-expression)</code></pre>
        <br/>
        <li><b>Function examples:</b></li>
<pre><code class="language-scheme line-numbers">; Simple function
(define (square x)
  (* x x))

(square 5)          ; Returns: 25

; Multiple parameters
(define (add a b)
  (+ a b))

(add 3 7)           ; Returns: 10

; Multiple expressions (returns last one)
(define (greet name)
  (display "Processing...")
  (newline)
  (string-append "Hello, " name "!"))

(greet "Alice")     ; Prints "Processing..." then returns "Hello, Alice!"</code></pre>
    </ul>
    <br/><br/>


    <li>Arithmetic Operations</li>
    <br/>
    <ul>
        <li>All arithmetic uses prefix notation.</li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Syntax</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Addition</td>
            <td><code>(+ n1 n2 ...)</code></td>
            <td><code>(+ 1 2 3)</code></td>
            <td>6</td>
        </tr>
        <tr>
            <td>Subtraction</td>
            <td><code>(- n1 n2 ...)</code></td>
            <td><code>(- 10 3)</code></td>
            <td>7</td>
        </tr>
        <tr>
            <td>Multiplication</td>
            <td><code>(* n1 n2 ...)</code></td>
            <td><code>(* 2 3 4)</code></td>
            <td>24</td>
        </tr>
        <tr>
            <td>Division</td>
            <td><code>(/ n1 n2 ...)</code></td>
            <td><code>(/ 10 2)</code></td>
            <td>5</td>
        </tr>
        <tr>
            <td>Quotient</td>
            <td><code>(quotient n1 n2)</code></td>
            <td><code>(quotient 10 3)</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td>Remainder</td>
            <td><code>(remainder n1 n2)</code></td>
            <td><code>(remainder 10 3)</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td>Modulo</td>
            <td><code>(modulo n1 n2)</code></td>
            <td><code>(modulo 10 3)</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td>Exponentiation</td>
            <td><code>(expt base exp)</code></td>
            <td><code>(expt 2 8)</code></td>
            <td>256</td>
        </tr>
        <tr>
            <td>Square root</td>
            <td><code>(sqrt n)</code></td>
            <td><code>(sqrt 16)</code></td>
            <td>4</td>
        </tr>
        <tr>
            <td>Absolute value</td>
            <td><code>(abs n)</code></td>
            <td><code>(abs -5)</code></td>
            <td>5</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Multiple arguments:</b></li>
<pre><code class="language-scheme line-numbers">(+ 1 2 3 4 5)       ; Returns: 15
(* 2 3 4)           ; Returns: 24

; With single argument
(+ 5)               ; Returns: 5
(- 10)              ; Returns: -10 (negation)

; No arguments
(+)                 ; Returns: 0
(*)                 ; Returns: 1</code></pre>
        <br/>
        <li><b>Nested operations:</b></li>
<pre><code class="language-scheme line-numbers">; Traditional: (2 + 3) * 4
(* (+ 2 3) 4)       ; Returns: 20

; Traditional: 2 + 3 * 4
(+ 2 (* 3 4))       ; Returns: 14

; Traditional: (10 - 2) / (3 + 1)
(/ (- 10 2) (+ 3 1))  ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Comparison and Logical Operations</li>
    <br/>
    <ul>
        <li><b>Comparison operators:</b></li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>=</code></td>
            <td>Numeric equality</td>
            <td><code>(= 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&lt;</code></td>
            <td>Less than</td>
            <td><code>(&lt; 3 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&gt;</code></td>
            <td>Greater than</td>
            <td><code>(&gt; 5 3)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&lt;=</code></td>
            <td>Less than or equal</td>
            <td><code>(&lt;= 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&gt;=</code></td>
            <td>Greater than or equal</td>
            <td><code>(&gt;= 5 3)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>eq?</code></td>
            <td>Same object</td>
            <td><code>(eq? 'a 'a)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>eqv?</code></td>
            <td>Equivalent value</td>
            <td><code>(eqv? 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>equal?</code></td>
            <td>Structurally equal</td>
            <td><code>(equal? '(1 2) '(1 2))</code></td>
            <td><code>#t</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Comparison examples:</b></li>
<pre><code class="language-scheme line-numbers">; Numeric comparisons
(= 5 5)             ; #t
(= 5 6)             ; #f
(&lt; 3 5)             ; #t
(&gt; 5 3)             ; #t

; Multiple arguments (chain)
(&lt; 1 2 3 4)         ; #t (all comparisons true)
(&lt; 1 3 2 4)         ; #f (3 is not &lt; 2)

; String comparison
(string=? "hello" "hello")    ; #t
(string&lt;? "abc" "xyz")        ; #t
</code></pre>
        <br/>
        <li><b>Logical operators:</b></li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>and</code></td>
            <td>Logical AND</td>
            <td><code>(and #t #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>or</code></td>
            <td>Logical OR</td>
            <td><code>(or #f #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>not</code></td>
            <td>Logical NOT</td>
            <td><code>(not #t)</code> → #f</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Logical examples:</b></li>
<pre><code class="language-scheme line-numbers">; AND - returns #f if any argument is #f
(and #t #t #t)      ; #t
(and #t #f #t)      ; #f

; OR - returns #t if any argument is true
(or #f #f #t)       ; #t
(or #f #f #f)       ; #f

; NOT
(not #t)            ; #f
(not #f)            ; #t

; Short-circuit evaluation
(and #f (display "This won't print"))  ; #f (doesn't evaluate second)
(or #t (display "This won't print"))   ; #t (doesn't evaluate second)</code></pre>
    </ul>
    <br/><br/>


    <li>Conditional Expressions</li>
    <br/>
    <ul>
        <li><b>if expression syntax:</b></li>
<pre><code class="language-scheme line-numbers">(if condition
    then-expression
    else-expression)</code></pre>
        <br/>
        <li><b>if examples:</b></li>
<pre><code class="language-scheme line-numbers">; Basic if
(if (> 5 3)
    "yes"
    "no")           ; Returns: "yes"

; If with computation
(if (= (* 2 3) 6)
    (+ 10 5)
    (- 10 5))       ; Returns: 15

; Nested if
(define (sign x)
  (if (< x 0)
      "negative"
      (if (= x 0)
          "zero"
          "positive")))

(sign -5)           ; Returns: "negative"
(sign 0)            ; Returns: "zero"
(sign 5)            ; Returns: "positive"</code></pre>
        <br/>
        <li><b>cond expression (multi-way conditional):</b></li>
<pre><code class="language-scheme line-numbers">(cond
  (condition1 result1)
  (condition2 result2)
  (condition3 result3)
  ...
  (else default-result))</code></pre>
        <br/>
        <li><b>cond examples:</b></li>
<pre><code class="language-scheme line-numbers">; Multiple conditions
(define (grade score)
  (cond
    ((>= score 90) "A")
    ((>= score 80) "B")
    ((>= score 70) "C")
    ((>= score 60) "D")
    (else "F")))

(grade 85)          ; Returns: "B"
(grade 55)          ; Returns: "F"

; Without else
(cond
  ((< 5 3) "impossible")
  ((> 5 3) "correct"))  ; Returns: "correct"</code></pre>
        <br/>
        <li><b>case expression (switch-like):</b></li>
<pre><code class="language-scheme line-numbers">(case key-expression
  ((value1 value2 ...) result1)
  ((value3 value4 ...) result2)
  ...
  (else default-result))</code></pre>
        <br/>
        <li><b>case examples:</b></li>
<pre><code class="language-scheme line-numbers">(define (day-name n)
  (case n
    ((1) "Monday")
    ((2) "Tuesday")
    ((3) "Wednesday")
    ((4) "Thursday")
    ((5) "Friday")
    ((6 7) "Weekend")
    (else "Invalid day")))

(day-name 1)        ; Returns: "Monday"
(day-name 6)        ; Returns: "Weekend"</code></pre>
    </ul>
    <br/><br/>


    <li>Lists and Pairs</li>
    <br/>
    <ul>
        <li>Lists are fundamental to Scheme.</li>
        <br/>
        <li><b>Creating lists:</b></li>
<pre><code class="language-scheme line-numbers">; Quoted list (doesn't evaluate)
'(1 2 3 4)

; Using list function
(list 1 2 3 4)

; Empty list
'()
(list)

; Mixed types
'(1 "hello" x #t)
(list 1 "hello" 'x #t)</code></pre>
        <br/>
        <li><b>Difference between quote and list:</b></li>
<pre><code class="language-scheme line-numbers">; With quote - literal
'(+ 1 2)            ; Returns: (+ 1 2) - just a list of symbols
'((+ 1 2) 3)        ; Returns: ((+ 1 2) 3)

; With list - evaluates arguments
(list + 1 2)        ; Returns: (#&lt;procedure:+&gt; 1 2)
(list (+ 1 2) 3)    ; Returns: (3 3)</code></pre>
        <br/>
        <li><b>Accessing list elements:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>car</code></td>
            <td>First element</td>
            <td><code>(car '(1 2 3))</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td><code>cdr</code></td>
            <td>Rest of list</td>
            <td><code>(cdr '(1 2 3))</code></td>
            <td>(2 3)</td>
        </tr>
        <tr>
            <td><code>cadr</code></td>
            <td>Second element</td>
            <td><code>(cadr '(1 2 3))</code></td>
            <td>2</td>
        </tr>
        <tr>
            <td><code>caddr</code></td>
            <td>Third element</td>
            <td><code>(caddr '(1 2 3))</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td><code>list-ref</code></td>
            <td>Element at index (0-based)</td>
            <td><code>(list-ref '(a b c) 1)</code></td>
            <td>b</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>List manipulation:</b></li>
<pre><code class="language-scheme line-numbers">; cons - add element to front
(cons 1 '(2 3))             ; Returns: (1 2 3)
(cons 'a '())               ; Returns: (a)

; append - combine lists
(append '(1 2) '(3 4))      ; Returns: (1 2 3 4)
(append '(a) '(b) '(c))     ; Returns: (a b c)

; length
(length '(1 2 3 4))         ; Returns: 4
(length '())                ; Returns: 0

; reverse
(reverse '(1 2 3))          ; Returns: (3 2 1)

; member - find element
(member 3 '(1 2 3 4))       ; Returns: (3 4)
(member 'x '(a b c))        ; Returns: #f</code></pre>
        <br/>
        <li><b>Pairs (dotted pairs):</b></li>
<pre><code class="language-scheme line-numbers">; Create pair with cons
(cons 1 2)              ; Returns: (1 . 2)

; Lists are chains of pairs ending in '()
(cons 1 (cons 2 (cons 3 '())))  ; Returns: (1 2 3)
; Same as '(1 2 3)

; Access pair elements
(car '(1 . 2))          ; Returns: 1
(cdr '(1 . 2))          ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Lambda Expressions</li>
    <br/>
    <ul>
        <li><b>lambda creates anonymous functions.</b></li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(lambda (parameter1 parameter2 ...)
  body-expression)</code></pre>
        <br/>
        <li><b>Basic examples:</b></li>
<pre><code class="language-scheme line-numbers">; Anonymous function
(lambda (x) (* x x))

; Call immediately
((lambda (x) (* x x)) 5)    ; Returns: 25

; Assign to variable
(define square (lambda (x) (* x x)))
(square 5)                  ; Returns: 25

; Multiple parameters
(define add (lambda (a b) (+ a b)))
(add 3 7)                   ; Returns: 10</code></pre>
        <br/>
        <li><b>Note: These are equivalent:</b></li>
<pre><code class="language-scheme line-numbers">; Using lambda explicitly
(define square (lambda (x) (* x x)))

; Shorthand (what we've been using)
(define (square x) (* x x))

; Both create the same function</code></pre>
        <br/>
        <li><b>Variable number of arguments:</b></li>
<pre><code class="language-scheme line-numbers">; Rest parameters
(define (sum . numbers)
  (if (null? numbers)
      0
      (+ (car numbers) (apply sum (cdr numbers)))))

(sum 1 2 3 4 5)     ; Returns: 15

; Mix fixed and rest parameters
(define (greet name . titles)
  (string-append name " " (apply string-append titles)))

(greet "John" "Dr. " "PhD")  ; Returns: "John Dr. PhD"</code></pre>
        <br/>
        <li><b>Higher-order functions:</b></li>
<pre><code class="language-scheme line-numbers">; Function that returns a function
(define (make-adder n)
  (lambda (x) (+ x n)))

(define add5 (make-adder 5))
(add5 10)           ; Returns: 15
(add5 3)            ; Returns: 8

; Function that takes a function
(define (apply-twice f x)
  (f (f x)))

(apply-twice (lambda (x) (* x 2)) 3)  ; Returns: 12
; First: (* 3 2) = 6
; Second: (* 6 2) = 12</code></pre>
    </ul>
    <br/><br/>


    <li>Local Bindings: let, let*, and letrec</li>
    <br/>
    <ul>
        <li><b>let:</b> Create local variables (parallel binding).</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(let ((var1 value1)
      (var2 value2)
      ...)
  body-expression)</code></pre>
        <br/>
        <li><b>let examples:</b></li>
<pre><code class="language-scheme line-numbers">; Simple let
(let ((x 5)
      (y 10))
  (+ x y))          ; Returns: 15

; Variables are parallel (can't reference each other)
(let ((x 5)
      (y x))        ; Error! x not yet defined
  (+ x y))

; Correct way
(let ((x 5))
  (let ((y x))
    (+ x y)))       ; Returns: 10</code></pre>
        <br/>
        <li><b>let*:</b> Create local variables (sequential binding).</li>
<pre><code class="language-scheme line-numbers">(let* ((var1 value1)
       (var2 value2)  ; Can use var1 here
       ...)
  body-expression)</code></pre>
        <br/>
        <li><b>let* examples:</b></li>
<pre><code class="language-scheme line-numbers">; Sequential binding
(let* ((x 5)
       (y (* x 2)))     ; Can use x
  (+ x y))              ; Returns: 15

; Each binding can use previous ones
(let* ((a 1)
       (b (+ a 1))      ; Uses a
       (c (+ a b)))     ; Uses a and b
  c)                    ; Returns: 3</code></pre>
        <br/>
        <li><b>letrec:</b> Create local recursive functions.</li>
<pre><code class="language-scheme line-numbers">(letrec ((var1 value1)
         (var2 value2)
         ...)
  body-expression)</code></pre>
        <br/>
        <li><b>letrec examples:</b></li>
<pre><code class="language-scheme line-numbers">; Recursive function
(letrec ((factorial
          (lambda (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))))
  (factorial 5))    ; Returns: 120

; Mutually recursive functions
(letrec ((even?
          (lambda (n)
            (if (= n 0)
                #t
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (= n 0)
                #f
                (even? (- n 1))))))
  (even? 10))       ; Returns: #t</code></pre>
    </ul>
    <br/><br/>


    <li>Recursion</li>
    <br/>
    <ul>
        <li>Recursion is the primary iteration mechanism in Scheme.</li>
        <br/>
        <li><b>Basic recursive pattern:</b></li>
<pre><code class="language-scheme line-numbers">(define (function-name param)
  (if base-case
      base-result
      (recursive-call)))</code></pre>
        <br/>
        <li><b>Factorial example:</b></li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (if (<= n 1)
      1                         ; Base case
      (* n (factorial (- n 1)))))  ; Recursive case

(factorial 5)       ; Returns: 120
; 5 * 4 * 3 * 2 * 1 = 120</code></pre>
        <br/>
        <li><b>List recursion:</b></li>
<pre><code class="language-scheme line-numbers">; Sum all numbers in list
(define (sum-list lst)
  (if (null? lst)
      0                         ; Base: empty list
      (+ (car lst)              ; Add first element
         (sum-list (cdr lst))))) ; Recursively sum rest

(sum-list '(1 2 3 4))   ; Returns: 10

; Length of list
(define (my-length lst)
  (if (null? lst)
      0
      (+ 1 (my-length (cdr lst)))))

(my-length '(a b c d))  ; Returns: 4</code></pre>
        <br/>
        <li><b>Tail recursion (more efficient):</b></li>
<pre><code class="language-scheme line-numbers">; Tail-recursive factorial
(define (factorial n)
  (define (fact-iter n acc)
    (if (<= n 1)
        acc
        (fact-iter (- n 1) (* n acc))))
  (fact-iter n 1))

; Tail-recursive sum
(define (sum-list lst)
  (define (sum-iter lst acc)
    (if (null? lst)
        acc
        (sum-iter (cdr lst) (+ acc (car lst)))))
  (sum-iter lst 0))

(sum-list '(1 2 3 4))   ; Returns: 10</code></pre>
    </ul>
    <br/><br/>


    <li>Common List Operations</li>
    <br/>
    <ul>
        <li><b>map:</b> Apply function to each element.</li>
<pre><code class="language-scheme line-numbers">; Syntax: (map function list)

(map (lambda (x) (* x 2)) '(1 2 3))
; Returns: (2 4 6)

(map car '((a b) (c d) (e f)))
; Returns: (a c e)

; Multiple lists
(map + '(1 2 3) '(10 20 30))
; Returns: (11 22 33)</code></pre>
        <br/>
        <li><b>filter:</b> Keep elements that satisfy predicate.</li>
<pre><code class="language-scheme line-numbers">; Keep only even numbers
(filter even? '(1 2 3 4 5 6))
; Returns: (2 4 6)

; Keep numbers > 5
(filter (lambda (x) (> x 5)) '(1 8 3 9 2 7))
; Returns: (8 9 7)</code></pre>
        <br/>
        <li><b>fold (reduce):</b> Combine elements.</li>
<pre><code class="language-scheme line-numbers">; foldl - fold from left
(foldl + 0 '(1 2 3 4))
; Returns: 10
; ((((0 + 1) + 2) + 3) + 4)

; foldr - fold from right
(foldr cons '() '(1 2 3))
; Returns: (1 2 3)

; foldl vs foldr
(foldl - 0 '(1 2 3))    ; (((0 - 1) - 2) - 3) = -6
(foldr - 0 '(1 2 3))    ; (1 - (2 - (3 - 0))) = 2</code></pre>
        <br/>
        <li><b>apply:</b> Apply function to list as arguments.</li>
<pre><code class="language-scheme line-numbers">(apply + '(1 2 3 4))
; Same as: (+ 1 2 3 4)
; Returns: 10

(apply max '(3 7 2 9 1))
; Same as: (max 3 7 2 9 1)
; Returns: 9</code></pre>
    </ul>
    <br/><br/>


    <li>String Operations</li>
    <br/>
    <ul>
        <li><b>Common string functions:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>string-length</code></td>
            <td>Get length</td>
            <td><code>(string-length "hello")</code></td>
            <td>5</td>
        </tr>
        <tr>
            <td><code>string-append</code></td>
            <td>Concatenate</td>
            <td><code>(string-append "hi" " " "there")</code></td>
            <td>"hi there"</td>
        </tr>
        <tr>
            <td><code>string-ref</code></td>
            <td>Get character</td>
            <td><code>(string-ref "hello" 1)</code></td>
            <td>#\e</td>
        </tr>
        <tr>
            <td><code>substring</code></td>
            <td>Extract portion</td>
            <td><code>(substring "hello" 1 4)</code></td>
            <td>"ell"</td>
        </tr>
        <tr>
            <td><code>string-upcase</code></td>
            <td>Uppercase</td>
            <td><code>(string-upcase "hello")</code></td>
            <td>"HELLO"</td>
        </tr>
        <tr>
            <td><code>string-downcase</code></td>
            <td>Lowercase</td>
            <td><code>(string-downcase "HELLO")</code></td>
            <td>"hello"</td>
        </tr>
        <tr>
            <td><code>string->list</code></td>
            <td>Convert to list</td>
            <td><code>(string->list "abc")</code></td>
            <td>(#\a #\b #\c)</td>
        </tr>
        <tr>
            <td><code>list->string</code></td>
            <td>Convert from list</td>
            <td><code>(list->string '(#\a #\b))</code></td>
            <td>"ab"</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Examples:</b></li>
<pre><code class="language-scheme line-numbers">; Concatenation
(string-append "Hello" ", " "World" "!")
; Returns: "Hello, World!"

; Substring
(substring "Hello, World!" 0 5)
; Returns: "Hello"

; Character access
(string-ref "Scheme" 0)     ; Returns: #\S

; String manipulation
(string-upcase "hello")     ; Returns: "HELLO"
(string-downcase "WORLD")   ; Returns: "world"</code></pre>
    </ul>
    <br/><br/>


    <li>Input and Output</li>
    <br/>
    <ul>
        <li><b>Display output:</b></li>
<pre><code class="language-scheme line-numbers">; display - print without quotes
(display "Hello, World!")   ; Prints: Hello, World!

; newline - print newline
(newline)

; write - print with quotes
(write "Hello")             ; Prints: "Hello"

; print multiple things
(display "x = ")
(display 42)
(newline)
; Prints: x = 42</code></pre>
        <br/>
        <li><b>Read input:</b></li>
<pre><code class="language-scheme line-numbers">; read - read S-expression
(define input (read))
; User types: (1 2 3)
; input is: '(1 2 3)

; read-line - read line as string
(define line (read-line))
; User types: Hello World
; line is: "Hello World"</code></pre>
        <br/>
        <li><b>File I/O:</b></li>
<pre><code class="language-scheme line-numbers">; Open file for reading
(define in (open-input-file "input.txt"))

; Read from file
(read in)
(read-line in)

; Close file
(close-input-port in)

; Open file for writing
(define out (open-output-file "output.txt"))

; Write to file
(write '(1 2 3) out)
(display "Hello" out)

; Close file
(close-output-port out)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Predicates</li>
    <br/>
    <ul>
        <li>Predicates are functions that return boolean values.</li>
<table>
    <thead>
        <tr>
            <th>Predicate</th>
            <th>Tests for</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>null?</code></td>
            <td>Empty list</td>
            <td><code>(null? '())</code> → #t</td>
        </tr>
        <tr>
            <td><code>pair?</code></td>
            <td>Pair/cons cell</td>
            <td><code>(pair? '(1 2))</code> → #t</td>
        </tr>
        <tr>
            <td><code>list?</code></td>
            <td>Proper list</td>
            <td><code>(list? '(1 2))</code> → #t</td>
        </tr>
        <tr>
            <td><code>number?</code></td>
            <td>Number</td>
            <td><code>(number? 42)</code> → #t</td>
        </tr>
        <tr>
            <td><code>integer?</code></td>
            <td>Integer</td>
            <td><code>(integer? 5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>real?</code></td>
            <td>Real number</td>
            <td><code>(real? 3.14)</code> → #t</td>
        </tr>
        <tr>
            <td><code>string?</code></td>
            <td>String</td>
            <td><code>(string? "hi")</code> → #t</td>
        </tr>
        <tr>
            <td><code>char?</code></td>
            <td>Character</td>
            <td><code>(char? #\a)</code> → #t</td>
        </tr>
        <tr>
            <td><code>symbol?</code></td>
            <td>Symbol</td>
            <td><code>(symbol? 'x)</code> → #t</td>
        </tr>
        <tr>
            <td><code>boolean?</code></td>
            <td>Boolean</td>
            <td><code>(boolean? #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>procedure?</code></td>
            <td>Function</td>
            <td><code>(procedure? +)</code> → #t</td>
        </tr>
        <tr>
            <td><code>zero?</code></td>
            <td>Zero</td>
            <td><code>(zero? 0)</code> → #t</td>
        </tr>
        <tr>
            <td><code>positive?</code></td>
            <td>Positive number</td>
            <td><code>(positive? 5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>negative?</code></td>
            <td>Negative number</td>
            <td><code>(negative? -5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>even?</code></td>
            <td>Even number</td>
            <td><code>(even? 4)</code> → #t</td>
        </tr>
        <tr>
            <td><code>odd?</code></td>
            <td>Odd number</td>
            <td><code>(odd? 3)</code> → #t</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Quick Reference Summary</li>
    <br/>
    <ul>
        <li><b>Basic syntax patterns:</b></li>
<pre><code class="language-scheme line-numbers">; Define variable
(define name value)

; Define function
(define (name params...) body)

; Lambda
(lambda (params...) body)

; Conditional
(if test then else)
(cond (test1 result1) (test2 result2) ... (else default))

; Local binding
(let ((var val) ...) body)
(let* ((var val) ...) body)
(letrec ((var val) ...) body)

; List operations
(car list)          ; First element
(cdr list)          ; Rest
(cons item list)    ; Add to front
(append list1 list2) ; Combine

; Higher-order
(map function list)
(filter predicate list)
(apply function list)</code></pre>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-multiple-expressions">Multiple Expressions in Conditionals</h3>
<ol>

    <li>The Problem with if</li>
    <br/>
    <ul>
        <li><b>if only accepts single expressions</b> for then and else branches.</li>
        <br/>
        <li><b>This doesn't work:</b></li>
<pre><code class="language-scheme line-numbers">; ✗ Error - trying multiple expressions
(if (> x 0)
    (display "Positive")
    (newline)           ; Error! if expects only one expression
    (display "Negative"))
</code></pre>
        <br/>
        <li>You need a way to <b>group multiple expressions into one</b>.</li>
    </ul>
    <br/><br/>


    <li>Solution: Using begin</li>
    <br/>
    <ul>
        <li><b>begin:</b> Groups multiple expressions into a single expression.</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(begin
  expression1
  expression2
  expression3
  ...
  final-expression)</code></pre>
        <br/>
        <li><b>What begin does:</b></li>
        <ul>
            <li>Evaluates all expressions in sequence (top to bottom)</li>
            <li>Returns the value of the <b>last expression only</b></li>
            <li>Side effects (like display, file I/O) from all expressions occur</li>
        </ul>
        <br/>
        <li><b>Basic begin example:</b></li>
<pre><code class="language-scheme line-numbers">(begin
  (display "First")
  (newline)
  (display "Second")
  (newline)
  42)               ; This value is returned

; Prints:
; First
; Second
; Returns: 42</code></pre>
    </ul>
    <br/><br/>


    <li>Using begin with if</li>
    <br/>
    <ul>
        <li><b>Pattern for multiple expressions in then branch:</b></li>
<pre><code class="language-scheme line-numbers">(if condition
    (begin
      expression1
      expression2
      ...)
    else-expression)</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-scheme line-numbers">(define x 10)

(if (&gt; x 0)
    (begin
      (display "x is positive")
      (newline)
      (display "x = ")
      (display x)
      #t)           ; Return value
    #f)

; Prints:
; x is positive
; x = 10
; Returns: #t</code></pre>
        <br/>
        <li><b>Multiple expressions in else branch:</b></li>
<pre><code class="language-scheme line-numbers">(if (> x 0)
    (display "Positive")
    (begin
      (display "Not positive")
      (newline)
      (display "Please enter a positive number")
      #f))</code></pre>
        <br/>
        <li><b>Multiple expressions in both branches:</b></li>
<pre><code class="language-scheme line-numbers">(if (> x 0)
    (begin
      (display "Positive: ")
      (display x)
      'positive)
    (begin
      (display "Not positive: ")
      (display x)
      'not-positive))</code></pre>
        <br/>
        <li><b>Real-world example - login check:</b></li>
<pre><code class="language-scheme line-numbers">(define (login username password)
  (if (and (string=? username "admin")
           (string=? password "secret"))
      (begin
        (display "Login successful!")
        (newline)
        (display "Welcome, ")
        (display username)
        (newline)
        #t)         ; Return success
      (begin
        (display "Login failed!")
        (newline)
        (display "Invalid credentials")
        (newline)
        #f)))       ; Return failure

(login "admin" "secret")
; Prints:
; Login successful!
; Welcome, admin
; Returns: #t
</code></pre>
    </ul>
    <br/><br/>


    <li>Alternative: when and unless</li>
    <br/>
    <ul>
        <li>Chez Scheme provides <code>when</code> and <code>unless</code> for common cases.</li>
        <br/>
        <li><b>when:</b> Execute multiple expressions if condition is true.</li>
<pre><code class="language-scheme line-numbers">; Syntax
(when condition
  expression1
  expression2
  ...)

; Equivalent to:
(if condition
    (begin expression1 expression2 ...)
    (void))     ; or returns unspecified value</code></pre>
        <br/>
        <li><b>when example:</b></li>
<pre><code class="language-scheme line-numbers">(define x 10)

(when (&gt; x 0)
  (display "x is positive")
  (newline)
  (display "x = ")
  (display x))

; No else branch needed
; If condition is false, does nothing</code></pre>
        <br/>
        <li><b>unless:</b> Execute multiple expressions if condition is false.</li>
<pre><code class="language-scheme line-numbers">; Syntax
(unless condition
  expression1
  expression2
  ...)

; Equivalent to:
(if (not condition)
    (begin expression1 expression2 ...)
    (void))</code></pre>
        <br/>
        <li><b>unless example:</b></li>
<pre><code class="language-scheme line-numbers">(define balance 50)

(unless (&gt;= balance 100)
  (display "Warning: Low balance")
  (newline)
  (display "Current balance: ")
  (display balance))

; Executes when balance < 100</code></pre>
        <br/>
        <li><b>Comparison:</b></li>
<table>
    <thead>
        <tr>
            <th>Form</th>
            <th>When to Use</th>
            <th>Has else?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>if</code> + <code>begin</code></td>
            <td>Need both then and else branches</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td><code>when</code></td>
            <td>Only execute if true, no else needed</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>unless</code></td>
            <td>Only execute if false, no else needed</td>
            <td>No</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Using cond for Multiple Expressions</li>
    <br/>
    <ul>
        <li><code>cond</code> clauses can have multiple expressions without <code>begin</code>.</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(cond
  (condition1
    expression1
    expression2
    ...)
  (condition2
    expression1
    expression2
    ...)
  (else
    expression1
    expression2
    ...))</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-scheme line-numbers">(define (grade-message score)
  (cond
    ((&gt;= score 90)
     (display "Excellent!")
     (newline)
     (display "Grade: A")
     'A)
    ((&gt;= score 80)
     (display "Good job!")
     (newline)
     (display "Grade: B")
     'B)
    ((&gt;= score 70)
     (display "Passing")
     (newline)
     (display "Grade: C")
     'C)
    (else
     (display "Failed")
     (newline)
     (display "Grade: F")
     'F)))

(grade-message 85)
; Prints:
; Good job!
; Grade: B
; Returns: B</code></pre>
        <br/>
        <li><b>Note:</b> Each clause can have multiple expressions, and the value of the last expression is returned if that clause matches.</li>
        <br/>
        <li><b>Comparison with if + begin:</b></li>
<pre><code class="language-scheme line-numbers">; Using if + begin (verbose)
(if (&gt;= score 90)
    (begin
      (display "Excellent!")
      'A)
    (if (&gt;= score 80)
        (begin
          (display "Good!")
          'B)
        ...))

; Using cond (cleaner)
(cond
  ((&gt;= score 90)
   (display "Excellent!")
   'A)
  ((&gt;= score 80)
   (display "Good!")
   'B)
  ...)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Patterns and Examples</li>
    <br/>
    <ul>
        <li><b>Pattern 1: Validation with multiple actions</b></li>
<pre><code class="language-scheme line-numbers">(define (validate-age age)
  (if (and (&gt;= age 0) (<= age 150))
      (begin
        (display "Age is valid")
        (newline)
        #t)
      (begin
        (display "Error: Invalid age")
        (newline)
        (display "Age must be between 0 and 150")
        (newline)
        #f)))
</code></pre>
        <br/>
        <li><b>Pattern 2: Side effects only when condition is true</b></li>
<pre><code class="language-scheme line-numbers">; Using when
(when (file-exists? "config.txt")
  (display "Loading config...")
  (newline)
  (load-config)
  (display "Config loaded"))

; Without when (more verbose)
(if (file-exists? "config.txt")
    (begin
      (display "Loading config...")
      (newline)
      (load-config)
      (display "Config loaded"))
    (void))</code></pre>
        <br/>
        <li><b>Pattern 3: Guard clauses</b></li>
<pre><code class="language-scheme line-numbers">(define (process-data data)
  ; Early return with multiple expressions
  (unless (valid-data? data)
    (display "Error: Invalid data")
    (newline)
    (return-error))

  ; Continue processing if valid
  (display "Processing...")
  (transform-data data))</code></pre>
        <br/>
        <li><b>Pattern 4: Logging with computation</b></li>
<pre><code class="language-scheme line-numbers">(define (calculate x y)
  (if (= y 0)
      (begin
        (display "Error: Division by zero")
        (newline)
        (display "Returning default value")
        (newline)
        0)
      (begin
        (display "Calculating: ")
        (display x)
        (display " / ")
        (display y)
        (newline)
        (/ x y))))</code></pre>
    </ul>
    <br/><br/>


    <li>When begin is NOT Needed</li>
    <br/>
    <ul>
        <li>Some forms already allow multiple expressions implicitly.</li>
        <br/>
        <li><b>Function bodies (define):</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in function body
(define (greet name)
  (display "Hello, ")
  (display name)
  (display "!")
  (newline)
  'done)            ; Returns 'done

; All expressions execute in sequence
; Last one is the return value</code></pre>
        <br/>
        <li><b>let, let*, letrec bodies:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in let body
(let ((x 10)
      (y 20))
  (display "Computing sum")
  (newline)
  (+ x y))          ; Returns 30</code></pre>
        <br/>
        <li><b>lambda bodies:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in lambda body
(lambda (x)
  (display "Processing: ")
  (display x)
  (newline)
  (* x x))          ; Returns x squared</code></pre>
        <br/>
        <li><b>cond clauses:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in cond clauses
(cond
  ((> x 0)
   (display "Positive")
   (newline)
   'pos)
  (else
   (display "Not positive")
   'not-pos))</code></pre>
        <br/>
        <li><b>case clauses:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in case clauses
(case n
  ((1)
   (display "One")
   1)
  ((2)
   (display "Two")
   2))</code></pre>
    </ul>
    <br/><br/>


    <li>Summary: When to Use What</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Situation</th>
            <th>Use</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Multiple expressions in if then/else</td>
            <td><code>begin</code></td>
            <td><code>(if test (begin e1 e2) e3)</code></td>
        </tr>
        <tr>
            <td>Only execute if true, no else</td>
            <td><code>when</code></td>
            <td><code>(when test e1 e2)</code></td>
        </tr>
        <tr>
            <td>Only execute if false, no else</td>
            <td><code>unless</code></td>
            <td><code>(unless test e1 e2)</code></td>
        </tr>
        <tr>
            <td>Multi-way with multiple expressions</td>
            <td><code>cond</code></td>
            <td><code>(cond (t1 e1 e2) (t2 e3 e4))</code></td>
        </tr>
        <tr>
            <td>In function/lambda/let body</td>
            <td>Nothing (implicit)</td>
            <td><code>(define (f) e1 e2)</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <ul>
        <li><b>Quick reference:</b></li>
    </ul>
<pre><code class="language-scheme line-numbers">; if with multiple expressions
(if test
    (begin e1 e2 e3)
    (begin e4 e5 e6))

; when (cleaner for one-sided if)
(when test
  e1
  e2
  e3)

; unless (cleaner for negative one-sided if)
(unless test
  e1
  e2
  e3)

; cond (no begin needed)
(cond
  (test1 e1 e2 e3)
  (test2 e4 e5 e6)
  (else e7 e8 e9))

; Function body (no begin needed)
(define (func)
  e1
  e2
  e3)</code></pre>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-naming-conventions">Chez Scheme Naming Conventions</h3>
<ol>

    <li>Understanding Scheme Identifiers</li>
    <br/>
    <ul>
        <li>Scheme has flexible rules for naming variables and functions.</li>
        <br/>
        <li><b>Core principle:</b> Names should be descriptive and follow consistent patterns.</li>
        <br/>
        <li><b>Valid characters in identifiers:</b></li>
        <ul>
            <li>Letters: <code>a-z</code>, <code>A-Z</code></li>
            <li>Digits: <code>0-9</code> (not at the start)</li>
            <li>Special characters: <code>!</code> <code>$</code> <code>%</code> <code>&</code> <code>*</code> <code>+</code> <code>-</code> <code>.</code> <code>/</code> <code>:</code> <code>&lt;</code> <code>=</code> <code>&gt;</code> <code>?</code> <code>@</code> <code>^</code> <code>_</code> <code>~</code></li>
        </ul>
        <br/>
        <li><b>Examples of valid identifiers:</b></li>
<pre><code class="language-scheme line-numbers">; All valid
x
my-variable
list->vector
string-ref
empty?
set!
<=
+
make-counter
file-exists?
*global-config*</code></pre>
        <br/>
        <li><b>Examples of invalid identifiers:</b></li>
<pre><code class="language-scheme line-numbers">; Invalid - starts with digit
123abc

; Invalid - contains space
my variable

; Invalid - contains special chars not allowed
my#var
item[0]
value{x}</code></pre>
    </ul>
    <br/><br/>


    <li>Predicate Naming Convention</li>
    <br/>
    <ul>
        <li>Functions that return boolean values end with <code>?</code></li>
        <br/>
        <li><b>Purpose:</b> Immediately identifies a function as a test or check.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Type predicates
(number? 42)        ; Returns: #t
(string? "hi")      ; Returns: #t
(list? '(1 2 3))    ; Returns: #t
(pair? '(a . b))    ; Returns: #t
(null? '())         ; Returns: #t

; Comparison predicates
(zero? 0)           ; Returns: #t
(positive? 5)       ; Returns: #t
(negative? -3)      ; Returns: #t
(even? 4)           ; Returns: #t
(odd? 7)            ; Returns: #t

; State predicates
(eof-object? x)     ; Checks for EOF
(file-exists? "test.txt")
(char-whitespace? #\space)</code></pre>
        <br/>
        <li><b>Creating your own predicates:</b></li>
<pre><code class="language-scheme line-numbers">(define (adult? age)
  (>= age 18))

(define (valid-email? email)
  (and (string? email)
       (string-contains? email "@")))

(define (empty-list? lst)
  (null? lst))

; Using predicates
(adult? 25)                    ; Returns: #t
(valid-email? "test@test.com") ; Returns: #t
(empty-list? '())              ; Returns: #t</code></pre>
    </ul>
    <br/><br/>


    <li>Mutating Function Convention</li>
    <br/>
    <ul>
        <li>Functions that modify (mutate) their arguments end with <code>!</code></li>
        <br/>
        <li><b>Warning:</b> The <code>!</code> signals side effects - use with caution.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Variable mutation
(define x 10)
(set! x 20)         ; Modifies x
x                   ; Returns: 20

; List mutation
(define lst '(1 2 3))
(set-car! lst 99)   ; Modifies first element
lst                 ; Returns: (99 2 3)

(set-cdr! lst '(8 9))
lst                 ; Returns: (99 8 9)

; Vector mutation
(define vec #(1 2 3))
(vector-set! vec 0 42)  ; Modifies element at index 0
vec                     ; Returns: #(42 2 3)</code></pre>
        <br/>
        <li><b>Creating your own mutators:</b></li>
<pre><code class="language-scheme line-numbers">(define (reset-counter! counter)
  (set-car! counter 0))

(define (increment! counter)
  (set-car! counter (+ (car counter) 1)))

(define (update-status! object new-status)
  (set-car! (cdr object) new-status))

; Usage
(define my-counter (list 0))
(increment! my-counter)
my-counter              ; Returns: (1)</code></pre>
        <br/>
        <li><b>Contrast with non-mutating functions:</b></li>
<pre><code class="language-scheme line-numbers">; Non-mutating - returns new value
(define (increment counter)
  (+ counter 1))

(define x 5)
(increment x)       ; Returns: 6
x                   ; Still: 5

; Mutating - modifies in place
(define (increment! counter-box)
  (set-car! counter-box
            (+ (car counter-box) 1)))

(define y (list 5))
(increment! y)      ; Modifies y
y                   ; Now: (6)</code></pre>
    </ul>
    <br/><br/>


    <li>Type Conversion Convention</li>
    <br/>
    <ul>
        <li>Conversion functions use <code>-&gt;</code> pattern: <code>source-&gt;target</code></li>
        <br/>
        <li><b>Pattern:</b> <code>(type-a-&gt;type-b value)</code> converts from type A to type B.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Number conversions
(string->number "42")       ; Returns: 42
(number->string 123)        ; Returns: "123"
(char->integer #\A)         ; Returns: 65
(integer->char 65)          ; Returns: #\A

; List/vector conversions
(list->vector '(1 2 3))     ; Returns: #(1 2 3)
(vector->list #(a b c))     ; Returns: (a b c)
(list->string '(#\h #\i))   ; Returns: "hi"
(string->list "abc")        ; Returns: (#\a #\b #\c)

; Symbol conversions
(symbol->string 'hello)     ; Returns: "hello"
(string->symbol "world")    ; Returns: world</code></pre>
        <br/>
        <li><b>Creating your own converters:</b></li>
<pre><code class="language-scheme line-numbers">(define (celsius->fahrenheit c)
  (+ (* c 9/5) 32))

(define (fahrenheit->celsius f)
  (* (- f 32) 5/9))

(define (list->set lst)
  ; Convert list to set (remove duplicates)
  (delete-duplicates lst))

(define (record->alist rec)
  ; Convert record to association list
  (map cons (record-field-names rec)
            (record-field-values rec)))

; Usage
(celsius->fahrenheit 100)   ; Returns: 212
(fahrenheit->celsius 32)    ; Returns: 0
(list->set '(1 2 2 3 3 3))  ; Returns: (1 2 3)</code></pre>
    </ul>
    <br/><br/>


    <li>Multi-word Identifier Convention</li>
    <br/>
    <ul>
        <li>Use <code>kebab-case</code> (words separated by hyphens) for multi-word names.</li>
        <br/>
        <li><b>Scheme style:</b> <code>kebab-case</code> is standard, NOT <code>camelCase</code> or <code>snake_case</code></li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Standard functions
string-length
string-append
list-ref
vector-set!
make-vector
call-with-current-continuation
call-with-input-file
read-char
write-char</code></pre>
        <br/>
        <li><b>Creating your own multi-word names:</b></li>
<pre><code class="language-scheme line-numbers">; Variables
(define max-retry-count 5)
(define database-connection-string "localhost:5432")
(define user-input-buffer '())

; Functions
(define (calculate-total-price items tax-rate)
  (* (apply + items) (+ 1 tax-rate)))

(define (validate-user-credentials username password)
  (and (valid-username? username)
       (valid-password? password)))

(define (send-email-notification recipient subject body)
  (email-send recipient subject body))

; Usage
(calculate-total-price '(10 20 30) 0.1)  ; Returns: 66.0</code></pre>
        <br/>
        <li><b>Bad examples (don't do this):</b></li>
<pre><code class="language-scheme line-numbers">; Wrong - camelCase (not Scheme style)
calculateTotalPrice
getUserInput
sendEmailNotification

; Wrong - snake_case (not Scheme style)
calculate_total_price
get_user_input
send_email_notification

; Right - kebab-case (Scheme style)
calculate-total-price
get-user-input
send-email-notification</code></pre>
    </ul>
    <br/><br/>


    <li>Global Variable Convention</li>
    <br/>
    <ul>
        <li>Global variables and parameters are sometimes surrounded by asterisks <code>*name*</code></li>
        <br/>
        <li><b>Note:</b> This convention is not universal in Scheme, but common in some codebases.</li>
        <br/>
        <li><b>Examples from libraries:</b></li>
<pre><code class="language-scheme line-numbers">; Common in some Scheme systems
*random-state*
*default-input-port*
*default-output-port*
*error-port*
*command-line-args*</code></pre>
        <br/>
        <li><b>Creating your own globals:</b></li>
<pre><code class="language-scheme line-numbers">(define *debug-mode* #f)
(define *max-connections* 100)
(define *database-url* "localhost:5432")
(define *application-version* "1.0.0")

; Usage
(when *debug-mode*
  (display "Debug: Processing request")
  (newline))

(if (< (connection-count) *max-connections*)
    (accept-connection)
    (reject-connection))</code></pre>
        <br/>
        <li><b>Alternative convention:</b> Some prefer <code>%name</code> for internal/private globals</li>
<pre><code class="language-scheme line-numbers">; Internal implementation details
(define %internal-cache (make-hash-table))
(define %debug-counter 0)
(define %temporary-buffer (make-vector 1024))</code></pre>
    </ul>
    <br/><br/>


    <li>Constructor and Maker Convention</li>
    <br/>
    <ul>
        <li>Constructor functions often use <code>make-</code> prefix.</li>
        <br/>
        <li><b>Pattern:</b> <code>(make-type args...)</code> creates a new instance of type.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Creating data structures
(make-vector 10)                  ; Creates vector of size 10
(make-vector 5 'x)                ; Creates #(x x x x x)
(make-string 3 #\a)               ; Creates "aaa"
(make-hash-table)                 ; Creates hash table
(make-list 4 0)                   ; Creates (0 0 0 0)</code></pre>
        <br/>
        <li><b>Creating your own constructors:</b></li>
<pre><code class="language-scheme line-numbers">(define (make-point x y)
  (cons x y))

(define (make-rectangle width height)
  (list 'rectangle width height))

(define (make-account name balance)
  (list name balance '()))  ; name, balance, transaction-history

(define (make-counter initial-value)
  (let ((count initial-value))
    (lambda ()
      (set! count (+ count 1))
      count)))

; Usage
(define p1 (make-point 10 20))
(define r1 (make-rectangle 100 50))
(define acc (make-account "John" 1000))
(define counter (make-counter 0))
(counter)  ; Returns: 1
(counter)  ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Private/Internal Naming</li>
    <br/>
    <ul>
        <li>Internal helper functions sometimes use <code>%</code> prefix or <code>-internal</code> suffix.</li>
        <br/>
        <li><b>Purpose:</b> Signals that a function is not part of the public API.</li>
        <br/>
        <li><b>Using % prefix:</b></li>
<pre><code class="language-scheme line-numbers">; Public API
(define (parse-expression expr)
  (%validate-syntax expr)
  (%transform-expr expr))

; Internal helpers (not for public use)
(define (%validate-syntax expr)
  ; Internal validation logic
  #t)

(define (%transform-expr expr)
  ; Internal transformation logic
  expr)</code></pre>
        <br/>
        <li><b>Using -internal suffix:</b></li>
<pre><code class="language-scheme line-numbers">; Public API
(define (calculate-total items)
  (apply + (map calculate-price-internal items)))

; Internal helper
(define (calculate-price-internal item)
  (* (item-quantity item)
     (item-unit-price item)
     (+ 1 (item-tax-rate item))))</code></pre>
        <br/>
        <li><b>Nested definitions (alternative):</b></li>
<pre><code class="language-scheme line-numbers">; Internal helpers defined inside public function
(define (process-data data)
  ; Helper only accessible within this function
  (define (validate item)
    (and (number? item) (positive? item)))

  (define (transform item)
    (* item 2))

  ; Use helpers
  (map transform (filter validate data)))

(process-data '(1 -2 3 4))  ; Returns: (2 6 8)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Naming Patterns Summary</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Convention</th>
            <th>Pattern</th>
            <th>Examples</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Predicates (boolean returns)</td>
            <td><code>name?</code></td>
            <td><code>empty?</code>, <code>valid?</code>, <code>member?</code></td>
        </tr>
        <tr>
            <td>Mutating functions</td>
            <td><code>name!</code></td>
            <td><code>set!</code>, <code>vector-set!</code>, <code>increment!</code></td>
        </tr>
        <tr>
            <td>Type conversions</td>
            <td><code>type-a-&gt;type-b</code></td>
            <td><code>list-&gt;vector</code>, <code>string-&gt;number</code></td>
        </tr>
        <tr>
            <td>Multi-word names</td>
            <td><code>kebab-case</code></td>
            <td><code>string-length</code>, <code>file-exists?</code></td>
        </tr>
        <tr>
            <td>Global variables</td>
            <td><code>*name*</code></td>
            <td><code>*debug-mode*</code>, <code>*max-size*</code></td>
        </tr>
        <tr>
            <td>Constructors</td>
            <td><code>make-name</code></td>
            <td><code>make-vector</code>, <code>make-point</code></td>
        </tr>
        <tr>
            <td>Internal/private</td>
            <td><code>%name</code> or <code>name-internal</code></td>
            <td><code>%helper</code>, <code>parse-internal</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <ul>
        <li><b>Complete example using multiple conventions:</b></li>
<pre><code class="language-scheme line-numbers">; Global configuration
(define *max-retries* 3)

; Constructor
(define (make-connection host port)
  (list host port 'disconnected))

; Predicate
(define (connected? conn)
  (eq? (caddr conn) 'connected))

; Type conversion
(define (connection-&gt;string conn)
  (string-append (car conn) ":" (number-&gt;string (cadr conn))))

; Mutator
(define (connect! conn)
  (set-car! (cddr conn) 'connected))

; Multi-word function
(define (establish-secure-connection host port)
  (let ((conn (make-connection host port)))
    (when (%validate-host host)
      (connect! conn))
    conn))

; Internal helper
(define (%validate-host host)
  (and (string? host)
       (> (string-length host) 0)))

; Usage
(define my-conn (make-connection "localhost" 8080))
(connected? my-conn)                    ; Returns: #f
(connect! my-conn)
(connected? my-conn)                    ; Returns: #t
(connection-&gt;string my-conn)             ; Returns: "localhost:8080"</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-compiler-interpreter">Interacting with Chez Scheme</h3>
<ol>

    <li>Starting Chez Scheme</li>
    <br/>
    <ul>
        <li>Chez Scheme provides both an interactive REPL and a compiler.</li>
        <br/>
        <li><b>Starting the REPL:</b></li>
<pre><code class="language-bash line-numbers"># Start interactive session
$ scheme

# Start with specific options
$ scheme --script myscript.scm
$ scheme --program myprogram.ss</code></pre>
        <br/>
        <li><b>Basic interaction:</b></li>
<pre><code class="language-scheme line-numbers">> (+ 2 3)
5

> (define x 10)

> x
10

> (string-append "Hello, " "World!")
"Hello, World!"</code></pre>
        <br/>
        <li><b>Exiting the REPL:</b></li>
<pre><code class="language-scheme line-numbers">; Method 1: Use exit procedure
> (exit)

; Method 2: Ctrl+D (Unix/Linux/Mac)
> ^D

; Method 3: Ctrl+Z then Enter (Windows)
> ^Z</code></pre>
    </ul>
    <br/><br/>


    <li>Loading and Compiling Files</li>
    <br/>
    <ul>
        <li>Chez Scheme can load source files or compiled object files.</li>
        <br/>
        <li><b>Loading source files with load:</b></li>
<pre><code class="language-scheme line-numbers">; Load a Scheme source file
> (load "myfile.ss")

; Load with .scm extension
> (load "library.scm")

; Load from specific path
> (load "/home/user/code/utils.ss")

; Load relative to current directory
> (load "./helpers/math.ss")</code></pre>
        <br/>
        <li><b>What load does:</b></li>
        <ul>
            <li>Reads and evaluates all expressions in the file</li>
            <li>Definitions become available immediately</li>
            <li>Side effects (like <code>display</code>) happen during load</li>
        </ul>
        <br/>
        <li><b>Example file to load:</b></li>
<pre><code class="language-scheme line-numbers">; File: math-utils.ss
(define (square x)
  (* x x))

(define (cube x)
  (* x x x))

(display "Math utilities loaded")
(newline)</code></pre>
<pre><code class="language-scheme line-numbers">; In REPL
> (load "math-utils.ss")
Math utilities loaded

> (square 5)
25

> (cube 3)
27</code></pre>
        <br/>
        <li><b>Compiling files:</b></li>
<pre><code class="language-scheme line-numbers">; Compile a source file to object file
> (compile-file "myfile.ss")

; This creates myfile.so (compiled object)</code></pre>
        <br/>
        <li><b>Loading compiled files:</b></li>
<pre><code class="language-scheme line-numbers">; Load compiled object (faster)
> (load "myfile.so")

; Chez automatically uses .so if available
> (load "myfile")  ; Loads myfile.so if it exists and is newer</code></pre>
        <br/>
        <li><b>Compilation workflow:</b></li>
<pre><code class="language-bash line-numbers"># From command line
$ echo '(compile-file "myfile.ss")' | scheme

# Or in REPL
> (compile-file "myfile.ss")
> (exit)

# Then load the compiled version
$ scheme
> (load "myfile.so")</code></pre>
    </ul>
    <br/><br/>


    <li>Command-Line Usage</li>
    <br/>
    <ul>
        <li>Chez Scheme supports various command-line options for different use cases.</li>
        <br/>
        <li><b>Running a script:</b></li>
<pre><code class="language-bash line-numbers"># Execute script and exit
$ scheme --script myscript.ss

# With arguments
$ scheme --script myscript.ss arg1 arg2 arg3</code></pre>
        <br/>
        <li><b>Running a program:</b></li>
<pre><code class="language-bash line-numbers"># Run as R6RS program
$ scheme --program myprogram.ss

# Programs must start with library/import declarations
$ scheme --program myprogram.ss arg1 arg2</code></pre>
        <br/>
        <li><b>Evaluating expressions:</b></li>
<pre><code class="language-bash line-numbers"># Evaluate expression and exit
$ scheme --eval '(display "Hello")' --eval '(newline)'

# Combine multiple expressions
$ scheme --eval '(+ 2 3)' --eval '(* 4 5)'</code></pre>
        <br/>
        <li><b>Loading files on startup:</b></li>
<pre><code class="language-bash line-numbers"># Load file then start REPL
$ scheme myfile.ss

# Load multiple files
$ scheme file1.ss file2.ss file3.ss

# Load and run expression
$ scheme myfile.ss --eval '(main)'</code></pre>
        <br/>
        <li><b>Common command-line options:</b></li>
<table>
    <thead>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>--script file</code></td>
            <td>Run script and exit</td>
            <td><code>scheme --script test.ss</code></td>
        </tr>
        <tr>
            <td><code>--program file</code></td>
            <td>Run R6RS program and exit</td>
            <td><code>scheme --program app.ss</code></td>
        </tr>
        <tr>
            <td><code>--eval expr</code></td>
            <td>Evaluate expression</td>
            <td><code>scheme --eval '(+ 1 2)'</code></td>
        </tr>
        <tr>
            <td><code>-q</code></td>
            <td>Quiet mode (no banner)</td>
            <td><code>scheme -q</code></td>
        </tr>
        <tr>
            <td><code>--version</code></td>
            <td>Display version and exit</td>
            <td><code>scheme --version</code></td>
        </tr>
        <tr>
            <td><code>--help</code></td>
            <td>Display help message</td>
            <td><code>scheme --help</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Example script file:</b></li>
<pre><code class="language-scheme line-numbers">#!/usr/bin/env scheme --script
; File: hello.ss

(display "Hello from Chez Scheme!")
(newline)

; Access command-line arguments
(display "Arguments: ")
(display (command-line))
(newline)</code></pre>
<pre><code class="language-bash line-numbers"># Make executable
$ chmod +x hello.ss

# Run directly
$ ./hello.ss arg1 arg2
Hello from Chez Scheme!
Arguments: ("./hello.ss" "arg1" "arg2")</code></pre>
    </ul>
    <br/><br/>


    <li>REPL Special Commands and Features</li>
    <br/>
    <ul>
        <li>The REPL provides special commands for development and debugging.</li>
        <br/>
        <li><b>Inspecting values:</b></li>
<pre><code class="language-scheme line-numbers">; Display value with details
> (define lst '(1 2 3))
> lst
(1 2 3)

; Inspect procedure
> car
#&lt;procedure car&gt;

; Get procedure information
> (procedure-arity car)
#&lt;arity (1)&gt;</code></pre>
        <br/>
        <li><b>Getting help and documentation:</b></li>
<pre><code class="language-scheme line-numbers">; Load help system (if available)
> (load "help.ss")

; Describe a procedure
> (describe '+)
; Shows documentation for +

; Apropos - search for procedures
> (apropos "list")
; Shows all procedures with "list" in name</code></pre>
        <br/>
        <li><b>Compiler and runtime information:</b></li>
<pre><code class="language-scheme line-numbers">; Check Scheme version
> (scheme-version)
"10.0.0"

; Machine type
> (machine-type)
'ta6le  ; or 'a6le, etc.

; Optimize level
> (optimize-level)
2

; Set optimize level (0-3)
> (optimize-level 3)</code></pre>
        <br/>
        <li><b>Timing expressions:</b></li>
<pre><code class="language-scheme line-numbers">; Time an expression
> (time (+ 2 3))
(time (+ 2 3))
    no collections
    0.000000s elapsed cpu time
    0.000001s elapsed real time
    0 bytes allocated
5

; Time a longer computation
> (time (apply + (iota 1000000)))
(time (apply + (iota 1000000)))
    5 collections
    0.021000s elapsed cpu time
    0.021234s elapsed real time
    24000016 bytes allocated
499999500000</code></pre>
        <br/>
        <li><b>Viewing compiler output:</b></li>
<pre><code class="language-scheme line-numbers">; Generate and view assembly
> (expand '(lambda (x) (* x x)))
; Shows expanded form

; Compile and inspect
> (compile '(lambda (x) (* x x)))
#&lt;procedure&gt;</code></pre>
        <br/>
        <li><b>Multi-line input in REPL:</b></li>
<pre><code class="language-scheme line-numbers">; REPL waits for complete expression
> (define (factorial n)
    (if (= n 0)
        1
        (* n (factorial (- n 1)))))

> (factorial 5)
120</code></pre>
        <br/>
        <li><b>Recovering from errors:</b></li>
<pre><code class="language-scheme line-numbers">; Error example
> (/ 1 0)
Exception: attempt to divide by zero

; REPL continues
> (+ 2 3)
5

; Reset environment if needed
> (reset)
; Or restart REPL</code></pre>
    </ul>
    <br/><br/>


    <li>Working with Libraries and Imports</li>
    <br/>
    <ul>
        <li>Chez Scheme supports R6RS libraries and import system.</li>
        <br/>
        <li><b>Defining a library file:</b></li>
<pre><code class="language-scheme line-numbers">; File: mylib.sls (Scheme Library Source)
(library (mylib)
  (export square cube double)
  (import (chezscheme))

  (define (square x)
    (* x x))

  (define (cube x)
    (* x x x))

  (define (double x)
    (* 2 x)))</code></pre>
        <br/>
        <li><b>Importing a library in REPL:</b></li>
<pre><code class="language-scheme line-numbers">; Import library
> (import (mylib))

; Use exported functions
> (square 5)
25

> (cube 3)
27

> (double 10)
20</code></pre>
        <br/>
        <li><b>Importing specific bindings:</b></li>
<pre><code class="language-scheme line-numbers">; Import only specific functions
> (import (only (mylib) square cube))

; Import all except specific
> (import (except (mylib) double))

; Import with rename
> (import (rename (mylib) (square sq)))
> (sq 4)
16

; Import with prefix
> (import (prefix (mylib) math:))
> (math:square 5)
25</code></pre>
        <br/>
        <li><b>Standard library imports:</b></li>
<pre><code class="language-scheme line-numbers">; Import R6RS base library
> (import (rnrs base))

; Import specific R6RS libraries
> (import (rnrs io simple))
> (import (rnrs lists))
> (import (rnrs sorting))

; Import Chez-specific features
> (import (chezscheme))

; Multiple imports at once
> (import (rnrs base)
          (rnrs io simple)
          (mylib))</code></pre>
        <br/>
        <li><b>Library search paths:</b></li>
<pre><code class="language-scheme line-numbers">; Check current library paths
> (library-directories)
(("." . "."))

; Add library path
> (library-directories
    '(("." . ".")
      ("/usr/local/lib/scheme" . "/usr/local/lib/scheme/compiled")))

; Now libraries in /usr/local/lib/scheme are searchable</code></pre>
        <br/>
        <li><b>Creating a program with imports:</b></li>
<pre><code class="language-scheme line-numbers">; File: myprogram.ss
#!chezscheme
(import (chezscheme)
        (mylib))

(define (main)
  (display "Square of 10: ")
  (display (square 10))
  (newline)

  (display "Cube of 5: ")
  (display (cube 5))
  (newline))

(main)</code></pre>
<pre><code class="language-bash line-numbers"># Run the program
$ scheme --program myprogram.ss
Square of 10: 100
Cube of 5: 125</code></pre>
    </ul>
    <br/><br/>


    <li>Compilation Options and Optimization</li>
    <br/>
    <ul>
        <li>Chez Scheme provides optimization levels and compilation controls.</li>
        <br/>
        <li><b>Optimization levels:</b></li>
<table>
    <thead>
        <tr>
            <th>Level</th>
            <th>Description</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>0</code></td>
            <td>No optimization, fastest compile</td>
            <td>Development, debugging</td>
        </tr>
        <tr>
            <td><code>1</code></td>
            <td>Basic optimization</td>
            <td>Default development</td>
        </tr>
        <tr>
            <td><code>2</code></td>
            <td>Standard optimization</td>
            <td>Default (balanced)</td>
        </tr>
        <tr>
            <td><code>3</code></td>
            <td>Aggressive optimization</td>
            <td>Production, performance</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Setting optimization level:</b></li>
<pre><code class="language-scheme line-numbers">; In REPL
> (optimize-level 3)

; Now compilations use level 3
> (compile-file "myfile.ss")

; Check current level
> (optimize-level)
3</code></pre>
        <br/>
        <li><b>Safety vs speed trade-offs:</b></li>
<pre><code class="language-scheme line-numbers">; Debug mode (more checks)
> (debug-level 3)
> (optimize-level 0)

; Production mode (maximum speed)
> (debug-level 0)
> (optimize-level 3)

; Balanced (default)
> (debug-level 2)
> (optimize-level 2)</code></pre>
        <br/>
        <li><b>Compiling with specific options:</b></li>
<pre><code class="language-scheme line-numbers">; Set options before compiling
(parameterize ([optimize-level 3]
               [debug-level 0])
  (compile-file "myfile.ss"))

; Compile multiple files with settings
(for-each
  (lambda (file)
    (parameterize ([optimize-level 3])
      (compile-file file)))
  '("file1.ss" "file2.ss" "file3.ss"))</code></pre>
        <br/>
        <li><b>Whole-program optimization:</b></li>
<pre><code class="language-scheme line-numbers">; Compile library for whole-program optimization
> (compile-library "mylib.sls")

; Or with options
> (parameterize ([optimize-level 3]
                 [generate-wpo-files #t])
    (compile-library "mylib.sls"))</code></pre>
        <br/>
        <li><b>Performance tips:</b></li>
        <ul>
            <li>Use <code>(optimize-level 3)</code> for production code</li>
            <li>Compile files to <code>.so</code> for faster loading</li>
            <li>Use type declarations when possible</li>
            <li>Profile with <code>time</code> to find bottlenecks</li>
            <li>Avoid <code>eval</code> and <code>load</code> in performance-critical code</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Debugging and Error Handling</li>
    <br/>
    <ul>
        <li>Chez Scheme provides tools for debugging and error inspection.</li>
        <br/>
        <li><b>Reading error messages:</b></li>
<pre><code class="language-scheme line-numbers">; Error example
> (car 42)
Exception in car: 42 is not a pair

; Error with context
> (define (process x)
    (car x))
> (process 42)
Exception in car: 42 is not a pair
Exception occurred in process</code></pre>
        <br/>
        <li><b>Stack traces:</b></li>
<pre><code class="language-scheme line-numbers">; Enable debug mode for better traces
> (debug-level 3)

; Now errors show more context
> (define (a) (b))
> (define (b) (c))
> (define (c) (car 42))
> (a)
Exception in car: 42 is not a pair
  in c
  in b
  in a</code></pre>
        <br/>
        <li><b>Exception handling:</b></li>
<pre><code class="language-scheme line-numbers">; Try-catch style with guard
(guard (ex
        [(error? ex)
         (display "Error caught: ")
         (display (error-object-message ex))
         (newline)
         #f])
  (car 42))
; Prints: Error caught: car: 42 is not a pair
; Returns: #f

; With-exception-handler
(with-exception-handler
  (lambda (ex)
    (display "Exception occurred")
    (newline)
    'error)
  (lambda ()
    (/ 1 0)))
; Prints: Exception occurred
; Returns: error</code></pre>
        <br/>
        <li><b>Tracing procedures:</b></li>
<pre><code class="language-scheme line-numbers">; Define a function
> (define (factorial n)
    (if (= n 0)
        1
        (* n (factorial (- n 1)))))

; Trace it
> (trace factorial)

; Now calls are traced
> (factorial 5)
|(factorial 5)
| (factorial 4)
| |(factorial 3)
| | (factorial 2)
| | |(factorial 1)
| | | (factorial 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120

; Untrace
> (untrace factorial)</code></pre>
        <br/>
        <li><b>Break and inspect:</b></li>
<pre><code class="language-scheme line-numbers">; Insert breakpoint
(define (compute x y)
  (let ((a (* x 2))
        (b (+ y 3)))
    (break)  ; Stop here
    (+ a b)))

; When break is hit, can inspect variables
> (compute 5 10)
Break in compute
debug> a
10
debug> b
13
debug> (continue)</code></pre>
        <br/>
        <li><b>Pretty-printing for debugging:</b></li>
<pre><code class="language-scheme line-numbers">; Pretty-print complex structures
> (pretty-print '((a b c) (d (e f) g) (h i)))
((a b c)
 (d (e f) g)
 (h i))

; Print with line numbers
> (pretty-print
    '(define (long-function x y z)
       (let ((a (+ x y))
             (b (* y z)))
         (+ a b))))
(define (long-function x y z)
  (let ((a (+ x y))
        (b (* y z)))
    (+ a b)))</code></pre>
    </ul>
    <br/><br/>


    <li>Creating Standalone Executables</li>
    <br/>
    <ul>
        <li>Chez Scheme can create standalone executable programs.</li>
        <br/>
        <li><b>Creating a boot file:</b></li>
<pre><code class="language-scheme line-numbers">; Compile program to boot file
$ echo '(make-boot-file "myapp.boot" '() "myprogram.ss")' | scheme

; This creates a boot file containing your program</code></pre>
        <br/>
        <li><b>Running a boot file:</b></li>
<pre><code class="language-bash line-numbers"># Run boot file with Scheme
$ scheme -b myapp.boot

# Or specify boot file and entry point
$ scheme -b myapp.boot --eval '(main)'</code></pre>
        <br/>
        <li><b>Creating shell script wrapper:</b></li>
<pre><code class="language-bash line-numbers">#!/bin/sh
# File: myapp
exec scheme -b myapp.boot "$@"</code></pre>
<pre><code class="language-bash line-numbers"># Make executable
$ chmod +x myapp

# Run like a normal program
$ ./myapp
$ ./myapp arg1 arg2</code></pre>
        <br/>
        <li><b>Example: complete program structure</b></li>
<pre><code class="language-scheme line-numbers">; File: myapp.ss
#!chezscheme

(import (chezscheme))

(define (main args)
  (display "MyApp v1.0")
  (newline)
  (when (> (length args) 1)
    (display "Arguments: ")
    (display (cdr args))
    (newline))
  (display "Hello from standalone app!")
  (newline))

; Auto-run main when loaded
(main (command-line))</code></pre>
<pre><code class="language-bash line-numbers"># Build steps
$ scheme --compile-imported-libraries --program myapp.ss
$ echo '(make-boot-file "myapp.boot" '() "myapp.ss")' | scheme

# Create wrapper script
$ cat > myapp << 'EOF'
#!/bin/sh
exec scheme -b myapp.boot "$@"
EOF
$ chmod +x myapp

# Run
$ ./myapp hello world
MyApp v1.0
Arguments: (hello world)
Hello from standalone app!</code></pre>
    </ul>
    <br/><br/>


    <li>Common Workflow Examples</li>
    <br/>
    <ul>
        <li><b>Interactive development workflow:</b></li>
<pre><code class="language-scheme line-numbers">; 1. Start REPL
$ scheme

; 2. Load your code
> (load "mycode.ss")

; 3. Test functions interactively
> (my-function test-data)

; 4. Modify code in editor

; 5. Reload
> (load "mycode.ss")

; 6. Test again
> (my-function test-data)

; Repeat 4-6 until satisfied</code></pre>
        <br/>
        <li><b>Library development workflow:</b></li>
<pre><code class="language-bash line-numbers"># 1. Create library file
$ cat > mylib.sls << 'EOF'
(library (mylib)
  (export func1 func2)
  (import (chezscheme))
  (define (func1 x) ...)
  (define (func2 y) ...))
EOF

# 2. Compile library
$ echo '(compile-library "mylib.sls")' | scheme

# 3. Test in REPL
$ scheme
> (import (mylib))
> (func1 test-input)

# 4. Modify and recompile as needed</code></pre>
        <br/>
        <li><b>Script development workflow:</b></li>
<pre><code class="language-bash line-numbers"># 1. Create script
$ cat > myscript.ss << 'EOF'
#!/usr/bin/env scheme --script
(display "Running script")
(newline)
EOF

# 2. Make executable
$ chmod +x myscript.ss

# 3. Test
$ ./myscript.ss

# 4. Debug if needed
$ scheme
> (load "myscript.ss")</code></pre>
        <br/>
        <li><b>Production deployment workflow:</b></li>
<pre><code class="language-bash line-numbers"># 1. Set optimization and compile all files
$ scheme &lt;&lt; 'EOF'
(optimize-level 3)
(debug-level 0)
(compile-file "module1.ss")
(compile-file "module2.ss")
(compile-library "mylib.sls")
(compile-program "main.ss")
EOF

# 2. Create boot file
$ echo '(make-boot-file "app.boot" '() "main.ss")' | scheme

# 3. Create launcher script
$ cat > app << 'EOF'
#!/bin/sh
exec scheme -b app.boot "$@"
EOF
$ chmod +x app

# 4. Deploy: copy app, app.boot, and .so files to target</code></pre>
    </ul>
    <br/><br/>


    <li>Tips and Best Practices</li>
    <br/>
    <ul>
        <li><b>Development mode setup:</b></li>
<pre><code class="language-scheme line-numbers">; In your .chezscheme.rc or startup file
(optimize-level 1)
(debug-level 3)
(case-sensitive #t)
(print-gensym #t)

; Load commonly used utilities
(load "~/scheme/utils.ss")</code></pre>
        <br/>
        <li><b>REPL productivity tips:</b></li>
        <ul>
            <li>Use arrow keys for command history</li>
            <li>Use Tab for completion (if enabled)</li>
            <li>Define helper functions in a utils file</li>
            <li>Keep a scratch file for experiments</li>
            <li>Use <code>(trace ...)</code> liberally during debugging</li>
        </ul>
        <br/>
        <li><b>File organization:</b></li>
<pre><code class="language-plaintext line-numbers">project/
  src/
    mylib.sls          ; Library definitions
    module1.ss         ; Module source
    module2.ss         ; Module source
  compiled/
    mylib.so           ; Compiled library
    module1.so         ; Compiled module
    module2.so         ; Compiled module
  tests/
    test-mylib.ss      ; Tests
  scripts/
    build.ss           ; Build script
  main.ss              ; Entry point</code></pre>
        <br/>
        <li><b>Avoid common pitfalls:</b></li>
<pre><code class="language-scheme line-numbers">; Don't redefine in REPL without restarting
; if you change function signatures

; Don't:
> (define (func x) ...)      ; Define with 1 arg
> (define (func x y) ...)    ; Redefine with 2 args
; Old callers may still use 1-arg version!

; Do: Restart REPL after signature changes
; Or use parameterize for temporary changes

; Don't load same file multiple times
; without understanding effects

; Don't rely on load order side effects

; Do use libraries for clean interfaces</code></pre>
        <br/>
        <li><b>Performance considerations:</b></li>
        <ul>
            <li>Compile files for production use</li>
            <li>Use <code>(optimize-level 3)</code> for hot paths</li>
            <li>Profile before optimizing</li>
            <li>Consider whole-program compilation for maximum performance</li>
            <li>Avoid unnecessary <code>eval</code> calls</li>
        </ul>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-command-line-options">Chez Scheme Command Line Options</h3>
<ol>

    <li>Basic Invocation</li>
    <br/>
    <ul>
        <li>Chez Scheme is invoked from the command line using <code>scheme</code> (full version) or <code>petite</code> (interpreter-only version).</li>
        <br/>
        <li>General syntax:</li>
<pre><code class="language-bash line-numbers"># Start interactive REPL
$ scheme

# Start Petite Chez Scheme (no compiler)
$ petite

# Load files before entering REPL
$ scheme file1.scm file2.scm

# Run a script
$ scheme --script myscript.scm

# Run an R6RS program
$ scheme --program myprogram.scm
</code></pre>
    </ul>
    <br/><br/>


    <li>Execution Mode Options</li>
    <br/>
    <ul>
        <li><code>--script file</code> runs file as a Scheme shell script.</li>
        <br/>
        <li><code>--program file</code> runs file as an R6RS top-level program.</li>
        <br/>
        <li><code>-q</code> or <code>--quiet</code> suppresses greeting banner and prompts.</li>
        <br/>
        <li>Script example:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --script
(display "Hello from script!")
(newline)
(display "Arguments: ")
(display (cdr (command-line)))
(newline)</code></pre>
        <br/>
        <li>R6RS program example:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --program
(import (rnrs))

(define (main args)
  (for-each
    (lambda (arg)
      (display arg)
      (newline))
    args))

(main (cdr (command-line)))</code></pre>
        <br/>
        <li>You can also use <code>scheme-script</code> as an alias for <code>scheme --program</code>:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/env scheme-script
(import (rnrs))
(display "Running as R6RS program")
(newline)</code></pre>
    </ul>
    <br/><br/>


    <li>Library Options</li>
    <br/>
    <ul>
        <li><code>--libdirs dir:...</code> — Set library source/object directories.</li>
        <br/>
        <li><code>--libexts ext:...</code> — Set library file extensions.</li>
        <br/>
        <li><code>--compile-imported-libraries</code> — Compile libraries before loading them.</li>
        <br/>
        <li><code>--import-notify</code> — Print messages when searching for libraries.</li>
        <br/>
        <li>Directory format uses colons (or semicolons on Windows) as separators:</li>
<pre><code class="language-bash line-numbers"># Set library directories
$ scheme --libdirs /path/to/libs:/another/path

# Set library extensions
$ scheme --libexts .sls:.scm

# Compile libraries automatically
$ scheme --compile-imported-libraries --program myapp.ss

# Debug library loading
$ scheme --import-notify --program myapp.ss</code></pre>
        <br/>
        <li>The source and object directories can be specified separately using double colons:</li>
<pre><code class="language-bash line-numbers"># source-dir::object-dir format
$ scheme --libdirs ./src::./obj:/usr/lib/scheme</code></pre>
        <br/>
        <li>Append to default directories by ending with a colon:</li>
<pre><code class="language-bash line-numbers"># Add to existing directories (note trailing colon)
$ scheme --libdirs /my/libs:</code></pre>
    </ul>
    <br/><br/>


    <li>Optimization and Debugging Options</li>
    <br/>
    <ul>
        <li><code>--optimize-level 0|1|2|3</code> — Set the optimization level (default: 0).</li>
        <ul>
            <li>Levels 0, 1, 2: Safe code with full type and bounds checking</li>
            <li>Level 3: Unsafe code, may omit checks for better performance</li>
        </ul>
        <br/>
        <li><code>--debug-on-exception</code> — Enter debugger on uncaught exceptions.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Maximum optimization (unsafe, for production)
$ scheme --optimize-level 3 --program myapp.ss

# Debug a script that's crashing
$ scheme --debug-on-exception --script buggy.ss

# Safe optimization for development
$ scheme --optimize-level 2 --program myapp.ss</code></pre>
        <br/>
        <li>When <code>--debug-on-exception</code> is active, exceptions enter the inspector:</li>
<pre><code class="language-scheme line-numbers">$ scheme --debug-on-exception
> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.
debug> i     ; inspect continuation
debug> ?     ; show help
debug> q     ; quit debugger</code></pre>
    </ul>
    <br/><br/>


    <li>Expression Editor Options</li>
    <br/>
    <ul>
        <li><code>--eedisable</code> — Disable the expression editor (use plain input).</li>
        <br/>
        <li><code>--eehistory off|file</code> — Set history file location or disable history.</li>
        <br/>
        <li>The expression editor provides:</li>
        <ul>
            <li>Multi-line expression editing with auto-indentation</li>
            <li>Emacs-style key bindings</li>
            <li>History across sessions (stored in <code>~/.chezscheme_history</code>)</li>
            <li>Tab completion for identifiers</li>
            <li>Parenthesis matching and auto-correction</li>
        </ul>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Disable expression editor (useful for piped input)
$ scheme --eedisable

# Use custom history file
$ scheme --eehistory /tmp/my_history

# Disable history saving
$ scheme --eehistory off

# Piping input (editor auto-disabled)
$ echo '(+ 1 2)' | scheme -q</code></pre>
    </ul>
    <br/><br/>


    <li>Boot File Options</li>
    <br/>
    <ul>
        <li><code>-b file</code> or <code>--boot file</code> — Load boot code from specified file.</li>
        <br/>
        <li><code>--verbose</code> — Trace the boot file search process.</li>
        <br/>
        <li>Boot files contain compiled Scheme code implementing the system. By default, the system searches for boot files based on the executable name.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Use custom boot file
$ scheme -b /path/to/custom.boot

# Multiple boot files (order matters: dependencies first)
$ scheme -b petite.boot -b scheme.boot -b myapp.boot

# Trace boot file searching
$ scheme --verbose

# Custom application with boot file
$ scheme -b myapp.boot --program main.ss</code></pre>
        <br/>
        <li>Creating boot files programmatically:</li>
<pre><code class="language-scheme line-numbers">; Create boot file depending on petite or scheme
(make-boot-file "myapp.boot"
                '("petite" "scheme")  ; alternatives
                "module1.so"
                "module2.so")

; Create standalone boot file (includes petite.boot)
(make-boot-file "standalone.boot"
                '()                    ; no dependencies
                "petite.boot"
                "myapp.so")</code></pre>
    </ul>
    <br/><br/>


    <li>Other Options</li>
    <br/>
    <ul>
        <li><code>--version</code> — Print version information and exit.</li>
        <br/>
        <li><code>--help</code> — Print brief help message and exit.</li>
        <br/>
        <li><code>--</code> — Pass all remaining arguments to Scheme (not processed as options).</li>
        <br/>
        <li><code>--enable-object-counts</code> — Have garbage collector maintain object counts.</li>
        <br/>
        <li><code>--retain-static-relocation</code> — Keep relocation info for <code>compute-size</code>, etc.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Check version
$ scheme --version
Chez Scheme Version 10.0.0

# Pass arguments that look like options to your script
$ scheme --script myapp.ss -- --my-flag --another-flag

# Enable object counting for memory profiling
$ scheme --enable-object-counts</code></pre>
    </ul>
    <br/><br/>


    <li>Environment Variables</li>
    <br/>
    <ul>
        <li><code>SCHEMEHEAPDIRS</code> — Colon-separated list of directories to search for boot files.</li>
        <ul>
            <li><code>%v</code> is replaced by the version number</li>
            <li><code>%m</code> is replaced by the machine type</li>
            <li><code>%%</code> is replaced by a literal <code>%</code></li>
        </ul>
        <br/>
        <li><code>CHEZSCHEMELIBDIRS</code> — Default value for <code>--libdirs</code> if not specified.</li>
        <br/>
        <li><code>CHEZSCHEMELIBEXTS</code> — Default value for <code>--libexts</code> if not specified.</li>
        <br/>
        <li><code>CHEZSCHEME_HISTORY</code> — Location of expression editor history file.</li>
        <br/>
        <li>Examples:</li>
<pre><code class="language-bash line-numbers"># Set boot file search path
export SCHEMEHEAPDIRS="/opt/chez/%v/%m:/usr/lib/csv%v"

# Set default library directories
export CHEZSCHEMELIBDIRS="/home/user/scheme/libs:/usr/local/lib/scheme"

# Set custom history location
export CHEZSCHEME_HISTORY="$HOME/.config/chez_history"</code></pre>
    </ul>
    <br/><br/>


    <li>Accessing Command Line Arguments in Scheme</li>
    <br/>
    <ul>
        <li>Use <code>(command-line)</code> to get arguments as a list.</li>
        <br/>
        <li>The first element is the script/program name, remaining elements are arguments.</li>
        <br/>
        <li>Use <code>(command-line-arguments)</code> for just the arguments (Chez-specific).</li>
        <br/>
        <li>Example script with argument parsing:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --script

(define args (command-line))

(display "Program: ")
(display (car args))
(newline)

(display "Arguments: ")
(display (cdr args))
(newline)

(display "Argument count: ")
(display (length (cdr args)))
(newline)

; Process arguments
(for-each
  (lambda (arg)
    (cond
      [(string=? arg "--help")
       (display "Usage: myscript [options]")
       (newline)
       (exit 0)]
      [(string=? arg "--verbose")
       (display "Verbose mode enabled")
       (newline)]
      [else
       (display "Unknown argument: ")
       (display arg)
       (newline)]))
  (cdr args))</code></pre>
<pre><code class="language-bash line-numbers">$ chmod +x myscript.ss
$ ./myscript.ss --verbose foo bar
Program: ./myscript.ss
Arguments: (--verbose foo bar)
Argument count: 3
Verbose mode enabled
Unknown argument: foo
Unknown argument: bar</code></pre>
    </ul>
    <br/><br/>


    <li>Quick Reference Table</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Option</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>-q, --quiet</code></td>
            <td>Suppress greeting and prompts</td>
        </tr>
        <tr>
            <td><code>--script file</code></td>
            <td>Run file as shell script</td>
        </tr>
        <tr>
            <td><code>--program file</code></td>
            <td>Run file as R6RS program</td>
        </tr>
        <tr>
            <td><code>--libdirs dir:...</code></td>
            <td>Set library directories</td>
        </tr>
        <tr>
            <td><code>--libexts ext:...</code></td>
            <td>Set library extensions</td>
        </tr>
        <tr>
            <td><code>--compile-imported-libraries</code></td>
            <td>Compile libraries before loading</td>
        </tr>
        <tr>
            <td><code>--import-notify</code></td>
            <td>Trace library search</td>
        </tr>
        <tr>
            <td><code>--optimize-level n</code></td>
            <td>Set optimization (0-3)</td>
        </tr>
        <tr>
            <td><code>--debug-on-exception</code></td>
            <td>Enter debugger on exceptions</td>
        </tr>
        <tr>
            <td><code>--eedisable</code></td>
            <td>Disable expression editor</td>
        </tr>
        <tr>
            <td><code>--eehistory off|file</code></td>
            <td>Set/disable history file</td>
        </tr>
        <tr>
            <td><code>-b, --boot file</code></td>
            <td>Load boot file</td>
        </tr>
        <tr>
            <td><code>--verbose</code></td>
            <td>Trace boot search</td>
        </tr>
        <tr>
            <td><code>--enable-object-counts</code></td>
            <td>Enable GC object counting</td>
        </tr>
        <tr>
            <td><code>--retain-static-relocation</code></td>
            <td>Keep relocation info</td>
        </tr>
        <tr>
            <td><code>--version</code></td>
            <td>Print version and exit</td>
        </tr>
        <tr>
            <td><code>--help</code></td>
            <td>Print help and exit</td>
        </tr>
        <tr>
            <td><code>--</code></td>
            <td>Pass remaining args to Scheme</td>
        </tr>
    </tbody>
</table>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-r6rs">R6RS in Chez Scheme</h3>
<ol>

    <li>What is R6RS?</li>
    <br/>
    <ul>
        <li>R6RS (Revised⁶ Report on the Algorithmic Language Scheme) is a major Scheme standard ratified in 2007.</li>
        <br/>
        <li>Key features introduced by R6RS:</li>
        <ul>
            <li>Standard library system for modular code</li>
            <li>Unicode support for source code and strings</li>
            <li>Exception handling and condition system</li>
            <li>Record types with procedural and syntactic layers</li>
            <li>Bytevectors for binary data</li>
            <li>Hash tables</li>
            <li>Hygienic macros via <code>syntax-case</code></li>
            <li>Full numeric tower requirement</li>
        </ul>
        <br/>
        <li>Chez Scheme fully implements R6RS and its standard libraries.</li>
    </ul>
    <br/><br/>


    <li>R6RS Standard Libraries</li>
    <br/>
    <ul>
        <li>R6RS organizes functionality into standard libraries that can be imported as needed:</li>
<table>
    <thead>
        <tr>
            <th>Library</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>(rnrs base (6))</code></td>
            <td>Core language: define, lambda, if, let, etc.</td>
        </tr>
        <tr>
            <td><code>(rnrs lists (6))</code></td>
            <td>List operations: find, filter, fold-left, etc.</td>
        </tr>
        <tr>
            <td><code>(rnrs sorting (6))</code></td>
            <td>Sorting: list-sort, vector-sort</td>
        </tr>
        <tr>
            <td><code>(rnrs control (6))</code></td>
            <td>Control: when, unless, do, case-lambda</td>
        </tr>
        <tr>
            <td><code>(rnrs io simple (6))</code></td>
            <td>Simple I/O: read, write, display</td>
        </tr>
        <tr>
            <td><code>(rnrs io ports (6))</code></td>
            <td>Port-based I/O: binary/textual ports</td>
        </tr>
        <tr>
            <td><code>(rnrs files (6))</code></td>
            <td>File operations: file-exists?, delete-file</td>
        </tr>
        <tr>
            <td><code>(rnrs unicode (6))</code></td>
            <td>Unicode: char-upcase, string-normalize-nfc</td>
        </tr>
        <tr>
            <td><code>(rnrs bytevectors (6))</code></td>
            <td>Binary data: bytevector operations</td>
        </tr>
        <tr>
            <td><code>(rnrs hashtables (6))</code></td>
            <td>Hash tables: make-hashtable, hashtable-ref</td>
        </tr>
        <tr>
            <td><code>(rnrs records syntactic (6))</code></td>
            <td>Record definitions via define-record-type</td>
        </tr>
        <tr>
            <td><code>(rnrs records procedural (6))</code></td>
            <td>Procedural record creation</td>
        </tr>
        <tr>
            <td><code>(rnrs records inspection (6))</code></td>
            <td>Record introspection</td>
        </tr>
        <tr>
            <td><code>(rnrs conditions (6))</code></td>
            <td>Condition types for exceptions</td>
        </tr>
        <tr>
            <td><code>(rnrs exceptions (6))</code></td>
            <td>Exception handling: guard, raise</td>
        </tr>
        <tr>
            <td><code>(rnrs syntax-case (6))</code></td>
            <td>Procedural macros</td>
        </tr>
        <tr>
            <td><code>(rnrs arithmetic fixnums (6))</code></td>
            <td>Fixed-precision integer operations</td>
        </tr>
        <tr>
            <td><code>(rnrs arithmetic flonums (6))</code></td>
            <td>Floating-point operations</td>
        </tr>
        <tr>
            <td><code>(rnrs arithmetic bitwise (6))</code></td>
            <td>Bitwise operations</td>
        </tr>
        <tr>
            <td><code>(rnrs enums (6))</code></td>
            <td>Enumeration types</td>
        </tr>
        <tr>
            <td><code>(rnrs eval (6))</code></td>
            <td>Evaluation: eval, environment</td>
        </tr>
        <tr>
            <td><code>(rnrs mutable-pairs (6))</code></td>
            <td>set-car!, set-cdr!</td>
        </tr>
        <tr>
            <td><code>(rnrs mutable-strings (6))</code></td>
            <td>string-set!, string-fill!</td>
        </tr>
        <tr>
            <td><code>(rnrs programs (6))</code></td>
            <td>command-line, exit</td>
        </tr>
        <tr>
            <td><code>(rnrs r5rs (6))</code></td>
            <td>R5RS compatibility: delay, force, etc.</td>
        </tr>
        <tr>
            <td><code>(rnrs (6))</code></td>
            <td>Composite: exports all of the above</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The version number <code>(6)</code> can usually be omitted:</li>
<pre><code class="language-scheme line-numbers">; These are equivalent
(import (rnrs base (6)))
(import (rnrs base))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Top-Level Programs</li>
    <br/>
    <ul>
        <li>An R6RS top-level program starts with an <code>import</code> form followed by a body:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

(define (greet name)
  (display "Hello, ")
  (display name)
  (display "!")
  (newline))

(greet "World")</code></pre>
        <br/>
        <li>Run with the <code>--program</code> option:</li>
<pre><code class="language-bash line-numbers">$ scheme --program hello.ss
Hello, World!</code></pre>
        <br/>
        <li>Make it executable with a shebang:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/scheme --program
(import (rnrs))

(for-each
  (lambda (arg)
    (display arg)
    (newline))
  (cdr (command-line)))</code></pre>
<pre><code class="language-bash line-numbers">$ chmod +x myprogram.ss
$ ./myprogram.ss arg1 arg2
arg1
arg2</code></pre>
        <br/>
        <li>Alternative shebang using <code>env</code>:</li>
<pre><code class="language-scheme line-numbers">#! /usr/bin/env scheme-script
(import (rnrs))
(display "Portable shebang!")
(newline)</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Library Definition</li>
    <br/>
    <ul>
        <li>Libraries are defined with the <code>library</code> form:</li>
<pre><code class="language-scheme line-numbers">(library (mylib utils)
  (export square cube average)
  (import (rnrs))

  (define (square x) (* x x))
  (define (cube x) (* x x x))
  (define (average x y) (/ (+ x y) 2)))</code></pre>
        <br/>
        <li>Save as <code>mylib/utils.sls</code> (directory structure matches library name).</li>
        <br/>
        <li>Use the library in a program:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs)
        (mylib utils))

(display (square 5))    ; 25
(newline)
(display (cube 3))      ; 27
(newline)</code></pre>
        <br/>
        <li>Library with versioning:</li>
<pre><code class="language-scheme line-numbers">(library (mylib math (1 0 0))
  (export factorial fibonacci)
  (import (rnrs))

  (define (factorial n)
    (if (zero? n) 1 (* n (factorial (- n 1)))))

  (define (fibonacci n)
    (if (< n 2) n
        (+ (fibonacci (- n 1))
           (fibonacci (- n 2))))))</code></pre>
    </ul>
    <br/><br/>


    <li>Import Specifications</li>
    <br/>
    <ul>
        <li>R6RS provides several ways to control imports:</li>
        <br/>
        <li><code>only</code> — import specific identifiers:</li>
<pre><code class="language-scheme line-numbers">(import (only (rnrs) define lambda if))</code></pre>
        <br/>
        <li><code>except</code> — import all except specified:</li>
<pre><code class="language-scheme line-numbers">(import (except (rnrs) set-car! set-cdr!))</code></pre>
        <br/>
        <li><code>prefix</code> — add prefix to all imports:</li>
<pre><code class="language-scheme line-numbers">(import (prefix (rnrs lists) list:))

(list:filter odd? '(1 2 3 4 5))  ; (1 3 5)</code></pre>
        <br/>
        <li><code>rename</code> — rename specific imports:</li>
<pre><code class="language-scheme line-numbers">(import (rename (rnrs)
                (display print)
                (newline nl)))

(print "Hello")
(nl)</code></pre>
        <br/>
        <li>Combinations:</li>
<pre><code class="language-scheme line-numbers">(import (prefix (only (rnrs lists) filter map) list:))

(list:map square '(1 2 3))       ; (1 4 9)
(list:filter even? '(1 2 3 4))   ; (2 4)</code></pre>
    </ul>
    <br/><br/>


    <li>Export Specifications</li>
    <br/>
    <ul>
        <li>Control what a library exports:</li>
        <br/>
        <li>Simple export:</li>
<pre><code class="language-scheme line-numbers">(library (mylib)
  (export public-proc another-proc)
  (import (rnrs))

  (define (public-proc x) (helper x))
  (define (another-proc y) (* y 2))
  (define (helper x) (+ x 1)))  ; not exported</code></pre>
        <br/>
        <li>Export with renaming:</li>
<pre><code class="language-scheme line-numbers">(library (mylib)
  (export (rename (internal-name external-name)
                  (proc1 public-proc1)))
  (import (rnrs))

  (define (internal-name x) ...)
  (define (proc1 x) ...))</code></pre>
        <br/>
        <li>Re-export from another library:</li>
<pre><code class="language-scheme line-numbers">(library (mylib combined)
  (export
    ; Export from this library
    my-func
    ; Re-export from rnrs lists
    (import (rnrs lists)))
  (import (rnrs)
          (rnrs lists))

  (define (my-func x) ...))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Records</li>
    <br/>
    <ul>
        <li>R6RS provides a powerful record system with syntactic and procedural layers.</li>
        <br/>
        <li>Syntactic layer (most common):</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

; Define a point record
(define-record-type point
  (fields x y))

; Create instances
(define p1 (make-point 3 4))

; Access fields
(point-x p1)    ; 3
(point-y p1)    ; 4

; Type predicate
(point? p1)     ; #t
(point? 42)     ; #f</code></pre>
        <br/>
        <li>Mutable fields:</li>
<pre><code class="language-scheme line-numbers">(define-record-type counter
  (fields (mutable value)))

(define c (make-counter 0))
(counter-value c)           ; 0
(counter-value-set! c 10)
(counter-value c)           ; 10</code></pre>
        <br/>
        <li>Record inheritance:</li>
<pre><code class="language-scheme line-numbers">(define-record-type point
  (fields x y))

(define-record-type point3d
  (parent point)
  (fields z))

(define p (make-point3d 1 2 3))
(point-x p)      ; 1 (inherited)
(point-y p)      ; 2 (inherited)
(point3d-z p)    ; 3
(point? p)       ; #t
(point3d? p)     ; #t</code></pre>
        <br/>
        <li>Custom constructor:</li>
<pre><code class="language-scheme line-numbers">(define-record-type person
  (fields name age)
  (protocol
    (lambda (new)
      (lambda (name birth-year)
        (new name (- 2025 birth-year))))))

(define p (make-person "Alice" 1990))
(person-name p)  ; "Alice"
(person-age p)   ; 35</code></pre>
        <br/>
        <li>Nongenerative records (same type across invocations):</li>
<pre><code class="language-scheme line-numbers">(define-record-type point
  (nongenerative point-uid-12345)
  (fields x y))</code></pre>
        <br/>
        <li>Sealed and opaque records:</li>
<pre><code class="language-scheme line-numbers">; Sealed: cannot be inherited
(define-record-type final-type
  (sealed #t)
  (fields value))

; Opaque: cannot be inspected
(define-record-type private-type
  (opaque #t)
  (fields secret))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Exception Handling</li>
    <br/>
    <ul>
        <li>R6RS provides <code>guard</code> for exception handling:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

(guard (ex
        [(error? ex)
         (display "Error: ")
         (display (condition-message ex))
         (newline)]
        [(assertion-violation? ex)
         (display "Assertion failed!")
         (newline)]
        [else
         (display "Unknown exception")
         (newline)])
  (assertion-violation 'test "something went wrong"))</code></pre>
        <br/>
        <li>Raising exceptions:</li>
<pre><code class="language-scheme line-numbers">; Raise continuable exception
(raise-continuable (make-warning))

; Raise non-continuable exception
(raise (make-error))

; Convenience procedures
(error 'proc-name "message" irritant1 irritant2)
(assertion-violation 'proc-name "message" irritant)</code></pre>
        <br/>
        <li>Condition hierarchy (partial):</li>
<pre><code class="language-scheme line-numbers">&condition
├── &warning
├── &serious
│   ├── &error
│   └── &violation
│       ├── &assertion
│       ├── &non-continuable
│       ├── &implementation-restriction
│       ├── &lexical
│       ├── &syntax
│       └── &undefined
├── &message
├── &irritants
└── &who</code></pre>
        <br/>
        <li>Creating compound conditions:</li>
<pre><code class="language-scheme line-numbers">(define my-condition
  (condition
    (make-error)
    (make-who-condition 'my-proc)
    (make-message-condition "Something failed")
    (make-irritants-condition '(bad-value))))

(raise my-condition)</code></pre>
        <br/>
        <li>Defining custom condition types:</li>
<pre><code class="language-scheme line-numbers">(define-condition-type &my-error &error
  make-my-error my-error?
  (code my-error-code))

(guard (ex
        [(my-error? ex)
         (display "My error with code: ")
         (display (my-error-code ex))])
  (raise (make-my-error 42)))</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Bytevectors</li>
    <br/>
    <ul>
        <li>Bytevectors are sequences of bytes for binary data:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

; Create bytevector
(define bv (make-bytevector 10 0))  ; 10 bytes, filled with 0

; Direct creation
(define bv2 #vu8(1 2 3 4 5))

; Access bytes
(bytevector-u8-ref bv2 0)           ; 1
(bytevector-u8-set! bv 0 255)

; Length
(bytevector-length bv2)             ; 5</code></pre>
        <br/>
        <li>Multi-byte access with endianness:</li>
<pre><code class="language-scheme line-numbers">; 16-bit access
(bytevector-u16-ref bv 0 (endianness big))
(bytevector-u16-set! bv 0 1000 (endianness little))

; 32-bit access
(bytevector-s32-ref bv 0 (endianness native))

; 64-bit access
(bytevector-u64-ref bv 0 (endianness big))

; Floating point
(bytevector-ieee-single-ref bv 0 (endianness native))
(bytevector-ieee-double-set! bv 0 3.14159 (endianness big))</code></pre>
        <br/>
        <li>String conversion:</li>
<pre><code class="language-scheme line-numbers">; UTF-8
(string->utf8 "Hello")           ; #vu8(72 101 108 108 111)
(utf8->string #vu8(72 101 108 108 111))  ; "Hello"

; UTF-16
(string->utf16 "Hello" (endianness big))
(utf16->string bv (endianness little))

; UTF-32
(string->utf32 "Hello" (endianness native))</code></pre>
        <br/>
        <li>Bytevector operations:</li>
<pre><code class="language-scheme line-numbers">; Copy
(bytevector-copy bv)
(bytevector-copy! src src-start dst dst-start count)

; Compare
(bytevector=? bv1 bv2)

; Fill
(bytevector-fill! bv 0)</code></pre>
    </ul>
    <br/><br/>


    <li>R6RS Hash Tables</li>
    <br/>
    <ul>
        <li>R6RS provides standard hash table operations:</li>
<pre><code class="language-scheme line-numbers">#!r6rs
(import (rnrs))

; Create hash tables
(define ht (make-hashtable string-hash string=?))
(define eq-ht (make-eq-hashtable))
(define eqv-ht (make-eqv-hashtable))

; Set and get
(hashtable-set! ht "name" "Alice")
(hashtable-set! ht "age" 30)
(hashtable-ref ht "name" #f)        ; "Alice"
(hashtable-ref ht "missing" 'default) ; default

; Check existence
(hashtable-contains? ht "name")     ; #t

; Delete
(hashtable-delete! ht "age")

; Size
(hashtable-size ht)                 ; 1</code></pre>
        <br/>
        <li>Iteration:</li>
<pre><code class="language-scheme line-numbers">; Get keys and values as vectors
(hashtable-keys ht)                 ; #("name")
(hashtable-entries ht)              ; #("name"), #("Alice")

; Process all entries
(let-values ([(keys vals) (hashtable-entries ht)])
  (vector-for-each
    (lambda (k v)
      (display k) (display ": ") (display v) (newline))
    keys vals))</code></pre>
        <br/>
        <li>Update operations:</li>
<pre><code class="language-scheme line-numbers">; Update existing or insert
(hashtable-update! ht "count"
  (lambda (v) (+ v 1))
  0)  ; default if not present

; Clear all
(hashtable-clear! ht)

; Copy
(hashtable-copy ht)
(hashtable-copy ht #t)  ; mutable copy</code></pre>
    </ul>
    <br/><br/>


    <li>Chez Scheme vs R6RS Mode</li>
    <br/>
    <ul>
        <li>Chez Scheme extends R6RS with additional features. Use <code>#!r6rs</code> for strict R6RS mode:</li>
<pre><code class="language-scheme line-numbers">; File starts in R6RS mode
#!r6rs
(import (rnrs))

; Only R6RS syntax allowed here
(define x 10)</code></pre>
        <br/>
        <li>Use <code>#!chezscheme</code> to enable Chez extensions:</li>
<pre><code class="language-scheme line-numbers">#!chezscheme
(import (chezscheme))

; Chez-specific features available
(printf "~a~n" "Hello")
(define-syntax my-macro
  (syntax-rules ()
    [(_ x) x]))  ; fenders allowed</code></pre>
        <br/>
        <li>The <code>(chezscheme)</code> library provides all R6RS bindings plus Chez extensions:</li>
<pre><code class="language-scheme line-numbers">; (rnrs) is strict R6RS
; (chezscheme) extends R6RS

; Some differences:
; - (chezscheme) syntax-rules allows fenders
; - (chezscheme) current-input-port accepts optional argument
; - (chezscheme) includes additional procedures</code></pre>
        <br/>
        <li>Chez also provides R6RS bindings with <code>rnrs:</code> prefix:</li>
<pre><code class="language-scheme line-numbers">(import (chezscheme))

; Both available:
(current-input-port)       ; Chez version (can set port)
(rnrs:current-input-port)  ; Strict R6RS version</code></pre>
    </ul>
    <br/><br/>


    <li>Compiling R6RS Programs</li>
    <br/>
    <ul>
        <li>Compile libraries:</li>
<pre><code class="language-bash line-numbers"># Compile a library
$ echo '(compile-library "mylib.sls")' | scheme

# Compile with auto-compilation of dependencies
$ scheme --compile-imported-libraries --program main.ss</code></pre>
        <br/>
        <li>Compile top-level programs:</li>
<pre><code class="language-bash line-numbers"># compile-program preserves shebang line
$ echo '(compile-program "myapp.ss")' | scheme

# Result: myapp.so (compiled program)</code></pre>
        <br/>
        <li>Programmatic compilation:</li>
<pre><code class="language-scheme line-numbers">; In REPL or build script
(compile-imported-libraries #t)  ; Auto-compile imports
(compile-library "mylib.sls")
(compile-program "main.ss")</code></pre>
        <br/>
        <li>Library search paths:</li>
<pre><code class="language-bash line-numbers"># Set library directories
$ scheme --libdirs ./src:./lib --program main.ss

# Set via environment
$ export CHEZSCHEMELIBDIRS="./src:./lib"
$ scheme --program main.ss</code></pre>
    </ul>
    <br/><br/>


    <li>Portability Tips</li>
    <br/>
    <ul>
        <li>R6RS does not guarantee argument evaluation order:</li>
<pre><code class="language-scheme line-numbers">; Don't rely on left-to-right evaluation
(define counter 0)
(define (inc!) (set! counter (+ counter 1)) counter)

; Result is implementation-dependent!
(list (inc!) (inc!) (inc!))  ; Could be (1 2 3) or (3 2 1) etc.</code></pre>
        <br/>
        <li>Fixnum range varies by implementation:</li>
<pre><code class="language-scheme line-numbers">; Minimum guaranteed: 24 bits (-8388608 to 8388607)
; Chez Scheme typically: 61 bits on 64-bit systems

; For portable code, use generic arithmetic for large numbers
(+ x y)  ; Always safe
(fx+ x y)  ; May overflow on small fixnum implementations</code></pre>
        <br/>
        <li>Specify endianness explicitly for binary data:</li>
<pre><code class="language-scheme line-numbers">; Don't use (endianness native) for files/network
(bytevector-u32-set! bv 0 value (endianness big))  ; Portable</code></pre>
        <br/>
        <li>Use <code>#!r6rs</code> at the start of portable code to ensure strict compliance.</li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-control-flow">Chez Scheme Control Flow</h3>
<ol>

    <li>Conditional Expressions</li>
    <br/>
    <ul>
        <li><code>if</code> is the fundamental conditional:</li>
<pre><code class="language-scheme line-numbers">; Basic if: (if test consequent alternative)
(if (> 5 3) 'yes 'no)           ; yes

; Without alternative (returns unspecified if false)
(if (> 5 3) (display "yes"))

; Nested if
(define (sign n)
  (if (> n 0)
      'positive
      (if (< n 0)
          'negative
          'zero)))

(sign 5)    ; positive
(sign -3)   ; negative
(sign 0)    ; zero</code></pre>
        <br/>
        <li><code>cond</code> for multiple conditions:</li>
<pre><code class="language-scheme line-numbers">; (cond [test expr ...] ... [else expr ...])
(define (grade score)
  (cond
    [(>= score 90) 'A]
    [(>= score 80) 'B]
    [(>= score 70) 'C]
    [(>= score 60) 'D]
    [else 'F]))

(grade 85)  ; B
(grade 55)  ; F

; cond with => (passes test result to procedure)
(cond
  [(assq 'b '((a 1) (b 2) (c 3))) => cadr]
  [else 'not-found])  ; 2

; Multiple expressions in clause
(cond
  [(even? x)
   (display "even")
   (newline)
   'even]
  [else 'odd])</code></pre>
        <br/>
        <li><code>case</code> for value matching:</li>
<pre><code class="language-scheme line-numbers">; (case key [(datum ...) expr ...] ... [else expr ...])
(define (day-type day)
  (case day
    [(saturday sunday) 'weekend]
    [(monday tuesday wednesday thursday friday) 'weekday]
    [else 'unknown]))

(day-type 'saturday)  ; weekend
(day-type 'monday)    ; weekday

; case uses eqv? for comparison
(case (car '(a b))
  [(a) 'first]
  [(b) 'second]
  [else 'other])  ; first

; Multiple values in single clause
(define (vowel? c)
  (case c
    [(a e i o u A E I O U) #t]
    [else #f]))</code></pre>
        <br/>
        <li><code>when</code> and <code>unless</code> for one-sided conditionals:</li>
<pre><code class="language-scheme line-numbers">; when: execute if true
(when (> x 0)
  (display "positive")
  (newline))

; unless: execute if false
(unless (null? lst)
  (display "list is not empty")
  (process lst))

; Equivalent to:
; (when test body ...) = (if test (begin body ...))
; (unless test body ...) = (if (not test) (begin body ...))</code></pre>
        <br/>
        <li>Boolean operations for control flow:</li>
<pre><code class="language-scheme line-numbers">; and: returns first false or last value
(and (> 5 3) (< 2 4) 'ok)       ; ok
(and (> 5 3) (< 4 2) 'ok)       ; #f
(and)                            ; #t

; or: returns first true or last value
(or (> 1 5) (> 3 2) 'fallback)  ; #t
(or #f #f 'default)             ; default
(or)                             ; #f

; Short-circuit evaluation
(and (pair? x) (car x))         ; Safe: car only if pair
(or (hashtable-ref ht key #f)
    (compute-default key))       ; Only compute if not found</code></pre>
    </ul>
    <br/><br/>


    <li>Sequencing</li>
    <br/>
    <ul>
        <li><code>begin</code> evaluates expressions in order:</li>
<pre><code class="language-scheme line-numbers">; Returns the value of the last expression
(begin
  (display "one")
  (newline)
  (display "two")
  (newline)
  'done)  ; displays "one" and "two", returns done

; Implicit begin in lambda, let, define, etc.
(define (greet name)
  (display "Hello, ")    ; implicit begin
  (display name)
  (newline))

; begin is often used in conditionals
(if (check-condition)
    (begin
      (do-something)
      (do-another)
      result)
    alternative)</code></pre>
        <br/>
        <li><code>begin0</code> returns the first value (Chez extension):</li>
<pre><code class="language-scheme line-numbers">; Returns value of first expression
(begin0
  (get-result)      ; This value is returned
  (cleanup)
  (log-completion))

; Useful for cleanup after getting a value
(define (pop! stack)
  (begin0
    (car stack)
    (set! stack (cdr stack))))</code></pre>
    </ul>
    <br/><br/>


    <li>Iteration with Named let</li>
    <br/>
    <ul>
        <li>Named <code>let</code> creates a local recursive procedure:</li>
<pre><code class="language-scheme line-numbers">; (let name ([var init] ...) body)
(let loop ([i 0])
  (when (< i 5)
    (display i)
    (newline)
    (loop (+ i 1))))
; Prints 0 1 2 3 4

; Summing a list
(define (sum lst)
  (let loop ([lst lst] [acc 0])
    (if (null? lst)
        acc
        (loop (cdr lst) (+ acc (car lst))))))

(sum '(1 2 3 4 5))  ; 15

; Finding an element
(define (find pred lst)
  (let loop ([lst lst])
    (cond
      [(null? lst) #f]
      [(pred (car lst)) (car lst)]
      [else (loop (cdr lst))])))</code></pre>
        <br/>
        <li>Named let for multiple accumulators:</li>
<pre><code class="language-scheme line-numbers">; Partition a list
(define (partition pred lst)
  (let loop ([lst lst] [yes '()] [no '()])
    (cond
      [(null? lst)
       (values (reverse yes) (reverse no))]
      [(pred (car lst))
       (loop (cdr lst) (cons (car lst) yes) no)]
      [else
       (loop (cdr lst) yes (cons (car lst) no))])))

(partition even? '(1 2 3 4 5 6))
; Values: (2 4 6) (1 3 5)</code></pre>
    </ul>
    <br/><br/>


    <li>The do Loop</li>
    <br/>
    <ul>
        <li><code>do</code> provides traditional loop syntax:</li>
<pre><code class="language-scheme line-numbers">; (do ([var init step] ...)
;     (test result ...)
;   body ...)

; Simple counting loop
(do ([i 0 (+ i 1)])
    [(= i 5) 'done]
  (display i)
  (newline))
; Prints 0 1 2 3 4, returns done

; Factorial
(define (factorial n)
  (do ([i n (- i 1)]
       [acc 1 (* acc i)])
      [(zero? i) acc]))

(factorial 5)  ; 120

; Multiple variables
(do ([i 0 (+ i 1)]
     [j 10 (- j 1)])
    [(= i j) (list i j)]
  (printf "i=~a j=~a~n" i j))
; Prints pairs until i=j=5</code></pre>
        <br/>
        <li>Building a list with do:</li>
<pre><code class="language-scheme line-numbers">; Map using do
(define (my-map f lst)
  (do ([lst lst (cdr lst)]
       [result '() (cons (f (car lst)) result)])
      [(null? lst) (reverse result)]))

(my-map square '(1 2 3 4 5))  ; (1 4 9 16 25)

; Collect first n elements
(define (take n lst)
  (do ([i 0 (+ i 1)]
       [lst lst (cdr lst)]
       [acc '() (cons (car lst) acc)])
      [(or (= i n) (null? lst))
       (reverse acc)]))</code></pre>
    </ul>
    <br/><br/>


    <li>Higher-Order Iteration</li>
    <br/>
    <ul>
        <li><code>for-each</code> for side effects:</li>
<pre><code class="language-scheme line-numbers">; Apply procedure to each element
(for-each display '(1 2 3 4 5))      ; Prints: 12345
(for-each
  (lambda (x) (display x) (newline))
  '(a b c))

; Multiple lists (stops at shortest)
(for-each
  (lambda (x y) (printf "~a + ~a = ~a~n" x y (+ x y)))
  '(1 2 3)
  '(10 20 30))
; 1 + 10 = 11
; 2 + 20 = 22
; 3 + 30 = 33</code></pre>
        <br/>
        <li><code>map</code> transforms lists:</li>
<pre><code class="language-scheme line-numbers">(map square '(1 2 3 4 5))           ; (1 4 9 16 25)
(map + '(1 2 3) '(10 20 30))        ; (11 22 33)
(map cons '(a b c) '(1 2 3))        ; ((a . 1) (b . 2) (c . 3))

; Nested map
(map (lambda (row)
       (map square row))
     '((1 2) (3 4) (5 6)))
; ((1 4) (9 16) (25 36))</code></pre>
        <br/>
        <li>Folding operations:</li>
<pre><code class="language-scheme line-numbers">; fold-left: accumulate left to right
; (fold-left proc init list)
(fold-left + 0 '(1 2 3 4 5))        ; 15
(fold-left cons '() '(1 2 3))       ; ((((() . 1) . 2) . 3)
(fold-left (lambda (acc x) (cons x acc))
           '() '(1 2 3))             ; (3 2 1) - reverse!

; fold-right: accumulate right to left
(fold-right cons '() '(1 2 3))      ; (1 2 3) - copy
(fold-right + 0 '(1 2 3 4 5))       ; 15

; Practical examples
(define (my-length lst)
  (fold-left (lambda (acc _) (+ acc 1)) 0 lst))

(define (my-reverse lst)
  (fold-left (lambda (acc x) (cons x acc)) '() lst))

(define (my-append lst1 lst2)
  (fold-right cons lst2 lst1))</code></pre>
        <br/>
        <li>Filtering and searching:</li>
<pre><code class="language-scheme line-numbers">; filter: keep matching elements
(filter even? '(1 2 3 4 5 6))       ; (2 4 6)
(filter (lambda (x) (> x 3)) '(1 2 3 4 5))  ; (4 5)

; find: first matching element
(find even? '(1 3 4 5 6))           ; 4
(find even? '(1 3 5))               ; #f

; exists: any element matches?
(exists even? '(1 3 4 5))           ; #t
(exists even? '(1 3 5))             ; #f

; for-all: all elements match?
(for-all even? '(2 4 6))            ; #t
(for-all even? '(2 3 4))            ; #f

; partition: split by predicate
(partition even? '(1 2 3 4 5 6))
; Values: (2 4 6) (1 3 5)</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Values</li>
    <br/>
    <ul>
        <li><code>values</code> returns multiple values:</li>
<pre><code class="language-scheme line-numbers">; Return multiple values
(define (quotient-remainder n d)
  (values (quotient n d) (remainder n d)))

(quotient-remainder 17 5)  ; 3 and 2

; values with any number of results
(values 1 2 3)             ; Three values
(values)                   ; Zero values
(values 'single)           ; One value (same as just 'single)</code></pre>
        <br/>
        <li><code>call-with-values</code> receives multiple values:</li>
<pre><code class="language-scheme line-numbers">; (call-with-values producer consumer)
(call-with-values
  (lambda () (values 1 2 3))
  (lambda (a b c) (+ a b c)))  ; 6

(call-with-values
  (lambda () (quotient-remainder 17 5))
  (lambda (q r) (list 'quotient q 'remainder r)))
; (quotient 3 remainder 2)</code></pre>
        <br/>
        <li><code>let-values</code> and <code>let*-values</code> bind multiple values:</li>
<pre><code class="language-scheme line-numbers">; let-values: bind multiple value results
(let-values ([(q r) (quotient-remainder 17 5)])
  (printf "17 = 5 * ~a + ~a~n" q r))
; 17 = 5 * 3 + 2

; Multiple bindings
(let-values ([(a b) (values 1 2)]
             [(x y z) (values 10 20 30)])
  (list a b x y z))  ; (1 2 10 20 30)

; let*-values: sequential binding
(let*-values ([(a b) (values 1 2)]
              [(c) (+ a b)])
  c)  ; 3

; With regular bindings mixed
(let-values ([(x y) (values 1 2)]
             [(z) 3])
  (+ x y z))  ; 6</code></pre>
        <br/>
        <li><code>define-values</code> for top-level definitions:</li>
<pre><code class="language-scheme line-numbers">(define-values (min-val max-val)
  (values 0 100))

min-val  ; 0
max-val  ; 100

(define-values (head . tail)
  (values 1 2 3 4 5))

head  ; 1
tail  ; (2 3 4 5)</code></pre>
    </ul>
    <br/><br/>


    <li>Continuations</li>
    <br/>
    <ul>
        <li><code>call/cc</code> captures the current continuation:</li>
<pre><code class="language-scheme line-numbers">; call/cc = call-with-current-continuation

; Early exit from computation
(define (find-first pred lst)
  (call/cc
    (lambda (return)
      (for-each
        (lambda (x)
          (when (pred x)
            (return x)))
        lst)
      #f)))

(find-first even? '(1 3 5 4 7))  ; 4
(find-first even? '(1 3 5 7))    ; #f

; Product with early exit on zero
(define (product lst)
  (call/cc
    (lambda (return)
      (let loop ([lst lst] [acc 1])
        (cond
          [(null? lst) acc]
          [(zero? (car lst)) (return 0)]
          [else (loop (cdr lst) (* acc (car lst)))])))))</code></pre>
        <br/>
        <li>Continuations as first-class values:</li>
<pre><code class="language-scheme line-numbers">; Save and reuse continuations
(define saved-k #f)

(+ 1 (call/cc
       (lambda (k)
         (set! saved-k k)
         2)))  ; 3

(saved-k 10)   ; 11 (continues from where we left)
(saved-k 100)  ; 101

; Continuations can be called multiple times
(let ([times 0])
  (let ([result (call/cc (lambda (k)
                           (set! saved-k k)
                           'first))])
    (set! times (+ times 1))
    (if (< times 3)
        (saved-k (string->symbol
                   (format "attempt-~a" times)))
        result)))
; Returns attempt-2 after being called multiple times</code></pre>
        <br/>
        <li>Implementing exceptions with continuations:</li>
<pre><code class="language-scheme line-numbers">(define (with-exception-handler handler thunk)
  (call/cc
    (lambda (return)
      (let ([raise (lambda (exn) (return (handler exn)))])
        (thunk raise)))))

(with-exception-handler
  (lambda (exn) (list 'caught exn))
  (lambda (raise)
    (raise 'my-error)))
; (caught my-error)</code></pre>
    </ul>
    <br/><br/>


    <li>Dynamic Wind</li>
    <br/>
    <ul>
        <li><code>dynamic-wind</code> ensures cleanup with continuations:</li>
<pre><code class="language-scheme line-numbers">; (dynamic-wind before thunk after)
; before: called when entering
; thunk: the main body
; after: called when exiting (even via continuation)

(dynamic-wind
  (lambda () (display "entering\n"))
  (lambda () (display "in body\n") 'result)
  (lambda () (display "leaving\n")))
; entering
; in body
; leaving
; Returns: result</code></pre>
        <br/>
        <li>Resource management:</li>
<pre><code class="language-scheme line-numbers">(define (with-input-file filename proc)
  (let ([port #f])
    (dynamic-wind
      (lambda () (set! port (open-input-file filename)))
      (lambda () (proc port))
      (lambda () (close-input-port port)))))

(with-input-file "data.txt"
  (lambda (port)
    (read port)))

; Even if continuation jumps out, port is closed
(call/cc
  (lambda (escape)
    (with-input-file "data.txt"
      (lambda (port)
        (escape 'early-exit)))))
; Port still properly closed!</code></pre>
        <br/>
        <li>Tracking entry/exit:</li>
<pre><code class="language-scheme line-numbers">(define level 0)

(define (show-level label)
  (printf "~a: level = ~a~n" label level))

(define (with-level thunk)
  (dynamic-wind
    (lambda ()
      (set! level (+ level 1))
      (show-level "enter"))
    thunk
    (lambda ()
      (show-level "exit")
      (set! level (- level 1)))))

(with-level
  (lambda ()
    (with-level
      (lambda ()
        (display "innermost\n")))))
; enter: level = 1
; enter: level = 2
; innermost
; exit: level = 2
; exit: level = 1</code></pre>
    </ul>
    <br/><br/>


    <li>Delimited Continuations</li>
    <br/>
    <ul>
        <li>Chez Scheme provides delimited continuations via <code>call/1cc</code>:</li>
<pre><code class="language-scheme line-numbers">; call/1cc: one-shot continuation (more efficient)
; Can only be called once

(define (find-first-1cc pred lst)
  (call/1cc
    (lambda (return)
      (for-each
        (lambda (x)
          (when (pred x)
            (return x)))
        lst)
      #f)))

; Use call/1cc when you only need to escape once</code></pre>
        <br/>
        <li>Prompts and control with <code>call/cc</code>:</li>
<pre><code class="language-scheme line-numbers">; Simulating generators with continuations
(define (make-generator proc)
  (let ([resume #f]
        [yield-k #f])
    (lambda ()
      (call/cc
        (lambda (return)
          (if resume
              (resume 'continue)
              (proc (lambda (value)
                      (call/cc
                        (lambda (k)
                          (set! resume k)
                          (return value)))))))))))

(define counter
  (make-generator
    (lambda (yield)
      (let loop ([i 0])
        (yield i)
        (loop (+ i 1))))))

(counter)  ; 0
(counter)  ; 1
(counter)  ; 2</code></pre>
    </ul>
    <br/><br/>


    <li>Exception Handling</li>
    <br/>
    <ul>
        <li><code>guard</code> for structured exception handling:</li>
<pre><code class="language-scheme line-numbers">(guard (exn
        [(error? exn)
         (display "An error occurred: ")
         (display (condition-message exn))
         (newline)
         'error-result]
        [(assertion-violation? exn)
         'assertion-failed]
        [else
         (raise exn)])  ; Re-raise if not handled
  (risky-operation))

; Nested guard
(guard (outer
        [else (display "outer caught it\n")])
  (guard (inner
          [(warning? inner) (display "just a warning\n")])
    (error 'test "something bad")))</code></pre>
        <br/>
        <li><code>with-exception-handler</code> for low-level handling:</li>
<pre><code class="language-scheme line-numbers">; Handler receives exception, can return or re-raise
(with-exception-handler
  (lambda (exn)
    (display "Handler called\n")
    (raise exn))  ; Re-raise to outer handler
  (lambda ()
    (error 'test "oops")))

; Handling continuable exceptions
(with-exception-handler
  (lambda (exn)
    (when (warning? exn)
      (display "Warning noted\n"))
    'continue-value)  ; Return value for continuable
  (lambda ()
    (let ([result (raise-continuable (make-warning))])
      (display "Continued with: ")
      (display result)
      (newline))))</code></pre>
        <br/>
        <li>Chez-specific <code>parameterize</code> for exception handling:</li>
<pre><code class="language-scheme line-numbers">; Using parameters for global exception behavior
(parameterize ([current-exception-handler
                (lambda (exn)
                  (printf "Caught: ~a~n" exn)
                  (default-exception-handler exn))])
  (error 'test "demo"))</code></pre>
    </ul>
    <br/><br/>


    <li>Non-Local Exit Patterns</li>
    <br/>
    <ul>
        <li>Early return from nested loops:</li>
<pre><code class="language-scheme line-numbers">(define (find-in-matrix pred matrix)
  (call/cc
    (lambda (return)
      (for-each
        (lambda (row)
          (for-each
            (lambda (elem)
              (when (pred elem)
                (return elem)))
            row))
        matrix)
      #f)))

(find-in-matrix
  (lambda (x) (> x 10))
  '((1 2 3) (4 5 6) (7 8 15)))  ; 15</code></pre>
        <br/>
        <li>Break and continue in loops:</li>
<pre><code class="language-scheme line-numbers">; Simulating break
(define (process-until-done lst)
  (call/cc
    (lambda (break)
      (for-each
        (lambda (x)
          (if (eq? x 'stop)
              (break 'stopped)
              (process x)))
        lst)
      'completed)))

; Simulating continue
(define (process-skip-negatives lst)
  (for-each
    (lambda (x)
      (call/cc
        (lambda (continue)
          (when (< x 0)
            (continue #f))
          (process x))))
    lst))</code></pre>
        <br/>
        <li>Return multiple levels:</li>
<pre><code class="language-scheme line-numbers">(define (deep-search tree target)
  (call/cc
    (lambda (found)
      (let search ([tree tree])
        (cond
          [(null? tree) #f]
          [(equal? (car tree) target)
           (found #t)]
          [(pair? (car tree))
           (search (car tree))
           (search (cdr tree))]
          [else
           (search (cdr tree))]))
      #f)))

(deep-search '(a (b (c d)) (e (f target g))) 'target)  ; #t</code></pre>
    </ul>
    <br/><br/>


    <li>Trampolining and Tail Calls</li>
    <br/>
    <ul>
        <li>Scheme guarantees tail call optimization:</li>
<pre><code class="language-scheme line-numbers">; This won't overflow the stack
(define (count-to n)
  (let loop ([i 0])
    (if (= i n)
        'done
        (loop (+ i 1)))))

(count-to 10000000)  ; Works fine!

; Tail recursive factorial
(define (factorial n)
  (let loop ([n n] [acc 1])
    (if (zero? n)
        acc
        (loop (- n 1) (* acc n)))))

; NOT tail recursive (multiplication after recursive call)
(define (factorial-bad n)
  (if (zero? n)
      1
      (* n (factorial-bad (- n 1)))))  ; Will overflow</code></pre>
        <br/>
        <li>Mutual recursion with tail calls:</li>
<pre><code class="language-scheme line-numbers">(define (even? n)
  (if (zero? n)
      #t
      (odd? (- n 1))))

(define (odd? n)
  (if (zero? n)
      #f
      (even? (- n 1))))

(even? 1000000)  ; #t, no stack overflow</code></pre>
        <br/>
        <li>Converting non-tail to tail recursive:</li>
<pre><code class="language-scheme line-numbers">; Non-tail recursive (builds up stack)
(define (sum-list lst)
  (if (null? lst)
      0
      (+ (car lst) (sum-list (cdr lst)))))

; Tail recursive with accumulator
(define (sum-list-tr lst)
  (let loop ([lst lst] [acc 0])
    (if (null? lst)
        acc
        (loop (cdr lst) (+ acc (car lst))))))

; CPS transformation for complex cases
(define (fib-cps n k)
  (if (< n 2)
      (k n)
      (fib-cps (- n 1)
               (lambda (a)
                 (fib-cps (- n 2)
                          (lambda (b)
                            (k (+ a b))))))))</code></pre>
    </ul>
    <br/><br/>


    <li>Fluid Bindings (Parameters)</li>
    <br/>
    <ul>
        <li>Parameters provide dynamic scoping:</li>
<pre><code class="language-scheme line-numbers">; Create a parameter
(define current-user (make-parameter "guest"))

(current-user)           ; "guest"

; Set temporarily with parameterize
(parameterize ([current-user "admin"])
  (display (current-user)))  ; "admin"

(current-user)           ; "guest" (restored)

; Nested parameterize
(parameterize ([current-user "alice"])
  (display (current-user))   ; alice
  (newline)
  (parameterize ([current-user "bob"])
    (display (current-user)) ; bob
    (newline))
  (display (current-user)))  ; alice</code></pre>
        <br/>
        <li>Parameters with validation:</li>
<pre><code class="language-scheme line-numbers">; Parameter with guard procedure
(define current-level
  (make-parameter 0
    (lambda (v)
      (unless (and (integer? v) (>= v 0))
        (error 'current-level "must be non-negative integer" v))
      v)))

(current-level 5)        ; OK
(current-level -1)       ; Error!</code></pre>
        <br/>
        <li>Common built-in parameters:</li>
<pre><code class="language-scheme line-numbers">; I/O parameters
(parameterize ([current-output-port (open-output-string)])
  (display "captured")
  (get-output-string (current-output-port)))

; Compilation parameters
(parameterize ([optimize-level 3]
               [debug-level 0])
  (compile-file "fast.ss"))

; Print parameters
(parameterize ([print-length 10]
               [print-level 5])
  (pretty-print deeply-nested-structure))</code></pre>
    </ul>
    <br/><br/>


    <li>Control Flow Summary</li>
    <br/>
    <ul>
        <li>Quick reference:</li>
<table>
    <thead>
        <tr>
            <th>Construct</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>if</code></td>
            <td>Simple two-way branch</td>
        </tr>
        <tr>
            <td><code>cond</code></td>
            <td>Multiple conditions</td>
        </tr>
        <tr>
            <td><code>case</code></td>
            <td>Match against literal values</td>
        </tr>
        <tr>
            <td><code>when/unless</code></td>
            <td>One-sided conditional with body</td>
        </tr>
        <tr>
            <td><code>and/or</code></td>
            <td>Short-circuit boolean logic</td>
        </tr>
        <tr>
            <td><code>begin</code></td>
            <td>Sequence expressions</td>
        </tr>
        <tr>
            <td>Named <code>let</code></td>
            <td>General iteration/recursion</td>
        </tr>
        <tr>
            <td><code>do</code></td>
            <td>Traditional loop with step</td>
        </tr>
        <tr>
            <td><code>for-each</code></td>
            <td>Iterate for side effects</td>
        </tr>
        <tr>
            <td><code>map</code></td>
            <td>Transform lists</td>
        </tr>
        <tr>
            <td><code>fold-left/right</code></td>
            <td>Accumulate over lists</td>
        </tr>
        <tr>
            <td><code>values</code></td>
            <td>Return multiple values</td>
        </tr>
        <tr>
            <td><code>let-values</code></td>
            <td>Bind multiple values</td>
        </tr>
        <tr>
            <td><code>call/cc</code></td>
            <td>Capture continuation</td>
        </tr>
        <tr>
            <td><code>dynamic-wind</code></td>
            <td>Ensure cleanup with continuations</td>
        </tr>
        <tr>
            <td><code>guard</code></td>
            <td>Exception handling</td>
        </tr>
        <tr>
            <td><code>parameterize</code></td>
            <td>Dynamic/fluid bindings</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-debugging">Chez Scheme Debugging</h3>
<ol>

    <li>Print Debugging with printf</li>
    <br/>
    <ul>
        <li>The simplest debugging technique — insert print statements:</li>
<pre><code class="language-scheme line-numbers">; printf works like C's printf but uses ~ instead of %
(define (factorial n)
  (printf "factorial called with n = ~a~n" n)
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

(factorial 5)
; factorial called with n = 5
; factorial called with n = 4
; factorial called with n = 3
; factorial called with n = 2
; factorial called with n = 1
; factorial called with n = 0
; 120</code></pre>
        <br/>
        <li>Common format directives:</li>
<table>
    <thead>
        <tr>
            <th>Directive</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>~a</code></td>
            <td>Display (human-readable, no quotes on strings)</td>
        </tr>
        <tr>
            <td><code>~s</code></td>
            <td>Write (machine-readable, quotes on strings)</td>
        </tr>
        <tr>
            <td><code>~d</code></td>
            <td>Decimal integer</td>
        </tr>
        <tr>
            <td><code>~b</code></td>
            <td>Binary integer</td>
        </tr>
        <tr>
            <td><code>~x</code></td>
            <td>Hexadecimal integer</td>
        </tr>
        <tr>
            <td><code>~n</code> or <code>~%</code></td>
            <td>Newline</td>
        </tr>
        <tr>
            <td><code>~~</code></td>
            <td>Literal tilde</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Examples:</li>
<pre><code class="language-scheme line-numbers">(printf "~a~n" "hello")       ; hello
(printf "~s~n" "hello")       ; "hello"
(printf "~d in binary is ~b~n" 42 42)  ; 42 in binary is 101010
(printf "hex: ~x~n" 255)      ; hex: ff

; Multiple values
(printf "x=~a, y=~a, sum=~a~n" 3 4 (+ 3 4))
; x=3, y=4, sum=7</code></pre>
        <br/>
        <li>Using <code>format</code> to create strings:</li>
<pre><code class="language-scheme line-numbers">; format returns a string instead of printing
(define msg (format "Value is ~a" 42))
msg  ; "Value is 42"

; Useful for logging
(define (log level msg . args)
  (printf "[~a] ~a~n" level (apply format msg args)))

(log 'INFO "Processing item ~a of ~a" 5 10)
; [INFO] Processing item 5 of 10</code></pre>
    </ul>
    <br/><br/>


    <li>Tracing Procedures</li>
    <br/>
    <ul>
        <li><code>trace</code> shows procedure calls and return values:</li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

; Enable tracing
(trace factorial)  ; (factorial)

(factorial 5)
; |(factorial 5)
; | (factorial 4)
; | |(factorial 3)
; | | (factorial 2)
; | | |(factorial 1)
; | | | (factorial 0)
; | | | 1
; | | |1
; | | 2
; | |6
; | 24
; |120
; 120

; Disable tracing
(untrace factorial)</code></pre>
        <br/>
        <li>Trace multiple procedures including built-ins:</li>
<pre><code class="language-scheme line-numbers">(trace factorial * -)  ; (factorial * -)

(factorial 3)
; |(factorial 3)
; | (factorial 2)
; | |(factorial 1)
; | | (factorial 0)
; | | 1
; | |(* 1 1)
; | |1
; | (* 2 1)
; | 2
; |(* 3 2)
; |6
; 6

; Untrace specific procedures
(untrace *)            ; (-)

; Untrace all
(untrace)              ; (factorial -)</code></pre>
        <br/>
        <li>Check what's being traced:</li>
<pre><code class="language-scheme line-numbers">(trace)  ; Returns list of currently traced procedures</code></pre>
        <br/>
        <li><code>trace-define</code> for inline tracing:</li>
<pre><code class="language-scheme line-numbers">; Automatically traced when defined
(trace-define (sum-list lst)
  (if (null? lst)
      0
      (+ (car lst) (sum-list (cdr lst)))))

(sum-list '(1 2 3))
; |(sum-list (1 2 3))
; | (sum-list (2 3))
; | |(sum-list (3))
; | | (sum-list ())
; | | 0
; | |3
; | 5
; |6
; 6</code></pre>
        <br/>
        <li><code>trace-lambda</code> for anonymous procedures:</li>
<pre><code class="language-scheme line-numbers">(define factorial
  (trace-lambda fact (n)
    (if (zero? n)
        1
        (* n (fact (- n 1))))))

(factorial 4)
; |(fact 4)
; | (fact 3)
; | |(fact 2)
; | | (fact 1)
; | | |(fact 0)
; | | |1
; | | 1
; | |2
; | 6
; |24
; 24</code></pre>
        <br/>
        <li><code>trace-define-syntax</code> for macros:</li>
<pre><code class="language-scheme line-numbers">(trace-define-syntax my-or
  (syntax-rules ()
    [(_) #f]
    [(_ e) e]
    [(_ e1 e2 ...) (let ([t e1]) (if t t (my-or e2 ...)))]))

(my-or #f #f 'found)
; |(my-or (my-or #f #f 'found))
; |(let ((t #f)) (if t t (my-or #f 'found)))
; found</code></pre>
    </ul>
    <br/><br/>


    <li>The Debugger</li>
    <br/>
    <ul>
        <li>When an error occurs, Chez Scheme suggests entering the debugger:</li>
<pre><code class="language-scheme line-numbers">> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.
></code></pre>
        <br/>
        <li>Enter the debugger with <code>(debug)</code>:</li>
<pre><code class="language-scheme line-numbers">> (debug)
debug></code></pre>
        <br/>
        <li>Debugger commands (type <code>?</code> to see):</li>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>?</code></td>
            <td>Show available commands</td>
        </tr>
        <tr>
            <td><code>i</code></td>
            <td>Inspect the raise continuation</td>
        </tr>
        <tr>
            <td><code>c</code></td>
            <td>Inspect the condition</td>
        </tr>
        <tr>
            <td><code>s</code></td>
            <td>Display the condition</td>
        </tr>
        <tr>
            <td><code>e</code></td>
            <td>Exit debugger, retain error continuation</td>
        </tr>
        <tr>
            <td><code>r</code></td>
            <td>Reset to REPL</td>
        </tr>
        <tr>
            <td><code>a</code></td>
            <td>Abort Scheme entirely</td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>Enter a new café</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Typical debugging session:</li>
<pre><code class="language-scheme line-numbers">> (define (my-reverse lst)
    (if (null? lst)
        '()
        (append (my-reverse (cdr lst)) (car lst))))

> (my-reverse '(1 2 3))
Exception in append: 1 is not a proper list
Type (debug) to enter the debugger.

> (debug)
debug> i                    ; Inspect continuation
#<continuation in append> :
debug> sf                   ; Show stack frames</code></pre>
    </ul>
    <br/><br/>


    <li>The Inspector</li>
    <br/>
    <ul>
        <li>After typing <code>i</code> in the debugger, you enter the inspector:</li>
<pre><code class="language-scheme line-numbers">debug> i
#<continuation in my-reverse> :</code></pre>
        <br/>
        <li>Inspector commands for continuations:</li>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>?</code></td>
            <td>Show commands for current object type</td>
        </tr>
        <tr>
            <td><code>??</code></td>
            <td>Show navigation commands</td>
        </tr>
        <tr>
            <td><code>s</code> or <code>show</code></td>
            <td>Show code and free variables</td>
        </tr>
        <tr>
            <td><code>sf</code></td>
            <td>Show stack frames</td>
        </tr>
        <tr>
            <td><code>d</code> or <code>down</code></td>
            <td>Move down to next frame</td>
        </tr>
        <tr>
            <td><code>u</code> or <code>up</code></td>
            <td>Move up to previous frame</td>
        </tr>
        <tr>
            <td><code>r N</code> or <code>ref N</code></td>
            <td>Inspect Nth free variable</td>
        </tr>
        <tr>
            <td><code>code</code> or <code>c</code></td>
            <td>Inspect the procedure code</td>
        </tr>
        <tr>
            <td><code>call</code></td>
            <td>Inspect the pending call</td>
        </tr>
        <tr>
            <td><code>q</code> or <code>quit</code></td>
            <td>Exit inspector</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Inspecting stack frames:</li>
<pre><code class="language-scheme line-numbers">#<continuation in my-reverse> : sf
0: #<continuation in my-reverse>
1: #<continuation in my-reverse>
2: #<continuation in my-reverse>
3: #<continuation in my-reverse>
4: #<system continuation>

#<continuation in my-reverse> : s
continuation: #<continuation in my-reverse>
procedure code: (lambda (lst) (if (null? lst) ... ...))
call code: (append (my-reverse (cdr lst)) (car lst))
free variables:
  0. lst: (1)

#<continuation in my-reverse> : d    ; Move to next frame
#<continuation in my-reverse> : s
free variables:
  0. lst: (2 1)

#<continuation in my-reverse> : r 0  ; Inspect lst
(2 1) :</code></pre>
        <br/>
        <li>Directly inspect any object with <code>inspect</code>:</li>
<pre><code class="language-scheme line-numbers">> (define (square x) (* x x))
> (inspect square)
#<procedure square> : ?
  show(s) .......... show code and free variables
  code(c) .......... inspect the code for the procedure
  ref(r) ........... inspect [nth] free variable
  length(l) ........ display number of free variables

#<procedure square> : c
(lambda (x) (* x x)) :

#<procedure square> : quit
></code></pre>
        <br/>
        <li>Inspector commands for different object types:</li>
<pre><code class="language-scheme line-numbers">; Lists
> (inspect '(1 2 3))
(1 2 3) : ?
  car .............. inspect car of pair
  cdr .............. inspect cdr of pair
  ref(r) ........... inspect [nth] car
  tail ............. inspect [nth] cdr
  show(s) .......... show [n] elements
  length(l) ........ display list length

(1 2 3) : car
1 :

; Vectors
> (inspect #(a b c))
#(a b c) : ref 1
b :</code></pre>
    </ul>
    <br/><br/>


    <li>Breakpoints</li>
    <br/>
    <ul>
        <li>Insert <code>(break)</code> to pause execution:</li>
<pre><code class="language-scheme line-numbers">(define (process-items items)
  (for-each
    (lambda (item)
      (break)              ; Pause here
      (display item)
      (newline))
    items))

> (process-items '(a b c))
break>                     ; Execution paused</code></pre>
        <br/>
        <li>Break handler commands:</li>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>?</code></td>
            <td>Show options</td>
        </tr>
        <tr>
            <td><code>e</code></td>
            <td>Exit break and continue execution</td>
        </tr>
        <tr>
            <td><code>i</code></td>
            <td>Inspect current continuation</td>
        </tr>
        <tr>
            <td><code>r</code></td>
            <td>Reset to REPL</td>
        </tr>
        <tr>
            <td><code>a</code></td>
            <td>Abort Scheme</td>
        </tr>
        <tr>
            <td><code>n</code></td>
            <td>Enter new café</td>
        </tr>
        <tr>
            <td><code>s</code></td>
            <td>Display statistics</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Break with a message:</li>
<pre><code class="language-scheme line-numbers">(define (compute x y)
  (let ([sum (+ x y)]
        [product (* x y)])
    (break 'compute "checking values")
    (list sum product)))

> (compute 3 4)
break in compute: "checking values"
break> i
#<continuation in compute> : s
free variables:
  0. product: 12
  1. sum: 7
  2. y: 4
  3. x: 3
#<continuation in compute> : q
break> e              ; Continue execution
(7 12)</code></pre>
        <br/>
        <li>Conditional breakpoints:</li>
<pre><code class="language-scheme line-numbers">(define (process n)
  (when (> n 100)        ; Only break on large values
    (break 'process "n is large"))
  (* n 2))

; Or using a helper
(define-syntax break-when
  (syntax-rules ()
    [(_ condition msg)
     (when condition (break 'break-when msg))]))

(define (search lst target)
  (break-when (> (length lst) 1000) "large list")
  (member target lst))</code></pre>
    </ul>
    <br/><br/>


    <li>Interrupting Infinite Loops</li>
    <br/>
    <ul>
        <li>Press <code>Ctrl-C</code> to interrupt a running computation:</li>
<pre><code class="language-scheme line-numbers">(define (infinite-loop)
  (infinite-loop))

> (infinite-loop)
^C                         ; Press Ctrl-C
break>                     ; Enters break handler</code></pre>
        <br/>
        <li>From the break handler, inspect where you are:</li>
<pre><code class="language-scheme line-numbers">break> i                   ; Inspect continuation
#<continuation in infinite-loop> : sf
0: #<continuation in infinite-loop>
1: #<continuation in infinite-loop>
2: #<continuation in infinite-loop>
... many frames ...

#<continuation in infinite-loop> : s
procedure code: (lambda () (infinite-loop))
call code: (infinite-loop)

break> r                   ; Reset to REPL
></code></pre>
        <br/>
        <li>Finding where a loop is stuck:</li>
<pre><code class="language-scheme line-numbers">(define (buggy-find x lst)
  (cond
    [(null? lst) #f]
    [(equal? x (car lst)) #t]
    [else (buggy-find x lst)]))  ; Bug: should be (cdr lst)

> (buggy-find 'z '(a b c))
^C
break> i
#<continuation in buggy-find> : s
free variables:
  0. lst: (a b c)         ; lst never changes!
  1. x: z</code></pre>
    </ul>
    <br/><br/>


    <li>Debug Parameters</li>
    <br/>
    <ul>
        <li><code>debug-on-exception</code> — enter debugger automatically:</li>
<pre><code class="language-scheme line-numbers">; Enable automatic debugging
(debug-on-exception #t)

> (car 5)
Exception in car: 5 is not a pair
debug>                     ; Directly in debugger, no need for (debug)

; From command line
$ scheme --debug-on-exception --script buggy.ss</code></pre>
        <br/>
        <li><code>debug-level</code> — control debug information (0-3):</li>
<pre><code class="language-scheme line-numbers">; Higher levels retain more debug info
(debug-level 3)            ; Maximum debug info (default)
(debug-level 0)            ; Minimal debug info (faster)

; Check current level
(debug-level)              ; Returns current level</code></pre>
        <br/>
        <li><code>generate-inspector-information</code> — control what's saved:</li>
<pre><code class="language-scheme line-numbers">; Disable for production (smaller, faster code)
(parameterize ([generate-inspector-information #f])
  (compile-file "production.ss"))

; Enable for development (better debugging)
(parameterize ([generate-inspector-information #t])
  (compile-file "development.ss"))</code></pre>
        <br/>
        <li><code>debug-condition</code> — access the last exception:</li>
<pre><code class="language-scheme line-numbers">> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.

> (debug-condition)
#<condition &assertion>

> (condition-message (debug-condition))
"~s is not a pair"

> (condition-irritants (debug-condition))
(5)</code></pre>
    </ul>
    <br/><br/>


    <li>Pretty Printing</li>
    <br/>
    <ul>
        <li><code>pretty-print</code> for readable output:</li>
<pre><code class="language-scheme line-numbers">(define complex-data
  '((name . "Alice")
    (scores . (90 85 92 88))
    (address . ((street . "123 Main")
                (city . "Boston")))))

> (write complex-data)
((name . "Alice") (scores 90 85 92 88) (address (street . "123 Main") (city . "Boston")))

> (pretty-print complex-data)
((name . "Alice")
 (scores 90 85 92 88)
 (address
   (street . "123 Main")
   (city . "Boston")))</code></pre>
        <br/>
        <li>Control pretty-print behavior:</li>
<pre><code class="language-scheme line-numbers">; Limit depth
(parameterize ([print-level 2])
  (pretty-print '(a (b (c (d (e)))))))
; (a (b (#1=#2#)))

; Limit length
(parameterize ([print-length 3])
  (pretty-print '(1 2 3 4 5 6 7 8 9 10)))
; (1 2 3 ...)

; Both limits
(parameterize ([print-level 2]
               [print-length 5])
  (pretty-print deeply-nested-list))</code></pre>
        <br/>
        <li><code>pretty-format</code> returns a string:</li>
<pre><code class="language-scheme line-numbers">(define formatted (pretty-format '(define (f x) (+ x 1))))
; Returns formatted string instead of printing</code></pre>
    </ul>
    <br/><br/>


    <li>Assertions and Contracts</li>
    <br/>
    <ul>
        <li><code>assert</code> for runtime checks:</li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (assert (and (integer? n) (>= n 0)))
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

> (factorial -1)
Exception: failed assertion (and (integer? n) (>= n 0))
Type (debug) to enter the debugger.

> (factorial 5)
120</code></pre>
        <br/>
        <li>Custom assertions with better messages:</li>
<pre><code class="language-scheme line-numbers">(define-syntax assert-type
  (syntax-rules ()
    [(_ pred val msg)
     (unless (pred val)
       (assertion-violation 'assert-type msg val))]))

(define (process-list lst)
  (assert-type list? lst "expected a list")
  (map add1 lst))

> (process-list 5)
Exception in assert-type: expected a list
  irritants: 5</code></pre>
        <br/>
        <li>Design-by-contract style:</li>
<pre><code class="language-scheme line-numbers">(define (divide x y)
  ; Preconditions
  (assert (number? x))
  (assert (number? y))
  (assert (not (zero? y)))

  (let ([result (/ x y)])
    ; Postcondition
    (assert (number? result))
    result))</code></pre>
    </ul>
    <br/><br/>


    <li>Timing and Profiling</li>
    <br/>
    <ul>
        <li><code>time</code> measures execution:</li>
<pre><code class="language-scheme line-numbers">> (time (factorial 10000))
(time (factorial 10000))
    no collections
    0.023756917s elapsed cpu time
    0.023821000s elapsed real time
    134696 bytes allocated
#<very large number...></code></pre>
        <br/>
        <li><code>statistics</code> for detailed info:</li>
<pre><code class="language-scheme line-numbers">> (statistics)
    0 collections
    no time in collector
    0.156250000s elapsed cpu time
    1.234567000s elapsed real time
    1234567 bytes allocated</code></pre>
        <br/>
        <li>Manual timing:</li>
<pre><code class="language-scheme line-numbers">(define (time-it thunk)
  (let ([start (current-time)])
    (let ([result (thunk)])
      (let ([end (current-time)])
        (printf "Elapsed: ~a seconds~n"
                (- (time-second end) (time-second start)))
        result))))

(time-it (lambda () (factorial 50000)))</code></pre>
        <br/>
        <li>Profile with <code>profile</code> (Chez-specific):</li>
<pre><code class="language-scheme line-numbers">; Enable profiling
(compile-profile #t)

; Compile with profiling
(compile-file "mycode.ss")

; Run code
(load "mycode.so")
(my-function test-data)

; Show profile
(profile-dump-html "profile.html")</code></pre>
    </ul>
    <br/><br/>


    <li>Café System</li>
    <br/>
    <ul>
        <li>Chez Scheme uses "cafés" as nested REPL levels:</li>
<pre><code class="language-scheme line-numbers">; One angle bracket = level 1
>

; Enter a new café
> (new-cafe)
>>                         ; Two brackets = level 2

; Exit back to level 1
>> (exit)
></code></pre>
        <br/>
        <li>Each café has its own reset and exit:</li>
<pre><code class="language-scheme line-numbers">> (new-cafe)
>> (new-cafe)
>>>                        ; Level 3

>>> (reset)                ; Reset level 3
>>>

>>> (exit)                 ; Exit to level 2
>>

>> (exit)                  ; Exit to level 1
></code></pre>
        <br/>
        <li>From break/debug, <code>n</code> enters a new café for testing:</li>
<pre><code class="language-scheme line-numbers">> (car 5)
Exception in car: 5 is not a pair
Type (debug) to enter the debugger.

> (debug)
debug> n                   ; New café
>>                         ; Can test things here
>> (+ 1 2)
3
>> (exit)                  ; Return to debug
debug> r                   ; Reset to main REPL
></code></pre>
    </ul>
    <br/><br/>


    <li>Common Debugging Patterns</li>
    <br/>
    <ul>
        <li>Debug wrapper for procedures:</li>
<pre><code class="language-scheme line-numbers">(define (debug-wrap name proc)
  (lambda args
    (printf "ENTER ~a: ~s~n" name args)
    (let ([result (apply proc args)])
      (printf "EXIT ~a: ~s~n" name result)
      result)))

(define my-add (debug-wrap 'add +))
> (my-add 1 2 3)
ENTER add: (1 2 3)
EXIT add: 6
6</code></pre>
        <br/>
        <li>Conditional debug output:</li>
<pre><code class="language-scheme line-numbers">(define *debug* (make-parameter #f))

(define-syntax debug-print
  (syntax-rules ()
    [(_ fmt args ...)
     (when (*debug*)
       (printf fmt args ...))]))

(define (my-function x)
  (debug-print "Processing ~a~n" x)
  (* x 2))

; Enable debugging
(parameterize ([*debug* #t])
  (my-function 5))
; Processing 5
; 10

; Disable debugging
(my-function 5)
; 10</code></pre>
        <br/>
        <li>Safe evaluation for testing:</li>
<pre><code class="language-scheme line-numbers">(define (safe-eval expr)
  (guard (ex
          [else
           (printf "Error: ~a~n" (condition-message ex))
           #f])
    (eval expr)))

> (safe-eval '(+ 1 2))
3
> (safe-eval '(car 5))
Error: ~s is not a pair
#f</code></pre>
        <br/>
        <li>Step-by-step execution helper:</li>
<pre><code class="language-scheme line-numbers">(define-syntax step
  (syntax-rules ()
    [(_ label expr)
     (begin
       (printf "~a: ~s~n" label 'expr)
       (let ([result expr])
         (printf "  => ~s~n" result)
         result))]))

(define (calculate x)
  (step "square" (* x x))
  (step "add-one" (+ (* x x) 1))
  (step "final" (sqrt (+ (* x x) 1))))

> (calculate 3)
square: (* x x)
  => 9
add-one: (+ (* x x) 1)
  => 10
final: (sqrt (+ (* x x) 1))
  => 3.1622776601683795
3.1622776601683795</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
