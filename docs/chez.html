<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>chez scheme</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/chez.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#scm-syntax-overview">Syntax Overview</a></li>
        <li><a href="#scm-multiple-expressions">Multiple Expressions</a></li>
        <li><a href="#scm-naming-conventions">Naming Conventions</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-syntax-overview">Chez Scheme Syntax Overview</h3>
<ol>

    <li>Understanding Scheme Basics</li>
    <br/>
    <ul>
        <li>Scheme is a dialect of Lisp with minimal, elegant syntax.</li>
        <br/>
        <li><b>Core principle:</b> Everything is an expression that returns a value.</li>
        <br/>
        <li><b>Syntax pattern:</b> <code>(function arg1 arg2 arg3 ...)</code></li>
        <ul>
            <li>Parentheses group expressions</li>
            <li>First element is the function/operator</li>
            <li>Remaining elements are arguments</li>
            <li>This is called "prefix notation" or "Polish notation"</li>
        </ul>
        <br/>
        <li><b>Examples of basic syntax:</b></li>
<pre><code class="language-scheme line-numbers">; Addition
(+ 2 3)          ; Returns: 5

; Multiplication
(* 4 5)          ; Returns: 20

; Function call
(string-length "hello")  ; Returns: 5

; Nested expressions
(+ (* 2 3) 4)    ; Returns: 10
                 ; First evaluates (* 2 3) = 6
                 ; Then evaluates (+ 6 4) = 10</code></pre>
        <br/>
        <li><b>Comments:</b></li>
<pre><code class="language-scheme line-numbers">; Single-line comment starts with semicolon

#|
  Multi-line
  comment between
  #| and |#
|#</code></pre>
        <br/>
        <li><b>Case sensitivity:</b> Scheme is case-insensitive by default, but Chez Scheme preserves case.</li>
<pre><code class="language-scheme line-numbers">(define MyVar 10)
MyVar    ; Works
MYVAR    ; Doesn't Work</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Data Types</li>
    <br/>
    <ul>
        <li>Scheme has several fundamental data types:</li>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Examples</th>
            <th>Predicate</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Number</td>
            <td><code>42</code>, <code>3.14</code>, <code>1/3</code>, <code>2+3i</code></td>
            <td><code>number?</code></td>
        </tr>
        <tr>
            <td>Boolean</td>
            <td><code>#t</code>, <code>#f</code></td>
            <td><code>boolean?</code></td>
        </tr>
        <tr>
            <td>String</td>
            <td><code>"hello"</code>, <code>"world"</code></td>
            <td><code>string?</code></td>
        </tr>
        <tr>
            <td>Character</td>
            <td><code>#\a</code>, <code>#\space</code></td>
            <td><code>char?</code></td>
        </tr>
        <tr>
            <td>Symbol</td>
            <td><code>'foo</code>, <code>'bar</code></td>
            <td><code>symbol?</code></td>
        </tr>
        <tr>
            <td>List</td>
            <td><code>'(1 2 3)</code>, <code>'(a b c)</code></td>
            <td><code>list?</code></td>
        </tr>
        <tr>
            <td>Pair</td>
            <td><code>'(1 . 2)</code></td>
            <td><code>pair?</code></td>
        </tr>
        <tr>
            <td>Vector</td>
            <td><code>#(1 2 3)</code></td>
            <td><code>vector?</code></td>
        </tr>
        <tr>
            <td>Procedure</td>
            <td><code>(lambda (x) (* x x))</code></td>
            <td><code>procedure?</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Numbers:</b></li>
<pre><code class="language-scheme line-numbers">; Integers
42
-17
0

; Floating point
3.14
-2.5

; Fractions (exact rationals)
1/3
22/7

; Complex numbers
2+3i
-1-4i

; Different bases
#b1010      ; Binary (10 in decimal)
#o755       ; Octal (493 in decimal)
#x1A        ; Hexadecimal (26 in decimal)</code></pre>
        <br/>
        <li><b>Booleans:</b></li>
<pre><code class="language-scheme line-numbers">#t          ; True
#f          ; False

; Everything except #f is considered true
(if 0 'yes 'no)        ; Returns: yes
(if "" 'yes 'no)       ; Returns: yes
(if '() 'yes 'no)      ; Returns: yes
(if #f 'yes 'no)       ; Returns: no</code></pre>
        <br/>
        <li><b>Strings:</b></li>
<pre><code class="language-scheme line-numbers">"Hello, World!"
"Multiple\nlines"
"Escape \"quotes\""
""              ; Empty string</code></pre>
        <br/>
        <li><b>Characters:</b></li>
<pre><code class="language-scheme line-numbers">#\a             ; Letter 'a'
#\Z             ; Letter 'Z'
#\0             ; Digit '0'
#\space         ; Space character
#\newline       ; Newline character
#\tab           ; Tab character</code></pre>
        <br/>
        <li><b>Symbols:</b></li>
<pre><code class="language-scheme line-numbers">'foo            ; Symbol foo
'hello-world    ; Symbol hello-world
'+              ; Symbol +
'lambda         ; Symbol lambda

; Symbols are like unique identifiers/names</code></pre>
    </ul>
    <br/><br/>


    <li>Variables and Definitions</li>
    <br/>
    <ul>
        <li><b>define:</b> Create global variables and functions.</li>
        <br/>
        <li><b>Syntax for variables:</b></li>
<pre><code class="language-scheme line-numbers">(define variable-name value)</code></pre>
        <br/>
        <li><b>Examples:</b></li>
<pre><code class="language-scheme line-numbers">; Define a number
(define x 10)
x                   ; Returns: 10

; Define a string
(define message "Hello")
message             ; Returns: "Hello"

; Define using an expression
(define y (* 5 4))
y                   ; Returns: 20

; Redefine (changes value)
(define x 100)
x                   ; Returns: 100</code></pre>
        <br/>
        <li><b>Syntax for functions:</b></li>
<pre><code class="language-scheme line-numbers">(define (function-name parameter1 parameter2 ...)
  body-expression)</code></pre>
        <br/>
        <li><b>Function examples:</b></li>
<pre><code class="language-scheme line-numbers">; Simple function
(define (square x)
  (* x x))

(square 5)          ; Returns: 25

; Multiple parameters
(define (add a b)
  (+ a b))

(add 3 7)           ; Returns: 10

; Multiple expressions (returns last one)
(define (greet name)
  (display "Processing...")
  (newline)
  (string-append "Hello, " name "!"))

(greet "Alice")     ; Prints "Processing..." then returns "Hello, Alice!"</code></pre>
    </ul>
    <br/><br/>


    <li>Arithmetic Operations</li>
    <br/>
    <ul>
        <li>All arithmetic uses prefix notation.</li>
<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Syntax</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Addition</td>
            <td><code>(+ n1 n2 ...)</code></td>
            <td><code>(+ 1 2 3)</code></td>
            <td>6</td>
        </tr>
        <tr>
            <td>Subtraction</td>
            <td><code>(- n1 n2 ...)</code></td>
            <td><code>(- 10 3)</code></td>
            <td>7</td>
        </tr>
        <tr>
            <td>Multiplication</td>
            <td><code>(* n1 n2 ...)</code></td>
            <td><code>(* 2 3 4)</code></td>
            <td>24</td>
        </tr>
        <tr>
            <td>Division</td>
            <td><code>(/ n1 n2 ...)</code></td>
            <td><code>(/ 10 2)</code></td>
            <td>5</td>
        </tr>
        <tr>
            <td>Quotient</td>
            <td><code>(quotient n1 n2)</code></td>
            <td><code>(quotient 10 3)</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td>Remainder</td>
            <td><code>(remainder n1 n2)</code></td>
            <td><code>(remainder 10 3)</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td>Modulo</td>
            <td><code>(modulo n1 n2)</code></td>
            <td><code>(modulo 10 3)</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td>Exponentiation</td>
            <td><code>(expt base exp)</code></td>
            <td><code>(expt 2 8)</code></td>
            <td>256</td>
        </tr>
        <tr>
            <td>Square root</td>
            <td><code>(sqrt n)</code></td>
            <td><code>(sqrt 16)</code></td>
            <td>4</td>
        </tr>
        <tr>
            <td>Absolute value</td>
            <td><code>(abs n)</code></td>
            <td><code>(abs -5)</code></td>
            <td>5</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Multiple arguments:</b></li>
<pre><code class="language-scheme line-numbers">(+ 1 2 3 4 5)       ; Returns: 15
(* 2 3 4)           ; Returns: 24

; With single argument
(+ 5)               ; Returns: 5
(- 10)              ; Returns: -10 (negation)

; No arguments
(+)                 ; Returns: 0
(*)                 ; Returns: 1</code></pre>
        <br/>
        <li><b>Nested operations:</b></li>
<pre><code class="language-scheme line-numbers">; Traditional: (2 + 3) * 4
(* (+ 2 3) 4)       ; Returns: 20

; Traditional: 2 + 3 * 4
(+ 2 (* 3 4))       ; Returns: 14

; Traditional: (10 - 2) / (3 + 1)
(/ (- 10 2) (+ 3 1))  ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Comparison and Logical Operations</li>
    <br/>
    <ul>
        <li><b>Comparison operators:</b></li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>=</code></td>
            <td>Numeric equality</td>
            <td><code>(= 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&lt;</code></td>
            <td>Less than</td>
            <td><code>(&lt; 3 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&gt;</code></td>
            <td>Greater than</td>
            <td><code>(&gt; 5 3)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&lt;=</code></td>
            <td>Less than or equal</td>
            <td><code>(&lt;= 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>&gt;=</code></td>
            <td>Greater than or equal</td>
            <td><code>(&gt;= 5 3)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>eq?</code></td>
            <td>Same object</td>
            <td><code>(eq? 'a 'a)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>eqv?</code></td>
            <td>Equivalent value</td>
            <td><code>(eqv? 5 5)</code></td>
            <td><code>#t</code></td>
        </tr>
        <tr>
            <td><code>equal?</code></td>
            <td>Structurally equal</td>
            <td><code>(equal? '(1 2) '(1 2))</code></td>
            <td><code>#t</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Comparison examples:</b></li>
<pre><code class="language-scheme line-numbers">; Numeric comparisons
(= 5 5)             ; #t
(= 5 6)             ; #f
(&lt; 3 5)             ; #t
(&gt; 5 3)             ; #t

; Multiple arguments (chain)
(&lt; 1 2 3 4)         ; #t (all comparisons true)
(&lt; 1 3 2 4)         ; #f (3 is not &lt; 2)

; String comparison
(string=? "hello" "hello")    ; #t
(string&lt;? "abc" "xyz")        ; #t
</code></pre>
        <br/>
        <li><b>Logical operators:</b></li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>and</code></td>
            <td>Logical AND</td>
            <td><code>(and #t #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>or</code></td>
            <td>Logical OR</td>
            <td><code>(or #f #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>not</code></td>
            <td>Logical NOT</td>
            <td><code>(not #t)</code> → #f</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Logical examples:</b></li>
<pre><code class="language-scheme line-numbers">; AND - returns #f if any argument is #f
(and #t #t #t)      ; #t
(and #t #f #t)      ; #f

; OR - returns #t if any argument is true
(or #f #f #t)       ; #t
(or #f #f #f)       ; #f

; NOT
(not #t)            ; #f
(not #f)            ; #t

; Short-circuit evaluation
(and #f (display "This won't print"))  ; #f (doesn't evaluate second)
(or #t (display "This won't print"))   ; #t (doesn't evaluate second)</code></pre>
    </ul>
    <br/><br/>


    <li>Conditional Expressions</li>
    <br/>
    <ul>
        <li><b>if expression syntax:</b></li>
<pre><code class="language-scheme line-numbers">(if condition
    then-expression
    else-expression)</code></pre>
        <br/>
        <li><b>if examples:</b></li>
<pre><code class="language-scheme line-numbers">; Basic if
(if (> 5 3)
    "yes"
    "no")           ; Returns: "yes"

; If with computation
(if (= (* 2 3) 6)
    (+ 10 5)
    (- 10 5))       ; Returns: 15

; Nested if
(define (sign x)
  (if (< x 0)
      "negative"
      (if (= x 0)
          "zero"
          "positive")))

(sign -5)           ; Returns: "negative"
(sign 0)            ; Returns: "zero"
(sign 5)            ; Returns: "positive"</code></pre>
        <br/>
        <li><b>cond expression (multi-way conditional):</b></li>
<pre><code class="language-scheme line-numbers">(cond
  (condition1 result1)
  (condition2 result2)
  (condition3 result3)
  ...
  (else default-result))</code></pre>
        <br/>
        <li><b>cond examples:</b></li>
<pre><code class="language-scheme line-numbers">; Multiple conditions
(define (grade score)
  (cond
    ((>= score 90) "A")
    ((>= score 80) "B")
    ((>= score 70) "C")
    ((>= score 60) "D")
    (else "F")))

(grade 85)          ; Returns: "B"
(grade 55)          ; Returns: "F"

; Without else
(cond
  ((< 5 3) "impossible")
  ((> 5 3) "correct"))  ; Returns: "correct"</code></pre>
        <br/>
        <li><b>case expression (switch-like):</b></li>
<pre><code class="language-scheme line-numbers">(case key-expression
  ((value1 value2 ...) result1)
  ((value3 value4 ...) result2)
  ...
  (else default-result))</code></pre>
        <br/>
        <li><b>case examples:</b></li>
<pre><code class="language-scheme line-numbers">(define (day-name n)
  (case n
    ((1) "Monday")
    ((2) "Tuesday")
    ((3) "Wednesday")
    ((4) "Thursday")
    ((5) "Friday")
    ((6 7) "Weekend")
    (else "Invalid day")))

(day-name 1)        ; Returns: "Monday"
(day-name 6)        ; Returns: "Weekend"</code></pre>
    </ul>
    <br/><br/>


    <li>Lists and Pairs</li>
    <br/>
    <ul>
        <li>Lists are fundamental to Scheme.</li>
        <br/>
        <li><b>Creating lists:</b></li>
<pre><code class="language-scheme line-numbers">; Quoted list (doesn't evaluate)
'(1 2 3 4)

; Using list function
(list 1 2 3 4)

; Empty list
'()
(list)

; Mixed types
'(1 "hello" x #t)
(list 1 "hello" 'x #t)</code></pre>
        <br/>
        <li><b>Difference between quote and list:</b></li>
<pre><code class="language-scheme line-numbers">; With quote - literal
'(+ 1 2)            ; Returns: (+ 1 2) - just a list of symbols
'((+ 1 2) 3)        ; Returns: ((+ 1 2) 3)

; With list - evaluates arguments
(list + 1 2)        ; Returns: (#&lt;procedure:+&gt; 1 2)
(list (+ 1 2) 3)    ; Returns: (3 3)</code></pre>
        <br/>
        <li><b>Accessing list elements:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>car</code></td>
            <td>First element</td>
            <td><code>(car '(1 2 3))</code></td>
            <td>1</td>
        </tr>
        <tr>
            <td><code>cdr</code></td>
            <td>Rest of list</td>
            <td><code>(cdr '(1 2 3))</code></td>
            <td>(2 3)</td>
        </tr>
        <tr>
            <td><code>cadr</code></td>
            <td>Second element</td>
            <td><code>(cadr '(1 2 3))</code></td>
            <td>2</td>
        </tr>
        <tr>
            <td><code>caddr</code></td>
            <td>Third element</td>
            <td><code>(caddr '(1 2 3))</code></td>
            <td>3</td>
        </tr>
        <tr>
            <td><code>list-ref</code></td>
            <td>Element at index (0-based)</td>
            <td><code>(list-ref '(a b c) 1)</code></td>
            <td>b</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>List manipulation:</b></li>
<pre><code class="language-scheme line-numbers">; cons - add element to front
(cons 1 '(2 3))             ; Returns: (1 2 3)
(cons 'a '())               ; Returns: (a)

; append - combine lists
(append '(1 2) '(3 4))      ; Returns: (1 2 3 4)
(append '(a) '(b) '(c))     ; Returns: (a b c)

; length
(length '(1 2 3 4))         ; Returns: 4
(length '())                ; Returns: 0

; reverse
(reverse '(1 2 3))          ; Returns: (3 2 1)

; member - find element
(member 3 '(1 2 3 4))       ; Returns: (3 4)
(member 'x '(a b c))        ; Returns: #f</code></pre>
        <br/>
        <li><b>Pairs (dotted pairs):</b></li>
<pre><code class="language-scheme line-numbers">; Create pair with cons
(cons 1 2)              ; Returns: (1 . 2)

; Lists are chains of pairs ending in '()
(cons 1 (cons 2 (cons 3 '())))  ; Returns: (1 2 3)
; Same as '(1 2 3)

; Access pair elements
(car '(1 . 2))          ; Returns: 1
(cdr '(1 . 2))          ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Lambda Expressions</li>
    <br/>
    <ul>
        <li><b>lambda creates anonymous functions.</b></li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(lambda (parameter1 parameter2 ...)
  body-expression)</code></pre>
        <br/>
        <li><b>Basic examples:</b></li>
<pre><code class="language-scheme line-numbers">; Anonymous function
(lambda (x) (* x x))

; Call immediately
((lambda (x) (* x x)) 5)    ; Returns: 25

; Assign to variable
(define square (lambda (x) (* x x)))
(square 5)                  ; Returns: 25

; Multiple parameters
(define add (lambda (a b) (+ a b)))
(add 3 7)                   ; Returns: 10</code></pre>
        <br/>
        <li><b>Note: These are equivalent:</b></li>
<pre><code class="language-scheme line-numbers">; Using lambda explicitly
(define square (lambda (x) (* x x)))

; Shorthand (what we've been using)
(define (square x) (* x x))

; Both create the same function</code></pre>
        <br/>
        <li><b>Variable number of arguments:</b></li>
<pre><code class="language-scheme line-numbers">; Rest parameters
(define (sum . numbers)
  (if (null? numbers)
      0
      (+ (car numbers) (apply sum (cdr numbers)))))

(sum 1 2 3 4 5)     ; Returns: 15

; Mix fixed and rest parameters
(define (greet name . titles)
  (string-append name " " (apply string-append titles)))

(greet "John" "Dr. " "PhD")  ; Returns: "John Dr. PhD"</code></pre>
        <br/>
        <li><b>Higher-order functions:</b></li>
<pre><code class="language-scheme line-numbers">; Function that returns a function
(define (make-adder n)
  (lambda (x) (+ x n)))

(define add5 (make-adder 5))
(add5 10)           ; Returns: 15
(add5 3)            ; Returns: 8

; Function that takes a function
(define (apply-twice f x)
  (f (f x)))

(apply-twice (lambda (x) (* x 2)) 3)  ; Returns: 12
; First: (* 3 2) = 6
; Second: (* 6 2) = 12</code></pre>
    </ul>
    <br/><br/>


    <li>Local Bindings: let, let*, and letrec</li>
    <br/>
    <ul>
        <li><b>let:</b> Create local variables (parallel binding).</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(let ((var1 value1)
      (var2 value2)
      ...)
  body-expression)</code></pre>
        <br/>
        <li><b>let examples:</b></li>
<pre><code class="language-scheme line-numbers">; Simple let
(let ((x 5)
      (y 10))
  (+ x y))          ; Returns: 15

; Variables are parallel (can't reference each other)
(let ((x 5)
      (y x))        ; Error! x not yet defined
  (+ x y))

; Correct way
(let ((x 5))
  (let ((y x))
    (+ x y)))       ; Returns: 10</code></pre>
        <br/>
        <li><b>let*:</b> Create local variables (sequential binding).</li>
<pre><code class="language-scheme line-numbers">(let* ((var1 value1)
       (var2 value2)  ; Can use var1 here
       ...)
  body-expression)</code></pre>
        <br/>
        <li><b>let* examples:</b></li>
<pre><code class="language-scheme line-numbers">; Sequential binding
(let* ((x 5)
       (y (* x 2)))     ; Can use x
  (+ x y))              ; Returns: 15

; Each binding can use previous ones
(let* ((a 1)
       (b (+ a 1))      ; Uses a
       (c (+ a b)))     ; Uses a and b
  c)                    ; Returns: 3</code></pre>
        <br/>
        <li><b>letrec:</b> Create local recursive functions.</li>
<pre><code class="language-scheme line-numbers">(letrec ((var1 value1)
         (var2 value2)
         ...)
  body-expression)</code></pre>
        <br/>
        <li><b>letrec examples:</b></li>
<pre><code class="language-scheme line-numbers">; Recursive function
(letrec ((factorial
          (lambda (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))))
  (factorial 5))    ; Returns: 120

; Mutually recursive functions
(letrec ((even?
          (lambda (n)
            (if (= n 0)
                #t
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (= n 0)
                #f
                (even? (- n 1))))))
  (even? 10))       ; Returns: #t</code></pre>
    </ul>
    <br/><br/>


    <li>Recursion</li>
    <br/>
    <ul>
        <li>Recursion is the primary iteration mechanism in Scheme.</li>
        <br/>
        <li><b>Basic recursive pattern:</b></li>
<pre><code class="language-scheme line-numbers">(define (function-name param)
  (if base-case
      base-result
      (recursive-call)))</code></pre>
        <br/>
        <li><b>Factorial example:</b></li>
<pre><code class="language-scheme line-numbers">(define (factorial n)
  (if (<= n 1)
      1                         ; Base case
      (* n (factorial (- n 1)))))  ; Recursive case

(factorial 5)       ; Returns: 120
; 5 * 4 * 3 * 2 * 1 = 120</code></pre>
        <br/>
        <li><b>List recursion:</b></li>
<pre><code class="language-scheme line-numbers">; Sum all numbers in list
(define (sum-list lst)
  (if (null? lst)
      0                         ; Base: empty list
      (+ (car lst)              ; Add first element
         (sum-list (cdr lst))))) ; Recursively sum rest

(sum-list '(1 2 3 4))   ; Returns: 10

; Length of list
(define (my-length lst)
  (if (null? lst)
      0
      (+ 1 (my-length (cdr lst)))))

(my-length '(a b c d))  ; Returns: 4</code></pre>
        <br/>
        <li><b>Tail recursion (more efficient):</b></li>
<pre><code class="language-scheme line-numbers">; Tail-recursive factorial
(define (factorial n)
  (define (fact-iter n acc)
    (if (<= n 1)
        acc
        (fact-iter (- n 1) (* n acc))))
  (fact-iter n 1))

; Tail-recursive sum
(define (sum-list lst)
  (define (sum-iter lst acc)
    (if (null? lst)
        acc
        (sum-iter (cdr lst) (+ acc (car lst)))))
  (sum-iter lst 0))

(sum-list '(1 2 3 4))   ; Returns: 10</code></pre>
    </ul>
    <br/><br/>


    <li>Common List Operations</li>
    <br/>
    <ul>
        <li><b>map:</b> Apply function to each element.</li>
<pre><code class="language-scheme line-numbers">; Syntax: (map function list)

(map (lambda (x) (* x 2)) '(1 2 3))
; Returns: (2 4 6)

(map car '((a b) (c d) (e f)))
; Returns: (a c e)

; Multiple lists
(map + '(1 2 3) '(10 20 30))
; Returns: (11 22 33)</code></pre>
        <br/>
        <li><b>filter:</b> Keep elements that satisfy predicate.</li>
<pre><code class="language-scheme line-numbers">; Keep only even numbers
(filter even? '(1 2 3 4 5 6))
; Returns: (2 4 6)

; Keep numbers > 5
(filter (lambda (x) (> x 5)) '(1 8 3 9 2 7))
; Returns: (8 9 7)</code></pre>
        <br/>
        <li><b>fold (reduce):</b> Combine elements.</li>
<pre><code class="language-scheme line-numbers">; foldl - fold from left
(foldl + 0 '(1 2 3 4))
; Returns: 10
; ((((0 + 1) + 2) + 3) + 4)

; foldr - fold from right
(foldr cons '() '(1 2 3))
; Returns: (1 2 3)

; foldl vs foldr
(foldl - 0 '(1 2 3))    ; (((0 - 1) - 2) - 3) = -6
(foldr - 0 '(1 2 3))    ; (1 - (2 - (3 - 0))) = 2</code></pre>
        <br/>
        <li><b>apply:</b> Apply function to list as arguments.</li>
<pre><code class="language-scheme line-numbers">(apply + '(1 2 3 4))
; Same as: (+ 1 2 3 4)
; Returns: 10

(apply max '(3 7 2 9 1))
; Same as: (max 3 7 2 9 1)
; Returns: 9</code></pre>
    </ul>
    <br/><br/>


    <li>String Operations</li>
    <br/>
    <ul>
        <li><b>Common string functions:</b></li>
<table>
    <thead>
        <tr>
            <th>Function</th>
            <th>Description</th>
            <th>Example</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>string-length</code></td>
            <td>Get length</td>
            <td><code>(string-length "hello")</code></td>
            <td>5</td>
        </tr>
        <tr>
            <td><code>string-append</code></td>
            <td>Concatenate</td>
            <td><code>(string-append "hi" " " "there")</code></td>
            <td>"hi there"</td>
        </tr>
        <tr>
            <td><code>string-ref</code></td>
            <td>Get character</td>
            <td><code>(string-ref "hello" 1)</code></td>
            <td>#\e</td>
        </tr>
        <tr>
            <td><code>substring</code></td>
            <td>Extract portion</td>
            <td><code>(substring "hello" 1 4)</code></td>
            <td>"ell"</td>
        </tr>
        <tr>
            <td><code>string-upcase</code></td>
            <td>Uppercase</td>
            <td><code>(string-upcase "hello")</code></td>
            <td>"HELLO"</td>
        </tr>
        <tr>
            <td><code>string-downcase</code></td>
            <td>Lowercase</td>
            <td><code>(string-downcase "HELLO")</code></td>
            <td>"hello"</td>
        </tr>
        <tr>
            <td><code>string->list</code></td>
            <td>Convert to list</td>
            <td><code>(string->list "abc")</code></td>
            <td>(#\a #\b #\c)</td>
        </tr>
        <tr>
            <td><code>list->string</code></td>
            <td>Convert from list</td>
            <td><code>(list->string '(#\a #\b))</code></td>
            <td>"ab"</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Examples:</b></li>
<pre><code class="language-scheme line-numbers">; Concatenation
(string-append "Hello" ", " "World" "!")
; Returns: "Hello, World!"

; Substring
(substring "Hello, World!" 0 5)
; Returns: "Hello"

; Character access
(string-ref "Scheme" 0)     ; Returns: #\S

; String manipulation
(string-upcase "hello")     ; Returns: "HELLO"
(string-downcase "WORLD")   ; Returns: "world"</code></pre>
    </ul>
    <br/><br/>


    <li>Input and Output</li>
    <br/>
    <ul>
        <li><b>Display output:</b></li>
<pre><code class="language-scheme line-numbers">; display - print without quotes
(display "Hello, World!")   ; Prints: Hello, World!

; newline - print newline
(newline)

; write - print with quotes
(write "Hello")             ; Prints: "Hello"

; print multiple things
(display "x = ")
(display 42)
(newline)
; Prints: x = 42</code></pre>
        <br/>
        <li><b>Read input:</b></li>
<pre><code class="language-scheme line-numbers">; read - read S-expression
(define input (read))
; User types: (1 2 3)
; input is: '(1 2 3)

; read-line - read line as string
(define line (read-line))
; User types: Hello World
; line is: "Hello World"</code></pre>
        <br/>
        <li><b>File I/O:</b></li>
<pre><code class="language-scheme line-numbers">; Open file for reading
(define in (open-input-file "input.txt"))

; Read from file
(read in)
(read-line in)

; Close file
(close-input-port in)

; Open file for writing
(define out (open-output-file "output.txt"))

; Write to file
(write '(1 2 3) out)
(display "Hello" out)

; Close file
(close-output-port out)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Predicates</li>
    <br/>
    <ul>
        <li>Predicates are functions that return boolean values.</li>
<table>
    <thead>
        <tr>
            <th>Predicate</th>
            <th>Tests for</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>null?</code></td>
            <td>Empty list</td>
            <td><code>(null? '())</code> → #t</td>
        </tr>
        <tr>
            <td><code>pair?</code></td>
            <td>Pair/cons cell</td>
            <td><code>(pair? '(1 2))</code> → #t</td>
        </tr>
        <tr>
            <td><code>list?</code></td>
            <td>Proper list</td>
            <td><code>(list? '(1 2))</code> → #t</td>
        </tr>
        <tr>
            <td><code>number?</code></td>
            <td>Number</td>
            <td><code>(number? 42)</code> → #t</td>
        </tr>
        <tr>
            <td><code>integer?</code></td>
            <td>Integer</td>
            <td><code>(integer? 5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>real?</code></td>
            <td>Real number</td>
            <td><code>(real? 3.14)</code> → #t</td>
        </tr>
        <tr>
            <td><code>string?</code></td>
            <td>String</td>
            <td><code>(string? "hi")</code> → #t</td>
        </tr>
        <tr>
            <td><code>char?</code></td>
            <td>Character</td>
            <td><code>(char? #\a)</code> → #t</td>
        </tr>
        <tr>
            <td><code>symbol?</code></td>
            <td>Symbol</td>
            <td><code>(symbol? 'x)</code> → #t</td>
        </tr>
        <tr>
            <td><code>boolean?</code></td>
            <td>Boolean</td>
            <td><code>(boolean? #t)</code> → #t</td>
        </tr>
        <tr>
            <td><code>procedure?</code></td>
            <td>Function</td>
            <td><code>(procedure? +)</code> → #t</td>
        </tr>
        <tr>
            <td><code>zero?</code></td>
            <td>Zero</td>
            <td><code>(zero? 0)</code> → #t</td>
        </tr>
        <tr>
            <td><code>positive?</code></td>
            <td>Positive number</td>
            <td><code>(positive? 5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>negative?</code></td>
            <td>Negative number</td>
            <td><code>(negative? -5)</code> → #t</td>
        </tr>
        <tr>
            <td><code>even?</code></td>
            <td>Even number</td>
            <td><code>(even? 4)</code> → #t</td>
        </tr>
        <tr>
            <td><code>odd?</code></td>
            <td>Odd number</td>
            <td><code>(odd? 3)</code> → #t</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Quick Reference Summary</li>
    <br/>
    <ul>
        <li><b>Basic syntax patterns:</b></li>
<pre><code class="language-scheme line-numbers">; Define variable
(define name value)

; Define function
(define (name params...) body)

; Lambda
(lambda (params...) body)

; Conditional
(if test then else)
(cond (test1 result1) (test2 result2) ... (else default))

; Local binding
(let ((var val) ...) body)
(let* ((var val) ...) body)
(letrec ((var val) ...) body)

; List operations
(car list)          ; First element
(cdr list)          ; Rest
(cons item list)    ; Add to front
(append list1 list2) ; Combine

; Higher-order
(map function list)
(filter predicate list)
(apply function list)</code></pre>
    </ul>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-multiple-expressions">Multiple Expressions in Conditionals</h3>
<ol>

    <li>The Problem with if</li>
    <br/>
    <ul>
        <li><b>if only accepts single expressions</b> for then and else branches.</li>
        <br/>
        <li><b>This doesn't work:</b></li>
<pre><code class="language-scheme line-numbers">; ✗ Error - trying multiple expressions
(if (> x 0)
    (display "Positive")
    (newline)           ; Error! if expects only one expression
    (display "Negative"))
</code></pre>
        <br/>
        <li>You need a way to <b>group multiple expressions into one</b>.</li>
    </ul>
    <br/><br/>


    <li>Solution: Using begin</li>
    <br/>
    <ul>
        <li><b>begin:</b> Groups multiple expressions into a single expression.</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(begin
  expression1
  expression2
  expression3
  ...
  final-expression)</code></pre>
        <br/>
        <li><b>What begin does:</b></li>
        <ul>
            <li>Evaluates all expressions in sequence (top to bottom)</li>
            <li>Returns the value of the <b>last expression only</b></li>
            <li>Side effects (like display, file I/O) from all expressions occur</li>
        </ul>
        <br/>
        <li><b>Basic begin example:</b></li>
<pre><code class="language-scheme line-numbers">(begin
  (display "First")
  (newline)
  (display "Second")
  (newline)
  42)               ; This value is returned

; Prints:
; First
; Second
; Returns: 42</code></pre>
    </ul>
    <br/><br/>


    <li>Using begin with if</li>
    <br/>
    <ul>
        <li><b>Pattern for multiple expressions in then branch:</b></li>
<pre><code class="language-scheme line-numbers">(if condition
    (begin
      expression1
      expression2
      ...)
    else-expression)</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-scheme line-numbers">(define x 10)

(if (&gt; x 0)
    (begin
      (display "x is positive")
      (newline)
      (display "x = ")
      (display x)
      #t)           ; Return value
    #f)

; Prints:
; x is positive
; x = 10
; Returns: #t</code></pre>
        <br/>
        <li><b>Multiple expressions in else branch:</b></li>
<pre><code class="language-scheme line-numbers">(if (> x 0)
    (display "Positive")
    (begin
      (display "Not positive")
      (newline)
      (display "Please enter a positive number")
      #f))</code></pre>
        <br/>
        <li><b>Multiple expressions in both branches:</b></li>
<pre><code class="language-scheme line-numbers">(if (> x 0)
    (begin
      (display "Positive: ")
      (display x)
      'positive)
    (begin
      (display "Not positive: ")
      (display x)
      'not-positive))</code></pre>
        <br/>
        <li><b>Real-world example - login check:</b></li>
<pre><code class="language-scheme line-numbers">(define (login username password)
  (if (and (string=? username "admin")
           (string=? password "secret"))
      (begin
        (display "Login successful!")
        (newline)
        (display "Welcome, ")
        (display username)
        (newline)
        #t)         ; Return success
      (begin
        (display "Login failed!")
        (newline)
        (display "Invalid credentials")
        (newline)
        #f)))       ; Return failure

(login "admin" "secret")
; Prints:
; Login successful!
; Welcome, admin
; Returns: #t
</code></pre>
    </ul>
    <br/><br/>


    <li>Alternative: when and unless</li>
    <br/>
    <ul>
        <li>Chez Scheme provides <code>when</code> and <code>unless</code> for common cases.</li>
        <br/>
        <li><b>when:</b> Execute multiple expressions if condition is true.</li>
<pre><code class="language-scheme line-numbers">; Syntax
(when condition
  expression1
  expression2
  ...)

; Equivalent to:
(if condition
    (begin expression1 expression2 ...)
    (void))     ; or returns unspecified value</code></pre>
        <br/>
        <li><b>when example:</b></li>
<pre><code class="language-scheme line-numbers">(define x 10)

(when (&gt; x 0)
  (display "x is positive")
  (newline)
  (display "x = ")
  (display x))

; No else branch needed
; If condition is false, does nothing</code></pre>
        <br/>
        <li><b>unless:</b> Execute multiple expressions if condition is false.</li>
<pre><code class="language-scheme line-numbers">; Syntax
(unless condition
  expression1
  expression2
  ...)

; Equivalent to:
(if (not condition)
    (begin expression1 expression2 ...)
    (void))</code></pre>
        <br/>
        <li><b>unless example:</b></li>
<pre><code class="language-scheme line-numbers">(define balance 50)

(unless (&gt;= balance 100)
  (display "Warning: Low balance")
  (newline)
  (display "Current balance: ")
  (display balance))

; Executes when balance < 100</code></pre>
        <br/>
        <li><b>Comparison:</b></li>
<table>
    <thead>
        <tr>
            <th>Form</th>
            <th>When to Use</th>
            <th>Has else?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>if</code> + <code>begin</code></td>
            <td>Need both then and else branches</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td><code>when</code></td>
            <td>Only execute if true, no else needed</td>
            <td>No</td>
        </tr>
        <tr>
            <td><code>unless</code></td>
            <td>Only execute if false, no else needed</td>
            <td>No</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Using cond for Multiple Expressions</li>
    <br/>
    <ul>
        <li><code>cond</code> clauses can have multiple expressions without <code>begin</code>.</li>
        <br/>
        <li><b>Syntax:</b></li>
<pre><code class="language-scheme line-numbers">(cond
  (condition1
    expression1
    expression2
    ...)
  (condition2
    expression1
    expression2
    ...)
  (else
    expression1
    expression2
    ...))</code></pre>
        <br/>
        <li><b>Example:</b></li>
<pre><code class="language-scheme line-numbers">(define (grade-message score)
  (cond
    ((&gt;= score 90)
     (display "Excellent!")
     (newline)
     (display "Grade: A")
     'A)
    ((&gt;= score 80)
     (display "Good job!")
     (newline)
     (display "Grade: B")
     'B)
    ((&gt;= score 70)
     (display "Passing")
     (newline)
     (display "Grade: C")
     'C)
    (else
     (display "Failed")
     (newline)
     (display "Grade: F")
     'F)))

(grade-message 85)
; Prints:
; Good job!
; Grade: B
; Returns: B</code></pre>
        <br/>
        <li><b>Note:</b> Each clause can have multiple expressions, and the value of the last expression is returned if that clause matches.</li>
        <br/>
        <li><b>Comparison with if + begin:</b></li>
<pre><code class="language-scheme line-numbers">; Using if + begin (verbose)
(if (&gt;= score 90)
    (begin
      (display "Excellent!")
      'A)
    (if (&gt;= score 80)
        (begin
          (display "Good!")
          'B)
        ...))

; Using cond (cleaner)
(cond
  ((&gt;= score 90)
   (display "Excellent!")
   'A)
  ((&gt;= score 80)
   (display "Good!")
   'B)
  ...)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Patterns and Examples</li>
    <br/>
    <ul>
        <li><b>Pattern 1: Validation with multiple actions</b></li>
<pre><code class="language-scheme line-numbers">(define (validate-age age)
  (if (and (&gt;= age 0) (<= age 150))
      (begin
        (display "Age is valid")
        (newline)
        #t)
      (begin
        (display "Error: Invalid age")
        (newline)
        (display "Age must be between 0 and 150")
        (newline)
        #f)))
</code></pre>
        <br/>
        <li><b>Pattern 2: Side effects only when condition is true</b></li>
<pre><code class="language-scheme line-numbers">; Using when
(when (file-exists? "config.txt")
  (display "Loading config...")
  (newline)
  (load-config)
  (display "Config loaded"))

; Without when (more verbose)
(if (file-exists? "config.txt")
    (begin
      (display "Loading config...")
      (newline)
      (load-config)
      (display "Config loaded"))
    (void))</code></pre>
        <br/>
        <li><b>Pattern 3: Guard clauses</b></li>
<pre><code class="language-scheme line-numbers">(define (process-data data)
  ; Early return with multiple expressions
  (unless (valid-data? data)
    (display "Error: Invalid data")
    (newline)
    (return-error))

  ; Continue processing if valid
  (display "Processing...")
  (transform-data data))</code></pre>
        <br/>
        <li><b>Pattern 4: Logging with computation</b></li>
<pre><code class="language-scheme line-numbers">(define (calculate x y)
  (if (= y 0)
      (begin
        (display "Error: Division by zero")
        (newline)
        (display "Returning default value")
        (newline)
        0)
      (begin
        (display "Calculating: ")
        (display x)
        (display " / ")
        (display y)
        (newline)
        (/ x y))))</code></pre>
    </ul>
    <br/><br/>


    <li>When begin is NOT Needed</li>
    <br/>
    <ul>
        <li>Some forms already allow multiple expressions implicitly.</li>
        <br/>
        <li><b>Function bodies (define):</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in function body
(define (greet name)
  (display "Hello, ")
  (display name)
  (display "!")
  (newline)
  'done)            ; Returns 'done

; All expressions execute in sequence
; Last one is the return value</code></pre>
        <br/>
        <li><b>let, let*, letrec bodies:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in let body
(let ((x 10)
      (y 20))
  (display "Computing sum")
  (newline)
  (+ x y))          ; Returns 30</code></pre>
        <br/>
        <li><b>lambda bodies:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in lambda body
(lambda (x)
  (display "Processing: ")
  (display x)
  (newline)
  (* x x))          ; Returns x squared</code></pre>
        <br/>
        <li><b>cond clauses:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in cond clauses
(cond
  ((> x 0)
   (display "Positive")
   (newline)
   'pos)
  (else
   (display "Not positive")
   'not-pos))</code></pre>
        <br/>
        <li><b>case clauses:</b></li>
<pre><code class="language-scheme line-numbers">; begin NOT needed in case clauses
(case n
  ((1)
   (display "One")
   1)
  ((2)
   (display "Two")
   2))</code></pre>
    </ul>
    <br/><br/>


    <li>Summary: When to Use What</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Situation</th>
            <th>Use</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Multiple expressions in if then/else</td>
            <td><code>begin</code></td>
            <td><code>(if test (begin e1 e2) e3)</code></td>
        </tr>
        <tr>
            <td>Only execute if true, no else</td>
            <td><code>when</code></td>
            <td><code>(when test e1 e2)</code></td>
        </tr>
        <tr>
            <td>Only execute if false, no else</td>
            <td><code>unless</code></td>
            <td><code>(unless test e1 e2)</code></td>
        </tr>
        <tr>
            <td>Multi-way with multiple expressions</td>
            <td><code>cond</code></td>
            <td><code>(cond (t1 e1 e2) (t2 e3 e4))</code></td>
        </tr>
        <tr>
            <td>In function/lambda/let body</td>
            <td>Nothing (implicit)</td>
            <td><code>(define (f) e1 e2)</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <ul>
        <li><b>Quick reference:</b></li>
    </ul>
<pre><code class="language-scheme line-numbers">; if with multiple expressions
(if test
    (begin e1 e2 e3)
    (begin e4 e5 e6))

; when (cleaner for one-sided if)
(when test
  e1
  e2
  e3)

; unless (cleaner for negative one-sided if)
(unless test
  e1
  e2
  e3)

; cond (no begin needed)
(cond
  (test1 e1 e2 e3)
  (test2 e4 e5 e6)
  (else e7 e8 e9))

; Function body (no begin needed)
(define (func)
  e1
  e2
  e3)</code></pre>
    <br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="scm-naming-conventions">Chez Scheme Naming Conventions</h3>
<ol>

    <li>Understanding Scheme Identifiers</li>
    <br/>
    <ul>
        <li>Scheme has flexible rules for naming variables and functions.</li>
        <br/>
        <li><b>Core principle:</b> Names should be descriptive and follow consistent patterns.</li>
        <br/>
        <li><b>Valid characters in identifiers:</b></li>
        <ul>
            <li>Letters: <code>a-z</code>, <code>A-Z</code></li>
            <li>Digits: <code>0-9</code> (not at the start)</li>
            <li>Special characters: <code>!</code> <code>$</code> <code>%</code> <code>&</code> <code>*</code> <code>+</code> <code>-</code> <code>.</code> <code>/</code> <code>:</code> <code>&lt;</code> <code>=</code> <code>&gt;</code> <code>?</code> <code>@</code> <code>^</code> <code>_</code> <code>~</code></li>
        </ul>
        <br/>
        <li><b>Examples of valid identifiers:</b></li>
<pre><code class="language-scheme line-numbers">; All valid
x
my-variable
list->vector
string-ref
empty?
set!
<=
+
make-counter
file-exists?
*global-config*</code></pre>
        <br/>
        <li><b>Examples of invalid identifiers:</b></li>
<pre><code class="language-scheme line-numbers">; Invalid - starts with digit
123abc

; Invalid - contains space
my variable

; Invalid - contains special chars not allowed
my#var
item[0]
value{x}</code></pre>
    </ul>
    <br/><br/>


    <li>Predicate Naming Convention</li>
    <br/>
    <ul>
        <li>Functions that return boolean values end with <code>?</code></li>
        <br/>
        <li><b>Purpose:</b> Immediately identifies a function as a test or check.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Type predicates
(number? 42)        ; Returns: #t
(string? "hi")      ; Returns: #t
(list? '(1 2 3))    ; Returns: #t
(pair? '(a . b))    ; Returns: #t
(null? '())         ; Returns: #t

; Comparison predicates
(zero? 0)           ; Returns: #t
(positive? 5)       ; Returns: #t
(negative? -3)      ; Returns: #t
(even? 4)           ; Returns: #t
(odd? 7)            ; Returns: #t

; State predicates
(eof-object? x)     ; Checks for EOF
(file-exists? "test.txt")
(char-whitespace? #\space)</code></pre>
        <br/>
        <li><b>Creating your own predicates:</b></li>
<pre><code class="language-scheme line-numbers">(define (adult? age)
  (>= age 18))

(define (valid-email? email)
  (and (string? email)
       (string-contains? email "@")))

(define (empty-list? lst)
  (null? lst))

; Using predicates
(adult? 25)                    ; Returns: #t
(valid-email? "test@test.com") ; Returns: #t
(empty-list? '())              ; Returns: #t</code></pre>
    </ul>
    <br/><br/>


    <li>Mutating Function Convention</li>
    <br/>
    <ul>
        <li>Functions that modify (mutate) their arguments end with <code>!</code></li>
        <br/>
        <li><b>Warning:</b> The <code>!</code> signals side effects - use with caution.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Variable mutation
(define x 10)
(set! x 20)         ; Modifies x
x                   ; Returns: 20

; List mutation
(define lst '(1 2 3))
(set-car! lst 99)   ; Modifies first element
lst                 ; Returns: (99 2 3)

(set-cdr! lst '(8 9))
lst                 ; Returns: (99 8 9)

; Vector mutation
(define vec #(1 2 3))
(vector-set! vec 0 42)  ; Modifies element at index 0
vec                     ; Returns: #(42 2 3)</code></pre>
        <br/>
        <li><b>Creating your own mutators:</b></li>
<pre><code class="language-scheme line-numbers">(define (reset-counter! counter)
  (set-car! counter 0))

(define (increment! counter)
  (set-car! counter (+ (car counter) 1)))

(define (update-status! object new-status)
  (set-car! (cdr object) new-status))

; Usage
(define my-counter (list 0))
(increment! my-counter)
my-counter              ; Returns: (1)</code></pre>
        <br/>
        <li><b>Contrast with non-mutating functions:</b></li>
<pre><code class="language-scheme line-numbers">; Non-mutating - returns new value
(define (increment counter)
  (+ counter 1))

(define x 5)
(increment x)       ; Returns: 6
x                   ; Still: 5

; Mutating - modifies in place
(define (increment! counter-box)
  (set-car! counter-box
            (+ (car counter-box) 1)))

(define y (list 5))
(increment! y)      ; Modifies y
y                   ; Now: (6)</code></pre>
    </ul>
    <br/><br/>


    <li>Type Conversion Convention</li>
    <br/>
    <ul>
        <li>Conversion functions use <code>-&gt;</code> pattern: <code>source-&gt;target</code></li>
        <br/>
        <li><b>Pattern:</b> <code>(type-a-&gt;type-b value)</code> converts from type A to type B.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Number conversions
(string->number "42")       ; Returns: 42
(number->string 123)        ; Returns: "123"
(char->integer #\A)         ; Returns: 65
(integer->char 65)          ; Returns: #\A

; List/vector conversions
(list->vector '(1 2 3))     ; Returns: #(1 2 3)
(vector->list #(a b c))     ; Returns: (a b c)
(list->string '(#\h #\i))   ; Returns: "hi"
(string->list "abc")        ; Returns: (#\a #\b #\c)

; Symbol conversions
(symbol->string 'hello)     ; Returns: "hello"
(string->symbol "world")    ; Returns: world</code></pre>
        <br/>
        <li><b>Creating your own converters:</b></li>
<pre><code class="language-scheme line-numbers">(define (celsius->fahrenheit c)
  (+ (* c 9/5) 32))

(define (fahrenheit->celsius f)
  (* (- f 32) 5/9))

(define (list->set lst)
  ; Convert list to set (remove duplicates)
  (delete-duplicates lst))

(define (record->alist rec)
  ; Convert record to association list
  (map cons (record-field-names rec)
            (record-field-values rec)))

; Usage
(celsius->fahrenheit 100)   ; Returns: 212
(fahrenheit->celsius 32)    ; Returns: 0
(list->set '(1 2 2 3 3 3))  ; Returns: (1 2 3)</code></pre>
    </ul>
    <br/><br/>


    <li>Multi-word Identifier Convention</li>
    <br/>
    <ul>
        <li>Use <code>kebab-case</code> (words separated by hyphens) for multi-word names.</li>
        <br/>
        <li><b>Scheme style:</b> <code>kebab-case</code> is standard, NOT <code>camelCase</code> or <code>snake_case</code></li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Standard functions
string-length
string-append
list-ref
vector-set!
make-vector
call-with-current-continuation
call-with-input-file
read-char
write-char</code></pre>
        <br/>
        <li><b>Creating your own multi-word names:</b></li>
<pre><code class="language-scheme line-numbers">; Variables
(define max-retry-count 5)
(define database-connection-string "localhost:5432")
(define user-input-buffer '())

; Functions
(define (calculate-total-price items tax-rate)
  (* (apply + items) (+ 1 tax-rate)))

(define (validate-user-credentials username password)
  (and (valid-username? username)
       (valid-password? password)))

(define (send-email-notification recipient subject body)
  (email-send recipient subject body))

; Usage
(calculate-total-price '(10 20 30) 0.1)  ; Returns: 66.0</code></pre>
        <br/>
        <li><b>Bad examples (don't do this):</b></li>
<pre><code class="language-scheme line-numbers">; Wrong - camelCase (not Scheme style)
calculateTotalPrice
getUserInput
sendEmailNotification

; Wrong - snake_case (not Scheme style)
calculate_total_price
get_user_input
send_email_notification

; Right - kebab-case (Scheme style)
calculate-total-price
get-user-input
send-email-notification</code></pre>
    </ul>
    <br/><br/>


    <li>Global Variable Convention</li>
    <br/>
    <ul>
        <li>Global variables and parameters are sometimes surrounded by asterisks <code>*name*</code></li>
        <br/>
        <li><b>Note:</b> This convention is not universal in Scheme, but common in some codebases.</li>
        <br/>
        <li><b>Examples from libraries:</b></li>
<pre><code class="language-scheme line-numbers">; Common in some Scheme systems
*random-state*
*default-input-port*
*default-output-port*
*error-port*
*command-line-args*</code></pre>
        <br/>
        <li><b>Creating your own globals:</b></li>
<pre><code class="language-scheme line-numbers">(define *debug-mode* #f)
(define *max-connections* 100)
(define *database-url* "localhost:5432")
(define *application-version* "1.0.0")

; Usage
(when *debug-mode*
  (display "Debug: Processing request")
  (newline))

(if (< (connection-count) *max-connections*)
    (accept-connection)
    (reject-connection))</code></pre>
        <br/>
        <li><b>Alternative convention:</b> Some prefer <code>%name</code> for internal/private globals</li>
<pre><code class="language-scheme line-numbers">; Internal implementation details
(define %internal-cache (make-hash-table))
(define %debug-counter 0)
(define %temporary-buffer (make-vector 1024))</code></pre>
    </ul>
    <br/><br/>


    <li>Constructor and Maker Convention</li>
    <br/>
    <ul>
        <li>Constructor functions often use <code>make-</code> prefix.</li>
        <br/>
        <li><b>Pattern:</b> <code>(make-type args...)</code> creates a new instance of type.</li>
        <br/>
        <li><b>Standard library examples:</b></li>
<pre><code class="language-scheme line-numbers">; Creating data structures
(make-vector 10)                  ; Creates vector of size 10
(make-vector 5 'x)                ; Creates #(x x x x x)
(make-string 3 #\a)               ; Creates "aaa"
(make-hash-table)                 ; Creates hash table
(make-list 4 0)                   ; Creates (0 0 0 0)</code></pre>
        <br/>
        <li><b>Creating your own constructors:</b></li>
<pre><code class="language-scheme line-numbers">(define (make-point x y)
  (cons x y))

(define (make-rectangle width height)
  (list 'rectangle width height))

(define (make-account name balance)
  (list name balance '()))  ; name, balance, transaction-history

(define (make-counter initial-value)
  (let ((count initial-value))
    (lambda ()
      (set! count (+ count 1))
      count)))

; Usage
(define p1 (make-point 10 20))
(define r1 (make-rectangle 100 50))
(define acc (make-account "John" 1000))
(define counter (make-counter 0))
(counter)  ; Returns: 1
(counter)  ; Returns: 2</code></pre>
    </ul>
    <br/><br/>


    <li>Private/Internal Naming</li>
    <br/>
    <ul>
        <li>Internal helper functions sometimes use <code>%</code> prefix or <code>-internal</code> suffix.</li>
        <br/>
        <li><b>Purpose:</b> Signals that a function is not part of the public API.</li>
        <br/>
        <li><b>Using % prefix:</b></li>
<pre><code class="language-scheme line-numbers">; Public API
(define (parse-expression expr)
  (%validate-syntax expr)
  (%transform-expr expr))

; Internal helpers (not for public use)
(define (%validate-syntax expr)
  ; Internal validation logic
  #t)

(define (%transform-expr expr)
  ; Internal transformation logic
  expr)</code></pre>
        <br/>
        <li><b>Using -internal suffix:</b></li>
<pre><code class="language-scheme line-numbers">; Public API
(define (calculate-total items)
  (apply + (map calculate-price-internal items)))

; Internal helper
(define (calculate-price-internal item)
  (* (item-quantity item)
     (item-unit-price item)
     (+ 1 (item-tax-rate item))))</code></pre>
        <br/>
        <li><b>Nested definitions (alternative):</b></li>
<pre><code class="language-scheme line-numbers">; Internal helpers defined inside public function
(define (process-data data)
  ; Helper only accessible within this function
  (define (validate item)
    (and (number? item) (positive? item)))

  (define (transform item)
    (* item 2))

  ; Use helpers
  (map transform (filter validate data)))

(process-data '(1 -2 3 4))  ; Returns: (2 6 8)</code></pre>
    </ul>
    <br/><br/>


    <li>Common Naming Patterns Summary</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Convention</th>
            <th>Pattern</th>
            <th>Examples</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Predicates (boolean returns)</td>
            <td><code>name?</code></td>
            <td><code>empty?</code>, <code>valid?</code>, <code>member?</code></td>
        </tr>
        <tr>
            <td>Mutating functions</td>
            <td><code>name!</code></td>
            <td><code>set!</code>, <code>vector-set!</code>, <code>increment!</code></td>
        </tr>
        <tr>
            <td>Type conversions</td>
            <td><code>type-a-&gt;type-b</code></td>
            <td><code>list-&gt;vector</code>, <code>string-&gt;number</code></td>
        </tr>
        <tr>
            <td>Multi-word names</td>
            <td><code>kebab-case</code></td>
            <td><code>string-length</code>, <code>file-exists?</code></td>
        </tr>
        <tr>
            <td>Global variables</td>
            <td><code>*name*</code></td>
            <td><code>*debug-mode*</code>, <code>*max-size*</code></td>
        </tr>
        <tr>
            <td>Constructors</td>
            <td><code>make-name</code></td>
            <td><code>make-vector</code>, <code>make-point</code></td>
        </tr>
        <tr>
            <td>Internal/private</td>
            <td><code>%name</code> or <code>name-internal</code></td>
            <td><code>%helper</code>, <code>parse-internal</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <ul>
        <li><b>Complete example using multiple conventions:</b></li>
<pre><code class="language-scheme line-numbers">; Global configuration
(define *max-retries* 3)

; Constructor
(define (make-connection host port)
  (list host port 'disconnected))

; Predicate
(define (connected? conn)
  (eq? (caddr conn) 'connected))

; Type conversion
(define (connection-&gt;string conn)
  (string-append (car conn) ":" (number-&gt;string (cadr conn))))

; Mutator
(define (connect! conn)
  (set-car! (cddr conn) 'connected))

; Multi-word function
(define (establish-secure-connection host port)
  (let ((conn (make-connection host port)))
    (when (%validate-host host)
      (connect! conn))
    conn))

; Internal helper
(define (%validate-host host)
  (and (string? host)
       (> (string-length host) 0)))

; Usage
(define my-conn (make-connection "localhost" 8080))
(connected? my-conn)                    ; Returns: #f
(connect! my-conn)
(connected? my-conn)                    ; Returns: #t
(connection-&gt;string my-conn)             ; Returns: "localhost:8080"</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
