<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>RabbitMQ</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;
        height: 18px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
        font-size: 14px;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/rabbitmq.png" alt="Logo" class="nav-icon"/> Documentation Index</h2>
    <ol style="line-height: 1.8;">
        <li><a href="#rabbitmq-introduction">Introduction</a></li>
        <li><a href="#rabbitmq-hello-world-java">Hello World (Using the Java Client)</a></li>
        <li><a href="#rabbitmq-work-queues-java">Work Queues (Using the Java Client)</a></li>
        <li><a href="#rabbitmq-publish-subscribe-java">Publish / Subscribe (Using the Java Client)</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="rabbitmq-introduction">RabbitMQ Introduction</h3>
<ol>

    <li>What Is RabbitMQ?</li>
    <br/>
    <ul>
        <li><b>RabbitMQ</b> is an open-source <u>message broker</u> that allows different parts of an application (or different applications) to communicate asynchronously.</li>
        <br/>
        <li>It implements the <b>AMQP protocol</b> (Advanced Message Queuing Protocol), which defines:
            <ul>
                <li>how messages are sent</li>
                <li>how messages are routed</li>
                <li>how queues and exchanges behave</li>
            </ul>
        </li>
        <br/>
        <li>It ensures reliable message delivery even if consumers or producers crash.</li>
    </ul>
    <br/><br/>


    <li>Core Concepts in RabbitMQ</li>
    <br/>
    <ul>

        <li>A <code>producer</code> is any program that sends messages to RabbitMQ.</li>
<pre><code class="language-python line-numbers">channel.basic_publish(exchange='', routing_key='jobs', body='hello')</code></pre>

        <br/>

        <li>A <code>receiver</code> receives and processes messages.</li>
<pre><code class="language-python line-numbers">channel.basic_consume(queue='jobs', on_message_callback=callback)</code></pre>

        <br/>

        <li>A <code>queue</code> is a buffer where messages wait until processed.</li>

        <br/>

        <li>An <code>exchange</code> receives messages and routes them to queues (Different routing strategies = different exchange types).</li>

        <br/>

        <li>A <code>binding</code> is a rule connecting a queue to an exchange.</li>

        <br/>

        <li>A <code>routing key</code> is a message label used by the exchange to decide where messages go.</li>

        <br/>

        <li>A <code>connection</code> is a TCP connection to RabbitMQ server.</li>

        <br/>

        <li>A <code>channel</code> is a virtual session used to perform messaging operations.</li>

    </ul>
    <br/><br/>


    <li>RabbitMQ Exchange Types</li>
    <br/>
    <ul>
        <table>
            <thead>
                <tr>
                    <th>Exchange Type</th>
                    <th>Description</th>
                    <th>Routing Behavior</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>direct</code></td>
                    <td>Simple mapping using routing key</td>
                    <td>Only queues with an exact-match routing key receive messages</td>
                </tr>
                <tr>
                    <td><code>fanout</code></td>
                    <td>Broadcasting</td>
                    <td>All queues bound to the exchange receive the message</td>
                </tr>
                <tr>
                    <td><code>topic</code></td>
                    <td>Pattern-based routing</td>
                    <td>Routing key supports wildcards (<code>*</code> and <code>#</code>)</td>
                </tr>
                <tr>
                    <td><code>headers</code></td>
                    <td>Routing based on message headers</td>
                    <td>Flexible but slower</td>
                </tr>
            </tbody>
        </table>
    </ul>
    <br/><br/>


    <li>Message Flow in RabbitMQ</li>
    <br/>
    <ul>
        <li>A message travels through 3 main stages:</li>
        <br/>
        <ol>
            <li>Producer → Exchange</li>
            <li>Exchange → Queue</li>
            <li>Queue → Consumer</li>
        </ol>
        <br/>
        <li>This allows full decoupling between sender and receiver.</li>
    </ul>
    <br/><br/>


    <li>RabbitMQ vs Kafka (High-Level)</li>
    <br/>
    <ul>
        <table>
            <thead>
                <tr>
                    <th>RabbitMQ</th>
                    <th>Kafka</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Message broker</td>
                    <td>Distributed log/event streaming</td>
                </tr>
                <tr>
                    <td>Best for task processing</td>
                    <td>Best for high-throughput event streams</td>
                </tr>
                <tr>
                    <td>Point-to-point or pub/sub</td>
                    <td>Pub/sub only</td>
                </tr>
                <tr>
                    <td>Lightweight; low latency</td>
                    <td>High throughput, scalable</td>
                </tr>
            </tbody>
        </table>
    </ul>
    <br/><br/>


    <li>Installing and Running RabbitMQ</li>
    <br/>
    <ul>
        <li>Local installation (OpenSUSE example):</li>
<pre><code class="language-bash line-numbers">sudo zypper install rabbitmq-server
sudo systemctl start rabbitmq-server</code></pre>

        <br/>
        <li>Or run via Docker:</li>
<pre><code class="language-bash line-numbers">docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></pre>

        <br/>
        <li>Management UI available at:</li>
<pre><code class="language-plaintext line-numbers">http://localhost:15672</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Python Producer and Consumer Example</li>
    <br/>
    <ul>

        <li><b>Producer (send message)</b></li>
<pre><code class="language-python line-numbers">import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

channel.queue_declare(queue='hello')
channel.basic_publish(exchange='', routing_key='hello', body='Hello RabbitMQ!')
connection.close()</code></pre>

        <br/>

        <li><b>Consumer (receive message)</b></li>
<pre><code class="language-python line-numbers">import pika

def callback(ch, method, properties, body):
    print("Received:", body.decode())

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

channel.queue_declare(queue='hello')
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

print("Waiting for messages...")
channel.start_consuming()</code></pre>

        <br/>
        <li>RabbitMQ automatically delivers messages to consumers.</li>
    </ul>
    <br/><br/>


    <li>RabbitMQ Acknowledgements</li>
    <br/>
    <ul>
        <li>Consumers send <code>ACKs</code> after processing messages.</li>
        <li>If a consumer crashes before an <code>ACK</code>, the message is requeued.</li>
    </ul>
<pre><code class="language-python line-numbers">channel.basic_consume(queue='jobs', on_message_callback=callback, auto_ack=False)</code></pre>
    <br/><br/>


    <li>Durable Queues &amp; Persistent Messages</li>
    <br/>
    <ul>
        <li>Ensure messages survive broker restarts:</li>
    </ul>
<pre><code class="language-python line-numbers">channel.queue_declare(queue='jobs', durable=True)
channel.basic_publish(exchange='', routing_key='jobs',
                      body='hello',
                      properties=pika.BasicProperties(delivery_mode=2))</code></pre>
    <ul>
        <li><code>delivery_mode=2</code> makes the message persistent.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rabbitmq-hello-world-java">RabbitMQ &mdash; Hello World with the Java Client</h3>
<ol>

    <li>This chapter explains how to build a minimal <b>Hello World</b> message queue using:</li>
    <ul>
        <br/>
        <li>A RabbitMQ Server running locally (default: <code>localhost:5672</code>)</li>
        <br/>
        <li>A Java Client using the official RabbitMQ Java library</li>
        <br/>
        <li>Two small programs:
            <ul>
                <li><code>Sender</code> sends <code>"Hello World"</code> messages to a queue</li>
                <li><code>Receiver</code> receives and prints those messages</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Prerequisites</li>
    <br/>
    <ul>
        <li>RabbitMQ default credentials:
            <ul>
                <li>Host: <code>localhost</code></li>
                <li>Port: <code>5672</code></li>
                <li>Username: <code>guest</code></li>
                <li>Password: <code>guest</code></li>
            </ul>
        </li>
        <br/>
        <li>RabbitMQ server running:
<pre><code class="language-bash line-numbers"># Example on Linux/macOS if installed via system packages
sudo service rabbitmq-server start

# Or via Homebrew on macOS
brew services start rabbitmq</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>Project Structure</li>
    <br/>
    <ul>
        <li>We will create a very small Maven project with two Java classes.</li>
        <br/>
        <li>Example structure:</li>
<pre><code class="language-plaintext line-numbers">rabbitmq-hello-world-java/
├─ pom.xml
└─ src/
   └─ main/
      └─ java/
         └─ com/
            └─ example/
               ├─ Send.java   &lt;-- sender (producer)
               └─ Recv.java   &lt;-- receiver (consumer)</code></pre>
        <br/>
        <li>You can adjust the package name as you like, just keep sender and receiver separate.</li>
    </ul>
    <br/><br/>


    <li>Adding the RabbitMQ Java Client Dependency (Maven)</li>
    <br/>
    <ul>
        <li>In your <code>pom.xml</code> add the RabbitMQ Java client dependency:</li>
<pre><code class="language-xml line-numbers">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;rabbitmq-hello-world-java&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.24.0&lt;/version&gt; &lt;!-- Example version --&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
        <br/>
        <li>After editing <code>pom.xml</code>, download dependencies:</li>
<pre><code class="language-bash line-numbers">mvn dependency:resolve</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding the Connection to RabbitMQ</li>
    <br/>
    <ul>
        <li>Both sender and receiver will:
            <ul>
                <li>Create a <code>ConnectionFactory</code></li>
                <li>Set the host (and optionally username/password)</li>
                <li>Open a <code>Connection</code></li>
                <li>Create a <code>Channel</code> from that connection</li>
            </ul>
        </li>
        <br/>
        <li>The queue name will be something simple, e.g.:</li>
<pre><code class="language-plaintext line-numbers">QUEUE_NAME = "hello";</code></pre>
        <li>Both sender and receiver must <b>declare</b> the same queue so that:
            <ul>
                <li>Sender publishes messages to that queue.</li>
                <li>Receiver consumes messages from that queue.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Sender &mdash; <code>Send.java</code></li>
    <br/>
    <ul>
        <li>Create the file <code>src/main/java/com/example/Send.java</code> with the following content:</li>
    </ul>
<pre><code class="language-java line-numbers">package com.example;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.nio.charset.StandardCharsets;

public class Send {

    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws Exception {
        // 1. Create a connection factory and configure it
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");
        // factory.setUsername("guest");
        // factory.setPassword("guest");

        // 2. Create connection and channel using try-with-resources
        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {

            // 3. Declare the queue (idempotent &mdash; only created if it does not exist)
            channel.queueDeclare(
                    QUEUE_NAME,
                    false,  // durable
                    false,  // exclusive
                    false,  // autoDelete
                    null    // arguments
            );

            // 4. Message to send
            String message = "Hello World from Java!";

            // 5. Publish the message to the default exchange ("") with routing key = queue name
            channel.basicPublish(
                    "",
                    QUEUE_NAME,
                    null,
                    message.getBytes(StandardCharsets.UTF_8)
            );

            System.out.println(" [x] Sent '" + message + "'");
        } // END try
    }
}</code></pre>
    <ul>
        <li><code>queueDeclare</code> is safe to call multiple times, it just ensures the queue exists.</li>
        <li><code>basicPublish("", QUEUE_NAME, ...)</code> uses the <b>default exchange</b> with routing key equal to the queue name.</li>
        <li><code>try (Connection ...)</code> auto-closes the connection and channel.</li>
    </ul>
    <br/><br/>


    <li>Receiver &mdash; <code>Recv.java</code></li>
    <br/>
    <ul>
        <li>Create the file <code>src/main/java/com/example/Recv.java</code> with the following content:</li>
    </ul>
<pre><code class="language-java line-numbers">package com.example;

import com.rabbitmq.client.*;

import java.nio.charset.StandardCharsets;

public class Recv {

    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws Exception {
        // 1. Create connection factory
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");
        // factory.setUsername("guest");
        // factory.setPassword("guest");

        // 2. Create connection and channel
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        // 3. Ensure the same queue exists
        channel.queueDeclare(
                QUEUE_NAME,
                false,
                false,
                false,
                null
        );

        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

        // 4. Define how to process delivered messages (callback)
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(
                    delivery.getBody(),
                    StandardCharsets.UTF_8
            );
            System.out.println(" [x] Received '" + message + "'");
        };

        CancelCallback cancelCallback = consumerTag -&gt; {
            System.out.println(" [!] Consumer was cancelled: " + consumerTag);
        };

        // 5. Start consuming messages (autoAck = true)
        channel.basicConsume(
                QUEUE_NAME,
                true,            // autoAck
                deliverCallback,
                cancelCallback
        );
    }
}</code></pre>
    <ul>
        <li>The receiver also calls <code>queueDeclare</code> to ensure the queue exists.</li>
        <li><code>basicConsume</code> registers an asynchronous consumer, the program keeps running.</li>
        <li><code>autoAck = true</code> means messages are automatically acknowledged as soon as they are delivered.</li>
    </ul>
    <br/><br/>


    <li>Building and Running the Example</li>
    <br/>
    <ul>
        <li>First, build the project with Maven:</li>
<pre><code class="language-bash line-numbers">cd rabbitmq-hello-world-java
mvn package</code></pre>
        <br/>
        <li>Run the receiver (consumer) in one terminal:</li>
<pre><code class="language-bash line-numbers"># From the project root
mvn -q exec:java -Dexec.mainClass="com.example.Recv"</code></pre>
        <br/>
        <li>In another terminal, run the sender (producer):</li>
<pre><code class="language-bash line-numbers">mvn -q exec:java -Dexec.mainClass="com.example.Send"</code></pre>
        <br/>
        <li>Expected output:
        <br/>
        <br/>
            <ul>
                <li>Sender terminal:</li>
            </ul>
<pre><code class="language-plaintext line-numbers"> [x] Sent 'Hello World from Java!'</code></pre>
            <ul>
                <li>Receiver terminal:</li>
            </ul>
<pre><code class="language-plaintext line-numbers"> [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'Hello World from Java!'</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li>How the Visually Message Flow Works</li>
<pre><code class="language-plaintext line-numbers">[Send.java] --basicPublish--&gt; [""] default exchange --&gt; [queue "hello"] --&gt; [Recv.java]</code></pre>
    <br/><br/>


    <li>Common Troubleshooting Tips</li>
    <br/>
    <ul>
        <li>Problem: <code>java.net.ConnectException: Connection refused</code>
            <ul>
                <li>Check if RabbitMQ is running.</li>
                <li>Verify host and port: <code>localhost:5672</code>.</li>
            </ul>
        </li>
        <br/>
        <li>Problem: Authentication failure
            <ul>
                <li>Ensure username/password <code>guest/guest</code> are correct.</li>
                <li>Note: by default, <code>guest/guest</code> might be restricted to localhost.</li>
                <li>For remote hosts, create a dedicated user in RabbitMQ if necessary.</li>
            </ul>
        </li>
        <br/>
        <li>Problem: Receiver doesn&#39;t print anything
            <ul>
                <li>Ensure the receiver is running <u>before</u> you send messages (for this simple example).</li>
                <li>Check that both sender and receiver use the <u>same queue name</u> and <u>same virtual host</u>.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rabbitmq-work-queues-java">RabbitMQ &mdash; Work Queues (Using the Java Client)</h3>
<ol>

    <li>What Are Work Queues?</li>
    <br/>
    <ul>
        <li>A <code>Work Queue</code> (also called <code>Task Queue</code>) is a RabbitMQ pattern where:
            <ul>
                <li>multiple worker processes share a queue</li>
                <li>each worker gets some messages</li>
                <li>tasks are distributed across workers</li>
            </ul>
        </li>
        <br/>
        <li>Use cases:
            <ul>
                <li>background job processing</li>
                <li>CPU-heavy or IO-heavy tasks</li>
                <li>distributing long-running tasks across multiple workers</li>
            </ul>
        </li>
        <br/>
        <li>We will build three components:
            <ul>
                <li><code>NewTask.java</code> is producer that sends tasks</li>
                <li><code>Worker.java</code> is worker that receives tasks</li>
                <li>Multiple Worker instances to demonstrate load balancing</li>
            </ul>
        </li>
    </ul>
    <br/><br/>

    <li>Project Structure</li>
<pre><code class="language-plaintext line-numbers">rabbitmq-work-queues/
├─ pom.xml
└─ src/
   └─ main/
      └─ java/
         └─ com/
            └─ example/
               ├─ NewTask.java   &lt;-- producer (sends tasks)
               └─ Worker.java    &lt;-- worker (receives tasks)
</code></pre>
    <br/><br/>


    <li>Declaring a Durable Queue</li>
    <ul>
        <li>Both producer and workers must declare the <u>same</u> durable queue:</li>
    </ul>
<pre><code class="language-java line-numbers">boolean durable = true;
channel.queueDeclare("task_queue", durable, false, false, null);
</code></pre>
    <ul>
        <li>This means:
            <ul>
                <li>Queue survives a RabbitMQ restart</li>
                <li>Task messages stored on disk (when we publish persistent messages)</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Producer (<code>NewTask.java</code>)</li>
    <br/>
    <ul>
        <li>Create <code>NewTask.java</code> to send a message representing a task.</li>
<pre><code class="language-java line-numbers">package com.example;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.MessageProperties;

public class NewTask {

    private static final String QUEUE_NAME = "task_queue";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {

            // Durable queue
            boolean durable = true;
            channel.queueDeclare(QUEUE_NAME, durable, false, false, null);

            // Create message from args
            String message = String.join(" ", argv);
            if (message.isEmpty()) {
                message = "Hello..."; // default message
            }

            // Publish persistent message
            channel.basicPublish(
                    "",
                    QUEUE_NAME,
                    MessageProperties.PERSISTENT_TEXT_PLAIN, // marks message as durable
                    message.getBytes("UTF-8")
            );

            System.out.println(" [x] Sent '" + message + "'");
        }
    }
}
</code></pre>
        <br/>
        <li>Example usage:</li>
<pre><code class="language-bash line-numbers">mvn -q exec:java -Dexec.mainClass="com.example.NewTask" -Dexec.args="Task....."</code></pre>
        <li>In the tutorials, the number of dots (<code>.</code>) represents seconds of “work”.</li>
    </ul>
    <br/><br/>


    <li>Worker (<code>Worker.java</code>)</li>
    <br/>
    <ul>
        <li>receive tasks</li>
        <li>simulate work based on <code>.</code> count</li>
        <li>manually acknowledge after finishing</li>
    </ul>
<pre><code class="language-java line-numbers">package com.example;

import com.rabbitmq.client.*;

public class Worker {

    private static final String QUEUE_NAME = "task_queue";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        // Durable queue
        boolean durable = true;
        channel.queueDeclare(QUEUE_NAME, durable, false, false, null);

        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

        // Fair dispatch: don't give new messages until worker is done
        channel.basicQos(1);

        // Define callback for messages
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" + message + "'");

            try {
                doWork(message);
            } finally {
                System.out.println(" [x] Done");
                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
            }
        };

        // AutoAck = false → manual acknowledgements
        boolean autoAck = false;

        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, consumerTag -&gt; { });
    }

    private static void doWork(String task) {
        for (char ch : task.toCharArray()) {
            if (ch == '.') {
                try {
                    Thread.sleep(1000); // one second per dot
                } catch (InterruptedException ignored) {}
            }
        }
    }
}
</code></pre>
    <ul>
        <li><code>basicAck</code> tells RabbitMQ the worker finished the task.</li>
        <li>If a worker dies, RabbitMQ re-queues the message to another worker.</li>
        <li>Fair dispatch using <code>basicQos(1)</code> ensures slower workers get fewer tasks.</li>
    </ul>
    <br/><br/>


    <li>Running Multiple Workers</li>
    <br/>
    <ul>
        <li>Open two (or more) terminals and run:</li>
<pre><code class="language-bash line-numbers"># Terminal 1
mvn -q exec:java -Dexec.mainClass="com.example.Worker"

# Terminal 2
mvn -q exec:java -Dexec.mainClass="com.example.Worker"
</code></pre>
        <br/>
        <li>Now send tasks:</li>
<pre><code class="language-bash line-numbers">mvn -q exec:java -Dexec.mainClass="com.example.NewTask" -Dexec.args="Hello..."
mvn -q exec:java -Dexec.mainClass="com.example.NewTask" -Dexec.args="Another....."
mvn -q exec:java -Dexec.mainClass="com.example.NewTask" -Dexec.args="Quick."
</code></pre>
        <br/>
        <li>You will see messages distributed like:</li>
<pre><code class="language-plaintext line-numbers"># Worker 1:
[x] Received 'Hello...'
[x] Done
[x] Received 'Quick.'
[x] Done

# Worker 2:
[x] Received 'Another.....'
[x] Done
</code></pre>
        <li>RabbitMQ dispatches them one by one to each worker.</li>
    </ul>
    <br/><br/>


    <li>How Acknowledgements Work</li>
    <br/>
    <ul>
        <li>Workers manually acknowledge messages:</li>
<pre><code class="language-java line-numbers">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
</code></pre>
        <li>If a worker:
            <ul>
                <li>crashes</li>
                <li>disconnects</li>
                <li>is killed</li>
            </ul>
            RabbitMQ will requeue the task and deliver it to another worker.
        </li>
        <br/>
        <li>This guarantees no message is lost.</li>
    </ul>
    <br/><br/>


    <li>Message Durability</li>
    <br/>
    <ul>
        <li>Two things make messages survive restarts:</li>
        <br/>
        <li><b>1. Durable queue</b></li>
<pre><code class="language-java line-numbers">channel.queueDeclare("task_queue", true, false, false, null);
</code></pre>
        <li><b>2. Persistent messages</b></li>
<pre><code class="language-java line-numbers">MessageProperties.PERSISTENT_TEXT_PLAIN
</code></pre>
<li>Even then, RabbitMQ does not guarantee <b>instant</b> disk flush, but in practice persistence is reliable.</li>
    </ul>
    <br/><br/>


    <li>Fair Dispatch with <code>basicQos(1)</code></li>
    <br/>
    <ul>
        <li>Without QoS, RabbitMQ sends messages in round-robin style, regardless of worker speed.</li>
        <br/>
        <li>With: <code>channel.basicQos(1);</code> RabbitMQ will:</li>
            <ul>
                <li>send only one unacknowledged message at a time</li>
                <li>wait for <code>basicAck</code> before giving that worker more tasks</li>
            </ul>
        <br/>
        <li>This prevents slow workers from being overloaded.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="rabbitmq-publish-subscribe-java">RabbitMQ &mdash; Publish/Subscribe (Using the Java Client)</h3>
<ol>

    <li>What Is Publish/Subscribe?</li>
    <br/>
    <ul>
        <li>Publish/Subscribe (pub/sub) is a messaging pattern where:
            <ul>
                <li>Producers <b>publish</b> messages to an <b>exchange</b></li>
                <li>Multiple queues are <b>bound</b> to that exchange</li>
                <li>Each consumer receives a <b>copy</b> of each message</li>
            </ul>
        </li>
        <br/>
        <li>Typical use cases:
            <ul>
                <li>Broadcasting logs to multiple receivers (e.g. console + file + monitoring)</li>
                <li>Sending notifications to multiple services</li>
                <li>Fan-out events to several independent consumers</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Core Concepts: Exchange &amp; Fanout</li>
    <br/>
    <ul>
        <li>Previously, we published directly to a queue (using the default exchange <code>""</code>).</li>
        <br/>
        <li>In pub/sub:
            <ul>
                <li>We publish to a <b>named exchange</b> (e.g. <code>logs</code>)</li>
                <li>The exchange forwards messages to all bound queues</li>
            </ul>
        </li>
        <br/>
        <li><b>Fanout exchange</b>:
            <ul>
                <li>Ignores routing keys</li>
                <li>Broadcasts messages to <b>every</b> queue that is bound to it</li>
            </ul>
        </li>
<pre><code class="language-plaintext line-numbers">Producer --&gt; [fanout exchange "logs"] --&gt; [queue A] --&gt; Consumer 1
                                          [queue B] --&gt; Consumer 2
                                          [queue C] --&gt; Consumer 3
</code></pre>
        <li>Each consumer gets its own copy of the message.</li>
    </ul>
    <br/><br/>


    <li>Project Structure</li>
<pre><code class="language-plaintext line-numbers">rabbitmq-pubsub-java/
├─ pom.xml
└─ src/
   └─ main/
      └─ java/
         └─ com/
            └─ example/
               ├─ EmitLog.java       &lt;-- producer (publishes logs)
               └─ ReceiveLogs.java   &lt;-- consumer (subscribes to logs)
</code></pre>
    <ul>
        <li>We reuse the same RabbitMQ Java client dependency as before (in <code>pom.xml</code>):</li>
    </ul>
<pre><code class="language-xml line-numbers">&lt;dependency&gt;
    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
    &lt;version&gt;5.24.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    <br/><br/>


    <li>Declaring the Fanout Exchange</li>
    <br/>
    <ul>
        <li>Both producer and consumers will use the same exchange:</li>
    </ul>
<pre><code class="language-java line-numbers">String EXCHANGE_NAME = "logs";
channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
</code></pre>
    <ul>
        <li><code>exchangeDeclare</code> is idempotent (safe to call multiple times) and creates the exchange if it does not exist</li>
        <br/>
        <li><code>BuiltinExchangeType.FANOUT</code> means broadcast to all bound queues.</li>
    </ul>
    <br/><br/><br/>


    <li>Producer &mdash; <code>EmitLog.java</code></li>
    <br/>
    <ul>
        <li><code>EmitLog</code> sends a log message to the <code>logs</code> exchange.</li>
    </ul>
<pre><code class="language-java line-numbers">package com.example;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.nio.charset.StandardCharsets;

public class EmitLog {

    private static final String EXCHANGE_NAME = "logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {

            // Declare fanout exchange
            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);

            // Build message from command-line arguments
            String message = String.join(" ", argv);
            if (message.isEmpty()) {
                message = "info: Hello RabbitMQ Publish/Subscribe!";
            }

            // Publish to exchange (routing key is ignored by fanout)
            channel.basicPublish(
                    EXCHANGE_NAME,
                    "",
                    null,
                    message.getBytes(StandardCharsets.UTF_8)
            );

            System.out.println(" [x] Sent '" + message + "'");
        }
    }
}
</code></pre>
    <ul>
        <li>We publish to <code>exchange</code> <code>"logs"</code>, not to a specific queue.</li>
        <li>Routing key is empty (<code>""</code>) because fanout ignores it anyway.</li>
    </ul>
    <br/><br/>


    <li>Consumer &mdash; <code>ReceiveLogs.java</code> (Ephemeral Queues)</li>
    <br/>
    <ul>
        <li>Each consumer will:
            <ul>
                <li>create its own <b>exclusive, auto-delete queue</b></li>
                <li>bind that queue to the <code>logs</code> exchange</li>
                <li>receive all messages published to the exchange</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-java line-numbers">package com.example;

import com.rabbitmq.client.*;

import java.nio.charset.StandardCharsets;

public class ReceiveLogs {

    private static final String EXCHANGE_NAME = "logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        // Declare fanout exchange
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);

        // Create a non-durable, exclusive, auto-delete queue with a generated name
        String queueName = channel.queueDeclare().getQueue();

        // Bind the queue to the exchange
        channel.queueBind(queueName, EXCHANGE_NAME, "");

        System.out.println(" [*] Waiting for logs in queue '" + queueName +
                           "'. To exit press CTRL+C");

        // Define callback
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(
                    delivery.getBody(),
                    StandardCharsets.UTF_8
            );
            System.out.println(" [x] Received '" + message + "'");
        };

        CancelCallback cancelCallback = consumerTag -&gt; {
            System.out.println(" [!] Consumer cancelled: " + consumerTag);
        };

        // Start consuming (autoAck = true)
        boolean autoAck = true;
        channel.basicConsume(queueName, autoAck, deliverCallback, cancelCallback);
    }
}
</code></pre>
    <ul>
        <li><code>queueDeclare()</code> with no arguments creates a fresh, server-named queue.</li>
        <li>It is:
            <ul>
                <li>non-durable</li>
                <li>exclusive (only this connection can use it)</li>
                <li>auto-delete (deleted when connection closes)</li>
            </ul>
        </li>
        <li>Each <code>ReceiveLogs</code> instance gets its <u>own</u> queue bound to <code>"logs"</code>.</li>
    </ul>
    <br/><br/>


    <li>Running Multiple Subscribers</li>
    <br/>
    <ul>
        <li>Start RabbitMQ server, then open three terminals.</li>
        <br/>
        <li>Terminal 1 &mdash; first subscriber:</li>
<pre><code class="language-bash line-numbers">mvn -q exec:java -Dexec.mainClass="com.example.ReceiveLogs"
</code></pre>
        <br/>
        <li>Terminal 2 &mdash; second subscriber:</li>
<pre><code class="language-bash line-numbers">mvn -q exec:java -Dexec.mainClass="com.example.ReceiveLogs"
</code></pre>
        <br/>
        <li>Terminal 3 &mdash; producer:</li>
<pre><code class="language-bash line-numbers">mvn -q exec:java -Dexec.mainClass="com.example.EmitLog" \
    -Dexec.args="info: Hello from pub/sub!"
</code></pre>
        <br/>
        <li>Expected result: Each <code>ReceiveLogs</code> terminal prints the <u>same</u> message.</li>
<pre><code class="language-plaintext line-numbers"># Terminal 1:
 [*] Waiting for logs in queue 'amq.gen-...'
 [x] Received 'info: Hello from pub/sub!'

# Terminal 2:
 [*] Waiting for logs in queue 'amq.gen-...'
 [x] Received 'info: Hello from pub/sub!'
</code></pre>
        <li>This demonstrates that pub/sub delivers a copy of each message to <u>every active subscriber</u>.</li>
    </ul>
    <br/><br/>


    <li>Temporary vs Persistent Subscribers</li>
    <br/>
    <ul>
        <li>The basic tutorial uses <u>temporary queues</u>:
            <ul>
                <li>Queue disappears when the consumer disconnects</li>
                <li>Messages are not kept for future subscribers</li>
                <li>Good for real-time log viewing</li>
            </ul>
        </li>
        <br/>
        <li>For persistent log storage you could:
            <ul>
                <li>Declare a named, durable queue (e.g. <code>"logs_file"</code>)</li>
                <li>Bind it to the exchange</li>
                <li>Run a consumer that writes all messages to a file or DB</li>
            </ul>
        </li>
<pre><code class="language-java line-numbers">// Example: named durable log queue
channel.queueDeclare("logs_file", true, false, false, null);
channel.queueBind("logs_file", EXCHANGE_NAME, "");
</code></pre>
        <li>Then, even if no subscribers are currently running, messages can be stored in that durable queue.</li>
    </ul>
    <br/><br/>


    <li>How Publish/Subscribe Differs from Work Queues</li>
    <br/>
    <ul>
        <li><b>Work Queues</b>:
            <ul>
                <li>One queue, many workers</li>
                <li>Each message goes to <u>only one</u> worker</li>
                <li>Goal: distribute load</li>
            </ul>
        </li>
        <br/>
        <li><b>Publish/Subscribe</b>:
            <ul>
                <li>One exchange, many queues</li>
                <li>Each message goes to <u>all</u> queues (and thus all subscribers)</li>
                <li>Goal: broadcast the same message to multiple consumers</li>
            </ul>
        </li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
