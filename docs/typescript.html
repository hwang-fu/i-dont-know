<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>TS</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>

    .nav-icon {
        width: 18px;          /* adjust size here */
        height: 18px;
        object-fit: contain;  /* keep aspect ratio */
        vertical-align: middle;
        margin-left: 0.3rem;  /* small gap from text */
    }

    /* Make comments grey */
    .token.comment {
        color: #888;
    }

    .token.keyword {
        font-weight: 500;
    }

    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-size: 14px;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }

    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/ts.png" alt="TS Logo" class="nav-icon"/> Documentation Index</h2>
    <ul style="line-height: 1.8;">
        <li><a href="#ts-typeof">The <code>typeof</code> Operator</a></li>
        <li><a href="#ts-type">The <code>type</code> Operator</a></li>
        <li><a href="#ts-everyday-types">Everyday Types</a></li>
        <li><a href="#ts-more-on-functions">More on Functions</a></li>
        <li><a href="#ts-object-types">Object Types</a></li>
        <li><a href="#ts-classes">Classes</a></li>
        <li><a href="#ts-constructor-vs-instance">Constructor Type vs. Instance Type</a></li>
        <li><a href="#ts-generics">Generics</a></li>
        <li><a href="#ts-keyof">The <code>keyof</code> Type Operator</a></li>
        <li><a href="#ts-indexed-access">Indexed Access Types (<code>T[K]</code>)</a></li>
        <li><a href="#ts-conditional-types">Conditional Types</a></li>
        <li><a href="#ts-mapped-types">Mapped Types</a></li>
        <li><a href="#ts-infer">The <code>infer</code> Keyword</a></li>
        <li><a href="#ts-template-literal-types">Template Literal Types</a></li>
        <li><a href="#ts-modules">Modules</a></li>
        <li><a href="#ts-decorators">Decorators</a></li>
        <li><a href="#ts-get-set">Getters and Setters in TS</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-typeof">The <code>typeof</code> Operator</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In TypeScript, <code>typeof</code> is a dual-purpose operator used both at <u>runtime</u> (JavaScript behavior) and at <u>compile time</u> (TypeScript type queries).</li>
        <br/>
        <li>At runtime, <code>typeof</code> returns a string describing the JS type of a value.</li>
        <br/>
        <li>At compile time, TypeScript uses <code>typeof</code> to extract the <u>type</u> of a variable or function instead of its value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Runtime <code>typeof</code></b></li>
    <br/>
    <ul>
        <li>Runtime <code>typeof</code> is identical to JavaScript and returns strings:</li>
    </ul>
<pre><code class="language-ts line-numbers">console.log(typeof 123);       // "number"
console.log(typeof 'hello');   // "string"
console.log(typeof true);      // "boolean"
console.log(typeof {});        // "object"
console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object"  (quirk of JavaScript)
</code></pre>
    <br/>
    <br/>


    <li><b>Compile-Time <code>typeof</code> (Type Query)</b></li>
    <br/>
    <ul>
        <li>In TypeScript, <code>typeof</code> inside a type context retrieves the <u>type</u> of a value.</li>
        <br/>
        <li>This allows you to reuse the type of an existing variable or function.</li>
    </ul>
<pre><code class="language-ts line-numbers">const user = {
    id: 1,
    name: 'Alice',
    active: true
};

type User = typeof user;
</code></pre>
    <br/>
    <ul>
        <li><code>User</code> is now exactly the type of the variable <code>user</code>.</li>
        <li>This avoids manually rewriting types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> with Functions</b></li>
<pre><code class="language-ts line-numbers">function createPoint(x: number, y: number) {
    return { x, y };
}

type Point = ReturnType&lt;typeof createPoint&gt;;
</code></pre>
    <br/>
    <ul>
        <li><code>typeof createPoint</code> gives you the type of the function object itself.</li>
        <li><code>ReturnType&lt;...&gt;</code> extracts the return type of that function.</li>
        <li>This is safer and avoids duplication when the function evolves.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> for Constant Union Types</b></li>
<pre><code class="language-ts line-numbers">const roles = ['admin', 'user', 'guest'] as const;

type Role = typeof roles[number];
</code></pre>
    <br/>
    <ul>
        <li><code>typeof roles[number]</code> turns the array into a union: <code>'admin' | 'user' | 'guest'</code>.</li>
        <li>This pattern is extremely useful for enums and constant lists.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>typeof</code> with Literal Types</b></li>
<pre><code class="language-ts line-numbers">const DEFAULT_PORT = 8080;

type Port = typeof DEFAULT_PORT; // type Port = 8080
</code></pre>
    <br/>
    <ul>
        <li>The type of <code>DEFAULT_PORT</code> is the literal type <code>8080</code>, not <code>number</code>.</li>
        <li>Useful for configuration constants or fixed numeric/string values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> in Type Guards</b></li>
<pre><code class="language-ts line-numbers">function logValue(v: string | number) {
    if (typeof v === 'string') {
        console.log(v.toUpperCase());
    } else {
        console.log(v.toFixed(2));
    }
}
</code></pre>
    <br/>
    <ul>
        <li>TypeScript understands the runtime <code>typeof</code> check and narrows types accordingly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Context</th>
                <th>Meaning</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Runtime</td>
                <td>Returns a string describing JS type</td>
                <td><code>typeof 123 === 'number'</code></td>
            </tr>
            <tr>
                <td>Compile-Time</td>
                <td>Returns the TypeScript type of a value</td>
                <td><code>type T = typeof x</code></td>
            </tr>
            <tr>
                <td>Combined</td>
                <td>Used for safe type narrowing</td>
                <td><code>if (typeof v === 'string') ...</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-type">The <code>type</code> Operator (Type Aliases)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In TypeScript, the <code>type</code> keyword creates a <b>type alias</b>, which is a custom name for any type.</li>
        <br/>
        <li>A type alias does not create a new type at runtime. Instead, it provides a readable, reusable label for complex type structures.</li>
        <br/>
        <li><code>type</code> is similar to <code>interface</code>, but more powerful in certain use cases (unions, mapped types, utility types).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-ts line-numbers">type AliasName = ExistingType;
</code></pre>
    <br/>
    <ul>
        <li><code>AliasName</code> becomes a new name referring to the right-hand side type.</li>
        <li>Type aliases improve clarity and reduce duplication.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Alias for Primitive Types</b></li>
<pre><code class="language-ts line-numbers">type ID = number;
type Username = string;
</code></pre>
    <br/>
    <ul>
        <li>Primitive aliases improve readability in function signatures.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Alias for Object Types</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};
</code></pre>
    <br/>
    <ul>
        <li>Defines a reusable object shape.</li>
        <li>Common in API response schemas or domain models.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Type Alias</b></li>
<pre><code class="language-ts line-numbers">type Add = (a: number, b: number) =&gt; number;

const sum: Add = (x, y) =&gt; x + y;
</code></pre>
    <br/>
    <ul>
        <li>Provides a clean, reusable type for a function signature.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Union Types with <code>type</code></b></li>
<pre><code class="language-ts line-numbers">type Status = 'success' | 'error' | 'loading';

type StringOrNumber = string | number;
</code></pre>
    <br/>
    <ul>
        <li>Type aliases are the only way (besides literal types) to define union types.</li>
        <li>Unions are essential for discriminated unions, enums, and input validation.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Intersection Types</b></li>
<pre><code class="language-ts line-numbers">type HasID = { id: number };
type HasName = { name: string };

type User = HasID &amp; HasName;
</code></pre>
    <br/>
    <ul>
        <li>An <b>intersection type</b> (<code>&amp;</code>) merges multiple types into a single combined type.</li>
        <br/>
        <li>The resulting type contains <u>all</u> properties from all intersected types.</li>
        <br/>
        <li>In the example above, <code>User</code> must have <code>id</code> and <code>name</code>:
<pre><code class="language-ts line-numbers">const u: User = {
    id: 1,
    name: "Alice"
};
</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection with More Types</b></li>
<pre><code class="language-ts line-numbers">type HasEmail = { email: string };

type Person = HasID &amp; HasName &amp; HasEmail;
</code></pre>
    <br/>
    <ul>
        <li><code>Person</code> must include all properties: <code>id</code>, <code>name</code>, and <code>email</code>.</li>
        <li>This allows building strong domain models from small reusable pieces.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection Types with Functions</b></li>
<pre><code class="language-ts line-numbers">type CanLog = { log: () =&gt; void };
type CanSave = { save: () =&gt; void };

type LoggerSaver = CanLog &amp; CanSave;

const obj: LoggerSaver = {
    log() { console.log("logging"); },
    save() { console.log("saving"); }
};
</code></pre>
    <br/>
    <ul>
        <li>Intersection types allow you to build objects that must implement multiple behaviors.</li>
        <li>This is a common pattern in mixin-based systems.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Merging Object Types (Property Compatibility)</b></li>
<pre><code class="language-ts line-numbers">type A = { x: number };
type B = { x: number | string };

type C = A &amp; B;
// type C = { x: number } &amp; { x: number | string }
</code></pre>
    <br/>
    <ul>
        <li>When intersecting conflicting property types, TypeScript computes the <u>most specific</u> possible type.</li>
        <br/>
        <li>Here:
            <ul>
                <li><code>A.x</code> must be <code>number</code></li>
                <li><code>B.x</code> may be <code>number | string</code></li>
            </ul>
        </li>
        <br/>
        <li>The only valid value that satisfies both is: <code>number</code>
        </li>
        <br/>
        <li>If no overlap exists, the type becomes <code>never</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection Producing <code>never</code> (Incompatible Types)</b></li>
<pre><code class="language-ts line-numbers">type A = { x: string };
type B = { x: number };

type Impossible = A &amp; B;  // { x: string &amp; number } → never
</code></pre>
    <br/>
    <ul>
        <li>A value cannot be <code>string</code> and <code>number</code> at the same time.</li>
        <br/>
        <li>Thus the combined property becomes <code>string &amp; number</code>, which resolves to <code>never</code>.</li>
        <br/>
        <li>This means <code>Impossible</code> has no possible valid values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection Types vs Interfaces</b></li>
    <br/>
    <ul>
        <li>Intersection types are compositional — you combine multiple types into bigger ones.</li>
        <br/>
        <li>Interfaces use <code>extends</code> (inheritance), while intersections use <code>&amp;</code> (composition).</li>
        <br/>
        <li>Example comparison:</li>
    </ul>
<pre><code class="language-ts line-numbers">interface A { x: number }
interface B { y: number }

type C = A &amp; B;
// Equivalent to:
interface D extends A, B {}
</code></pre>
    <br/>
    <ul>
        <li>However, intersections work with:
            <ul>
                <li>Unions</li>
                <li>Function types</li>
                <li>Primitive types</li>
                <li>Mapped types</li>
            </ul>
        </li>
        <br/>
        <li>Therefore, intersection types are more flexible and more expressive than interface inheritance alone.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Aliases for Strings, Numbers, or Enums</b></li>
<pre><code class="language-ts line-numbers">type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

type Port = 80 | 443 | 8080;
</code></pre>
    <br/>
    <ul>
        <li>Creates powerful compile-time constraints on accepted values.</li>
        <li>Helps eliminate invalid inputs early.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> with <code>type</code></b></li>
<pre><code class="language-ts line-numbers">const config = {
    host: 'localhost',
    port: 3000
};

type Config = typeof config;
</code></pre>
    <br/>
    <ul>
        <li>The <code>type</code> keyword combines perfectly with <code>typeof</code> to derive types from runtime objects.</li>
        <li>This prevents duplicate definitions and keeps types consistent with real code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type Response&lt;T&gt; = {
    data: T;
    error: string | null;
};

type UserResponse = Response&lt;{ id: number; name: string }&gt;;
</code></pre>
    <br/>
    <ul>
        <li>Type aliases can be generic and work similarly to generic interfaces.</li>
        <li>Extremely useful for reusable API or library types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Mapped Types Using <code>type</code></b></li>
<pre><code class="language-ts line-numbers">type ReadonlyObject&lt;T&gt; = {
    readonly [K in keyof T]: T[K];
};

type FullUser = { id: number; name: string };
type ReadonlyUser = ReadonlyObject&lt;FullUser&gt;;
</code></pre>
    <br/>
    <ul>
        <li>Mapped types allow programmatic transformations of types.</li>
        <li>Type aliases are the foundation for most advanced TS utilities.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison: <code>type</code> vs <code>interface</code></b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th><code>type</code></th>
                <th><code>interface</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Can define unions</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Can define primitives</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Supports declaration merging</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Mapped types</td>
                <td>Yes</td>
                <td>Limited</td>
            </tr>
            <tr>
                <td>Extending others</td>
                <td>With <code>&amp;</code></td>
                <td>With <code>extends</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Use <code>type</code> for unions, intersections, and advanced type transformations.</li>
        <li>Use <code>interface</code> for object shapes needing merging or class implementation.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-everyday-types">Everyday Types</h3>
<ol>
    <li><b>Primitive Types</b></li>
<pre><code class="language-ts line-numbers">let age: number = 25;
let name: string = "Alice";
let isActive: boolean = true;
</code></pre>
    <br/>
    <ul>
        <li>Primitive types represent basic values.</li>
        <li>They include: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, and <code>symbol</code>.</li>
        <li>TypeScript adds optional type annotations to improve clarity and safety.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Arrays</b></li>
<pre><code class="language-ts line-numbers">let numbers: number[] = [1, 2, 3];
let names: Array&lt;string&gt; = ["Alice", "Bob"];
</code></pre>
    <br/>
    <ul>
        <li>Two syntaxes exist: <code>T[]</code> and <code>Array&lt;T&gt;</code>.</li>
        <li>Both are equivalent — choose whichever improves readability.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Objects</b></li>
<pre><code class="language-ts line-numbers">let user: {
    id: number;
    name: string;
    active: boolean;
} = {
    id: 1,
    name: "Alice",
    active: true
};
</code></pre>
    <br/>
    <ul>
        <li>TypeScript supports <u>structural typing</u>: objects must contain certain properties, regardless of their origin.</li>
        <li>Object types can be declared inline or with type aliases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Optional and Readonly Properties</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name?: string;              // optional
    readonly active: boolean;   // cannot be modified
};
</code></pre>
    <br/>
    <ul>
        <li>Optional properties may be omitted.</li>
        <li>Readonly properties cannot be reassigned after creation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions</b></li>
<pre><code class="language-ts line-numbers">function add(a: number, b: number): number {
    return a + b;
}

const greet = (name: string): void =&gt; {
    console.log("Hello " + name);
};
</code></pre>
    <br/>
    <ul>
        <li>Function type annotations include parameter types and return types.</li>
        <li><code>void</code> indicates the function returns nothing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type Add = (x: number, y: number) =&gt; number;

const sum: Add = (a, b) =&gt; a + b;
</code></pre>
    <br/>
    <ul>
        <li>Function signatures are reusable via type aliases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Union Types</b></li>
<pre><code class="language-ts line-numbers">let value: number | string;

value = 42;
value = "hello";
</code></pre>
    <br/>
    <ul>
        <li>A union type allows a value to be one of several types.</li>
        <li>Useful when variables accept multiple formats.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Narrowing</b></li>
<pre><code class="language-ts line-numbers">function printValue(v: number | string) {
    if (typeof v === "string") {
        console.log(v.toUpperCase());
    } else {
        console.log(v.toFixed(2));
    }
}
</code></pre>
    <br/>
    <ul>
        <li>TypeScript "narrows" a union type based on conditions.</li>
        <li>Common narrowing tools include <code>typeof</code>, <code>instanceof</code>, and <code>in</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type ID = number;
type Point = { x: number; y: number; };
</code></pre>
    <br/>
    <ul>
        <li><code>type</code> gives reusable names to simple or complex types.</li>
        <li>Highly useful for domain modeling and clean code organization.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Interfaces</b></li>
<pre><code class="language-ts line-numbers">interface Person {
    id: number;
    name: string;
}
</code></pre>
    <br/>
    <ul>
        <li>Interfaces describe object shapes and support extension.</li>
        <li>They are similar to type aliases but provide interface merging and class implementation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Literal Types</b></li>
<pre><code class="language-ts line-numbers">let direction: "left" | "right" | "up" | "down";
</code></pre>
    <br/>
    <ul>
        <li>Variables can be restricted to specific literal values.</li>
        <li>Literal types are heavily used in modern TypeScript to create precise APIs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Nullable Types</b></li>
<pre><code class="language-ts line-numbers">let maybe: string | null = null;
</code></pre>
    <br/>
    <ul>
        <li>Combine types with <code>null</code> or <code>undefined</code> to model optional or missing data.</li>
        <li>Helps enforce safer handling of "empty" values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Enums</b></li>
<pre><code class="language-ts line-numbers">enum Status {
    Success,
    Error,
    Loading
}
</code></pre>
    <br/>
    <ul>
        <li>Enums create real runtime objects, unlike most TypeScript types.</li>
        <li>Useful for named constants, but constant unions are often preferred.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Tuples</b></li>
<pre><code class="language-ts line-numbers">let point: [number, number] = [10, 20];
</code></pre>
    <br/>
    <ul>
        <li>Tuples represent fixed-length arrays with typed positions.</li>
        <li>Useful for pairs, coordinate systems, or function return values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Any, Unknown, and Never</b></li>
<pre><code class="language-ts line-numbers">let anything: any;
let data: unknown;
function fail(msg: string): never {
    throw new Error(msg);
}
</code></pre>
    <br/>
    <ul>
        <li><code>any</code>: opt-out of the type system (dangerous).</li>
        <li><code>unknown</code>: safer alternative requiring type checks.</li>
        <li><code>never</code>: represents values that never occur (e.g., errors, infinite loops).</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-more-on-functions">More on Functions</h3>
<ol>
    <li><b>Function Parameter Types</b></li>
<pre><code class="language-ts line-numbers">function greet(name: string, age: number): void {
    console.log(`Hello ${name}, age ${age}`);
}
</code></pre>
    <br/>
    <ul>
        <li>Every parameter must have a known type (explicit or inferred).</li>
        <li>TypeScript enforces parameter count and type correctness.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Optional Parameters</b></li>
<pre><code class="language-ts line-numbers">function log(message: string, userId?: number) {
    console.log(message, userId ?? "anonymous");
}

log("Hello");
log("Hi", 42);
</code></pre>
    <br/>
    <ul>
        <li><code>?</code> marks a parameter as optional.</li>
        <li>Typed as <code>T | undefined</code> internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Default Parameters</b></li>
<pre><code class="language-ts line-numbers">function multiply(a: number, b: number = 1) {
    return a * b;
}

multiply(5);  // 5
</code></pre>
    <br/>
    <ul>
        <li>Defaults provide a fallback when the caller omits a parameter.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Rest Parameters</b></li>
<pre><code class="language-ts line-numbers">function sum(...values: number[]): number {
    return values.reduce((a, b) =&gt; a + b, 0);
}

sum(1, 2, 3, 4);
</code></pre>
    <br/>
    <ul>
        <li>Rest parameters allow variable-length arguments.</li>
        <li>The type must be an array type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Return Types</b></li>
<pre><code class="language-ts line-numbers">function isEven(n: number): boolean {
    return n % 2 === 0;
}
</code></pre>
    <br/>
    <ul>
        <li>Return types can be inferred, but explicit typing improves clarity.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Anonymous and Arrow Functions</b></li>
<pre><code class="language-ts line-numbers">const double = (x: number): number =&gt; x * 2;

const logger = function(message: string): void {
    console.log(message);
};
</code></pre>
    <br/>
    <ul>
        <li>Arrow functions inherit <code>this</code> from their surrounding scope.</li>
        <li>Anonymous functions are useful for callbacks or inline logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Overloads</b></li>
<pre><code class="language-ts line-numbers">function format(value: number): string;
function format(value: string): string;
function format(value: number | string) {
    return `Value: ${value}`;
}

format(10);
format("hello");
</code></pre>
    <br/>
    <ul>
        <li>Overloads define multiple allowed call signatures.</li>
        <li>The implementation must handle all combined cases.</li>
        <li>Useful for flexible function APIs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Types</b></li>
<pre><code class="language-ts line-numbers">type Comparator = (a: number, b: number) =&gt; number;

const compare: Comparator = (x, y) =&gt; x - y;
</code></pre>
    <br/>
    <ul>
        <li>Function types can be reused via <code>type</code> or <code>interface</code>.</li>
        <li>This improves consistency across codebases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions as Arguments</b></li>
<pre><code class="language-ts line-numbers">function applyOperation(a: number, b: number, op: (x: number, y: number) =&gt; number) {
    return op(a, b);
}

applyOperation(3, 4, (x, y) =&gt; x + y);
</code></pre>
    <br/>
    <ul>
        <li>Functional patterns are natural in TypeScript due to strong typing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Functions</b></li>
<pre><code class="language-ts line-numbers">function identity&lt;T&gt;(value: T): T {
    return value;
}

const result = identity&lt;string&gt;("hello");
</code></pre>
    <br/>
    <ul>
        <li>Generics allow functions to work with any type while preserving type safety.</li>
        <li>The type parameter <code>&lt;T&gt;</code> is inferred or explicit.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Constraints</b></li>
<pre><code class="language-ts line-numbers">function getLength&lt;T extends { length: number }&gt;(item: T) {
    return item.length;
}

getLength("hello");
getLength([1, 2, 3]);
</code></pre>
    <br/>
    <ul>
        <li>Constraints restrict which types are allowed as <code>T</code>.</li>
        <li>This enables more expressive type-safe abstractions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Contextual Typing</b></li>
<pre><code class="language-ts line-numbers">const nums = [1, 2, 3];

nums.forEach(n =&gt; console.log(n.toFixed(2)));
</code></pre>
    <br/>
    <ul>
        <li>TypeScript infers types for anonymous functions based on their context.</li>
        <li>The callback receives <code>n: number</code> automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>this</code> in Functions</b></li>
<pre><code class="language-ts line-numbers">const obj = {
    value: 10,
    getValue() {
        return this.value; // `this` is obj
    }
};
</code></pre>
    <br/>
    <ul>
        <li>Functions inside objects infer <code>this</code> automatically.</li>
        <li>Arrow functions do not bind <code>this</code> — they use the outer value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Callable and Constructable Objects</b></li>
<pre><code class="language-ts line-numbers">interface Callable {
    (msg: string): void;         // callable
    description: string;         // property
}

const fn: Callable = (m: string) =&gt; console.log(m);
fn.description = "Logger function";
</code></pre>
    <br/>
    <ul>
        <li>Functions in JS can have both call signatures and properties.</li>
        <li>TypeScript fully supports these patterns using interfaces.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions That Return Functions</b></li>
<pre><code class="language-ts line-numbers">function createMultiplier(factor: number) {
    return (n: number) =&gt; n * factor;
}

const double = createMultiplier(2);
</code></pre>
    <br/>
    <ul>
        <li>Higher-order functions are typed naturally using nested signatures.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-object-types">Object Types</h3>
<ol>
    <li><b>Basic Object Types</b></li>
<pre><code class="language-ts line-numbers">let user: {
    id: number;
    name: string;
    active: boolean;
} = {
    id: 1,
    name: "Alice",
    active: true
};
</code></pre>
    <br/>
    <ul>
        <li>This object must contain all three properties with the correct types.</li>
        <li>Extra properties are usually not allowed without special typing (see excess property checks).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Optional Properties</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name?: string;   // optional
};
</code></pre>
    <br/>
    <ul>
        <li>Optional properties may be omitted when creating an object.</li>
        <li>The type becomes <code>string | undefined</code> internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Readonly Properties</b></li>
<pre><code class="language-ts line-numbers">type Config = {
    readonly host: string;
    readonly port: number;
};
</code></pre>
    <br/>
    <ul>
        <li><code>readonly</code> prevents properties from being reassigned after initialization.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Nested Object Types</b></li>
<pre><code class="language-ts line-numbers">type Product = {
    id: number;
    details: {
        name: string;
        price: number;
    };
};
</code></pre>
    <br/>
    <ul>
        <li>Object types can be nested to model complex structures.</li>
        <li>This is common in APIs, form handling, or domain models.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Object Types with Methods</b></li>
<pre><code class="language-ts line-numbers">type Point = {
    x: number;
    y: number;
    move(dx: number, dy: number): void;
};
</code></pre>
    <br/>
    <ul>
        <li>Methods can be defined directly within object types.</li>
        <li>TypeScript checks parameter and return types during usage.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Aliases for Object Types</b></li>
<pre><code class="language-ts line-numbers">type Address = {
    street: string;
    city: string;
    country: string;
};
</code></pre>
    <br/>
    <ul>
        <li>Type aliases allow naming reusable object type definitions.</li>
        <li>They improve readability and reduce duplication.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection-Based Object Composition</b></li>
<pre><code class="language-ts line-numbers">type HasID = { id: number };
type HasName = { name: string };

type User = HasID &amp; HasName;
</code></pre>
    <br/>
    <ul>
        <li>Intersections combine smaller object fragments into larger, more detailed structures.</li>
        <li>Promotes modular design and DRY principles.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Index Signatures (Dynamic Object Keys)</b></li>
<pre><code class="language-ts line-numbers">type Scores = {
    [player: string]: number;
};

let game: Scores = {
    Alice: 10,
    Bob: 8,
    Charlie: 12
};
</code></pre>
    <br/>
    <ul>
        <li>Use index signatures when the keys are unknown ahead of time.</li>
        <li>Each key must have a value of the specified type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Excess Property Checks</b></li>
<pre><code class="language-ts line-numbers">type User = { id: number; name: string };

let u: User = {
    id: 1,
    name: "Alice",
    // age: 30   ❌ Error: extra property
};
</code></pre>
    <br/>
    <ul>
        <li>TypeScript checks for unexpected properties when assigning literal objects.</li>
        <li>This catches typos and structural mismatches early.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>in</code> for Object Type Narrowing</b></li>
<pre><code class="language-ts line-numbers">type Fish = { swim: () =&gt; void };
type Bird = { fly: () =&gt; void };

function move(animal: Fish | Bird) {
    if ("swim" in animal) {
        animal.swim();
    } else {
        animal.fly();
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>in</code> operator narrows union object types based on property existence.</li>
        <li>Useful for discriminated unions and polymorphic behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Object Type Compatibility</b></li>
<pre><code class="language-ts line-numbers">type Animal = { name: string };
type Dog = { name: string; bark: () =&gt; void };

let a: Animal = { name: "Spike" };
let d: Dog = { name: "Buddy", bark() {} };

a = d;   // ✔ OK (Dog has at least the properties Animal requires)
</code></pre>
    <br/>
    <ul>
        <li>TypeScript uses <b>structural typing</b> — only property shapes matter.</li>
        <li>Extra properties are allowed when assigning larger objects to smaller ones.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Readonly vs Mutable Object Types</b></li>
<pre><code class="language-ts line-numbers">type MutablePoint = { x: number; y: number };
type ReadonlyPoint = {
    readonly x: number;
    readonly y: number;
};
</code></pre>
    <br/>
    <ul>
        <li>Readonly object types prevent property reassignment, offering immutability guarantees.</li>
    </ul>
    <br/>
    <br/>


    <li><b>"Object" vs "object" vs "{}"</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>object</code></td>
                <td>Any non-primitive value</td>
                <td><code>{}, [], function() {}</code></td>
            </tr>
            <tr>
                <td><code>Object</code></td>
                <td>Type of most built-in objects (rarely used)</td>
                <td><code>new String("x")</code></td>
            </tr>
            <tr>
                <td><code>{}</code></td>
                <td>Any non-nullish value</td>
                <td><code>42, "hi", {}</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li><code>object</code> is preferred when you want "not a primitive".</li>
        <li><code>{}</code> is extremely permissive and rarely used intentionally.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-classes">Classes</h3>
<ol>
    <li><b>Basic Class Declaration</b></li>
<pre><code class="language-ts line-numbers">class User {
    id: number;
    name: string;

    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }

    greet() {
        console.log(`Hello, ${this.name}`);
    }
}

const u = new User(1, "Alice");
u.greet();
</code></pre>
    <br/>
    <ul>
        <li><code>constructor</code> is invoked when creating an instance.</li>
        <li>Properties must be declared before assignment unless using parameter properties.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Visibility Modifiers</b></li>
<pre><code class="language-ts line-numbers">class Person {
    public name: string;   // accessible everywhere
    private age: number;   // accessible inside the class only
    protected id: number;  // accessible inside class + subclasses

    constructor(name: string, age: number, id: number) {
        this.name = name;
        this.age = age;
        this.id = id;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>public</code> — accessible from anywhere (default).</li>
        <li><code>private</code> — only accessible inside the class.</li>
        <li><code>protected</code> — accessible in the class and its subclasses.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Read-only Properties</b></li>
<pre><code class="language-ts line-numbers">class Config {
    readonly host: string = "localhost";
    readonly port: number;

    constructor(port: number) {
        this.port = port;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>readonly</code> prevents reassignment after initialization.</li>
        <li>Useful for configuration objects and constants.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Parameter Properties (Shorthand)</b></li>
<pre><code class="language-ts line-numbers">class Point {
    constructor(
        public x: number,
        public y: number
    ) {}
}

const p = new Point(10, 20);
</code></pre>
    <br/>
    <ul>
        <li>Declares and initializes properties directly in the constructor.</li>
        <li>Reduces boilerplate and improves readability.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Getters and Setters</b></li>
<pre><code class="language-ts line-numbers">class Rectangle {
    constructor(private _width: number, private _height: number) {}

    get area() {
        return this._width * this._height;
    }

    set width(value: number) {
        if (value &lt;= 0) throw new Error("Invalid width");
        this._width = value;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Getters provide computed properties.</li>
        <li>Setters allow validation upon assignment.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Static Properties and Methods</b></li>
<pre><code class="language-ts line-numbers">class MathUtils {
    static PI = 3.14;

    static double(n: number) {
        return n * 2;
    }
}

console.log(MathUtils.PI);
console.log(MathUtils.double(10));
</code></pre>
    <br/>
    <ul>
        <li>Static members belong to the class itself, not instances.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Class Inheritance</b></li>
<pre><code class="language-ts line-numbers">class Animal {
    constructor(public name: string) {}

    move() {
        console.log(`${this.name} moves`);
    }
}

class Dog extends Animal {
    bark() {
        console.log("Woof!");
    }
}

const d = new Dog("Buddy");
d.move();
d.bark();
</code></pre>
    <br/>
    <ul>
        <li><code>extends</code> allows one class to inherit from another.</li>
        <li>Subclasses can access <code>public</code> and <code>protected</code> members.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Method Overriding</b></li>
<pre><code class="language-ts line-numbers">class Base {
    greet() {
        console.log("Hello from Base");
    }
}

class Derived extends Base {
    override greet() {
        console.log("Hello from Derived");
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>override</code> ensures that a method truly overrides a parent method.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Abstract Classes</b></li>
<pre><code class="language-ts line-numbers">abstract class Shape {
    abstract area(): number;
}

class Circle extends Shape {
    constructor(public radius: number) { super(); }
    area() {
        return Math.PI * this.radius ** 2;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Abstract classes cannot be instantiated.</li>
        <li>They define required methods that subclasses must implement.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Implementing Interfaces</b></li>
<pre><code class="language-ts line-numbers">interface Logger {
    log(message: string): void;
}

class ConsoleLogger implements Logger {
    log(msg: string) {
        console.log(msg);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Classes can implement interfaces to guarantee method and property structure.</li>
        <li>Provides compile-time contracts for class behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Type vs Instance Type</b></li>
<pre><code class="language-ts line-numbers">class Car {
    constructor(public brand: string) {}
}

type CarInstance = Car;              // instance type
type CarConstructor = typeof Car;    // constructor function type
</code></pre>
    <br/>
    <ul>
        <li><code>Car</code> refers to the instance type.</li>
        <li><code>typeof Car</code> refers to the constructor function type.</li>
        <li>Useful for dependency injection, factories, or meta-programming.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Private Fields (# syntax)</b></li>
<pre><code class="language-ts line-numbers">class Counter {
    #count = 0;   // hard private, JS-level

    increment() {
        this.#count++;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>#private</code> fields are enforced by JavaScript itself.</li>
        <li>They differ from <code>private</code>, which is enforced by TypeScript only.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-constructor-vs-instance">Constructor Type vs Instance Type</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In TypeScript, classes create <u>two types simultaneously</u>:</li>
        <br/>
        <ul>
            <li><b>Instance Type</b> — the type of objects created by <code>new</code>.</li>
            <li><b>Constructor Type</b> — the type of the class constructor function itself.</li>
        </ul>
        <br/>
        <li>These two types behave differently and are used in different contexts.</li>
        <br/>
        <li>Understanding the distinction is essential for dependency injection, factories, generics, and meta-programming patterns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Instance Type</b></li>
<pre><code class="language-ts line-numbers">class User {
    constructor(public id: number, public name: string) {}
}

let u: User = new User(1, "Alice");
</code></pre>
    <br/>
    <ul>
        <li><code>User</code> refers to the <u>type of instances</u> created by <code>new User()</code>.</li>
        <li>This includes all instance properties and methods.</li>
        <li>It does <u>not</u> include static members or the constructor signature.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Type</b></li>
<pre><code class="language-ts line-numbers">type UserConstructor = typeof User;
</code></pre>
    <br/>
    <ul>
        <li><code>typeof User</code> refers to the <b>constructor function</b> itself.</li>
        <li>This includes:</li>
        <ul>
            <li>the <code>new (...args)</code> signature</li>
            <li>static properties</li>
            <li>the constructor's parameter types</li>
        </ul>
        <br/>
        <li>Constructor types are useful for passing classes as values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Comparing Both Types</b></li>
<pre><code class="language-ts line-numbers">class Car {
    static company = "Tesla";

    constructor(public model: string) {}
}

type CarInstance = Car;             // instance type
type CarConstructor = typeof Car;   // constructor type
</code></pre>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Instance Type (<code>Car</code>)</th>
                <th>Constructor Type (<code>typeof Car</code>)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Instance properties</td>
                <td>✔ Available</td>
                <td>✘ Not available</td>
            </tr>
            <tr>
                <td>Instance methods</td>
                <td>✔ Available</td>
                <td>✘ Not available</td>
            </tr>
            <tr>
                <td>Static members</td>
                <td>✘ Not available</td>
                <td>✔ Available</td>
            </tr>
            <tr>
                <td>Constructor signature</td>
                <td>✘ No</td>
                <td>✔ Yes</td>
            </tr>
            <tr>
                <td>Used with <code>new</code></td>
                <td>✘ No</td>
                <td>✔ Yes</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Using Constructor Types for Factories</b></li>
<pre><code class="language-ts line-numbers">function createInstance(ctor: { new (...args: any[]): any }) {
    return new ctor();
}

class A { constructor() { console.log("A created"); } }
class B { constructor() { console.log("B created"); } }

createInstance(A);
createInstance(B);
</code></pre>
    <br/>
    <ul>
        <li>Factories often accept constructor types rather than instances.</li>
        <li>TypeScript enforces that the provided argument supports <code>new</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Typing Class Constructors More Strictly</b></li>
<pre><code class="language-ts line-numbers">interface UserConstructor {
    new (id: number, name: string): { id: number; name: string };
}

function createUser(ctor: UserConstructor) {
    return new ctor(1, "Alice");
}
</code></pre>
    <br/>
    <ul>
        <li>You can define detailed constructor signatures using interfaces.</li>
        <li>This is extremely powerful for plugins, DI containers, and testing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Static Properties Live on the Constructor Type</b></li>
<pre><code class="language-ts line-numbers">class Settings {
    static version = "1.0";
    theme = "light";
}

let s: Settings = new Settings();   // instance type
let C: typeof Settings = Settings;  // constructor type

console.log(C.version); // OK
console.log(s.theme);   // OK
</code></pre>
    <br/>
    <ul>
        <li>Static fields belong to the constructor type.</li>
        <li>Instance fields belong to the instance type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Types and Dependency Injection</b></li>
<pre><code class="language-ts line-numbers">function runService(ctor: { new(): Service }) {
    const service = new ctor();
    service.run();
}

class Service {
    run() { console.log("Running service..."); }
}

runService(Service);
</code></pre>
    <br/>
    <ul>
        <li>DI frameworks frequently accept constructor types to dynamically create instances.</li>
        <li>TypeScript ensures correctness via <code>new()</code> signatures.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Types with Generics</b></li>
<pre><code class="language-ts line-numbers">function create&lt;T&gt;(ctor: { new (...args: any[]): T }): T {
    return new ctor();
}

class Logger { log() { console.log("log"); } }

const logger = create(Logger);
</code></pre>
    <br/>
    <ul>
        <li>Generics ensure the returned instance has the correct type.</li>
        <li>Used widely in factory abstractions and IoC containers.</li>
    </ul>
    <br/>
    <br/>


    <li><b>A Class Is Both a Value and a Type</b></li>
<pre><code class="language-ts line-numbers">class Example {}

type T1 = Example;     // instance type
const T2 = Example;    // constructor value
</code></pre>
    <br/>
    <ul>
        <li><code>Example</code> (in a type position) = the instance type.</li>
        <li><code>Example</code> (in a value position) = the constructor function.</li>
        <li>This duality is unique compared to many other languages.</li>
    </ul>
    <br/>
    <br/>

        <li><b>Constructor Type vs Instance Type</b></li>
<pre><code class="language-ts line-numbers">class User {
    static role = "user-class";

    constructor(public id: number, public name: string) {}

    greet() {
        console.log(`Hello, ${this.name}`);
    }
}

// 1) Instance type: "what new User() returns"
let instance: User = new User(1, "Alice");

instance.id;        // OK - instance property
instance.name;      // OK - instance property
instance.greet();   // OK - instance method
// instance.role;   // Error: 'role' is static (on the constructor, not instance)


// 2) Constructor type: "the class itself (function + statics)"
let Ctor: typeof User = User;

Ctor.role;                          // OK - static property
const other = new Ctor(2, "Bob");   // OK - calling the constructor

// other has the instance type:
other.id;           // OK
other.greet();      // OK


// 3) Using constructor type in a factory
function createAndGreet(ctor: typeof User, id: number, name: string) {
    const u = new ctor(id, name); // we can 'new' the constructor
    u.greet();
}

createAndGreet(User, 3, "Charlie");
</code></pre>
    <br/>
    <ul>
        <li><code>User</code> (as a type) describes the <b>instance</b> you get from <code>new User(...)</code> (instance fields + methods, no statics, no constructor).</li>
        <br/>
        <li><code>typeof User</code> (as a type) describes the <b>constructor</b> itself (the class function):
            <ul>
                <li>has <code>new (...)</code> so you can construct instances</li>
                <li>contains static members like <code>role</code></li>
                <li>does <b>not</b> have instance fields like <code>id</code> or instance methods like <code>greet()</code></li>
            </ul>
        </li>
        <br/>
        <li>Use <code>User</code> when you are talking about objects (instances), and <code>typeof User</code> when you are passing the class itself around (e.g. factories, DI).</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-generics">Generics</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>They are written using angle brackets <code>&lt;T&gt;</code>, <code>&lt;T, U&gt;</code> and can be used on:
            <ul>
                <li>functions</li>
                <li>type aliases</li>
                <li>interfaces</li>
                <li>classes</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Generic Function</b></li>
<pre><code class="language-ts line-numbers">function identity&lt;T&gt;(value: T): T {
    return value;
}

const a = identity(10);        // T = number
const b = identity("hello");   // T = string
</code></pre>
    <br/>
    <ul>
        <li><code>T</code> is a type parameter — a placeholder for "some type".</li>
        <li>When you call <code>identity</code>, TypeScript infers <code>T</code> from the argument.</li>
        <li>The function now returns the <u>same type</u> it receives, without losing information.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Explicit vs Inferred Type Arguments</b></li>
<pre><code class="language-ts line-numbers">identity&lt;number&gt;(123);    // explicit
identity("hello");        // inferred (T = string)
</code></pre>
    <br/>
    <ul>
        <li>Usually, TypeScript <u>infers</u> generic types for you.</li>
        <li>You can specify them explicitly when inference fails or for clarity.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type Box&lt;T&gt; = {
    value: T;
};

const numberBox: Box&lt;number&gt; = { value: 42 };
const stringBox: Box&lt;string&gt; = { value: "hi" };
</code></pre>
    <br/>
    <ul>
        <li><code>Box&lt;T&gt;</code> is a template for a type, you plug in a concrete type for <code>T</code>.</li>
        <li>This avoids repeating similar structures for different types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Interfaces</b></li>
<pre><code class="language-ts line-numbers">interface Repository&lt;T&gt; {
    findById(id: number): T | null;
    save(entity: T): void;
}

type User = { id: number; name: string };

const userRepo: Repository&lt;User&gt; = {
    findById(id) {
        return { id, name: "Alice" };
    },
    save(user) {
        console.log("Saving", user.name);
    }
};
</code></pre>
    <br/>
    <ul>
        <li>Interfaces can be generic and represent generic APIs (e.g. repositories, services, collections).</li>
        <li><code>Repository&lt;User&gt;</code> is a concrete interface where <code>T = User</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Classes</b></li>
<pre><code class="language-ts line-numbers">class Stack&lt;T&gt; {
    private items: T[] = [];

    push(item: T) {
        this.items.push(item);
    }

    pop(): T | undefined {
        return this.items.pop();
    }
}

const numStack = new Stack&lt;number&gt;();
numStack.push(1);
numStack.push(2);

const strStack = new Stack&lt;string&gt;();
strStack.push("a");
strStack.push("b");
</code></pre>
    <br/>
    <ul>
        <li>Generic classes are containers that can store values of a configurable type.</li>
        <li>The same class <code>Stack</code> is reused for many types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constrained Generics with <code>extends</code></b></li>
<pre><code class="language-ts line-numbers">function getLength&lt;T extends { length: number }&gt;(value: T): number {
    return value.length;
}

getLength("hello");         // ✔ string has length
getLength([1, 2, 3]);       // ✔ array has length
// getLength(123);          // ❌ number has no length
</code></pre>
    <br/>
    <ul>
        <li><code>T extends { length: number }</code> restricts <code>T</code> to types that have a <code>length</code> property.</li>
        <li>If you pass a type that doesn't satisfy the constraint, TypeScript errors.</li>
        <li>Constraints are important for using properties safely in generic code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Keyof and Indexed Access with Generics</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
};

type UserKey = keyof User;              // "id" | "name"

function getProp&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

const u: User = { id: 1, name: "Alice" };

const idValue = getProp(u, "id");
const nameValue = getProp(u, "name");
// getProp(u, "age");                   // ❌ Error: "age" not in "id" | "name"
</code></pre>
    <br/>
    <ul>
        <li><code>keyof T</code> produces a union of property names of <code>T</code>.</li>
        <li><code>K extends keyof T</code> ensures <code>key</code> is a valid property name.</li>
        <li><code>T[K]</code> is an <u>indexed access type</u> — "type of property K on T".</li>
        <li>This pattern is the basis of many advanced utility types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Default Type Parameters</b></li>
<pre><code class="language-ts line-numbers">type ApiResponse&lt;T = unknown&gt; = {
    data: T;
    error: string | null;
};

const r1: ApiResponse = {
    data: 123,          // T = unknown, but still typed
    error: null
};

const r2: ApiResponse&lt;{ id: number }&gt; = {
    data: { id: 1 },
    error: null
};
</code></pre>
    <br/>
    <ul>
        <li><code>&lt;T = unknown&gt;</code> gives <code>T</code> a default type when the user does not specify one.</li>
        <li>Similar to default values for function parameters.</li>
        <li>Useful for APIs where the generic is often omitted.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Utility Types (Built-in)</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    email?: string;
};

type ReadonlyUser = Readonly&lt;User&gt;;
type PartialUser = Partial&lt;User&gt;;
type UserWithoutEmail = Omit&lt;User, "email"&gt;;
</code></pre>
    <br/>
    <ul>
        <li>TypeScript ships with many generic <b>utility types</b> (all defined using generics):</li>
        <br/>
        <table>
            <thead>
                <tr>
                    <th>Utility</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>Readonly&lt;T&gt;</code></td>
                    <td>Makes all properties of <code>T</code> readonly</td>
                    <td><code>Readonly&lt;User&gt;</code></td>
                </tr>
                <tr>
                    <td><code>Partial&lt;T&gt;</code></td>
                    <td>Makes all properties optional</td>
                    <td><code>Partial&lt;User&gt;</code></td>
                </tr>
                <tr>
                    <td><code>Pick&lt;T, K&gt;</code></td>
                    <td>Picks only selected keys</td>
                    <td><code>Pick&lt;User, "id" | "name"&gt;</code></td>
                </tr>
                <tr>
                    <td><code>Omit&lt;T, K&gt;</code></td>
                    <td>Removes selected keys</td>
                    <td><code>Omit&lt;User, "email"&gt;</code></td>
                </tr>
                <tr>
                    <td><code>Record&lt;K, T&gt;</code></td>
                    <td>Object type with keys <code>K</code> and value type <code>T</code></td>
                    <td><code>Record&lt;string, number&gt;</code></td>
                </tr>
            </tbody>
        </table>
        <br/>
    </ul>
    <br/>
    <br/>


    <li><b>Generics with Arrays and Promises</b></li>
<pre><code class="language-ts line-numbers">let nums: Array&lt;number&gt; = [1, 2, 3];

function fetchUser(): Promise&lt;{ id: number; name: string }&gt; {
    return Promise.resolve({ id: 1, name: "Alice" });
}
</code></pre>
    <br/>
    <ul>
        <li><code>Array&lt;T&gt;</code> and <code>Promise&lt;T&gt;</code> are generic types from the standard library.</li>
        <li><code>Promise&lt;User&gt;</code> means "a promise that eventually yields a <code>User</code>".</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Constraints with Multiple Parameters</b></li>
<pre><code class="language-ts line-numbers">function merge&lt;A extends object, B extends object&gt;(a: A, b: B): A &amp; B {
    return { ...a, ...b };
}

const merged = merge(
    { id: 1, name: "Alice" },
    { active: true }
);
// type of merged: { id: number; name: string } &amp; { active: boolean }
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>A</code> and <code>B</code> must be objects.</li>
        <li>The result type is an intersection <code>A &amp; B</code>, containing all properties from both arguments.</li>
        <li>Generics + intersections give powerful composition of object types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic "Shape-Preserving" Functions</b></li>
<pre><code class="language-ts line-numbers">function mapValues&lt;T, U&gt;(
    obj: T,
    fn: (value: T[keyof T]) =&gt; U
): { [K in keyof T]: U } {
    const result: any = {};
    for (const key in obj) {
        result[key] = fn(obj[key]);
    }
    return result;
}

const original = { a: 1, b: 2, c: 3 };
const doubled = mapValues(original, v =&gt; v * 2);
// type of doubled: { a: number; b: number; c: number }
</code></pre>
    <br/>
    <ul>
        <li>This example uses:
            <ul>
                <li>generic parameters <code>T</code>, <code>U</code></li>
                <li><code>keyof T</code> and indexed access</li>
                <li>a mapped type <code>{ [K in keyof T]: U }</code></li>
            </ul>
        </li>
        <br/>
        <li>Generics allow TypeScript to <u>preserve the exact shape</u> of objects while transforming their value types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>When to Use Generics</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Situation</th>
                <th>Example</th>
                <th>Why Generics?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Reusable container</td>
                <td><code>Stack&lt;T&gt;</code>, <code>Box&lt;T&gt;</code></td>
                <td>Same logic for many element types</td>
            </tr>
            <tr>
                <td>Reusable API</td>
                <td><code>Repository&lt;T&gt;</code></td>
                <td>One interface for many domain models</td>
            </tr>
            <tr>
                <td>Transforming types</td>
                <td><code>Readonly&lt;T&gt;</code>, <code>Partial&lt;T&gt;</code></td>
                <td>Programmatic type manipulation</td>
            </tr>
            <tr>
                <td>Safe property access</td>
                <td><code>getProp&lt;T, K&gt;(obj, key)</code></td>
                <td>Prevent typos and invalid keys</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>If you find yourself writing the same function/type for <code>User</code>, <code>Product</code>, <code>Order</code>, etc., it is often a good candidate for generics.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-keyof">The <code>keyof</code> Type Operator</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>keyof</code> is a TypeScript <u>type operator</u> that produces a union of the property names of a type.</li>
        <br/>
        <li>It is used only in <u>type positions</u> (not at runtime).</li>
        <br/>
        <li>Together with indexed access types (<code>T[K]</code>) and generics, <code>keyof</code> is one of the core building blocks for advanced typing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Usage with Object Types</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};

type UserKeys = keyof User;
// type UserKeys = "id" | "name" | "active"
</code></pre>
    <br/>
    <ul>
        <li><code>keyof User</code> becomes a union of all property names on <code>User</code>.</li>
        <li>Here, <code>UserKeys</code> can only be <code>"id"</code>, <code>"name"</code>, or <code>"active"</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>keyof</code> to Type-Safe Property Access</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
};

function getProp&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

const u: User = { id: 1, name: "Alice" };

const id = getProp(u, "id");      // type: number
const name = getProp(u, "name");  // type: string
// getProp(u, "age");             // ❌ Error: "age" not in "id" | "name"
</code></pre>
    <br/>
    <ul>
        <li><code>K extends keyof T</code> ensures that <code>key</code> is a valid property name of <code>T</code>.</li>
        <li><code>T[K]</code> gives the type of that property, fully type-safe.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>keyof</code> with Index Signatures</b></li>
<pre><code class="language-ts line-numbers">type Scores = {
    [player: string]: number;
};

type ScoreKey = keyof Scores;
// type ScoreKey = string | number
</code></pre>
    <br/>
    <ul>
        <li>For string index signatures, <code>keyof</code> usually becomes <code>string | number</code> because JS object keys are treated as strings internally.</li>
        <br/>
        <li>This is why you often see <code>Record&lt;string, T&gt;</code> together with <code>keyof</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>keyof</code> with Arrays and Tuples</b></li>
<pre><code class="language-ts line-numbers">type Numbers = number[];

type NumbersKey = keyof Numbers;
// type NumbersKey = number | "length" | "push" | "pop" | ...

type Point = [number, number];

type PointKey = keyof Point;
// type PointKey = "0" | "1" | "length" | ...
</code></pre>
    <br/>
    <ul>
        <li>For normal arrays, <code>keyof</code> includes numeric indexes (<code>number</code>) and array methods like <code>"length"</code>, <code>"push"</code>, etc.</li>
        <br/>
        <li>For tuples, <code>keyof</code> includes <u>string literal indices</u> like <code>"0"</code>, <code>"1"</code>, plus common array members.</li>
        <br/>
        <li>Because of this, you usually use <code>number</code> (or explicit indices) to index tuples instead of <code>keyof</code> directly.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>keyof</code> and Unions of Object Types</b></li>
<pre><code class="language-ts line-numbers">type Cat = { meow: () =&gt; void; name: string };
type Dog = { bark: () =&gt; void; name: string };

type Pet = Cat | Dog;
type PetKeys = keyof Pet;
// type PetKeys = "name"  | "meow" | "bark"
</code></pre>
    <br/>
    <ul>
        <li>For unions of object types, <code>keyof</code> gives the <b>union of all keys</b>.</li>
        <li>Here, <code>Pet</code> might have <code>"meow"</code> (for <code>Cat</code>) or <code>"bark"</code> (for <code>Dog</code>), and always <code>"name"</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>keyof</code> and Intersections</b></li>
<pre><code class="language-ts line-numbers">type A = { id: number; name: string };
type B = { name: string; active: boolean };

type AB = A &amp; B;
type ABKeys = keyof AB;
// type ABKeys = "id" | "name" | "active"
</code></pre>
    <br/>
    <ul>
        <li>For intersections, the resulting type has <u>all</u> properties, so <code>keyof</code> gives the union of those keys.</li>
        <li>Intersections are often used with <code>keyof</code> to model combined domains.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>keyof</code> Special Cases: <code>any</code> and <code>never</code></b></li>
<pre><code class="language-ts line-numbers">type KAny = keyof any;      // string | number | symbol
type KNever = keyof never;  // never
</code></pre>
    <br/>
    <ul>
        <li><code>keyof any</code> is defined as <code>string | number | symbol</code> (all possible property key types).</li>
        <br/>
        <li><code>keyof never</code> is <code>never</code>, because there is no value of type <code>never</code>, and thus no keys.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining <code>keyof</code> with Indexed Access Types</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};

type UserKey = keyof User;    // "id" | "name" | "active"
type UserValue = User[UserKey];
// type UserValue = number | string | boolean
</code></pre>
    <br/>
    <ul>
        <li><code>User[UserKey]</code> means "the union of the types of all properties of <code>User</code>".</li>
        <li>This pattern is useful when you want "any value from this object type".</li>
    </ul>
    <br/>
    <br/>


    <li><b>Building Utility Types with <code>keyof</code></b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    email?: string;
};

type PickProps&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
};

type UserBasic = PickProps&lt;User, "id" | "name"&gt;;
// type UserBasic = { id: number; name: string; }
</code></pre>
    <br/>
    <ul>
        <li><code>K extends keyof T</code> ensures we only pick existing keys.</li>
        <li><code>[P in K]: T[P]</code> (a mapped type) uses <code>keyof</code> and indexed access to build new object shapes.</li>
        <li>Many built-in utilities like <code>Pick</code>, <code>Omit</code>, <code>Readonly</code>, and <code>Partial</code> are defined using <code>keyof</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>keyof</code> to Constrain APIs</b></li>
<pre><code class="language-ts line-numbers">type Settings = {
    theme: "light" | "dark";
    language: "en" | "de";
    pageSize: number;
};

function updateSetting&lt;K extends keyof Settings&gt;(
    key: K,
    value: Settings[K]
) {
    // ...
}

updateSetting("theme", "dark");         // ✔ OK
updateSetting("pageSize", 20);          // ✔ OK
// updateSetting("language", "fr");     // ❌ Error: "fr" not assignable to "en" | "de"
</code></pre>
    <br/>
    <ul>
        <li><code>keyof</code> lets the function accept only valid setting names.</li>
        <li><code>Settings[K]</code> forces the value to match the exact type for that key.</li>
        <li>This pattern is extremely common for config APIs, Redux-like stores, or form updaters.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-indexed-access">Indexed Access Types (<code>T[K]</code>)</h3>
<ol>
    <li>Indexed access types let you look up the type of a property by its key, using the syntax <code>T[K]</code>.</li>
    <br/>
    <br/>


    <li>You can think of <code>T</code> as an object type, and <code>K</code> as a property name (or union of names).</li>
    <br/>
    <br/>


    <li>Indexed access types are pure <u>type-level</u> operations, they do not exist at runtime.</li>
    <br/>
    <br/>


    <li><b>Basic Example: Single Property</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};

type UserIdType = User["id"];       // number
type UserNameType = User["name"];   // string
</code></pre>
    <br/>
    <br/>


    <li><b>Using Unions as Index Keys</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};

type IdOrName = User["id" | "name"];    // number | string
</code></pre>
    <br/>
    <br/>


    <li><b>Combining with <code>keyof</code>: All Property Values</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};

type UserKey = keyof User;          // "id" | "name" | "active"
type UserValue = User[UserKey];     // number | string | boolean
</code></pre>
    <br/>
    <br/>


    <li><b>Working with Arrays and Tuples</b></li>
<pre><code class="language-ts line-numbers">type Numbers = number[];

type Element = Numbers[number];
// type Element = number

type Point = [number, number, number];

type PointIndex = keyof Point;
// type PointIndex = "0" | "1" | "2" | "length" | ...

type PointElement = Point[number];
// type PointElement = number
</code></pre>
    <br/>
    <ul>
        <li>For arrays, <code>T[number]</code> gives "element type".</li>
        <li>For tuples, <code>T[number]</code> gives a union of all element types.</li>
        <li>This is how built-in helpers like <code>ReturnType</code> and <code>Parameters</code> work internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Nested Indexed Access</b></li>
<pre><code class="language-ts line-numbers">type Product = {
    id: number;
    details: {
        name: string;
        price: number;
    };
};

type ProductDetails = Product["details"];
// { name: string; price: number; }

type ProductPrice = Product["details"]["price"];
// number
</code></pre>
    <br/>
    <ul>
        <li>Indexed access can be chained to drill into nested types.</li>
        <li>This is useful when you want types for deep properties without manually rewriting them.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Indexed Access with Generics</b></li>
<pre><code class="language-ts line-numbers">type GetPropType&lt;T, K extends keyof T&gt; = T[K];

type User = {
    id: number;
    name: string;
};

type UserIdType   = GetPropType&lt;User, "id"&gt;;   // number
type UserNameType = GetPropType&lt;User, "name"&gt;; // string
</code></pre>
    <br/>
    <br/>


    <li><b>Shape-Preserving Functions with <code>T[K]</code></b></li>
<pre><code class="language-ts line-numbers">function pluck&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): T[K][] {
    return keys.map(k =&gt; obj[k]);
}

type User = {
    id: number;
    name: string;
    active: boolean;
};

const u: User = { id: 1, name: "Alice", active: true };

const values = pluck(u, ["id", "name"]);
// type of values: (number | string)[]
</code></pre>
    <br/>
    <ul>
        <li><code>T[K]</code> represents the type of elements in the returned array.</li>
        <li>The compiler knows that:
            <ul>
                <li><code>keys</code> contains valid property names of <code>T</code></li>
                <li>and each element of <code>values</code> is the type of the corresponding property</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Using Indexed Access in Utility Types</b></li>
<pre><code class="language-ts line-numbers">type PickProps&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
};

type User = {
    id: number;
    name: string;
    email: string;
};

type BasicUser = PickProps&lt;User, "id" | "name"&gt;;
// { id: number; name: string; }
</code></pre>
    <br/>
    <ul>
        <li>Mapped types often use <code>T[P]</code> on the right-hand side to copy property types.</li>
        <li>This pattern is the basis for built-in utilities like <code>Pick</code>, <code>Omit</code>, <code>Readonly</code>, and <code>Partial</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Extracting the Type of a Method</b></li>
<pre><code class="language-ts line-numbers">type Service = {
    start(): void;
    stop(code: number): void;
};

type StartType = Service["start"];    // () =&gt; void
type StopType = Service["stop"];      // (code: number) =&gt; void
</code></pre>
    <br/>
    <ul>
        <li>Indexed access works for methods as well: you get the function type.</li>
        <li>This is handy when you want to re-use or transform method signatures.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Value Type of a Dictionary</b></li>
<pre><code class="language-ts line-numbers">type Dictionary = Record&lt;string, number&gt;;

type DictValue = Dictionary[string];
// type DictValue = number
</code></pre>
    <br/>
    <ul>
        <li>For "map-like" types, <code>T[string]</code> or <code>T[number]</code> gives you the value type.</li>
        <li>This is frequently used in libraries dealing with key-value objects.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Indexed Access and Readonly Transformations</b></li>
<pre><code class="language-ts line-numbers">type ReadonlyObject&lt;T&gt; = {
    readonly [K in keyof T]: T[K];
};

type User = {
    id: number;
    name: string;
};

type ReadonlyUser = ReadonlyObject&lt;User&gt;;
// { readonly id: number; readonly name: string; }
</code></pre>
    <br/>
    <ul>
        <li><code>T[K]</code> copies the original property type from <code>T</code> into the new object.</li>
        <li>Here only the modifier (<code>readonly</code>) changes — the underlying property types stay exactly the same.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Index Signatures for Dynamic String Keys</b></li>
    <br/>
    <ul>
        <li>Sometimes you don't know the exact property names in advance, but you do know that <u>all keys are strings</u> and <u>all values share the same type</u>.</li>
        <br/>
        <li>In that case, you can declare an <u>index signature</u> such as <code>[key: string]: string</code> to express:
            <ul>
                <li>"any <code>string</code> can be used as a property name"</li>
                <li>"each property must store a <code>string</code>"</li>
            </ul>
        </li>
        <br/>
        <li>Index signatures are the TypeScript way to model dictionary/map objects, including keys with spaces, dashes, or other special characters.</li>
    </ul>

<pre><code class="language-ts line-numbers">type StringMap = {
    // NOTE: the name `key` here is arbitrary, you can use any identifiers here.
    [key: string]: string;
};

const m: StringMap = {
    "user name": "Alice",
    "user-email": "a@example.com",
};

const a = m["user name"];   // string
const b = m["user-email"];  // string
// const c = m["age"];      // string | undefined (runtime)
</code></pre>

    <br/>
    <ul>
        <li>Any valid JavaScript string can be used as a key: <code>"user name"</code>, <code>"user-email"</code>, <code>"x.y.z"</code>, etc.</li>
        <br/>
        <li>Because such keys are not valid identifiers, you must use <u>bracket notation</u>:
            <ul>
                <li><code>m["user name"]</code> ✔ valid</li>
                <li><code>m.user name</code> ✘ syntax error</li>
            </ul>
        </li>
        <br/>
        <li>The index signature ensures that every property value inside a <code>StringMap</code> is always a <code>string</code>, regardless of how unusual the key is.</li>
        <br/>
        <li>You can also express this pattern using the built-in utility: <code>Record&lt;string, string&gt;</code>.</li>
    </ul>
    <br/>
    <br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-conditional-types">Conditional Types</h3>
<ol>
    <li>Conditional types allow TypeScript to express logic inside the type system.</li>
    <br/>
    <br/>


    <li>The syntax resembles a JavaScript ternary, but applies entirely at compile time:</li>
<pre><code class="language-ts line-numbers">T extends U ? X : Y</code></pre>
    It means: "If <code>T</code> is assignable to <code>U</code>, then the resulting type is <code>X</code>, otherwise <code>Y</code>."
    <br/>
    <br/>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-ts line-numbers">type IsString&lt;T&gt; = T extends string ? "yes" : "no";

type A = IsString&lt;string&gt;;   // "yes"
type B = IsString&lt;number&gt;;   // "no"
</code></pre>
    <br/>
    <ul>
        <li>If <code>T</code> fits the constraint <code>string</code>, the type becomes <code>"yes"</code>.</li>
        <li>Otherwise it becomes <code>"no"</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Conditional Types with Generics</b></li>
<pre><code class="language-ts line-numbers">type Boxed&lt;T&gt; =
    T extends number ? { value: number } :
    T extends string ? { value: string } :
    { value: T };

type X = Boxed&lt;number&gt;;   // { value: number }
type Y = Boxed&lt;string&gt;;   // { value: string }
type Z = Boxed&lt;boolean&gt;;  // { value: boolean }
</code></pre>
    <br/>
    <ul>
        <li>Generic conditional types allow you to branch based on the shape or category of <code>T</code>.</li>
        <li>This is often used in API schemas or serialization libraries.</li>
    </ul>
    <br/><br/>


    <li><b>Distributive Conditional Types</b></li>
    <br/>
    <ul>
        <li>When the checked type <code>T</code> is a union, conditional types automatically distribute over each member.</li>
        <br/>
        <li>This is one of the most powerful and surprising features of the TypeScript type system.</li>
    </ul>

<pre><code class="language-ts line-numbers">type ToArray&lt;T&gt; = T extends any ? T[] : never;

type A = ToArray&lt;string | number&gt;;
// A = string[] | number[]
</code></pre>

    <br/>
    <ul>
        <li>Each union member is processed individually, producing a union of results.</li>
        <li>This is useful for mapping or filtering unions.</li>
    </ul>
    <br/><br/>


    <li><b>Filtering Unions</b></li>
<pre><code class="language-ts line-numbers">type ExtractString&lt;T&gt; = T extends string ? T : never;

type R = ExtractString&lt;string | number | boolean&gt;;
// R = string
</code></pre>
    <br/>
    <ul>
        <li>Conditional types can "pick out" parts of a union.</li>
        <li><code>never</code> removes branches, so only <code>string</code> remains.</li>
    </ul>
    <br/><br/>


    <li><b>Excluding Types</b></li>
<pre><code class="language-ts line-numbers">type ExcludeNumber&lt;T&gt; = T extends number ? never : T;

type R = ExcludeNumber&lt;string | number | boolean&gt;;
// R = string | boolean
</code></pre>
    <br/>
    <ul>
        <li>Conditional types can remove specific members from a union.</li>
        <li>This is exactly how the built-in <code>Exclude&lt;T, U&gt;</code> utility is implemented.</li>
    </ul>
    <br/><br/>


    <li><b>Inferring Types Using <code>infer</code></b></li>
    <br/>
    <ul>
        <li>Conditional types can extract (infer) parts of a type automatically.</li>
        <li><code>infer</code> introduces a type variable whose type is deduced from the structure of the input.</li>
    </ul>

<pre><code class="language-ts line-numbers">type ReturnTypeOf&lt;T&gt; =
    T extends (...args: any[]) =&gt; infer R
        ? R
        : never;

function foo() {
    return { id: 1, name: "Alice" };
}

type R = ReturnTypeOf&lt;typeof foo&gt;;
// { id: number; name: string }
</code></pre>

    <br/>
    <ul>
        <li><code>infer R</code> captures the return type of the function.</li>
        <li>This mechanism powers many of TypeScript's built-in helpers.</li>
    </ul>
    <br/><br/>


    <li><b>Inferring Tuple and Array Element Types</b></li>
<pre><code class="language-ts line-numbers">type ElementOf&lt;T&gt; =
    T extends (infer U)[] ? U : never;

type A = ElementOf&lt;string[]&gt;;   // string
type B = ElementOf&lt;number[]&gt;;   // number
</code></pre>
    <br/>
    <ul>
        <li><code>infer U</code> extracts the element type of an array.</li>
        <li>Useful for generic collections and serialization utilities.</li>
    </ul>
    <br/><br/>


    <li><b>Inferring Function Parameters</b></li>
<pre><code class="language-ts line-numbers">type FirstArg&lt;T&gt; =
    T extends (arg: infer A, ...rest: any[]) =&gt; any
        ? A
        : never;

type F = FirstArg&lt;(x: number, y: string) =&gt; void&gt;;
// number
</code></pre>
    <br/>
    <ul>
        <li>You can pattern-match function signatures and pull out their components.</li>
    </ul>
    <br/><br/>


    <li><b>Conditional Types with <code>readonly</code> and Mutability Checks</b></li>
<pre><code class="language-ts line-numbers">type IsReadonlyArray&lt;T&gt; = T extends readonly any[] ? true : false;

type A = IsReadonlyArray&lt;readonly number[]&gt;;   // true
type B = IsReadonlyArray&lt;number[]&gt;;            // false
</code></pre>
    <br/>
    <ul>
        <li>Conditional types enable "meta" checks such as immutability, tuple-ness, or structure validation.</li>
    </ul>
    <br/><br/>


    <li><b>Real-World Example: Extracting a Promise's Resolved Type</b></li>
<pre><code class="language-ts line-numbers">type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;

type A = UnwrapPromise&lt;Promise&lt;number&gt;&gt;;     // number
type B = UnwrapPromise&lt;Promise&lt;string&gt;&gt;;     // string
type C = UnwrapPromise&lt;number&gt;;              // number
</code></pre>
    <br/>
    <ul>
        <li>Used in async utils, API clients, or testing frameworks.</li>
        <li>If it's a Promise, unwrap it; otherwise, keep the type as-is.</li>
    </ul>
    <br/><br/>


    <li><b>Real-World Example: JSON Serialization Type</b></li>
<pre><code class="language-ts line-numbers">type JsonSafe&lt;T&gt; =
    T extends string | number | boolean | null
        ? T
        : T extends (infer U)[]
            ? JsonSafe&lt;U&gt;[]
            : T extends object
                ? { [K in keyof T]: JsonSafe&lt;T[K]&gt; }
                : never;

type User = {
    id: number;
    name: string;
    flags: boolean[];
};

type J = JsonSafe&lt;User&gt;;
// {
//   id: number;
//   name: string;
//   flags: boolean[];
// }
</code></pre>

    <br/>
    <ul>
        <li>Shows how complex data can be recursively transformed at type level.</li>
        <li>Conditional types allow for branching logic at each structural level.</li>
    </ul>
    <br/><br/>


    <li><b>Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Purpose</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic condition</td>
                <td>Choose between two types</td>
                <td><code>T extends U ? A : B</code></td>
            </tr>
            <tr>
                <td>Distributive behavior</td>
                <td>Map each union member</td>
                <td><code>(A | B) extends X ? Y : Z</code></td>
            </tr>
            <tr>
                <td><code>infer</code> keyword</td>
                <td>Extract parts of a type</td>
                <td><code>infer R</code></td>
            </tr>
            <tr>
                <td>Filtering unions</td>
                <td>Keep or remove union members</td>
                <td><code>string | never</code></td>
            </tr>
            <tr>
                <td>Recursive conditional types</td>
                <td>Transform deep structures</td>
                <td>JSON-safe types</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-mapped-types">Mapped Types</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Mapped types allow you to take an existing object type and create a new one by <u>applying the same transformation</u> to each property.</li>
        <br/>
        <li>The syntax has the form:
<pre><code class="language-ts line-numbers">{ [K in SomeKeys]: SomeTransformation&lt;T[K]&gt; }</code></pre>
        </li>
        <br/>
        <li>They are the foundation of many built-in TypeScript utilities like <code>Partial</code>, <code>Readonly</code>, <code>Pick</code>, <code>Record</code>, and <code>Required</code>.</li>
        <br/>
        <li>You can think of mapped types as "type-level loops" that iterate over keys and build a new shape.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Example</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
};

type OptionalUser = {
    [K in keyof User]?: User[K];
};
// { id?: number; name?: string }
</code></pre>
    <br/>
    <ul>
        <li>This iterates over all keys of <code>User</code> and makes each property optional.</li>
        <li><code>keyof User</code> produces the union <code>"id" | "name"</code>.</li>
        <li><code>User[K]</code> copies the original property type.</li>
    </ul>
    <br/><br/>


    <li><b>Readonly Mapped Types</b></li>
<pre><code class="language-ts line-numbers">type ReadonlyObject&lt;T&gt; = {
    readonly [K in keyof T]: T[K];
};

type Product = {
    price: number;
    title: string;
};

type ReadonlyProduct = ReadonlyObject&lt;Product&gt;;
// { readonly price: number; readonly title: string }
</code></pre>
    <br/>
    <ul>
        <li>Mapped types can add or remove modifiers like <code>readonly</code> or <code>?</code>.</li>
        <li>This pattern is the same one used internally by TypeScript's <code>Readonly&lt;T&gt;</code> utility.</li>
    </ul>
    <br/><br/>


    <li><b>Adding, Removing and Changing Modifiers</b></li>
    <br/>
    <ul>
        <li>You can explicitly add or remove modifiers:</li>
    </ul>
<pre><code class="language-ts line-numbers">type Mutable&lt;T&gt; = {
    -readonly [K in keyof T]: T[K];
};

type RequiredObject&lt;T&gt; = {
    [K in keyof T]-?: T[K];
};

type OptionalObject&lt;T&gt; = {
    [K in keyof T]?: T[K];
};
</code></pre>
    <br/>
    <ul>
        <li><code>+readonly</code> and <code>-readonly</code> (or simply <code>readonly</code>) adjust mutability.</li>
        <li><code>+?</code> and <code>-?</code> adjust optionality.</li>
        <li>This allows extremely fine control over type transformations.</li>
    </ul>
    <br/><br/>


    <li><b>Remapping Keys with <code>as</code></b></li>
    <br/>
    <ul>
        <li>You can rename keys while mapping them using <code>as</code> inside mapped types.</li>
        <li>This feature (introduced in TS 4.1) enables advanced transformations.</li>
    </ul>

<pre><code class="language-ts line-numbers">type PrefixKeys&lt;T&gt; = {
    [K in keyof T as `prefix_${K}`]: T[K];
};

type Example = {
    a: number;
    b: string;
};

type WithPrefix = PrefixKeys&lt;Example&gt;;
// { prefix_a: number; prefix_b: string }
</code></pre>
    <br/>
    <ul>
        <li><code>as</code> allows computed property names, template literal types, and key filtering.</li>
    </ul>
    <br/><br/>


    <li><b>Filtering Keys</b></li>
    <br/>
    <ul>
        <li>Mapped types combined with key remapping can remove certain properties from a type.</li>
    </ul>

<pre><code class="language-ts line-numbers">type RemoveMethods&lt;T&gt; = {
    [K in keyof T as T[K] extends Function ? never : K]: T[K];
};

type Model = {
    id: number;
    save(): void;
    load(): void;
};

type DataOnly = RemoveMethods&lt;Model&gt;;
// { id: number }
</code></pre>
    <br/>
    <ul>
        <li>Returning <code>never</code> for a key removes it from the resulting type.</li>
    </ul>
    <br/><br/>


    <li><b>Mapping Over Unions</b></li>
    <br/>
    <ul>
        <li>Mapped types also iterate over unions of keys, not only object keys.</li>
    </ul>

<pre><code class="language-ts line-numbers">type EventName = "click" | "focus" | "keydown";

type EventMap = {
    [E in EventName]: { type: E };
};

type M = EventMap;
// {
//   click:   { type: "click" },
//   focus:   { type: "focus" },
//   keydown: { type: "keydown" }
// }
</code></pre>
    <br/>
    <ul>
        <li>This helps construct strongly typed event maps, command tables, reducers, or configuration objects.</li>
    </ul>
    <br/><br/>


    <li><b>Mapping and Transforming Value Types</b></li>
    <br/>
    <ul>
        <li>Mapped types can transform both keys and values at the same time.</li>
    </ul>

<pre><code class="language-ts line-numbers">type Nullable&lt;T&gt; = {
    [K in keyof T]: T[K] | null;
};

type User = {
    id: number;
    name: string;
};

type NullableUser = Nullable&lt;User&gt;;
// { id: number | null; name: string | null }
</code></pre>
    <br/>
    <ul>
        <li>This is common for database schemas, partial updates, or form defaults.</li>
    </ul>
    <br/><br/>


    <li><b>Mapped Types Combined with Conditional Types</b></li>
    <br/>
    <ul>
        <li>Mapped types often appear together with conditional types for advanced logic.</li>
    </ul>

<pre><code class="language-ts line-numbers">type Serialize&lt;T&gt; = {
    [K in keyof T]: T[K] extends Function
        ? never
        : T[K] extends object
            ? Serialize&lt;T[K]&gt;
            : T[K];
};

type Model = {
    id: number;
    flags: { admin: boolean };
    save(): void;
};

type S = Serialize&lt;Model&gt;;
// { id: number; flags: { admin: boolean } }
</code></pre>
    <br/>
    <ul>
        <li>You can recursively transform each property depending on its type.</li>
        <li>This unlocks extremely expressive type manipulation patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Constructing Dictionary Types</b></li>
<pre><code class="language-ts line-numbers">type Dictionary&lt;K extends string, V&gt; = {
    [P in K]: V;
};

type UserRoles = Dictionary&lt;"admin" | "user" | "guest", boolean&gt;;
// { admin: boolean; user: boolean; guest: boolean }
</code></pre>
    <br/>
    <ul>
        <li>This pattern is used extensively in settings objects, configuration tables, registry maps, and permission systems.</li>
    </ul>
    <br/><br/>


    <li><b>Built-In Mapped Type Utilities</b></li>
    <br/>
    <ul>
        <li>Many TS built-ins are implemented as mapped types:</li>
    </ul>

<pre><code class="language-ts line-numbers">type Partial&lt;T&gt; = {
    [K in keyof T]?: T[K];
};

type Required&lt;T&gt; = {
    [K in keyof T]-?: T[K];
};

type Readonly&lt;T&gt; = {
    readonly [K in keyof T]: T[K];
};

type Record&lt;K extends string, T&gt; = {
    [P in K]: T;
};
</code></pre>

    <br/>
    <ul>
        <li>Understanding mapped types is essential to understanding how these built-ins work.</li>
    </ul>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Explanation</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Key iteration</td>
                <td>Iterate over keys with <code>keyof</code></td>
                <td><code>[K in keyof T]</code></td>
            </tr>
            <tr>
                <td>Property copying</td>
                <td>Reusing existing types</td>
                <td><code>T[K]</code></td>
            </tr>
            <tr>
                <td>Modifier changes</td>
                <td>Add/remove <code>readonly</code> / <code>?</code></td>
                <td><code>+readonly</code>, <code>-?</code></td>
            </tr>
            <tr>
                <td>Key remapping</td>
                <td>Rename or filter keys</td>
                <td><code>as ...</code></td>
            </tr>
            <tr>
                <td>Union mapping</td>
                <td>Build objects from unions</td>
                <td><code>[K in "a" | "b"]</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-infer">The <code>infer</code> Keyword</h3>
<ol>
    <li><code>infer</code> is a special keyword used inside <u>conditional types</u> to extract some part of a type and assign it to a new type variable.</li>
    <br/>
    <br/>


    <li>You can think of <code>infer</code> as "pattern matching for types": if the pattern fits, TypeScript extracts the needed portion.</li>
    <br/>
    <br/>


    <li><code>infer</code> only works inside conditional types of the form:</li>
<pre><code class="language-ts line-numbers">T extends SomePattern&lt;infer X&gt; ? Result : Fallback</code></pre>
    <br/>
    <br/>


    <li><b>Basic Example: Extracting a Function's Return Type</b></li>
<pre><code class="language-ts line-numbers">type ReturnTypeOf&lt;T&gt; =
    T extends (...args: any[]) =&gt; infer R
        ? R
        : never;

function foo() {
    return { id: 1, name: "Alice" };
}

type R = ReturnTypeOf&lt;typeof foo&gt;;
// { id: number; name: string }
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>infer R</code> grabs the return type of the function.</li>
        <li>If <code>T</code> does not match a function type, the result becomes <code>never</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Extracting Function Parameter Types</b></li>
<pre><code class="language-ts line-numbers">type FirstArg&lt;T&gt; =
    T extends (arg: infer A, ...rest: any[]) =&gt; any
        ? A
        : never;

type X = FirstArg&lt;(x: number, y: string) =&gt; void&gt;;
// number
</code></pre>
    <br/>
    <ul>
        <li><code>infer A</code> binds the type of the first parameter.</li>
        <li>You can extract more parameters by pattern matching the full function signature.</li>
    </ul>
    <br/><br/>


    <li><b>Extracting Tuple and Array Element Types</b></li>
<pre><code class="language-ts line-numbers">type ElementOf&lt;T&gt; =
    T extends (infer U)[] ? U : never;

type A = ElementOf&lt;string[]&gt;;  // string
type B = ElementOf&lt;number[]&gt;;  // number
</code></pre>
    <br/>
    <ul>
        <li>The pattern <code>(infer U)[]</code> matches any array type, extracting its element type.</li>
        <li>This is essential for building reusable collection helpers.</li>
    </ul>
    <br/><br/>


    <li><b>Extracting Tuple Element Types With Precision</b></li>
<pre><code class="language-ts line-numbers">type TupleFirst&lt;T&gt; =
    T extends [infer A, ...any[]] ? A : never;

type TupleRest&lt;T&gt; =
    T extends [any, ...infer R] ? R : never;

type T1 = TupleFirst&lt;[1, 2, 3]&gt;;   // 1
type T2 = TupleRest&lt;[1, 2, 3]&gt;;    // [2, 3]
</code></pre>
    <br/>
    <ul>
        <li>You can destructure tuples using <code>infer</code> just like JavaScript destructures arrays.</li>
        <li>This enables flexible tuple manipulation in type-level programming.</li>
    </ul>
    <br/><br/>


    <li><b>Extracting the Resolved Type of a Promise</b></li>
<pre><code class="language-ts line-numbers">type UnwrapPromise&lt;T&gt; =
    T extends Promise&lt;infer U&gt; ? U : T;

type P1 = UnwrapPromise&lt;Promise&lt;string&gt;&gt;;  // string
type P2 = UnwrapPromise&lt;Promise&lt;number&gt;&gt;;  // number
type P3 = UnwrapPromise&lt;number&gt;;           // number
</code></pre>
    <br/>
    <ul>
        <li><code>infer U</code> extracts the inner type of a promise.</li>
        <li>If <code>T</code> is not a promise, the type remains unchanged.</li></li>
    </ul>
    <br/><br/>


    <li><b>Extracting Object Property Types</b></li>
<pre><code class="language-ts line-numbers">type ValueOf&lt;T&gt; =
    T extends { [K: string]: infer V } ? V : never;

type Obj = { a: number; b: string; };

type V = ValueOf&lt;Obj&gt;;
// number | string
</code></pre>
    <br/>
    <ul>
        <li>The pattern matches any property value, collecting all possible ones.</li>
        <li>This is helpful for map-like objects or enums.</li>
    </ul>
    <br/><br/>


    <li><b>Extracting Constructor Instance Types</b></li>
<pre><code class="language-ts line-numbers">type InstanceTypeOf&lt;T&gt; =
    T extends new (...args: any[]) =&gt; infer R
        ? R
        : never;

class User {
    constructor(public id: number) {}
}

type U = InstanceTypeOf&lt;typeof User&gt;;
// User
</code></pre>
    <br/>
    <ul>
        <li><code>infer R</code> captures whatever the constructor returns (the instance type).</li>
        <li>This is similar to built-in <code>InstanceType&lt;T&gt;</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Inferring Within Nested Structures</b></li>
<pre><code class="language-ts line-numbers">type ResponseType&lt;T&gt; =
    T extends { data: infer D } ? D : never;

type Api = {
    data: {
        id: number;
        name: string;
    }
};

type R = ResponseType&lt;Api&gt;;
// { id: number; name: string }
</code></pre>

    <br/>
    <ul>
        <li><code>infer</code> works inside deeply nested object patterns.</li>
        <li>This enables type extraction from complex APIs or validation libraries.</li>
    </ul>
    <br/><br/>


    <li><b>Combining <code>infer</code> with Conditional Mapped Types</b></li>
<pre><code class="language-ts line-numbers">type DeepUnwrapPromise&lt;T&gt; = {
    [K in keyof T]: T[K] extends Promise&lt;infer U&gt;
        ? U
        : T[K];
};

type Obj = {
    name: string;
    age: Promise&lt;number&gt;;
};

type NewObj = DeepUnwrapPromise&lt;Obj&gt;;
// { name: string; age: number }
</code></pre>
    <br/>
    <ul>
        <li>Makes <code>infer</code> extremely powerful in generic transformations.</li>
        <li>Real-world usage includes ORMs, serializers, schemas, and RPC frameworks.</li>
    </ul>
    <br/><br/>


    <li><b>Recursive Extraction with <code>infer</code></b></li>
<pre><code class="language-ts line-numbers">type DeepResolve&lt;T&gt; =
    T extends Promise&lt;infer U&gt;
        ? DeepResolve&lt;U&gt;
        : T;

type P = DeepResolve&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;;
// string
</code></pre>
    <br/>
    <ul>
        <li><code>infer</code> supports recursion, enabling deeply nested type transformation.</li>
        <li>Used in advanced async utilities or libraries like tRPC and Zod.</li>
    </ul>
    <br/><br/>


    <li><b>Using <code>infer</code> to Detect Arrays vs Non-Arrays</b></li>
<pre><code class="language-ts line-numbers">type IsArray&lt;T&gt; =
    T extends readonly any[] ? true : false;

type A = IsArray&lt;number[]&gt;;             // true
type B = IsArray&lt;readonly string[]&gt;;    // true
type C = IsArray&lt;number&gt;;               // false
</code></pre>
    <br/>
    <ul>
        <li>You can infer tuple vs array vs non-array patterns for strict validation.</li>
    </ul>
    <br/><br/>


    <li><b>Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Pattern</th>
                <th>Purpose</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>infer R</code> in function patterns</td>
                <td>Extract return type or parameter type</td>
                <td><code>(...args) =&gt; infer R</code></td>
            </tr>
            <tr>
                <td><code>infer U</code> in array patterns</td>
                <td>Extract element type</td>
                <td><code>(infer U)[]</code></td>
            </tr>
            <tr>
                <td><code>infer A</code> in tuple patterns</td>
                <td>Extract first, last, or rest elements</td>
                <td><code>[infer A, ...rest]</code></td>
            </tr>
            <tr>
                <td>Nested <code>infer</code></td>
                <td>Deep extraction inside objects</td>
                <td><code>{ data: infer D }</code></td>
            </tr>
            <tr>
                <td>Recursive <code>infer</code></td>
                <td>Unwrap nested structures</td>
                <td><code>Promise&lt;Promise&lt;...&gt;&gt;</code></td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-template-literal-types">Template Literal Types</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Template Literal Types in TypeScript allow you to construct new string types by combining:
            <ul>
                <li>string literal types</li>
                <li>union types</li>
                <li>interpolations using <code>${...}</code></li>
            </ul>
        </li>
        <br/>
        <li>They work similarly to JavaScript template strings, but at the type level.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Template Literal Type</b></li>
<pre><code class="language-ts line-numbers">type Greeting = `Hello ${string}`;

let a: Greeting = "Hello Alice";  // OK
let b: Greeting = "Hi Bob";       // Error
</code></pre>
    <br/>
    <ul>
        <li>The type <code>Hello ${string}</code> matches any string starting with "Hello ". </li>
        <li>The <code>${string}</code> placeholder means any string literal.</li>
    </ul>
    <br/><br/>


    <li><b>Using Union Types Inside Template Literals</b></li>
<pre><code class="language-ts line-numbers">type Direction = "up" | "down";
type Move = `move-${Direction}`;

let a: Move = "move-up";    // OK
let b: Move = "move-left";  // Error
</code></pre>
    <br/>
    <ul>
        <li>Unions expand all combinations.</li>
        <li>Template literal types allow building strict naming patterns.</li>
    </ul>
    <br/><br/>


    <li><b>Combining Multiple Unions</b></li>
<pre><code class="language-ts line-numbers">type Size = "small" | "medium" | "large";
type Color = "red" | "blue";

type Variant = `${Size}-${Color}`;

let v1: Variant = "small-red";      // OK
let v2: Variant = "large-blue";     // OK
let v3: Variant = "medium-green";   // Error
</code></pre>
    <br/>
    <ul>
        <li>The type expands to all valid combinations automatically.</li>
        <li>Useful for CSS-like systems, classnames, config options, etc.</li>
    </ul>
    <br/><br/>


    <li><b>Inferring Template Literal Types</b></li>
<pre><code class="language-ts line-numbers">function makeEvent(name: string) {
    return `on-${name}` as const;
}

const e = makeEvent("click");
// type: "on-click"
</code></pre>
    <br/>
    <ul>
        <li>Using <code>as const</code> helps preserve literal types instead of widening to <code>string</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Narrowing With Template Literal Types</b></li>
<pre><code class="language-ts line-numbers">type ID = `id-${number}`;

function printID(id: ID) {
    console.log(id);
}

printID("id-42");     // OK
printID("id-Alice");  // Error
</code></pre>
    <br/>
    <ul>
        <li>You can require specific string patterns at compile time.</li>
        <li>This is helpful in routing, command parsing, event names, etc.</li>
    </ul>
    <br/><br/>


    <li><b>Template Literal Types With Built-In String Manipulation Types</b></li>
<pre><code class="language-ts line-numbers">type Name = "alice" | "bob";
type Capitalized = Capitalize&lt;Name&gt;;

type Greeting = `Hello ${Capitalized}`;

let a: Greeting = "Hello Alice"; // OK
let b: Greeting = "Hello bob";   // Error
</code></pre>
    <br/>
    <ul>
        <li>Template literal types integrate with TypeScript's utility types:
            <ul>
                <li><code>Uppercase&lt;T&gt;</code></li>
                <li><code>Lowercase&lt;T&gt;</code></li>
                <li><code>Capitalize&lt;T&gt;</code></li>
                <li><code>Uncapitalize&lt;T&gt;</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Building Safe API Routes With Template Literal Types</b></li>
<pre><code class="language-ts line-numbers">type UserID = number;
type Route = `/users/${UserID}/posts/${number}`;

let r: Route = "/users/12/posts/99"; // OK
let x: Route = "/users/A/posts/5";   // Error
</code></pre>
    <br/>
    <ul>
        <li>Great for ensuring correctness in API path strings.</li>
        <li>Reduces runtime errors from typos or wrong formats.</li>
    </ul>
    <br/><br/>


    <li><b>Extracting Parts Using Inference</b></li>
<pre><code class="language-ts line-numbers">type Event = `on-${string}`;

function handle&lt;T extends Event&gt;(name: T) {
    const type = name.replace("on-", "");
    return type;
}

handle("on-click"); // OK
handle("on-move");  // OK
handle("click");    // Error
</code></pre>
    <br/>
    <ul>
        <li>This allows pattern-based type checking.</li>
        <li>Useful when parsing structured strings.</li>
    </ul>
    <br/><br/>


    <li><b>Template Literals in Conditional Types</b></li>
<pre><code class="language-ts line-numbers">type RemovePrefix&lt;T&gt; = T extends `id-${infer U}` ? U : never;

type R1 = RemovePrefix&lt;"id-123"&gt;; // "123"
type R2 = RemovePrefix&lt;"user"&gt;;   // never
</code></pre>
    <br/>
    <ul>
        <li>You can extract substrings at the type level via <code>infer</code>.</li>
        <li>Enables advanced type transformations.</li>
    </ul>
    <br/><br/>


    <li><b>Tagging and Branding Types</b></li>
<pre><code class="language-ts line-numbers">type BrandedID = `${number}-user-id`;

let id1: BrandedID = "123-user-id"; // OK
let id2: BrandedID = "123abc";      // Error
</code></pre>
    <br/>
    <ul>
        <li>Template literal types help create nominal-like typing patterns.</li>
        <li>Useful for preventing mixing of different ID types.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Template Literal Types</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Basic construction</td>
                <td>Create string patterns using ${}</td>
                <td><code>`Hello ${string}`</code></td>
            </tr>
            <tr>
                <td>Union expansion</td>
                <td>Build combinations from unions</td>
                <td><code>`move-${"left"|"right"}`</code></td>
            </tr>
            <tr>
                <td>Type-safe strings</td>
                <td>Prevent invalid formats</td>
                <td><code>id-${number}</code></td>
            </tr>
            <tr>
                <td>Integration with utility types</td>
                <td>Uppercase, Lowercase, Capitalize</td>
                <td><code>`Hello ${Capitalize&lt;T&gt;}`</code></td>
            </tr>
            <tr>
                <td>Pattern inference</td>
                <td>Extract inner substrings with infer</td>
                <td><code>T extends `x-${infer U}`</code></td>
            </tr>
            <tr>
                <td>API schemas</td>
                <td>Build strict REST endpoints</td>
                <td><code>`/users/${number}`</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-modules">Modules in TypeScript</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A module is simply any file that contains at least one of:</li>
        <ul>
            <li><code>export</code></li>
            <li><code>import</code></li>
        </ul>
        <br/>
        <li>Each file with exports becomes its own module and has its own scope.</li>
    </ul>
    <br/><br/>


    <li><b>Named Exports</b></li>
<pre><code class="language-ts line-numbers">// math.ts
export const PI = 3.14;
export function add(a: number, b: number) {
    return a + b;
}
</code></pre>
    <br/>
    <ul>
        <li>Use named exports when you want to export multiple things from a file.</li>
        <li>Import them by name:</li>
    </ul>

<pre><code class="language-ts line-numbers">import { PI, add } from "./math";
</code></pre>
    <br/><br/>


    <li><b>Renaming Exports and Imports to Avoid Conflicts or for Clarity</b></li>
<pre><code class="language-ts line-numbers">// utils.ts
export function calculate() {}
</code></pre>

<pre><code class="language-ts line-numbers">import { calculate as calc } from "./utils";
calc();
</code></pre>
    <br/><br/>


    <li><b>Default Exports</b></li>
<pre><code class="language-ts line-numbers">// greet.ts
export default function greet(name: string) {
    return `Hello ${name}`;
}
</code></pre>

<pre><code class="language-ts line-numbers">import greet from "./greet";
greet("Alice");
</code></pre>
    <br/>
    <ul>
        <li>A file can have only one default export.</li>
        <li>Default exports can be imported with any name.</li>
    </ul>
    <br/><br/>


    <li><b>Mixing Default and Named Exports</b></li>
<pre><code class="language-ts line-numbers">// server.ts
export default function connect() {}
export const PORT = 8080;
</code></pre>

<pre><code class="language-ts line-numbers">import connect, { PORT } from "./server";
</code></pre>
    <br/>
    <ul>
        <li>A module may export both a default export and named exports.</li>
        <li>Import syntax clearly distinguishes them.</li>
    </ul>
    <br/><br/>


    <li><b>Re-exporting</b></li>
<pre><code class="language-ts line-numbers">// math.ts
export const PI = 3.14;
export const E = 2.718;
</code></pre>

<pre><code class="language-ts line-numbers">// constants.ts
export * from "./math";
</code></pre>

<pre><code class="language-ts line-numbers">import { PI } from "./constants";
</code></pre>
    <br/>
    <ul>
        <li><code>export *</code> re-exports everything from another module.</li>
        <li>Useful for building "barrel files".</li>
    </ul>
    <br/><br/>


    <li><b>Re-exporting with Renaming</b></li>
<pre><code class="language-ts line-numbers">export { PI as PI_VALUE } from "./math";
</code></pre>
    <br/>
    <ul>
        <li>Allows reorganizing a module's public API.</li>
    </ul>
    <br/><br/>


    <li><b>Importing Everything</b></li>
<pre><code class="language-ts line-numbers">import * as utils from "./utils";

utils.log("Hello");
utils.debug("Test");
</code></pre>
    <br/>
    <ul>
        <li>Use <code>* as</code> to import all exports under a namespace.</li>
        <li>Useful when a module exports many small members.</li>
    </ul>
    <br/><br/>


    <li><b>Type-Only Imports and Exports</b></li>
<pre><code class="language-ts line-numbers">export type User = {
    id: number;
    name: string;
};
</code></pre>

<pre><code class="language-ts line-numbers">import type { User } from "./types";

let u: User = { id: 1, name: "Alice" };
</code></pre>
    <br/>
    <ul>
        <li><code>import type</code> ensures that the import is removed at compile time.</li>
        <li>Helps reduce emitted JavaScript bundle size.</li>
    </ul>
    <br/><br/>


    <li><b>Type-Only Re-exports</b></li>
<pre><code class="language-ts line-numbers">export type { User } from "./types";
</code></pre>
    <br/>
    <ul>
        <li>Re-exports type information without producing JavaScript code.</li>
    </ul>
    <br/><br/>


    <li><b>ES Modules vs CommonJS (in Node)</b></li>
    <br/>
    <ul>
        <li>TypeScript supports both module systems:
            <ul>
                <li><u>ESM</u> (ECMAScript Modules):
                    <code>import</code> / <code>export</code>
                </li>
                <li><u>CommonJS</u> (older Node.js):
                    <code>require()</code> / <code>module.exports</code>
                </li>
            </ul>
        </li>
        <br/>
        <li>Set target in <code>tsconfig.json</code>:
<pre><code class="language-json line-numbers">{
    "compilerOptions": {
        "module": "ESNext"
    }
}
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li><b>export = and import = require()</b> (CommonJS interoperability)</li>
<pre><code class="language-ts line-numbers">const fs = require("fs");
export = fs;
</code></pre>

<pre><code class="language-ts line-numbers">import fs = require("fs");
</code></pre>
    <br/>
    <ul>
        <li>This syntax exists for compatibility with CommonJS modules.</li>
        <li>Use ESM-style modules in modern TypeScript whenever possible.</li>
    </ul>
    <br/><br/>


    <li><b>Barrel Files (Index Files)</b></li>
<pre><code class="language-ts line-numbers">// index.ts
export * from "./math";
export * from "./utils";
export * from "./types";
</code></pre>

<pre><code class="language-ts line-numbers">import { add, PI, User } from "./index";
</code></pre>
    <br/>
    <ul>
        <li>Barrel files collect exports from many files into a single entry point.</li>
        <li>Common in React, Angular, and backend Node projects.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Modules in TypeScript</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Usage</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Named exports</td>
                <td>Export multiple items</td>
                <td><code>export const x = 1;</code></td>
            </tr>
            <tr>
                <td>Default export</td>
                <td>One main export per module</td>
                <td><code>export default fn;</code></td>
            </tr>
            <tr>
                <td>Namespace import</td>
                <td>Group all exports</td>
                <td><code>import * as A from "./a"</code></td>
            </tr>
            <tr>
                <td>Type-only imports</td>
                <td>Avoid emitting JS</td>
                <td><code>import type { T }</code></td>
            </tr>
            <tr>
                <td>Re-exporting</td>
                <td>Forward exports</td>
                <td><code>export * from "./a"</code></td>
            </tr>
            <tr>
                <td>Barrel files</td>
                <td>Centralized exports</td>
                <td><code>index.ts</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>

</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-decorators">Decorators in TypeScript</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><u>Decorators</u> in TypeScript provide a way to attach metadata or modify classes, methods, properties, parameters, and accessors.</li>
        <br/>
        <li>A <u>decorator</u> is simply a function that receives the target being decorated.</li>
        <br/>
        <li>To enable decorators, you must first activate them in <code>tsconfig.json</code>:</li>
<pre><code class="language-json line-numbers">{
    "compilerOptions": {
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true
    }
}
</code></pre>
    </ul>
    <br/><br/>


    <li><b>Decorator Basics</b></li>
<pre><code class="language-ts line-numbers">function SimpleDecorator(constructor: Function) {
    console.log("Decorated:", constructor.name);
}

@SimpleDecorator
class MyClass {}
</code></pre>
    <br/>
    <ul>
        <li><code>@SimpleDecorator</code> invokes the function when the class is defined.</li>
        <li>Decorators run at definition time, not at runtime when instances are created.</li>
    </ul>
    <br/><br/>


    <li><b>Class Decorators</b></li>
    <br/>
    <ul>
        <li>A class decorator receives the constructor function of the class.</li>
    </ul>

<pre><code class="language-ts line-numbers">function LogClass(target: Function) {
    console.log(`Class: ${target.name}`);
}

@LogClass
class User {}
</code></pre>
    <br/>
    <ul>
        <li>Output:
<pre><code class="language-ts">Class: User
</code></pre>
        </li>
        <li>Useful for logging, metadata, or modifying the constructor.</li>
    </ul>
    <br/><br/>


    <li><b>Class Decorator Factory</b></li>
<pre><code class="language-ts line-numbers">function WithRole(role: string) {
    return function (target: Function) {
        target.prototype.role = role;
    };
}

@WithRole("admin")
class Account {}

const a = new Account();
console.log(a.role);        // "admin"
</code></pre>
    <br/>
    <ul>
        <li>Decorator factories allow passing parameters into decorators.</li>
        <li>The first function receives parameters; the second receives the class.</li>
    </ul>
    <br/><br/>


    <li><b>Method Decorators</b></li>
    <br/>
    <ul>
        <li>A method decorator receives:
            <ul>
                <li><code>target</code> — the prototype</li>
                <li><code>key</code> — the method name</li>
                <li><code>descriptor</code> — the property descriptor</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">function LogMethod(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${key} with`, args);
        return original.apply(this, args);
    };
}

class Calculator {
    @LogMethod
    add(a: number, b: number) {
        return a + b;
    }
}

const c = new Calculator();
c.add(2, 3);
</code></pre>
    <br/>
    <ul>
        <li>A method decorator can wrap, modify, or replace the method.</li>
        <li>This is the base of logging, profiling, caching, and authorization decorators.</li>
    </ul>
    <br/><br/>


    <li><b>Accessor Decorators</b></li>
<pre><code class="language-ts line-numbers">function Readonly(target: any, key: string, descriptor: PropertyDescriptor) {
    descriptor.writable = false;
}

class Person {
    private _name = "Alice";

    @Readonly
    get name() {
        return this._name;
    }
}

// person.name = "Bob"; // Error
</code></pre>
    <br/>
    <ul>
        <li>Accessor decorators modify getters and setters.</li>
        <li>They allow controlling writability or enumerability.</li>
    </ul>
    <br/><br/>


    <li><b>Property Decorators</b></li>
    <br/>
    <ul>
        <li>A property decorator receives only:
            <ul>
                <li><code>target</code> — the prototype</li>
                <li><code>key</code> — the property name</li>
            </ul>
        </li>
        <li>It cannot directly modify property values because properties do not have descriptors on the prototype.</li>
    </ul>

<pre><code class="language-ts line-numbers">function Required(target: any, key: string) {
    console.log(`${key} is required`);
}

class Settings {
    @Required
    theme!: string;
}
</code></pre>
    <br/>
    <ul>
        <li>Often used for validation metadata.</li>
    </ul>
    <br/><br/>


    <li><b>Parameter Decorators</b></li>
<pre><code class="language-ts line-numbers">function LogParam(target: any, key: string, index: number) {
    console.log(`Parameter #${index} in ${key}`);
}

class Service {
    greet(@LogParam name: string) {
        console.log("Hello " + name);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Parameter decorators receive:
            <ul>
                <li><code>target</code></li>
                <li><code>method name</code></li>
                <li><code>parameter index</code></li>
            </ul>
        </li>
        <li>Useful for dependency injection systems (e.g. NestJS).</li>
    </ul>
    <br/><br/>


    <li><b>Using Decorators for Dependency Injection</b></li>
<pre><code class="language-ts line-numbers">function Inject(service: any) {
    return function (target: any, key: string, index: number) {
        console.log(`Injecting ${service.name} into ${key}`);
    };
}

class Logger {}

class Controller {
    constructor(@Inject(Logger) private logger: Logger) {}
}
</code></pre>
    <br/>
    <ul>
        <li>Decorators allow building DI frameworks similar to Angular and NestJS.</li>
    </ul>
    <br/><br/>


    <li><b>Metadata Decorators</b></li>
<pre><code class="language-ts line-numbers">import "reflect-metadata";

function Type(type: any) {
    return function (target: any, key: string) {
        Reflect.defineMetadata("design:type", type, target, key);
    };
}

class Box {
    @Type(String)
    content!: string;
}

const type = Reflect.getMetadata("design:type", new Box(), "content");
console.log(type.name); // "String"
</code></pre>
    <br/>
    <ul>
        <li>Used heavily in ORMs and DI frameworks.</li>
        <li>Requires <code>emitDecoratorMetadata</code> to be enabled.</li>
    </ul>
    <br/><br/>


    <li><b>Execution Order of Decorators</b></li>
    <br/>
    <ul>
        <li>If multiple decorators are applied, evaluation happens:
            <ul>
                <li><u>Bottom to top</u> (in code)</li>
                <li>Then <u>each result is applied top to bottom</u></li>
            </ul>
        </li>
    </ul>

<pre><code class="language-ts line-numbers">function A() { return () =&gt; console.log("A"); }
function B() { return () =&gt; console.log("B"); }

@A()
@B()
class Example {}
</code></pre>

    <br/>
    <ul>
        <li>Output:
<pre><code class="language-ts">B
A
</code></pre>
        </li>
    </ul>
    <br/><br/>


    <li><b>Summary of Decorators in TypeScript</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Decorator Type</th>
                <th>Purpose</th>
                <th>Arguments Received</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Class Decorator</td>
                <td>Modify/replace class constructor</td>
                <td><code>(constructor)</code></td>
            </tr>
            <tr>
                <td>Method Decorator</td>
                <td>Modify method behavior</td>
                <td><code>(target, key, descriptor)</code></td>
            </tr>
            <tr>
                <td>Accessor Decorator</td>
                <td>Control getters/setters</td>
                <td><code>(target, key, descriptor)</code></td>
            </tr>
            <tr>
                <td>Property Decorator</td>
                <td>Attach metadata to fields</td>
                <td><code>(target, key)</code></td>
            </tr>
            <tr>
                <td>Parameter Decorator</td>
                <td>Inject or annotate parameters</td>
                <td><code>(target, key, index)</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-get-set">Getters and Setters in TypeScript</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>TypeScript allows you to define special class methods called <code>get</code> and <code>set</code>.</li>
        <br/>
        <li>These methods look like normal property access from the outside, but inside they run custom logic.</li>
        <br/>
        <li>They behave like properties but work like functions.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Example of Getter and Setter</b></li>
<pre><code class="language-ts line-numbers">class User {
    private _name: string = "";

    get name() {
        return this._name.toUpperCase();
    }

    set name(value: string) {
        if (value.length < 2) {
            throw new Error("Name too short");
        }
        this._name = value;
    }
}

const u = new User();
u.name = "alice";          // calls the setter
console.log(u.name);       // calls the getter
</code></pre>
    <br/>
    <ul>
        <li>Typing <code>u.name</code> does NOT access a field.</li>
        <li>It triggers the getter or setter <b>as if</b> they were functions.</li>
        <li>This is called a <b>computed property accessor</b>.</li>
    </ul>
    <br/><br/>


    <li><b>Why Not Just Use Methods?</b></li>
<pre><code class="language-ts line-numbers">u.getName();       // explicit method
u.setName("Bob");  // explicit method
</code></pre>
    <br/>
    <ul>
        <li>Getter and setter syntax allows you to write <b>cleaner and more natural APIs</b>:</li>
<pre><code class="language-ts">u.name;     // getter
u.name = x; // setter
</code></pre>
        <br/>
        <li>The API feels like using normal properties.</li>
        <li>This is why frameworks like Angular and libraries like TypeORM rely on <code>get</code>/<code>set</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Getter Only (Read-Only Property)</b></li>
<pre><code class="language-ts line-numbers">class Circle {
    constructor(private radius: number) {}

    get area() {
        return Math.PI * this.radius * this.radius;
    }
}

const c = new Circle(10);
console.log(c.area);  // computed every time
</code></pre>
    <br/>
    <ul>
        <li>No setter means the property cannot be assigned to.</li>
        <li><code>c.area = 10;</code> causes a compile-time error.</li>
        <li>Used for computed values or protected internal values.</li>
    </ul>
    <br/><br/>


    <li><b>Setter Only (Write-Only Property)</b></li>
<pre><code class="language-ts line-numbers">class Logger {
    set message(value: string) {
        console.log("Log:", value);
    }
}

const log = new Logger();
log.message = "Hello";  // allowed
// console.log(log.message); // ERROR: getter missing
</code></pre>
    <br/>
    <ul>
        <li>Rare in practice but used in logging or write-only channels.</li>
    </ul>
    <br/><br/>


    <li><b>Using Getters and Setters to Control Access</b></li>
<pre><code class="language-ts line-numbers">class Person {
    private _age = 0;

    get age() {
        return this._age;
    }

    set age(value: number) {
        if (value < 0 || value > 150) {
            throw new Error("Invalid age");
        }
        this._age = value;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Useful when a property must follow rules or constraints.</li>
        <li>Prevents invalid state from being assigned.</li>
    </ul>
    <br/><br/>


    <li><b>Getters and Setters with Types</b></li>
<pre><code class="language-ts line-numbers">class Point {
    private _x = 0;

    get x(): number {
        return this._x;
    }

    set x(value: number) {
        this._x = value;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The getter declares a return type.</li>
        <li>The setter declares a parameter type.</li>
        <li>They must match or be compatible.</li>
    </ul>
    <br/><br/>


    <li><b>How They Work Internally (Property Descriptor)</b></li>
    <br/>
    <ul>
        <li>TypeScript compiles getters and setters to JavaScript using <code>Object.defineProperty</code>.</li>
    </ul>

<pre><code class="language-js line-numbers">Object.defineProperty(Person.prototype, "age", {
    get: function () { ... },
    set: function (value) { ... },
    enumerable: true,
    configurable: true
});
</code></pre>
    <br/>
    <ul>
        <li>This is the true magic behind <code>get</code> and <code>set</code>.</li>
        <li>The property is stored on the prototype as an accessor, not as a normal field.</li>
        <li>Reading it calls the getter function; writing it calls the setter function.</li>
    </ul>
    <br/><br/>


    <li><b>Getters and Setters with Private Fields</b></li>
<pre><code class="language-ts line-numbers">class Account {
    #balance = 0;

    get balance() {
        return this.#balance;
    }

    set balance(value: number) {
        if (value < 0) throw new Error("Negative balance not allowed");
        this.#balance = value;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>#balance</code> is a <b>true private</b> field at runtime (ES private field).</li>
        <li>Getters and setters act as a controlled interface to private data.</li>
    </ul>
    <br/><br/>


    <li><b>Getters and Setters with Computation</b></li>
<pre><code class="language-ts line-numbers">class Temperature {
    constructor(private celsius: number) {}

    get fahrenheit() {
        return this.celsius * 1.8 + 32;
    }

    set fahrenheit(value: number) {
        this.celsius = (value - 32) / 1.8;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The getter computes Fahrenheit from Celsius.</li>
        <li>The setter reverses the calculation.</li>
        <li>This creates virtual fields that appear real but are computed.</li>
    </ul>
    <br/><br/>


    <li><b>Combining Getters, Setters, and Decorators</b></li>
<pre><code class="language-ts line-numbers">function Log(target: any, key: string, descriptor: PropertyDescriptor) {
    const originalSet = descriptor.set!;
    descriptor.set = function (value: any) {
        console.log(`Assigning ${key} =`, value);
        originalSet.call(this, value);
    };
}

class Product {
    private _price = 0;

    @Log
    set price(value: number) {
        this._price = value;
    }

    get price() {
        return this._price;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Setters are widely used together with decorators to implement validation, logging, or metadata.</li>
    </ul>
    <br/><br/>


    <li><b>Summary of Getters and Setters in TypeScript</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Getter</td>
                <td>Runs when accessing a property</td>
                <td><code>obj.name</code></td>
            </tr>
            <tr>
                <td>Setter</td>
                <td>Runs when assigning to a property</td>
                <td><code>obj.name = value</code></td>
            </tr>
            <tr>
                <td>Computed property</td>
                <td>Looks like a field but acts like a function</td>
                <td><code>get area() {...}</code></td>
            </tr>
            <tr>
                <td>Validation</td>
                <td>Prevent invalid values</td>
                <td><code>set age(v)</code></td>
            </tr>
            <tr>
                <td>Encapsulation</td>
                <td>Hide private data</td>
                <td><code>#balance</code></td>
            </tr>
            <tr>
                <td>Interoperability</td>
                <td>Works well with decorators and metadata</td>
                <td><code>@Log</code> on setter</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
