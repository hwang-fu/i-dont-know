<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>TS</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>TypeScript</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-typeof">The <code>typeof</code> Operator</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In TypeScript, <code>typeof</code> is a dual-purpose operator used both at <u>runtime</u> (JavaScript behavior) and at <u>compile time</u> (TypeScript type queries).</li>
        <br/>
        <li>At runtime, <code>typeof</code> returns a string describing the JS type of a value.</li>
        <br/>
        <li>At compile time, TypeScript uses <code>typeof</code> to extract the <u>type</u> of a variable or function instead of its value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Runtime <code>typeof</code></b></li>
    <br/>
    <ul>
        <li>Runtime <code>typeof</code> is identical to JavaScript and returns strings:</li>
    </ul>
<pre><code class="language-ts line-numbers">console.log(typeof 123);       // "number"
console.log(typeof 'hello');   // "string"
console.log(typeof true);      // "boolean"
console.log(typeof {});        // "object"
console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object"  (quirk of JavaScript)
</code></pre>
    <br/>
    <br/>


    <li><b>Compile-Time <code>typeof</code> (Type Query)</b></li>
    <br/>
    <ul>
        <li>In TypeScript, <code>typeof</code> inside a type context retrieves the <u>type</u> of a value.</li>
        <br/>
        <li>This allows you to reuse the type of an existing variable or function.</li>
    </ul>
<pre><code class="language-ts line-numbers">const user = {
    id: 1,
    name: 'Alice',
    active: true
};

type User = typeof user;
</code></pre>
    <br/>
    <ul>
        <li><code>User</code> is now exactly the type of the variable <code>user</code>.</li>
        <li>This avoids manually rewriting types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> with Functions</b></li>
<pre><code class="language-ts line-numbers">function createPoint(x: number, y: number) {
    return { x, y };
}

type Point = ReturnType&lt;typeof createPoint&gt;;
</code></pre>
    <br/>
    <ul>
        <li><code>typeof createPoint</code> gives you the type of the function object itself.</li>
        <li><code>ReturnType&lt;...&gt;</code> extracts the return type of that function.</li>
        <li>This is safer and avoids duplication when the function evolves.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> for Constant Union Types</b></li>
<pre><code class="language-ts line-numbers">const roles = ['admin', 'user', 'guest'] as const;

type Role = typeof roles[number];
</code></pre>
    <br/>
    <ul>
        <li><code>typeof roles[number]</code> turns the array into a union: <code>'admin' | 'user' | 'guest'</code>.</li>
        <li>This pattern is extremely useful for enums and constant lists.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>typeof</code> with Literal Types</b></li>
<pre><code class="language-ts line-numbers">const DEFAULT_PORT = 8080;

type Port = typeof DEFAULT_PORT; // type Port = 8080
</code></pre>
    <br/>
    <ul>
        <li>The type of <code>DEFAULT_PORT</code> is the literal type <code>8080</code>, not <code>number</code>.</li>
        <li>Useful for configuration constants or fixed numeric/string values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> in Type Guards</b></li>
<pre><code class="language-ts line-numbers">function logValue(v: string | number) {
    if (typeof v === 'string') {
        console.log(v.toUpperCase());
    } else {
        console.log(v.toFixed(2));
    }
}
</code></pre>
    <br/>
    <ul>
        <li>TypeScript understands the runtime <code>typeof</code> check and narrows types accordingly.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Context</th>
                <th>Meaning</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Runtime</td>
                <td>Returns a string describing JS type</td>
                <td><code>typeof 123 === 'number'</code></td>
            </tr>
            <tr>
                <td>Compile-Time</td>
                <td>Returns the TypeScript type of a value</td>
                <td><code>type T = typeof x</code></td>
            </tr>
            <tr>
                <td>Combined</td>
                <td>Used for safe type narrowing</td>
                <td><code>if (typeof v === 'string') ...</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-type">The <code>type</code> Operator (Type Aliases)</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In TypeScript, the <code>type</code> keyword creates a <b>type alias</b>, which is a custom name for any type.</li>
        <br/>
        <li>A type alias does not create a new type at runtime. Instead, it provides a readable, reusable label for complex type structures.</li>
        <br/>
        <li><code>type</code> is similar to <code>interface</code>, but more powerful in certain use cases (unions, mapped types, utility types).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Basic Syntax</b></li>
<pre><code class="language-ts line-numbers">type AliasName = ExistingType;
</code></pre>
    <br/>
    <ul>
        <li><code>AliasName</code> becomes a new name referring to the right-hand side type.</li>
        <li>Type aliases improve clarity and reduce duplication.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Alias for Primitive Types</b></li>
<pre><code class="language-ts line-numbers">type ID = number;
type Username = string;
</code></pre>
    <br/>
    <ul>
        <li>Primitive aliases improve readability in function signatures.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Alias for Object Types</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name: string;
    active: boolean;
};
</code></pre>
    <br/>
    <ul>
        <li>Defines a reusable object shape.</li>
        <li>Common in API response schemas or domain models.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Type Alias</b></li>
<pre><code class="language-ts line-numbers">type Add = (a: number, b: number) =&gt; number;

const sum: Add = (x, y) =&gt; x + y;
</code></pre>
    <br/>
    <ul>
        <li>Provides a clean, reusable type for a function signature.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Union Types with <code>type</code></b></li>
<pre><code class="language-ts line-numbers">type Status = 'success' | 'error' | 'loading';

type StringOrNumber = string | number;
</code></pre>
    <br/>
    <ul>
        <li>Type aliases are the only way (besides literal types) to define union types.</li>
        <li>Unions are essential for discriminated unions, enums, and input validation.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Intersection Types</b></li>
<pre><code class="language-ts line-numbers">type HasID = { id: number };
type HasName = { name: string };

type User = HasID &amp; HasName;
</code></pre>
    <br/>
    <ul>
        <li>An <b>intersection type</b> (<code>&amp;</code>) merges multiple types into a single combined type.</li>
        <br/>
        <li>The resulting type contains <u>all</u> properties from all intersected types.</li>
        <br/>
        <li>In the example above, <code>User</code> must have <code>id</code> and <code>name</code>:
<pre><code class="language-ts line-numbers">const u: User = {
    id: 1,
    name: "Alice"
};
</code></pre>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection with More Types</b></li>
<pre><code class="language-ts line-numbers">type HasEmail = { email: string };

type Person = HasID &amp; HasName &amp; HasEmail;
</code></pre>
    <br/>
    <ul>
        <li><code>Person</code> must include all properties: <code>id</code>, <code>name</code>, and <code>email</code>.</li>
        <li>This allows building strong domain models from small reusable pieces.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection Types with Functions</b></li>
<pre><code class="language-ts line-numbers">type CanLog = { log: () =&gt; void };
type CanSave = { save: () =&gt; void };

type LoggerSaver = CanLog &amp; CanSave;

const obj: LoggerSaver = {
    log() { console.log("logging"); },
    save() { console.log("saving"); }
};
</code></pre>
    <br/>
    <ul>
        <li>Intersection types allow you to build objects that must implement multiple behaviors.</li>
        <li>This is a common pattern in mixin-based systems.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Merging Object Types (Property Compatibility)</b></li>
<pre><code class="language-ts line-numbers">type A = { x: number };
type B = { x: number | string };

type C = A &amp; B;
// type C = { x: number } &amp; { x: number | string }
</code></pre>
    <br/>
    <ul>
        <li>When intersecting conflicting property types, TypeScript computes the <u>most specific</u> possible type.</li>
        <br/>
        <li>Here:
            <ul>
                <li><code>A.x</code> must be <code>number</code></li>
                <li><code>B.x</code> may be <code>number | string</code></li>
            </ul>
        </li>
        <br/>
        <li>The only valid value that satisfies both is: <code>number</code>
        </li>
        <br/>
        <li>If no overlap exists, the type becomes <code>never</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection Producing <code>never</code> (Incompatible Types)</b></li>
<pre><code class="language-ts line-numbers">type A = { x: string };
type B = { x: number };

type Impossible = A &amp; B;  // { x: string &amp; number } → never
</code></pre>
    <br/>
    <ul>
        <li>A value cannot be <code>string</code> and <code>number</code> at the same time.</li>
        <br/>
        <li>Thus the combined property becomes <code>string &amp; number</code>, which resolves to <code>never</code>.</li>
        <br/>
        <li>This means <code>Impossible</code> has no possible valid values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection Types vs Interfaces</b></li>
    <br/>
    <ul>
        <li>Intersection types are compositional — you combine multiple types into bigger ones.</li>
        <br/>
        <li>Interfaces use <code>extends</code> (inheritance), while intersections use <code>&amp;</code> (composition).</li>
        <br/>
        <li>Example comparison:</li>
    </ul>
<pre><code class="language-ts line-numbers">interface A { x: number }
interface B { y: number }

type C = A &amp; B;
// Equivalent to:
interface D extends A, B {}
</code></pre>
    <br/>
    <ul>
        <li>However, intersections work with:
            <ul>
                <li>Unions</li>
                <li>Function types</li>
                <li>Primitive types</li>
                <li>Mapped types</li>
            </ul>
        </li>
        <br/>
        <li>Therefore, intersection types are more flexible and more expressive than interface inheritance alone.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Aliases for Strings, Numbers, or Enums</b></li>
<pre><code class="language-ts line-numbers">type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

type Port = 80 | 443 | 8080;
</code></pre>
    <br/>
    <ul>
        <li>Creates powerful compile-time constraints on accepted values.</li>
        <li>Helps eliminate invalid inputs early.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>typeof</code> with <code>type</code></b></li>
<pre><code class="language-ts line-numbers">const config = {
    host: 'localhost',
    port: 3000
};

type Config = typeof config;
</code></pre>
    <br/>
    <ul>
        <li>The <code>type</code> keyword combines perfectly with <code>typeof</code> to derive types from runtime objects.</li>
        <li>This prevents duplicate definitions and keeps types consistent with real code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type Response&lt;T&gt; = {
    data: T;
    error: string | null;
};

type UserResponse = Response&lt;{ id: number; name: string }&gt;;
</code></pre>
    <br/>
    <ul>
        <li>Type aliases can be generic and work similarly to generic interfaces.</li>
        <li>Extremely useful for reusable API or library types.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Mapped Types Using <code>type</code></b></li>
<pre><code class="language-ts line-numbers">type ReadonlyObject&lt;T&gt; = {
    readonly [K in keyof T]: T[K];
};

type FullUser = { id: number; name: string };
type ReadonlyUser = ReadonlyObject&lt;FullUser&gt;;
</code></pre>
    <br/>
    <ul>
        <li>Mapped types allow programmatic transformations of types.</li>
        <li>Type aliases are the foundation for most advanced TS utilities.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Comparison: <code>type</code> vs <code>interface</code></b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th><code>type</code></th>
                <th><code>interface</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Can define unions</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Can define primitives</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Supports declaration merging</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Mapped types</td>
                <td>Yes</td>
                <td>Limited</td>
            </tr>
            <tr>
                <td>Extending others</td>
                <td>With <code>&amp;</code></td>
                <td>With <code>extends</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Use <code>type</code> for unions, intersections, and advanced type transformations.</li>
        <li>Use <code>interface</code> for object shapes needing merging or class implementation.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-everyday-types">Everyday Types</h3>
<ol>
    <li><b>Primitive Types</b></li>
<pre><code class="language-ts line-numbers">let age: number = 25;
let name: string = "Alice";
let isActive: boolean = true;
</code></pre>
    <br/>
    <ul>
        <li>Primitive types represent basic values.</li>
        <li>They include: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, and <code>symbol</code>.</li>
        <li>TypeScript adds optional type annotations to improve clarity and safety.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Arrays</b></li>
<pre><code class="language-ts line-numbers">let numbers: number[] = [1, 2, 3];
let names: Array&lt;string&gt; = ["Alice", "Bob"];
</code></pre>
    <br/>
    <ul>
        <li>Two syntaxes exist: <code>T[]</code> and <code>Array&lt;T&gt;</code>.</li>
        <li>Both are equivalent — choose whichever improves readability.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Objects</b></li>
<pre><code class="language-ts line-numbers">let user: {
    id: number;
    name: string;
    active: boolean;
} = {
    id: 1,
    name: "Alice",
    active: true
};
</code></pre>
    <br/>
    <ul>
        <li>TypeScript supports <u>structural typing</u>: objects must contain certain properties, regardless of their origin.</li>
        <li>Object types can be declared inline or with type aliases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Optional and Readonly Properties</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name?: string;              // optional
    readonly active: boolean;   // cannot be modified
};
</code></pre>
    <br/>
    <ul>
        <li>Optional properties may be omitted.</li>
        <li>Readonly properties cannot be reassigned after creation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions</b></li>
<pre><code class="language-ts line-numbers">function add(a: number, b: number): number {
    return a + b;
}

const greet = (name: string): void =&gt; {
    console.log("Hello " + name);
};
</code></pre>
    <br/>
    <ul>
        <li>Function type annotations include parameter types and return types.</li>
        <li><code>void</code> indicates the function returns nothing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type Add = (x: number, y: number) =&gt; number;

const sum: Add = (a, b) =&gt; a + b;
</code></pre>
    <br/>
    <ul>
        <li>Function signatures are reusable via type aliases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Union Types</b></li>
<pre><code class="language-ts line-numbers">let value: number | string;

value = 42;
value = "hello";
</code></pre>
    <br/>
    <ul>
        <li>A union type allows a value to be one of several types.</li>
        <li>Useful when variables accept multiple formats.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Narrowing</b></li>
<pre><code class="language-ts line-numbers">function printValue(v: number | string) {
    if (typeof v === "string") {
        console.log(v.toUpperCase());
    } else {
        console.log(v.toFixed(2));
    }
}
</code></pre>
    <br/>
    <ul>
        <li>TypeScript "narrows" a union type based on conditions.</li>
        <li>Common narrowing tools include <code>typeof</code>, <code>instanceof</code>, and <code>in</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Aliases</b></li>
<pre><code class="language-ts line-numbers">type ID = number;
type Point = { x: number; y: number; };
</code></pre>
    <br/>
    <ul>
        <li><code>type</code> gives reusable names to simple or complex types.</li>
        <li>Highly useful for domain modeling and clean code organization.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Interfaces</b></li>
<pre><code class="language-ts line-numbers">interface Person {
    id: number;
    name: string;
}
</code></pre>
    <br/>
    <ul>
        <li>Interfaces describe object shapes and support extension.</li>
        <li>They are similar to type aliases but provide interface merging and class implementation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Literal Types</b></li>
<pre><code class="language-ts line-numbers">let direction: "left" | "right" | "up" | "down";
</code></pre>
    <br/>
    <ul>
        <li>Variables can be restricted to specific literal values.</li>
        <li>Literal types are heavily used in modern TypeScript to create precise APIs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Nullable Types</b></li>
<pre><code class="language-ts line-numbers">let maybe: string | null = null;
</code></pre>
    <br/>
    <ul>
        <li>Combine types with <code>null</code> or <code>undefined</code> to model optional or missing data.</li>
        <li>Helps enforce safer handling of "empty" values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Enums</b></li>
<pre><code class="language-ts line-numbers">enum Status {
    Success,
    Error,
    Loading
}
</code></pre>
    <br/>
    <ul>
        <li>Enums create real runtime objects, unlike most TypeScript types.</li>
        <li>Useful for named constants, but constant unions are often preferred.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Tuples</b></li>
<pre><code class="language-ts line-numbers">let point: [number, number] = [10, 20];
</code></pre>
    <br/>
    <ul>
        <li>Tuples represent fixed-length arrays with typed positions.</li>
        <li>Useful for pairs, coordinate systems, or function return values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Any, Unknown, and Never</b></li>
<pre><code class="language-ts line-numbers">let anything: any;
let data: unknown;
function fail(msg: string): never {
    throw new Error(msg);
}
</code></pre>
    <br/>
    <ul>
        <li><code>any</code>: opt-out of the type system (dangerous).</li>
        <li><code>unknown</code>: safer alternative requiring type checks.</li>
        <li><code>never</code>: represents values that never occur (e.g., errors, infinite loops).</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-more-on-functions">More on Functions</h3>
<ol>
    <li><b>Function Parameter Types</b></li>
<pre><code class="language-ts line-numbers">function greet(name: string, age: number): void {
    console.log(`Hello ${name}, age ${age}`);
}
</code></pre>
    <br/>
    <ul>
        <li>Every parameter must have a known type (explicit or inferred).</li>
        <li>TypeScript enforces parameter count and type correctness.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Optional Parameters</b></li>
<pre><code class="language-ts line-numbers">function log(message: string, userId?: number) {
    console.log(message, userId ?? "anonymous");
}

log("Hello");
log("Hi", 42);
</code></pre>
    <br/>
    <ul>
        <li><code>?</code> marks a parameter as optional.</li>
        <li>Typed as <code>T | undefined</code> internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Default Parameters</b></li>
<pre><code class="language-ts line-numbers">function multiply(a: number, b: number = 1) {
    return a * b;
}

multiply(5);  // 5
</code></pre>
    <br/>
    <ul>
        <li>Defaults provide a fallback when the caller omits a parameter.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Rest Parameters</b></li>
<pre><code class="language-ts line-numbers">function sum(...values: number[]): number {
    return values.reduce((a, b) =&gt; a + b, 0);
}

sum(1, 2, 3, 4);
</code></pre>
    <br/>
    <ul>
        <li>Rest parameters allow variable-length arguments.</li>
        <li>The type must be an array type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Return Types</b></li>
<pre><code class="language-ts line-numbers">function isEven(n: number): boolean {
    return n % 2 === 0;
}
</code></pre>
    <br/>
    <ul>
        <li>Return types can be inferred, but explicit typing improves clarity.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Anonymous and Arrow Functions</b></li>
<pre><code class="language-ts line-numbers">const double = (x: number): number =&gt; x * 2;

const logger = function(message: string): void {
    console.log(message);
};
</code></pre>
    <br/>
    <ul>
        <li>Arrow functions inherit <code>this</code> from their surrounding scope.</li>
        <li>Anonymous functions are useful for callbacks or inline logic.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Overloads</b></li>
<pre><code class="language-ts line-numbers">function format(value: number): string;
function format(value: string): string;
function format(value: number | string) {
    return `Value: ${value}`;
}

format(10);
format("hello");
</code></pre>
    <br/>
    <ul>
        <li>Overloads define multiple allowed call signatures.</li>
        <li>The implementation must handle all combined cases.</li>
        <li>Useful for flexible function APIs.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Function Types</b></li>
<pre><code class="language-ts line-numbers">type Comparator = (a: number, b: number) =&gt; number;

const compare: Comparator = (x, y) =&gt; x - y;
</code></pre>
    <br/>
    <ul>
        <li>Function types can be reused via <code>type</code> or <code>interface</code>.</li>
        <li>This improves consistency across codebases.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions as Arguments</b></li>
<pre><code class="language-ts line-numbers">function applyOperation(a: number, b: number, op: (x: number, y: number) =&gt; number) {
    return op(a, b);
}

applyOperation(3, 4, (x, y) =&gt; x + y);
</code></pre>
    <br/>
    <ul>
        <li>Functional patterns are natural in TypeScript due to strong typing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Functions</b></li>
<pre><code class="language-ts line-numbers">function identity&lt;T&gt;(value: T): T {
    return value;
}

const result = identity&lt;string&gt;("hello");
</code></pre>
    <br/>
    <ul>
        <li>Generics allow functions to work with any type while preserving type safety.</li>
        <li>The type parameter <code>&lt;T&gt;</code> is inferred or explicit.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Generic Constraints</b></li>
<pre><code class="language-ts line-numbers">function getLength&lt;T extends { length: number }&gt;(item: T) {
    return item.length;
}

getLength("hello");
getLength([1, 2, 3]);
</code></pre>
    <br/>
    <ul>
        <li>Constraints restrict which types are allowed as <code>T</code>.</li>
        <li>This enables more expressive type-safe abstractions.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Contextual Typing</b></li>
<pre><code class="language-ts line-numbers">const nums = [1, 2, 3];

nums.forEach(n =&gt; console.log(n.toFixed(2)));
</code></pre>
    <br/>
    <ul>
        <li>TypeScript infers types for anonymous functions based on their context.</li>
        <li>The callback receives <code>n: number</code> automatically.</li>
    </ul>
    <br/>
    <br/>


    <li><b><code>this</code> in Functions</b></li>
<pre><code class="language-ts line-numbers">const obj = {
    value: 10,
    getValue() {
        return this.value; // `this` is obj
    }
};
</code></pre>
    <br/>
    <ul>
        <li>Functions inside objects infer <code>this</code> automatically.</li>
        <li>Arrow functions do not bind <code>this</code> — they use the outer value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Callable and Constructable Objects</b></li>
<pre><code class="language-ts line-numbers">interface Callable {
    (msg: string): void;         // callable
    description: string;         // property
}

const fn: Callable = (m: string) =&gt; console.log(m);
fn.description = "Logger function";
</code></pre>
    <br/>
    <ul>
        <li>Functions in JS can have both call signatures and properties.</li>
        <li>TypeScript fully supports these patterns using interfaces.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions That Return Functions</b></li>
<pre><code class="language-ts line-numbers">function createMultiplier(factor: number) {
    return (n: number) =&gt; n * factor;
}

const double = createMultiplier(2);
</code></pre>
    <br/>
    <ul>
        <li>Higher-order functions are typed naturally using nested signatures.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-object-types">Object Types</h3>
<ol>
    <li><b>Basic Object Types</b></li>
<pre><code class="language-ts line-numbers">let user: {
    id: number;
    name: string;
    active: boolean;
} = {
    id: 1,
    name: "Alice",
    active: true
};
</code></pre>
    <br/>
    <ul>
        <li>This object must contain all three properties with the correct types.</li>
        <li>Extra properties are usually not allowed without special typing (see excess property checks).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Optional Properties</b></li>
<pre><code class="language-ts line-numbers">type User = {
    id: number;
    name?: string;   // optional
};
</code></pre>
    <br/>
    <ul>
        <li>Optional properties may be omitted when creating an object.</li>
        <li>The type becomes <code>string | undefined</code> internally.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Readonly Properties</b></li>
<pre><code class="language-ts line-numbers">type Config = {
    readonly host: string;
    readonly port: number;
};
</code></pre>
    <br/>
    <ul>
        <li><code>readonly</code> prevents properties from being reassigned after initialization.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Nested Object Types</b></li>
<pre><code class="language-ts line-numbers">type Product = {
    id: number;
    details: {
        name: string;
        price: number;
    };
};
</code></pre>
    <br/>
    <ul>
        <li>Object types can be nested to model complex structures.</li>
        <li>This is common in APIs, form handling, or domain models.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Object Types with Methods</b></li>
<pre><code class="language-ts line-numbers">type Point = {
    x: number;
    y: number;
    move(dx: number, dy: number): void;
};
</code></pre>
    <br/>
    <ul>
        <li>Methods can be defined directly within object types.</li>
        <li>TypeScript checks parameter and return types during usage.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Type Aliases for Object Types</b></li>
<pre><code class="language-ts line-numbers">type Address = {
    street: string;
    city: string;
    country: string;
};
</code></pre>
    <br/>
    <ul>
        <li>Type aliases allow naming reusable object type definitions.</li>
        <li>They improve readability and reduce duplication.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Intersection-Based Object Composition</b></li>
<pre><code class="language-ts line-numbers">type HasID = { id: number };
type HasName = { name: string };

type User = HasID &amp; HasName;
</code></pre>
    <br/>
    <ul>
        <li>Intersections combine smaller object fragments into larger, more detailed structures.</li>
        <li>Promotes modular design and DRY principles.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Index Signatures (Dynamic Object Keys)</b></li>
<pre><code class="language-ts line-numbers">type Scores = {
    [player: string]: number;
};

let game: Scores = {
    Alice: 10,
    Bob: 8,
    Charlie: 12
};
</code></pre>
    <br/>
    <ul>
        <li>Use index signatures when the keys are unknown ahead of time.</li>
        <li>Each key must have a value of the specified type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Excess Property Checks</b></li>
<pre><code class="language-ts line-numbers">type User = { id: number; name: string };

let u: User = {
    id: 1,
    name: "Alice",
    // age: 30   ❌ Error: extra property
};
</code></pre>
    <br/>
    <ul>
        <li>TypeScript checks for unexpected properties when assigning literal objects.</li>
        <li>This catches typos and structural mismatches early.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>in</code> for Object Type Narrowing</b></li>
<pre><code class="language-ts line-numbers">type Fish = { swim: () =&gt; void };
type Bird = { fly: () =&gt; void };

function move(animal: Fish | Bird) {
    if ("swim" in animal) {
        animal.swim();
    } else {
        animal.fly();
    }
}
</code></pre>
    <br/>
    <ul>
        <li>The <code>in</code> operator narrows union object types based on property existence.</li>
        <li>Useful for discriminated unions and polymorphic behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Object Type Compatibility</b></li>
<pre><code class="language-ts line-numbers">type Animal = { name: string };
type Dog = { name: string; bark: () =&gt; void };

let a: Animal = { name: "Spike" };
let d: Dog = { name: "Buddy", bark() {} };

a = d;   // ✔ OK (Dog has at least the properties Animal requires)
</code></pre>
    <br/>
    <ul>
        <li>TypeScript uses <b>structural typing</b> — only property shapes matter.</li>
        <li>Extra properties are allowed when assigning larger objects to smaller ones.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Readonly vs Mutable Object Types</b></li>
<pre><code class="language-ts line-numbers">type MutablePoint = { x: number; y: number };
type ReadonlyPoint = {
    readonly x: number;
    readonly y: number;
};
</code></pre>
    <br/>
    <ul>
        <li>Readonly object types prevent property reassignment, offering immutability guarantees.</li>
    </ul>
    <br/>
    <br/>


    <li><b>"Object" vs "object" vs "{}"</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>object</code></td>
                <td>Any non-primitive value</td>
                <td><code>{}, [], function() {}</code></td>
            </tr>
            <tr>
                <td><code>Object</code></td>
                <td>Type of most built-in objects (rarely used)</td>
                <td><code>new String("x")</code></td>
            </tr>
            <tr>
                <td><code>{}</code></td>
                <td>Any non-nullish value</td>
                <td><code>42, "hi", {}</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li><code>object</code> is preferred when you want "not a primitive".</li>
        <li><code>{}</code> is extremely permissive and rarely used intentionally.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-classes">Classes</h3>
<ol>
    <li><b>Basic Class Declaration</b></li>
<pre><code class="language-ts line-numbers">class User {
    id: number;
    name: string;

    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }

    greet() {
        console.log(`Hello, ${this.name}`);
    }
}

const u = new User(1, "Alice");
u.greet();
</code></pre>
    <br/>
    <ul>
        <li><code>constructor</code> is invoked when creating an instance.</li>
        <li>Properties must be declared before assignment unless using parameter properties.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Visibility Modifiers</b></li>
<pre><code class="language-ts line-numbers">class Person {
    public name: string;   // accessible everywhere
    private age: number;   // accessible inside the class only
    protected id: number;  // accessible inside class + subclasses

    constructor(name: string, age: number, id: number) {
        this.name = name;
        this.age = age;
        this.id = id;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>public</code> — accessible from anywhere (default).</li>
        <li><code>private</code> — only accessible inside the class.</li>
        <li><code>protected</code> — accessible in the class and its subclasses.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Read-only Properties</b></li>
<pre><code class="language-ts line-numbers">class Config {
    readonly host: string = "localhost";
    readonly port: number;

    constructor(port: number) {
        this.port = port;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>readonly</code> prevents reassignment after initialization.</li>
        <li>Useful for configuration objects and constants.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Parameter Properties (Shorthand)</b></li>
<pre><code class="language-ts line-numbers">class Point {
    constructor(
        public x: number,
        public y: number
    ) {}
}

const p = new Point(10, 20);
</code></pre>
    <br/>
    <ul>
        <li>Declares and initializes properties directly in the constructor.</li>
        <li>Reduces boilerplate and improves readability.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Getters and Setters</b></li>
<pre><code class="language-ts line-numbers">class Rectangle {
    constructor(private _width: number, private _height: number) {}

    get area() {
        return this._width * this._height;
    }

    set width(value: number) {
        if (value &lt;= 0) throw new Error("Invalid width");
        this._width = value;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Getters provide computed properties.</li>
        <li>Setters allow validation upon assignment.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Static Properties and Methods</b></li>
<pre><code class="language-ts line-numbers">class MathUtils {
    static PI = 3.14;

    static double(n: number) {
        return n * 2;
    }
}

console.log(MathUtils.PI);
console.log(MathUtils.double(10));
</code></pre>
    <br/>
    <ul>
        <li>Static members belong to the class itself, not instances.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Class Inheritance</b></li>
<pre><code class="language-ts line-numbers">class Animal {
    constructor(public name: string) {}

    move() {
        console.log(`${this.name} moves`);
    }
}

class Dog extends Animal {
    bark() {
        console.log("Woof!");
    }
}

const d = new Dog("Buddy");
d.move();
d.bark();
</code></pre>
    <br/>
    <ul>
        <li><code>extends</code> allows one class to inherit from another.</li>
        <li>Subclasses can access <code>public</code> and <code>protected</code> members.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Method Overriding</b></li>
<pre><code class="language-ts line-numbers">class Base {
    greet() {
        console.log("Hello from Base");
    }
}

class Derived extends Base {
    override greet() {
        console.log("Hello from Derived");
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>override</code> ensures that a method truly overrides a parent method.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Abstract Classes</b></li>
<pre><code class="language-ts line-numbers">abstract class Shape {
    abstract area(): number;
}

class Circle extends Shape {
    constructor(public radius: number) { super(); }
    area() {
        return Math.PI * this.radius ** 2;
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Abstract classes cannot be instantiated.</li>
        <li>They define required methods that subclasses must implement.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Implementing Interfaces</b></li>
<pre><code class="language-ts line-numbers">interface Logger {
    log(message: string): void;
}

class ConsoleLogger implements Logger {
    log(msg: string) {
        console.log(msg);
    }
}
</code></pre>
    <br/>
    <ul>
        <li>Classes can implement interfaces to guarantee method and property structure.</li>
        <li>Provides compile-time contracts for class behavior.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Type vs Instance Type</b></li>
<pre><code class="language-ts line-numbers">class Car {
    constructor(public brand: string) {}
}

type CarInstance = Car;              // instance type
type CarConstructor = typeof Car;    // constructor function type
</code></pre>
    <br/>
    <ul>
        <li><code>Car</code> refers to the instance type.</li>
        <li><code>typeof Car</code> refers to the constructor function type.</li>
        <li>Useful for dependency injection, factories, or meta-programming.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Private Fields (# syntax)</b></li>
<pre><code class="language-ts line-numbers">class Counter {
    #count = 0;   // hard private, JS-level

    increment() {
        this.#count++;
    }
}
</code></pre>
    <br/>
    <ul>
        <li><code>#private</code> fields are enforced by JavaScript itself.</li>
        <li>They differ from <code>private</code>, which is enforced by TypeScript only.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="ts-constructor-vs-instance">Constructor Type vs Instance Type</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In TypeScript, classes create <u>two types simultaneously</u>:</li>
        <br/>
        <ul>
            <li><b>Instance Type</b> — the type of objects created by <code>new</code>.</li>
            <li><b>Constructor Type</b> — the type of the class constructor function itself.</li>
        </ul>
        <br/>
        <li>These two types behave differently and are used in different contexts.</li>
        <br/>
        <li>Understanding the distinction is essential for dependency injection, factories, generics, and meta-programming patterns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Instance Type</b></li>
<pre><code class="language-ts line-numbers">class User {
    constructor(public id: number, public name: string) {}
}

let u: User = new User(1, "Alice");
</code></pre>
    <br/>
    <ul>
        <li><code>User</code> refers to the <u>type of instances</u> created by <code>new User()</code>.</li>
        <li>This includes all instance properties and methods.</li>
        <li>It does <u>not</u> include static members or the constructor signature.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Type</b></li>
<pre><code class="language-ts line-numbers">type UserConstructor = typeof User;
</code></pre>
    <br/>
    <ul>
        <li><code>typeof User</code> refers to the <b>constructor function</b> itself.</li>
        <li>This includes:</li>
        <ul>
            <li>the <code>new (...args)</code> signature</li>
            <li>static properties</li>
            <li>the constructor's parameter types</li>
        </ul>
        <br/>
        <li>Constructor types are useful for passing classes as values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: Comparing Both Types</b></li>
<pre><code class="language-ts line-numbers">class Car {
    static company = "Tesla";

    constructor(public model: string) {}
}

type CarInstance = Car;             // instance type
type CarConstructor = typeof Car;   // constructor type
</code></pre>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Instance Type (<code>Car</code>)</th>
                <th>Constructor Type (<code>typeof Car</code>)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Instance properties</td>
                <td>✔ Available</td>
                <td>✘ Not available</td>
            </tr>
            <tr>
                <td>Instance methods</td>
                <td>✔ Available</td>
                <td>✘ Not available</td>
            </tr>
            <tr>
                <td>Static members</td>
                <td>✘ Not available</td>
                <td>✔ Available</td>
            </tr>
            <tr>
                <td>Constructor signature</td>
                <td>✘ No</td>
                <td>✔ Yes</td>
            </tr>
            <tr>
                <td>Used with <code>new</code></td>
                <td>✘ No</td>
                <td>✔ Yes</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Using Constructor Types for Factories</b></li>
<pre><code class="language-ts line-numbers">function createInstance(ctor: { new (...args: any[]): any }) {
    return new ctor();
}

class A { constructor() { console.log("A created"); } }
class B { constructor() { console.log("B created"); } }

createInstance(A);
createInstance(B);
</code></pre>
    <br/>
    <ul>
        <li>Factories often accept constructor types rather than instances.</li>
        <li>TypeScript enforces that the provided argument supports <code>new</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Typing Class Constructors More Strictly</b></li>
<pre><code class="language-ts line-numbers">interface UserConstructor {
    new (id: number, name: string): { id: number; name: string };
}

function createUser(ctor: UserConstructor) {
    return new ctor(1, "Alice");
}
</code></pre>
    <br/>
    <ul>
        <li>You can define detailed constructor signatures using interfaces.</li>
        <li>This is extremely powerful for plugins, DI containers, and testing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Static Properties Live on the Constructor Type</b></li>
<pre><code class="language-ts line-numbers">class Settings {
    static version = "1.0";
    theme = "light";
}

let s: Settings = new Settings();   // instance type
let C: typeof Settings = Settings;  // constructor type

console.log(C.version); // OK
console.log(s.theme);   // OK
</code></pre>
    <br/>
    <ul>
        <li>Static fields belong to the constructor type.</li>
        <li>Instance fields belong to the instance type.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Types and Dependency Injection</b></li>
<pre><code class="language-ts line-numbers">function runService(ctor: { new(): Service }) {
    const service = new ctor();
    service.run();
}

class Service {
    run() { console.log("Running service..."); }
}

runService(Service);
</code></pre>
    <br/>
    <ul>
        <li>DI frameworks frequently accept constructor types to dynamically create instances.</li>
        <li>TypeScript ensures correctness via <code>new()</code> signatures.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Constructor Types with Generics</b></li>
<pre><code class="language-ts line-numbers">function create&lt;T&gt;(ctor: { new (...args: any[]): T }): T {
    return new ctor();
}

class Logger { log() { console.log("log"); } }

const logger = create(Logger);
</code></pre>
    <br/>
    <ul>
        <li>Generics ensure the returned instance has the correct type.</li>
        <li>Used widely in factory abstractions and IoC containers.</li>
    </ul>
    <br/>
    <br/>


    <li><b>A Class Is Both a Value and a Type</b></li>
<pre><code class="language-ts line-numbers">class Example {}

type T1 = Example;     // instance type
const T2 = Example;    // constructor value
</code></pre>
    <br/>
    <ul>
        <li><code>Example</code> (in a type position) = the instance type.</li>
        <li><code>Example</code> (in a value position) = the constructor function.</li>
        <li>This duality is unique compared to many other languages.</li>
    </ul>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
