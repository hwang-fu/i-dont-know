<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>golang</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "æ¥·ä½“", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "æ¥·ä½“", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/golang.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#go-introduction">Introduction to Golang</a></li>
        <li><a href="#go-hello-world">Hello World</a></li>
        <li><a href="#go-variables">Variables and Data Types</a></li>
        <li><a href="#go-functions">Functions</a></li>
        <li><a href="#go-packages">Packages</a></li>
        <li><a href="#go-module-naming">Understanding Go Module Names and Project Naming</a></li>
        <li><a href="#go-control-flow">Control Flow</a></li>
        <li><a href="#go-arrays-slices">Arrays and Slices</a></li>
        <li><a href="#go-variadic-functions">Variadic Functions</a></li>
        <li><a href="#go-type-aliases">Type Aliases</a></li>
        <li><a href="#go-maps">Maps</a></li>
        <li><a href="#go-strings">Strings</a></li>
        <li><a href="#go-pointers">Pointers</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-introduction">Introduction to Golang</h3>
<ol>

    <li>What Is Go (Golang)?</li>
    <br/>
    <ul>
        <li><b>Go</b> (also known as <b>Golang</b>) is a statically typed, compiled programming language designed at Google.</li>
        <br/>
        <li>The name "Golang" comes from the domain name <code>golang.org</code> (to make it more searchable).</li>
    </ul>
    <br/><br/>

    <li>Go favors <b>composition over inheritance</b> and <b>explicit over implicit</b> behavior.</li>
    <br/><br/>


    <li>Key Features of Go</li>
    <br/>
    <ul>
        <li><b>Static Typing:</b> Variables have types known at compile time, catching errors early.</li>
        <br/>
        <li><b>Fast Compilation:</b> Go compiles directly to machine code extremely quickly.</li>
        <br/>
        <li><b>Goroutines:</b> Lightweight threads that enable easy concurrent programming.</li>
        <br/>
        <li><b>Channels:</b> Built-in primitives for safe communication between goroutines.</li>
        <br/>
        <li><b>Garbage Collection:</b> Automatic memory management without manual allocation/deallocation.</li>
        <br/>
        <li><b>Standard Library:</b> Rich, comprehensive standard library for networking, I/O, cryptography, and more.</li>
        <br/>
        <li><b>Cross-Platform:</b> Compiles to native binaries for Windows, Linux, macOS, and many other platforms.</li>
        <br/>
        <li><b>Built-in Tooling:</b> Includes formatter, linter, testing framework, package manager, and documentation generator.</li>
        <br/>
        <li><b>No Generics (until Go 1.18):</b> Originally designed without generics for simplicity, added in 2022.</li>
    </ul>
    <br/><br/>


    <li>Setting Up Your First Go Project</li>
    <br/>
    <ul>
        <li>Create a project directory:</li>
<pre><code class="language-bash line-numbers">mkdir hello-go
cd hello-go</code></pre>
        <br/>
        <li>Initialize a Go module:</li>
<pre><code class="language-bash line-numbers">go mod init example.com/hello</code></pre>
        <br/>
        <li>This creates a <code>go.mod</code> file that tracks dependencies.</li>
        <br/>
        <li>Go modules are the standard way to manage dependencies since Go 1.11.</li>
    </ul>
    <br/><br/>


    <li>Hello World in Go</li>
    <br/>
    <ul>
        <li>Create a file named <code>main.go</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre>
        <ul>
            <li><code>package main</code> declares this as an executable program</li>
            <li><code>import "fmt"</code> imports the format/print package</li>
            <li><code>func main()</code> is the entry point of the program</li>
            <li><code>fmt.Println()</code> prints text to the console</li>
        </ul>
        <br/>
        <li>Run the program:</li>
<pre><code class="language-bash line-numbers">go run main.go</code></pre>
        <br/>
        <li>Build an executable:</li>
<pre><code class="language-bash line-numbers">go build main.go
./main</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Go Syntax Overview</li>
    <br/>
    <ul>
        <li><b>Variable Declaration:</b></li>
<pre><code class="language-go line-numbers">var name string = "Junzhe"
age := 30  // Short declaration with type inference</code></pre>
        <br/>
        <li><b>Constants:</b></li>
<pre><code class="language-go line-numbers">const Pi = 3.14159</code></pre>
        <br/>
        <li><b>Functions:</b></li>
<pre><code class="language-go line-numbers">func add(x int, y int) int {
    return x + y
}</code></pre>
        <br/>
        <li><b>Control Structures:</b></li>
<pre><code class="language-go line-numbers">if x > 10 {
    fmt.Println("x is large")
}

for i := 0; i < 5; i++ {
    fmt.Println(i)
}

switch day {
case "Monday":
    fmt.Println("Start of week")
default:
    fmt.Println("Other day")
}</code></pre>
        <br/>
        <li>Note: Go has no <code>while</code> loop, <code>for</code> is used for all loops.</li>
    </ul>
    <br/><br/>


    <li>Go's Type System</li>
    <br/>
    <ul>
        <li>Basic types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Category</th>
            <th>Types</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Boolean</b></td>
            <td><code>bool</code></td>
        </tr>
        <tr>
            <td><b>String</b></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td><b>Integer</b></td>
            <td>
                <code>int</code>, <code>int8</code>,
                <code>int16</code>, <code>int32</code>,
                <code>int64</code>, <code>uint</code>,
                <code>uint8</code>, <code>uint16</code>,
                <code>uint32</code>, <code>uint64</code>
            </td>
        </tr>
        <tr>
            <td><b>Float</b></td>
            <td><code>float32</code>, <code>float64</code></td>
        </tr>
        <tr>
            <td><b>Complex</b></td>
            <td><code>complex64</code>, <code>complex128</code></td>
        </tr>
        <tr>
            <td><b>Byte</b></td>
            <td><code>byte</code> (alias for <code>uint8</code>)</td>
        </tr>
        <tr>
            <td><b>Rune</b></td>
            <td><code>rune</code> (alias for <code>int32</code>, represents Unicode code point)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Composite types:
            <ul>
                <li>Arrays: <code>[5]int</code></li>
                <li>Slices: <code>[]int</code></li>
                <li>Maps: <code>map[string]int</code></li>
                <li>Structs: <code>type Person struct { Name string; Age int }</code></li>
                <li>Pointers: <code>*int</code></li>
                <li>Interfaces: <code>interface{}</code></li>
                <li>Channels: <code>chan int</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Concurrency: Goroutines and Channels</li>
    <br/>
    <ul>
        <li><b>Goroutines</b> are lightweight threads managed by the Go runtime.</li>
        <br/>
        <li>Starting a goroutine:</li>
<pre><code class="language-go line-numbers">go myFunction()  // Runs concurrently

go func() {
    fmt.Println("Anonymous goroutine")
}()</code></pre>
        <br/>
        <li><b>Channels</b> enable safe communication between goroutines:</li>
<pre><code class="language-go line-numbers">ch := make(chan int)

go func() {
    ch <- 42  // Send value to channel
}()

value := <-ch  // Receive value from channel
fmt.Println(value)</code></pre>
        <br/>
        <li>This model follows the philosophy: <b>"Don't communicate by sharing memory, share memory by communicating."</b></li>
    </ul>
    <br/><br/>


    <li>Go's Standard Library</li>
    <br/>
    <ul>
        <li>Go includes a powerful standard library for common tasks:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fmt</code></td>
            <td>Formatted I/O (printing, scanning)</td>
        </tr>
        <tr>
            <td><code>net/http</code></td>
            <td>HTTP client and server</td>
        </tr>
        <tr>
            <td><code>encoding/json</code></td>
            <td>JSON encoding and decoding</td>
        </tr>
        <tr>
            <td><code>io</code></td>
            <td>Basic I/O primitives</td>
        </tr>
        <tr>
            <td><code>os</code></td>
            <td>Operating system functionality</td>
        </tr>
        <tr>
            <td><code>time</code></td>
            <td>Time and duration handling</td>
        </tr>
        <tr>
            <td><code>strings</code></td>
            <td>String manipulation</td>
        </tr>
        <tr>
            <td><code>testing</code></td>
            <td>Automated testing support</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Standard library documentation:</li>
<pre><code class="language-plaintext line-numbers">https://pkg.go.dev/std</code></pre>
    </ul>
    <br/><br/>


    <li>Built-in Tooling</li>
    <br/>
    <ul>
        <li>Go provides excellent tools out of the box:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>go build</code></td>
            <td>Compile packages and dependencies</td>
        </tr>
        <tr>
            <td><code>go run</code></td>
            <td>Compile and run Go program</td>
        </tr>
        <tr>
            <td><code>go test</code></td>
            <td>Run tests</td>
        </tr>
        <tr>
            <td><code>go fmt</code></td>
            <td>Format Go source code</td>
        </tr>
        <tr>
            <td><code>go get</code></td>
            <td>Download and install packages</td>
        </tr>
        <tr>
            <td><code>go mod</code></td>
            <td>Module maintenance</td>
        </tr>
        <tr>
            <td><code>go doc</code></td>
            <td>Show documentation</td>
        </tr>
        <tr>
            <td><code>go vet</code></td>
            <td>Examine code for suspicious constructs</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example usage:</li>
<pre><code class="language-bash line-numbers">go fmt ./...        # Format all files in project
go test ./...       # Run all tests
go vet ./...        # Check for issues</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-hello-world">Your First Go Program</h3>
<ol>

    <li>Creating the Hello World Program</li>
    <br/>
    <ul>
        <li>Create a new directory for your project:</li>
<pre><code class="language-bash line-numbers">mkdir hello-world
cd hello-world</code></pre>
        <br/>
        <li>Initialize a Go module:</li>
<pre><code class="language-bash line-numbers">go mod init example.com/hello</code></pre>
        <br/>
        <li>This creates a <code>go.mod</code> file that defines your module's path and dependencies.</li>
        <br/>
        <li>Create a file named <code>main.go</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre>
        <br/>
        <li>This is the simplest complete Go program.</li>
    </ul>
    <br/><br/>


    <li>Understanding the Program Structure</li>
    <br/>
    <ul>
        <li>Every Go program is organized into packages.</li>
        <br/>
        <li>Line-by-line explanation:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Line</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>package main</code></td>
            <td>Declares this file belongs to the <code>main</code> package, which creates an executable program</td>
        </tr>
        <tr>
            <td><code>import "fmt"</code></td>
            <td>Imports the <code>fmt</code> package for formatted I/O operations</td>
        </tr>
        <tr>
            <td><code>func main()</code></td>
            <td>Defines the <code>main</code> function, the entry point of the program</td>
        </tr>
        <tr>
            <td><code>fmt.Println(...)</code></td>
            <td>Calls the <code>Println</code> function from the <code>fmt</code> package to print text</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The <code>main</code> package is special: it tells the Go compiler to create an executable rather than a library.</li>
        <br/>
        <li>The <code>main()</code> function is automatically called when the program starts.</li>
    </ul>
    <br/><br/>


    <li>Running the Program</li>
    <br/>
    <ul>
        <li>Use <code>go run</code> to compile and execute in one step:</li>
<pre><code class="language-bash line-numbers">go run main.go</code></pre>
        <br/>
        <li>Expected output:</li>
<pre><code class="language-plaintext line-numbers">Hello, World!</code></pre>
        <br/>
        <li>The <code>go run</code> command:
            <ul>
                <li>compiles your code</li>
                <li>creates a temporary executable</li>
                <li>runs the executable</li>
                <li>cleans up the temporary files</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Building an Executable</li>
    <br/>
    <ul>
        <li>To create a standalone executable, use <code>go build</code>:</li>
<pre><code class="language-bash line-numbers">go build main.go</code></pre>
        <br/>
        <li>This creates an executable file:
            <ul>
                <li>On Linux/macOS: <code>main</code></li>
                <li>On Windows: <code>main.exe</code></li>
            </ul>
        </li>
        <br/>
        <li>Run the executable directly:</li>
<pre><code class="language-bash line-numbers">./main        # Linux/macOS
main.exe      # Windows</code></pre>
        <br/>
        <li>Custom output name:</li>
<pre><code class="language-bash line-numbers">go build -o hello main.go
./hello</code></pre>
        <br/>
        <li>The executable is a self-contained binary with no external dependencies.</li>
    </ul>
    <br/><br/>


    <li>Understanding the Import Statement</li>
    <br/>
    <ul>
        <li>The <code>import</code> keyword brings in packages you need:</li>
<pre><code class="language-go line-numbers">import "fmt"              // Single import

import (                  // Multiple imports
    "fmt"
    "time"
    "strings"
)</code></pre>
        <br/>
        <li>Common standard library packages:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fmt</code></td>
            <td>Formatted I/O (printing, scanning)</td>
        </tr>
        <tr>
            <td><code>os</code></td>
            <td>Operating system functionality</td>
        </tr>
        <tr>
            <td><code>strings</code></td>
            <td>String manipulation functions</td>
        </tr>
        <tr>
            <td><code>time</code></td>
            <td>Time and date operations</td>
        </tr>
        <tr>
            <td><code>math</code></td>
            <td>Mathematical functions</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Go automatically removes unused imports when you run <code>go fmt</code>.</li>
        <br/>
        <li>Importing a package without using it causes a compilation error.</li>
    </ul>
    <br/><br/>


    <li>Variations of Hello World</li>
    <br/>
    <ul>
        <li>Using <code>fmt.Print()</code> without newline:</li>
<pre><code class="language-go line-numbers">fmt.Print("Hello, World!")  // No automatic newline</code></pre>
        <br/>
        <li>Using <code>fmt.Printf()</code> for formatted output:</li>
<pre><code class="language-go line-numbers">name := "Go"
fmt.Printf("Hello, %s!\n", name)</code></pre>
        <br/>
        <li>Printing multiple values:</li>
<pre><code class="language-go line-numbers">fmt.Println("Hello,", "World", "from", "Go")</code></pre>
        <br/>
        <li>Using variables:</li>
<pre><code class="language-go line-numbers">func main() {
    greeting := "Hello, World!"
    fmt.Println(greeting)
}</code></pre>
        <br/>
        <li>Accepting user input:</li>
<pre><code class="language-go line-numbers">func main() {
    var name string
    fmt.Print("Enter your name: ")
    fmt.Scan(&name)
    fmt.Printf("Hello, %s!\n", name)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Adding Comments</li>
    <br/>
    <ul>
        <li>Go supports two types of comments:</li>
<pre><code class="language-go line-numbers">// Single-line comment

/*
   Multi-line comment
   Can span multiple lines
*/</code></pre>
        <br/>
        <li>Documented example:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

// main is the entry point of the program
func main() {
    // Print a greeting message
    fmt.Println("Hello, World!")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Formatting Your Code</li>
    <br/>
    <ul>
        <li>Go includes a built-in formatter called <code>gofmt</code>:</li>
<pre><code class="language-bash line-numbers">gofmt -w main.go</code></pre>
        <br/>
        <li>Or use the <code>go fmt</code> command:</li>
<pre><code class="language-bash line-numbers">go fmt main.go</code></pre>
        <br/>
        <li>Format all files in current directory:</li>
<pre><code class="language-bash line-numbers">go fmt ./...</code></pre>
        <br/>
        <li>All Go code should be formatted with <code>gofmt</code> before committing.</li>
        <br/>
        <li>Most editors can run <code>gofmt</code> automatically on save.</li>
    </ul>
    <br/><br/>


    <li>Understanding Module Initialization</li>
    <br/>
    <ul>
        <li>The <code>go.mod</code> file defines your module:</li>
<pre><code class="language-plaintext line-numbers">module example.com/hello

go 1.21</code></pre>
        <li>Module path components:</li>
        <ul>
            <li><code>example.com/hello</code> is an unique identifier for your module</li>
            <li><code>go 1.21</code> is the minimum Go version required</li>
        </ul>
        <br/>
        <li>For real projects, use your actual domain or repository:</li>
<pre><code class="language-bash line-numbers">go mod init github.com/username/projectname</code></pre>
        <li>The module path becomes the import path for packages within your project.</li>
    </ul>
    <br/><br/>


    <li>Running the Program with Arguments</li>
    <br/>
    <ul>
        <li>Access command-line arguments using the <code>os</code> package:</li>
<pre><code class="language-go line-numbers">package main

import (
    "fmt"
    "os"
)

func main() {
    args := os.Args
    if len(args) &gt; 1 {
        fmt.Printf("Hello, %s!\n", args[1])
    } else {
        fmt.Println("Hello, World!")
    }
}</code></pre>
        <br/>
        <li>Run with arguments:</li>
<pre><code class="language-bash line-numbers">go run main.go Junzhe</code></pre>
        <br/>
        <li>Output:</li>
<pre><code class="language-plaintext line-numbers">Hello, Junzhe!</code></pre>
        <br/>
        <li><code>os.Args[0]</code> contains the program name.</li>
        <br/>
        <li><code>os.Args[1]</code> and beyond contain the actual arguments.</li>
    </ul>
    <br/><br/>


    <li>Creating Multiple Functions</li>
    <br/>
    <ul>
        <li>You can define additional functions beyond <code>main()</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func greet(name string) string {
    return "Hello, " + name + "!"
}

func main() {
    message := greet("World")
    fmt.Println(message)
}</code></pre>
        <li>Functions must be defined before use or in any order at package level.</li>
    </ul>
    <br/><br/>


    <li>Cross-Compiling for Different Platforms</li>
    <br/>
    <ul>
        <li>Go makes it easy to build executables for different operating systems:</li>
<pre><code class="language-bash line-numbers"># Build for Windows from Linux/macOS
GOOS=windows GOARCH=amd64 go build -o hello.exe main.go

# Build for Linux from Windows/macOS
GOOS=linux GOARCH=amd64 go build -o hello main.go

# Build for macOS from Linux/Windows
GOOS=darwin GOARCH=amd64 go build -o hello main.go</code></pre>
        <br/><li>Common GOOS and GOARCH values:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>GOOS (Operating System)</th>
            <th>GOARCH (Architecture)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>linux</code></td>
            <td><code>amd64</code> (64-bit)</td>
        </tr>
        <tr>
            <td><code>windows</code></td>
            <td><code>386</code> (32-bit)</td>
        </tr>
        <tr>
            <td><code>darwin</code> (macOS)</td>
            <td><code>arm</code></td>
        </tr>
        <tr>
            <td><code>freebsd</code></td>
            <td><code>arm64</code></td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-variables">Go Variables and Data Types</h3>
<ol>

    <li>What Are Variables?</li>
    <br/>
    <ul>
        <li>A <b>variable</b> is a named storage location that holds a value of a specific type.</li>
        <br/>
        <li>Variables in Go are:</li>
        <ul>
            <li>statically typed (type is known at compile time)</li>
            <li>explicitly declared or inferred</li>
            <li>initialized with zero values if not assigned</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Declaring Variables</li>
    <br/>
    <ul>
        <li>Go provides several ways to declare variables:</li>
        <br/>
        <li>Using <code>var</code> keyword:</li>
<pre><code class="language-go line-numbers">var name string
var age int
var isActive bool</code></pre>
        <br/>
        <li>With initialization:</li>
<pre><code class="language-go line-numbers">var name string = "Junzhe"
var age int = 30
var isActive bool = true</code></pre>
        <br/>
        <li>Type inference (omit type):</li>
<pre><code class="language-go line-numbers">var name = "Junzhe"     // Go infers string
var age = 30            // Go infers int
var isActive = true     // Go infers bool</code></pre>
        <br/>
        <li>Short declaration (inside functions only):</li>
<pre><code class="language-go line-numbers">name := "Junzhe"
age := 30
isActive := true</code></pre>
        <br/>
        <li>The <code>:=</code> operator declares and initializes in one step.</li>
    </ul>
    <br/><br/>


    <li>Zero Values</li>
    <br/>
    <ul>
        <li>Variables declared without initialization receive a <b>zero value</b>:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Zero Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>float32</code>, <code>float64</code></td>
            <td><code>0.0</code></td>
        </tr>
        <tr>
            <td><code>bool</code></td>
            <td><code>false</code></td>
        </tr>
        <tr>
            <td><code>string</code></td>
            <td><code>""</code> (empty string)</td>
        </tr>
        <tr>
            <td>Pointers, functions, interfaces, slices, channels, maps</td>
            <td><code>nil</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">var count int        // 0
var price float64    // 0.0
var name string      // ""
var active bool      // false</code></pre>
        <br/>
        <li>Zero values make variables safe to use immediately without explicit initialization.</li>
    </ul>
    <br/><br/>


    <li>Basic Data Types</li>
    <br/>
    <ul>
        <li>Go has several categories of basic types:</li>
        <br/>
        <li><b>Boolean Type:</b></li>
<pre><code class="language-go line-numbers">var isReady bool = true
var hasError bool = false</code></pre>
        <br/>
        <li><b>String Type:</b></li>
<pre><code class="language-go line-numbers">var message string = "Hello, Go!"
var empty string   // "" (empty string)</code></pre>
        <br/>
        <li><b>Integer Types:</b></li>
<pre><code class="language-go line-numbers">var age int = 25
var count int32 = 100
var bigNumber int64 = 9223372036854775807</code></pre>
        <br/>
        <li><b>Unsigned Integer Types:</b></li>
<pre><code class="language-go line-numbers">var distance uint = 1000
var byteValue uint8 = 255</code></pre>
        <br/>
        <li><b>Floating-Point Types:</b></li>
<pre><code class="language-go line-numbers">var price float32 = 19.99
var pi float64 = 3.14159265359</code></pre>
        <br/>
        <li><b>Complex Number Types:</b></li>
<pre><code class="language-go line-numbers">var complex1 complex64 = 1 + 2i
var complex2 complex128 = 3.5 + 4.2i</code></pre>
    </ul>
    <br/><br/>


    <li>Integer Types Overview</li>
    <br/>
    <ul>
        <li>Go provides sized integer types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Size</th>
            <th>Range</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>int8</code></td>
            <td>8 bits</td>
            <td>-128 to 127</td>
        </tr>
        <tr>
            <td><code>int16</code></td>
            <td>16 bits</td>
            <td>-32,768 to 32,767</td>
        </tr>
        <tr>
            <td><code>int32</code></td>
            <td>32 bits</td>
            <td>-2,147,483,648 to 2,147,483,647</td>
        </tr>
        <tr>
            <td><code>int64</code></td>
            <td>64 bits</td>
            <td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
        </tr>
        <tr>
            <td><code>int</code></td>
            <td>32 or 64 bits</td>
            <td>Platform dependent</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Unsigned integer types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Size</th>
            <th>Range</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>uint8</code></td>
            <td>8 bits</td>
            <td>0 to 255</td>
        </tr>
        <tr>
            <td><code>uint16</code></td>
            <td>16 bits</td>
            <td>0 to 65,535</td>
        </tr>
        <tr>
            <td><code>uint32</code></td>
            <td>32 bits</td>
            <td>0 to 4,294,967,295</td>
        </tr>
        <tr>
            <td><code>uint64</code></td>
            <td>64 bits</td>
            <td>0 to 18,446,744,073,709,551,615</td>
        </tr>
        <tr>
            <td><code>uint</code></td>
            <td>32 or 64 bits</td>
            <td>Platform dependent</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Use <code>int</code> for most cases unless you need a specific size.</li>
    </ul>
    <br/><br/>


    <li>Special Integer Types</li>
    <br/>
    <ul>
        <li>Go provides special-purpose integer types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>byte</code></td>
            <td>Alias for <code>uint8</code>, used for raw data</td>
        </tr>
        <tr>
            <td><code>rune</code></td>
            <td>Alias for <code>int32</code>, represents a Unicode code point</td>
        </tr>
        <tr>
            <td><code>uintptr</code></td>
            <td>Unsigned integer large enough to hold a pointer</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example using <code>byte</code>:</li>
<pre><code class="language-go line-numbers">var data byte = 255</code></pre>
        <br/>
        <li>Example using <code>rune</code>:</li>
<pre><code class="language-go line-numbers">var letter rune = 'A'     // Unicode code point for 'A'
var emoji rune = 'ðŸ˜€'      // Unicode code point for emoji</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Variable Declarations</li>
    <br/>
    <ul>
        <li>Declare multiple variables of the same type:</li>
<pre><code class="language-go line-numbers">var x, y, z int
var a, b, c = 1, 2, 3</code></pre>
        <br/>
        <li>Declare multiple variables of different types:</li>
<pre><code class="language-go line-numbers">var (
    name   string  = "Junzhe"
    age    int     = 30
    height float64 = 5.7
)</code></pre>
        <br/>
        <li>Short declaration with multiple variables:</li>
<pre><code class="language-go line-numbers">name, age := "Junzhe", 30
x, y, z   := 1, 2, 3</code></pre>
        <br/>
        <li>At least one new variable must be declared when using <code>:=</code>:</li>
<pre><code class="language-go line-numbers">name := "Alice"
name, age := "Bob", 30  // OK: age is new
// name := "Charlie"    // Error: no new variables</code></pre>
    </ul>
    <br/><br/>


    <li>Constants</li>
    <br/>
    <ul>
        <li>Constants are immutable values declared with the <code>const</code> keyword:</li>
<pre><code class="language-go line-numbers">const Pi = 3.14159
const MaxUsers = 100
const AppName = "MyApp"</code></pre>
        <br/>
        <li>Constants can be typed or untyped:</li>
<pre><code class="language-go line-numbers">const TypedPi float64 = 3.14159  // Typed constant
const UntypedPi = 3.14159        // Untyped constant</code></pre>
        <br/>
        <li>Multiple constants:</li>
<pre><code class="language-go line-numbers">const (
    StatusOK       = 200
    StatusNotFound = 404
    StatusError    = 500
)</code></pre>
        <br/>
        <li>Constants cannot use the <code>:=</code> syntax.</li>
        <br/>
        <li>Constants must be assigned at compile time (no runtime values).</li>
    </ul>
    <br/><br/>


    <li>Type Conversion</li>
    <br/>
    <ul>
        <li>Go does not allow implicit type conversion:</li>
<pre><code class="language-go line-numbers">var i int = 42
var f float64 = i      // Error: cannot use i (type int) as type float64</code></pre>
        <br/>
        <li>Explicit conversion is required:</li>
<pre><code class="language-go line-numbers">var i int = 42
var f float64 = float64(i)  // OK: explicit conversion</code></pre>
        <br/>
        <li>Common conversions:</li>
<pre><code class="language-go line-numbers">var x int = 100
var y float64 = float64(x)
var z int32 = int32(x)
var s string = string(x)     // Converts to Unicode character, not "100"</code></pre>
        <br/>
        <li>Converting integers to strings (proper way):</li>
<pre><code class="language-go line-numbers">import "strconv"

var num int = 42
var str string = strconv.Itoa(num)  // "42"</code></pre>
        <br/>
        <li>Converting strings to integers:</li>
<pre><code class="language-go line-numbers">import "strconv"

var str string = "42"
num, err := strconv.Atoi(str)  // num = 42, err = nil</code></pre>
    </ul>
    <br/><br/>


    <li>Variable Scope</li>
    <br/>
    <ul>
        <li>Variables have different scopes based on where they're declared:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Scope Level</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Package-level</b></td>
            <td>Declared outside functions, accessible throughout the package</td>
        </tr>
        <tr>
            <td><b>Function-level</b></td>
            <td>Declared inside functions, accessible only within that function</td>
        </tr>
        <tr>
            <td><b>Block-level</b></td>
            <td>Declared inside blocks (if, for, etc.), accessible only in that block</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">package main

var globalVar = "I'm global"  // Package-level

func main() {
    var localVar = "I'm local"  // Function-level

    if true {
        var blockVar = "I'm in a block"  // Block-level
        fmt.Println(globalVar)   // OK
        fmt.Println(localVar)    // OK
        fmt.Println(blockVar)    // OK
    }

    // fmt.Println(blockVar)  // Error: undefined
}</code></pre>
        <br/>
        <li>Package-level variables cannot use the <code>:=</code> syntax.</li>
    </ul>
    <br/><br/>


    <li>Naming Conventions</li>
    <br/>
    <ul>
        <li>Go has strict naming rules and conventions:</li>
        <br/>
        <li><b>Basic rules:</b></li>
        <ul>
            <li>must start with a letter or underscore</li>
            <li>can contain letters, digits, and underscores</li>
            <li>case-sensitive (<code>name</code> and <code>Name</code> are different)</li>
        </ul>
        <br/>
        <li><b>Visibility rules:</b></li>
<table>
    <thead>
        <tr>
            <th>Case</th>
            <th>Visibility</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Starts with uppercase</td>
            <td>Exported (public)</td>
            <td><code>MaxValue</code>, <code>UserName</code></td>
        </tr>
        <tr>
            <td>Starts with lowercase</td>
            <td>Unexported (private)</td>
            <td><code>maxValue</code>, <code>userName</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Naming conventions:</b></li>
        <ul>
            <li>use camelCase for local variables: <code>userName</code>, <code>totalCount</code></li>
            <li>use PascalCase for exported names: <code>UserName</code>, <code>TotalCount</code></li>
            <li>short names are preferred for small scopes: <code>i</code>, <code>j</code>, <code>err</code></li>
            <li>acronyms should be all caps: <code>HTTP</code>, <code>URL</code>, <code>ID</code></li>
        </ul>
        <br/>
        <li>Good examples:</li>
<pre><code class="language-go line-numbers">var userCount int
var httpClient *http.Client
var userID string</code></pre>
        <br/>
        <li>Avoid using underscore separators except for package-level constants.</li>
    </ul>
    <br/><br/>


    <li>The Blank Identifier</li>
    <br/>
    <ul>
        <li>The underscore <code>_</code> is a special identifier that discards values:</li>
<pre><code class="language-go line-numbers">// Ignore a return value
result, _ := someFunction()  // Ignore error

// Ignore first value
_, value := someFunction()   // Ignore result

// Import package for side effects only
import _ "github.com/lib/pq"</code></pre>
        <br/>
        <li>Example with range:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}

for _, num := range numbers {  // Ignore index
    fmt.Println(num)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Variable Shadowing</li>
    <br/>
    <ul>
        <li>A variable in an inner scope can <b>shadow</b> a variable in an outer scope:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

var x = "global"

func main() {
    fmt.Println(x)  // "global"

    x := "local"    // Shadows the global x
    fmt.Println(x)  // "local"

    {
        x := "block"  // Shadows the function-level x
        fmt.Println(x)  // "block"
    }

    fmt.Println(x)  // "local"
}</code></pre>
        <br/>
        <li>Shadowing can lead to bugs, so use it carefully.</li>
        <br/>
        <li>Many linters warn about shadowing common variables like <code>err</code>.</li>
    </ul>
    <br/><br/>


    <li>Pointers and Variables</li>
    <br/>
    <ul>
        <li>Go supports pointers, which store memory addresses:</li>
<pre><code class="language-go line-numbers">var x int = 42
var p *int = &amp;x  // p holds the address of x

fmt.Println(x)   // 42
fmt.Println(p)   // 0xc0000b4008 (memory address)
fmt.Println(*p)  // 42 (dereference to get value)</code></pre>
        <br/>
        <li>Pointer operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>&amp;</code></td>
            <td>Address-of operator (gets memory address)</td>
        </tr>
        <tr>
            <td><code>*</code></td>
            <td>Dereference operator (gets value at address)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Modifying through pointers:</li>
<pre><code class="language-go line-numbers">var x int = 10
var p *int = &amp;x

*p = 20          // Modify x through pointer
fmt.Println(x)   // 20</code></pre>
        <br/>
        <li>Zero value of a pointer is <code>nil</code>.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-functions">Functions in Go</h3>
<ol>

    <li>What Are Functions?</li>
    <br/>
    <ul>
        <li>A <b>function</b> is a reusable block of code that performs a specific task.</li>
        <br/>
        <li>Functions in Go:</li>
        <ul>
            <li>are first-class citizens (can be assigned to variables, passed as arguments)</li>
            <li>can return multiple values</li>
            <li>support named return values</li>
            <li>can be anonymous (function literals)</li>
            <li>can form closures</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Basic Function Syntax</li>
    <br/>
    <ul>
        <li>The basic syntax for declaring a function:</li>
<pre><code class="language-go line-numbers">func functionName(parameter1 type1, parameter2 type2) returnType {
    // function body
    return value
}</code></pre>
        <br/>
        <li>Simple example:</li>
<pre><code class="language-go line-numbers">func greet(name string) string {
    return "Hello, " + name
}

func main() {
    message := greet("Alice")
    fmt.Println(message)  // Hello, Alice
}</code></pre>
        <br/>
        <li>Function components:</li>
<table>
    <thead>
        <tr>
            <th>Component</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>func</code></td>
            <td>Keyword to declare a function</td>
        </tr>
        <tr>
            <td><code>functionName</code></td>
            <td>Name of the function (must start with letter)</td>
        </tr>
        <tr>
            <td><code>(parameters)</code></td>
            <td>Input parameters (optional)</td>
        </tr>
        <tr>
            <td><code>returnType</code></td>
            <td>Type of value returned (optional)</td>
        </tr>
        <tr>
            <td><code>return</code></td>
            <td>Statement to return a value (if return type specified)</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Functions Without Return Values</li>
    <br/>
    <ul>
        <li>Functions can execute code without returning a value:</li>
<pre><code class="language-go line-numbers">func printMessage(message string) {
    fmt.Println(message)
}

func main() {
    printMessage("Hello, World!")
}</code></pre>
        <br/>
        <li>No return type is specified.</li>
        <br/>
        <li>The <code>return</code> keyword can be used to exit early:</li>
<pre><code class="language-go line-numbers">func process(value int) {
    if value < 0 {
        return  // Exit early
    }
    fmt.Println("Processing:", value)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Functions With Parameters</li>
    <br/>
    <ul>
        <li>Functions can accept zero or more parameters:</li>
<pre><code class="language-go line-numbers">// No parameters
func sayHello() {
    fmt.Println("Hello!")
}

// One parameter
func square(x int) int {
    return x * x
}

// Multiple parameters
func add(x int, y int) int {
    return x + y
}</code></pre>
        <br/>
        <li>When consecutive parameters have the same type, you can omit the type for all but the last:</li>
<pre><code class="language-go line-numbers">// Both are equivalent
func add(x int, y int) int
func add(x, y int) int</code></pre>
        <br/>
        <li>Mixed parameter types:</li>
<pre><code class="language-go line-numbers">func describe(name string, age int, height float64) {
    fmt.Printf("%s is %d years old and %.2f meters tall\n", name, age, height)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Return Values</li>
    <br/>
    <ul>
        <li>Go functions can return multiple values:</li>
<pre><code class="language-go line-numbers">func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)  // Result: 5
}</code></pre>
        <br/>
        <li>Common pattern: returning a value and an error:</li>
<pre><code class="language-go line-numbers">func readFile(filename string) ([]byte, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    return data, nil
}</code></pre>
        <br/>
        <li>Multiple return values are specified in parentheses:</li>
<pre><code class="language-go line-numbers">func swap(x, y string) (string, string) {
    return y, x
}

a, b := swap("hello", "world")
fmt.Println(a, b)  // world hello</code></pre>
    </ul>
    <br/><br/>


    <li>Named Return Values (it somehow reminds me of Pascal)</li>
    <br/>
    <ul>
        <li>Return values can be named in the function signature:</li>
<pre><code class="language-go line-numbers">func calculate(x, y int) (sum int, product int) {
    sum = x + y
    product = x * y
    return  // Naked return
}

func main() {
    s, p := calculate(3, 4)
    fmt.Println(s, p)  // 7 12
}</code></pre>
        <br/>
        <li>Named return values are automatically initialized to their zero values.</li>
        <br/>
        <li>A <b>naked return</b> returns the named values without explicitly specifying them.</li>
        <br/>
        <li>Named returns improve documentation but can reduce clarity in complex functions:</li>
<pre><code class="language-go line-numbers">func divide(a, b float64) (result float64, err error) {
    if b == 0 {
        err = errors.New("division by zero")
        return  // result will be 0.0 (zero value)
    }
    result = a / b
    return
}</code></pre>
    </ul>
    <br/><br/>


    <li>Variadic Functions</li>
    <br/>
    <ul>
        <li>A <b>variadic function</b> accepts a variable number of arguments:</li>
<pre><code class="language-go line-numbers">func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3))        // 6
    fmt.Println(sum(10, 20, 30, 40)) // 100
    fmt.Println(sum())               // 0
}</code></pre>
        <br/>
        <li>The <code>...</code> before the type indicates a variadic parameter.</li>
        <br/>
        <li>Inside the function, the variadic parameter is treated as a slice.</li>
        <br/>
        <li>Variadic parameter must be the last parameter:</li>
<pre><code class="language-go line-numbers">func printf(format string, args ...interface{}) {
    fmt.Printf(format, args...)
}</code></pre>
        <br/>
        <li>Passing a slice to a variadic function:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
total := sum(numbers...)  // Spread operator</code></pre>
    </ul>
    <br/><br/>


    <li>Anonymous Functions</li>
    <br/>
    <ul>
        <li>Functions can be defined without a name (function literals):</li>
<pre><code class="language-go line-numbers">func main() {
    // Define and call immediately
    func() {
        fmt.Println("Anonymous function")
    }()

    // Assign to variable
    greet := func(name string) {
        fmt.Println("Hello,", name)
    }
    greet("Alice")
}</code></pre>
        <br/>
        <li>Anonymous functions with parameters and return values:</li>
<pre><code class="language-go line-numbers">add := func(x, y int) int {
    return x + y
}

result := add(5, 3)
fmt.Println(result)  // 8</code></pre>
    </ul>
    <br/><br/>


    <li>Functions as Values</li>
    <br/>
    <ul>
        <li>Functions are first-class values and can be:</li>
        <ul>
            <li>assigned to variables</li>
            <li>passed as arguments</li>
            <li>returned from functions</li>
        </ul>
        <br/>
        <li>Assigning functions to variables:</li>
<pre><code class="language-go line-numbers">func add(x, y int) int {
    return x + y
}

func main() {
    var operation func(int, int) int
    operation = add

    result := operation(3, 4)
    fmt.Println(result)  // 7
}</code></pre>
        <br/>
        <li>Passing functions as arguments:</li>
<pre><code class="language-go line-numbers">func apply(f func(int, int) int, x, y int) int {
    return f(x, y)
}

func multiply(x, y int) int {
    return x * y
}

func main() {
    result := apply(multiply, 5, 6)
    fmt.Println(result)  // 30
}</code></pre>
        <br/>
        <li>Returning functions from functions:</li>
<pre><code class="language-go line-numbers">func makeAdder(x int) func(int) int {
    return func(y int) int {
        return x + y
    }
}

func main() {
    add5 := makeAdder(5)
    fmt.Println(add5(3))  // 8
    fmt.Println(add5(10)) // 15
}</code></pre>
    </ul>
    <br/><br/>


    <li>Closures</li>
    <br/>
    <ul>
        <li>A <b>closure</b> is a function that references variables from outside its body:</li>
<pre><code class="language-go line-numbers">func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    next := counter()
    fmt.Println(next())  // 1
    fmt.Println(next())  // 2
    fmt.Println(next())  // 3
}</code></pre>
        <br/>
        <li>Each closure maintains its own state:</li>
<pre><code class="language-go line-numbers">counter1 := counter()
counter2 := counter()

fmt.Println(counter1())  // 1
fmt.Println(counter1())  // 2
fmt.Println(counter2())  // 1 (separate state)</code></pre>
        <br/>
        <li>Common use case: creating private state:</li>
<pre><code class="language-go line-numbers">func makeMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

double := makeMultiplier(2)
triple := makeMultiplier(3)

fmt.Println(double(5))  // 10
fmt.Println(triple(5))  // 15</code></pre>
    </ul>
    <br/><br/>


    <li>The Defer Statement</li>
    <br/>
    <ul>
        <li>The <code>defer</code> keyword postpones function execution until the surrounding function returns:</li>
<pre><code class="language-go line-numbers">func main() {
    defer fmt.Println("World")
    fmt.Println("Hello")
}
// Output:
// Hello
// World</code></pre>
        <br/>
        <li>Multiple defers execute in LIFO (Last In, First Out) order:</li>
<pre><code class="language-go line-numbers">func main() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
    fmt.Println("Main")
}
// Output:
// Main
// Third
// Second
// First</code></pre>
        <br/>
        <li>Common use cases:</li>
<table>
    <thead>
        <tr>
            <th>Use Case</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Closing files</td>
            <td><code>defer file.Close()</code></td>
        </tr>
        <tr>
            <td>Unlocking mutexes</td>
            <td><code>defer mutex.Unlock()</code></td>
        </tr>
        <tr>
            <td>Closing database connections</td>
            <td><code>defer db.Close()</code></td>
        </tr>
        <tr>
            <td>Cleanup operations</td>
            <td><code>defer cleanup()</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Practical example with file handling:</li>
<pre><code class="language-go line-numbers">func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // Ensures file is closed

    // Read file contents
    // Even if an error occurs, file.Close() will be called
    return nil
}</code></pre>
        <br/>
        <li>Deferred function arguments are evaluated immediately:</li>
<pre><code class="language-go line-numbers">func main() {
    x := 10
    defer fmt.Println(x)  // x is evaluated now (10)
    x = 20
    fmt.Println(x)
}
// Output:
// 20
// 10</code></pre>
    </ul>
    <br/><br/>


    <li>Recursive Functions</li>
    <br/>
    <ul>
        <li>A function can call itself (recursion):</li>
<pre><code class="language-go line-numbers">func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)
}

func main() {
    fmt.Println(factorial(5))  // 120
}</code></pre>
        <br/>
        <li>Fibonacci sequence using recursion:</li>
<pre><code class="language-go line-numbers">func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}

func main() {
    for i := 0; i < 10; i++ {
        fmt.Print(fibonacci(i), " ")
    }
    // Output: 0 1 1 2 3 5 8 13 21 34
}</code></pre>
        <br/>
        <li>Always include a base case to prevent infinite recursion.</li>
        <br/>
        <li>Recursive tree traversal:</li>
<pre><code class="language-go line-numbers">type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

func traverse(node *TreeNode) {
    if node == nil {
        return
    }
    fmt.Println(node.Value)
    traverse(node.Left)
    traverse(node.Right)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Methods</li>
    <br/>
    <ul>
        <li>Go doesn't have classes, but you can define methods on types:</li>
<pre><code class="language-go line-numbers">type Rectangle struct {
    Width  float64
    Height float64
}

// Method with value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    fmt.Println(rect.Area())  // 50
}</code></pre>
        <br/>
        <li>Methods can have pointer receivers to modify the receiver:</li>
<pre><code class="language-go line-numbers">// Method with pointer receiver
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    rect.Scale(2)
    fmt.Println(rect.Area())  // 200
}</code></pre>
        <br/>
        <li>Value receiver vs pointer receiver:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Receiver Type</th>
            <th>When to Use</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Value <code>(r Type)</code></td>
            <td>When method doesn't modify the receiver, small structs</td>
        </tr>
        <tr>
            <td>Pointer <code>(r *Type)</code></td>
            <td>When method modifies the receiver, large structs, or consistency</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Methods can be defined on any type in the same package:</li>
<pre><code class="language-go line-numbers">type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}

func main() {
    num := MyInt(5)
    fmt.Println(num.Double())  // 10
}</code></pre>
    </ul>
    <br/><br/>


    <li>Function Type Declarations</li>
    <br/>
    <ul>
        <li>You can create custom function types:</li>
<pre><code class="language-go line-numbers">type Operation func(int, int) int

func add(x, y int) int {
    return x + y
}

func multiply(x, y int) int {
    return x * y
}

func apply(op Operation, x, y int) int {
    return op(x, y)
}

func main() {
    fmt.Println(apply(add, 5, 3))      // 8
    fmt.Println(apply(multiply, 5, 3)) // 15
}</code></pre>
    </ul>
    <br/><br/>


    <li>Init Function</li>
    <br/>
    <ul>
        <li>The <code>init()</code> function runs automatically before <code>main()</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func init() {
    fmt.Println("Initialization")
}

func main() {
    fmt.Println("Main function")
}
// Output:
// Initialization
// Main function</code></pre>
        <br/>
        <li>Multiple <code>init()</code> functions can exist in the same package.</li>
        <br/>
        <li>They execute in the order they appear in the file.</li>
        <br/>
        <li>Common uses:</li>
        <ul>
            <li>initializing package-level variables</li>
            <li>registering drivers or plugins</li>
            <li>setting up configuration</li>
            <li>validating state</li>
        </ul>
        <br/>
        <li>Example with database driver:</li>
<pre><code class="language-go line-numbers">import (
    "database/sql"
    _ "github.com/lib/pq"  // init() registers PostgreSQL driver
)</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-packages">Packages in Go</h3>
<ol>

    <li>What Are Packages?</li>
    <br/>
    <ul>
        <li>A <code>package</code> is a collection of Go source files in the same directory that are compiled together.</li>
        <br/>
        <li>Every Go file must belong to a package:</li>
<pre><code class="language-go line-numbers">package main  // First line of every .go file</code></pre>
        <li>Go's standard library consists of many packages like <code>fmt</code>, <code>os</code>, <code>net/http</code>, etc.</li>
    </ul>
    <br/><br/>


    <li>Package Declaration</li>
    <br/>
    <ul>
        <li>Every Go file starts with a package declaration:</li>
<pre><code class="language-go line-numbers">package &lt;packagename&gt;</code></pre>
        <br/>
        <li>Package naming rules:</li>
        <ul>
            <li>must be lowercase</li>
            <li>should be short and concise</li>
            <li>no underscores or mixed caps</li>
            <li>by convention, matches the directory name</li>
        </ul>
        <br/>
        <li>Examples of good package names:</li>
<pre><code class="language-go line-numbers">package math
package strings
package http
package json</code></pre>
        <br/>
        <li>Examples of bad package names:</li>
<pre><code class="language-go line-numbers">package Math          // Uppercase
package string_utils  // Underscore
package myPackage     // Mixed caps</code></pre>
    </ul>
    <br/><br/>


    <li>The Main Package</li>
    <br/>
    <ul>
        <li>The <code>main</code> package is special -- it creates an executable program:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {
    fmt.Println("This is an executable")
}</code></pre>
        <br/>
        <li>Requirements for an executable:</li>
        <ul>
            <li>must be named <code>main</code></li>
            <li>must contain a <code>main()</code> function</li>
            <li>the <code>main()</code> function takes no arguments and returns nothing</li>
        </ul>
        <br/>
        <li>Non-main packages create reusable libraries, not executables.</li>
        <br/>
        <li>You can have multiple <code>main</code> packages in different directories of a project.</li>
    </ul>
    <br/><br/>


    <li>Creating a Custom Package</li>
    <br/>
    <ul>
        <li>Project structure example:</li>
<pre><code class="language-plaintext line-numbers">myproject/
â”œâ”€â”€ main.go
â”œâ”€â”€ go.mod
â””â”€â”€ calculator/
    â”œâ”€â”€ add.go
    â””â”€â”€ multiply.go</code></pre>
        <br/>
        <li>File: <code>calculator/add.go</code></li>
<pre><code class="language-go line-numbers">package calculator

func Add(x, y int) int {
    return x + y
}</code></pre>
        <br/>
        <li>File: <code>calculator/multiply.go</code></li>
<pre><code class="language-go line-numbers">package calculator

func Multiply(x, y int) int {
    return x * y
}</code></pre>
        <br/>
        <li>File: <code>main.go</code></li>
<pre><code class="language-go line-numbers">package main

import (
    "fmt"
    "myproject/calculator"
)

func main() {
    sum := calculator.Add(5, 3)
    product := calculator.Multiply(5, 3)

    fmt.Println("Sum:", sum)         // Sum: 8
    fmt.Println("Product:", product) // Product: 15
}</code></pre>
        <li>All files in the same directory MUST have the same package name.</li>
    </ul>
    <br/><br/>


    <li>Importing Packages</li>
    <br/>
    <ul>
        <li>Use the <code>import</code> keyword to include packages:</li>
<pre><code class="language-go line-numbers">import "fmt"</code></pre>
        <br/>
        <li>Multiple imports:</li>
<pre><code class="language-go line-numbers">import (
    "fmt"
    "os"
    "strings"
    "time"
)</code></pre>
        <br/>
        <li>Importing with alias:</li>
<pre><code class="language-go line-numbers">import (
    f "fmt"              // Alias as 'f'
    "math/rand"
)

func main() {
    f.Println("Hello")   // Using alias
}</code></pre>
        <br/>
        <li>Import for side effects only (runs <code>init()</code> functions):</li>
<pre><code class="language-go line-numbers">import _ "github.com/lib/pq"  // Register PostgreSQL driver</code></pre>
        <br/>
        <li>Dot import (imports into current namespace - not recommended):</li>
<pre><code class="language-go line-numbers">import . "fmt"

func main() {
    Println("No prefix needed")  // Not recommended
}</code></pre>
    </ul>
    <br/><br/>


    <li>Package Visibility Rules</li>
    <br/>
    <ul>
        <li>Go uses capitalization to control visibility:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Case</th>
            <th>Visibility</th>
            <th>Accessible From</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Uppercase (exported)</td>
            <td>Public</td>
            <td>Any package</td>
        </tr>
        <tr>
            <td>Lowercase (unexported)</td>
            <td>Private</td>
            <td>Same package only</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">package calculator

// Exported (public) - can be used by other packages
func Add(x, y int) int {
    return x + y
}

// Unexported (private) - only accessible within calculator package
func validate(x int) bool {
    return x &gt;= 0
}</code></pre>
        <li>Example with struct:</li>
<pre><code class="language-go line-numbers">package user

type User struct {
    Name    string  // Exported field
    Email   string  // Exported field
    age     int     // Unexported field (private)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Package Organization</li>
    <br/>
    <ul>
        <li>Common project structure:</li>
<pre><code class="language-bash line-numbers">myproject/
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ main.go
â”œâ”€â”€ README.md
â”œâ”€â”€ cmd/               # Command-line applications
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ pkg/               # Reusable packages
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ db.go
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ user.go
â”œâ”€â”€ internal/          # Private packages (Go convention)
â”‚   â””â”€â”€ config/
â”‚       â””â”€â”€ config.go
â””â”€â”€ test/              # Test files
    â””â”€â”€ integration/</code></pre>
        <br/>
        <li>Directory purposes:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Directory</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>cmd/</code></td>
            <td>Contains main applications (each subdirectory is a separate executable)</td>
        </tr>
        <tr>
            <td><code>pkg/</code></td>
            <td>Contains reusable library code</td>
        </tr>
        <tr>
            <td><code>internal/</code></td>
            <td>Private application code (cannot be imported by other projects)</td>
        </tr>
        <tr>
            <td><code>api/</code></td>
            <td>API definitions (OpenAPI, Protocol Buffers)</td>
        </tr>
        <tr>
            <td><code>web/</code></td>
            <td>Web application assets</td>
        </tr>
        <tr>
            <td><code>scripts/</code></td>
            <td>Build and deployment scripts</td>
        </tr>
        <tr>
            <td><code>test/</code></td>
            <td>Additional test files</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>The Internal Package</li>
    <br/>
    <ul>
        <li>The <code>internal/</code> directory has special meaning in Go:</li>
<pre><code class="language-plaintext line-numbers">myproject/
â””â”€â”€ internal/
    â””â”€â”€ auth/
        â””â”€â”€ auth.go</code></pre>
        <br/>
        <li>Packages in <code>internal/</code> can only be imported by code in the parent tree.</li>
        <br/>
        <li>Example structure:</li>
<pre><code class="language-plaintext line-numbers">github.com/user/myproject/
â”œâ”€â”€ internal/
â”‚   â””â”€â”€ helper/         # Only importable by myproject
â”‚       â””â”€â”€ helper.go
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ public/         # Can be imported by anyone
â”‚       â””â”€â”€ public.go
â””â”€â”€ cmd/
    â””â”€â”€ app/
        â””â”€â”€ main.go     # Can import internal/helper</code></pre>
        <br/>
        <li>Import path restrictions:</li>
<pre><code class="language-go line-numbers">// âœ“ OK - same project
import "github.com/user/myproject/internal/helper"

// âœ— ERROR - external project cannot import internal
import "github.com/other/theirproject/internal/something"</code></pre>
        <li>Use <code>internal/</code> to prevent external projects from depending on unstable APIs.</li>
    </ul>
    <br/><br/>


    <li>Go Modules</li>
    <br/>
    <ul>
        <li>Go modules are the standard dependency management system (since Go 1.11).</li>
        <br/>
        <li>Initialize a module:</li>
<pre><code class="language-bash line-numbers">go mod init github.com/username/projectname</code></pre>
        <br/>
        <li>This creates a <code>go.mod</code> file:</li>
<pre><code class="language-plaintext line-numbers">module github.com/username/projectname

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/lib/pq v1.10.9
)</code></pre>
        <br/>
        <li>Common module commands:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>go mod init</code></td>
            <td>Initialize a new module</td>
        </tr>
        <tr>
            <td><code>go mod tidy</code></td>
            <td>Add missing and remove unused dependencies</td>
        </tr>
        <tr>
            <td><code>go mod download</code></td>
            <td>Download dependencies to local cache</td>
        </tr>
        <tr>
            <td><code>go mod verify</code></td>
            <td>Verify dependencies have expected content</td>
        </tr>
        <tr>
            <td><code>go mod vendor</code></td>
            <td>Copy dependencies to vendor directory</td>
        </tr>
        <tr>
            <td><code>go get</code></td>
            <td>Add or update dependencies</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The <code>go.sum</code> file stores checksums for dependency verification.</li>
    </ul>
    <br/><br/>


    <li>Installing Third-Party Packages</li>
    <br/>
    <ul>
        <li>Add a dependency using <code>go get</code>:</li>
<pre><code class="language-bash line-numbers">go get github.com/gin-gonic/gin</code></pre>
        <br/>
        <li>Install specific version:</li>
<pre><code class="language-bash line-numbers">go get github.com/gin-gonic/gin@v1.9.1</code></pre>
        <br/>
        <li>Import and use in code:</li>
<pre><code class="language-go line-numbers">package main

import (
    "github.com/gin-gonic/gin"
)

func main() {
    router := gin.Default()
    router.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "Hello"})
    })
    router.Run(":8080")
}</code></pre>
        <br/>
        <li>Go automatically downloads dependencies when you build:</li>
<pre><code class="language-bash line-numbers">go build</code></pre>
        <br/>
        <li>Update all dependencies:</li>
<pre><code class="language-bash line-numbers">go get -u ./...</code></pre>
        <br/>
        <li>Remove unused dependencies:</li>
<pre><code class="language-bash line-numbers">go mod tidy</code></pre>
    </ul>
    <br/><br/>


    <li>Standard Library Packages</li>
    <br/>
    <ul>
        <li>Go's standard library provides many useful packages:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fmt</code></td>
            <td>Formatted I/O operations</td>
        </tr>
        <tr>
            <td><code>os</code></td>
            <td>Operating system functionality</td>
        </tr>
        <tr>
            <td><code>io</code></td>
            <td>Basic I/O primitives</td>
        </tr>
        <tr>
            <td><code>net/http</code></td>
            <td>HTTP client and server</td>
        </tr>
        <tr>
            <td><code>encoding/json</code></td>
            <td>JSON encoding and decoding</td>
        </tr>
        <tr>
            <td><code>database/sql</code></td>
            <td>Generic SQL database interface</td>
        </tr>
        <tr>
            <td><code>time</code></td>
            <td>Time and duration operations</td>
        </tr>
        <tr>
            <td><code>strings</code></td>
            <td>String manipulation</td>
        </tr>
        <tr>
            <td><code>strconv</code></td>
            <td>String conversions</td>
        </tr>
        <tr>
            <td><code>math</code></td>
            <td>Mathematical functions</td>
        </tr>
        <tr>
            <td><code>regexp</code></td>
            <td>Regular expressions</td>
        </tr>
        <tr>
            <td><code>context</code></td>
            <td>Request scoping and cancellation</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example using multiple standard packages:</li>
<pre><code class="language-go line-numbers">package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type Response struct {
    Message   string    `json:"message"`
    Timestamp time.Time `json:"timestamp"`
}

func handler(w http.ResponseWriter, r *http.Request) {
    response := Response{
        Message:   "Hello, World!",
        Timestamp: time.Now(),
    }

    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/", handler)
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Package Documentation</li>
    <br/>
    <ul>
        <li>Document packages with comments before the package declaration:</li>
<pre><code class="language-go line-numbers">// Package calculator provides basic arithmetic operations.
// It supports addition, subtraction, multiplication, and division.
package calculator</code></pre>
        <br/>
        <li>Document exported functions:</li>
<pre><code class="language-go line-numbers">// Add returns the sum of x and y.
func Add(x, y int) int {
    return x + y
}

// Divide returns the quotient of x divided by y.
// It returns an error if y is zero.
func Divide(x, y float64) (float64, error) {
    if y == 0 {
        return 0, errors.New("division by zero")
    }
    return x / y, nil
}</code></pre>
        <br/>
        <li>View documentation locally:</li>
<pre><code class="language-bash line-numbers">go doc calculator
go doc calculator.Add</code></pre>
        <br/>
        <li>Generate HTML documentation:</li>
<pre><code class="language-bash line-numbers">godoc -http=:6060</code></pre>
        <br/>
        <li>Documentation is automatically published on <code>pkg.go.dev</code> for public packages.</li>
    </ul>
    <br/><br/>


    <li>Package Initialization</li>
    <br/>
    <ul>
        <li>Packages are initialized in the following order:</li>
        <ol>
            <li>Import dependencies</li>
            <li>Initialize package-level variables</li>
            <li>Run <code>init()</code> functions</li>
        </ol>
        <br/>
        <li>Example with <code>init()</code>:</li>
<pre><code class="language-go line-numbers">package database

import "database/sql"

var db *sql.DB

func init() {
    var err error
    db, err = sql.Open("postgres", "connection_string")
    if err != nil {
        panic(err)
    }
}

func GetDB() *sql.DB {
    return db
}</code></pre>
        <br/>
        <li>Multiple <code>init()</code> functions are executed in declaration order.</li>
        <br/>
        <li>Each imported package's <code>init()</code> runs before the importing package.</li>
    </ul>
    <br/><br/>


    <li>Vendor Directory</li>
    <br/>
    <ul>
        <li>The <code>vendor/</code> directory stores a copy of dependencies:</li>
<pre><code class="language-bash line-numbers">go mod vendor</code></pre>
        <br/>
        <li>Creates structure:</li>
<pre><code class="language-plaintext line-numbers">myproject/
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ main.go
â””â”€â”€ vendor/
    â”œâ”€â”€ github.com/
    â”‚   â””â”€â”€ gin-gonic/
    â”‚       â””â”€â”€ gin/
    â””â”€â”€ modules.txt</code></pre>
        <br/>
        <li>Benefits of vendoring:</li>
        <ul>
            <li>guaranteed reproducible builds</li>
            <li>works without internet access</li>
            <li>complete control over dependencies</li>
        </ul>
        <br/>
        <li>Build using vendor directory:</li>
<pre><code class="language-bash line-numbers">go build -mod=vendor</code></pre>
        <br/>
        <li>Most projects don't need vendoring anymore due to Go's module cache.</li>
    </ul>
    <br/><br/>


    <li>Package Aliases and Naming Conflicts</li>
    <br/>
    <ul>
        <li>Resolve naming conflicts with aliases:</li>
<pre><code class="language-go line-numbers">import (
    "crypto/rand"
    mrand "math/rand"  // Alias to avoid conflict
)

func main() {
    // Use crypto/rand
    bytes := make([]byte, 32)
    rand.Read(bytes)

    // Use math/rand with alias
    num := mrand.Intn(100)
}</code></pre>
        <br/>
        <li>Another example:</li>
<pre><code class="language-go line-numbers">import (
    "database/sql"
    "github.com/jmoiron/sqlx"

    stdSQL "database/sql"  // If needed
)</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-module-naming">Understanding Go Module Names and Project Naming</h3>
<ol>

    <li>What is a Module Path?</li>
    <br/>
    <ul>
        <li>In Go, every project has a <b>module path</b> - a unique identifier for your project.</li>
        <br/>
        <li>The module path looks like a URL: <code>example.com/user/project</code></li>
        <br/>
        <li>This appears in your <code>go.mod</code> file:</li>
<pre><code class="language-go line-numbers">module github.com/alice/myproject

go 1.21</code></pre>
        <br/>
        <li>The module path does <u>not</u> have to be a real website - it's just a naming convention!</li>
        <br/>
        <li>However, if you plan to share your code, using a real repository URL makes it importable by others.</li>
    </ul>
    <br/><br/>


    <li>The Structure of Module Paths</li>
    <br/>
    <ul>
        <li>A typical module path has three parts:</li>
<pre><code class="language-plaintext line-numbers">domain.com  /  username  /  project-name
    â†“              â†“              â†“
  hosting      namespace      project</code></pre>
        <br/>
        <li><b>Examples from real projects:</b></li>
<pre><code class="language-go line-numbers">// GitHub projects
github.com/gorilla/mux           // Gorilla web toolkit's router
github.com/spf13/cobra           // CLI framework
github.com/docker/docker         // Docker engine

// Official Go projects
golang.org/x/tools               // Go tools
golang.org/x/crypto              // Cryptography packages

// Company projects
go.uber.org/zap                  // Uber's logging library
cloud.google.com/go/storage      // Google Cloud Storage client
github.com/aws/aws-sdk-go        // AWS SDK</code></pre>
        <br/>
        <li>The path can be deeper with subpackages:</li>
<pre><code class="language-go line-numbers">github.com/myuser/myproject              // Root module
github.com/myuser/myproject/api          // Subpackage
github.com/myuser/myproject/api/v2       // Version-specific subpackage
github.com/myuser/myproject/internal     // Internal package (not importable outside)</code></pre>
    </ul>
    <br/><br/>


    <li>Naming for Different Scenarios</li>
    <br/>
    <ul>
        <li><b>Scenario 1: Public project on GitHub</b></li>
        <br/>
        <ul>
            <li>Use your GitHub repository URL:</li>
<pre><code class="language-bash line-numbers">$ mkdir myproject
$ cd myproject
$ go mod init github.com/yourusername/myproject</code></pre>
            <li>This allows others to import your code:</li>
<pre><code class="language-bash line-numbers">$ go get github.com/yourusername/myproject</code></pre>
        </ul>
        <br/>
        <br/>
        <li><b>Scenario 2: Private/local project (not shared)</b></li>
        <br/>
        <ul>
            <li>Use any domain-like name you want:</li>
<pre><code class="language-bash line-numbers">$ go mod init mycompany.local/myproject
$ go mod init example.com/learning/hello
$ go mod init local/myapp</code></pre>
            <li>These won't work with <code>go get</code>, but that's fine for personal projects!</li>
        </ul>
        <br/>
        <br/>
        <li><b>Scenario 3: Company internal project</b></li>
        <br/>
        <ul>
            <li>Use your company's domain:</li>
<pre><code class="language-bash line-numbers">$ go mod init acme.com/internal/billing
$ go mod init mycompany.io/services/auth</code></pre>
            <li>Can configure private repositories:</li>
<pre><code class="language-bash line-numbers"># Tell Go this is a private module
$ export GOPRIVATE=acme.com/*
$ go get acme.com/internal/shared</code></pre>
        </ul>
        <br/>
        <br/>
        <li><b>Scenario 4: Learning/experimentation</b></li>
        <br/>
        <ul>
            <li>Use simple names for quick projects:</li>
<pre><code class="language-bash line-numbers">$ go mod init hello
$ go mod init calculator
$ go mod init example.com/tutorial</code></pre>
            <li>Perfect for following tutorials or testing ideas!</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Common Domain Patterns</li>
    <br/>
    <ul>
        <li><b>GitHub (most common):</b></li>
<pre><code class="language-plaintext line-numbers">github.com/username/project-name

Examples:
github.com/alice/todo-api
github.com/bob/image-processor
github.com/teamname/backend-services</code></pre>
        <br/>
        <li><b>GitLab:</b></li>
<pre><code class="language-plaintext line-numbers">gitlab.com/username/project-name

Examples:
gitlab.com/devteam/microservices
gitlab.com/alice/web-scraper</code></pre>
        <br/>
        <li><b>Bitbucket:</b></li>
<pre><code class="language-plaintext line-numbers">bitbucket.org/username/project-name</code></pre>
        <br/>
        <li><b>Custom domains:</b></li>
<pre><code class="language-plaintext line-numbers">yourname.dev/project
code.yourcompany.com/team/project
pkg.mysite.io/library</code></pre>
        <br/>
        <li><b>Official Go packages:</b></li>
<pre><code class="language-plaintext line-numbers">golang.org/x/...         # Extended Go libraries
go.googlesource.com/...  # Google's Go repositories</code></pre>
    </ul>
    <br/><br/>


    <li>Creating Your First Module</li>
<pre><code class="language-bash line-numbers"># 1. Create project directory
$ mkdir hello-world
$ cd hello-world

# 2. Initialize Go module with a name
$ go mod init github.com/yourusername/hello-world

# This creates go.mod file:
# module github.com/yourusername/hello-world
#
# go 1.21

# 3. Create your Go file
$ cat &gt; main.go &lt;&lt; 'EOF'
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
EOF

# 4. Run it
$ go run main.go
Hello, World!

# 5. Build executable
$ go build
$ ./hello-world
Hello, World!
</code></pre>
    <br/><br/>


    <li>The go.mod File Explained</li>
    <br/>
    <ul>
        <li>After <code>go mod init</code>, you get a <code>go.mod</code> file:</li>
<pre><code class="language-go line-numbers">module github.com/alice/myproject

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    golang.org/x/crypto v0.14.0
)

replace github.com/old/package =&gt; github.com/new/package v1.2.3
</code></pre>
        <br/>
        <li><b>Key sections:</b></li>
        <ul>
            <br/>
            <li><code>module</code>: Your project's module path (the name you chose)</li>
            <br/>
            <li><code>go</code>: Minimum Go version required</li>
            <br/>
            <li><code>require</code>: Dependencies your project needs</li>
            <br/>
            <li><code>replace</code>: Override dependency locations (optional)</li>
        </ul>
        <br/>
        <li>Dependencies are added automatically when you import and build:</li>
<pre><code class="language-bash line-numbers"># Import a package in your code
import "github.com/gin-gonic/gin"

# Build or run - Go automatically adds to go.mod
$ go build
go: downloading github.com/gin-gonic/gin v1.9.1
go: downloading github.com/gin-contrib/sse v0.1.0
...</code></pre>
    </ul>
    <br/><br/>


    <li>Importing Your Own Packages</li>
    <br/>
    <ul>
        <li>Once you have a module name, you can create subpackages:</li>
<pre><code class="language-plaintext line-numbers">myproject/
  go.mod                    # module github.com/alice/myproject
  main.go
  utils/
    helpers.go
  api/
    handlers.go
    routes.go</code></pre>
        <br/>
        <li><b>In helpers.go:</b></li>
<pre><code class="language-go line-numbers">package utils

func FormatName(first, last string) string {
    return first + " " + last
}</code></pre>
        <br/>
        <li><b>In main.go:</b></li>
<pre><code class="language-go line-numbers">package main

import (
    "fmt"
    "github.com/alice/myproject/utils"  // Import your own package
    "github.com/alice/myproject/api"
)

func main() {
    name := utils.FormatName("Alice", "Smith")
    fmt.Println(name)
}</code></pre>
        <br/>
        <li><b>Key rule:</b> Import paths = module path + subdirectory path</li>
<pre><code class="language-plaintext line-numbers">Module path:  github.com/alice/myproject
Subdirectory: utils/
Import path:  github.com/alice/myproject/utils</code></pre>
    </ul>
    <br/><br/>


    <li>Versioning in Module Names</li>
    <br/>
    <ul>
        <li>For version 2 and above, include version in module path:</li>
<pre><code class="language-go line-numbers">// Version 1.x
module github.com/alice/myproject

// Version 2.x and above
module github.com/alice/myproject/v2

// Version 3.x
module github.com/alice/myproject/v3</code></pre>
        <br/>
        <li>This allows multiple major versions to coexist:</li>
<pre><code class="language-go line-numbers">import (
    v1 "github.com/alice/myproject"
    v2 "github.com/alice/myproject/v2"
)

func main() {
    // Use both versions in same program
    v1.DoSomething()
    v2.DoSomething()
}</code></pre>
        <br/>
        <li><b>Directory structure for versioned modules:</b></li>
<pre><code class="language-plaintext line-numbers">myproject/
  go.mod              # module github.com/alice/myproject (v1)
  main.go
  v2/
    go.mod            # module github.com/alice/myproject/v2
    main.go
  v3/
    go.mod            # module github.com/alice/myproject/v3
    main.go</code></pre>
    </ul>
    <br/><br/>


    <li>Working with Local Modules (Development)</li>
    <br/>
    <ul>
        <li>When developing multiple modules locally, use <code>replace</code> directive:</li>
<pre><code class="language-plaintext line-numbers">Projects/
  myapp/
    go.mod          # module github.com/alice/myapp
    main.go
  mylib/
    go.mod          # module github.com/alice/mylib
    lib.go</code></pre>
        <br/>
        <li><b>In myapp/go.mod:</b></li>
<pre><code class="language-go line-numbers">module github.com/alice/myapp

go 1.21

require github.com/alice/mylib v0.0.0

// Point to local directory during development
replace github.com/alice/mylib => ../mylib</code></pre>
        <br/>
        <li><b>In myapp/main.go:</b></li>
<pre><code class="language-go line-numbers">package main

import "github.com/alice/mylib"

func main() {
    mylib.DoSomething()
}</code></pre>
        <br/>
        <li>The <code>replace</code> directive lets you test local changes before publishing!</li>
    </ul>
    <br/><br/>


    <li>Best Practices</li>
    <br/>
    <ul>
        <li><b>Use lowercase:</b> Module paths should be lowercase</li>
<pre><code class="language-bash line-numbers"># Good
$ go mod init github.com/alice/my-project

# Avoid (even if GitHub allows it)
$ go mod init github.com/Alice/My-Project</code></pre>
        <br/>
        <li><b>Use hyphens, not underscores:</b></li>
<pre><code class="language-bash line-numbers"># Preferred
github.com/alice/todo-list

# Less common
github.com/alice/todo_list</code></pre>
        <br/>
        <li><b>Match your repository name exactly:</b></li>
<pre><code class="language-bash line-numbers"># If GitHub repo is "my-awesome-project"
$ go mod init github.com/alice/my-awesome-project

# Not
$ go mod init github.com/alice/myawesomeproject</code></pre>
        <br/>
        <li><b>Keep names descriptive but concise:</b></li>
<pre><code class="language-bash line-numbers"># Good
github.com/alice/http-router
github.com/alice/json-validator

# Too generic
github.com/alice/utils
github.com/alice/tools</code></pre>
        <br/>
        <li><b>For organization projects, use organization name:</b></li>
<pre><code class="language-bash line-numbers">github.com/myorg/project
github.com/google/go-cloud
github.com/kubernetes/kubernetes</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-control-flow">Control Flow in Go</h3>
<ol>

    <li>Go provides several control flow structures:</li>
    <ul>
        <br/>
        <li><code>if</code> statements for conditional execution</li>
        <br/>
        <li><code>switch</code> statements for multi-way branching</li>
        <br/>
        <li><code>for</code> loops for iteration (the only loop in Go)</li>
        <br/>
        <li><code>break</code> and <code>continue</code> for loop control</li>
        <br/>
        <li><code>goto</code> for unconditional jumps (rarely used)</li>
        <br/>
        <li><code>defer</code> for deferred execution</li>
    </ul>
    <br/><br/>


    <li>If Statements</li>
    <br/>
    <ul>
        <li>Basic <code>if</code> statement:</li>
<pre><code class="language-go line-numbers">if condition {
    // code to execute if condition is true
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">age := 18

if age >= 18 {
    fmt.Println("You are an adult")
}</code></pre>
        <br/>
        <li>Important notes:</li>
        <ul>
            <li>parentheses around the condition are optional (and discouraged)</li>
            <li>curly braces are required, even for single-line blocks</li>
            <li>opening brace must be on the same line as <code>if</code></li>
        </ul>
        <br/>
        <li>Invalid syntax:</li>
<pre><code class="language-go line-numbers">// âœ— ERROR - missing braces
if age >= 18
    fmt.Println("Adult")

// âœ— ERROR - brace on wrong line
if age >= 18
{
    fmt.Println("Adult")
}</code></pre>
    </ul>
    <br/><br/>


    <li>If-Else Statements</li>
    <br/>
    <ul>
        <li>Execute different code blocks based on condition:</li>
<pre><code class="language-go line-numbers">if condition {
    // code if true
} else {
    // code if false
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">temperature := 25

if temperature > 30 {
    fmt.Println("It's hot")
} else {
    fmt.Println("It's not too hot")
}</code></pre>
        <br/>
        <li>If-else-if chain:</li>
<pre><code class="language-go line-numbers">score := 85

if score >= 90 {
    fmt.Println("Grade: A")
} else if score >= 80 {
    fmt.Println("Grade: B")
} else if score >= 70 {
    fmt.Println("Grade: C")
} else if score >= 60 {
    fmt.Println("Grade: D")
} else {
    fmt.Println("Grade: F")
}</code></pre>
        <br/>
        <li>The <code>else</code> keyword must be on the same line as the closing brace of the previous block.</li>
    </ul>
    <br/><br/>


    <li>If With Initialization Statement</li>
    <br/>
    <ul>
        <li>Go allows a short statement before the condition:</li>
<pre><code class="language-go line-numbers">if statement; condition {
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">if age := getAge(); age >= 18 {
    fmt.Println("Adult, age:", age)
} else {
    fmt.Println("Minor, age:", age)
}
// age is not accessible here</code></pre>
        <br/>
        <li>The variable declared in the initialization is scoped to the <code>if</code> block.</li>
        <br/>
        <li>Common pattern with error checking:</li>
<pre><code class="language-go line-numbers">if err := doSomething(); err != nil {
    fmt.Println("Error:", err)
    return
}
// err is not accessible here</code></pre>
        <br/>
        <li>Another example:</li>
<pre><code class="language-go line-numbers">if value, ok := myMap[key]; ok {
    fmt.Println("Found:", value)
} else {
    fmt.Println("Key not found")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Switch Statements</li>
    <br/>
    <ul>
        <li>Switch provides multi-way branching based on value:</li>
<pre><code class="language-go line-numbers">switch variable {
    case value1:
        // code
    case value2:
        // code
    default:
        // code if no case matches
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">day := "Monday"

switch day {
    case "Monday":
        fmt.Println("Start of the work week")
    case "Friday":
        fmt.Println("End of the work week")
    case "Saturday", "Sunday":
        fmt.Println("Weekend!")
    default:
        fmt.Println("Midweek")
}</code></pre>
        <br/>
        <li>Key differences from other languages:</li>
        <ul>
            <li>no automatic fall-through (no <code>break</code> needed)</li>
            <li>cases don't need to be constants</li>
            <li>multiple values in one case (comma-separated)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Switch Without Expression</li>
    <br/>
    <ul>
        <li>Switch can work like an if-else chain:</li>
<pre><code class="language-go line-numbers">switch {
    case condition1:
        // code
    case condition2:
        // code
    default:
        // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">hour := 14

switch {
    case hour < 12:
        fmt.Println("Good morning")
    case hour < 18:
        fmt.Println("Good afternoon")
    default:
        fmt.Println("Good evening")
}</code></pre>
        <br/>
        <li>Often cleaner than long if-else chains.</li>
    </ul>
    <br/><br/>


    <li>Switch With Initialization</li>
    <br/>
    <ul>
        <li>Like <code>if</code>, switch can have an initialization statement:</li>
<pre><code class="language-go line-numbers">switch statement; expression {
case value1:
    // code
case value2:
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">switch num := getRandom(); num {
case 1, 2, 3:
    fmt.Println("Low number:", num)
case 4, 5, 6:
    fmt.Println("Medium number:", num)
default:
    fmt.Println("High number:", num)
}</code></pre>
        <br/>
        <li>The variable is scoped to the switch block.</li>
    </ul>
    <br/><br/>


    <li>Type Switch</li>
    <br/>
    <ul>
        <li>Switch can determine the type of an interface value:</li>
<pre><code class="language-go line-numbers">switch v := value.(type) {
case Type1:
    // v is of Type1
case Type2:
    // v is of Type2
default:
    // v is of unknown type
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

func main() {
    describe(42)      // Integer: 42
    describe("hello") // String: hello
    describe(true)    // Boolean: true
    describe(3.14)    // Unknown type: float64
}</code></pre>
        <br/>
        <li>The <code>type</code> keyword is special and only works in type switches.</li>
    </ul>
    <br/><br/>


    <li>Fallthrough in Switch</li>
    <br/>
    <ul>
        <li>Use <code>fallthrough</code> to explicitly continue to the next case:</li>
<pre><code class="language-go line-numbers">switch num := 2; num {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
    fallthrough
case 3:
    fmt.Println("Three")
default:
    fmt.Println("Other")
}
// Output:
// Two
// Three</code></pre>
        <br/>
        <li><code>fallthrough</code> must be the last statement in a case.</li>
        <br/>
        <li>It transfers control to the next case unconditionally (doesn't check the condition).</li>
    </ul>
    <br/><br/>


    <li>For Loop - Basic Form</li>
    <br/>
    <ul>
        <li>The <code>for</code> loop is Go's only looping construct:</li>
<pre><code class="language-go line-numbers">for initialization; condition; post {
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">for i := 0; i < 5; i++ {
    fmt.Println(i)
}
// Output: 0 1 2 3 4</code></pre>
        <br/>
        <li>Components:</li>
<table>
    <thead>
        <tr>
            <th>Component</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>initialization</code></td>
            <td>Executed once before the loop starts</td>
        </tr>
        <tr>
            <td><code>condition</code></td>
            <td>Evaluated before each iteration</td>
        </tr>
        <tr>
            <td><code>post</code></td>
            <td>Executed after each iteration</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>All three components are optional:</li>
<pre><code class="language-go line-numbers">i := 0
for ; i < 5; i++ {
    fmt.Println(i)
}</code></pre>
    </ul>
    <br/><br/>


    <li>For Loop - While Style</li>
    <br/>
    <ul>
        <li>Omit initialization and post to create a while-style loop:</li>
<pre><code class="language-go line-numbers">for condition {
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">count := 0
for count < 5 {
    fmt.Println(count)
    count++
}</code></pre>
        <br/>
        <li>This is Go's equivalent of <code>while</code> in other languages.</li>
    </ul>
    <br/><br/>


    <li>Infinite Loop</li>
    <br/>
    <ul>
        <li>Omit all components for an infinite loop:</li>
<pre><code class="language-go line-numbers">for {
    // code runs forever
}</code></pre>
        <br/>
        <li>Example with break condition:</li>
<pre><code class="language-go line-numbers">count := 0
for {
    fmt.Println(count)
    count++
    if count >= 5 {
        break
    }
}
// Output: 0 1 2 3 4</code></pre>
        <br/>
        <li>Common in server applications:</li>
<pre><code class="language-go line-numbers">for {
    conn, err := listener.Accept()
    if err != nil {
        continue
    }
    go handleConnection(conn)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Range-Based For Loop</li>
    <br/>
    <ul>
        <li>Use <code>range</code> to iterate over slices, arrays, maps, strings, and channels:</li>
<pre><code class="language-go line-numbers">for index, value := range collection {
    // code
}</code></pre>
        <br/>
        <li>Iterating over a slice:</li>
<pre><code class="language-go line-numbers">numbers := []int{10, 20, 30, 40, 50}

for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}</code></pre>
        <br/>
        <li>Iterating over a map:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 25,
    "Bob":   30,
    "Charlie": 35,
}

for name, age := range ages {
    fmt.Printf("%s is %d years old\n", name, age)
}</code></pre>
        <br/>
        <li>Iterating over a string (returns runes):</li>
<pre><code class="language-go line-numbers">for index, char := range "Hello" {
    fmt.Printf("%d: %c\n", index, char)
}</code></pre>
        <br/>
        <li>Ignoring index or value with <code>_</code>:</li>
<pre><code class="language-go line-numbers">// Only value
for _, value := range numbers {
    fmt.Println(value)
}

// Only index
for index := range numbers {
    fmt.Println(index)
}

// Just iterate (no variables)
for range numbers {
    fmt.Println("Iterating...")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Break Statement</li>
    <br/>
    <ul>
        <li>The <code>break</code> statement exits the innermost loop:</li>
<pre><code class="language-go line-numbers">for i := 0; i < 10; i++ {
    if i == 5 {
        break  // Exit loop when i is 5
    }
    fmt.Println(i)
}
// Output: 0 1 2 3 4</code></pre>
        <br/>
        <li>Break with nested loops (exits only the inner loop):</li>
<pre><code class="language-go line-numbers">for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if j == 1 {
            break  // Only breaks inner loop
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}</code></pre>
        <br/>
        <li>Break in switch statements:</li>
<pre><code class="language-go line-numbers">switch value {
case 1:
    fmt.Println("One")
    break  // Optional - cases don't fall through by default
case 2:
    fmt.Println("Two")
}</code></pre>
        <br/>
        <li>Note: <code>break</code> is implicit in switch cases unless <code>fallthrough</code> is used.</li>
    </ul>
    <br/><br/>


    <li>Continue Statement</li>
    <br/>
    <ul>
        <li>The <code>continue</code> statement skips the rest of the current iteration:</li>
<pre><code class="language-go line-numbers">for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // Skip even numbers
    }
    fmt.Println(i)
}
// Output: 1 3 5 7 9</code></pre>
        <br/>
        <li>Example with validation:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, -3, 4, -5, 6}

for _, num := range numbers {
    if num < 0 {
        continue  // Skip negative numbers
    }
    fmt.Println(num)
}
// Output: 1 2 4 6</code></pre>
        <br/>
        <li>Continue in nested loops (continues the innermost loop):</li>
<pre><code class="language-go line-numbers">for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if j == 1 {
            continue  // Skip to next j
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}</code></pre>
    </ul>
    <br/><br/>


    <li>Labels With Break and Continue</li>
    <br/>
    <ul>
        <li>Use labels to break or continue outer loops:</li>
<pre><code class="language-go line-numbers">OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break OuterLoop  // Break outer loop
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
// Output:
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0</code></pre>
        <br/>
        <li>Continue with labels:</li>
<pre><code class="language-go line-numbers">OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if j == 1 {
            continue OuterLoop  // Continue outer loop
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}</code></pre>
        <br/>
        <li>Labels must be <u>immediately</u> before a <code>for</code> statement.</li>
    </ul>
    <br/><br/>


    <li>Goto Statement</li>
    <br/>
    <ul>
        <li>The <code>goto</code> statement jumps to a labeled statement:</li>
<pre><code class="language-go line-numbers">func main() {
    i := 0

Loop:
    fmt.Println(i)
    i++

    if i < 5 {
        goto Loop
    }

    fmt.Println("Done")
}</code></pre>
        <br/>
        <li>Restrictions:</li>
        <ul>
            <li>cannot jump into a block from outside</li>
            <li>cannot jump over variable declarations</li>
            <li>label must be in the same function</li>
        </ul>
        <br/>
        <li>Valid use case - error handling cleanup:</li>
<pre><code class="language-go line-numbers">func process() error {
    if err := step1(); err != nil {
        goto cleanup
    }
    if err := step2(); err != nil {
        goto cleanup
    }
    if err := step3(); err != nil {
        goto cleanup
    }
    return nil

cleanup:
    // Cleanup code
    return err
}</code></pre>
        <br/>
        <li><code>goto</code> is rarely used in Go - prefer structured control flow.</li>
    </ul>
    <br/><br/>


    <li>Defer in Control Flow</li>
    <br/>
    <ul>
        <li>The <code>defer</code> statement schedules a function to run when the surrounding function returns:</li>
<pre><code class="language-go line-numbers">func readFile(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        return
    }
    defer file.Close()  // Always executes before function returns

    // Read file...
}</code></pre>
        <br/>
        <li>Multiple defers execute in LIFO order:</li>
<pre><code class="language-go line-numbers">func example() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
    fmt.Println("Main")
}
// Output:
// Main
// Third
// Second
// First</code></pre>
        <br/>
        <li>Defer with loops:</li>
<pre><code class="language-go line-numbers">func processFiles(files []string) {
    for _, filename := range files {
        file, err := os.Open(filename)
        if err != nil {
            continue
        }
        defer file.Close()  // All defers execute at function end!

        // Process file...
    }
    // All files closed here
}</code></pre>
        <br/>
        <li>Better pattern - use a closure:</li>
<pre><code class="language-go line-numbers">func processFiles(files []string) {
    for _, filename := range files {
        func() {
            file, err := os.Open(filename)
            if err != nil {
                return
            }
            defer file.Close()  // Closes at end of this iteration

            // Process file...
        }()
    }
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-arrays-slices">Arrays and Slices in Go</h3>
<ol>

    <li>Understanding Arrays</li>
    <br/>
    <ul>
        <li>An <b>array</b> is a fixed-size sequence of elements of the same type.</li>
        <br/>
        <li>Key characteristics:</li>
        <ul>
            <li>fixed length (cannot be resized)</li>
            <li>value type (copying creates a new array)</li>
            <li>zero-indexed (first element at index 0)</li>
            <li>elements are stored contiguously in memory</li>
        </ul>
        <br/>
        <li>Array declaration syntax:</li>
<pre><code class="language-go line-numbers">var arrayName [size]Type</code></pre>
        <li>The size is part of the array's type - <code>[5]int</code> and <code>[10]int</code> are different types.</li>
    </ul>
    <br/><br/>


    <li>Declaring and Initializing Arrays</li>
    <br/>
    <ul>
        <li>Declaration without initialization (elements set to zero values):</li>
<pre><code class="language-go line-numbers">var numbers [5]int  // [0, 0, 0, 0, 0]
var names [3]string // ["", "", ""]</code></pre>
        <br/>
        <li>Declaration with initialization:</li>
<pre><code class="language-go line-numbers">var numbers = [5]int{1, 2, 3, 4, 5}
names := [3]string{"Alice", "Bob", "Charlie"}</code></pre>
        <br/>
        <li>Partial initialization (remaining elements are zero values):</li>
<pre><code class="language-go line-numbers">numbers := [5]int{1, 2, 3}  // [1, 2, 3, 0, 0]</code></pre>
        <br/>
        <li>Let compiler count the length:</li>
<pre><code class="language-go line-numbers">numbers := [...]int{1, 2, 3, 4, 5}  // Length is 5</code></pre>
        <br/>
        <li>Initialize specific indices:</li>
<pre><code class="language-go line-numbers">numbers := [5]int{0: 10, 2: 30, 4: 50}  // [10, 0, 30, 0, 50]</code></pre>
    </ul>
    <br/><br/>


    <li>Accessing and Modifying Array Elements</li>
    <br/>
    <ul>
        <li>Access elements using index notation:</li>
<pre><code class="language-go line-numbers">numbers := [5]int{10, 20, 30, 40, 50}

fmt.Println(numbers[0])  // 10
fmt.Println(numbers[2])  // 30</code></pre>
        <br/>
        <li>Modify elements:</li>
<pre><code class="language-go line-numbers">numbers[1] = 25
fmt.Println(numbers)  // [10, 25, 30, 40, 50]</code></pre>
        <br/>
        <li>Get array length:</li>
<pre><code class="language-go line-numbers">length := len(numbers)
fmt.Println(length)  // 5</code></pre>
        <br/>
        <li>Accessing out-of-bounds indices causes a panic:</li>
<pre><code class="language-go line-numbers">numbers[10] = 100  // panic: index out of range</code></pre>
    </ul>
    <br/><br/>


    <li>Arrays Are Value Types</li>
    <br/>
    <ul>
        <li>Assigning an array to another variable creates a copy:</li>
<pre><code class="language-go line-numbers">original := [3]int{1, 2, 3}
copy := original

copy[0] = 10

fmt.Println(original)  // [1, 2, 3] - unchanged
fmt.Println(copy)      // [10, 2, 3] - modified</code></pre>
        <br/>
        <li>Passing arrays to functions creates a copy:</li>
<pre><code class="language-go line-numbers">func modify(arr [3]int) {
    arr[0] = 100  // Modifies the copy
}

func main() {
    numbers := [3]int{1, 2, 3}
    modify(numbers)
    fmt.Println(numbers)  // [1, 2, 3] - unchanged
}</code></pre>
        <br/>
        <li>To modify the original array, pass a pointer:</li>
<pre><code class="language-go line-numbers">func modify(arr *[3]int) {
    arr[0] = 100  // Modifies the original
}

func main() {
    numbers := [3]int{1, 2, 3}
    modify(&amp;numbers)
    fmt.Println(numbers)  // [100, 2, 3] - modified
}</code></pre>
    </ul>
    <br/><br/>


    <li>Understanding Slices</li>
    <br/>
    <ul>
        <li>A <code>slice</code> is a flexible, dynamic view into an array.</li>
        <br/>
        <li>Key differences from arrays:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>Array</th>
            <th>Slice</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Size</b></td>
            <td>Fixed</td>
            <td>Dynamic (can grow/shrink)</td>
        </tr>
        <tr>
            <td><b>Type</b></td>
            <td>Value type</td>
            <td>Reference type</td>
        </tr>
        <tr>
            <td><b>Declaration</b></td>
            <td><code>[n]Type</code></td>
            <td><code>[]Type</code></td>
        </tr>
        <tr>
            <td><b>Memory</b></td>
            <td>Stores actual values</td>
            <td>Stores pointer to underlying array</td>
        </tr>
        <tr>
            <td><b>Usage</b></td>
            <td>Rare in practice</td>
            <td>Very common</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>A slice consists of three components:</li>
        <ul>
            <li>pointer to the underlying array</li>
            <li>length (number of elements)</li>
            <li>capacity (maximum length without reallocation)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Declaring and Initializing Slices</li>
    <br/>
    <ul>
        <li>Declare a nil slice:</li>
<pre><code class="language-go line-numbers">var numbers []int  // nil slice
fmt.Println(numbers == nil)  // true
fmt.Println(len(numbers))    // 0</code></pre>
        <br/>
        <li>Initialize with values (slice literal):</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
names := []string{"Alice", "Bob", "Charlie"}</code></pre>
        <br/>
        <li>Create a slice using <code>make</code>:</li>
<pre><code class="language-go line-numbers">// make([]Type, length, capacity)
numbers := make([]int, 5)       // Length 5, capacity 5
numbers := make([]int, 5, 10)   // Length 5, capacity 10</code></pre>
        <br/>
        <li>Create a slice from an array:</li>
<pre><code class="language-go line-numbers">array := [5]int{1, 2, 3, 4, 5}
slice := array[1:4]  // [2, 3, 4]</code></pre>
        <br/>
        <li>Empty slice vs nil slice:</li>
<pre><code class="language-go line-numbers">var nilSlice []int           // nil
emptySlice := []int{}        // not nil, but length 0
emptySlice2 := make([]int, 0) // not nil, but length 0

fmt.Println(nilSlice == nil)    // true
fmt.Println(emptySlice == nil)  // false</code></pre>
    </ul>
    <br/><br/>


    <li>Slice Length and Capacity</li>
    <br/>
    <ul>
        <li><b>Length</b> - number of elements in the slice:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
fmt.Println(len(numbers))  // 5</code></pre>
        <br/>
        <li><b>Capacity</b> - number of elements in the underlying array (from the first element of the slice):</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
fmt.Println(cap(numbers))  // 5</code></pre>
        <br/>
        <li>Example showing length vs capacity:</li>
<pre><code class="language-go line-numbers">numbers := make([]int, 3, 10)
fmt.Println(len(numbers))  // 3 (current elements)
fmt.Println(cap(numbers))  // 10 (available space)</code></pre>
        <br/>
        <li>When slicing, capacity is from the start of the slice to the end of the underlying array:</li>
<pre><code class="language-go line-numbers">original := []int{1, 2, 3, 4, 5}
slice := original[1:3]  // [2, 3]

fmt.Println(len(slice))  // 2
fmt.Println(cap(slice))  // 4 (from index 1 to end of original)</code></pre>
    </ul>
    <br/><br/>


    <li>Slicing Operations</li>
    <br/>
    <ul>
        <li>Basic slicing syntax:</li>
<pre><code class="language-go line-numbers">slice[low:high]  // Elements from low to high-1</code></pre>
        <br/>
        <li>Examples:</li>
<pre><code class="language-go line-numbers">numbers := []int{0, 1, 2, 3, 4, 5}

fmt.Println(numbers[1:4])   // [1, 2, 3]
fmt.Println(numbers[:3])    // [0, 1, 2] - from start
fmt.Println(numbers[3:])    // [3, 4, 5] - to end
fmt.Println(numbers[:])     // [0, 1, 2, 3, 4, 5] - entire slice</code></pre>
        <br/>
        <li>Full slice expression with capacity:</li>
<pre><code class="language-go line-numbers">slice[low:high:max]  // Capacity is max - low</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">numbers := []int{0, 1, 2, 3, 4, 5}
slice := numbers[1:3:4]  // [1, 2] with capacity 3

fmt.Println(slice)       // [1, 2]
fmt.Println(len(slice))  // 2
fmt.Println(cap(slice))  // 3 (4 - 1)</code></pre>
        <br/>
        <li>Slices share the same underlying array:</li>
<pre><code class="language-go line-numbers">original := []int{1, 2, 3, 4, 5}
slice1 := original[1:4]
slice2 := original[2:5]

slice1[1] = 100

fmt.Println(original)  // [1, 2, 100, 4, 5]
fmt.Println(slice1)    // [2, 100, 4]
fmt.Println(slice2)    // [100, 4, 5]</code></pre>
    </ul>
    <br/><br/>


    <li>Appending to Slices</li>
    <br/>
    <ul>
        <li>Use the <code>append</code> function to add elements:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3}
numbers = append(numbers, 4)
fmt.Println(numbers)  // [1, 2, 3, 4]</code></pre>
        <br/>
        <li>Append multiple elements:</li>
<pre><code class="language-go line-numbers">numbers = append(numbers, 5, 6, 7)
fmt.Println(numbers)  // [1, 2, 3, 4, 5, 6, 7]</code></pre>
        <br/>
        <li>Append another slice (use <code>...</code> to spread):</li>
<pre><code class="language-go line-numbers">slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}

result := append(slice1, slice2...)
fmt.Println(result)  // [1, 2, 3, 4, 5, 6]</code></pre>
        <br/>
        <li>Capacity growth behavior:</li>
<pre><code class="language-go line-numbers">numbers := make([]int, 0, 2)
fmt.Printf("Len: %d, Cap: %d\n", len(numbers), cap(numbers))  // Len: 0, Cap: 2

numbers = append(numbers, 1)
fmt.Printf("Len: %d, Cap: %d\n", len(numbers), cap(numbers))  // Len: 1, Cap: 2

numbers = append(numbers, 2)
fmt.Printf("Len: %d, Cap: %d\n", len(numbers), cap(numbers))  // Len: 2, Cap: 2

numbers = append(numbers, 3)  // Triggers reallocation
fmt.Printf("Len: %d, Cap: %d\n", len(numbers), cap(numbers))  // Len: 3, Cap: 4</code></pre>
        <br/>
        <li>When capacity is exceeded, Go allocates a new underlying array (typically double the size).</li>
    </ul>
    <br/><br/>


    <li>Copying Slices</li>
    <br/>
    <ul>
        <li>Use the <code>copy</code> function to copy slice elements:</li>
<pre><code class="language-go line-numbers">copy(destination, source)</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">source := []int{1, 2, 3, 4, 5}
destination := make([]int, len(source))

n := copy(destination, source)
fmt.Println(destination)  // [1, 2, 3, 4, 5]
fmt.Println(n)            // 5 (number of elements copied)</code></pre>
        <br/>
        <li>Copy only copies the minimum of the two lengths:</li>
<pre><code class="language-go line-numbers">source := []int{1, 2, 3, 4, 5}
destination := make([]int, 3)

copy(destination, source)
fmt.Println(destination)  // [1, 2, 3]</code></pre>
        <br/>
        <li>Partial copy:</li>
<pre><code class="language-go line-numbers">source := []int{1, 2, 3, 4, 5}
destination := make([]int, 5)

copy(destination[1:4], source[2:5])
fmt.Println(destination)  // [0, 3, 4, 5, 0]</code></pre>
        <br/>
        <li>After copying, slices have independent underlying arrays:</li>
<pre><code class="language-go line-numbers">original := []int{1, 2, 3}
copied := make([]int, len(original))
copy(copied, original)

copied[0] = 100
fmt.Println(original)  // [1, 2, 3] - unchanged
fmt.Println(copied)    // [100, 2, 3] - modified</code></pre>
    </ul>
    <br/><br/>


    <li>Removing Elements From Slices</li>
    <br/>
    <ul>
        <li>Go has no built-in function to remove elements - use slicing and append:</li>
        <br/>
        <li>Remove element at index:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
index := 2

// Remove element at index 2
numbers = append(numbers[:index], numbers[index+1:]...)
fmt.Println(numbers)  // [1, 2, 4, 5]</code></pre>
        <br/>
        <li>Remove first element:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
numbers = numbers[1:]
fmt.Println(numbers)  // [2, 3, 4, 5]</code></pre>
        <br/>
        <li>Remove last element:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
numbers = numbers[:len(numbers)-1]
fmt.Println(numbers)  // [1, 2, 3, 4]</code></pre>
        <br/>
        <li>Remove multiple elements:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5, 6, 7}
start := 2
end := 5

numbers = append(numbers[:start], numbers[end:]...)
fmt.Println(numbers)  // [1, 2, 6, 7]</code></pre>
        <br/>
        <li>Filter slice (keep elements matching condition):</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5, 6}
result := numbers[:0]  // Reuse backing array

for _, num := range numbers {
    if num%2 == 0 {  // Keep even numbers
        result = append(result, num)
    }
}
fmt.Println(result)  // [2, 4, 6]</code></pre>
    </ul>
    <br/><br/>


    <li>Multi-Dimensional Arrays and Slices</li>
    <br/>
    <ul>
        <li>Multi-dimensional arrays:</li>
<pre><code class="language-go line-numbers">// 2D array
var matrix [3][4]int

// Initialize 2D array
matrix := [3][4]int{
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
}

fmt.Println(matrix[1][2])  // 7</code></pre>
        <br/>
        <li>Multi-dimensional slices:</li>
<pre><code class="language-go line-numbers">// Slice of slices
matrix := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

fmt.Println(matrix[1][1])  // 5</code></pre>
        <br/>
        <li>Create 2D slice with make:</li>
<pre><code class="language-go line-numbers">rows := 3
cols := 4

matrix := make([][]int, rows)
for i := range matrix {
    matrix[i] = make([]int, cols)
}

matrix[1][2] = 100
fmt.Println(matrix[1][2])  // 100</code></pre>
        <br/>
        <li>Jagged slices (rows with different lengths):</li>
<pre><code class="language-go line-numbers">jagged := [][]int{
    {1},
    {2, 3},
    {4, 5, 6},
    {7, 8, 9, 10},
}

for i, row := range jagged {
    fmt.Printf("Row %d: %v\n", i, row)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Iterating Over Arrays and Slices</li>
    <br/>
    <ul>
        <li>Using <code>for</code> loop with index:</li>
<pre><code class="language-go line-numbers">numbers := []int{10, 20, 30, 40, 50}

for i := 0; i < len(numbers); i++ {
    fmt.Println(numbers[i])
}</code></pre>
        <br/>
        <li>Using <code>range</code> (recommended):</li>
<pre><code class="language-go line-numbers">numbers := []int{10, 20, 30, 40, 50}

for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}</code></pre>
        <br/>
        <li>Iterate with values only:</li>
<pre><code class="language-go line-numbers">for _, value := range numbers {
    fmt.Println(value)
}</code></pre>
        <br/>
        <li>Iterate with indices only:</li>
<pre><code class="language-go line-numbers">for index := range numbers {
    fmt.Println(index)
}</code></pre>
        <br/>
        <li>Iterating backwards:</li>
<pre><code class="language-go line-numbers">for i := len(numbers) - 1; i >= 0; i-- {
    fmt.Println(numbers[i])
}</code></pre>
        <br/>
        <li>Iterate 2D slice:</li>
<pre><code class="language-go line-numbers">matrix := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

for i, row := range matrix {
    for j, value := range row {
        fmt.Printf("matrix[%d][%d] = %d\n", i, j, value)
    }
}</code></pre>
    </ul>
    <br/><br/>


    <li>Common Slice Operations</li>
    <br/>
    <ul>
        <li>Check if slice is empty:</li>
<pre><code class="language-go line-numbers">if len(slice) == 0 {
    fmt.Println("Slice is empty")
}</code></pre>
        <br/>
        <li>Reverse a slice:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}

for i, j := 0, len(numbers)-1; i < j; i, j = i+1, j-1 {
    numbers[i], numbers[j] = numbers[j], numbers[i]
}

fmt.Println(numbers)  // [5, 4, 3, 2, 1]</code></pre>
        <br/>
        <li>Find element in slice:</li>
<pre><code class="language-go line-numbers">numbers := []int{10, 20, 30, 40, 50}
target := 30
found := false

for _, num := range numbers {
    if num == target {
        found = true
        break
    }
}

fmt.Println(found)  // true</code></pre>
        <br/>
        <li>Sum all elements:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
sum := 0

for _, num := range numbers {
    sum += num
}

fmt.Println(sum)  // 15</code></pre>
        <br/>
        <li>Find minimum and maximum:</li>
<pre><code class="language-go line-numbers">numbers := []int{34, 12, 56, 23, 89, 5}
min := numbers[0]
max := numbers[0]

for _, num := range numbers {
    if num < min {
        min = num
    }
    if num > max {
        max = num
    }
}

fmt.Printf("Min: %d, Max: %d\n", min, max)  // Min: 5, Max: 89</code></pre>
    </ul>
    <br/><br/>


    <li>Slice Tricks and Patterns</li>
    <br/>
    <ul>
        <li>Pre-allocate slice when size is known:</li>
<pre><code class="language-go line-numbers">// Instead of:
var numbers []int
for i := 0; i < 1000; i++ {
    numbers = append(numbers, i)  // Multiple reallocations
}

// Better:
numbers := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    numbers = append(numbers, i)  // No reallocations
}</code></pre>
        <br/>
        <li>Insert element at index:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 4, 5}
index := 2
value := 3

numbers = append(numbers[:index], append([]int{value}, numbers[index:]...)...)
fmt.Println(numbers)  // [1, 2, 3, 4, 5]</code></pre>
        <br/>
        <li>Clear slice (keep capacity):</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
numbers = numbers[:0]  // Length 0, capacity unchanged</code></pre>
        <br/>
        <li>Clone a slice:</li>
<pre><code class="language-go line-numbers">original := []int{1, 2, 3, 4, 5}
clone := append([]int{}, original...)
// Or:
clone := make([]int, len(original))
copy(clone, original)</code></pre>
        <br/>
        <li>Deduplicate slice (remove duplicates):</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 2, 3, 3, 3, 4, 5, 5}
seen := make(map[int]bool)
result := []int{}

for _, num := range numbers {
    if !seen[num] {
        seen[num] = true
        result = append(result, num)
    }
}

fmt.Println(result)  // [1, 2, 3, 4, 5]</code></pre>
    </ul>
    <br/><br/>


    <li>Slice Internals and Memory</li>
    <br/>
    <ul>
        <li>A slice header contains:</li>
<pre><code class="language-go line-numbers">type slice struct {
    ptr *Elem  // Pointer to array
    len int    // Length
    cap int    // Capacity
}</code></pre>
        <br/>
        <li>Visualizing slice memory:</li>
<pre><code class="language-go line-numbers">array := [6]int{1, 2, 3, 4, 5, 6}
slice := array[1:4]

// slice points to: [2, 3, 4]
// len(slice) = 3
// cap(slice) = 5 (from index 1 to end of array)</code></pre>
        <br/>
        <li>Memory leak risk with large arrays:</li>
<pre><code class="language-go line-numbers">// Bad - keeps entire array in memory
func getFirstTwo(data []int) []int {
    return data[:2]  // Still references original array
}

// Good - copy to new slice
func getFirstTwo(data []int) []int {
    result := make([]int, 2)
    copy(result, data[:2])
    return result  // Original array can be garbage collected
}</code></pre>
        <br/>
        <li>Capacity doubling strategy:</li>
        <ul>
            <li>When capacity is exceeded, Go typically doubles the capacity</li>
            <li>For very large slices, growth rate may be less than 2x</li>
            <li>This ensures append operations are amortized O(1)</li>
        </ul>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-variadic-functions">Variadic Functions in Go</h3>
<ol>

    <li>What Are Variadic Functions?</li>
    <br/>
    <ul>
        <li><b>Variadic functions</b> are functions that can accept a variable number of arguments of the same type.</li>
        <br/>
        <li>The last parameter uses <code>...</code> syntax before the type: <code>func name(args ...Type)</code></li>
        <br/>
        <li>Inside the function, the variadic parameter becomes a slice of that type.</li>
        <br/>
        <li>Example from standard library:</li>
<pre><code class="language-go line-numbers">fmt.Println("Hello", "World", "!")      // Takes any number of arguments
fmt.Printf("%s %s\n", "Hello", "World") // First arg is format, rest are variadic
</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Syntax</li>
    <br/>
    <ul>
        <li>Declaring a variadic function:</li>
<pre><code class="language-go line-numbers">// Simple variadic function
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    // Call with different number of arguments
    fmt.Println(sum())              // 0 (no arguments)
    fmt.Println(sum(1))             // 1 (one argument)
    fmt.Println(sum(1, 2, 3))       // 6 (three arguments)
    fmt.Println(sum(1, 2, 3, 4, 5)) // 15 (five arguments)
}
</code></pre>
        <li>Only the <u>last parameter</u> can be variadic</li>
    </ul>
    <br/><br/>


    <li>Variadic Parameters Are Slices</li>
    <br/>
    <ul>
        <li>Inside the function, the variadic parameter is a regular slice:</li>
    </ul>
<pre><code class="language-go line-numbers">func printInfo(names ...string) {
    // names is a []string slice
    fmt.Printf("Type: %T\n", names)      // Type: []string
    fmt.Printf("Length: %d\n", len(names))
    fmt.Printf("Values: %v\n", names)

    // Can use all slice operations
    if len(names) > 0 {
        fmt.Println("First:", names[0])
    }

    // Can iterate
    for i, name := range names {
        fmt.Printf("%d: %s\n", i, name)
    }
}

func main() {
    printInfo("Alice", "Bob", "Carol")
}

// Output:
// Type: []string
// Length: 3
// Values: [Alice Bob Carol]
// First: Alice
// 0: Alice
// 1: Bob
// 2: Carol
</code></pre>
    <br/><br/>


    <li>Passing Slices to Variadic Functions</li>
    <br/>
    <ul>
        <li>You can pass a slice to a variadic function using the <code>...</code> operator:</li>
<pre><code class="language-go line-numbers">func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    // Pass individual arguments
    result := sum(1, 2, 3, 4, 5)
    fmt.Println(result)  // 15

    // Pass a slice using ...
    nums := []int{1, 2, 3, 4, 5}
    result = sum(nums...)  // Unpack slice into variadic args
    fmt.Println(result)    // 15

    // Can also use slice literal
    result = sum([]int{10, 20, 30}...)
    fmt.Println(result)    // 60
}</code></pre>
        <br/>
        <li><b>The <code>...</code> operator unpacks the slice:</b></li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3}

// These are equivalent:
sum(numbers...)        // Unpack slice
sum(1, 2, 3)           // Individual arguments

// Without ..., it's a type error:
// sum(numbers)        // âŒ Error: cannot use []int as int</code></pre>
        <br/>
        <li><b>Important: Unpacking creates a slice reference</b></li>
<pre><code class="language-go line-numbers">func modify(numbers ...int) {
    if len(numbers) > 0 {
        numbers[0] = 999  // Modify the slice
    }
}

func main() {
    nums := []int{1, 2, 3}

    modify(nums...)        // Pass slice
    fmt.Println(nums)      // [999 2 3] - Original slice modified!

    modify(1, 2, 3)        // Pass individual values
    // Creates a new slice, original data not affected
}</code></pre>
    </ul>
    <br/><br/>


    <li>Advanced Patterns</li>
    <br/>
    <ul>
        <li><b>Functional options pattern:</b></li>
<pre><code class="language-go line-numbers">type Server struct {
    host string
    port int
    timeout int
}

type Option func(*Server)

func WithHost(host string) Option {
    return func(s *Server) {
        s.host = host
    }
}

func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

func WithTimeout(timeout int) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func NewServer(options ...Option) *Server {
    // Default values
    server := &Server{
        host:    "localhost",
        port:    8080,
        timeout: 30,
    }

    // Apply options
    for _, opt := range options {
        opt(server)
    }

    return server
}

func main() {
    // Use defaults
    s1 := NewServer()
    fmt.Printf("%+v\n", s1)  // {host:localhost port:8080 timeout:30}

    // Customize some options
    s2 := NewServer(
        WithHost("example.com"),
        WithPort(3000),
    )
    fmt.Printf("%+v\n", s2)  // {host:example.com port:3000 timeout:30}

    // Customize all options
    s3 := NewServer(
        WithHost("api.example.com"),
        WithPort(443),
        WithTimeout(60),
    )
    fmt.Printf("%+v\n", s3)  // {host:api.example.com port:443 timeout:60}
}</code></pre>
        <br/>
        <li><b>Logger with variadic formatting:</b></li>
<pre><code class="language-go line-numbers">type Logger struct {
    prefix string
}

func (l *Logger) Log(format string, args ...interface{}) {
    message := fmt.Sprintf(format, args...)
    fmt.Printf("[%s] %s\n", l.prefix, message)
}

func main() {
    logger := Logger{prefix: "APP"}

    logger.Log("Starting server")
    // [APP] Starting server

    logger.Log("User %s logged in at %d", "alice", 1234567890)
    // [APP] User alice logged in at 1234567890

    logger.Log("Processing %d items", 42)
    // [APP] Processing 42 items
}</code></pre>
        <br/>
        <li><b>Variadic method receivers:</b></li>
<pre><code class="language-go line-numbers">type Numbers struct {
    values []int
}

func (n *Numbers) Add(numbers ...int) {
    n.values = append(n.values, numbers...)
}

func (n *Numbers) Sum() int {
    total := 0
    for _, v := range n.values {
        total += v
    }
    return total
}

func main() {
    nums := &Numbers{}

    nums.Add(1, 2, 3)
    nums.Add(4, 5)

    slice := []int{6, 7, 8}
    nums.Add(slice...)

    fmt.Println(nums.Sum())  // 36
}</code></pre>
    </ul>
    <br/><br/>


    <li>Performance Considerations</li>
    <br/>
    <ul>
        <li><b>Memory allocation:</b></li>
<pre><code class="language-go line-numbers">func process(items ...string) {
    // items is allocated as a slice each call
    fmt.Println(len(items))
}

// Each call allocates a new slice
process("a", "b", "c")  // Allocates []string with 3 elements
process("d", "e")       // Allocates []string with 2 elements

// If you already have a slice, use ... to avoid extra allocation
existing := []string{"a", "b", "c"}
process(existing...)    // No extra allocation, passes existing slice</code></pre>
        <br/>
        <li><b>Passing slice vs individual args:</b></li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}

// Option 1: Unpack slice (no copy, just passes reference)
sum(numbers...)     // Efficient

// Option 2: Individual args (compiler creates new slice)
sum(1, 2, 3, 4, 5)  // Less efficient for many args

// For small number of args (< 5), individual args are fine
// For large number of args or existing slice, use ... operator</code></pre>
        <br/>
        <li><b>Benchmarking example:</b></li>
<pre><code class="language-go line-numbers">// For hot paths or performance-critical code:

// If always passing 2-3 args, might be better to have explicit params
func add3(a, b, c int) int {
    return a + b + c
}

// Instead of
func addVariadic(numbers ...int) int {
    total := 0
    for _, n := range numbers {
        total += n
    }
    return total
}

// addVariadic is more flexible but slightly slower
// Difference is negligible for most use cases</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-type-aliases">Type Aliases in Go</h3>
<ol>

    <li>What Are Type Aliases?</li>
    <br/>
    <ul>
        <li>Go has two ways to create new type names:</li>
        <ul>
            <br/>
            <li>Type definition (creates a new, distinct type): <code>type NewType OldType</code></li>
            <br/>
            <li>Type alias (creates an alternate name for existing type): <code>type NewType = OldType</code></li>
        </ul>
        <br/>
        <li>Type alias example:</li>
<pre><code class="language-go line-numbers">// Create an alias for int
type MyInt = int

func main() {
    var x MyInt = 42
    var y int = 100

    // MyInt and int are the SAME type
    x = y  // âœ“ Works - they're identical types
    y = x  // âœ“ Works - they're identical types

    fmt.Printf("Type of x: %T\n", x)  // Type of x: int
    fmt.Printf("Type of y: %T\n", y)  // Type of y: int
}</code></pre>
        <br/>
        <li>Type definition example (for comparison):</li>
<pre><code class="language-go line-numbers">// Create a NEW type based on int
type MyInt int

func main() {
    var x MyInt = 42
    var y int = 100

    // MyInt and int are DIFFERENT types
    // x = y  // âŒ Error: cannot use y (type int) as type MyInt
    // y = x  // âŒ Error: cannot use x (type MyInt) as type int

    // Must explicitly convert
    x = MyInt(y)  // âœ“ Works with conversion
    y = int(x)    // âœ“ Works with conversion

    fmt.Printf("Type of x: %T\n", x)  // Type of x: main.MyInt
    fmt.Printf("Type of y: %T\n", y)  // Type of y: int
}</code></pre>
    </ul>
    <br/><br/>


    <li>Type Aliases in the Standard Library</li>
    <br/>
    <ul>
        <li><code>byte</code> and <code>rune</code>:</li>
<pre><code class="language-go line-numbers">// Built-in type aliases
type byte = uint8
type rune = int32

func main() {
    var b byte = 'A'
    var u uint8 = 65

    b = u  // âœ“ Same type
    u = b  // âœ“ Same type

    fmt.Printf("%T\n", b)  // uint8 (not byte!)

    var r rune = 'ä¸–'
    var i int32 = 19990

    r = i  // âœ“ Same type
    i = r  // âœ“ Same type

    fmt.Printf("%T\n", r)  // int32 (not rune!)
}
</code></pre>
        <br/>
        <li><code>any</code> (Go 1.18+):</li>
<pre><code class="language-go line-numbers">// any is an alias for interface{}
type any = interface{}

func printAny(v any) {
    fmt.Println(v)
}

// Same as
func printInterface(v interface{}) {
    fmt.Println(v)
}

// Both are identical
func main() {
    printAny("hello")
    printInterface(42)
}
</code></pre>
        <br/>
        <li>Type aliases for migration in standard library:</li>
<pre><code class="language-go line-numbers">// In the context package, there were type aliases
// used during refactoring

// Original location
// package oldpkg
// type Context interface { ... }

// New location
// package context

// Alias for compatibility
// type Context = newlocation.Context
</code></pre>
    </ul>
    <br/><br/>


    <li>Type Aliases with Generics (Go 1.18+)</li>
    <br/>
    <ul>
        <li>Alias for generic types:</li>
<pre><code class="language-go line-numbers">// Original generic type
type Pair[T, U any] struct {
    First  T
    Second U
}

// Create alias (must include type parameters)
type Coord[T, U any] = Pair[T, U]

func main() {
    // Use either name
    p := Pair[int, string]{First: 1, Second: "one"}
    c := Coord[int, string]{First: 2, Second: "two"}

    // They're the same type
    p = c  // âœ“ Works
    c = p  // âœ“ Works
}
</code></pre>
        <br/>
        <li>Alias for specific instantiation:</li>
<pre><code class="language-go line-numbers">// Generic type
type List[T any] []T

// Alias for specific type
type IntList = List[int]
type StringList = List[string]

func main() {
    var nums IntList = IntList{1, 2, 3}
    var words StringList = StringList{"a", "b", "c"}

    // IntList is the same as List[int]
    var nums2 List[int] = nums  // âœ“ Works
}
</code></pre>
        <br/>
        <li>Simplifying complex generic types:</li>
<pre><code class="language-go line-numbers">// Complex generic map type
type Cache[K comparable, V any] map[K]V

// Create simpler aliases for common cases
type StringCache[V any] = Cache[string, V]
type IntCache[V any] = Cache[int, V]

func main() {
    // Simpler to write
    userCache := StringCache[User]{}

    // Instead of
    userCache2 := Cache[string, User]{}
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Type Aliases and Reflection</li>
    <br/>
    <ul>
        <li>Reflection sees type aliases as their underlying type:</li>
    </ul>
<pre><code class="language-go line-numbers">import "reflect"

type MyString = string
type MyStringType string

func main() {
    var s1 MyString = "alias"
    var s2 MyStringType = "definition"
    var s3 string = "original"

    // Type alias: same reflect.Type as original
    t1 := reflect.TypeOf(s1)
    t3 := reflect.TypeOf(s3)
    fmt.Println(t1 == t3)  // true
    fmt.Println(t1.Name()) // string

    // Type definition: different reflect.Type
    t2 := reflect.TypeOf(s2)
    fmt.Println(t2 == t3)  // false
    fmt.Println(t2.Name()) // MyStringType
}
</code></pre>
    <br/><br/>


    <li>Limitations of Type Aliases</li>
    <br/>
    <ul>
        <li>Cannot add methods:</li>
<pre><code class="language-go line-numbers">type MyInt = int

// âŒ Cannot define methods on non-local type
// func (m MyInt) Double() int {
//     return m * 2
// }

// Solution: use type definition
type MyIntType int

func (m MyIntType) Double() int {
    return int(m) * 2
}  // âœ“ Works</code></pre>
        <br/>
        <li>No type safety:</li>
<pre><code class="language-go line-numbers">type UserID = int
type ProductID = int

func getUser(id UserID) { }
func getProduct(id ProductID) { }

func main() {
    var userId UserID = 1
    var productId ProductID = 2

    // No type safety - both are just int!
    getUser(productId)    // âœ“ Compiles (but logically wrong!)
    getProduct(userId)    // âœ“ Compiles (but logically wrong!)

    // With type definitions, you get safety
    type UserIDType int
    type ProductIDType int

    var userId2 UserIDType = 1
    var productId2 ProductIDType = 2

    // getUser(productId2)  // âŒ Type error
}</code></pre>
        <br/>
        <li>Cannot use in composite literals of unexported types:</li>
<pre><code class="language-go line-numbers">// In package a
package a

type internal struct {
    Field int
}

type Public = internal  // Alias

// In package b
package b

import "pkg/a"

func main() {
    // âŒ Cannot construct - internal is unexported
    // v := a.Public{Field: 1}

    // Even though Public is exported, it's an alias
    // to unexported type internal
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-maps">Maps in Go</h3>
<ol>

    <li>What Are Maps?</li>
    <br/>
    <ul>
        <li><b>Maps</b> are Go's built-in key-value data structure (similar to dictionaries in Python or objects in JavaScript).</li>
        <br/>
        <li>Maps provide fast lookup, insertion, and deletion based on keys.</li>
        <br/>
        <li>In Go, maps are <b>reference types</b> - they reference an underlying hash table.</li>
        <br/>
        <li>Basic syntax:</li>
<pre><code class="language-go line-numbers">var ages map[string]int         // Declaration
ages = make(map[string]int)     // Initialization
ages["Amy"] = 30                // Assignment
fmt.Println(ages["Amy"])        // Access: 30</code></pre>
    </ul>
    <br/><br/>


    <li>Map Type Declaration</li>
    <br/>
    <ul>
        <li>Map types are declared as <code>map[KeyType]ValueType</code></li>
        <br/>
        <li><code>KeyType</code> must be a comparable type (supports <code>==</code> and <code>!=</code>)</li>
        <br/>
        <li><code>ValueType</code> Can be any type, including slices, maps, or functions</li>
        <br/>
        <li>Examples of valid map types:</li>
<pre><code class="language-go line-numbers">map[string]int              // String keys, int values
map[int]string              // Int keys, string values
map[string][]int            // String keys, slice values
map[int]map[string]bool     // Int keys, nested map values
map[[2]int]string           // Array keys, string values

// Struct as key (all fields must be comparable)
type Point struct {
    X, Y int
}
map[Point]string            // Point keys, string values

map[[]int]string            // âŒ Slice keys not allowed
map[map[string]int]bool     // âŒ Map keys not allowed
map[func()]string           // âŒ Function keys not allowed</code></pre>
</code></pre>
    </ul>
    <br/><br/>


    <li>Creating Maps</li>
    <br/>
    <ul>
        <li>Method 1: Using <code>make</code></li>
<pre><code class="language-go line-numbers">// Create empty map
ages := make(map[string]int)

// With initial capacity hint (for performance)
ages := make(map[string]int, 100)  // Hint: expect ~100 elements</code></pre>
        <br/>
        <li>Method 2: Map literal</li>
<pre><code class="language-go line-numbers">// Create and initialize in one step
ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
    "Carol": 28,
}

// Empty map literal
ages := map[string]int{}</code></pre>
        <br/>
        <li>Method 3: <code>var</code> declaration (creates <code>nil</code> map)</li>
<pre><code class="language-go line-numbers">var ages map[string]int     // ages is nil
// Can read from nil map (returns zero value)
fmt.Println(ages["Alice"])  // 0

// âŒ Cannot write to nil map - will panic!
// ages["Alice"] = 30       // panic: assignment to entry in nil map

// Must initialize with make first
ages = make(map[string]int)
ages["Alice"] = 30          // âœ“ Now it works</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Map Operations</li>
    <br/>
    <ul>
        <li>Adding or updating entries:</li>
<pre><code class="language-go line-numbers">ages := make(map[string]int)

// Add new entry
ages["Alice"] = 30

// Update existing entry (same syntax)
ages["Alice"] = 31

// Multiple assignments
ages["Bob"] = 25
ages["Carol"] = 28</code></pre>
        <br/>
        <li>Accessing values:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
}

// Direct access
age := ages["Alice"]    // 30

// Accessing non-existent key returns zero value
age := ages["David"]    // 0 (zero value for int)</code></pre>
        <br/>
        <li>Checking if key exists:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 30,
    "Bob":   0,      // Explicitly set to 0
}

// Two-value assignment
age, exists := ages["Alice"]
if exists {
    fmt.Println("Alice's age:", age)  // Alice's age: 30
}

// Check for Bob (age is 0)
age, exists = ages["Bob"]
fmt.Println(age, exists)    // 0 true (key exists, value is 0)

// Check for non-existent key
age, exists = ages["Carol"]
fmt.Println(age, exists)    // 0 false (key doesn't exist)

// Common pattern: check and use
if age, ok := ages["Alice"]; ok {
    fmt.Println("Found:", age)
}</code></pre>
        <br/>
        <li>Deleting entries:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
    "Carol": 28,
}

// Delete a key
delete(ages, "Bob")

// Delete non-existent key (safe, no error)
delete(ages, "David")  // No-op

fmt.Println(ages)  // map[Alice:30 Carol:28]</code></pre>
        <br/>
        <li>Getting map length:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
}

count := len(ages)      // 2

// Empty map
empty := make(map[string]int)
count = len(empty)      // 0

// Nil map
var nilMap map[string]int
count = len(nilMap)     // 0</code></pre>
    </ul>
    <br/><br/>


    <li>Iterating Over Maps</li>
    <br/>
    <ul>
        <li>Using <code>for</code>-<code>range</code> loop:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
    "Carol": 28,
}

// Iterate over key-value pairs
for name, age := range ages {
    fmt.Printf("%s is %d years old\n", name, age)
}

// Output (order is random!):
// Bob is 25 years old
// Carol is 28 years old
// Alice is 30 years old</code></pre>
        <br/>
        <li>Iterate over keys only:</li>
<pre><code class="language-go line-numbers">for name := range ages {
    fmt.Println(name)
}</code></pre>
        <br/>
        <li>Iterate over values only (less common):</li>
<pre><code class="language-go line-numbers">for _, age := range ages {
    fmt.Println(age)
}</code></pre>
        <br/>
        <li>IMPORTANT: Map iteration order is random!</li>
<pre><code class="language-go line-numbers">// Do NOT rely on iteration order
ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
    "Carol": 28,
}

// Each run may produce different order
for name := range ages {
    fmt.Println(name)
}

// Run 1: Alice, Bob, Carol
// Run 2: Carol, Alice, Bob
// Run 3: Bob, Carol, Alice
// Order is deliberately randomized!</code></pre>
    </ul>
    <br/><br/>


    <li>Sorting Map Keys for Consistent Order</li>
    <br/>
    <ul>
        <li>Since map iteration is random, sort keys for consistent output:</li>
<pre><code class="language-go line-numbers">import (
    "fmt"
    "sort"
)

ages := map[string]int{
    "Carol": 28,
    "Alice": 30,
    "Bob":   25,
}

// Extract keys into slice
keys := make([]string, 0, len(ages))
for k := range ages {
    keys = append(keys, k)
}

// Sort keys
sort.Strings(keys)

// Iterate in sorted order
for _, name := range keys {
    fmt.Printf("%s: %d\n", name, ages[name])
}

// Output (always in this order):
// Alice: 30
// Bob: 25
// Carol: 28</code></pre>
        <br/>
        <li>Sorting by values:</li>
<pre><code class="language-go line-numbers">import (
    "fmt"
    "sort"
)

ages := map[string]int{
    "Alice": 30,
    "Bob":   25,
    "Carol": 28,
}

// Create slice of key-value pairs
type kv struct {
    Key   string
    Value int
}

var pairs []kv
for k, v := range ages {
    pairs = append(pairs, kv{k, v})
}

// Sort by value
sort.Slice(pairs, func(i, j int) bool {
    return pairs[i].Value < pairs[j].Value
})

// Print sorted
for _, pair := range pairs {
    fmt.Printf("%s: %d\n", pair.Key, pair.Value)
}

// Output:
// Bob: 25
// Carol: 28
// Alice: 30
</code></pre>
    </ul>
    <br/><br/>


    <li>Maps Are Reference Types</li>
    <br/>
    <ul>
        <li>Maps are references to underlying hash table data structure:</li>
<pre><code class="language-go line-numbers">// When you assign a map, both variables point to same data
ages1 := map[string]int{
    "Alice": 30,
}

ages2 := ages1          // Both reference same underlying map

ages2["Bob"] = 25       // Modify through ages2

fmt.Println(ages1)      // map[Alice:30 Bob:25]
fmt.Println(ages2)      // map[Alice:30 Bob:25]
// Both show the change!</code></pre>
        <br/>
        <li>Passing maps to functions:</li>
<pre><code class="language-go line-numbers">func addPerson(m map[string]int, name string, age int) {
    m[name] = age  // Modifies the original map
}

func main() {
    ages := map[string]int{
        "Alice": 30,
    }

    addPerson(ages, "Bob", 25)

    fmt.Println(ages)  // map[Alice:30 Bob:25]
    // Original map is modified
}</code></pre>
        <br/>
        <li>To create a copy, must manually copy entries:</li>
<pre><code class="language-go line-numbers">original := map[string]int{
    "Alice": 30,
    "Bob":   25,
}

// Create a copy
copy := make(map[string]int)
for k, v := range original {
    copy[k] = v
}

// Now they're independent
copy["Carol"] = 28
fmt.Println(original)  // map[Alice:30 Bob:25]
fmt.Println(copy)      // map[Alice:30 Bob:25 Carol:28]</code></pre>
    </ul>
    <br/><br/>


    <li>Zero Values and Nil Maps</li>
    <br/>
    <ul>
        <li>Zero value of map type is nil:</li>
<pre><code class="language-go line-numbers">var ages map[string]int     // nil map
fmt.Println(ages == nil)    // true
fmt.Println(len(ages))      // 0</code></pre>
        <br/>
        <li>Reading from nil map is safe:</li>
<pre><code class="language-go line-numbers">var ages map[string]int     // nil

age := ages["Alice"]        // âœ“ Returns 0 (zero value)
_, ok := ages["Bob"]        // âœ“ Returns 0, false
len := len(ages)            // âœ“ Returns 0

for k, v := range ages {    // âœ“ Loop doesn't execute
    fmt.Println(k, v)
}</code></pre>
        <br/>
        <li>Writing to nil map causes panic:</li>
<pre><code class="language-go line-numbers">var ages map[string]int     // nil

ages["Alice"] = 30          // âŒ panic: assignment to entry in nil map

// Must initialize first
ages = make(map[string]int)
ages["Alice"] = 30          // âœ“ Works</code></pre>
        <br/>
        <li>Deleting from nil map is safe (no-op):</li>
<pre><code class="language-go line-numbers">var ages map[string]int     // nil
delete(ages, "Alice")       // âœ“ Safe, does nothing</code></pre>
    </ul>
    <br/><br/>


    <li>Maps with Complex Value Types</li>
    <br/>
    <ul>
        <li>Map of slices:</li>
<pre><code class="language-go line-numbers">// Store multiple values per key
students := make(map[string][]int)

// Add grades
students["Alice"] = []int{95, 87, 92}
students["Bob"] = []int{78, 85, 90}

// Add more grades
students["Alice"] = append(students["Alice"], 88)

fmt.Println(students["Alice"])  // [95 87 92 88]</code></pre>
        <br/>
        <li>Map of maps (nested):</li>
<pre><code class="language-go line-numbers">// Two-level lookup: country -> city -> population
world := make(map[string]map[string]int)

// Initialize inner maps
world["USA"] = make(map[string]int)
world["Japan"] = make(map[string]int)

// Add data
world["USA"]["NYC"] = 8000000
world["USA"]["LA"] = 4000000
world["Japan"]["Tokyo"] = 14000000

// Access nested data
fmt.Println(world["USA"]["NYC"])  // 8000000

// Check nested key existence
if cities, ok := world["USA"]; ok {
    if pop, ok := cities["NYC"]; ok {
        fmt.Println("NYC population:", pop)
    }
}</code></pre>
        <br/>
        <li>Map of structs:</li>
<pre><code class="language-go line-numbers">type Person struct {
    Age  int
    City string
}

people := make(map[string]Person)
people["Alice"] = Person{Age: 30, City: "NYC"}
people["Bob"] = Person{Age: 25, City: "LA"}

// Access
alice := people["Alice"]
fmt.Println(alice.City)  // NYC

// Cannot modify struct fields directly (map returns a copy)
// people["Alice"].Age = 31  // âŒ Compile error

// Must replace entire struct
alice.Age = 31
people["Alice"] = alice  // âœ“ Works

// Or use pointer to struct
peoplePtr := make(map[string]*Person)
peoplePtr["Alice"] = &Person{Age: 30, City: "NYC"}
peoplePtr["Alice"].Age = 31  // âœ“ Works (modifying through pointer)</code></pre>
    </ul>
    <br/><br/>


    <li>Concurrent Access to Maps</li>
    <br/>
    <ul>
        <li>WARNING: Maps are <u>NOT</u> safe for concurrent access!</li>
<pre><code class="language-go line-numbers">// âŒ UNSAFE - will crash!
m := make(map[int]int)

go func() {
    for i := 0; i < 1000; i++ {
        m[i] = i  // Writing
    }
}()

go func() {
    for i := 0; i < 1000; i++ {
        _ = m[i]  // Reading
    }
}()

// This will cause: fatal error: concurrent map read and map write
</code></pre>
        <br/>
        <li>Solution 1: Use <code>sync.Mutex</code></li>
<pre><code class="language-go line-numbers">import "sync"

type SafeMap struct {
    mu sync.Mutex
    m  map[int]int
}

func (sm *SafeMap) Set(key, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.m[key] = value
}

func (sm *SafeMap) Get(key int) (int, bool) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    val, ok := sm.m[key]
    return val, ok
}

func main() {
    sm := SafeMap{m: make(map[int]int)}

    go func() {
        for i := 0; i < 1000; i++ {
            sm.Set(i, i)
        }
    }()

    go func() {
        for i := 0; i < 1000; i++ {
            sm.Get(i)
        }
    }()
}</code></pre>
        <br/>
        <li>Solution 2: Use <code>sync.Map</code> (for specific use cases)</li>
<pre><code class="language-go line-numbers">import "sync"

var m sync.Map

// Store
m.Store("key", "value")

// Load
value, ok := m.Load("key")
if ok {
    fmt.Println(value)
}

// Delete
m.Delete("key")

// LoadOrStore (atomic)
actual, loaded := m.LoadOrStore("key", "value")

// Range (iterate)
m.Range(func(key, value interface{}) bool {
    fmt.Println(key, value)
    return true  // continue iteration
})

// Note: sync.Map uses interface{}, so less type-safe than regular maps</code></pre>
        <ul>
            <li>Use <code>sync.Map</code> when: keys are stable (write once, read many), or high contention</li>
            <li>Use <code>Mutex</code> when: frequent writes, or need type safety, or map is small</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Comparing Maps</li>
    <br/>
    <ul>
        <li>Maps cannot be compared directly with <code>==</code> (except to nil):</li>
<pre><code class="language-go line-numbers">m1 := map[string]int{"a": 1}
m2 := map[string]int{"a": 1}

// âŒ Compile error
// if m1 == m2 { }

// âœ“ Can compare to nil
var m3 map[string]int
if m3 == nil {
    fmt.Println("m3 is nil")
}</code></pre>
        <br/>
        <li>To compare maps, must iterate:</li>
<pre><code class="language-go line-numbers">func equalMaps(m1, m2 map[string]int) bool {
    if len(m1) != len(m2) {
        return false
    }

    for k, v1 := range m1 {
        if v2, ok := m2[k]; !ok || v1 != v2 {
            return false
        }
    }

    return true
}

m1 := map[string]int{"a": 1, "b": 2}
m2 := map[string]int{"a": 1, "b": 2}
m3 := map[string]int{"a": 1, "b": 3}

fmt.Println(equalMaps(m1, m2))  // true
fmt.Println(equalMaps(m1, m3))  // false</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-strings">Strings in Go</h3>
<ol>

    <li>What Are Strings in Go?</li>
    <br/>
    <ul>
        <li>A <code>string</code> in Go is a read-only sequence of bytes.</li>
        <br/>
        <li>Strings are <u>immutable</u> - once created, they cannot be modified.</li>
        <br/>
        <li>Strings are <u>UTF-8 encoded</u> by default, supporting Unicode characters.</li>
        <br/>
        <li>The zero value of a string is <code>""</code> (empty string).</li>
        <br/>
        <li>Basic string operations:</li>
<pre><code class="language-go line-numbers">// Declaration and initialization
var s1 string          // Zero value: ""
var s2 string = "Hello"
s3 := "World"

// Concatenation
greeting := s2 + " " + s3  // "Hello World"

// Length (number of bytes, not characters!)
length := len(greeting)    // 11

// Accessing bytes by index
first := greeting[0]       // 'H' (byte value: 72)
last := greeting[len(greeting)-1]  // 'd' (byte value: 100)</code></pre>
    </ul>
    <br/><br/>


    <li>String Literals</li>
    <br/>
    <ul>
        <li>Interpreted string literals (double quotes):</li>
<pre><code class="language-go line-numbers">// Use double quotes for interpreted strings
s := "Hello, World!"

// Escape sequences are processed
s1 := "Line 1\nLine 2"        // Newline
s2 := "Tab\there"             // Tab
s3 := "Quote: \"Hello\""      // Escaped quotes
s4 := "Path: C:\\Users\\Name" // Backslash
s5 := "Unicode: \u4e16\u754c" // Unicode code points (ä¸–ç•Œ)

fmt.Println(s1)
// Output:
// Line 1
// Line 2</code></pre>
        <br/>
        <li>Raw string literals (backticks):</li>
<pre><code class="language-go line-numbers">// Use backticks for raw strings
s := `Hello, World!`

// No escape sequences - everything literal
s1 := `Line 1\nLine 2`     // Contains literal \n
s2 := `Quote: "Hello"`     // No need to escape quotes
s3 := `Path: C:\Users\Name` // Backslashes are literal

// Multiline strings
s4 := `Line 1
Line 2
Line 3`

// Regular expressions (common use case)
regex := `^\d{3}-\d{3}-\d{4}$`  // Phone number pattern

fmt.Println(s1)
// Output: Line 1\nLine 2(literal backslash-n)</code></pre>
        <br/>
        <li><b>Common escape sequences:</b></li>
<table>
    <thead>
        <tr>
            <th>Escape</th>
            <th>Meaning</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>\n</code></td>
            <td>Newline</td>
            <td><code>"Line1\nLine2"</code></td>
        </tr>
        <tr>
            <td><code>\t</code></td>
            <td>Tab</td>
            <td><code>"Name:\tValue"</code></td>
        </tr>
        <tr>
            <td><code>\\</code></td>
            <td>Backslash</td>
            <td><code>"C:\\path"</code></td>
        </tr>
        <tr>
            <td><code>\"</code></td>
            <td>Double quote</td>
            <td><code>"He said \"Hi\""</code></td>
        </tr>
        <tr>
            <td><code>\'</code></td>
            <td>Single quote</td>
            <td><code>'\'x\''</code></td>
        </tr>
        <tr>
            <td><code>\r</code></td>
            <td>Carriage return</td>
            <td><code>"text\r\n"</code></td>
        </tr>
        <tr>
            <td><code>\uXXXX</code></td>
            <td>Unicode (4 hex digits)</td>
            <td><code>"\u4e16"</code> (ä¸–)</td>
        </tr>
        <tr>
            <td><code>\UXXXXXXXX</code></td>
            <td>Unicode (8 hex digits)</td>
            <td><code>"\U0001F600"</code> (ðŸ˜€)</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>String Immutability</li>
    <br/>
    <ul>
        <li>Strings in Go are <b>immutable</b> - you cannot modify their contents:</li>
<pre><code class="language-go line-numbers">s := "Hello"

// âŒ Cannot modify string bytes
// s[0] = 'h'  // Compile error: cannot assign to s[0]

// âœ“ Must create new string
s = "hello"  // Creates new string, reassigns variable

// String operations create new strings
s2 := s + " World"  // New string created
s3 := strings.ToUpper(s)  // New string created

// Original strings unchanged
fmt.Println(s)   // "hello"
fmt.Println(s2)  // "hello World"
fmt.Println(s3)  // "HELLO"</code></pre>
        <br/>
        <li><b>Why immutability matters:</b></li>
        <ul>
            <li>Strings can be safely shared between goroutines (no race conditions)</li>
            <li>Strings can be used as map keys (won't change unexpectedly)</li>
            <li>String values can be optimized by the compiler</li>
        </ul>
        <br/>
        <li><b>To modify strings, convert to []byte or use strings.Builder:</b></li>
<pre><code class="language-go line-numbers">s := "Hello"

// Method 1: Convert to []byte slice
bytes := []byte(s)
bytes[0] = 'h'
s = string(bytes)
fmt.Println(s)  // "hello"

// Method 2: Use strings.Builder for multiple modifications
var builder strings.Builder
builder.WriteString("Hello")
builder.WriteString(" ")
builder.WriteString("World")
s = builder.String()
fmt.Println(s)  // "Hello World"</code></pre>
    </ul>
    <br/><br/>


    <li>UTF-8 Encoding and Runes</li>
    <br/>
    <ul>
        <li>Go strings are UTF-8 encoded sequences of <code>byte</code>s.</li>
        <br/>
        <li>A <code>rune</code> is a Unicode code point (alias for <code>int32</code>).</li>
        <br/>
        <li>One character may use 1-4 bytes in UTF-8.</li>
        <br/>
        <li>Length vs character count:</li>
<pre><code class="language-go line-numbers">s1 := "Hello"
fmt.Println(len(s1))  // 5 bytes, 5 characters

s2 := "ä¸–ç•Œ"           // "World" in Chinese
fmt.Println(len(s2))  // 6 bytes (3 bytes per character)

// To count actual characters (runes), use utf8.RuneCountInString
import "unicode/utf8"

count := utf8.RuneCountInString(s2)
fmt.Println(count)  // 2 characters

// Or convert to []rune
runes := []rune(s2)
fmt.Println(len(runes))  // 2 characters</code></pre>
        <br/>
        <li>Rune literals (single quotes):</li>
<pre><code class="language-go line-numbers">// Single character in single quotes
var r1 rune = 'A'        // Unicode code point 65
var r2 rune = 'ä¸–'       // Unicode code point 19990
var r3 rune = '\n'       // Newline character
var r4 rune = '\u4e16'   // Unicode escape

fmt.Printf("%c %d\n", r1, r1)  // A 65
fmt.Printf("%c %d\n", r2, r2)  // ä¸– 19990

// Rune is int32
var i int32 = r1
fmt.Println(i)  // 65</code></pre>
        <br/>
        <li>Iterating over <code>rune</code>s vs <code>byte</code>s:</li>
<pre><code class="language-go line-numbers">s := "Helloä¸–ç•Œ"

// Iterate bytes (wrong for multi-byte characters!)
fmt.Println("Bytes:")
for i := 0; i < len(s); i++ {
    fmt.Printf("%d: %c (%d)\n", i, s[i], s[i])
}
// H, e, l, l, o, then garbage for multi-byte characters

// Iterate runes (correct!)
fmt.Println("\nRunes:")
for i, r := range s {
    fmt.Printf("%d: %c (%d)\n", i, r, r)
}
// Output:
// 0: H (72)
// 1: e (101)
// 2: l (108)
// 3: l (108)
// 4: o (111)
// 5: ä¸– (19990)
// 8: ç•Œ (30028)
// Note: indices jump (5 -> 8) because ä¸– takes 3 bytes</code></pre>
    </ul>
    <br/><br/>


    <li>String Indexing and Slicing</li>
    <br/>
    <ul>
        <li>Indexing returns bytes, not characters:</li>
<pre><code class="language-go line-numbers">s := "Hello"

// Access individual bytes
first := s[0]   // 'H' (byte value: 72)
second := s[1]  // 'e' (byte value: 101)

fmt.Printf("%c\n", first)   // H
fmt.Printf("%d\n", first)   // 72

// âŒ Index out of bounds panics
// last := s[100]  // panic: index out of range</code></pre>
        <br/>
        <li>Slicing creates substrings:</li>
<pre><code class="language-go line-numbers">s := "Hello, World!"

// Basic slicing
sub1 := s[0:5]    // "Hello" (index 0 to 4)
sub2 := s[7:12]   // "World"
sub3 := s[7:]     // "World!" (from 7 to end)
sub4 := s[:5]     // "Hello" (from start to 4)
sub5 := s[:]      // "Hello, World!" (entire string)

// Slicing is based on byte positions, not character positions!
s2 := "ä¸–ç•Œä½ å¥½"
bytes := s2[0:3]   // "ä¸–" (first character is 3 bytes)
// bytes := s2[0:2] would be invalid UTF-8!
</code></pre>
        <br/>
        <li>Safe substring extraction:</li>
<pre><code class="language-go line-numbers">// To extract first N characters (not bytes)
func firstNRunes(s string, n int) string {
    runes := []rune(s)
    if len(runes) &lt;= n {
        return s
    }
    return string(runes[:n])
}

s := "ä¸–ç•Œä½ å¥½"
fmt.Println(firstNRunes(s, 2))  // "ä¸–ç•Œ"

// Check bounds before slicing
func safeSlice(s string, start, end int) string {
    if start &lt; 0 || start &gt; len(s) || end &gt; len(s) || start &gt; end {
        return ""
    }
    return s[start:end]
}
</code></pre>
    </ul>
    <br/><br/>


    <li>String Concatenation</li>
    <br/>
    <ul>
        <li>Using <code>+</code> operator (simple cases):</li>
<pre><code class="language-go line-numbers">// Simple concatenation
s1 := "Hello"
s2 := "World"
result := s1 + " " + s2  // "Hello World"

// Multiple concatenations
path := "home" + "/" + "user" + "/" + "documents"

// Note: Each + creates a new string (inefficient for many concatenations)
</code></pre>
        <br/>
        <li>Using <code>fmt.Sprintf</code> (formatting):</li>
<pre><code class="language-go line-numbers">name := "Alice"
age := 30

// Format string with values
s := fmt.Sprintf("Name: %s, Age: %d", name, age)
fmt.Println(s)      // "Name: Alice, Age: 30"

// Complex formatting
price := 19.99
s2 := fmt.Sprintf("Price: $%.2f", price)
fmt.Println(s2)     // "Price: $19.99"
</code></pre>
        <br/>
        <li>Using <code>strings.Join</code> (slices):</li>
<pre><code class="language-go line-numbers">import "strings"

// Join slice of strings
words := []string{"Go", "is", "awesome"}
sentence := strings.Join(words, " ")
fmt.Println(sentence)   // "Go is awesome"

// Join with different separator
csv := strings.Join([]string{"a", "b", "c"}, ",")
fmt.Println(csv)        // "a,b,c"
</code></pre>
        <br/>
        <li>Using <code>strings.Builder</code> (efficient for many concatenations):</li>
<pre><code class="language-go line-numbers">import "strings"

// Efficient string building
var builder strings.Builder

builder.WriteString("Hello")
builder.WriteString(" ")
builder.WriteString("World")
builder.WriteByte('!')

result := builder.String()
fmt.Println(result)  // "Hello World!"

// Builder in a loop (much more efficient than +)
var b strings.Builder
for i := 0; i &lt; 1000; i++ {
    b.WriteString("Line ")
    b.WriteString(fmt.Sprintf("%d\n", i))
}
output := b.String()
</code></pre>
        <br/>
        <li>Performance comparison:</li>
<pre><code class="language-go line-numbers">// âŒ Slow: Creates many intermediate strings
func buildStringSlow(n int) string {
    s := ""
    for i := 0; i &lt; n; i++ {
        s += "x"  // Creates new string each iteration
    }
    return s
}

// âœ“ Fast: Efficient memory usage
func buildStringFast(n int) string {
    var builder strings.Builder
    builder.Grow(n)  // Pre-allocate capacity
    for i := 0; i &lt; n; i++ {
        builder.WriteByte('x')
    }
    return builder.String()
}

// For n=10000:
// buildStringSlow: ~50ms
// buildStringFast: ~0.1ms
</code></pre>
    </ul>
    <br/><br/>


    <li>Common String Operations (strings package)</li>
    <br/>
    <ul>
        <li>Checking string contents:</li>
<pre><code class="language-go line-numbers">import "strings"

s := "Hello, World!"

// Check prefix/suffix
hasPrefix := strings.HasPrefix(s, "Hello")  // true
hasSuffix := strings.HasSuffix(s, "!")      // true

// Check if contains substring
contains := strings.Contains(s, "World")    // true

// Count occurrences
count := strings.Count(s, "l")              // 3
count2 := strings.Count(s, "ll")            // 1</code></pre>
        <br/>
        <li>Finding substrings:</li>
<pre><code class="language-go line-numbers">s := "Hello, World!"

// Find first occurrence (returns index, or -1)
index := strings.Index(s, "World")     // 7
index2 := strings.Index(s, "xyz")      // -1

// Find last occurrence
lastIndex := strings.LastIndex(s, "o") // 8

// Find any character from set
index3 := strings.IndexAny(s, "aeiou") // 1 (first vowel 'e')</code></pre>
        <br/>
        <li>Case conversion:</li>
<pre><code class="language-go line-numbers">s := "Hello, World!"

upper := strings.ToUpper(s)  // "HELLO, WORLD!"
lower := strings.ToLower(s)  // "hello, world!"
title := strings.Title(s)    // "Hello, World!" (deprecated in Go 1.18)

// Title case with unicode
import "golang.org/x/text/cases"
import "golang.org/x/text/language"

caser := cases.Title(language.English)
title2 := caser.String("hello world")  // "Hello World"</code></pre>
        <br/>
        <li>Trimming whitespace and characters:</li>
<pre><code class="language-go line-numbers">// Trim whitespace
s1 := "  Hello  "
trimmed := strings.TrimSpace(s1)  // "Hello"

// Trim specific characters
s2 := "!!!Hello!!!"
trimmed2 := strings.Trim(s2, "!")       // "Hello"
trimmed3 := strings.TrimLeft(s2, "!")   // "Hello!!!"
trimmed4 := strings.TrimRight(s2, "!")  // "!!!Hello"

// Trim prefix/suffix
s3 := "Hello, World!"
trimmed5 := strings.TrimPrefix(s3, "Hello, ")  // "World!"
trimmed6 := strings.TrimSuffix(s3, "!")        // "Hello, World"</code></pre>
        <br/>
        <li>Splitting and joining:</li>
<pre><code class="language-go line-numbers">// Split by separator
s := "apple,banana,cherry"
fruits := strings.Split(s, ",")
// []string{"apple", "banana", "cherry"}

// Split with limit
s2 := "a:b:c:d"
parts := strings.SplitN(s2, ":", 2)
// []string{"a", "b:c:d"}

// Split on whitespace
s3 := "one  two   three"
words := strings.Fields(s3)
// []string{"one", "two", "three"}

// Join
joined := strings.Join(fruits, " | ")
// "apple | banana | cherry"</code></pre>
        <br/>
        <li>Replacing:</li>
<pre><code class="language-go line-numbers">s := "Hello World, World!"

// Replace all occurrences
s1 := strings.Replace(s, "World", "Go", -1)
// "Hello Go, Go!"

// Replace limited number
s2 := strings.Replace(s, "World", "Go", 1)
// "Hello Go, World!"

// ReplaceAll (convenience, same as Replace with -1)
s3 := strings.ReplaceAll(s, "World", "Go")
// "Hello Go, Go!"</code></pre>
        <br/>
        <li>Repeating:</li>
<pre><code class="language-go line-numbers">// Repeat string n times
line := strings.Repeat("-", 20)  // "--------------------"
laugh := strings.Repeat("ha", 3)  // "hahaha"</code></pre>
    </ul>
    <br/><br/>


    <li>String Comparison</li>
    <br/>
    <ul>
        <li>Using <code>==</code> and <code>!=</code> operators:</li>
<pre><code class="language-go line-numbers">s1 := "hello"
s2 := "hello"
s3 := "Hello"

// Exact comparison
fmt.Println(s1 == s2)  // true
fmt.Println(s1 == s3)  // false (case-sensitive)
fmt.Println(s1 != s3)  // true</code></pre>
        <br/>
        <li>Using <code>strings.EqualFold</code> (case-insensitive):</li>
<pre><code class="language-go line-numbers">s1 := "hello"
s2 := "HELLO"
s3 := "Hello"

equal := strings.EqualFold(s1, s2)  // true
equal2 := strings.EqualFold(s1, s3) // true</code></pre>
        <br/>
        <li>Comparing order (lexicographic):</li>
<pre><code class="language-go line-numbers">s1 := "apple"
s2 := "banana"

// s1 &lt; s2 lexicographically
if s1 &lt; s2 {
    fmt.Println("apple comes before banana")
}

// Use strings.Compare for explicit comparison
result := strings.Compare(s1, s2)
// result &lt; 0 if s1 &lt; s2
// result == 0 if s1 == s2
// result &gt; 0 if s1 &gt; s2

fmt.Println(strings.Compare("a", "b"))  // -1
fmt.Println(strings.Compare("b", "a"))  // 1
fmt.Println(strings.Compare("a", "a"))  // 0
</code></pre>
    </ul>
    <br/><br/>


    <li>Converting Between string, []byte, and []rune</li>
    <br/>
    <ul>
        <li>String to <code>[]byte</code>:</li>
<pre><code class="language-go line-numbers">s := "Hello"

// Convert to byte slice
bytes := []byte(s)
fmt.Printf("%v\n", bytes)  // [72 101 108 108 111]

// Modify bytes
bytes[0] = 'h'
s2 := string(bytes)
fmt.Println(s2)  // "hello"

// Note: Conversion makes a copy
fmt.Println(s)  // "Hello" (original unchanged)</code></pre>
        <br/>
        <li>String to <code>[]rune</code>:</li>
<pre><code class="language-go line-numbers">s := "Helloä¸–ç•Œ"

// Convert to rune slice
runes := []rune(s)
fmt.Printf("%v\n", runes)  // [72 101 108 108 111 19990 30028]

// Access individual characters
fmt.Printf("%c\n", runes[5])  // ä¸–
fmt.Printf("%c\n", runes[6])  // ç•Œ

// Modify runes
runes[0] = 'h'
s2 := string(runes)
fmt.Println(s2)  // "helloä¸–ç•Œ"</code></pre>
        <br/>
        <li>[]byte to string:</li>
<pre><code class="language-go line-numbers">bytes := []byte{72, 101, 108, 108, 111}

// Convert to string
s := string(bytes)
fmt.Println(s)  // "Hello"</code></pre>
        <br/>
        <li>[]rune to string:</li>
<pre><code class="language-go line-numbers">runes := []rune{72, 101, 108, 108, 111}

// Convert to string
s := string(runes)
fmt.Println(s)  // "Hello"</code></pre>
        <br/>
        <li>Performance note:</li>
<pre><code class="language-go line-numbers">// string <-> []byte conversion makes a copy
s := "Hello"
b := []byte(s)    // Allocates new slice, copies data
s2 := string(b)   // Allocates new string, copies data

// For read-only operations, consider keeping as string
// For many modifications, work with []byte then convert once</code></pre>
    </ul>
    <br/><br/>


    <li>Iterating Over Strings</li>
    <br/>
    <ul>
        <li>Range loop (iterates over <code>rune</code>s):</li>
<pre><code class="language-go line-numbers">s := "Helloä¸–ç•Œ"

// Range automatically decodes UTF-8 to runes
for i, r := range s {
    fmt.Printf("%d: %c (U+%04X)\n", i, r, r)
}

// Output:
// 0: H (U+0048)
// 1: e (U+0065)
// 2: l (U+006C)
// 3: l (U+006C)
// 4: o (U+006F)
// 5: ä¸– (U+4E16)
// 8: ç•Œ (U+754C)

// Note: Index jumps from 5 to 8 (ä¸– takes 3 bytes)</code></pre>
        <br/>
        <li>Index loop (iterates over <code>byte</code>s):</li>
<pre><code class="language-go line-numbers">s := "Hello"

// Loop through byte indices
for i := 0; i &lt; len(s); i++ {
    fmt.Printf("%d: %c (%d)\n", i, s[i], s[i])
}

// âŒ Don't use this for multi-byte characters!
s2 := "ä¸–ç•Œ"
for i := 0; i &lt; len(s2); i++ {
    fmt.Printf("%c ", s2[i])  // Prints garbage
}
</code></pre>
        <br/>
        <li>Using <code>strings.Reader</code>:</li>
<pre><code class="language-go line-numbers">import "strings"

s := "Hello"
reader := strings.NewReader(s)

// Read rune by rune
for {
    r, size, err := reader.ReadRune()
    if err != nil {
        break
    }
    fmt.Printf("%c (size: %d bytes)\n", r, size)
}</code></pre>
    </ul>
    <br/><br/>


    <li>String Formatting with fmt</li>
    <br/>
    <ul>
        <li>Common format verbs:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Verb</th>
            <th>Description</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>%s</code></td>
            <td>String</td>
            <td><code>fmt.Printf("%s", "hello")</code></td>
        </tr>
        <tr>
            <td><code>%q</code></td>
            <td>Quoted string</td>
            <td><code>fmt.Printf("%q", "hello")</code> â†’ <code>"hello"</code></td>
        </tr>
        <tr>
            <td><code>%x</code></td>
            <td>Hex bytes</td>
            <td><code>fmt.Printf("%x", "hi")</code> â†’ <code>6869</code></td>
        </tr>
        <tr>
            <td><code>%X</code></td>
            <td>Hex bytes (uppercase)</td>
            <td><code>fmt.Printf("%X", "hi")</code> â†’ <code>6869</code></td>
        </tr>
        <tr>
            <td><code>%#x</code></td>
            <td>Hex bytes with spaces</td>
            <td><code>fmt.Printf("%#x", "hi")</code> â†’ <code>68 69</code></td>
        </tr>
        <tr>
            <td><code>%v</code></td>
            <td>Default format</td>
            <td><code>fmt.Printf("%v", "hello")</code></td>
        </tr>
        <tr>
            <td><code>%+v</code></td>
            <td>Value with field names</td>
            <td>For structs</td>
        </tr>
        <tr>
            <td><code>%#v</code></td>
            <td>Go syntax representation</td>
            <td><code>fmt.Printf("%#v", "hello")</code> â†’ <code>"hello"</code></td>
        </tr>
        <tr>
            <td><code>%T</code></td>
            <td>Type</td>
            <td><code>fmt.Printf("%T", "hello")</code> â†’ <code>string</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Width and precision:</li>
<pre><code class="language-go line-numbers">name := "Alice"

// Width (minimum width)
fmt.Printf("|%10s|\n", name)   // |     Alice|
fmt.Printf("|%-10s|\n", name)  // |Alice     | (left-aligned)

// Precision (maximum width)
fmt.Printf("%.3s\n", name)      // Ali

// Both
fmt.Printf("|%10.3s|\n", name)  // |       Ali|</code></pre>
        <br/>
        <li>Sprintf vs Printf vs Print:</li>
<pre><code class="language-go line-numbers">name := "Alice"
age := 30

// Printf: prints to stdout
fmt.Printf("Name: %s, Age: %d\n", name, age)

// Sprintf: returns string
s := fmt.Sprintf("Name: %s, Age: %d", name, age)

// Print: simple printing (no formatting)
fmt.Print("Hello ", "World\n")

// Println: adds spaces and newline
fmt.Println("Hello", "World")  // "Hello World\n"</code></pre>
    </ul>
    <br/><br/>


    <li>Regular Expressions with Strings</li>
    <br/>
    <ul>
        <li>Basic regex matching:</li>
<pre><code class="language-go line-numbers">import "regexp"

// Compile pattern
pattern := `^\d{3}-\d{3}-\d{4}$`  // Phone: 123-456-7890
re := regexp.MustCompile(pattern)

// Test if matches
matched := re.MatchString("123-456-7890")
fmt.Println(matched)  // true

matched2 := re.MatchString("invalid")
fmt.Println(matched2)  // false</code></pre>
        <br/>
        <li>Finding matches:</li>
<pre><code class="language-go line-numbers">s := "Contact: alice@example.com or bob@test.com"

// Find email addresses
re := regexp.MustCompile(`\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b`)

// Find first match
first := re.FindString(s)
fmt.Println(first)  // "alice@example.com"

// Find all matches
all := re.FindAllString(s, -1)
fmt.Println(all)  // ["alice@example.com", "bob@test.com"]</code></pre>
        <br/>
        <li>Replacing with regex:</li>
<pre><code class="language-go line-numbers">s := "Price: $19.99, Cost: $5.00"

// Replace all dollar amounts
re := regexp.MustCompile(`\$\d+\.\d+`)
replaced := re.ReplaceAllString(s, "XXX")
fmt.Println(replaced)  // "Price: XXX, Cost: XXX"

// Replace with function
re2 := regexp.MustCompile(`\d+`)
result := re2.ReplaceAllStringFunc("The year is 2024", func(match string) string {
    return "[" + match + "]"
})
fmt.Println(result)  // "The year is [2024]"</code></pre>
    </ul>
    <br/><br/>


    <li>String Performance Tips</li>
    <br/>
    <ul>
        <li>Tip 1: Use <code>strings.Builder</code> for concatenation in loops</li>
<pre><code class="language-go line-numbers">// âŒ Slow: O(nÂ²) complexity
func buildSlow(words []string) string {
    result := ""
    for _, word := range words {
        result += word + " "
    }
    return result
}

// âœ“ Fast: O(n) complexity
func buildFast(words []string) string {
    var b strings.Builder
    for _, word := range words {
        b.WriteString(word)
        b.WriteString(" ")
    }
    return b.String()
}</code></pre>
        <br/>
        <li>Tip 2: Use <code>strings.Join</code> for slices</li>
<pre><code class="language-go line-numbers">words := []string{"Go", "is", "fast"}

// âœ“ Efficient
result := strings.Join(words, " ")

// Less efficient
result2 := words[0] + " " + words[1] + " " + words[2]</code></pre>
        <br/>
        <li>Tip 3: Avoid unnecessary conversions</li>
<pre><code class="language-go line-numbers">s := "Hello"

// âŒ Unnecessary conversions
bytes := []byte(s)
s2 := string(bytes)

// âœ“ Keep as string if possible
// Only convert when you need to modify</code></pre>
        <br/>
        <li>Tip 4: Pre-allocate Builder capacity</li>
<pre><code class="language-go line-numbers">// If you know approximate size
var b strings.Builder
b.Grow(1000)  // Pre-allocate for ~1000 bytes

for i := 0; i &lt; 100; i++ {
    b.WriteString("Line\n")
}
result := b.String()</code></pre>
        <br/>
        <li>Tip 5: Reuse <code>strings.Builder</code></li>
<pre><code class="language-go line-numbers">var b strings.Builder

for i := 0; i &lt; 10; i++ {
    b.Reset()  // Reuse the builder

    b.WriteString("Iteration ")
    b.WriteString(fmt.Sprintf("%d", i))

    result := b.String()
    fmt.Println(result)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Common Mistakes and How to Avoid Them</li>
    <br/>
    <ul>
        <li>Mistake 1: Confusing byte length with character count</li>
<pre><code class="language-go line-numbers">s := "ä¸–ç•Œ"

// âŒ Wrong: Returns byte length
fmt.Println(len(s))  // 6 (not 2!)

// âœ“ Correct: Count runes
fmt.Println(utf8.RuneCountInString(s))  // 2
fmt.Println(len([]rune(s)))             // 2</code></pre>
        <br/>
        <li>Mistake 2: Modifying strings by index</li>
<pre><code class="language-go line-numbers">s := "Hello"

// âŒ Error: cannot assign
// s[0] = 'h'

// âœ“ Convert to []byte or []rune
bytes := []byte(s)
bytes[0] = 'h'
s = string(bytes)</code></pre>
        <br/>
        <li>Mistake 3: Slicing multi-byte characters</li>
<pre><code class="language-go line-numbers">s := "ä¸–ç•Œ"

// âŒ Wrong: Cuts in middle of character
// invalid := s[0:2]  // Invalid UTF-8!

// âœ“ Correct: Work with runes
runes := []rune(s)
first := string(runes[0:1])  // "ä¸–"</code></pre>
        <br/>
        <li>Mistake 4: Using + for many concatenations</li>
<pre><code class="language-go line-numbers">// âŒ Slow for large n
result := ""
for i := 0; i &lt; 10000; i++ {
    result += "x"
}

// âœ“ Use strings.Builder
var b strings.Builder
for i := 0; i &lt; 10000; i++ {
    b.WriteString("x")
}
result := b.String()
</code></pre>
        <br/>
        <li>Mistake 5: Not checking for empty string before indexing</li>
<pre><code class="language-go line-numbers">func getFirst(s string) byte {
    // âŒ Panics if s is empty
    // return s[0]

    // âœ“ Check length first
    if len(s) == 0 {
        return 0
    }
    return s[0]
}</code></pre>
        <br/>
        <li>Mistake 6: Iterating bytes for multi-byte strings</li>
<pre><code class="language-go line-numbers">s := "Helloä¸–ç•Œ"

// âŒ Wrong: Iterates bytes, breaks multi-byte chars
for i := 0; i &lt; len(s); i++ {
    fmt.Printf("%c ", s[i])  // Prints garbage for ä¸–ç•Œ
}

// âœ“ Correct: Use range (iterates runes)
for _, r := range s {
    fmt.Printf("%c ", r)  // Prints all characters correctly
}
</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-pointers">Pointers in Go</h3>
<ol>
    <li>Pointer Syntax</li>
    <br/>
    <ul>
        <li>Declaring pointer variables:</li>
<pre><code class="language-go line-numbers">var x int = 42

// Declare pointer to int
var p *int      // p is nil (zero value of pointer)

// Assign address to pointer
p = &amp;x          // Now p points to x

// Declare and initialize
p2 := &amp;x        // Type inferred as *int
</code></pre>
        <br/>
        <li>Pointer type notation:</li>
<pre><code class="language-go line-numbers">var p1 *int        // Pointer to int
var p2 *string     // Pointer to string
var p3 *bool       // Pointer to bool
var p4 *[]int      // Pointer to slice of ints
var p5 *MyStruct   // Pointer to struct
</code></pre>
        <br/>
        <li>The <code>&amp;</code> operator (address-of):</li>
<pre><code class="language-go line-numbers">x := 100
p := &amp;x                                 // Get address of x

fmt.Printf("x = %d\n", x)               // x = 100
fmt.Printf("address of x = %p\n", p)    // address of x = 0xc000012028
</code></pre>
        <br/>
        <li>The <code>*</code> operator (dereference):</li>
<pre><code class="language-go line-numbers">x := 100
p := &amp;x

// Read value through pointer
value := *p     // value = 100

// Modify value through pointer
*p = 200        // Changes x to 200

fmt.Println(x)  // 200 (x was modified!)
fmt.Println(*p) // 200</code></pre>
    </ul>
    <br/><br/>


    <li>Pointers and Functions</li>
    <br/>
    <ul>
        <li>Pass by value (default in Go):</li>
<pre><code class="language-go line-numbers">func modify(x int) {
    x = 100  // Modifies local copy only
}

func main() {
    num := 10
    modify(num)
    fmt.Println(num)  // 10 (unchanged)
}</code></pre>
        <br/>
        <li>Pass by pointer (to modify original):</li>
<pre><code class="language-go line-numbers">func modify(x *int) {
    *x = 100  // Modifies original value
}

func main() {
    num := 10
    modify(&amp;num)
    fmt.Println(num)  // 100 (changed!)
}</code></pre>
        <br/>
        <li>Returning pointers:</li>
<pre><code class="language-go line-numbers">func createPerson(name string, age int) *Person {
    p := Person{
        Name: name,
        Age:  age,
    }
    return &amp;p  // âœ“ Safe in Go (p survives beyond function)
}

func main() {
    person := createPerson("Alice", 30)
    fmt.Printf("%+v\n", person)  // &amp;{Name:Alice Age:30}
}
</code></pre>
    </ul>
    <br/><br/>


    <li>Pointers and Structs</li>
    <br/>
    <ul>
        <li>Accessing struct fields through pointers:</li>
<pre><code class="language-go line-numbers">type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Alice", Age: 30}
    ptr := &amp;p

    // Go automatically dereferences
    fmt.Println(ptr.Name)       // "Alice" (Go does: (*ptr).Name)

    // Both syntaxes work
    fmt.Println((*ptr).Name)    // "Alice" (explicit)
    fmt.Println(ptr.Name)       // "Alice" (automatic)

    // Modify through pointer
    ptr.Age = 31
    fmt.Println(p.Age)  // 31 (original modified)
}
</code></pre>
        <br/>
        <li>Methods with pointer receivers:</li>
<pre><code class="language-go line-numbers">type Counter struct {
    count int
}

// Pointer receiver - can modify
func (c *Counter) Increment() {
    c.count++
}

// Value receiver - cannot modify original
func (c Counter) IncrementBad() {
    c.count++  // Modifies copy, not original
}

func main() {
    c := Counter{}

    c.Increment()
    c.Increment()
    fmt.Println(c.count)  // 2

    c.IncrementBad()
    fmt.Println(c.count)  // 2 (unchanged)
}
</code></pre>
        <br/>
        <li>Creating struct pointers:</li>
<pre><code class="language-go line-numbers">// Method 1: Create value, then take address
p1 := Person{Name: "Alice", Age: 30}
ptr1 := &amp;p1

// Method 2: Use &amp; with literal
ptr2 := &amp;Person{Name: "Bob", Age: 25}

// Method 3: Use new (creates zero-valued struct)
ptr3 := new(Person)  // &amp;Person{Name: "", Age: 0}
ptr3.Name = "Carol"
ptr3.Age = 28</code></pre>
    </ul>
    <br/><br/>


    <li>Nil Pointers</li>
    <br/>
    <ul>
        <li>The zero value of a pointer is <code>nil</code> (doesn't point to anything).</li>
        <br/>
        <li>Checking for <code>nil</code>:</li>
<pre><code class="language-go line-numbers">var p *int      // p is nil

if p == nil {
    fmt.Println("Pointer is nil")
}

// Assign address
x := 42
p = &amp;x

if p != nil {
    fmt.Println("Pointer is not nil")
    fmt.Println(*p)  // 42
}</code></pre>
        <br/>
        <li>Dereferencing <code>nil</code> pointer causes panic:</li>
<pre><code class="language-go line-numbers">var p *int      // nil pointer

// âŒ Panic: runtime error
// value := *p

// âœ“ Always check before dereferencing
if p != nil {
    value := *p
    fmt.Println(value)
}</code></pre>
        <br/>
        <li>Safe <code>struct</code> field access:</li>
<pre><code class="language-go line-numbers">type Person struct {
    Name string
    Age  int
}

var p *Person  // nil

// âŒ Panic
// name := p.Name

// âœ“ Check first
if p != nil {
    name := p.Name
    fmt.Println(name)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Pointers and Arrays vs Slices</li>
    <br/>
    <ul>
        <li>Arrays are copied:</li>
<pre><code class="language-go line-numbers">func modifyArray(arr [3]int) {
    arr[0] = 100  // Modifies copy
}

func modifyArrayPtr(arr *[3]int) {
    arr[0] = 100  // Modifies original
}

func main() {
    arr := [3]int{1, 2, 3}

    modifyArray(arr)
    fmt.Println(arr)  // [1 2 3] (unchanged)

    modifyArrayPtr(&amp;arr)
    fmt.Println(arr)  // [100 2 3] (changed)
}</code></pre>
        <br/>
        <li>Slices are already references (don't need pointers):</li>
<pre><code class="language-go line-numbers">func modifySlice(s []int) {
    s[0] = 100  // Modifies original (slice is reference type)
}

func main() {
    slice := []int{1, 2, 3}

    modifySlice(slice)
    fmt.Println(slice)  // [100 2 3] (changed!)

    // Usually don't need *[]int
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
