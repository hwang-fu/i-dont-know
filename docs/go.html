<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>golang</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 38px;
        height: 38px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "æ¥·ä½“", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "æ¥·ä½“", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .05rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.775rem;
        line-height: 1.1;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <h2> <img src="resources/golang.png" alt="Logo" class="nav-icon"/></h2>
    <ol style="line-height: 1.8;">
        <li><a href="#go-introduction">Introduction to Golang</a></li>
        <li><a href="#go-hello-world">Hello World</a></li>
        <li><a href="#go-variables">Variables and Data Types</a></li>
        <li><a href="#go-functions">Functions</a></li>
        <li><a href="#go-packages">Packages</a></li>
        <li><a href="#go-control-flow">Control Flow</a></li>
    </ol>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-introduction">Introduction to Golang</h3>
<ol>

    <li>What Is Go (Golang)?</li>
    <br/>
    <ul>
        <li><b>Go</b> (also known as <b>Golang</b>) is a statically typed, compiled programming language designed at Google.</li>
        <br/>
        <li>The name "Golang" comes from the domain name <code>golang.org</code> (to make it more searchable).</li>
    </ul>
    <br/><br/>

    <li>Go favors <b>composition over inheritance</b> and <b>explicit over implicit</b> behavior.</li>
    <br/><br/>


    <li>Key Features of Go</li>
    <br/>
    <ul>
        <li><b>Static Typing:</b> Variables have types known at compile time, catching errors early.</li>
        <br/>
        <li><b>Fast Compilation:</b> Go compiles directly to machine code extremely quickly.</li>
        <br/>
        <li><b>Goroutines:</b> Lightweight threads that enable easy concurrent programming.</li>
        <br/>
        <li><b>Channels:</b> Built-in primitives for safe communication between goroutines.</li>
        <br/>
        <li><b>Garbage Collection:</b> Automatic memory management without manual allocation/deallocation.</li>
        <br/>
        <li><b>Standard Library:</b> Rich, comprehensive standard library for networking, I/O, cryptography, and more.</li>
        <br/>
        <li><b>Cross-Platform:</b> Compiles to native binaries for Windows, Linux, macOS, and many other platforms.</li>
        <br/>
        <li><b>Built-in Tooling:</b> Includes formatter, linter, testing framework, package manager, and documentation generator.</li>
        <br/>
        <li><b>No Generics (until Go 1.18):</b> Originally designed without generics for simplicity, added in 2022.</li>
    </ul>
    <br/><br/>


    <li>Setting Up Your First Go Project</li>
    <br/>
    <ul>
        <li>Create a project directory:</li>
<pre><code class="language-bash line-numbers">mkdir hello-go
cd hello-go</code></pre>
        <br/>
        <li>Initialize a Go module:</li>
<pre><code class="language-bash line-numbers">go mod init example.com/hello</code></pre>
        <br/>
        <li>This creates a <code>go.mod</code> file that tracks dependencies.</li>
        <br/>
        <li>Go modules are the standard way to manage dependencies since Go 1.11.</li>
    </ul>
    <br/><br/>


    <li>Hello World in Go</li>
    <br/>
    <ul>
        <li>Create a file named <code>main.go</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre>
        <ul>
            <li><code>package main</code> declares this as an executable program</li>
            <li><code>import "fmt"</code> imports the format/print package</li>
            <li><code>func main()</code> is the entry point of the program</li>
            <li><code>fmt.Println()</code> prints text to the console</li>
        </ul>
        <br/>
        <li>Run the program:</li>
<pre><code class="language-bash line-numbers">go run main.go</code></pre>
        <br/>
        <li>Build an executable:</li>
<pre><code class="language-bash line-numbers">go build main.go
./main</code></pre>
    </ul>
    <br/><br/>


    <li>Basic Go Syntax Overview</li>
    <br/>
    <ul>
        <li><b>Variable Declaration:</b></li>
<pre><code class="language-go line-numbers">var name string = "Junzhe"
age := 30  // Short declaration with type inference</code></pre>
        <br/>
        <li><b>Constants:</b></li>
<pre><code class="language-go line-numbers">const Pi = 3.14159</code></pre>
        <br/>
        <li><b>Functions:</b></li>
<pre><code class="language-go line-numbers">func add(x int, y int) int {
    return x + y
}</code></pre>
        <br/>
        <li><b>Control Structures:</b></li>
<pre><code class="language-go line-numbers">if x > 10 {
    fmt.Println("x is large")
}

for i := 0; i < 5; i++ {
    fmt.Println(i)
}

switch day {
case "Monday":
    fmt.Println("Start of week")
default:
    fmt.Println("Other day")
}</code></pre>
        <br/>
        <li>Note: Go has no <code>while</code> loop, <code>for</code> is used for all loops.</li>
    </ul>
    <br/><br/>


    <li>Go's Type System</li>
    <br/>
    <ul>
        <li>Basic types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Category</th>
            <th>Types</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Boolean</b></td>
            <td><code>bool</code></td>
        </tr>
        <tr>
            <td><b>String</b></td>
            <td><code>string</code></td>
        </tr>
        <tr>
            <td><b>Integer</b></td>
            <td>
                <code>int</code>, <code>int8</code>,
                <code>int16</code>, <code>int32</code>,
                <code>int64</code>, <code>uint</code>,
                <code>uint8</code>, <code>uint16</code>,
                <code>uint32</code>, <code>uint64</code>
            </td>
        </tr>
        <tr>
            <td><b>Float</b></td>
            <td><code>float32</code>, <code>float64</code></td>
        </tr>
        <tr>
            <td><b>Complex</b></td>
            <td><code>complex64</code>, <code>complex128</code></td>
        </tr>
        <tr>
            <td><b>Byte</b></td>
            <td><code>byte</code> (alias for <code>uint8</code>)</td>
        </tr>
        <tr>
            <td><b>Rune</b></td>
            <td><code>rune</code> (alias for <code>int32</code>, represents Unicode code point)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Composite types:
            <ul>
                <li>Arrays: <code>[5]int</code></li>
                <li>Slices: <code>[]int</code></li>
                <li>Maps: <code>map[string]int</code></li>
                <li>Structs: <code>type Person struct { Name string; Age int }</code></li>
                <li>Pointers: <code>*int</code></li>
                <li>Interfaces: <code>interface{}</code></li>
                <li>Channels: <code>chan int</code></li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Concurrency: Goroutines and Channels</li>
    <br/>
    <ul>
        <li><b>Goroutines</b> are lightweight threads managed by the Go runtime.</li>
        <br/>
        <li>Starting a goroutine:</li>
<pre><code class="language-go line-numbers">go myFunction()  // Runs concurrently

go func() {
    fmt.Println("Anonymous goroutine")
}()</code></pre>
        <br/>
        <li><b>Channels</b> enable safe communication between goroutines:</li>
<pre><code class="language-go line-numbers">ch := make(chan int)

go func() {
    ch <- 42  // Send value to channel
}()

value := <-ch  // Receive value from channel
fmt.Println(value)</code></pre>
        <br/>
        <li>This model follows the philosophy: <b>"Don't communicate by sharing memory, share memory by communicating."</b></li>
    </ul>
    <br/><br/>


    <li>Go's Standard Library</li>
    <br/>
    <ul>
        <li>Go includes a powerful standard library for common tasks:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fmt</code></td>
            <td>Formatted I/O (printing, scanning)</td>
        </tr>
        <tr>
            <td><code>net/http</code></td>
            <td>HTTP client and server</td>
        </tr>
        <tr>
            <td><code>encoding/json</code></td>
            <td>JSON encoding and decoding</td>
        </tr>
        <tr>
            <td><code>io</code></td>
            <td>Basic I/O primitives</td>
        </tr>
        <tr>
            <td><code>os</code></td>
            <td>Operating system functionality</td>
        </tr>
        <tr>
            <td><code>time</code></td>
            <td>Time and duration handling</td>
        </tr>
        <tr>
            <td><code>strings</code></td>
            <td>String manipulation</td>
        </tr>
        <tr>
            <td><code>testing</code></td>
            <td>Automated testing support</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Standard library documentation:</li>
<pre><code class="language-plaintext line-numbers">https://pkg.go.dev/std</code></pre>
    </ul>
    <br/><br/>


    <li>Built-in Tooling</li>
    <br/>
    <ul>
        <li>Go provides excellent tools out of the box:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>go build</code></td>
            <td>Compile packages and dependencies</td>
        </tr>
        <tr>
            <td><code>go run</code></td>
            <td>Compile and run Go program</td>
        </tr>
        <tr>
            <td><code>go test</code></td>
            <td>Run tests</td>
        </tr>
        <tr>
            <td><code>go fmt</code></td>
            <td>Format Go source code</td>
        </tr>
        <tr>
            <td><code>go get</code></td>
            <td>Download and install packages</td>
        </tr>
        <tr>
            <td><code>go mod</code></td>
            <td>Module maintenance</td>
        </tr>
        <tr>
            <td><code>go doc</code></td>
            <td>Show documentation</td>
        </tr>
        <tr>
            <td><code>go vet</code></td>
            <td>Examine code for suspicious constructs</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example usage:</li>
<pre><code class="language-bash line-numbers">go fmt ./...        # Format all files in project
go test ./...       # Run all tests
go vet ./...        # Check for issues</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-hello-world">Your First Go Program</h3>
<ol>

    <li>Creating the Hello World Program</li>
    <br/>
    <ul>
        <li>Create a new directory for your project:</li>
<pre><code class="language-bash line-numbers">mkdir hello-world
cd hello-world</code></pre>
        <br/>
        <li>Initialize a Go module:</li>
<pre><code class="language-bash line-numbers">go mod init example.com/hello</code></pre>
        <br/>
        <li>This creates a <code>go.mod</code> file that defines your module's path and dependencies.</li>
        <br/>
        <li>Create a file named <code>main.go</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre>
        <br/>
        <li>This is the simplest complete Go program.</li>
    </ul>
    <br/><br/>


    <li>Understanding the Program Structure</li>
    <br/>
    <ul>
        <li>Every Go program is organized into packages.</li>
        <br/>
        <li>Line-by-line explanation:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Line</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>package main</code></td>
            <td>Declares this file belongs to the <code>main</code> package, which creates an executable program</td>
        </tr>
        <tr>
            <td><code>import "fmt"</code></td>
            <td>Imports the <code>fmt</code> package for formatted I/O operations</td>
        </tr>
        <tr>
            <td><code>func main()</code></td>
            <td>Defines the <code>main</code> function, the entry point of the program</td>
        </tr>
        <tr>
            <td><code>fmt.Println(...)</code></td>
            <td>Calls the <code>Println</code> function from the <code>fmt</code> package to print text</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The <code>main</code> package is special: it tells the Go compiler to create an executable rather than a library.</li>
        <br/>
        <li>The <code>main()</code> function is automatically called when the program starts.</li>
    </ul>
    <br/><br/>


    <li>Running the Program</li>
    <br/>
    <ul>
        <li>Use <code>go run</code> to compile and execute in one step:</li>
<pre><code class="language-bash line-numbers">go run main.go</code></pre>
        <br/>
        <li>Expected output:</li>
<pre><code class="language-plaintext line-numbers">Hello, World!</code></pre>
        <br/>
        <li>The <code>go run</code> command:
            <ul>
                <li>compiles your code</li>
                <li>creates a temporary executable</li>
                <li>runs the executable</li>
                <li>cleans up the temporary files</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li>Building an Executable</li>
    <br/>
    <ul>
        <li>To create a standalone executable, use <code>go build</code>:</li>
<pre><code class="language-bash line-numbers">go build main.go</code></pre>
        <br/>
        <li>This creates an executable file:
            <ul>
                <li>On Linux/macOS: <code>main</code></li>
                <li>On Windows: <code>main.exe</code></li>
            </ul>
        </li>
        <br/>
        <li>Run the executable directly:</li>
<pre><code class="language-bash line-numbers">./main        # Linux/macOS
main.exe      # Windows</code></pre>
        <br/>
        <li>Custom output name:</li>
<pre><code class="language-bash line-numbers">go build -o hello main.go
./hello</code></pre>
        <br/>
        <li>The executable is a self-contained binary with no external dependencies.</li>
    </ul>
    <br/><br/>


    <li>Understanding the Import Statement</li>
    <br/>
    <ul>
        <li>The <code>import</code> keyword brings in packages you need:</li>
<pre><code class="language-go line-numbers">import "fmt"              // Single import

import (                  // Multiple imports
    "fmt"
    "time"
    "strings"
)</code></pre>
        <br/>
        <li>Common standard library packages:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fmt</code></td>
            <td>Formatted I/O (printing, scanning)</td>
        </tr>
        <tr>
            <td><code>os</code></td>
            <td>Operating system functionality</td>
        </tr>
        <tr>
            <td><code>strings</code></td>
            <td>String manipulation functions</td>
        </tr>
        <tr>
            <td><code>time</code></td>
            <td>Time and date operations</td>
        </tr>
        <tr>
            <td><code>math</code></td>
            <td>Mathematical functions</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Go automatically removes unused imports when you run <code>go fmt</code>.</li>
        <br/>
        <li>Importing a package without using it causes a compilation error.</li>
    </ul>
    <br/><br/>


    <li>Variations of Hello World</li>
    <br/>
    <ul>
        <li>Using <code>fmt.Print()</code> without newline:</li>
<pre><code class="language-go line-numbers">fmt.Print("Hello, World!")  // No automatic newline</code></pre>
        <br/>
        <li>Using <code>fmt.Printf()</code> for formatted output:</li>
<pre><code class="language-go line-numbers">name := "Go"
fmt.Printf("Hello, %s!\n", name)</code></pre>
        <br/>
        <li>Printing multiple values:</li>
<pre><code class="language-go line-numbers">fmt.Println("Hello,", "World", "from", "Go")</code></pre>
        <br/>
        <li>Using variables:</li>
<pre><code class="language-go line-numbers">func main() {
    greeting := "Hello, World!"
    fmt.Println(greeting)
}</code></pre>
        <br/>
        <li>Accepting user input:</li>
<pre><code class="language-go line-numbers">func main() {
    var name string
    fmt.Print("Enter your name: ")
    fmt.Scan(&name)
    fmt.Printf("Hello, %s!\n", name)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Adding Comments</li>
    <br/>
    <ul>
        <li>Go supports two types of comments:</li>
<pre><code class="language-go line-numbers">// Single-line comment

/*
   Multi-line comment
   Can span multiple lines
*/</code></pre>
        <br/>
        <li>Documented example:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

// main is the entry point of the program
func main() {
    // Print a greeting message
    fmt.Println("Hello, World!")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Formatting Your Code</li>
    <br/>
    <ul>
        <li>Go includes a built-in formatter called <code>gofmt</code>:</li>
<pre><code class="language-bash line-numbers">gofmt -w main.go</code></pre>
        <br/>
        <li>Or use the <code>go fmt</code> command:</li>
<pre><code class="language-bash line-numbers">go fmt main.go</code></pre>
        <br/>
        <li>Format all files in current directory:</li>
<pre><code class="language-bash line-numbers">go fmt ./...</code></pre>
        <br/>
        <li>All Go code should be formatted with <code>gofmt</code> before committing.</li>
        <br/>
        <li>Most editors can run <code>gofmt</code> automatically on save.</li>
    </ul>
    <br/><br/>


    <li>Understanding Module Initialization</li>
    <br/>
    <ul>
        <li>The <code>go.mod</code> file defines your module:</li>
<pre><code class="language-plaintext line-numbers">module example.com/hello

go 1.21</code></pre>
        <li>Module path components:</li>
        <ul>
            <li><code>example.com/hello</code> is an unique identifier for your module</li>
            <li><code>go 1.21</code> is the minimum Go version required</li>
        </ul>
        <br/>
        <li>For real projects, use your actual domain or repository:</li>
<pre><code class="language-bash line-numbers">go mod init github.com/username/projectname</code></pre>
        <li>The module path becomes the import path for packages within your project.</li>
    </ul>
    <br/><br/>


    <li>Running the Program with Arguments</li>
    <br/>
    <ul>
        <li>Access command-line arguments using the <code>os</code> package:</li>
<pre><code class="language-go line-numbers">package main

import (
    "fmt"
    "os"
)

func main() {
    args := os.Args
    if len(args) &gt; 1 {
        fmt.Printf("Hello, %s!\n", args[1])
    } else {
        fmt.Println("Hello, World!")
    }
}</code></pre>
        <br/>
        <li>Run with arguments:</li>
<pre><code class="language-bash line-numbers">go run main.go Junzhe</code></pre>
        <br/>
        <li>Output:</li>
<pre><code class="language-plaintext line-numbers">Hello, Junzhe!</code></pre>
        <br/>
        <li><code>os.Args[0]</code> contains the program name.</li>
        <br/>
        <li><code>os.Args[1]</code> and beyond contain the actual arguments.</li>
    </ul>
    <br/><br/>


    <li>Creating Multiple Functions</li>
    <br/>
    <ul>
        <li>You can define additional functions beyond <code>main()</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func greet(name string) string {
    return "Hello, " + name + "!"
}

func main() {
    message := greet("World")
    fmt.Println(message)
}</code></pre>
        <li>Functions must be defined before use or in any order at package level.</li>
    </ul>
    <br/><br/>


    <li>Cross-Compiling for Different Platforms</li>
    <br/>
    <ul>
        <li>Go makes it easy to build executables for different operating systems:</li>
<pre><code class="language-bash line-numbers"># Build for Windows from Linux/macOS
GOOS=windows GOARCH=amd64 go build -o hello.exe main.go

# Build for Linux from Windows/macOS
GOOS=linux GOARCH=amd64 go build -o hello main.go

# Build for macOS from Linux/Windows
GOOS=darwin GOARCH=amd64 go build -o hello main.go</code></pre>
        <br/><li>Common GOOS and GOARCH values:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>GOOS (Operating System)</th>
            <th>GOARCH (Architecture)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>linux</code></td>
            <td><code>amd64</code> (64-bit)</td>
        </tr>
        <tr>
            <td><code>windows</code></td>
            <td><code>386</code> (32-bit)</td>
        </tr>
        <tr>
            <td><code>darwin</code> (macOS)</td>
            <td><code>arm</code></td>
        </tr>
        <tr>
            <td><code>freebsd</code></td>
            <td><code>arm64</code></td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-variables">Go Variables and Data Types</h3>
<ol>

    <li>What Are Variables?</li>
    <br/>
    <ul>
        <li>A <b>variable</b> is a named storage location that holds a value of a specific type.</li>
        <br/>
        <li>Variables in Go are:</li>
        <ul>
            <li>statically typed (type is known at compile time)</li>
            <li>explicitly declared or inferred</li>
            <li>initialized with zero values if not assigned</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Declaring Variables</li>
    <br/>
    <ul>
        <li>Go provides several ways to declare variables:</li>
        <br/>
        <li>Using <code>var</code> keyword:</li>
<pre><code class="language-go line-numbers">var name string
var age int
var isActive bool</code></pre>
        <br/>
        <li>With initialization:</li>
<pre><code class="language-go line-numbers">var name string = "Junzhe"
var age int = 30
var isActive bool = true</code></pre>
        <br/>
        <li>Type inference (omit type):</li>
<pre><code class="language-go line-numbers">var name = "Junzhe"     // Go infers string
var age = 30            // Go infers int
var isActive = true     // Go infers bool</code></pre>
        <br/>
        <li>Short declaration (inside functions only):</li>
<pre><code class="language-go line-numbers">name := "Junzhe"
age := 30
isActive := true</code></pre>
        <br/>
        <li>The <code>:=</code> operator declares and initializes in one step.</li>
    </ul>
    <br/><br/>


    <li>Zero Values</li>
    <br/>
    <ul>
        <li>Variables declared without initialization receive a <b>zero value</b>:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Zero Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>float32</code>, <code>float64</code></td>
            <td><code>0.0</code></td>
        </tr>
        <tr>
            <td><code>bool</code></td>
            <td><code>false</code></td>
        </tr>
        <tr>
            <td><code>string</code></td>
            <td><code>""</code> (empty string)</td>
        </tr>
        <tr>
            <td>Pointers, functions, interfaces, slices, channels, maps</td>
            <td><code>nil</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">var count int        // 0
var price float64    // 0.0
var name string      // ""
var active bool      // false</code></pre>
        <br/>
        <li>Zero values make variables safe to use immediately without explicit initialization.</li>
    </ul>
    <br/><br/>


    <li>Basic Data Types</li>
    <br/>
    <ul>
        <li>Go has several categories of basic types:</li>
        <br/>
        <li><b>Boolean Type:</b></li>
<pre><code class="language-go line-numbers">var isReady bool = true
var hasError bool = false</code></pre>
        <br/>
        <li><b>String Type:</b></li>
<pre><code class="language-go line-numbers">var message string = "Hello, Go!"
var empty string   // "" (empty string)</code></pre>
        <br/>
        <li><b>Integer Types:</b></li>
<pre><code class="language-go line-numbers">var age int = 25
var count int32 = 100
var bigNumber int64 = 9223372036854775807</code></pre>
        <br/>
        <li><b>Unsigned Integer Types:</b></li>
<pre><code class="language-go line-numbers">var distance uint = 1000
var byteValue uint8 = 255</code></pre>
        <br/>
        <li><b>Floating-Point Types:</b></li>
<pre><code class="language-go line-numbers">var price float32 = 19.99
var pi float64 = 3.14159265359</code></pre>
        <br/>
        <li><b>Complex Number Types:</b></li>
<pre><code class="language-go line-numbers">var complex1 complex64 = 1 + 2i
var complex2 complex128 = 3.5 + 4.2i</code></pre>
    </ul>
    <br/><br/>


    <li>Integer Types Overview</li>
    <br/>
    <ul>
        <li>Go provides sized integer types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Size</th>
            <th>Range</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>int8</code></td>
            <td>8 bits</td>
            <td>-128 to 127</td>
        </tr>
        <tr>
            <td><code>int16</code></td>
            <td>16 bits</td>
            <td>-32,768 to 32,767</td>
        </tr>
        <tr>
            <td><code>int32</code></td>
            <td>32 bits</td>
            <td>-2,147,483,648 to 2,147,483,647</td>
        </tr>
        <tr>
            <td><code>int64</code></td>
            <td>64 bits</td>
            <td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
        </tr>
        <tr>
            <td><code>int</code></td>
            <td>32 or 64 bits</td>
            <td>Platform dependent</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Unsigned integer types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Size</th>
            <th>Range</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>uint8</code></td>
            <td>8 bits</td>
            <td>0 to 255</td>
        </tr>
        <tr>
            <td><code>uint16</code></td>
            <td>16 bits</td>
            <td>0 to 65,535</td>
        </tr>
        <tr>
            <td><code>uint32</code></td>
            <td>32 bits</td>
            <td>0 to 4,294,967,295</td>
        </tr>
        <tr>
            <td><code>uint64</code></td>
            <td>64 bits</td>
            <td>0 to 18,446,744,073,709,551,615</td>
        </tr>
        <tr>
            <td><code>uint</code></td>
            <td>32 or 64 bits</td>
            <td>Platform dependent</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Use <code>int</code> for most cases unless you need a specific size.</li>
    </ul>
    <br/><br/>


    <li>Special Integer Types</li>
    <br/>
    <ul>
        <li>Go provides special-purpose integer types:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>byte</code></td>
            <td>Alias for <code>uint8</code>, used for raw data</td>
        </tr>
        <tr>
            <td><code>rune</code></td>
            <td>Alias for <code>int32</code>, represents a Unicode code point</td>
        </tr>
        <tr>
            <td><code>uintptr</code></td>
            <td>Unsigned integer large enough to hold a pointer</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example using <code>byte</code>:</li>
<pre><code class="language-go line-numbers">var data byte = 255</code></pre>
        <br/>
        <li>Example using <code>rune</code>:</li>
<pre><code class="language-go line-numbers">var letter rune = 'A'     // Unicode code point for 'A'
var emoji rune = 'ðŸ˜€'      // Unicode code point for emoji</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Variable Declarations</li>
    <br/>
    <ul>
        <li>Declare multiple variables of the same type:</li>
<pre><code class="language-go line-numbers">var x, y, z int
var a, b, c = 1, 2, 3</code></pre>
        <br/>
        <li>Declare multiple variables of different types:</li>
<pre><code class="language-go line-numbers">var (
    name   string  = "Junzhe"
    age    int     = 30
    height float64 = 5.7
)</code></pre>
        <br/>
        <li>Short declaration with multiple variables:</li>
<pre><code class="language-go line-numbers">name, age := "Junzhe", 30
x, y, z   := 1, 2, 3</code></pre>
        <br/>
        <li>At least one new variable must be declared when using <code>:=</code>:</li>
<pre><code class="language-go line-numbers">name := "Alice"
name, age := "Bob", 30  // OK: age is new
// name := "Charlie"    // Error: no new variables</code></pre>
    </ul>
    <br/><br/>


    <li>Constants</li>
    <br/>
    <ul>
        <li>Constants are immutable values declared with the <code>const</code> keyword:</li>
<pre><code class="language-go line-numbers">const Pi = 3.14159
const MaxUsers = 100
const AppName = "MyApp"</code></pre>
        <br/>
        <li>Constants can be typed or untyped:</li>
<pre><code class="language-go line-numbers">const TypedPi float64 = 3.14159  // Typed constant
const UntypedPi = 3.14159        // Untyped constant</code></pre>
        <br/>
        <li>Multiple constants:</li>
<pre><code class="language-go line-numbers">const (
    StatusOK       = 200
    StatusNotFound = 404
    StatusError    = 500
)</code></pre>
        <br/>
        <li>Constants cannot use the <code>:=</code> syntax.</li>
        <br/>
        <li>Constants must be assigned at compile time (no runtime values).</li>
    </ul>
    <br/><br/>


    <li>Type Conversion</li>
    <br/>
    <ul>
        <li>Go does not allow implicit type conversion:</li>
<pre><code class="language-go line-numbers">var i int = 42
var f float64 = i      // Error: cannot use i (type int) as type float64</code></pre>
        <br/>
        <li>Explicit conversion is required:</li>
<pre><code class="language-go line-numbers">var i int = 42
var f float64 = float64(i)  // OK: explicit conversion</code></pre>
        <br/>
        <li>Common conversions:</li>
<pre><code class="language-go line-numbers">var x int = 100
var y float64 = float64(x)
var z int32 = int32(x)
var s string = string(x)     // Converts to Unicode character, not "100"</code></pre>
        <br/>
        <li>Converting integers to strings (proper way):</li>
<pre><code class="language-go line-numbers">import "strconv"

var num int = 42
var str string = strconv.Itoa(num)  // "42"</code></pre>
        <br/>
        <li>Converting strings to integers:</li>
<pre><code class="language-go line-numbers">import "strconv"

var str string = "42"
num, err := strconv.Atoi(str)  // num = 42, err = nil</code></pre>
    </ul>
    <br/><br/>


    <li>Variable Scope</li>
    <br/>
    <ul>
        <li>Variables have different scopes based on where they're declared:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Scope Level</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Package-level</b></td>
            <td>Declared outside functions, accessible throughout the package</td>
        </tr>
        <tr>
            <td><b>Function-level</b></td>
            <td>Declared inside functions, accessible only within that function</td>
        </tr>
        <tr>
            <td><b>Block-level</b></td>
            <td>Declared inside blocks (if, for, etc.), accessible only in that block</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">package main

var globalVar = "I'm global"  // Package-level

func main() {
    var localVar = "I'm local"  // Function-level

    if true {
        var blockVar = "I'm in a block"  // Block-level
        fmt.Println(globalVar)   // OK
        fmt.Println(localVar)    // OK
        fmt.Println(blockVar)    // OK
    }

    // fmt.Println(blockVar)  // Error: undefined
}</code></pre>
        <br/>
        <li>Package-level variables cannot use the <code>:=</code> syntax.</li>
    </ul>
    <br/><br/>


    <li>Naming Conventions</li>
    <br/>
    <ul>
        <li>Go has strict naming rules and conventions:</li>
        <br/>
        <li><b>Basic rules:</b></li>
        <ul>
            <li>must start with a letter or underscore</li>
            <li>can contain letters, digits, and underscores</li>
            <li>case-sensitive (<code>name</code> and <code>Name</code> are different)</li>
        </ul>
        <br/>
        <li><b>Visibility rules:</b></li>
<table>
    <thead>
        <tr>
            <th>Case</th>
            <th>Visibility</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Starts with uppercase</td>
            <td>Exported (public)</td>
            <td><code>MaxValue</code>, <code>UserName</code></td>
        </tr>
        <tr>
            <td>Starts with lowercase</td>
            <td>Unexported (private)</td>
            <td><code>maxValue</code>, <code>userName</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li><b>Naming conventions:</b></li>
        <ul>
            <li>use camelCase for local variables: <code>userName</code>, <code>totalCount</code></li>
            <li>use PascalCase for exported names: <code>UserName</code>, <code>TotalCount</code></li>
            <li>short names are preferred for small scopes: <code>i</code>, <code>j</code>, <code>err</code></li>
            <li>acronyms should be all caps: <code>HTTP</code>, <code>URL</code>, <code>ID</code></li>
        </ul>
        <br/>
        <li>Good examples:</li>
<pre><code class="language-go line-numbers">var userCount int
var httpClient *http.Client
var userID string</code></pre>
        <br/>
        <li>Avoid using underscore separators except for package-level constants.</li>
    </ul>
    <br/><br/>


    <li>The Blank Identifier</li>
    <br/>
    <ul>
        <li>The underscore <code>_</code> is a special identifier that discards values:</li>
<pre><code class="language-go line-numbers">// Ignore a return value
result, _ := someFunction()  // Ignore error

// Ignore first value
_, value := someFunction()   // Ignore result

// Import package for side effects only
import _ "github.com/lib/pq"</code></pre>
        <br/>
        <li>Example with range:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}

for _, num := range numbers {  // Ignore index
    fmt.Println(num)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Variable Shadowing</li>
    <br/>
    <ul>
        <li>A variable in an inner scope can <b>shadow</b> a variable in an outer scope:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

var x = "global"

func main() {
    fmt.Println(x)  // "global"

    x := "local"    // Shadows the global x
    fmt.Println(x)  // "local"

    {
        x := "block"  // Shadows the function-level x
        fmt.Println(x)  // "block"
    }

    fmt.Println(x)  // "local"
}</code></pre>
        <br/>
        <li>Shadowing can lead to bugs, so use it carefully.</li>
        <br/>
        <li>Many linters warn about shadowing common variables like <code>err</code>.</li>
    </ul>
    <br/><br/>


    <li>Pointers and Variables</li>
    <br/>
    <ul>
        <li>Go supports pointers, which store memory addresses:</li>
<pre><code class="language-go line-numbers">var x int = 42
var p *int = &amp;x  // p holds the address of x

fmt.Println(x)   // 42
fmt.Println(p)   // 0xc0000b4008 (memory address)
fmt.Println(*p)  // 42 (dereference to get value)</code></pre>
        <br/>
        <li>Pointer operators:</li>
<table>
    <thead>
        <tr>
            <th>Operator</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>&amp;</code></td>
            <td>Address-of operator (gets memory address)</td>
        </tr>
        <tr>
            <td><code>*</code></td>
            <td>Dereference operator (gets value at address)</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Modifying through pointers:</li>
<pre><code class="language-go line-numbers">var x int = 10
var p *int = &amp;x

*p = 20          // Modify x through pointer
fmt.Println(x)   // 20</code></pre>
        <br/>
        <li>Zero value of a pointer is <code>nil</code>.</li>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-functions">Functions in Go</h3>
<ol>

    <li>What Are Functions?</li>
    <br/>
    <ul>
        <li>A <b>function</b> is a reusable block of code that performs a specific task.</li>
        <br/>
        <li>Functions in Go:</li>
        <ul>
            <li>are first-class citizens (can be assigned to variables, passed as arguments)</li>
            <li>can return multiple values</li>
            <li>support named return values</li>
            <li>can be anonymous (function literals)</li>
            <li>can form closures</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Basic Function Syntax</li>
    <br/>
    <ul>
        <li>The basic syntax for declaring a function:</li>
<pre><code class="language-go line-numbers">func functionName(parameter1 type1, parameter2 type2) returnType {
    // function body
    return value
}</code></pre>
        <br/>
        <li>Simple example:</li>
<pre><code class="language-go line-numbers">func greet(name string) string {
    return "Hello, " + name
}

func main() {
    message := greet("Alice")
    fmt.Println(message)  // Hello, Alice
}</code></pre>
        <br/>
        <li>Function components:</li>
<table>
    <thead>
        <tr>
            <th>Component</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>func</code></td>
            <td>Keyword to declare a function</td>
        </tr>
        <tr>
            <td><code>functionName</code></td>
            <td>Name of the function (must start with letter)</td>
        </tr>
        <tr>
            <td><code>(parameters)</code></td>
            <td>Input parameters (optional)</td>
        </tr>
        <tr>
            <td><code>returnType</code></td>
            <td>Type of value returned (optional)</td>
        </tr>
        <tr>
            <td><code>return</code></td>
            <td>Statement to return a value (if return type specified)</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>Functions Without Return Values</li>
    <br/>
    <ul>
        <li>Functions can execute code without returning a value:</li>
<pre><code class="language-go line-numbers">func printMessage(message string) {
    fmt.Println(message)
}

func main() {
    printMessage("Hello, World!")
}</code></pre>
        <br/>
        <li>No return type is specified.</li>
        <br/>
        <li>The <code>return</code> keyword can be used to exit early:</li>
<pre><code class="language-go line-numbers">func process(value int) {
    if value < 0 {
        return  // Exit early
    }
    fmt.Println("Processing:", value)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Functions With Parameters</li>
    <br/>
    <ul>
        <li>Functions can accept zero or more parameters:</li>
<pre><code class="language-go line-numbers">// No parameters
func sayHello() {
    fmt.Println("Hello!")
}

// One parameter
func square(x int) int {
    return x * x
}

// Multiple parameters
func add(x int, y int) int {
    return x + y
}</code></pre>
        <br/>
        <li>When consecutive parameters have the same type, you can omit the type for all but the last:</li>
<pre><code class="language-go line-numbers">// Both are equivalent
func add(x int, y int) int
func add(x, y int) int</code></pre>
        <br/>
        <li>Mixed parameter types:</li>
<pre><code class="language-go line-numbers">func describe(name string, age int, height float64) {
    fmt.Printf("%s is %d years old and %.2f meters tall\n", name, age, height)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Multiple Return Values</li>
    <br/>
    <ul>
        <li>Go functions can return multiple values:</li>
<pre><code class="language-go line-numbers">func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)  // Result: 5
}</code></pre>
        <br/>
        <li>Common pattern: returning a value and an error:</li>
<pre><code class="language-go line-numbers">func readFile(filename string) ([]byte, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    return data, nil
}</code></pre>
        <br/>
        <li>Multiple return values are specified in parentheses:</li>
<pre><code class="language-go line-numbers">func swap(x, y string) (string, string) {
    return y, x
}

a, b := swap("hello", "world")
fmt.Println(a, b)  // world hello</code></pre>
    </ul>
    <br/><br/>


    <li>Named Return Values (it somehow reminds me of Pascal)</li>
    <br/>
    <ul>
        <li>Return values can be named in the function signature:</li>
<pre><code class="language-go line-numbers">func calculate(x, y int) (sum int, product int) {
    sum = x + y
    product = x * y
    return  // Naked return
}

func main() {
    s, p := calculate(3, 4)
    fmt.Println(s, p)  // 7 12
}</code></pre>
        <br/>
        <li>Named return values are automatically initialized to their zero values.</li>
        <br/>
        <li>A <b>naked return</b> returns the named values without explicitly specifying them.</li>
        <br/>
        <li>Named returns improve documentation but can reduce clarity in complex functions:</li>
<pre><code class="language-go line-numbers">func divide(a, b float64) (result float64, err error) {
    if b == 0 {
        err = errors.New("division by zero")
        return  // result will be 0.0 (zero value)
    }
    result = a / b
    return
}</code></pre>
    </ul>
    <br/><br/>


    <li>Variadic Functions</li>
    <br/>
    <ul>
        <li>A <b>variadic function</b> accepts a variable number of arguments:</li>
<pre><code class="language-go line-numbers">func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3))        // 6
    fmt.Println(sum(10, 20, 30, 40)) // 100
    fmt.Println(sum())               // 0
}</code></pre>
        <br/>
        <li>The <code>...</code> before the type indicates a variadic parameter.</li>
        <br/>
        <li>Inside the function, the variadic parameter is treated as a slice.</li>
        <br/>
        <li>Variadic parameter must be the last parameter:</li>
<pre><code class="language-go line-numbers">func printf(format string, args ...interface{}) {
    fmt.Printf(format, args...)
}</code></pre>
        <br/>
        <li>Passing a slice to a variadic function:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, 3, 4, 5}
total := sum(numbers...)  // Spread operator</code></pre>
    </ul>
    <br/><br/>


    <li>Anonymous Functions</li>
    <br/>
    <ul>
        <li>Functions can be defined without a name (function literals):</li>
<pre><code class="language-go line-numbers">func main() {
    // Define and call immediately
    func() {
        fmt.Println("Anonymous function")
    }()

    // Assign to variable
    greet := func(name string) {
        fmt.Println("Hello,", name)
    }
    greet("Alice")
}</code></pre>
        <br/>
        <li>Anonymous functions with parameters and return values:</li>
<pre><code class="language-go line-numbers">add := func(x, y int) int {
    return x + y
}

result := add(5, 3)
fmt.Println(result)  // 8</code></pre>
    </ul>
    <br/><br/>


    <li>Functions as Values</li>
    <br/>
    <ul>
        <li>Functions are first-class values and can be:</li>
        <ul>
            <li>assigned to variables</li>
            <li>passed as arguments</li>
            <li>returned from functions</li>
        </ul>
        <br/>
        <li>Assigning functions to variables:</li>
<pre><code class="language-go line-numbers">func add(x, y int) int {
    return x + y
}

func main() {
    var operation func(int, int) int
    operation = add

    result := operation(3, 4)
    fmt.Println(result)  // 7
}</code></pre>
        <br/>
        <li>Passing functions as arguments:</li>
<pre><code class="language-go line-numbers">func apply(f func(int, int) int, x, y int) int {
    return f(x, y)
}

func multiply(x, y int) int {
    return x * y
}

func main() {
    result := apply(multiply, 5, 6)
    fmt.Println(result)  // 30
}</code></pre>
        <br/>
        <li>Returning functions from functions:</li>
<pre><code class="language-go line-numbers">func makeAdder(x int) func(int) int {
    return func(y int) int {
        return x + y
    }
}

func main() {
    add5 := makeAdder(5)
    fmt.Println(add5(3))  // 8
    fmt.Println(add5(10)) // 15
}</code></pre>
    </ul>
    <br/><br/>


    <li>Closures</li>
    <br/>
    <ul>
        <li>A <b>closure</b> is a function that references variables from outside its body:</li>
<pre><code class="language-go line-numbers">func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    next := counter()
    fmt.Println(next())  // 1
    fmt.Println(next())  // 2
    fmt.Println(next())  // 3
}</code></pre>
        <br/>
        <li>Each closure maintains its own state:</li>
<pre><code class="language-go line-numbers">counter1 := counter()
counter2 := counter()

fmt.Println(counter1())  // 1
fmt.Println(counter1())  // 2
fmt.Println(counter2())  // 1 (separate state)</code></pre>
        <br/>
        <li>Common use case: creating private state:</li>
<pre><code class="language-go line-numbers">func makeMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

double := makeMultiplier(2)
triple := makeMultiplier(3)

fmt.Println(double(5))  // 10
fmt.Println(triple(5))  // 15</code></pre>
    </ul>
    <br/><br/>


    <li>The Defer Statement</li>
    <br/>
    <ul>
        <li>The <code>defer</code> keyword postpones function execution until the surrounding function returns:</li>
<pre><code class="language-go line-numbers">func main() {
    defer fmt.Println("World")
    fmt.Println("Hello")
}
// Output:
// Hello
// World</code></pre>
        <br/>
        <li>Multiple defers execute in LIFO (Last In, First Out) order:</li>
<pre><code class="language-go line-numbers">func main() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
    fmt.Println("Main")
}
// Output:
// Main
// Third
// Second
// First</code></pre>
        <br/>
        <li>Common use cases:</li>
<table>
    <thead>
        <tr>
            <th>Use Case</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Closing files</td>
            <td><code>defer file.Close()</code></td>
        </tr>
        <tr>
            <td>Unlocking mutexes</td>
            <td><code>defer mutex.Unlock()</code></td>
        </tr>
        <tr>
            <td>Closing database connections</td>
            <td><code>defer db.Close()</code></td>
        </tr>
        <tr>
            <td>Cleanup operations</td>
            <td><code>defer cleanup()</code></td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Practical example with file handling:</li>
<pre><code class="language-go line-numbers">func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // Ensures file is closed

    // Read file contents
    // Even if an error occurs, file.Close() will be called
    return nil
}</code></pre>
        <br/>
        <li>Deferred function arguments are evaluated immediately:</li>
<pre><code class="language-go line-numbers">func main() {
    x := 10
    defer fmt.Println(x)  // x is evaluated now (10)
    x = 20
    fmt.Println(x)
}
// Output:
// 20
// 10</code></pre>
    </ul>
    <br/><br/>


    <li>Recursive Functions</li>
    <br/>
    <ul>
        <li>A function can call itself (recursion):</li>
<pre><code class="language-go line-numbers">func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)
}

func main() {
    fmt.Println(factorial(5))  // 120
}</code></pre>
        <br/>
        <li>Fibonacci sequence using recursion:</li>
<pre><code class="language-go line-numbers">func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}

func main() {
    for i := 0; i < 10; i++ {
        fmt.Print(fibonacci(i), " ")
    }
    // Output: 0 1 1 2 3 5 8 13 21 34
}</code></pre>
        <br/>
        <li>Always include a base case to prevent infinite recursion.</li>
        <br/>
        <li>Recursive tree traversal:</li>
<pre><code class="language-go line-numbers">type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

func traverse(node *TreeNode) {
    if node == nil {
        return
    }
    fmt.Println(node.Value)
    traverse(node.Left)
    traverse(node.Right)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Methods</li>
    <br/>
    <ul>
        <li>Go doesn't have classes, but you can define methods on types:</li>
<pre><code class="language-go line-numbers">type Rectangle struct {
    Width  float64
    Height float64
}

// Method with value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    fmt.Println(rect.Area())  // 50
}</code></pre>
        <br/>
        <li>Methods can have pointer receivers to modify the receiver:</li>
<pre><code class="language-go line-numbers">// Method with pointer receiver
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    rect.Scale(2)
    fmt.Println(rect.Area())  // 200
}</code></pre>
        <br/>
        <li>Value receiver vs pointer receiver:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Receiver Type</th>
            <th>When to Use</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Value <code>(r Type)</code></td>
            <td>When method doesn't modify the receiver, small structs</td>
        </tr>
        <tr>
            <td>Pointer <code>(r *Type)</code></td>
            <td>When method modifies the receiver, large structs, or consistency</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Methods can be defined on any type in the same package:</li>
<pre><code class="language-go line-numbers">type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}

func main() {
    num := MyInt(5)
    fmt.Println(num.Double())  // 10
}</code></pre>
    </ul>
    <br/><br/>


    <li>Function Type Declarations</li>
    <br/>
    <ul>
        <li>You can create custom function types:</li>
<pre><code class="language-go line-numbers">type Operation func(int, int) int

func add(x, y int) int {
    return x + y
}

func multiply(x, y int) int {
    return x * y
}

func apply(op Operation, x, y int) int {
    return op(x, y)
}

func main() {
    fmt.Println(apply(add, 5, 3))      // 8
    fmt.Println(apply(multiply, 5, 3)) // 15
}</code></pre>
    </ul>
    <br/><br/>


    <li>Init Function</li>
    <br/>
    <ul>
        <li>The <code>init()</code> function runs automatically before <code>main()</code>:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func init() {
    fmt.Println("Initialization")
}

func main() {
    fmt.Println("Main function")
}
// Output:
// Initialization
// Main function</code></pre>
        <br/>
        <li>Multiple <code>init()</code> functions can exist in the same package.</li>
        <br/>
        <li>They execute in the order they appear in the file.</li>
        <br/>
        <li>Common uses:</li>
        <ul>
            <li>initializing package-level variables</li>
            <li>registering drivers or plugins</li>
            <li>setting up configuration</li>
            <li>validating state</li>
        </ul>
        <br/>
        <li>Example with database driver:</li>
<pre><code class="language-go line-numbers">import (
    "database/sql"
    _ "github.com/lib/pq"  // init() registers PostgreSQL driver
)</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-packages">Packages in Go</h3>
<ol>

    <li>What Are Packages?</li>
    <br/>
    <ul>
        <li>A <code>package</code> is a collection of Go source files in the same directory that are compiled together.</li>
        <br/>
        <li>Every Go file must belong to a package:</li>
<pre><code class="language-go line-numbers">package main  // First line of every .go file</code></pre>
        <li>Go's standard library consists of many packages like <code>fmt</code>, <code>os</code>, <code>net/http</code>, etc.</li>
    </ul>
    <br/><br/>


    <li>Package Declaration</li>
    <br/>
    <ul>
        <li>Every Go file starts with a package declaration:</li>
<pre><code class="language-go line-numbers">package &lt;packagename&gt;</code></pre>
        <br/>
        <li>Package naming rules:</li>
        <ul>
            <li>must be lowercase</li>
            <li>should be short and concise</li>
            <li>no underscores or mixed caps</li>
            <li>by convention, matches the directory name</li>
        </ul>
        <br/>
        <li>Examples of good package names:</li>
<pre><code class="language-go line-numbers">package math
package strings
package http
package json</code></pre>
        <br/>
        <li>Examples of bad package names:</li>
<pre><code class="language-go line-numbers">package Math          // Uppercase
package string_utils  // Underscore
package myPackage     // Mixed caps</code></pre>
    </ul>
    <br/><br/>


    <li>The Main Package</li>
    <br/>
    <ul>
        <li>The <code>main</code> package is special -- it creates an executable program:</li>
<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {
    fmt.Println("This is an executable")
}</code></pre>
        <br/>
        <li>Requirements for an executable:</li>
        <ul>
            <li>must be named <code>main</code></li>
            <li>must contain a <code>main()</code> function</li>
            <li>the <code>main()</code> function takes no arguments and returns nothing</li>
        </ul>
        <br/>
        <li>Non-main packages create reusable libraries, not executables.</li>
        <br/>
        <li>You can have multiple <code>main</code> packages in different directories of a project.</li>
    </ul>
    <br/><br/>


    <li>Creating a Custom Package</li>
    <br/>
    <ul>
        <li>Project structure example:</li>
<pre><code class="language-plaintext line-numbers">myproject/
â”œâ”€â”€ main.go
â”œâ”€â”€ go.mod
â””â”€â”€ calculator/
    â”œâ”€â”€ add.go
    â””â”€â”€ multiply.go</code></pre>
        <br/>
        <li>File: <code>calculator/add.go</code></li>
<pre><code class="language-go line-numbers">package calculator

func Add(x, y int) int {
    return x + y
}</code></pre>
        <br/>
        <li>File: <code>calculator/multiply.go</code></li>
<pre><code class="language-go line-numbers">package calculator

func Multiply(x, y int) int {
    return x * y
}</code></pre>
        <br/>
        <li>File: <code>main.go</code></li>
<pre><code class="language-go line-numbers">package main

import (
    "fmt"
    "myproject/calculator"
)

func main() {
    sum := calculator.Add(5, 3)
    product := calculator.Multiply(5, 3)

    fmt.Println("Sum:", sum)         // Sum: 8
    fmt.Println("Product:", product) // Product: 15
}</code></pre>
        <li>All files in the same directory MUST have the same package name.</li>
    </ul>
    <br/><br/>


    <li>Importing Packages</li>
    <br/>
    <ul>
        <li>Use the <code>import</code> keyword to include packages:</li>
<pre><code class="language-go line-numbers">import "fmt"</code></pre>
        <br/>
        <li>Multiple imports:</li>
<pre><code class="language-go line-numbers">import (
    "fmt"
    "os"
    "strings"
    "time"
)</code></pre>
        <br/>
        <li>Importing with alias:</li>
<pre><code class="language-go line-numbers">import (
    f "fmt"              // Alias as 'f'
    "math/rand"
)

func main() {
    f.Println("Hello")   // Using alias
}</code></pre>
        <br/>
        <li>Import for side effects only (runs <code>init()</code> functions):</li>
<pre><code class="language-go line-numbers">import _ "github.com/lib/pq"  // Register PostgreSQL driver</code></pre>
        <br/>
        <li>Dot import (imports into current namespace - not recommended):</li>
<pre><code class="language-go line-numbers">import . "fmt"

func main() {
    Println("No prefix needed")  // Not recommended
}</code></pre>
    </ul>
    <br/><br/>


    <li>Package Visibility Rules</li>
    <br/>
    <ul>
        <li>Go uses capitalization to control visibility:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Case</th>
            <th>Visibility</th>
            <th>Accessible From</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Uppercase (exported)</td>
            <td>Public</td>
            <td>Any package</td>
        </tr>
        <tr>
            <td>Lowercase (unexported)</td>
            <td>Private</td>
            <td>Same package only</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">package calculator

// Exported (public) - can be used by other packages
func Add(x, y int) int {
    return x + y
}

// Unexported (private) - only accessible within calculator package
func validate(x int) bool {
    return x &gt;= 0
}</code></pre>
        <li>Example with struct:</li>
<pre><code class="language-go line-numbers">package user

type User struct {
    Name    string  // Exported field
    Email   string  // Exported field
    age     int     // Unexported field (private)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Package Organization</li>
    <br/>
    <ul>
        <li>Common project structure:</li>
<pre><code class="language-bash line-numbers">myproject/
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ main.go
â”œâ”€â”€ README.md
â”œâ”€â”€ cmd/               # Command-line applications
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ pkg/               # Reusable packages
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ db.go
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ user.go
â”œâ”€â”€ internal/          # Private packages (Go convention)
â”‚   â””â”€â”€ config/
â”‚       â””â”€â”€ config.go
â””â”€â”€ test/              # Test files
    â””â”€â”€ integration/</code></pre>
        <br/>
        <li>Directory purposes:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Directory</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>cmd/</code></td>
            <td>Contains main applications (each subdirectory is a separate executable)</td>
        </tr>
        <tr>
            <td><code>pkg/</code></td>
            <td>Contains reusable library code</td>
        </tr>
        <tr>
            <td><code>internal/</code></td>
            <td>Private application code (cannot be imported by other projects)</td>
        </tr>
        <tr>
            <td><code>api/</code></td>
            <td>API definitions (OpenAPI, Protocol Buffers)</td>
        </tr>
        <tr>
            <td><code>web/</code></td>
            <td>Web application assets</td>
        </tr>
        <tr>
            <td><code>scripts/</code></td>
            <td>Build and deployment scripts</td>
        </tr>
        <tr>
            <td><code>test/</code></td>
            <td>Additional test files</td>
        </tr>
    </tbody>
</table>
    </ul>
    <br/><br/>


    <li>The Internal Package</li>
    <br/>
    <ul>
        <li>The <code>internal/</code> directory has special meaning in Go:</li>
<pre><code class="language-plaintext line-numbers">myproject/
â””â”€â”€ internal/
    â””â”€â”€ auth/
        â””â”€â”€ auth.go</code></pre>
        <br/>
        <li>Packages in <code>internal/</code> can only be imported by code in the parent tree.</li>
        <br/>
        <li>Example structure:</li>
<pre><code class="language-plaintext line-numbers">github.com/user/myproject/
â”œâ”€â”€ internal/
â”‚   â””â”€â”€ helper/         # Only importable by myproject
â”‚       â””â”€â”€ helper.go
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ public/         # Can be imported by anyone
â”‚       â””â”€â”€ public.go
â””â”€â”€ cmd/
    â””â”€â”€ app/
        â””â”€â”€ main.go     # Can import internal/helper</code></pre>
        <br/>
        <li>Import path restrictions:</li>
<pre><code class="language-go line-numbers">// âœ“ OK - same project
import "github.com/user/myproject/internal/helper"

// âœ— ERROR - external project cannot import internal
import "github.com/other/theirproject/internal/something"</code></pre>
        <li>Use <code>internal/</code> to prevent external projects from depending on unstable APIs.</li>
    </ul>
    <br/><br/>


    <li>Go Modules</li>
    <br/>
    <ul>
        <li>Go modules are the standard dependency management system (since Go 1.11).</li>
        <br/>
        <li>Initialize a module:</li>
<pre><code class="language-bash line-numbers">go mod init github.com/username/projectname</code></pre>
        <br/>
        <li>This creates a <code>go.mod</code> file:</li>
<pre><code class="language-plaintext line-numbers">module github.com/username/projectname

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/lib/pq v1.10.9
)</code></pre>
        <br/>
        <li>Common module commands:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Command</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>go mod init</code></td>
            <td>Initialize a new module</td>
        </tr>
        <tr>
            <td><code>go mod tidy</code></td>
            <td>Add missing and remove unused dependencies</td>
        </tr>
        <tr>
            <td><code>go mod download</code></td>
            <td>Download dependencies to local cache</td>
        </tr>
        <tr>
            <td><code>go mod verify</code></td>
            <td>Verify dependencies have expected content</td>
        </tr>
        <tr>
            <td><code>go mod vendor</code></td>
            <td>Copy dependencies to vendor directory</td>
        </tr>
        <tr>
            <td><code>go get</code></td>
            <td>Add or update dependencies</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>The <code>go.sum</code> file stores checksums for dependency verification.</li>
    </ul>
    <br/><br/>


    <li>Installing Third-Party Packages</li>
    <br/>
    <ul>
        <li>Add a dependency using <code>go get</code>:</li>
<pre><code class="language-bash line-numbers">go get github.com/gin-gonic/gin</code></pre>
        <br/>
        <li>Install specific version:</li>
<pre><code class="language-bash line-numbers">go get github.com/gin-gonic/gin@v1.9.1</code></pre>
        <br/>
        <li>Import and use in code:</li>
<pre><code class="language-go line-numbers">package main

import (
    "github.com/gin-gonic/gin"
)

func main() {
    router := gin.Default()
    router.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "Hello"})
    })
    router.Run(":8080")
}</code></pre>
        <br/>
        <li>Go automatically downloads dependencies when you build:</li>
<pre><code class="language-bash line-numbers">go build</code></pre>
        <br/>
        <li>Update all dependencies:</li>
<pre><code class="language-bash line-numbers">go get -u ./...</code></pre>
        <br/>
        <li>Remove unused dependencies:</li>
<pre><code class="language-bash line-numbers">go mod tidy</code></pre>
    </ul>
    <br/><br/>


    <li>Standard Library Packages</li>
    <br/>
    <ul>
        <li>Go's standard library provides many useful packages:</li>
        <br/>
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>fmt</code></td>
            <td>Formatted I/O operations</td>
        </tr>
        <tr>
            <td><code>os</code></td>
            <td>Operating system functionality</td>
        </tr>
        <tr>
            <td><code>io</code></td>
            <td>Basic I/O primitives</td>
        </tr>
        <tr>
            <td><code>net/http</code></td>
            <td>HTTP client and server</td>
        </tr>
        <tr>
            <td><code>encoding/json</code></td>
            <td>JSON encoding and decoding</td>
        </tr>
        <tr>
            <td><code>database/sql</code></td>
            <td>Generic SQL database interface</td>
        </tr>
        <tr>
            <td><code>time</code></td>
            <td>Time and duration operations</td>
        </tr>
        <tr>
            <td><code>strings</code></td>
            <td>String manipulation</td>
        </tr>
        <tr>
            <td><code>strconv</code></td>
            <td>String conversions</td>
        </tr>
        <tr>
            <td><code>math</code></td>
            <td>Mathematical functions</td>
        </tr>
        <tr>
            <td><code>regexp</code></td>
            <td>Regular expressions</td>
        </tr>
        <tr>
            <td><code>context</code></td>
            <td>Request scoping and cancellation</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>Example using multiple standard packages:</li>
<pre><code class="language-go line-numbers">package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type Response struct {
    Message   string    `json:"message"`
    Timestamp time.Time `json:"timestamp"`
}

func handler(w http.ResponseWriter, r *http.Request) {
    response := Response{
        Message:   "Hello, World!",
        Timestamp: time.Now(),
    }

    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/", handler)
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Package Documentation</li>
    <br/>
    <ul>
        <li>Document packages with comments before the package declaration:</li>
<pre><code class="language-go line-numbers">// Package calculator provides basic arithmetic operations.
// It supports addition, subtraction, multiplication, and division.
package calculator</code></pre>
        <br/>
        <li>Document exported functions:</li>
<pre><code class="language-go line-numbers">// Add returns the sum of x and y.
func Add(x, y int) int {
    return x + y
}

// Divide returns the quotient of x divided by y.
// It returns an error if y is zero.
func Divide(x, y float64) (float64, error) {
    if y == 0 {
        return 0, errors.New("division by zero")
    }
    return x / y, nil
}</code></pre>
        <br/>
        <li>View documentation locally:</li>
<pre><code class="language-bash line-numbers">go doc calculator
go doc calculator.Add</code></pre>
        <br/>
        <li>Generate HTML documentation:</li>
<pre><code class="language-bash line-numbers">godoc -http=:6060</code></pre>
        <br/>
        <li>Documentation is automatically published on <code>pkg.go.dev</code> for public packages.</li>
    </ul>
    <br/><br/>


    <li>Package Initialization</li>
    <br/>
    <ul>
        <li>Packages are initialized in the following order:</li>
        <ol>
            <li>Import dependencies</li>
            <li>Initialize package-level variables</li>
            <li>Run <code>init()</code> functions</li>
        </ol>
        <br/>
        <li>Example with <code>init()</code>:</li>
<pre><code class="language-go line-numbers">package database

import "database/sql"

var db *sql.DB

func init() {
    var err error
    db, err = sql.Open("postgres", "connection_string")
    if err != nil {
        panic(err)
    }
}

func GetDB() *sql.DB {
    return db
}</code></pre>
        <br/>
        <li>Multiple <code>init()</code> functions are executed in declaration order.</li>
        <br/>
        <li>Each imported package's <code>init()</code> runs before the importing package.</li>
    </ul>
    <br/><br/>


    <li>Vendor Directory</li>
    <br/>
    <ul>
        <li>The <code>vendor/</code> directory stores a copy of dependencies:</li>
<pre><code class="language-bash line-numbers">go mod vendor</code></pre>
        <br/>
        <li>Creates structure:</li>
<pre><code class="language-plaintext line-numbers">myproject/
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ main.go
â””â”€â”€ vendor/
    â”œâ”€â”€ github.com/
    â”‚   â””â”€â”€ gin-gonic/
    â”‚       â””â”€â”€ gin/
    â””â”€â”€ modules.txt</code></pre>
        <br/>
        <li>Benefits of vendoring:</li>
        <ul>
            <li>guaranteed reproducible builds</li>
            <li>works without internet access</li>
            <li>complete control over dependencies</li>
        </ul>
        <br/>
        <li>Build using vendor directory:</li>
<pre><code class="language-bash line-numbers">go build -mod=vendor</code></pre>
        <br/>
        <li>Most projects don't need vendoring anymore due to Go's module cache.</li>
    </ul>
    <br/><br/>


    <li>Package Aliases and Naming Conflicts</li>
    <br/>
    <ul>
        <li>Resolve naming conflicts with aliases:</li>
<pre><code class="language-go line-numbers">import (
    "crypto/rand"
    mrand "math/rand"  // Alias to avoid conflict
)

func main() {
    // Use crypto/rand
    bytes := make([]byte, 32)
    rand.Read(bytes)

    // Use math/rand with alias
    num := mrand.Intn(100)
}</code></pre>
        <br/>
        <li>Another example:</li>
<pre><code class="language-go line-numbers">import (
    "database/sql"
    "github.com/jmoiron/sqlx"

    stdSQL "database/sql"  // If needed
)</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="go-control-flow">Control Flow in Go</h3>
<ol>

    <li>Go provides several control flow structures:</li>
    <ul>
        <br/>
        <li><code>if</code> statements for conditional execution</li>
        <br/>
        <li><code>switch</code> statements for multi-way branching</li>
        <br/>
        <li><code>for</code> loops for iteration (the only loop in Go)</li>
        <br/>
        <li><code>break</code> and <code>continue</code> for loop control</li>
        <br/>
        <li><code>goto</code> for unconditional jumps (rarely used)</li>
        <br/>
        <li><code>defer</code> for deferred execution</li>
    </ul>
    <br/><br/>


    <li>If Statements</li>
    <br/>
    <ul>
        <li>Basic <code>if</code> statement:</li>
<pre><code class="language-go line-numbers">if condition {
    // code to execute if condition is true
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">age := 18

if age >= 18 {
    fmt.Println("You are an adult")
}</code></pre>
        <br/>
        <li>Important notes:</li>
        <ul>
            <li>parentheses around the condition are optional (and discouraged)</li>
            <li>curly braces are required, even for single-line blocks</li>
            <li>opening brace must be on the same line as <code>if</code></li>
        </ul>
        <br/>
        <li>Invalid syntax:</li>
<pre><code class="language-go line-numbers">// âœ— ERROR - missing braces
if age >= 18
    fmt.Println("Adult")

// âœ— ERROR - brace on wrong line
if age >= 18
{
    fmt.Println("Adult")
}</code></pre>
    </ul>
    <br/><br/>


    <li>If-Else Statements</li>
    <br/>
    <ul>
        <li>Execute different code blocks based on condition:</li>
<pre><code class="language-go line-numbers">if condition {
    // code if true
} else {
    // code if false
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">temperature := 25

if temperature > 30 {
    fmt.Println("It's hot")
} else {
    fmt.Println("It's not too hot")
}</code></pre>
        <br/>
        <li>If-else-if chain:</li>
<pre><code class="language-go line-numbers">score := 85

if score >= 90 {
    fmt.Println("Grade: A")
} else if score >= 80 {
    fmt.Println("Grade: B")
} else if score >= 70 {
    fmt.Println("Grade: C")
} else if score >= 60 {
    fmt.Println("Grade: D")
} else {
    fmt.Println("Grade: F")
}</code></pre>
        <br/>
        <li>The <code>else</code> keyword must be on the same line as the closing brace of the previous block.</li>
    </ul>
    <br/><br/>


    <li>If With Initialization Statement</li>
    <br/>
    <ul>
        <li>Go allows a short statement before the condition:</li>
<pre><code class="language-go line-numbers">if statement; condition {
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">if age := getAge(); age >= 18 {
    fmt.Println("Adult, age:", age)
} else {
    fmt.Println("Minor, age:", age)
}
// age is not accessible here</code></pre>
        <br/>
        <li>The variable declared in the initialization is scoped to the <code>if</code> block.</li>
        <br/>
        <li>Common pattern with error checking:</li>
<pre><code class="language-go line-numbers">if err := doSomething(); err != nil {
    fmt.Println("Error:", err)
    return
}
// err is not accessible here</code></pre>
        <br/>
        <li>Another example:</li>
<pre><code class="language-go line-numbers">if value, ok := myMap[key]; ok {
    fmt.Println("Found:", value)
} else {
    fmt.Println("Key not found")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Switch Statements</li>
    <br/>
    <ul>
        <li>Switch provides multi-way branching based on value:</li>
<pre><code class="language-go line-numbers">switch variable {
    case value1:
        // code
    case value2:
        // code
    default:
        // code if no case matches
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">day := "Monday"

switch day {
    case "Monday":
        fmt.Println("Start of the work week")
    case "Friday":
        fmt.Println("End of the work week")
    case "Saturday", "Sunday":
        fmt.Println("Weekend!")
    default:
        fmt.Println("Midweek")
}</code></pre>
        <br/>
        <li>Key differences from other languages:</li>
        <ul>
            <li>no automatic fall-through (no <code>break</code> needed)</li>
            <li>cases don't need to be constants</li>
            <li>multiple values in one case (comma-separated)</li>
        </ul>
    </ul>
    <br/><br/>


    <li>Switch Without Expression</li>
    <br/>
    <ul>
        <li>Switch can work like an if-else chain:</li>
<pre><code class="language-go line-numbers">switch {
    case condition1:
        // code
    case condition2:
        // code
    default:
        // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">hour := 14

switch {
    case hour < 12:
        fmt.Println("Good morning")
    case hour < 18:
        fmt.Println("Good afternoon")
    default:
        fmt.Println("Good evening")
}</code></pre>
        <br/>
        <li>Often cleaner than long if-else chains.</li>
    </ul>
    <br/><br/>


    <li>Switch With Initialization</li>
    <br/>
    <ul>
        <li>Like <code>if</code>, switch can have an initialization statement:</li>
<pre><code class="language-go line-numbers">switch statement; expression {
case value1:
    // code
case value2:
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">switch num := getRandom(); num {
case 1, 2, 3:
    fmt.Println("Low number:", num)
case 4, 5, 6:
    fmt.Println("Medium number:", num)
default:
    fmt.Println("High number:", num)
}</code></pre>
        <br/>
        <li>The variable is scoped to the switch block.</li>
    </ul>
    <br/><br/>


    <li>Type Switch</li>
    <br/>
    <ul>
        <li>Switch can determine the type of an interface value:</li>
<pre><code class="language-go line-numbers">switch v := value.(type) {
case Type1:
    // v is of Type1
case Type2:
    // v is of Type2
default:
    // v is of unknown type
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

func main() {
    describe(42)      // Integer: 42
    describe("hello") // String: hello
    describe(true)    // Boolean: true
    describe(3.14)    // Unknown type: float64
}</code></pre>
        <br/>
        <li>The <code>type</code> keyword is special and only works in type switches.</li>
    </ul>
    <br/><br/>


    <li>Fallthrough in Switch</li>
    <br/>
    <ul>
        <li>Use <code>fallthrough</code> to explicitly continue to the next case:</li>
<pre><code class="language-go line-numbers">switch num := 2; num {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
    fallthrough
case 3:
    fmt.Println("Three")
default:
    fmt.Println("Other")
}
// Output:
// Two
// Three</code></pre>
        <br/>
        <li><code>fallthrough</code> must be the last statement in a case.</li>
        <br/>
        <li>It transfers control to the next case unconditionally (doesn't check the condition).</li>
    </ul>
    <br/><br/>


    <li>For Loop - Basic Form</li>
    <br/>
    <ul>
        <li>The <code>for</code> loop is Go's only looping construct:</li>
<pre><code class="language-go line-numbers">for initialization; condition; post {
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">for i := 0; i < 5; i++ {
    fmt.Println(i)
}
// Output: 0 1 2 3 4</code></pre>
        <br/>
        <li>Components:</li>
<table>
    <thead>
        <tr>
            <th>Component</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>initialization</code></td>
            <td>Executed once before the loop starts</td>
        </tr>
        <tr>
            <td><code>condition</code></td>
            <td>Evaluated before each iteration</td>
        </tr>
        <tr>
            <td><code>post</code></td>
            <td>Executed after each iteration</td>
        </tr>
    </tbody>
</table>
        <br/>
        <li>All three components are optional:</li>
<pre><code class="language-go line-numbers">i := 0
for ; i < 5; i++ {
    fmt.Println(i)
}</code></pre>
    </ul>
    <br/><br/>


    <li>For Loop - While Style</li>
    <br/>
    <ul>
        <li>Omit initialization and post to create a while-style loop:</li>
<pre><code class="language-go line-numbers">for condition {
    // code
}</code></pre>
        <br/>
        <li>Example:</li>
<pre><code class="language-go line-numbers">count := 0
for count < 5 {
    fmt.Println(count)
    count++
}</code></pre>
        <br/>
        <li>This is Go's equivalent of <code>while</code> in other languages.</li>
    </ul>
    <br/><br/>


    <li>Infinite Loop</li>
    <br/>
    <ul>
        <li>Omit all components for an infinite loop:</li>
<pre><code class="language-go line-numbers">for {
    // code runs forever
}</code></pre>
        <br/>
        <li>Example with break condition:</li>
<pre><code class="language-go line-numbers">count := 0
for {
    fmt.Println(count)
    count++
    if count >= 5 {
        break
    }
}
// Output: 0 1 2 3 4</code></pre>
        <br/>
        <li>Common in server applications:</li>
<pre><code class="language-go line-numbers">for {
    conn, err := listener.Accept()
    if err != nil {
        continue
    }
    go handleConnection(conn)
}</code></pre>
    </ul>
    <br/><br/>


    <li>Range-Based For Loop</li>
    <br/>
    <ul>
        <li>Use <code>range</code> to iterate over slices, arrays, maps, strings, and channels:</li>
<pre><code class="language-go line-numbers">for index, value := range collection {
    // code
}</code></pre>
        <br/>
        <li>Iterating over a slice:</li>
<pre><code class="language-go line-numbers">numbers := []int{10, 20, 30, 40, 50}

for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}</code></pre>
        <br/>
        <li>Iterating over a map:</li>
<pre><code class="language-go line-numbers">ages := map[string]int{
    "Alice": 25,
    "Bob":   30,
    "Charlie": 35,
}

for name, age := range ages {
    fmt.Printf("%s is %d years old\n", name, age)
}</code></pre>
        <br/>
        <li>Iterating over a string (returns runes):</li>
<pre><code class="language-go line-numbers">for index, char := range "Hello" {
    fmt.Printf("%d: %c\n", index, char)
}</code></pre>
        <br/>
        <li>Ignoring index or value with <code>_</code>:</li>
<pre><code class="language-go line-numbers">// Only value
for _, value := range numbers {
    fmt.Println(value)
}

// Only index
for index := range numbers {
    fmt.Println(index)
}

// Just iterate (no variables)
for range numbers {
    fmt.Println("Iterating...")
}</code></pre>
    </ul>
    <br/><br/>


    <li>Break Statement</li>
    <br/>
    <ul>
        <li>The <code>break</code> statement exits the innermost loop:</li>
<pre><code class="language-go line-numbers">for i := 0; i < 10; i++ {
    if i == 5 {
        break  // Exit loop when i is 5
    }
    fmt.Println(i)
}
// Output: 0 1 2 3 4</code></pre>
        <br/>
        <li>Break with nested loops (exits only the inner loop):</li>
<pre><code class="language-go line-numbers">for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if j == 1 {
            break  // Only breaks inner loop
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}</code></pre>
        <br/>
        <li>Break in switch statements:</li>
<pre><code class="language-go line-numbers">switch value {
case 1:
    fmt.Println("One")
    break  // Optional - cases don't fall through by default
case 2:
    fmt.Println("Two")
}</code></pre>
        <br/>
        <li>Note: <code>break</code> is implicit in switch cases unless <code>fallthrough</code> is used.</li>
    </ul>
    <br/><br/>


    <li>Continue Statement</li>
    <br/>
    <ul>
        <li>The <code>continue</code> statement skips the rest of the current iteration:</li>
<pre><code class="language-go line-numbers">for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // Skip even numbers
    }
    fmt.Println(i)
}
// Output: 1 3 5 7 9</code></pre>
        <br/>
        <li>Example with validation:</li>
<pre><code class="language-go line-numbers">numbers := []int{1, 2, -3, 4, -5, 6}

for _, num := range numbers {
    if num < 0 {
        continue  // Skip negative numbers
    }
    fmt.Println(num)
}
// Output: 1 2 4 6</code></pre>
        <br/>
        <li>Continue in nested loops (continues the innermost loop):</li>
<pre><code class="language-go line-numbers">for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if j == 1 {
            continue  // Skip to next j
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}</code></pre>
    </ul>
    <br/><br/>


    <li>Labels With Break and Continue</li>
    <br/>
    <ul>
        <li>Use labels to break or continue outer loops:</li>
<pre><code class="language-go line-numbers">OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break OuterLoop  // Break outer loop
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
// Output:
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0</code></pre>
        <br/>
        <li>Continue with labels:</li>
<pre><code class="language-go line-numbers">OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if j == 1 {
            continue OuterLoop  // Continue outer loop
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}</code></pre>
        <br/>
        <li>Labels must be <u>immediately</u> before a <code>for</code> statement.</li>
    </ul>
    <br/><br/>


    <li>Goto Statement</li>
    <br/>
    <ul>
        <li>The <code>goto</code> statement jumps to a labeled statement:</li>
<pre><code class="language-go line-numbers">func main() {
    i := 0

Loop:
    fmt.Println(i)
    i++

    if i < 5 {
        goto Loop
    }

    fmt.Println("Done")
}</code></pre>
        <br/>
        <li>Restrictions:</li>
        <ul>
            <li>cannot jump into a block from outside</li>
            <li>cannot jump over variable declarations</li>
            <li>label must be in the same function</li>
        </ul>
        <br/>
        <li>Valid use case - error handling cleanup:</li>
<pre><code class="language-go line-numbers">func process() error {
    if err := step1(); err != nil {
        goto cleanup
    }
    if err := step2(); err != nil {
        goto cleanup
    }
    if err := step3(); err != nil {
        goto cleanup
    }
    return nil

cleanup:
    // Cleanup code
    return err
}</code></pre>
        <br/>
        <li><code>goto</code> is rarely used in Go - prefer structured control flow.</li>
    </ul>
    <br/><br/>


    <li>Defer in Control Flow</li>
    <br/>
    <ul>
        <li>The <code>defer</code> statement schedules a function to run when the surrounding function returns:</li>
<pre><code class="language-go line-numbers">func readFile(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        return
    }
    defer file.Close()  // Always executes before function returns

    // Read file...
}</code></pre>
        <br/>
        <li>Multiple defers execute in LIFO order:</li>
<pre><code class="language-go line-numbers">func example() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
    fmt.Println("Main")
}
// Output:
// Main
// Third
// Second
// First</code></pre>
        <br/>
        <li>Defer with loops:</li>
<pre><code class="language-go line-numbers">func processFiles(files []string) {
    for _, filename := range files {
        file, err := os.Open(filename)
        if err != nil {
            continue
        }
        defer file.Close()  // All defers execute at function end!

        // Process file...
    }
    // All files closed here
}</code></pre>
        <br/>
        <li>Better pattern - use a closure:</li>
<pre><code class="language-go line-numbers">func processFiles(files []string) {
    for _, filename := range files {
        func() {
            file, err := os.Open(filename)
            if err != nil {
                return
            }
            defer file.Close()  // Closes at end of this iteration

            // Process file...
        }()
    }
}</code></pre>
    </ul>
    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
